<!DOCTYPE html><html lang="en"><head><title>Help for package BayesianFactorZoo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesianFactorZoo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesianFM'><p>Bayesian Fama-MacBeth</p></a></li>
<li><a href='#BayesianSDF'><p>Bayesian estimation of Linear SDF (B-SDF)</p></a></li>
<li><a href='#BFactor_zoo_example'>
<p>Simulated Example Dataset <b>'BFactor_zoo_example'</b></p></a></li>
<li><a href='#continuous_ss_sdf'><p>SDF model selection with continuous spike-and-slab prior</p></a></li>
<li><a href='#continuous_ss_sdf_v2'><p>SDF model selection with continuous spike-and-slab prior (tradable factors are treated as test assets)</p></a></li>
<li><a href='#dirac_ss_sdf_pvalue'><p>Hypothesis testing for risk prices (Bayesian p-values) with Dirac spike-and-slab prior</p></a></li>
<li><a href='#psi_to_priorSR'><p>Mapping <code class="reqn">\psi</code> (<code>psi0</code>) to the prior Sharpe ratio of factors (<code>priorSR</code>), and vice versa.</p></a></li>
<li><a href='#SDF_gmm'><p>GMM Estimates of Factors' Risk Prices under the Linear SDF Framework</p></a></li>
<li><a href='#Two_Pass_Regression'><p>Fama MacBeth Two-Pass Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Solutions for the Factor Zoo: We Just Ran Two
Quadrillion Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains the functions to use the econometric methods in the paper Bryzgalova, Huang, and Julliard (2023) &lt;<a href="https://doi.org/10.1111%2Fjofi.13197">doi:10.1111/jofi.13197</a>&gt;. In this package, we provide a novel Bayesian framework for analyzing linear asset pricing models: simple, robust, and applicable to high-dimensional problems. For a stand-alone model, we provide functions including BayesianFM() and BayesianSDF() to deliver reliable price of risk estimates for both tradable and nontradable factors. For competing factors and possibly nonnested models, we provide functions including continuous_ss_sdf(), continuous_ss_sdf_v2(), and dirac_ss_sdf_pvalue() to analyze high-dimensional models. If you use this package, please cite the paper. We are thankful to Yunan Ding and Jingtong Zhang for their research assistance. Any errors or omissions are the responsibility of the authors.</td>
</tr>
<tr>
<td>Imports:</td>
<td>MCMCpack, reshape2, MASS, timeSeries, coda, mvtnorm,
matrixcalc, ggplot2, nse, Rdpack, stats, utils, Matrix</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-04 08:54:47 UTC; jiantaohuang</td>
</tr>
<tr>
<td>Author:</td>
<td>Svetlana Bryzgalova [aut],
  Jiantao Huang [cre],
  Christian Julliard [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jiantao Huang &lt;huangjt@hku.hk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-04 09:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesianFM'>Bayesian Fama-MacBeth</h2><span id='topic+BayesianFM'></span>

<h3>Description</h3>

<p>This function provides the Bayesian Fama-MacBeth regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesianFM(f, R, sim_length)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesianFM_+3A_f">f</code></td>
<td>
<p>A matrix of factors with dimension <code class="reqn">t \times k</code>, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods;</p>
</td></tr>
<tr><td><code id="BayesianFM_+3A_r">R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets;</p>
</td></tr>
<tr><td><code id="BayesianFM_+3A_sim_length">sim_length</code></td>
<td>
<p>The length of MCMCs;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>BayesianFM</code> is similar to another twin function in this package, <code>BayesianSDF</code>,
except that we estimate factors' risk premia rather than risk prices in this function.
Unlike <code>BayesianSDF</code>, we use factor loadings, <code class="reqn">\beta_f</code>, instead of covariance exposures, <code class="reqn">C_f</code>,
in the Fama-MacBeth regression. In particular, after we obtain the posterior draws of <code class="reqn">\mu_{Y}</code> and <code class="reqn">\Sigma_{Y}</code>
(details can be found in the section introducing <code>BayesianSDF</code> function),
we calculate <code class="reqn">\beta_f</code> as follows: <code class="reqn">\beta_f = C_f \Sigma_f^{-1}</code>, and <code class="reqn">\beta = (1_N, \beta_f)</code>.
</p>
<p><strong>Bayesian Fama-MacBeth (BFM)</strong>
</p>
<p>The posterior distribution of <code class="reqn">\lambda</code> conditional on <code class="reqn">\mu_{Y}</code>, <code class="reqn">\Sigma_{Y}</code>, and the data, is a Dirac distribution at
<code class="reqn">(\beta^\top \beta)^{-1} \beta^\top \mu_R</code>.
</p>
<p><strong>Bayesian Fama-MacBeth GLS (BFM-GLS)</strong>
</p>
<p>The posterior distribution of <code class="reqn">\lambda</code> conditional on <code class="reqn">\mu_{Y}</code>, <code class="reqn">\Sigma_{Y}</code>, and the data, is a Dirac distribution at
<code class="reqn"> (\beta^\top \Sigma_R^{-1} \beta)^{-1} \beta^\top \Sigma_R^{-1} \mu_R  </code>.
</p>


<h3>Value</h3>

<p>The return of <code>BayesianFM</code> is a list of the following elements:
</p>

<ul>
<li> <p><code>lambda_ols_path</code>: A <code>sim_length</code><code class="reqn">\times (k+1)</code> matrix of OLS risk premia estimates (Each row represents a draw.
Note that the first column is <code class="reqn">\lambda_c</code> corresponding to the constant term.
The next <code class="reqn">k</code> columns are the risk premia estimates of the <code class="reqn">k</code> factors);
</p>
</li>
<li> <p><code>lambda_gls_path</code>: A <code>sim_length</code><code class="reqn">\times (k+1)</code> matrix of the risk premia estimates <code class="reqn">\lambda</code> (GLS);
</p>
</li>
<li> <p><code>R2_ols_path</code>: A <code>sim_length</code><code class="reqn">\times 1</code> matrix of the <code class="reqn">R^2_{OLS}</code>;
</p>
</li>
<li> <p><code>R2_gls_path</code>: A <code>sim_length</code><code class="reqn">\times 1</code> matrix of the <code class="reqn">R^2_{GLS}</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## &lt;--------------------------------------------------------------------------------&gt;
##   Example: Bayesian Fama-MacBeth
## &lt;--------------------------------------------------------------------------------&gt;

library(reshape2)
library(ggplot2)

# Load Data
data("BFactor_zoo_example")
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf

## &lt;-------------------Case 1: strong factor----------------------------------------&gt;

# the Frequentist Fama-MacBeth
# sim_f: simulated factor, sim_R: simulated return
# sim_f is the useful (i.e., strong) factor
results.fm &lt;- Two_Pass_Regression(sim_f, sim_R)

# the Bayesian Fama-MacBeth with 10000 simulations
results.bfm &lt;- BayesianFM(sim_f, sim_R, 2000)

# Note that the first element correspond to lambda of the constant term
# So we choose k=2 to get lambda of the strong factor
k &lt;- 2
m1 &lt;- results.fm$lambda[k]
sd1 &lt;- sqrt(results.fm$cov_lambda[k,k])

bfm&lt;-results.bfm$lambda_ols_path[1001:2000,k]
fm&lt;-rnorm(20000,mean = m1, sd=sd1)
data&lt;-data.frame(cbind(fm, bfm))
colnames(data)&lt;-c("Frequentist FM", "Bayesian FM")
data.long&lt;-melt(data)

p &lt;- ggplot(aes(x=value, colour=variable, linetype=variable), data=data.long)
p+
 stat_density(aes(x=value, colour=variable),
              geom="line",position="identity", size = 2, adjust=1) +
 geom_vline(xintercept = lambda_ols[2], linetype="dotted", color = "#8c8c8c", size=1.5)+
 guides(colour = guide_legend(override.aes=list(size=2), title.position = "top",
 title.hjust = 0.5, nrow=1,byrow=TRUE))+
 theme_bw()+
 labs(color=element_blank()) +
 labs(linetype=element_blank()) +
 theme(legend.key.width=unit(4,"line")) +
 theme(legend.position="bottom")+
 theme(text = element_text(size = 26))+
 xlab(bquote("Risk premium ("~lambda[strong]~")")) +
 ylab("Density" )


## &lt;-------------------Case 2: useless factor---------------------------------------&gt;

# uf is the useless factor
# the Frequentist Fama-MacBeth
results.fm &lt;- Two_Pass_Regression(uf, sim_R)

# the Bayesian Fama-MacBeth with 10000 simulations
results.bfm &lt;- BayesianFM(uf, sim_R, 2000)

# Note that the first element correspond to lambda of the constant term
# So we choose k=2 to get lambda of the useless factor
k &lt;- 2
m1 &lt;- results.fm$lambda[k]
sd1 &lt;- sqrt(results.fm$cov_lambda[k,k])


bfm&lt;-results.bfm$lambda_ols_path[1001:2000,k]
fm&lt;-rnorm(20000,mean = m1, sd=sd1)
data&lt;-data.frame(cbind(fm, bfm))
colnames(data)&lt;-c("Frequentist FM", "Bayesian FM")
data.long&lt;-melt(data)

p &lt;- ggplot(aes(x=value, colour=variable, linetype=variable), data=data.long)
p+
 stat_density(aes(x=value, colour=variable),
              geom="line",position="identity", size = 2, adjust=1) +
 geom_vline(xintercept = lambda_ols[2], linetype="dotted", color = "#8c8c8c", size=1.5)+
 guides(colour = guide_legend(override.aes=list(size=2),
 title.position = "top", title.hjust = 0.5, nrow=1,byrow=TRUE))+
 theme_bw()+
 labs(color=element_blank()) +
 labs(linetype=element_blank()) +
 theme(legend.key.width=unit(4,"line")) +
 theme(legend.position="bottom")+
 theme(text = element_text(size = 26))+
 xlab(bquote("Risk premium ("~lambda[strong]~")")) +
 ylab("Density" )



</code></pre>

<hr>
<h2 id='BayesianSDF'>Bayesian estimation of Linear SDF (B-SDF)</h2><span id='topic+BayesianSDF'></span>

<h3>Description</h3>

<p>This function provides the Bayesian estimates of factors' risk prices.
The estimates with the flat prior are given by Definitions 1 and 2 in
Bryzgalova et al. (2023).
The estimates with the normal prior are used in Table I (see the footnote of Table I).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesianSDF(
  f,
  R,
  sim_length = 10000,
  intercept = TRUE,
  type = "OLS",
  prior = "Flat",
  psi0 = 5,
  d = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesianSDF_+3A_f">f</code></td>
<td>
<p>A <code class="reqn">t \times k</code> matrix of factors, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods</p>
</td></tr>
<tr><td><code id="BayesianSDF_+3A_r">R</code></td>
<td>
<p>A <code class="reqn">t \times N</code> matrix of test assets, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets</p>
</td></tr>
<tr><td><code id="BayesianSDF_+3A_sim_length">sim_length</code></td>
<td>
<p>The length of MCMCs</p>
</td></tr>
<tr><td><code id="BayesianSDF_+3A_intercept">intercept</code></td>
<td>
<p>If <code>intercept = TRUE</code> (<code>intercept = FALSE</code>), the model includes (does not include) the intercept.
The default is <code>intercept = TRUE</code></p>
</td></tr>
<tr><td><code id="BayesianSDF_+3A_type">type</code></td>
<td>
<p>If <code>type = 'OLS'</code> (<code>type = 'GLS'</code>), the function returns Bayesian OLS (GLS) estimates of risk prices <code class="reqn">\lambda</code>. The default is 'OLS'</p>
</td></tr>
<tr><td><code id="BayesianSDF_+3A_prior">prior</code></td>
<td>
<p>If <code>type = 'Flat'</code> (<code>type = 'Normal'</code>), the function executes the Bayesian estimation with the flat prior (normal prior).
The default is 'Flat'</p>
</td></tr>
<tr><td><code id="BayesianSDF_+3A_psi0">psi0</code></td>
<td>
<p>The hyper-parameter of the prior distribution of risk prices <code class="reqn">\lambda</code> used in the normal prior (see <b>Details</b>).
This parameter is needed only when the user chooses  the normal prior. The default value is 5</p>
</td></tr>
<tr><td><code id="BayesianSDF_+3A_d">d</code></td>
<td>
<p>The hyper-parameter of the prior distribution of risk prices <code class="reqn">\lambda</code> used in the normal prior (see <b>Details</b>). The default value is 0.5</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Intercept</strong>
</p>
<p>Consider the cross-sectional step. If one includes the intercept, the model is
</p>
<p style="text-align: center;"><code class="reqn">\mu_R = \lambda_c 1_N + C_f \lambda_f = C \lambda,</code>
</p>

<p>where <code class="reqn">C = (1_N, C_f)</code> and <code class="reqn">\lambda^\top = (\lambda_c^\top, \lambda_f^\top)^\top </code>.
If one doesn't include the intercept, the model is
</p>
<p style="text-align: center;"><code class="reqn">\mu_R = C_f \lambda_f = C \lambda,</code>
</p>

<p>where <code class="reqn">C = C_f</code> and <code class="reqn">\lambda = \lambda_f</code>.
</p>
<p><strong>Bayesian Estimation</strong>
</p>
<p>Let <code class="reqn">Y_t = f_t \cup R_t</code>. Conditional on the data <code class="reqn">Y = \{Y_t\}_{t=1}^T</code>, we can draw <code class="reqn">\mu_{Y}</code> and <code class="reqn">\Sigma_{Y}</code> from the Normal-inverse-Wishart system
</p>
<p style="text-align: center;"><code class="reqn">\mu_Y | \Sigma_Y, Y \sim N (\hat{\mu}_Y , \Sigma_Y / T) , </code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma_Y | Y \sim W^{-1} (T-1, \Sigma_{t=1}^{T} (Y_t - \hat{\mu}_Y ) ( Y_t - \hat{\mu}_Y )^\top   ) , </code>
</p>

<p>where <code class="reqn">W^{-1}</code> is the inverse-Wishart distribution.
We do not standardize <code class="reqn">Y_t</code> in the time-series regression.
In the empirical implementation, after obtaining posterior draws for <code class="reqn">\mu_{Y}</code> and <code class="reqn">\Sigma_{Y}</code>,
we calculate <code class="reqn">\mu_R</code> and <code class="reqn">C_f</code> as the standardized expected returns of test assets and correlation
between test assets and factors. It follows that <code class="reqn">C</code> is a matrix containing a vector of ones and <code class="reqn">C_f</code>.
</p>
<p>The prior distribution of risk prices is either the flat prior or the normal prior.
</p>
<p>With <code>prior = 'Flat'</code> and <code>type = 'OLS'</code>, for each draw, the risk price estimate is
</p>
<p style="text-align: center;"><code class="reqn">\hat{\lambda} = (C^{\top} C)^{-1}C^{T} \mu_{R}  .</code>
</p>

<p>With <code>prior = 'Flat'</code> and <code>type = 'GLS'</code>, for each draw, the risk price estimate is
</p>
<p style="text-align: center;"><code class="reqn">\hat{\lambda} = (C^{\top} \Sigma^{-1}_{R} C)^{-1} C^{\top} \Sigma^{-1}_{R} \mu_{R} </code>
</p>

<p>If one chooses <code>prior = 'Normal'</code>, the prior of factor <code class="reqn">j</code>'s risk price is
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_j | \sigma^2 \sim N(0, \sigma^2 \psi \tilde{\rho}_j^\top \tilde{\rho}_j  T^d  ) ,</code>
</p>

<p>where <code class="reqn"> \tilde{\rho}_j = \rho_j - (\frac{1}{N} \Sigma_{i=1}^{N} \rho_{j,i}  ) \times 1_N </code> is the cross-sectionally
demeaned vector of factor <code class="reqn">j</code>'s correlations with asset returns. Equivalently,
</p>
<p style="text-align: center;"><code class="reqn"> \lambda | \sigma^2 \sim N(0, \sigma^2 D^{-1}) ,</code>
</p>

<p style="text-align: center;"><code class="reqn">D = diag \{ (\psi \tilde{\rho}_1^\top \tilde{\rho}_1  T^d)^{-1}, ..., (\psi \tilde{\rho}_k^\top \tilde{\rho}_k  T^d)^{-1} \} \ \ without \ intercept;</code>
</p>

<p style="text-align: center;"><code class="reqn">D = diag \{ c, (\psi \tilde{\rho}_1^\top \tilde{\rho}_1  T^d)^{-1}, ..., (\psi \tilde{\rho}_k^\top \tilde{\rho}_k  T^d)^{-1} \} \ \ with \ intercept;</code>
</p>

<p>where <code class="reqn">c</code> is a small positive number corresponding to the common cross-sectional intercept (<code class="reqn">\lambda_c</code>).
Default values for <code class="reqn">\psi</code> (<code>psi0</code>) and <code class="reqn">d</code> (<code>d</code>) are 5 and 0.5, respectively.
</p>
<p>With <code>prior = 'Normal'</code> and <code>type = 'OLS'</code>, for each draw, the risk price estimate is
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\lambda} = ( C^{\top} C +D )^{-1} C^{\top} \mu_R .</code>
</p>

<p>With <code>prior = 'Normal'</code> and <code>type = 'GLS'</code>, for each draw, the risk price estimate is
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\lambda} = ( C^{\top} \Sigma_R^{-1} C +D )^{-1} C^{\top} \Sigma_R^{-1} \mu_R .</code>
</p>



<h3>Value</h3>

<p>The return of <code>BayesianSDF</code> is a list that contains the following elements:
</p>

<ul>
<li> <p><code>lambda_path</code>: A <code>sim_length</code><code class="reqn">\times (k+1)</code> matrix if the intercept is included.
NOTE: the first column <code class="reqn">\lambda_c</code> corresponds to the intercept. The next <code class="reqn">k</code> columns (i.e., the 2th &ndash; <code class="reqn">(k+1)</code>-th columns)
are the risk prices of <code class="reqn">k</code> factors. If the intercept is excluded, the dimension of <code>lambda_path</code> is <code>sim_length</code><code class="reqn">\times k</code>.
</p>
</li>
<li> <p><code>R2_path</code>: A <code>sim_length</code><code class="reqn">\times 1</code> matrix, which contains the posterior draws of the OLS or GLS <code class="reqn">R^2</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
&ldquo;Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.&rdquo;
<em>Journal of Finance</em>, <b>78</b>(1), 487&ndash;557.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## &lt;--------------------------------------------------------------------------------&gt;
## Example: Bayesian estimates of risk prices and R2
## This example is from the paper (see Section III. Simulation)
## &lt;--------------------------------------------------------------------------------&gt;

library(reshape2)
library(ggplot2)

# Load the example data
data("BFactor_zoo_example")
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf
W_ols &lt;- BFactor_zoo_example$W_ols

cat("Load the simulated example \n")

cat("Cross-section: Fama-French 25 size and value portfolios \n")
cat("True pricing factor in simulations: HML \n")
cat("Pseudo-true cross-sectional R-squared:", R2.ols.true, "\n")
cat("Pseudo-true (monthly) risk price:", lambda_ols[2], "\n")

cat("----------------------------- Bayesian SDF ----------------------------\n")
cat("------------------------ See definitions 1 and 2 ----------------------\n")

cat("--------------------- Bayesian SDF: Strong factor ---------------------\n")

sim_result &lt;- SDF_gmm(sim_R, sim_f, W_ols)   # GMM estimation
# sim_result$lambda_gmm
# sqrt(sim_result$Avar_hat[2,2])
# sim_result$R2_adj

## Now estimate the model using Bayesian method
two_step &lt;- BayesianSDF(sim_f, sim_R, sim_length =  2000, psi0 = 5, d = 0.5)
# apply(X = two_step$lambda_path, FUN = quantile, MARGIN = 2, probs = c(0.05, 0.95))
# quantile(two_step$R2_path, probs = c(0.05, 0.5, 0.95))

# Note that the first element correspond to lambda of the constant term
# So we choose k=2 to get lambda of the strong factor
k &lt;- 2
m1 &lt;- sim_result$lambda_gmm[k]
sd1 &lt;- sqrt(sim_result$Avar_hat[k,k])

bfm&lt;-two_step$lambda_path[1001:2000, k]
fm&lt;-rnorm(5000,mean = m1, sd=sd1)
data&lt;-data.frame(cbind(fm, bfm))
colnames(data)&lt;-c("GMM-OLS", "BSDF-OLS")
data.long&lt;-melt(data)

#
### Figure 1(c)
#
p &lt;- ggplot(aes(x=value, colour=variable, linetype=variable), data=data.long)
p+
 stat_density(aes(x=value, colour=variable),
              geom="line",position="identity", size = 2, adjust=1) +
 geom_vline(xintercept = lambda_ols[2], linetype="dotted", color = "#8c8c8c", size=1.5)+
 guides(colour = guide_legend(override.aes=list(size=2), title.position = "top",
 title.hjust = 0.5, nrow=1,byrow=TRUE))+
 theme_bw()+
 labs(color=element_blank()) +
 labs(linetype=element_blank()) +
 theme(legend.key.width=unit(4,"line")) +
 theme(legend.position="bottom")+
 theme(text = element_text(size = 26))+
 xlab(bquote("Risk price ("~lambda[strong]~")")) +
 ylab("Density" )


cat("--------------------- Bayesian SDF: Useless factor --------------------\n")

sim_result &lt;- SDF_gmm(sim_R, uf, W_ols)
# sim_result$lambda_gmm
# sqrt(sim_result$Avar_hat[2,2])
# sim_result$R2_adj

two_step &lt;- BayesianSDF(uf, sim_R, sim_length =  2000, psi0 = 5, d = 0.5)
#apply(X = two_step$lambda_path, FUN = quantile, MARGIN = 2, probs = c(0.05, 0.95))


## Posterior (Asymptotic) Distribution of lambda
k &lt;- 2
m1 &lt;- sim_result$lambda[k]
sd1 &lt;- sqrt(sim_result$Avar_hat[k,k])

bfm&lt;-two_step$lambda_path[1001:2000, k]
fm&lt;-rnorm(5000,mean = m1, sd=sd1)
data&lt;-data.frame(cbind(fm, bfm))
colnames(data)&lt;-c("GMM-OLS", "BSDF-OLS")
data.long&lt;-melt(data)

#
### Figure 1(a)
#
p &lt;- ggplot(aes(x=value, colour=variable, linetype=variable), data=data.long)
p+
 stat_density(aes(x=value, colour=variable),
              geom="line",position="identity", size = 2, adjust=2) +
 geom_vline(xintercept = 0, linetype="dotted", color = "#8c8c8c", size=1.5)+
 guides(colour = guide_legend(override.aes=list(size=2),
 title.position = "top", title.hjust = 0.5, nrow=1,byrow=TRUE))+
 theme_bw()+
 labs(color=element_blank()) +
 labs(linetype=element_blank()) +
 theme(legend.key.width=unit(4,"line")) +
 theme(legend.position="bottom")+
 theme(text = element_text(size = 26))+
 xlab(bquote("Risk price ("~lambda[spurious]~")")) +
 ylab("Density" )



</code></pre>

<hr>
<h2 id='BFactor_zoo_example'>
Simulated Example Dataset <b>'BFactor_zoo_example'</b>
</h2><span id='topic+BFactor_zoo_example'></span>

<h3>Description</h3>

<p>A simulated dataset used in Figure 1 of Bryzgalova et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BFactor_zoo_example")</code></pre>


<h3>Format</h3>

<p>A list consisting of the following variables:
</p>

<dl>
<dt>HML</dt><dd><p>High-minus-low value factor, from Ken French Website</p>
</dd>
<dt>lambda_ols</dt><dd><p>Hypothetical true risk prices of factors in simulations</p>
</dd>
<dt>R2.ols.true</dt><dd><p>Hypothetical true OLS R-squared in simulations</p>
</dd>
<dt>sim_f</dt><dd><p>Simulated strong factor</p>
</dd>
<dt>sim_R</dt><dd><p>Simulated test asset returns</p>
</dd>
<dt>uf</dt><dd><p>Simulated weak/unspanned factor</p>
</dd>
<dt>W_ols</dt><dd><p>Weighting matrix used in GMM OLS estimations</p>
</dd>
</dl>



<h3>Source</h3>

<p>Section III in Bryzgalova et al. (2023).
</p>


<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
&ldquo;Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.&rdquo;
<em>Journal of Finance</em>, <b>78</b>(1), 487&ndash;557.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BFactor_zoo_example)
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf
W_ols &lt;- BFactor_zoo_example$W_ols

cat("Load the simulated example \n")
cat("Cross-section: Fama-French 25 size and value portfolios \n")
cat("True pricing factor in simulations: HML \n")
cat("Misspecified model with pseudo-true R-squared:", R2.ols.true, "\n")
cat("Pseudo-true (monthly) risk price:", lambda_ols[2], "\n")
</code></pre>

<hr>
<h2 id='continuous_ss_sdf'>SDF model selection with continuous spike-and-slab prior</h2><span id='topic+continuous_ss_sdf'></span>

<h3>Description</h3>

<p>This function provides the SDF model selection procedure using the continuous spike-and-slab prior.
See Propositions 3 and 4 in Bryzgalova et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous_ss_sdf(
  f,
  R,
  sim_length,
  psi0 = 1,
  r = 0.001,
  aw = 1,
  bw = 1,
  type = "OLS",
  intercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continuous_ss_sdf_+3A_f">f</code></td>
<td>
<p>A matrix of factors with dimension <code class="reqn">t \times k</code>, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods;</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_r">R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets;</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_sim_length">sim_length</code></td>
<td>
<p>The length of monte-carlo simulations;</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_psi0">psi0</code></td>
<td>
<p>The hyper-parameter in the prior distribution of risk prices (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_r">r</code></td>
<td>
<p>The hyper-parameter related to the prior of risk prices (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_aw">aw</code></td>
<td>
<p>The hyper-parameter related to the prior of <code class="reqn">\gamma</code> (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_bw">bw</code></td>
<td>
<p>The hyper-parameter related to the prior of <code class="reqn">\gamma</code> (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_type">type</code></td>
<td>
<p>If <code>type = 'OLS'</code> (<code>type = 'GLS'</code>), the function returns Bayesian OLS (GLS) estimates of risk prices. The default is 'OLS'.</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_+3A_intercept">intercept</code></td>
<td>
<p>If <code>intercept = TRUE</code> (<code>intercept = FALSE</code>), we include (exclude) the common intercept in the cross-sectional regression. The default is <code>intercept = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To model the variable selection procedure, we introduce a vector of binary latent variables <code class="reqn">\gamma^\top = (\gamma_0,\gamma_1,...,\gamma_K)</code>,
where <code class="reqn">\gamma_j \in \{0,1\} </code>. When <code class="reqn">\gamma_j = 1</code>, factor <code class="reqn">j</code> (with associated loadings <code class="reqn">C_j</code>) should be included
in the model and vice verse.
</p>
<p>The continuous spike-and-slab prior of risk prices <code class="reqn">\lambda</code> is
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_j | \gamma_j, \sigma^2 \sim N (0, r(\gamma_j) \psi_j \sigma^2  ) .</code>
</p>

<p>When the factor <code class="reqn">j</code> is included, we have <code class="reqn"> r(\gamma_j = 1)=1 </code>.
When the factor is excluded from the model, <code class="reqn"> r(\gamma_j = 0) =r \ll 1 </code>.
Hence, the Dirac &quot;spike&quot; is replaced by a Gaussian spike, which is extremely concentrated at zero
(the default value for <code class="reqn">r</code> is 0.001).
If <code>intercept = TRUE</code>, we choose <code class="reqn"> \psi_j =  \psi \tilde{\rho}_j^\top \tilde{\rho}_j  </code>,
where <code class="reqn"> \tilde{\rho}_j = \rho_j - (\frac{1}{N} \Sigma_{i=1}^{N} \rho_{j,i}  ) \times 1_N </code>
is the cross-sectionally demeaned vector of factor <code class="reqn">j</code>'s correlations with asset returns.
Instead, if <code>intercept = FALSE</code>, we choose <code class="reqn"> \psi_j =  \psi \rho_j^\top \rho_j  </code>.
In the codes, <code class="reqn">\psi</code> is equal to the value of <code>psi0</code>.
</p>
<p>The prior <code class="reqn">\pi (\omega)</code> encoded the belief about the sparsity of the true model using the prior distribution
<code class="reqn">\pi (\gamma_j = 1 | \omega_j) = \omega_j </code>. Following the literature on the variable selection, we set
</p>
<p style="text-align: center;"><code class="reqn"> \pi (\gamma_j = 1 | \omega_j) = \omega_j,  \ \ \omega_j \sim Beta(a_\omega, b_\omega) . </code>
</p>

<p>Different hyperparameters <code class="reqn">a_\omega</code> and <code class="reqn">b_\omega</code> determine whether one a priori favors more parsimonious models or not.
We choose <code class="reqn">a_\omega = 1</code> (<code>aw</code>) and <code class="reqn">b_\omega=1</code> (<code>bw</code>) as the default values.
</p>
<p>For each posterior draw of factors' risk prices <code class="reqn">\lambda^{(j)}_f</code>, we can define the SDF as
<code class="reqn">m^{(j)}_t = 1 - (f_t - \mu_f)^\top \lambda^{(j)}_f</code>.The Bayesian model averaging of the SDF (BMA-SDF)
over <code class="reqn">J</code> draws is
</p>
<p style="text-align: center;"><code class="reqn">m^{bma}_t = \frac{1}{J}  \sum^J_{j=1} m^{(j)}_t.</code>
</p>



<h3>Value</h3>

<p>The return of <code>continuous_ss_sdf</code> is a list of the following elements:
</p>

<ul>
<li> <p><code>gamma_path</code>: A <code>sim_length</code><code class="reqn">\times k</code> matrix of the posterior draws of <code class="reqn">\gamma</code>. Each row represents
a draw. If <code class="reqn">\gamma_j = 1</code> in one draw, factor <code class="reqn">j</code> is included in the model in this draw and vice verse.
</p>
</li>
<li> <p><code>lambda_path</code>: A <code>sim_length</code><code class="reqn">\times (k+1)</code> matrix of the risk prices <code class="reqn">\lambda</code> if <code>intercept = TRUE</code>. Each row represents
a draw. Note that the first column is <code class="reqn">\lambda_c</code> corresponding to the constant term. The next <code class="reqn">k</code> columns (i.e., the 2-th &ndash; <code class="reqn">(k+1)</code>-th columns)
are the risk prices of the <code class="reqn">k</code> factors. If <code>intercept = FALSE</code>, <code>lambda_path</code> is a <code>sim_length</code><code class="reqn">\times k</code> matrix of the risk prices,
without the estimates of <code class="reqn">\lambda_c</code>.
</p>
</li>
<li> <p><code>sdf_path</code>: A <code>sim_length</code><code class="reqn">\times t</code> matrix of posterior draws of SDFs. Each row represents a draw.
</p>
</li>
<li> <p><code>bma_sdf</code>: BMA-SDF.
</p>
</li></ul>



<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
&ldquo;Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.&rdquo;
<em>Journal of Finance</em>, <b>78</b>(1), 487&ndash;557.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load the example data
data("BFactor_zoo_example")
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf

## sim_f: simulated strong factor
## uf: simulated useless factor

psi_hat &lt;- psi_to_priorSR(sim_R, cbind(sim_f,uf), priorSR=0.1)
shrinkage &lt;- continuous_ss_sdf(cbind(sim_f,uf), sim_R, 5000, psi0=psi_hat, r=0.001, aw=1, bw=1)
cat("Null hypothesis: lambda =", 0, "for each factor", "\n")
cat("Posterior probabilities of rejecting the above null hypotheses are:",
    colMeans(shrinkage$gamma_path), "\n")

## We also have the posterior draws of SDF: m(t) = 1 - lambda_g %*% (f(t) - mu_f)
sdf_path &lt;- shrinkage$sdf_path

## We also provide the Bayesian model averaging of the SDF (BMA-SDF)
bma_sdf &lt;- shrinkage$bma_sdf

</code></pre>

<hr>
<h2 id='continuous_ss_sdf_v2'>SDF model selection with continuous spike-and-slab prior (tradable factors are treated as test assets)</h2><span id='topic+continuous_ss_sdf_v2'></span>

<h3>Description</h3>

<p>This function provides the SDF model selection procedure using the continuous spike-and-slab prior.
See Propositions 3 and 4 in Bryzgalova et al. (2023).
Unlike <code>continuous_ss_sdf</code>, tradable factors are treated as test assets in this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous_ss_sdf_v2(
  f1,
  f2,
  R,
  sim_length,
  psi0 = 1,
  r = 0.001,
  aw = 1,
  bw = 1,
  type = "OLS",
  intercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continuous_ss_sdf_v2_+3A_f1">f1</code></td>
<td>
<p>A matrix of nontradable factors with dimension <code class="reqn">t \times k_1</code>, where <code class="reqn">k_1</code> is the number of nontradable factors
and <code class="reqn">t</code> is the number of periods.</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_f2">f2</code></td>
<td>
<p>A matrix of tradable factors with dimension <code class="reqn">t \times k_2</code>, where <code class="reqn">k_2</code> is the number of tradable factors
and <code class="reqn">t</code> is the number of periods.</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_r">R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets (<b><code>R</code> should NOT contain tradable factors <code>f2</code></b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_sim_length">sim_length</code></td>
<td>
<p>The length of monte-carlo simulations;</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_psi0">psi0</code></td>
<td>
<p>The hyper-parameter in the prior distribution of risk prices (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_r">r</code></td>
<td>
<p>The hyper-parameter related to the prior of risk prices (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_aw">aw</code></td>
<td>
<p>The hyper-parameter related to the prior of <code class="reqn">\gamma</code> (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_bw">bw</code></td>
<td>
<p>The hyper-parameter related to the prior of <code class="reqn">\gamma</code> (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_type">type</code></td>
<td>
<p>If <code>type = 'OLS'</code> (<code>type = 'GLS'</code>), the function returns Bayesian OLS (GLS) estimates of risk prices. The default is 'OLS'.</p>
</td></tr>
<tr><td><code id="continuous_ss_sdf_v2_+3A_intercept">intercept</code></td>
<td>
<p>If <code>intercept = TRUE</code> (<code>intercept = FALSE</code>), we include (exclude) the common intercept in the cross-sectional regression. The default is <code>intercept = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the description in the twin function <code>continuous_ss_sdf</code>.
</p>


<h3>Value</h3>

<p>The return of <code>continuous_ss_sdf_v2</code> is a list of the following elements:
</p>

<ul>
<li> <p><code>gamma_path</code>: A <code>sim_length</code><code class="reqn">\times k</code> matrix of the posterior draws of <code class="reqn">\gamma</code> (<code class="reqn">k = k_1 + k_2</code>). Each row represents
a draw. If <code class="reqn">\gamma_j = 1</code> in one draw, factor <code class="reqn">j</code> is included in the model in this draw and vice verse.
</p>
</li>
<li> <p><code>lambda_path</code>: A <code>sim_length</code><code class="reqn">\times (k+1)</code> matrix of the risk prices <code class="reqn">\lambda</code> if <code>intercept = TRUE</code>. Each row represents
a draw. Note that the first column is <code class="reqn">\lambda_c</code> corresponding to the constant term. The next <code class="reqn">k</code> columns (i.e., the 2-th &ndash; <code class="reqn">(k+1)</code>-th columns)
are the risk prices of the <code class="reqn">k</code> factors. If <code>intercept = FALSE</code>, <code>lambda_path</code> is a <code>sim_length</code><code class="reqn">\times k</code> matrix of the risk prices,
without the estimates of <code class="reqn">\lambda_c</code>.
</p>
</li>
<li> <p><code>sdf_path</code>: A <code>sim_length</code><code class="reqn">\times t</code> matrix of posterior draws of SDFs. Each row represents a draw.
</p>
</li>
<li> <p><code>bma_sdf</code>: BMA-SDF.
</p>
</li></ul>



<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
&ldquo;Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.&rdquo;
<em>Journal of Finance</em>, <b>78</b>(1), 487&ndash;557.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(timeSeries)

## Load the example data
data("BFactor_zoo_example")
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf

## sim_f: simulated strong factor
## uf: simulated useless factor

psi_hat &lt;- psi_to_priorSR(sim_R, cbind(sim_f,uf,sim_R[,1]), priorSR=0.1)

## We include the first test asset, sim_R[,1], into factors, so f2 = sim_R[,1,drop=FALSE].
## Also remember excluding sim_R[,1,drop=FALSE] from test assets, so R = sim_R[,-1].
shrinkage &lt;- continuous_ss_sdf_v2(cbind(sim_f,uf), sim_R[,1,drop=FALSE], sim_R[,-1], 1000,
                                  psi0=psi_hat, r=0.001, aw=1, bw=1)
cat("Null hypothesis: lambda =", 0, "for each of these three factors", "\n")
cat("Posterior probabilities of rejecting the above null hypotheses are:",
    colMeans(shrinkage$gamma_path), "\n")

## We also have the posterior draws of SDF: m(t) = 1 - lambda_g %*% (f(t) - mu_f)
sdf_path &lt;- shrinkage$sdf_path

## We also provide the Bayesian model averaging of the SDF (BMA-SDF)
bma_sdf &lt;- shrinkage$bma_sdf

## We can further estimate the posterior distributions of model-implied Sharpe ratios:
cat("The 5th, 50th, and 95th quantiles of model-implied Sharpe ratios:",
    quantile(colSds(t(sdf_path)), probs=c(0.05, 0.5, 0.95)), "\n")

## Finally, we can estimate the posterior distribution of model dimensions:
cat("The posterior distribution of model dimensions (= 0, 1, 2, 3):",
    prop.table(table(rowSums(shrinkage$gamma_path))), "\n")

## We now use the 17th test asset, sim_R[,17,drop=FALSE], as the tradable factor,
## so f2 = sim_R[,17,drop=FALSE].
## Also remember excluding sim_R[,17,drop=FALSE] from test assets, so R = sim_R[,-17].
psi_hat &lt;- psi_to_priorSR(sim_R, cbind(sim_f,uf,sim_R[,17]), priorSR=0.1)
shrinkage &lt;- continuous_ss_sdf_v2(cbind(sim_f,uf), sim_R[,17,drop=FALSE], sim_R[,-17],
                                  1000, psi0=psi_hat, r=0.001, aw=1, bw=1)
cat("Null hypothesis: lambda =", 0, "for each of these three factors", "\n")
cat("Posterior probabilities of rejecting the above null hypotheses are:",
    colMeans(shrinkage$gamma_path), "\n")



</code></pre>

<hr>
<h2 id='dirac_ss_sdf_pvalue'>Hypothesis testing for risk prices (Bayesian p-values) with Dirac spike-and-slab prior</h2><span id='topic+dirac_ss_sdf_pvalue'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis, <code class="reqn">H_0: \lambda = \lambda_0</code>, when <code class="reqn">\gamma=0</code>.
When <code class="reqn">\lambda_0 = 0</code>, we compare factor models using the algorithm in Proposition 1 of Bryzgalova et al. (2023).
When <code class="reqn">\lambda_0 \neq 0</code>, this function corresponds to Corollary 2 in Section II.A.2 of Bryzgalova et al. (2023).
The function can also be used to compute the posterior probabilities of all possible models with up to a
given maximum number of factors (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirac_ss_sdf_pvalue(f, R, sim_length, lambda0, psi0 = 1, max_k = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dirac_ss_sdf_pvalue_+3A_f">f</code></td>
<td>
<p>A matrix of factors with dimension <code class="reqn">t \times k</code>, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods;</p>
</td></tr>
<tr><td><code id="dirac_ss_sdf_pvalue_+3A_r">R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets;</p>
</td></tr>
<tr><td><code id="dirac_ss_sdf_pvalue_+3A_sim_length">sim_length</code></td>
<td>
<p>The length of Monte-Carlo simulations;</p>
</td></tr>
<tr><td><code id="dirac_ss_sdf_pvalue_+3A_lambda0">lambda0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of risk prices under the null hypothesis (<code class="reqn">\gamma=0</code>);</p>
</td></tr>
<tr><td><code id="dirac_ss_sdf_pvalue_+3A_psi0">psi0</code></td>
<td>
<p>The hyper-parameter in the prior distribution of risk price <code class="reqn">\lambda</code> (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="dirac_ss_sdf_pvalue_+3A_max_k">max_k</code></td>
<td>
<p>The maximal number of factors in models (<code>max_k</code> is a positive integer or <code>NULL</code> if the user does not impose any restriction on the model dimension).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">D</code> denote a diagonal matrix with elements <code class="reqn">c, \psi_1^{-1},..., \psi_K^{-1}</code>, and <code class="reqn">D_\gamma</code> the submatrix of <code class="reqn">D</code>
corresponding to model <code class="reqn">\gamma</code>, where <code class="reqn">c</code> is a small positive number corresponding to the common cross-sectional intercept
(<code class="reqn">\lambda_c</code>). The prior for the prices of risk (<code class="reqn">\lambda_\gamma</code>) of model <code class="reqn">\gamma</code> is then
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_\gamma | \sigma^2, \gamma \sim N (0, \sigma^2, D_{\gamma}^{-1}). </code>
</p>

<p>We choose
<code class="reqn"> \psi_j =  \psi \tilde{\rho}_j^\top \tilde{\rho}_j  </code>, where <code class="reqn"> \tilde{\rho}_j = \rho_j - (\frac{1}{N} \Sigma_{i=1}^{N} \rho_{j,i}  ) \times 1_N </code> is the cross-sectionally
demeaned vector of factor <code class="reqn">j</code>'s correlations with asset returns. In the codes, <code class="reqn">\psi</code> is equal to the value of <code>psi0</code>.
</p>


<h3>Value</h3>

<p>The return of <code>dirac_ss_sdf_pvalue</code> is a list of the following elements:
</p>

<ul>
<li> <p><code>gamma_path</code>: A <code>sim_length</code><code class="reqn">\times k</code> matrix of the posterior draws of <code class="reqn">\gamma</code>. Each row represents
a draw. If <code class="reqn">\gamma_j = 1</code> in one draw, factor <code class="reqn">j</code> is included in the model in this draw and vice verse.
</p>
</li>
<li> <p><code>lambda_path</code>: A <code>sim_length</code><code class="reqn">\times (k+1)</code> matrix of the risk prices <code class="reqn">\lambda</code>. Each row represents
a draw. Note that the first column is <code class="reqn">\lambda_c</code> corresponding to the constant term. The next <code class="reqn">k</code> columns (i.e., the 2-th &ndash; <code class="reqn">(k+1)</code>-th columns) are the risk prices of the <code class="reqn">k</code> factors;
</p>
</li>
<li> <p><code>model_probs</code>: A <code class="reqn">2^k \times (k+1)</code> matrix of posterior model probabilities, where the first k columns are the model indices and the final column is a vector of model probabilities.
</p>
</li></ul>



<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
&ldquo;Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.&rdquo;
<em>Journal of Finance</em>, <b>78</b>(1), 487&ndash;557.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## &lt;--------------------------------------------------------------------------------&gt;
## Example: Bayesian p-value (with the dirac spike-and-slab prior)
## &lt;--------------------------------------------------------------------------------&gt;

# Load the example data
data("BFactor_zoo_example")
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf

### Now we estimate the Bayesian p-values defined in Corollary 2.

#
### Prior Sharpe ratio of factor model for different values of psi: see equation (27):
#
cat("--------------- Choose psi based on prior Sharpe ratio ----------------\n")
cat("if psi = 1, prior Sharpe ratio is", psi_to_priorSR(sim_R, sim_f, psi0=1), "\n")
cat("if psi = 2, prior Sharpe ratio is", psi_to_priorSR(sim_R, sim_f, psi0=2), "\n")
cat("if psi = 5, prior Sharpe ratio is", psi_to_priorSR(sim_R, sim_f, psi0=5), "\n")

## Test whether factors' risk prices equal 'matrix(lambda_ols[2]*sd(HML),ncol=1)'
## Bayesian p-value is given by mean(shrinkage$gamma_path)
shrinkage &lt;- dirac_ss_sdf_pvalue(sim_f, sim_R, 1000, matrix(lambda_ols[2]*sd(HML),ncol=1))
cat("Null hypothesis: lambda =", matrix(lambda_ols[2]*sd(HML)), "\n")
cat("Posterior probability of rejecting the above null hypothesis is:",
    mean(shrinkage$gamma_path), "\n")

## Test whether the risk price of factor 'sim_f' is equal to 0
shrinkage &lt;- dirac_ss_sdf_pvalue(sim_f, sim_R, 1000, 0, psi0=1)
cat("Null hypothesis: lambda =", 0, "\n")
cat("Posterior probability of rejecting the above null hypothesis is:",
    mean(shrinkage$gamma_path), "\n")


## One can also put more than one factor into the test
two_f = cbind(sim_f,uf) # sim_f is the strong factor while uf is the useless factor
# Test1: lambda of sim_f = 0, Test2: lambda of uf = 0
lambda0_null_vec = t(cbind(0,0)) # 2x1 vector
shrinkage &lt;- dirac_ss_sdf_pvalue(two_f, sim_R, 1000, lambda0_null_vec, psi0=1)
cat("Null hypothesis: lambda =", 0, "for each factor", "\n")
cat("Posterior probabilities of rejecting the above null hypothesis are:",
    colMeans(shrinkage$gamma_path), "\n")

## We can also print the posterior model probabilities:
cat('Posterior model probabilities are:\n')
print(shrinkage$model_probs)


## One can compute the posterior probabilities of all possible models with up to
## a given maximum number of factors. For example, we consider two factors, but
## the number of factors is restricted to be less than two.
lambda0_null_vec = t(cbind(0,0)) # 2x1 vector
shrinkage &lt;- dirac_ss_sdf_pvalue(two_f, sim_R, 1000, lambda0_null_vec, psi0=1, max_k=1)
cat('Posterior model probabilities are:\n')
print(shrinkage$model_probs)
## Comment: You may notice that the model with index (1, 1) has a posterior probability
##          of exactly zero since the maximal number of factors is one.

</code></pre>

<hr>
<h2 id='psi_to_priorSR'>Mapping <code class="reqn">\psi</code> (<code>psi0</code>) to the prior Sharpe ratio of factors (<code>priorSR</code>), and vice versa.</h2><span id='topic+psi_to_priorSR'></span>

<h3>Description</h3>

<p>This function provides the one-to-one mapping between <code class="reqn">\psi</code> and the prior Sharpe ratio of factors.
See Section II.A.3 in Bryzgalova et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_to_priorSR(R, f, psi0 = NULL, priorSR = NULL, aw = 1, bw = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_to_priorSR_+3A_r">R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets;</p>
</td></tr>
<tr><td><code id="psi_to_priorSR_+3A_f">f</code></td>
<td>
<p>A matrix of factors with dimension <code class="reqn">t \times k</code>, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods;</p>
</td></tr>
<tr><td><code id="psi_to_priorSR_+3A_psi0">psi0</code></td>
<td>
<p>The hyper-parameter in the prior distribution of risk prices (see <b>Details</b> in the function <code>continuous_ss_sdf</code>);</p>
</td></tr>
<tr><td><code id="psi_to_priorSR_+3A_priorsr">priorSR</code></td>
<td>
<p>The prior Sharpe ratio of all factors (see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="psi_to_priorSR_+3A_aw">aw</code></td>
<td>
<p>The hyper-parameter in the prior of <code class="reqn">\gamma</code> (default value = 1, see <b>Details</b>);</p>
</td></tr>
<tr><td><code id="psi_to_priorSR_+3A_bw">bw</code></td>
<td>
<p>The hyper-parameter in the prior of <code class="reqn">\gamma</code> (default value = 1, see <b>Details</b>);</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to equation (27) in Bryzgalova et al. (2023), we learn that
</p>
<p style="text-align: center;"><code class="reqn">\frac{E_{\pi} [ SR^2_f \mid \gamma, \sigma^2 ] }{E_{\pi} [ SR^2_{\alpha} \mid \sigma^2] } = \frac{\psi \sum^K_{k=1} r(\gamma_k) \tilde{\rho}^\top_k \tilde{\rho}_k }{N}, </code>
</p>

<p>where <code class="reqn">SR^2_f</code> and <code class="reqn">SR^2_{\alpha}</code> denote the Sharpe ratios of all factors (<code class="reqn">f_t</code>) and of the pricing errors
(<code class="reqn">\alpha</code>), and <code class="reqn">E_{\pi}</code> denotes prior expectations.
</p>
<p>The prior <code class="reqn">\pi (\omega)</code> encodes the belief about the sparsity of the true model using the prior distribution
<code class="reqn">\pi (\gamma_j = 1 | \omega_j) = \omega_j, \ \ \omega_j \sim Beta(a_\omega, b_\omega) .</code> We further integrate out
<code class="reqn">\gamma_j</code> in <code class="reqn">E_{\pi} [ SR^2_f \mid \gamma, \sigma^2 ]</code> and show the following:
</p>
<p style="text-align: center;"><code class="reqn">\frac{E_{\pi} [ SR^2_f \mid \sigma^2 ] }{E_{\pi} [ SR^2_{\alpha} \mid \sigma^2 ] } \approx \frac{a_\omega}{a_\omega+b_\omega} \psi \frac{ \sum^K_{k=1} \tilde{\rho}^\top_k \tilde{\rho}_k }{N}, \ as \ r \to 0 .</code>
</p>

<p>Since we can decompose the Sharpe ratios of all test assets, <code class="reqn">SR^2_R</code>, into <code class="reqn">SR^2_f</code> and <code class="reqn">SR^2_{\alpha}</code> (i.e., <code class="reqn">SR^2_R = SR^2_f + SR^2_{\alpha}</code>), we can
represent <code class="reqn">SR^2_f</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn"> E_{\pi} [ SR^2_f \mid \sigma^2 ] \approx \frac{\frac{a_\omega}{a_\omega+b_\omega} \psi \frac{ \sum^K_{k=1} \tilde{\rho}^\top_k \tilde{\rho}_k }{N}}{1 + \frac{a_\omega}{a_\omega+b_\omega} \psi \frac{ \sum^K_{k=1} \tilde{\rho}^\top_k \tilde{\rho}_k }{N}} SR^2_R.</code>
</p>

<p>We define the prior Sharpe ratio implied by the factor models as <code class="reqn">\sqrt{E_{\pi} [ SR^2_f \mid \sigma^2 ]}</code>.
Given <code class="reqn">a_\omega</code>, <code class="reqn">b_\omega</code>, <code class="reqn">\frac{ \sum^K_{k=1} \tilde{\rho}^\top_k \tilde{\rho}_k }{N}</code>, and the observed
Sharpe ratio of test assets, we have one-to-one mapping between <code class="reqn">\psi</code> and <code class="reqn">\sqrt{E_{\pi} [ SR^2_f \mid \sigma^2 ]}</code>.
</p>
<p>If the user aims to convert <code class="reqn">\psi</code> to the prior Sharpe ratio, she should input only <code>psi0</code>.
In contrast, if she wants to convert the prior Sharpe ratio to <code class="reqn">\psi</code>, <code>priorSR</code> should be entered.
</p>


<h3>Value</h3>

<p>The return of <code>psi_to_priorSR</code> is:
</p>

<ul>
<li> <p><code>psi0</code> or <code>priorSR</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
&ldquo;Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.&rdquo;
<em>Journal of Finance</em>, <b>78</b>(1), 487&ndash;557.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load the example data
data("BFactor_zoo_example")
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf

## If the user aims to convert \eqn{\psi} to the prior Sharpe ratio:
print(psi_to_priorSR(sim_R, sim_f, priorSR=0.1))

## If the user  wants to convert the prior Sharpe ratio to \eqn{\psi}:
psi0_to_map &lt;- psi_to_priorSR(sim_R, sim_f, priorSR=0.1)
print(psi_to_priorSR(sim_R, sim_f, psi0=psi0_to_map))

## If we enter both psi0 and priorSR (or forget to input them simultaneously),
## a warning will be printed:
print(psi_to_priorSR(sim_R, sim_f))
print(psi_to_priorSR(sim_R, sim_f, priorSR=0.1, psi0=2))



</code></pre>

<hr>
<h2 id='SDF_gmm'>GMM Estimates of Factors' Risk Prices under the Linear SDF Framework</h2><span id='topic+SDF_gmm'></span>

<h3>Description</h3>

<p>This function provides the GMM estimates of factors' risk prices under the linear SDF framework (including the common intercept).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDF_gmm(R, f, W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SDF_gmm_+3A_r">R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets;</p>
</td></tr>
<tr><td><code id="SDF_gmm_+3A_f">f</code></td>
<td>
<p>A matrix of factors with dimension <code class="reqn">t \times k</code>, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods;</p>
</td></tr>
<tr><td><code id="SDF_gmm_+3A_w">W</code></td>
<td>
<p>Weighting matrix in GMM estimation (see <b>Details</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We follow the notations in Section I of Bryzgalova et al. (2023).
Suppose that there are <code class="reqn">K</code> factors, <code class="reqn">f_t = (f_{1t},...,f_{Kt})^\top, t=1,...,T</code>.
The returns of <code class="reqn">N</code> test assets are denoted by <code class="reqn">R_t = (R_{1t},...,R_{Nt})^\top</code>.
</p>
<p>Consider linear SDFs (<code class="reqn">M</code>), that is, models of the form <code class="reqn">M_t = 1- (f_t -E[f_t])^\top \lambda_f</code>.
</p>
<p>The model is estimated via GMM with moment conditions
</p>
<p style="text-align: center;"><code class="reqn">E[g_t (\lambda_c, \lambda_f, \mu_f)] =E\left(\begin{array}{c} R_t - \lambda_c 1_N - R_t (f_t - \mu_f)^\top \lambda_f \\ f_t - \mu_f \end{array} \right) =\left(\begin{array}{c}  0_N \\ 0_K \end{array} \right)</code>
</p>

<p>and the corresponding sample analog function <code class="reqn"> g_T (\lambda_c, \lambda_f, \mu_f) = \frac{1}{T} \Sigma_{t=1}^T  g_t (\lambda_c, \lambda_f, \mu_f)</code>. Different weighting matrices deliver different point estimates. Two popular choices are
</p>
<p style="text-align: center;"><code class="reqn">	W_{ols}=\left(\begin{array}{cc}I_N &amp; 0_{N \times K}  \\ 0_{K \times N} &amp; \kappa I_K\end{array}\right), \ \ W_{gls}=\left(\begin{array}{cc} \Sigma_R^{-1} &amp; 0_{N \times K}  \\ 0_{K \times N} &amp; \kappa I_K\end{array}\right), </code>
</p>

<p>where <code class="reqn">\Sigma_R</code> is the covariance matrix of returns and <code class="reqn">\kappa &gt;0</code> is a large constant so that <code class="reqn">\hat{\mu}_f = \frac{1}{T} \Sigma_{t=1}^{T} f_t </code>.
</p>
<p>The asymptotic covariance matrix of risk premia estimates, <code>Avar_hat</code>, is based on the assumption that
<code class="reqn">g_t (\lambda_c, \lambda_f, \mu_f)</code> is independent over time.
</p>


<h3>Value</h3>

<p>The return of <code>SDF_gmm</code> is a list of the following elements:
</p>

<ul>
<li> <p><code>lambda_gmm</code>: Risk price estimates;
</p>
</li>
<li> <p><code>mu_f</code>: Sample means of factors;
</p>
</li>
<li> <p><code>Avar_hat</code>: Asymptotic covariance matrix of GMM estimates (see <b>Details</b>);
</p>
</li>
<li> <p><code>R2_adj</code>: Adjusted cross-sectional <code class="reqn">R^2</code>;
</p>
</li>
<li> <p><code>S_hat</code>: Spectral matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
&ldquo;Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.&rdquo;
<em>Journal of Finance</em>, <b>78</b>(1), 487&ndash;557.
</p>

<hr>
<h2 id='Two_Pass_Regression'>Fama MacBeth Two-Pass Regression</h2><span id='topic+Two_Pass_Regression'></span>

<h3>Description</h3>

<p>This function provides the frequentist Fama-MacBeth Two-Pass Regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Two_Pass_Regression(f, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Two_Pass_Regression_+3A_f">f</code></td>
<td>
<p>A matrix of factors with dimension <code class="reqn">t \times k</code>, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods;</p>
</td></tr>
<tr><td><code id="Two_Pass_Regression_+3A_r">R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Chapter 12.2 in Cochrane (2009). <code>t_stat</code> and <code>t_stat_gls</code>
are t-statistics of OLS and GLS risk premia estimates based on the asymptotic standard errors in equation (12.19) in
Cochrane (2009).
</p>


<h3>Value</h3>

<p>The return of <code>Two_Pass_Regression</code> is a list of the following elements:
</p>

<ul>
<li><p> lambda: Risk premia estimates in the OLS two-pass regression;
</p>
</li>
<li><p> lambda_gls: Risk premia estimates in the GLS two-pass regression;
</p>
</li>
<li><p> t_stat: The t-statistics of risk premia estimates in the OLS two-pass regression;
</p>
</li>
<li><p> t_stat_gls: The t-statistics of risk premia estimates in the GLS two-pass regression;
</p>
</li>
<li><p> R2_adj: Adjusted <code class="reqn">R2</code> in the OLS two-pass regression;
</p>
</li>
<li><p> R2_adj_GLS: Adjusted <code class="reqn">R2</code> in the GLS two-pass regression.
</p>
</li></ul>



<h3>References</h3>

<p>Cochrane J (2009).
<em>Asset pricing: Revised edition</em>.
Princeton University Press.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
