<!DOCTYPE html><html lang="EN-US"><head><title>Help for package estimateW</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {estimateW}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bbinompdf'><p>Probability density for a hierarchical prior setup for the elements of the adjacency matrix based on the beta binomial distribution</p></a></li>
<li><a href='#beta_priors'><p>Set prior specifications for the slope parameters</p></a></li>
<li><a href='#beta_sampler'><p>An R6 class for sampling slope parameters</p></a></li>
<li><a href='#betapdf'><p>The four-parameter Beta probability density function</p></a></li>
<li><a href='#covid'><p>Covid incidences data</p></a></li>
<li><a href='#logdetAinvUpdate'><p>Efficient update of the log-determinant and the matrix inverse</p></a></li>
<li><a href='#logdetPaceBarry'><p>Pace and Barry's log determinant approximation</p></a></li>
<li><a href='#normalgamma'><p>A Markov Chain Monte Carlo (MCMC) sampler for a linear panel model</p></a></li>
<li><a href='#plot.estimateW'><p>Graphical summary of the estimated adjacency matrix <code class="reqn">\Omega</code></p></a></li>
<li><a href='#plot.sim_dgp'><p>Graphical summary of a generated spatial weight matrix</p></a></li>
<li><a href='#rho_priors'><p>Specify prior for the spatial autoregressive parameter and sampling settings</p></a></li>
<li><a href='#rho_sampler'><p>An R6 class for sampling the spatial autoregressive parameter <code class="reqn">\rho</code></p></a></li>
<li><a href='#sar'><p>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial autoregressive model (SAR) with exogenous spatial weight matrix.</p></a></li>
<li><a href='#sarw'><p>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial autoregressive model (SAR) with unknown spatial weight matrix</p></a></li>
<li><a href='#sdm'><p>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial Durbin model (SDM) with exogenous spatial weight matrix.</p></a></li>
<li><a href='#sdmw'><p>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial Durbin model (SDM) with unknown spatial weight matrix</p></a></li>
<li><a href='#sigma_priors'><p>Set prior specification for the error variance using an inverse Gamma distribution</p></a></li>
<li><a href='#sigma_sampler'><p>An R6 class for sampling for sampling <code class="reqn">\sigma^2</code></p></a></li>
<li><a href='#sim_dgp'><p>Simulating from a data generating process</p></a></li>
<li><a href='#slxw'><p>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial SLX model with unknown spatial weight matrix</p></a></li>
<li><a href='#W_priors'><p>Set prior specifications for the spatial weight matrix</p></a></li>
<li><a href='#W_sampler'><p>An R6 class for sampling the elements of <code class="reqn">W</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Spatial Weight Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Tamas Krisztin <a href="https://orcid.org/0000-0002-9241-8628"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Philipp Piribauer <a href="https://orcid.org/0000-0002-3414-3101"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tamas Krisztin &lt;krisztin@iiasa.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian estimation of spatial weight matrices in spatial econometric panel models. Allows for estimation of spatial autoregressive (SAR), spatial Durbin (SDM), and spatially lagged explanatory variable (SLX) type specifications featuring an unknown spatial weight matrix. Methodological details are given in Krisztin and Piribauer (2022) &lt;<a href="https://doi.org/10.1080%2F17421772.2022.2095426">doi:10.1080/17421772.2022.2095426</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>EN-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, matrixcalc, plot.matrix, stats, R6</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-06 04:40:22 UTC; tamaskrisztin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-06 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bbinompdf'>Probability density for a hierarchical prior setup for the elements of the adjacency matrix based on the beta binomial distribution</h2><span id='topic+bbinompdf'></span>

<h3>Description</h3>

<p>A hierarchical prior setup can be used in <code><a href="#topic+W_priors">W_priors</a></code> to anchor the prior
number of expected neighbors. Assuming a <em>fixed</em> prior inclusion probability <code class="reqn">\underline{p}=1/2</code>
for the off-diagonal entries in the binary <code class="reqn">n</code> by <code class="reqn">n</code> adjacency matrix <code class="reqn">\Omega</code> implies
that the number of neighbors (i.e. the row sums of <code class="reqn">\Omega</code>) follows a Binomial distribution
with a prior expected number of neighbors for the <code class="reqn">n</code> spatial observations of <code class="reqn">(n-1)\underline{p}</code>.
However, such a prior structure has the potential undesirable effect of promoting a relatively large
number of neighbors. To put more prior weight on parsimonious neighborhood structures and promote sparsity
in <code class="reqn">\Omega</code>, the beta binomial prior accounts for the number of neighbors in each row of <code class="reqn">\Omega</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbinompdf(x, nsize, a, b, min_k = 0, max_k = nsize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bbinompdf_+3A_x">x</code></td>
<td>
<p>Number of neighbors (scalar)</p>
</td></tr>
<tr><td><code id="bbinompdf_+3A_nsize">nsize</code></td>
<td>
<p>Number of potential neighbors: <code>nsize</code><code class="reqn">=(n-1)</code></p>
</td></tr>
<tr><td><code id="bbinompdf_+3A_a">a</code></td>
<td>
<p>Scalar prior parameter <code class="reqn">a</code></p>
</td></tr>
<tr><td><code id="bbinompdf_+3A_b">b</code></td>
<td>
<p>Scalar prior parameter <code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="bbinompdf_+3A_min_k">min_k</code></td>
<td>
<p>Minimum prior number of neighbors (defaults to 0)</p>
</td></tr>
<tr><td><code id="bbinompdf_+3A_max_k">max_k</code></td>
<td>
<p>Maximum prior number of neighbors (defaults to <code>nsize</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta-binomial distribution is the result of treating the prior inclusion probability <code class="reqn">\underline{p}</code>
as random (rather than being fixed) by placing a hierarchical beta prior on it.
For the number of neighbors <code class="reqn">x</code>, the resulting prior on the elements of <code class="reqn">\Omega</code>, <code class="reqn">\omega_{ij}</code>,
can be written as:
</p>
<p style="text-align: center;"><code class="reqn">
 p(\omega_{ij} = 1 | x)\propto \Gamma\left(a+ x \right)\Gamma\left(b+(n-1)-x\right),
 </code>
</p>

<p>where <code class="reqn">\Gamma(\cdot )</code> is the Gamma function, and <code class="reqn">a</code> and
<code class="reqn">b</code> are hyperparameters from the beta prior. In the case of <code class="reqn">a = b = 1</code>, the prior takes the
form of a discrete uniform distribution over the number of neighbors. By fixing <code class="reqn">a = 1</code>
the prior can be anchored around the expected number of neighbors <code class="reqn">m</code> through
<code class="reqn">b=[(n-1)-m]/m</code> (see Ley and Steel, 2009).
</p>
<p>The prior can be truncated by setting a minimum (<code>min_k</code>) and/or a maximum number of
neighbors (<code>max_k</code>). Values outside this range have zero prior support.
</p>


<h3>Value</h3>

<p>Prior density evaluated at <code>x</code>.
</p>


<h3>References</h3>

<p>Ley, E., &amp; Steel, M. F. (2009). On the effect of prior assumptions in Bayesian
model averaging with applications to growth regression. <em>Journal of Applied Econometrics</em>,
<b>24(4)</b>. <a href="https://doi.org/10.1002/jae.1057">doi:10.1002/jae.1057</a>.
</p>

<hr>
<h2 id='beta_priors'>Set prior specifications for the slope parameters</h2><span id='topic+beta_priors'></span>

<h3>Description</h3>

<p>This function allows the user to specify custom values for Gaussian priors on the slope parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_priors(
  k,
  beta_mean_prior = matrix(0, k, 1),
  beta_var_prior = diag(k) * 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta_priors_+3A_k">k</code></td>
<td>
<p>The total number of slope parameters in the model.</p>
</td></tr>
<tr><td><code id="beta_priors_+3A_beta_mean_prior">beta_mean_prior</code></td>
<td>
<p>numeric <code class="reqn">k</code> by <code class="reqn">1</code> matrix of prior means <code class="reqn">\underline{\mu}_\beta</code>.</p>
</td></tr>
<tr><td><code id="beta_priors_+3A_beta_var_prior">beta_var_prior</code></td>
<td>
<p>A <code class="reqn">k</code> by <code class="reqn">k</code> matrix of prior variances <code class="reqn">\underline{V}_\beta</code>. Defaults to a
diagonal matrix with <code>100</code> on the main diagonal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the slope parameters <code class="reqn">\beta</code> the package uses common Normal
prior specifications. Specifically,  <code class="reqn">p(\beta)\sim\mathcal{N}(\underline{\mu}_\beta,\underline{V}_\beta)</code>.
</p>
<p>This function allows the user to specify custom values for the prior hyperparameters <code class="reqn">\underline{\mu}_\beta</code>
and <code class="reqn">\underline{V}_\beta</code>. The default values correspond to weakly informative Gaussian priors with mean
zero and a diagonal prior variance-covariance matrix with <code class="reqn">100</code> on the main diagonal.
</p>


<h3>Value</h3>

<p>A list with the prior mean vector (<code>beta_mean_prior</code>), the prior variance matrix
(<code>beta_var_prior</code>) and the inverse of the prior variance matrix (<code>beta_var_prior_inv</code>).
</p>

<hr>
<h2 id='beta_sampler'>An R6 class for sampling slope parameters</h2><span id='topic+beta_sampler'></span>

<h3>Description</h3>

<p>This class samples slope parameters with a Gaussian prior from the conditional posterior.
Use the <a href="#topic+beta_priors">beta_priors</a> class for setup.
</p>


<h3>Format</h3>

<p>An <code>R6Class</code> generator object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>beta_prior</code></dt><dd><p>The current <code><a href="#topic+beta_priors">beta_priors</a></code></p>
</dd>
<dt><code>curr_beta</code></dt><dd><p>The current value of <code class="reqn">\beta</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-beta_sampler-new"><code>beta_sampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-beta_sampler-sample"><code>beta_sampler$sample()</code></a>
</p>
</li></ul>


<hr>
<a id="method-beta_sampler-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>beta_sampler$new(beta_prior)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta_prior</code></dt><dd><p>The list returned by <code><a href="#topic+beta_priors">beta_priors</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-beta_sampler-sample"></a>



<h4>Method <code>sample()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>beta_sampler$sample(Y, X, curr_sigma)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>The <code class="reqn">N</code> by <code class="reqn">1</code> matrix of responses</p>
</dd>
<dt><code>X</code></dt><dd><p>The <code class="reqn">N</code> by <code class="reqn">k</code> design matrix</p>
</dd>
<dt><code>curr_sigma</code></dt><dd><p>The variance parameter <code class="reqn">\sigma^2</code></p>
</dd>
</dl>

</div>



<hr>
<h2 id='betapdf'>The four-parameter Beta probability density function</h2><span id='topic+betapdf'></span>

<h3>Description</h3>

<p>A four-parameter Beta specification as the prior for the spatial autoregressive parameter <code class="reqn">\rho</code>,
as proposed by LeSage and Parent (2007) .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betapdf(rho, a = 1, b = 1, rmin = 0, rmax = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betapdf_+3A_rho">rho</code></td>
<td>
<p>The scalar value for <code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code id="betapdf_+3A_a">a</code></td>
<td>
<p>The first shape parameter of the Beta distribution</p>
</td></tr>
<tr><td><code id="betapdf_+3A_b">b</code></td>
<td>
<p>The second shape parameter of the Beta distribution</p>
</td></tr>
<tr><td><code id="betapdf_+3A_rmin">rmin</code></td>
<td>
<p>Scalar <code class="reqn">\underline{\rho}_{min}</code>: the minimum value of <code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code id="betapdf_+3A_rmax">rmax</code></td>
<td>
<p>Scalar <code class="reqn">\underline{\rho}_{max}</code>: the maximum value of <code class="reqn">\rho</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior density is given by:
</p>
<p style="text-align: center;"><code class="reqn"> p(\rho) \sim \frac{1}{Beta(a,b)} \frac{(\rho - \underline{\rho}_{min})^{(a-1)} (\underline{\rho}_{max} - \rho)^{(b-1)} }{2^{a + b - 1}} </code>
</p>

<p>where <code class="reqn">Beta(a, b)</code> (<code class="reqn">a,b &gt; 0</code>) represents the Beta function,
<code class="reqn">Beta(a, b)= \int_{0}^{1} t^{a-1} (1-t)^{b-1} dt</code>.
</p>


<h3>Value</h3>

<p>Density value evaluated at <code>rho</code>.
</p>


<h3>References</h3>

<p>LeSage, J. P., and Parent, O. (2007) Bayesian model averaging for spatial econometric models.
<em>Geographical Analysis</em>, <b>39(3)</b>, 241-267.
</p>

<hr>
<h2 id='covid'>Covid incidences data</h2><span id='topic+covid'></span>

<h3>Description</h3>

<p>COVID-19 data set provided by Johns Hopkins University (Dong et al., 2020). The
database contains information on (official) daily infections for a large panel of
countries around the globe in the very beginning of the outbreak
from 17 February to 20 April 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covid
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object.
</p>


<h3>Details</h3>

<p>Data is provided for countries: Australia (AUS), Bahrain (BHR), Belgium (BEL),
Canada (CAN), China (CHN), Finland (FIN), France (FRA), Germany (DEU), Iran (IRN), Iraq (IRQ),
Israel (ISR), Italy (ITA), Japan (JPN), Kuwait (KWT), Lebanon (LBN), Malaysia (MYS), Oman (OMN),
Republic of Korea (KOR), Russian Federation (RUS), Singapore (SGP), Spain (ESP), Sweden (SWE),
Thailand (THA), United Arab Emirates (ARE), United Kingdom (GBR), United States of America (USA),
and Viet Nam (VNM).
</p>
<p>The dataset includes daily data on the country specific maximum measured temperature (Temperature) and
precipitation levels (Precipitation) as additional covariates (source: Dark Sky API).
The stringency index (Stringency) put forward by Hale et al. (2020), which summarizes country-specific
governmental policy measures to contain the spread of the virus. We use the biweekly average of the
reported stringency index.
</p>


<h3>References</h3>

<p>Dong, E., Du, H., and Gardner, L. (2020). An interactive web-based dashboard to track
COVID-19 in real time. <em>The Lancet Infectious Diseases</em>, <b>20(5)</b>, 533–534.
<a href="https://doi.org/10.1016/S1473-3099%2820%2930120-1">doi:10.1016/S1473-3099(20)30120-1</a>.
</p>
<p>Hale, T., Petherick, A., Phillips, T., and Webster, S. (2020). Variation in government
responses to COVID-19. Blavatnik School of Government Working Paper, 31, 2020–2011.
<a href="https://doi.org/10.1038/s41562-021-01079-8">doi:10.1038/s41562-021-01079-8</a>.
</p>
<p>Krisztin, T., and Piribauer, P. (2022). A Bayesian approach for the estimation
of weight matrices in spatial autoregressive models, <em>Spatial Economic Analysis</em>,
1-20. <a href="https://doi.org/10.1080/17421772.2022.2095426">doi:10.1080/17421772.2022.2095426</a>.
</p>
<p>Krisztin, T., Piribauer, P., and Wögerer, M. (2020). The spatial econometrics of the
coronavirus pandemic. <em>Letters in Spatial and Resource Sciences</em>, <b>13 (3)</b>, 209-218.
<a href="https://doi.org/10.1007/s12076-020-00254-1">doi:10.1007/s12076-020-00254-1</a>.
</p>
<p>Dong, E., Du, H., and Gardner, L. (2020). An interactive web-based dashboard to track
COVID-19 in real time. <em>The Lancet Infectious Diseases</em>, <b>20(5)</b>, 533–534.
<a href="https://doi.org/10.1016/S1473-3099%2820%2930120-1">doi:10.1016/S1473-3099(20)30120-1</a>.
</p>

<hr>
<h2 id='logdetAinvUpdate'>Efficient update of the log-determinant and the matrix inverse</h2><span id='topic+logdetAinvUpdate'></span>

<h3>Description</h3>

<p>While updating the elements of the spatial weight matrix in SAR and SDM type spatial models in a
MCMC sampler, the log-determinant term has to be regularly updated, too.
When the binary elements of the adjacency matrix are treated unknown, the Matrix Determinant Lemma
and the Sherman-Morrison formula are used for computationally efficient updates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdetAinvUpdate(ch_ind, diff, AI, logdet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logdetAinvUpdate_+3A_ch_ind">ch_ind</code></td>
<td>
<p>vector of non-negative integers, between 1 and <code class="reqn">n</code>. Denotes which rows of <code class="reqn">A</code>
should be updated.</p>
</td></tr>
<tr><td><code id="logdetAinvUpdate_+3A_diff">diff</code></td>
<td>
<p>a numeric <code>length(ch_ind)</code> by <code>n</code> matrix. This value will be added to the corresponding rows of <code class="reqn">A</code>.</p>
</td></tr>
<tr><td><code id="logdetAinvUpdate_+3A_ai">AI</code></td>
<td>
<p>numeric <code class="reqn">n</code> by <code class="reqn">n</code> matrix that is the inverse of <code class="reqn">A = (I_n - \rho W)</code>. This inverse will
be updated using the Sherman-Morrison formula.</p>
</td></tr>
<tr><td><code id="logdetAinvUpdate_+3A_logdet">logdet</code></td>
<td>
<p>single number that is the log-determinant of the matrix <code class="reqn">A</code>. This log-determinant
will be updated through the Matrix Determinant Lemma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">A = (I_n - \rho W)</code> be an invertible <code class="reqn">n</code> by <code class="reqn">n</code> matrix. <code class="reqn">v</code> is an <code class="reqn">n</code> by <code class="reqn">1</code>
column vector of real numbers and <code class="reqn">u</code> is a binary vector containing a single one and zeros otherwise.
Then the Matrix Determinant Lemma states that:
</p>
<p style="text-align: center;"><code class="reqn">A + uv' = (1 + v'A^{-1}u)det(A)</code>
</p>
<p>.
</p>
<p>This provides an update to the determinant, but the inverse of <code class="reqn">A</code> has to be updated as well.
The Sherman-Morrison formula proves useful:
</p>
<p style="text-align: center;"><code class="reqn">(A + uv')^{-1} = A^{-1} \frac{A^{-1}uv'A^{-1}}{1 + v'A^{-1}u}</code>
</p>
<p>.
</p>
<p>Using these two formulas, an efficient update of the spatial projection matrix determinant can be achieved.
</p>


<h3>Value</h3>

<p>A list containing the updated <code class="reqn">n</code> by <code class="reqn">n</code> matrix <code class="reqn">A^{-1}</code>, as well as the
updated log determinant of <code class="reqn">A</code>
</p>


<h3>References</h3>

<p>Sherman, J., and Morrison, W. J. (1950) Adjustment of an inverse matrix corresponding to a
change in one element of a given matrix. <em>The Annals of Mathematical Statistics</em>, <b>21(1)</b>,
124-127.
</p>
<p>Harville, D. A. (1998) Matrix algebra from a statistician's perspective. Taylor &amp; Francis.
</p>

<hr>
<h2 id='logdetPaceBarry'>Pace and Barry's log determinant approximation</h2><span id='topic+logdetPaceBarry'></span>

<h3>Description</h3>

<p>Bayesian estimates of parameters of SAR and SDM type spatial models require the computation
of the log-determinant of positive-definite spatial projection matrices of the form
<code class="reqn">(I_n - \rho W)</code>, where <code class="reqn">W</code> is a <code class="reqn">n</code> by <code class="reqn">n</code> spatial weight matrix. However, direct computation
of the log-determinant is computationally expensive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdetPaceBarry(W, length.out = 200, rmin = -1, rmax = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logdetPaceBarry_+3A_w">W</code></td>
<td>
<p>numeric <code class="reqn">n</code> by <code class="reqn">n</code> non-negative spatial weights matrix,
with zeros on the main diagonal.</p>
</td></tr>
<tr><td><code id="logdetPaceBarry_+3A_length.out">length.out</code></td>
<td>
<p>single, integer number, has to be at least 51 (due to order
of approximation). Sets how fine the grid approximation is. Default
value is 200.</p>
</td></tr>
<tr><td><code id="logdetPaceBarry_+3A_rmin">rmin</code></td>
<td>
<p>single number between -1 and 1. Sets the minimum value of the
spatial autoregressive parameter <code class="reqn">\rho</code>. Has to be lower than
<code>rmax</code>. Default value is -1.</p>
</td></tr>
<tr><td><code id="logdetPaceBarry_+3A_rmax">rmax</code></td>
<td>
<p>single number between -1 and 1. Sets the maximum value of the
spatial autoregressive parameter <code class="reqn">\rho</code>. Has to be higher than
<code>rmin</code>. Default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps the log-determinant approximation by Barry and Pace (1999), which
can be used to precompute the log-determinants over a grid of <code class="reqn">\rho</code> values.
</p>


<h3>Value</h3>

<p>numeric <code>length.out</code> by  <code>2</code> matrix; the first column
contains the approximated log-determinants the second column the <code class="reqn">\rho</code> values
ranging between <code>rmin</code> and <code>rmax</code>.
</p>


<h3>References</h3>

<p>Barry, R. P., and Pace, R. K. (1999) Monte Carlo estimates of the
log determinant of large sparse matrices. <em>Linear Algebra and its
applications</em>, <b>289(1-3)</b>, 41-54.
</p>

<hr>
<h2 id='normalgamma'>A Markov Chain Monte Carlo (MCMC) sampler for a linear panel model</h2><span id='topic+normalgamma'></span>

<h3>Description</h3>

<p>The sampler uses independent Normal-inverse-Gamma priors to estimate a linear panel data model. The function is
used for an illustration on using the <code><a href="#topic+beta_sampler">beta_sampler</a></code> and <code><a href="#topic+sigma_sampler">sigma_sampler</a></code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalgamma(
  Y,
  tt,
  X = matrix(1, nrow(Y), 1),
  niter = 200,
  nretain = 100,
  beta_prior = beta_priors(k = ncol(X)),
  sigma_prior = sigma_priors()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalgamma_+3A_y">Y</code></td>
<td>
<p>numeric <code class="reqn">N \times 1</code> matrix containing the dependent variables, where <code class="reqn">N = nT</code> is the number of
spatial (<code class="reqn">n</code>) times the number of time observations (<code class="reqn">T</code>, with <code>tt=T</code>). Note that the observations
have organized such that <code class="reqn">Y = [Y_1',...,Y_T']'</code>.</p>
</td></tr>
<tr><td><code id="normalgamma_+3A_tt">tt</code></td>
<td>
<p>single number greater or equal to 1. Denotes the number of time observations. <code class="reqn">tt = T</code>.</p>
</td></tr>
<tr><td><code id="normalgamma_+3A_x">X</code></td>
<td>
<p>numeric <code class="reqn">N \times k_1</code> design matrix of independent variables.</p>
</td></tr>
<tr><td><code id="normalgamma_+3A_niter">niter</code></td>
<td>
<p>single number greater or equal to 1, indicating the total number of draws.
Will be automatically coerced to integer. The default value is 200.</p>
</td></tr>
<tr><td><code id="normalgamma_+3A_nretain">nretain</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of draws
kept after the burn-in. Will be automatically coerced to integer. The default value is 100.</p>
</td></tr>
<tr><td><code id="normalgamma_+3A_beta_prior">beta_prior</code></td>
<td>
<p>list containing priors for the slope coefficients <code class="reqn">\beta</code>,
generated by the smart constructor <code><a href="#topic+beta_priors">beta_priors</a></code>.</p>
</td></tr>
<tr><td><code id="normalgamma_+3A_sigma_prior">sigma_prior</code></td>
<td>
<p>list containing priors for the error variance <code class="reqn">\sigma^2</code>,
generated by the smart constructor <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The considered model takes the form:
</p>
<p style="text-align: center;"><code class="reqn">
 Y_t = X_t \beta + \varepsilon_t,
 </code>
</p>

<p>with <code class="reqn">\varepsilon_t \sim N(0,I_n \sigma^2)</code>.
</p>
<p><code class="reqn">Y_t</code> (<code class="reqn">n \times 1</code>) collects the <code class="reqn">n</code> cross-sectional observations for time
<code class="reqn">t=1,...,T</code>. <code class="reqn">X_t</code> (<code class="reqn">n \times k_1</code>) is a matrix of explanatory variables.
<code class="reqn">\beta</code> (<code class="reqn">k_1 \times 1</code>) is an unknown slope parameter matrix.
</p>
<p>After vertically staking the <code class="reqn">T</code> cross-sections  <code class="reqn">Y=[Y_1',...,Y_T']'</code> (<code class="reqn">N \times 1</code>),
<code class="reqn">X=[X_1',...,X_T']'</code> (<code class="reqn">N \times k</code>), with <code class="reqn">N=nT</code>, the final model can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
 Y = X \beta + \varepsilon,
</code>
</p>

<p>where <code class="reqn">\varepsilon \sim N(0,I_N \sigma^2)</code>. Note that the input
data matrices have to be ordered first by the cross-sectional (spatial) units and then stacked by time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20; tt = 10; k = 3
X = matrix(stats::rnorm(n*tt*k),n*tt,k)
Y = X %*% c(1,0,-1) + stats::rnorm(n*tt,0,.5)
res = normalgamma(Y,tt,X)
</code></pre>

<hr>
<h2 id='plot.estimateW'>Graphical summary of the estimated adjacency matrix <code class="reqn">\Omega</code></h2><span id='topic+plot.estimateW'></span>

<h3>Description</h3>

<p>Graphical plot of the posterior probabilities of the estimated adjacency matrix <code class="reqn">\Omega</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimateW'
plot(
  x,
  cols = c("white", "lightgrey", "black"),
  breaks = c(0, 0.5, 0.75, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.estimateW_+3A_x">x</code></td>
<td>
<p><code>estimateW</code> object.</p>
</td></tr>
<tr><td><code id="plot.estimateW_+3A_cols">cols</code></td>
<td>
<p>Main colors to use for the plot</p>
</td></tr>
<tr><td><code id="plot.estimateW_+3A_breaks">breaks</code></td>
<td>
<p>Breaks for the colors</p>
</td></tr>
<tr><td><code id="plot.estimateW_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to be invoked</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sim_dgp'>Graphical summary of a generated spatial weight matrix</h2><span id='topic+plot.sim_dgp'></span>

<h3>Description</h3>

<p>Graphical summary of a generated spatial weight matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_dgp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sim_dgp_+3A_x">x</code></td>
<td>
<p><code>sim_dgp</code> object</p>
</td></tr>
<tr><td><code id="plot.sim_dgp_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the invoked</p>
</td></tr>
</table>

<hr>
<h2 id='rho_priors'>Specify prior for the spatial autoregressive parameter and sampling settings</h2><span id='topic+rho_priors'></span>

<h3>Description</h3>

<p>Specify prior for the spatial autoregressive parameter and sampling settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho_priors(
  rho_a_prior = 1,
  rho_b_prior = 1,
  rho_min = 0,
  rho_max = 1,
  init_rho_scale = 1,
  griddy_n = 60,
  use_griddy_gibbs = TRUE,
  mh_tune_low = 0.4,
  mh_tune_high = 0.6,
  mh_tune_scale = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rho_priors_+3A_rho_a_prior">rho_a_prior</code></td>
<td>
<p>Single number. Prior hyperparameter for the four-parameter beta distribution <code><a href="#topic+betapdf">betapdf</a></code>.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_rho_b_prior">rho_b_prior</code></td>
<td>
<p>Single number. Prior hyperparameter for the four-parameter beta distribution <code><a href="#topic+betapdf">betapdf</a></code>.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_rho_min">rho_min</code></td>
<td>
<p>Minimum value for <code class="reqn">\rho</code> (default: 0)</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_rho_max">rho_max</code></td>
<td>
<p>Maximum value for <code class="reqn">\rho</code> (default: 1)</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_init_rho_scale">init_rho_scale</code></td>
<td>
<p>For Metropolis-Hastings step the initial candidate variance (default: 1)</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_griddy_n">griddy_n</code></td>
<td>
<p>single integer number. Sets how fine the grid approximation is. Default
value is 60.</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_use_griddy_gibbs">use_griddy_gibbs</code></td>
<td>
<p>Binary value. Should griddy-Gibbs be used for <code class="reqn">\rho</code> estimation?
<code>use_griddy_gibbs=TRUE</code> does not work if <code>row_standardized_prior = FALSE</code> is specified in the <code class="reqn">W</code> prior specification.
if TRUE: griddy-Gibbs step for sampling <code class="reqn">\rho</code>; if FALSE: tuned random-walk Metropolis-Hastings step</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_mh_tune_low">mh_tune_low</code></td>
<td>
<p>Lower bound of acceptance rate for Metropolis-Hastings tuning
(used if <code>use_griddy_gibbs==FALSE</code>)</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_mh_tune_high">mh_tune_high</code></td>
<td>
<p>Upper bound of acceptance rate for Metropolis-Hastings tuning
(used if <code>use_griddy_gibbs==FALSE</code>)</p>
</td></tr>
<tr><td><code id="rho_priors_+3A_mh_tune_scale">mh_tune_scale</code></td>
<td>
<p>Scaling factor for Metropolis-Hastings tuning
(used if <code>use_griddy_gibbs==FALSE</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='rho_sampler'>An R6 class for sampling the spatial autoregressive parameter <code class="reqn">\rho</code></h2><span id='topic+rho_sampler'></span>

<h3>Description</h3>

<p>An R6 class for sampling the spatial autoregressive parameter <code class="reqn">\rho</code>
</p>
<p>An R6 class for sampling the spatial autoregressive parameter <code class="reqn">\rho</code>
</p>


<h3>Format</h3>

<p>An <code>R6Class</code> generator object
</p>


<h3>Details</h3>

<p>This class samples the spatial autoregressive parameter using either a tuned random-walk
Metropolis-Hastings or a griddy Gibbs step. Use the <code><a href="#topic+rho_priors">rho_priors</a></code> class for setup.
</p>
<p>For the Griddy-Gibbs algorithm see Ritter and Tanner (1992).
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>rho_prior</code></dt><dd><p>The current <code><a href="#topic+rho_priors">rho_priors</a></code></p>
</dd>
<dt><code>curr_rho</code></dt><dd><p>The current value of <code class="reqn">\rho</code></p>
</dd>
<dt><code>curr_W</code></dt><dd><p>The current spatial weight matrix <code class="reqn">W</code>; an <code class="reqn">n</code> by <code class="reqn">n</code> matrix.</p>
</dd>
<dt><code>curr_A</code></dt><dd><p>The current spatial filter matrix <code class="reqn">I - \rho W</code>.</p>
</dd>
<dt><code>curr_AI</code></dt><dd><p>The inverse of <code>curr_A</code></p>
</dd>
<dt><code>curr_logdet</code></dt><dd><p>The current log-determinant of <code>curr_A</code></p>
</dd>
<dt><code>curr_logdets</code></dt><dd><p>A set of log-determinants for various values of <code class="reqn">\rho</code>. See the
<code><a href="#topic+rho_priors">rho_priors</a></code> function for settings of step site and other parameters of the grid.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-rho_sampler-new"><code>rho_sampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-rho_sampler-stopMHtune"><code>rho_sampler$stopMHtune()</code></a>
</p>
</li>
<li> <p><a href="#method-rho_sampler-setW"><code>rho_sampler$setW()</code></a>
</p>
</li>
<li> <p><a href="#method-rho_sampler-sample"><code>rho_sampler$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-rho_sampler-sample_Griddy"><code>rho_sampler$sample_Griddy()</code></a>
</p>
</li>
<li> <p><a href="#method-rho_sampler-sample_MH"><code>rho_sampler$sample_MH()</code></a>
</p>
</li></ul>


<hr>
<a id="method-rho_sampler-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rho_sampler$new(rho_prior, W = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rho_prior</code></dt><dd><p>The list returned by <code><a href="#topic+rho_priors">rho_priors</a></code></p>
</dd>
<dt><code>W</code></dt><dd><p>An optional starting value for the spatial weight matrix <code class="reqn">W</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-rho_sampler-stopMHtune"></a>



<h4>Method <code>stopMHtune()</code></h4>

<p>Function to stop the tuning of the Metropolis-Hastings step. The tuning of the
Metropolis-Hastings step is usually carried out until half of the burn-in phase.
Call this function to turn it off.
</p>


<h5>Usage</h5>

<div class="r"><pre>rho_sampler$stopMHtune()</pre></div>


<hr>
<a id="method-rho_sampler-setW"></a>



<h4>Method <code>setW()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rho_sampler$setW(newW, newLogdet = NULL, newA = NULL, newAI = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newW</code></dt><dd><p>The updated spatial weight matrix <code class="reqn">W</code>.</p>
</dd>
<dt><code>newLogdet</code></dt><dd><p>An optional value for the log determinant corresponding to <code>newW</code> and <code>curr_rho</code>.</p>
</dd>
<dt><code>newA</code></dt><dd><p>An optional value for the spatial projection matrix using <code>newW</code> and <code>curr_rho</code>.</p>
</dd>
<dt><code>newAI</code></dt><dd><p>An optional value for the matrix inverse of <code>newA</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-rho_sampler-sample"></a>



<h4>Method <code>sample()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rho_sampler$sample(Y, mu, sigma)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">T</code> matrix of responses.</p>
</dd>
<dt><code>mu</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">T</code> matrix of means.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>The variance parameter <code class="reqn">\sigma^2</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-rho_sampler-sample_Griddy"></a>



<h4>Method <code>sample_Griddy()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rho_sampler$sample_Griddy(Y, mu, sigma)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">T</code> matrix of responses.</p>
</dd>
<dt><code>mu</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">T</code> matrix of means.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>The variance parameter <code class="reqn">\sigma^2</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-rho_sampler-sample_MH"></a>



<h4>Method <code>sample_MH()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rho_sampler$sample_MH(Y, mu, sigma)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">T</code> matrix of responses.</p>
</dd>
<dt><code>mu</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">T</code> matrix of means.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>The variance parameter <code class="reqn">\sigma^2</code>.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Ritter, C., and Tanner, M. A. (1992). Facilitating the Gibbs sampler: The Gibbs stopper
and the griddy-Gibbs sampler. <em>Journal of the American Statistical Association</em>,
<b>87(419)</b>, 861-868.
</p>

<hr>
<h2 id='sar'>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial autoregressive model (SAR) with exogenous spatial weight matrix.</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p>The sampler uses independent Normal-inverse-Gamma priors for the slope and variance parameters,
as well as a four-parameter beta prior for the spatial autoregressive parameter <code class="reqn">\rho</code>. The function is
used as an illustration on using the <code><a href="#topic+beta_sampler">beta_sampler</a></code>, <code><a href="#topic+sigma_sampler">sigma_sampler</a></code>,
and <code><a href="#topic+rho_sampler">rho_sampler</a></code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar(
  Y,
  tt,
  W,
  Z = matrix(1, nrow(Y), 1),
  niter = 200,
  nretain = 100,
  rho_prior = rho_priors(),
  beta_prior = beta_priors(k = ncol(Z)),
  sigma_prior = sigma_priors()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar_+3A_y">Y</code></td>
<td>
<p>numeric <code class="reqn">N \times 1</code> matrix containing the dependent variables, where <code class="reqn">N = nT</code> is the number of
spatial (<code class="reqn">n</code>) times the number of time observations (<code class="reqn">T</code>, with <code>tt=T</code>). Note that the observations
have organized such that <code class="reqn">Y = [Y_1',...,Y_T']'</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_tt">tt</code></td>
<td>
<p>single number greater or equal to 1. Denotes the number of time observations. <code class="reqn">tt = T</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_w">W</code></td>
<td>
<p>numeric, non-negative and row-stochastic <code class="reqn">n</code> by <code class="reqn">n</code> exogenous spatial weight matrix.
Must have zeros on the main diagonal.</p>
</td></tr>
<tr><td><code id="sar_+3A_z">Z</code></td>
<td>
<p>numeric <code class="reqn">N \times k_3</code> design matrix of independent variables.
The default value is a <code class="reqn">N \times 1</code> vector of ones (i.e. an intercept for the model).</p>
</td></tr>
<tr><td><code id="sar_+3A_niter">niter</code></td>
<td>
<p>single number greater or equal to 1, indicating the total number of draws.
Will be automatically coerced to integer. The default value is 200.</p>
</td></tr>
<tr><td><code id="sar_+3A_nretain">nretain</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of draws
kept after the burn-in. Will be automatically coerced to integer. The default value is 100.</p>
</td></tr>
<tr><td><code id="sar_+3A_rho_prior">rho_prior</code></td>
<td>
<p>list of prior settings for estimating <code class="reqn">\rho</code>,
generated by the smart constructor <code><a href="#topic+rho_priors">rho_priors</a></code></p>
</td></tr>
<tr><td><code id="sar_+3A_beta_prior">beta_prior</code></td>
<td>
<p>list containing priors for the slope coefficients,
generated by the smart constructor <code><a href="#topic+beta_priors">beta_priors</a></code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_sigma_prior">sigma_prior</code></td>
<td>
<p>list containing priors for the error variance <code class="reqn">\sigma^2</code>,
generated by the smart constructor <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The considered panel spatial autoregressive model (SAR) takes the form:
</p>
<p style="text-align: center;"><code class="reqn">
 Y_t = \rho W Y_t + Z_t \beta + \varepsilon_t,
 </code>
</p>

<p>with <code class="reqn">\varepsilon_t \sim N(0,I_n \sigma^2)</code>. The row-stochastic <code class="reqn">n</code> by <code class="reqn">n</code> spatial weight
matrix <code class="reqn">W</code> is non-negative and has zeros on the main diagonal. <code class="reqn">\rho</code> is a scalar spatial autoregressive parameter.
</p>
<p><code class="reqn">Y_t</code> (<code class="reqn">n \times 1</code>) collects the <code class="reqn">n</code> cross-sectional (spatial) observations for time
<code class="reqn">t=1,...,T</code>. <code class="reqn">Z_t</code> (<code class="reqn">n \times k_3</code>) is a matrix of explanatory variables.
<code class="reqn">\beta</code> (<code class="reqn">k_3 \times 1</code>) is an unknown slope parameter matrix.
</p>
<p>After vertically staking the <code class="reqn">T</code> cross-sections  <code class="reqn">Y=[Y_1',...,Y_T']'</code> (<code class="reqn">N \times 1</code>),
<code class="reqn">Z=[Z_1',...,Z_T']'</code> (<code class="reqn">N \times k_3</code>), with <code class="reqn">N=nT</code>, the final model can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
 Y = \rho \tilde{W}Y + Z \beta + \varepsilon,
</code>
</p>

<p>where <code class="reqn">\tilde{W}=I_T \otimes W</code> and <code class="reqn">\varepsilon \sim N(0,I_N \sigma^2)</code>. Note that the input
data matrices have to be ordered first by the cross-sectional spatial units and then stacked by time.
This is a wrapper function calling <code><a href="#topic+sdm">sdm</a></code> with no spatially lagged dependent variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20; tt = 10
dgp_dat = sim_dgp(n =n, tt = tt, rho = .5, beta3 = c(1,.5), sigma2 = .5)
res = sar(Y = dgp_dat$Y,tt = tt, W = dgp_dat$W,
          Z = dgp_dat$Z,niter = 100,nretain = 50)
</code></pre>

<hr>
<h2 id='sarw'>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial autoregressive model (SAR) with unknown spatial weight matrix</h2><span id='topic+sarw'></span>

<h3>Description</h3>

<p>The sampler uses independent  Normal-inverse-Gamma priors for the slope and variance parameters, as well as a four-parameter
beta prior for the spatial autoregressive parameter <code class="reqn">\rho</code>.
This is a wrapper function calling <code><a href="#topic+sdmw">sdmw</a></code> with no spatially lagged exogenous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarw(
  Y,
  tt,
  Z,
  niter = 100,
  nretain = 50,
  W_prior = W_priors(n = nrow(Y)/tt),
  rho_prior = rho_priors(),
  beta_prior = beta_priors(k = ncol(Z)),
  sigma_prior = sigma_priors()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarw_+3A_y">Y</code></td>
<td>
<p>numeric <code class="reqn">N \times 1</code> matrix containing the dependent variables, where <code class="reqn">N = nT</code> is the number of
spatial (<code class="reqn">n</code>) times the number of time observations (<code class="reqn">T</code>, with <code>tt=T</code>). Note that the observations
have organized such that <code class="reqn">Y = [Y_1',...,Y_T']'</code>.</p>
</td></tr>
<tr><td><code id="sarw_+3A_tt">tt</code></td>
<td>
<p>single number greater or equal to 1. Denotes the number of time observations. <code class="reqn">tt = T</code>.</p>
</td></tr>
<tr><td><code id="sarw_+3A_z">Z</code></td>
<td>
<p>numeric <code class="reqn">N \times k_3</code> design matrix of independent variables.
The default value is a <code class="reqn">N \times 1</code> vector of ones (i.e. an intercept for the model).</p>
</td></tr>
<tr><td><code id="sarw_+3A_niter">niter</code></td>
<td>
<p>single number greater or equal to 1, indicating the total number of draws.
Will be automatically coerced to integer. The default value is 100.</p>
</td></tr>
<tr><td><code id="sarw_+3A_nretain">nretain</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of draws
kept after the burn-in. Will be automatically coerced to integer. The default value is 50.</p>
</td></tr>
<tr><td><code id="sarw_+3A_w_prior">W_prior</code></td>
<td>
<p>list containing prior settings for estimating the spatial weight matrix <code class="reqn">W</code>.
Generated by the smart constructor <code><a href="#topic+W_priors">W_priors</a></code>.</p>
</td></tr>
<tr><td><code id="sarw_+3A_rho_prior">rho_prior</code></td>
<td>
<p>list of prior settings for estimating <code class="reqn">\rho</code>,
generated by the smart constructor <code><a href="#topic+rho_priors">rho_priors</a></code></p>
</td></tr>
<tr><td><code id="sarw_+3A_beta_prior">beta_prior</code></td>
<td>
<p>list containing priors for the slope coefficients <code class="reqn">\beta</code>,
generated by the smart constructor <code><a href="#topic+beta_priors">beta_priors</a></code>.</p>
</td></tr>
<tr><td><code id="sarw_+3A_sigma_prior">sigma_prior</code></td>
<td>
<p>list containing priors for the error variance <code class="reqn">\sigma^2</code>,
generated by the smart constructor <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The considered panel spatial autoregressive model (SAR) with unknown (<code class="reqn">n</code> by <code class="reqn">n</code>) spatial weight
matrix <code class="reqn">W</code> takes the form:
</p>
<p style="text-align: center;"><code class="reqn">
 Y_t = \rho W Y_t + Z \beta + \varepsilon_t,
 </code>
</p>

<p>with <code class="reqn">\varepsilon_t \sim N(0,I_n \sigma^2)</code> and <code class="reqn">W = f(\Omega)</code>. The <code class="reqn">n</code> by <code class="reqn">n</code>
matrix <code class="reqn">\Omega</code> is an unknown binary adjacency matrix with zeros on the main diagonal and
<code class="reqn">f(\cdot)</code> is the (optional) row-standardization function. <code class="reqn">\rho</code> is a scalar spatial autoregressive parameter.
</p>
<p><code class="reqn">Y_t</code> (<code class="reqn">n \times 1</code>) collects the <code class="reqn">n</code> cross-sectional (spatial) observations for time
<code class="reqn">t=1,...,T</code>. <code class="reqn">Z_t</code> (<code class="reqn">n \times k_3</code>) is a matrix of explanatory variables.
<code class="reqn">\beta</code> (<code class="reqn">k_3 \times 1</code>) is an unknown slope parameter vector.
</p>
<p>After vertically staking the <code class="reqn">T</code> cross-sections  <code class="reqn">Y=[Y_1',...,Y_T']'</code> (<code class="reqn">N \times 1</code>),
and <code class="reqn">Z=[Z_1', ..., Z_T']'</code> (<code class="reqn">N \times k_3</code>), with <code class="reqn">N=nT</code>. The final model can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
 Y = \rho \tilde{W}Y + Z \beta + \varepsilon,
</code>
</p>

<p>where <code class="reqn">\tilde{W}=I_T \otimes W</code> and <code class="reqn">\varepsilon \sim N(0,I_N \sigma^2)</code>. Note that the input
data matrices have to be ordered first by the cross-sectional spatial units and then stacked by time.
</p>
<p>Estimation usually even works well in cases of <code class="reqn">n &gt;&gt; T</code>. However, note that for applications with <code class="reqn">n &gt; 200</code> the
estimation process becomes computationally demanding and slow. Consider in this case reducing <code>niter</code> and
<code>nretain</code> and carefully check whether the posterior chains have converged.
</p>


<h3>Value</h3>

<p>List with posterior samples for the slope parameters, <code class="reqn">\rho</code>, <code class="reqn">\sigma^2</code>, <code class="reqn">W</code>,
and average direct, indirect, and total effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20; tt = 10
dgp_dat = sim_dgp(n =n, tt = tt, rho = .5, beta3 = c(.5,1),
            sigma2 = .05,n_neighbor = 3,intercept = TRUE)
res = sarw(Y = dgp_dat$Y,tt = tt,Z = dgp_dat$Z,niter = 20,nretain = 10)
</code></pre>

<hr>
<h2 id='sdm'>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial Durbin model (SDM) with exogenous spatial weight matrix.</h2><span id='topic+sdm'></span>

<h3>Description</h3>

<p>The sampler uses independent Normal-inverse-Gamma priors for the slope and variance parameters,
as well as a four-parameter prior for the spatial autoregressive parameter <code class="reqn">\rho</code>. The function is
used as an illustration on using the <code><a href="#topic+beta_sampler">beta_sampler</a></code>, <code><a href="#topic+sigma_sampler">sigma_sampler</a></code>,
and <code><a href="#topic+rho_sampler">rho_sampler</a></code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdm(
  Y,
  tt,
  W,
  X = matrix(0, nrow(Y), 0),
  Z = matrix(1, nrow(Y), 1),
  niter = 200,
  nretain = 100,
  rho_prior = rho_priors(),
  beta_prior = beta_priors(k = ncol(X) * 2 + ncol(Z)),
  sigma_prior = sigma_priors()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdm_+3A_y">Y</code></td>
<td>
<p>numeric <code class="reqn">N \times 1</code> matrix containing the dependent variables, where <code class="reqn">N = nT</code> is the number of
spatial (<code class="reqn">n</code>) times the number of time observations (<code class="reqn">T</code>, with <code>tt=T</code>). Note that the observations
have organized such that <code class="reqn">Y = [Y_1',...,Y_T']'</code>.</p>
</td></tr>
<tr><td><code id="sdm_+3A_tt">tt</code></td>
<td>
<p>single number greater or equal to 1. Denotes the number of time observations. <code class="reqn">tt = T</code>.</p>
</td></tr>
<tr><td><code id="sdm_+3A_w">W</code></td>
<td>
<p>numeric, non-negative and row-stochastic <code class="reqn">n</code> by <code class="reqn">n</code> exogenous spatial weight matrix.
Must have zeros on the main diagonal.</p>
</td></tr>
<tr><td><code id="sdm_+3A_x">X</code></td>
<td>
<p>numeric <code class="reqn">N \times k_1</code> design matrix of independent variables. These will be
automatically spatially lagged. If no spatially lagged variable is included in the model
a matrix with <code class="reqn">N</code> rows and zero columns should be supplied (the default value). Note:
either <code class="reqn">X</code> or <code class="reqn">Z</code> has to be a matrix with at least one column.</p>
</td></tr>
<tr><td><code id="sdm_+3A_z">Z</code></td>
<td>
<p>numeric <code class="reqn">N \times k_3</code> design matrix of independent variables which are not
spatially lagged. The default value is a <code class="reqn">N \times 1</code> vector of ones (i.e. an intercept for the model).
Note: either <code class="reqn">X</code> or <code class="reqn">Z</code> has to be a matrix with at least one column.</p>
</td></tr>
<tr><td><code id="sdm_+3A_niter">niter</code></td>
<td>
<p>single number greater or equal to 1, indicating the total number of draws.
Will be automatically coerced to integer. The default value is 200.</p>
</td></tr>
<tr><td><code id="sdm_+3A_nretain">nretain</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of draws
kept after the burn-in. Will be automatically coerced to integer. The default value is 100.</p>
</td></tr>
<tr><td><code id="sdm_+3A_rho_prior">rho_prior</code></td>
<td>
<p>list of prior settings for estimating <code class="reqn">\rho</code>,
generated by the smart constructor <code><a href="#topic+rho_priors">rho_priors</a></code></p>
</td></tr>
<tr><td><code id="sdm_+3A_beta_prior">beta_prior</code></td>
<td>
<p>list containing priors for the slope coefficients <code class="reqn">\beta</code>,
generated by the smart constructor <code><a href="#topic+beta_priors">beta_priors</a></code>. The ordering of the priors is:
(1) priors of <code class="reqn">X</code>, (2) priors of spatially lagged <code class="reqn">X</code>, (3) priors of <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="sdm_+3A_sigma_prior">sigma_prior</code></td>
<td>
<p>list containing priors for the error variance <code class="reqn">\sigma^2</code>,
generated by the smart constructor <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The considered panel spatial Durbin model (SDM) takes the form:
</p>
<p style="text-align: center;"><code class="reqn">
 Y_t = \rho W Y_t + X_t \beta_1 + W X_t \beta_2 + Z \beta_3 + \varepsilon_t,
 </code>
</p>

<p>with <code class="reqn">\varepsilon_t \sim N(0,I_n \sigma^2)</code>. The row-stochastic <code class="reqn">n</code> by <code class="reqn">n</code> spatial weight
matrix <code class="reqn">W</code> is non-negative and has zeros on the main diagonal. <code class="reqn">\rho</code> is a scalar spatial autoregressive parameter.
</p>
<p><code class="reqn">Y_t</code> (<code class="reqn">n \times 1</code>) collects the <code class="reqn">n</code> cross-sectional (spatial) observations for time
<code class="reqn">t=1,...,T</code>. <code class="reqn">X_t</code> (<code class="reqn">n \times k_1</code>) and <code class="reqn">Z_t</code> (<code class="reqn">n \times k_2</code>) are
matrices of explanatory variables, where the former will also be spatially lagged. <code class="reqn">\beta_1</code>
(<code class="reqn">k_1 \times 1</code>), <code class="reqn">\beta_2</code> (<code class="reqn">k_1 \times 1</code>) and <code class="reqn">\beta_3</code> (<code class="reqn">k_2 \times 1</code>)
are unknown slope parameter vectors.
</p>
<p>After vertically staking the <code class="reqn">T</code> cross-sections  <code class="reqn">Y=[Y_1',...,Y_T']'</code> (<code class="reqn">N \times 1</code>),
<code class="reqn">X=[X_1',...,X_T']'</code> (<code class="reqn">N \times k_1</code>) and <code class="reqn">Z=[Z_1', ..., Z_T']'</code> (<code class="reqn">N \times k_2</code>),
with <code class="reqn">N=nT</code>, the final model can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
 Y = \rho \tilde{W}Y + X \beta_1 + \tilde{W} X \beta_2 + Z \beta_3 + \varepsilon,
</code>
</p>

<p>where <code class="reqn">\tilde{W}=I_T \otimes W</code> and <code class="reqn">\varepsilon \sim N(0,I_N \sigma^2)</code>. Note that the input
data matrices have to be ordered first by the cross-sectional spatial units and then stacked by time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20; tt = 10
dgp_dat = sim_dgp(n = n, tt = tt, rho = .5, beta1 = c(.5,1), beta2 = c(-1,.5),
                  beta3 = c(1.5), sigma2 = .5)
res = sdm(Y = dgp_dat$Y, tt = tt,  W = dgp_dat$W, X = dgp_dat$X,
          Z = dgp_dat$Z, niter = 100, nretain = 50)
</code></pre>

<hr>
<h2 id='sdmw'>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial Durbin model (SDM) with unknown spatial weight matrix</h2><span id='topic+sdmw'></span>

<h3>Description</h3>

<p>The sampler uses independent Normal-inverse-Gamma priors for the slope and variance parameters, as well as a four-parameter
beta prior for the spatial autoregressive parameter <code class="reqn">\rho</code>. It is a wrapper around <code><a href="#topic+W_sampler">W_sampler</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmw(
  Y,
  tt,
  X = matrix(0, nrow(Y), 0),
  Z = matrix(1, nrow(Y), 1),
  niter = 100,
  nretain = 50,
  W_prior = W_priors(n = nrow(Y)/tt),
  rho_prior = rho_priors(),
  beta_prior = beta_priors(k = ncol(X) * 2 + ncol(Z)),
  sigma_prior = sigma_priors()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdmw_+3A_y">Y</code></td>
<td>
<p>numeric <code class="reqn">N \times 1</code> matrix containing the dependent variables, where <code class="reqn">N = nT</code> is the number of
spatial (<code class="reqn">n</code>) times the number of time observations (<code class="reqn">T</code>, with <code>tt=T</code>). Note that the observations
have organized such that <code class="reqn">Y = [Y_1',...,Y_T']'</code>.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_tt">tt</code></td>
<td>
<p>single number greater or equal to 1. Denotes the number of time observations. <code class="reqn">tt = T</code>.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_x">X</code></td>
<td>
<p>numeric <code class="reqn">N \times k_1</code> design matrix of independent variables. These will be
automatically spatially lagged. If no spatially lagged variable is included in the model
a matrix with <code class="reqn">N</code> rows and zero columns should be supplied (the default value). Note:
either <code class="reqn">X</code> or <code class="reqn">Z</code> has to be a matrix with at least one column.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_z">Z</code></td>
<td>
<p>numeric <code class="reqn">N \times k_3</code> design matrix of independent variables which are not
spatially lagged. The default value is a <code class="reqn">N \times 1</code> vector of ones (i.e. an intercept for the model).
Note: either <code class="reqn">X</code> or <code class="reqn">Z</code> has to be a matrix with at least one column.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_niter">niter</code></td>
<td>
<p>single number greater or equal to 1, indicating the total number of draws.
Will be automatically coerced to integer. The default value is 100.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_nretain">nretain</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of draws
kept after the burn-in. Will be automatically coerced to integer. The default value is 50.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_w_prior">W_prior</code></td>
<td>
<p>list containing prior settings for estimating the spatial weight matrix <code class="reqn">W</code>.
Generated by the smart constructor <code><a href="#topic+W_priors">W_priors</a></code>.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_rho_prior">rho_prior</code></td>
<td>
<p>list of prior settings for estimating <code class="reqn">\rho</code>,
generated by the smart constructor <code><a href="#topic+rho_priors">rho_priors</a></code></p>
</td></tr>
<tr><td><code id="sdmw_+3A_beta_prior">beta_prior</code></td>
<td>
<p>list containing priors for the slope coefficients <code class="reqn">\beta</code>,
generated by the smart constructor <code><a href="#topic+beta_priors">beta_priors</a></code>. The ordering of the priors is:
(1) priors of <code class="reqn">X</code>, (2) priors of spatially lagged <code class="reqn">X</code>, (3) priors of <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="sdmw_+3A_sigma_prior">sigma_prior</code></td>
<td>
<p>list containing priors for the error variance <code class="reqn">\sigma^2</code>,
generated by the smart constructor <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The considered panel spatial Durbin model (SDM) with unknown (<code class="reqn">n</code> by <code class="reqn">n</code>) spatial weight
matrix <code class="reqn">W</code> takes the form:
</p>
<p style="text-align: center;"><code class="reqn">
 Y_t = \rho W Y_t + X_t \beta_1 + W X_t \beta_2 + Z \beta_3 + \varepsilon_t,
 </code>
</p>

<p>with <code class="reqn">\varepsilon_t \sim N(0,I_n \sigma^2)</code> and <code class="reqn">W = f(\Omega)</code>. The <code class="reqn">n</code> by <code class="reqn">n</code>
matrix <code class="reqn">\Omega</code> is an unknown binary adjacency matrix with zeros on the main diagonal and
<code class="reqn">f(\cdot)</code> is the (optional) row-standardization function. <code class="reqn">\rho</code> is a scalar spatial autoregressive parameter.
</p>
<p><code class="reqn">Y_t</code> (<code class="reqn">n \times 1</code>) collects the <code class="reqn">n</code> cross-sectional (spatial) observations for time
<code class="reqn">t=1,...,T</code>. <code class="reqn">X_t</code> (<code class="reqn">n \times k_1</code>) and <code class="reqn">Z_t</code> (<code class="reqn">n \times k_2</code>) are
matrices of explanatory variables, where the former will also be spatially lagged. <code class="reqn">\beta_1</code>
(<code class="reqn">k_1 \times 1</code>), <code class="reqn">\beta_2</code> (<code class="reqn">k_1 \times 1</code>) and <code class="reqn">\beta_3</code> (<code class="reqn">k_2 \times 1</code>)
are unknown slope parameter vectors.
</p>
<p>After vertically staking the <code class="reqn">T</code> cross-sections  <code class="reqn">Y=[Y_1',...,Y_T']'</code> (<code class="reqn">N \times 1</code>),
<code class="reqn">X=[X_1',...,X_T']'</code> (<code class="reqn">N \times k_1</code>) and <code class="reqn">Z=[Z_1', ..., Z_T']'</code> (<code class="reqn">N \times k_2</code>),
with <code class="reqn">N=nT</code>. The final model can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
 Y = \rho \tilde{W}Y + X \beta_1 + \tilde{W} X \beta_2 + Z \beta_3 + \varepsilon,
</code>
</p>

<p>where <code class="reqn">\tilde{W}=I_T \otimes W</code> and <code class="reqn">\varepsilon \sim N(0,I_N \sigma^2)</code>. Note that the input
data matrices have to be ordered first by the cross-sectional spatial units and then stacked by time.
</p>
<p>Estimation usually even works well in cases of <code class="reqn">n &gt;&gt; T</code>. However, note that for applications with <code class="reqn">n &gt; 200</code> the
estimation process becomes computationally demanding and slow. Consider in this case reducing <code>niter</code> and
<code>nretain</code> and carefully check whether the posterior chains have converged.
</p>


<h3>Value</h3>

<p>List with posterior samples for the slope parameters, <code class="reqn">\rho</code>, <code class="reqn">\sigma^2</code>, <code class="reqn">W</code>,
and average direct, indirect, and total effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20; tt = 10
dgp_dat = sim_dgp(n =n, tt = tt, rho = .75, beta1 = c(.5,1),beta2 = c(-1,.5),
            beta3 = c(1.5), sigma2 = .05,n_neighbor = 3,intercept = TRUE)
res = sdmw(Y = dgp_dat$Y,tt = tt,X = dgp_dat$X,Z = dgp_dat$Z,niter = 20,nretain = 10)
</code></pre>

<hr>
<h2 id='sigma_priors'>Set prior specification for the error variance using an inverse Gamma distribution</h2><span id='topic+sigma_priors'></span>

<h3>Description</h3>

<p>Set prior specification for the error variance using an inverse Gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_priors(sigma_rate_prior = 0.001, sigma_shape_prior = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma_priors_+3A_sigma_rate_prior">sigma_rate_prior</code></td>
<td>
<p>Sigma rate prior parameter (scalar), default: <code class="reqn">0.001</code>.</p>
</td></tr>
<tr><td><code id="sigma_priors_+3A_sigma_shape_prior">sigma_shape_prior</code></td>
<td>
<p>Sigma shape prior parameter (scalar), default: <code class="reqn">0.001</code>.
</p>
<p>This function allows the user to specify priors for the error variance <code class="reqn">\sigma^2</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='sigma_sampler'>An R6 class for sampling for sampling <code class="reqn">\sigma^2</code></h2><span id='topic+sigma_sampler'></span>

<h3>Description</h3>

<p>This class samples nuisance parameter which an inverse Gamma prior from the conditional posterior.
Use the <a href="#topic+sigma_priors">sigma_priors</a> class for setup.
</p>


<h3>Format</h3>

<p>An <code>R6Class</code> generator object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>sigma_prior</code></dt><dd><p>The current <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</dd>
<dt><code>curr_sigma</code></dt><dd><p>The current value of <code class="reqn">\sigma^2</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-sigma_sampler-new"><code>sigma_sampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-sigma_sampler-sample"><code>sigma_sampler$sample()</code></a>
</p>
</li></ul>


<hr>
<a id="method-sigma_sampler-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>sigma_sampler$new(sigma_prior)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sigma_prior</code></dt><dd><p>The list returned by <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-sigma_sampler-sample"></a>



<h4>Method <code>sample()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>sigma_sampler$sample(Y, mu)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>The <code class="reqn">N</code> by <code class="reqn">1</code> matrix of responses</p>
</dd>
<dt><code>mu</code></dt><dd><p>The <code class="reqn">N</code> by <code class="reqn">1</code> matrix of means</p>
</dd>
</dl>

</div>



<hr>
<h2 id='sim_dgp'>Simulating from a data generating process</h2><span id='topic+sim_dgp'></span>

<h3>Description</h3>

<p>This function can be used to generate data from a data generating process for SDM,
SAR, SLX type models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dgp(
  n,
  tt,
  rho,
  beta1 = c(),
  beta2 = c(),
  beta3 = c(),
  sigma2,
  n_neighbor = 4,
  do_symmetric = FALSE,
  intercept = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_dgp_+3A_n">n</code></td>
<td>
<p>Number of spatial observations <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_tt">tt</code></td>
<td>
<p>Number of time observations <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_rho">rho</code></td>
<td>
<p>The true <code class="reqn">\rho</code> parameter</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_beta1">beta1</code></td>
<td>
<p>Vector of dimensions <code class="reqn">k_1 \times 1</code>. Provides the values for <code class="reqn">\beta_1</code> Defaults
to <code>c()</code>. Note: has to be of same length as <code class="reqn">\beta_2</code>.</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_beta2">beta2</code></td>
<td>
<p>Vector of dimensions <code class="reqn">k_1 \times 1</code>. Provides the values for <code class="reqn">\beta_2</code> Defaults
to <code>c()</code>. Note: has to be fo same length as <code class="reqn">\beta_1</code>.</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_beta3">beta3</code></td>
<td>
<p>Vector of dimensions <code class="reqn">k_2 \times 1</code>. Provides the values for <code class="reqn">\beta_3</code> Defaults
to <code>c()</code>.</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_sigma2">sigma2</code></td>
<td>
<p>The true <code class="reqn">\sigma^2</code> parameter for the DGP. Has to be a scalar larger than zero.</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>Number of neighbors for the generated <code class="reqn">n \times n</code> spatial weight <code class="reqn">W</code> matrix.
Defaults to 4.</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_do_symmetric">do_symmetric</code></td>
<td>
<p>Should the generated spatial weight matrix be symmetric? (default: FALSE)</p>
</td></tr>
<tr><td><code id="sim_dgp_+3A_intercept">intercept</code></td>
<td>
<p>Should the first column of <code class="reqn">Z</code> be an intercept? Defaults to <code>FALSE</code>.
If <code>intercept = TRUE</code>, <code class="reqn">\beta_3</code> has to be at least of length <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated spatial panel model takes the form
</p>
<p style="text-align: center;"><code class="reqn">
Y = \rho W Y + X \beta_1 + W X \beta_2 + Z \beta_3 +  \epsilon,
</code>
</p>

<p>with <code class="reqn">\epsilon \sim N(0,I_n\sigma^2)</code>. he function generates the <code class="reqn">N \times 1</code> vector <code class="reqn">Y</code>.
The elements of the explanatory variable matrices <code class="reqn">X</code>
(<code class="reqn">N \times k_1</code>) and <code class="reqn">Z</code> (<code class="reqn">N \times k_2</code>) are randomly generated from a Gaussian
distribution with zero mean and unity variance (<code class="reqn">N(0,1)</code>).
</p>
<p>The non-negative, row-stochastic <code class="reqn">n</code> by <code class="reqn">n</code> matrix <code class="reqn">W</code> is constructed using a k-nearest neighbor specification
based on a randomly generated spatial location pattern, with coordinates sampled from a standard normal distribution.
</p>
<p>Values for the parameters <code class="reqn">\beta_1</code>, <code class="reqn">\beta_2</code>, and <code class="reqn">\beta_3</code>, as well as
<code class="reqn">\rho</code> and <code class="reqn">\sigma^2</code> have to be provided by the user. The length of <code class="reqn">\beta_1</code> and
<code class="reqn">\beta_2</code> have to be equal.
</p>

<ul>
<li><p>A spatial Durbin model (SDM) is constructed if <code class="reqn">\rho</code> is not equal to zero and
<code class="reqn">\beta_1</code>, <code class="reqn">\beta_2</code>, and <code class="reqn">\beta_3</code> are all supplied by the user.
</p>
</li>
<li><p>A spatial autoregressive model is constructed if <code class="reqn">\rho</code> is not equal to zero and only
<code class="reqn">\beta_3</code> is supplied by the user.
</p>
</li>
<li><p>An SLX type model is constructed if <code class="reqn">\rho</code> is equal to zero and <code class="reqn">\beta_1</code>,
<code class="reqn">\beta_2</code> are supplied by the user.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the generated <code class="reqn">X</code>, <code class="reqn">Y</code> and <code class="reqn">W</code> and a list of parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SDM data generating process
dgp_dat = sim_dgp(n =20, tt = 10, rho = .5, beta1 = c(1,-1),
                  beta2 = c(0,.5),beta3 = c(.2),sigma2 = .5)
</code></pre>

<hr>
<h2 id='slxw'>A Markov Chain Monte Carlo (MCMC) sampler for the panel spatial SLX model with unknown spatial weight matrix</h2><span id='topic+slxw'></span>

<h3>Description</h3>

<p>The sampler uses independent Normal-inverse-Gamma priors for the slope and variance parameters.
It is a wrapper around <code><a href="#topic+W_sampler">W_sampler</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slxw(
  Y,
  tt,
  X = matrix(0, nrow(Y), 0),
  Z = matrix(1, nrow(Y), 1),
  niter = 100,
  nretain = 50,
  W_prior = W_priors(n = nrow(Y)/tt),
  beta_prior = beta_priors(k = ncol(X) * 2 + ncol(Z)),
  sigma_prior = sigma_priors()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slxw_+3A_y">Y</code></td>
<td>
<p>numeric <code class="reqn">N \times 1</code> matrix containing the dependent variables, where <code class="reqn">N = nT</code> is the number of
spatial (<code class="reqn">n</code>) times the number of time observations (<code class="reqn">T</code>, with <code>tt=T</code>). Note that the observations
have organized such that <code class="reqn">Y = [Y_1',...,Y_T']'</code>.</p>
</td></tr>
<tr><td><code id="slxw_+3A_tt">tt</code></td>
<td>
<p>single number greater or equal to 1. Denotes the number of time observations. <code class="reqn">tt = T</code>.</p>
</td></tr>
<tr><td><code id="slxw_+3A_x">X</code></td>
<td>
<p>numeric <code class="reqn">N \times k_1</code> design matrix of independent variables. These will be
automatically spatially lagged. If no spatially lagged variable is included in the model
a matrix with <code class="reqn">N</code> rows and zero columns should be supplied (the default value). Note:
either <code class="reqn">X</code> or <code class="reqn">Z</code> has to be a matrix with at least one column.</p>
</td></tr>
<tr><td><code id="slxw_+3A_z">Z</code></td>
<td>
<p>numeric <code class="reqn">N \times k_3</code> design matrix of independent variables which are not
spatially lagged. The default value is a <code class="reqn">N \times 1</code> vector of ones (i.e. an intercept for the model).
Note: either <code class="reqn">X</code> or <code class="reqn">Z</code> has to be a matrix with at least one column.</p>
</td></tr>
<tr><td><code id="slxw_+3A_niter">niter</code></td>
<td>
<p>single number greater or equal to 1, indicating the total number of draws.
Will be automatically coerced to integer. The default value is 100.</p>
</td></tr>
<tr><td><code id="slxw_+3A_nretain">nretain</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of draws
kept after the burn-in. Will be automatically coerced to integer. The default value is 50.</p>
</td></tr>
<tr><td><code id="slxw_+3A_w_prior">W_prior</code></td>
<td>
<p>list containing prior settings for estimating the spatial weight matrix <code class="reqn">W</code>.
Generated by the smart constructor <code><a href="#topic+W_priors">W_priors</a></code>.</p>
</td></tr>
<tr><td><code id="slxw_+3A_beta_prior">beta_prior</code></td>
<td>
<p>list containing priors for the slope coefficients <code class="reqn">\beta</code>,
generated by the smart constructor <code><a href="#topic+beta_priors">beta_priors</a></code>. The ordering of the priors is:
(1) priors of <code class="reqn">X</code>, (2) priors of spatially lagged <code class="reqn">X</code>, (3) priors of <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="slxw_+3A_sigma_prior">sigma_prior</code></td>
<td>
<p>list containing priors for the error variance <code class="reqn">\sigma^2</code>,
generated by the smart constructor <code><a href="#topic+sigma_priors">sigma_priors</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The considered spatial panel SLX model with unknown (<code class="reqn">n</code> by <code class="reqn">n</code>) spatial weight
matrix <code class="reqn">W</code> takes the form:
</p>
<p style="text-align: center;"><code class="reqn">
 Y_t = X_t \beta_1 + W X_t \beta_2 + Z \beta_3 + \varepsilon_t,
 </code>
</p>

<p>with <code class="reqn">\varepsilon_t \sim N(0,I_n \sigma^2)</code> and <code class="reqn">W = f(\Omega)</code>. The <code class="reqn">n</code> by <code class="reqn">n</code>
matrix <code class="reqn">\Omega</code> is an unknown binary adjacency matrix with zeros on the main diagonal and
<code class="reqn">f(\cdot)</code> is the (optional) row-standardization function.
</p>
<p><code class="reqn">Y_t</code> (<code class="reqn">n \times 1</code>) collects the <code class="reqn">n</code> cross-sectional (spatial) observations for time
<code class="reqn">t=1,...,T</code>. <code class="reqn">X_t</code> (<code class="reqn">n \times k_1</code>) and <code class="reqn">Z_t</code> (<code class="reqn">n \times k_2</code>) are
matrices of explanatory variables, where the former will also be spatially lagged. <code class="reqn">\beta_1</code>
(<code class="reqn">k_1 \times 1</code>), <code class="reqn">\beta_2</code> (<code class="reqn">k_1 \times 1</code>) and <code class="reqn">\beta_3</code> (<code class="reqn">k_2 \times 1</code>)
are unknown slope parameter vectors.
</p>
<p>After vertically staking the <code class="reqn">T</code> cross-sections  <code class="reqn">Y=[Y_1',...,Y_T']'</code> (<code class="reqn">N \times 1</code>),
<code class="reqn">X=[X_1',...,X_T']'</code> (<code class="reqn">N \times k_1</code>) and <code class="reqn">Z=[Z_1', ..., Z_T']'</code> (<code class="reqn">N \times k_2</code>),
with <code class="reqn">N=nT</code>. The final model can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
 Y = X \beta_1 + \tilde{W} X \beta_2 + Z \beta_3 + \varepsilon,
</code>
</p>

<p>where <code class="reqn">\tilde{W}=I_T \otimes W</code> and <code class="reqn">\varepsilon \sim N(0,I_N \sigma^2)</code>. Note that the input
data matrices have to be ordered first by the cross-sectional spatial units and then stacked by time.
</p>
<p>Estimation usually even works well in cases of <code class="reqn">n &gt;&gt; T</code>. However, note that for applications with <code class="reqn">n &gt; 200</code> the
estimation process becomes computationally demanding and slow. Consider in this case reducing <code>niter</code> and
<code>nretain</code> and carefully check whether the posterior chains have converged.
</p>


<h3>Value</h3>

<p>List with posterior samples for the slope parameters, <code class="reqn">\sigma^2</code>, <code class="reqn">W</code>,
and average direct, indirect, and total effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n = 20; tt = 10
dgp_dat = sim_dgp(n = 20, tt = 10, rho = 0, beta1 = c(1,-1),
                  beta2 = c(3,-2.5), beta3 = c(.2), sigma2 = .05,
                  n_neighbor = 3,intercept = TRUE)
res = slxw(Y = dgp_dat$Y, tt = tt, X = dgp_dat$X, Z = dgp_dat$Z,
                  niter = 20, nretain = 10)
</code></pre>

<hr>
<h2 id='W_priors'>Set prior specifications for the spatial weight matrix</h2><span id='topic+W_priors'></span>

<h3>Description</h3>

<p>Set prior specifications for the <code class="reqn">n</code> by <code class="reqn">n</code> spatial weight matrix <code class="reqn">W=f(\Omega)</code>,
where <code class="reqn">\Omega</code> is an <code class="reqn">n</code> by <code class="reqn">n</code> unknown binary adjacency matrix (with zeros on the
main diagonal), and <code class="reqn">f()</code> denotes the (optional) row-standardization function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_priors(
  n,
  W_prior = matrix(0.5, n, n),
  symmetric_prior = FALSE,
  row_standardized_prior = TRUE,
  nr_neighbors_prior = bbinompdf(0:(n - 1), nsize = n - 1, a = 1, b = 1, min_k = 0, max_k
    = n - 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="W_priors_+3A_n">n</code></td>
<td>
<p>The number of spatial observations</p>
</td></tr>
<tr><td><code id="W_priors_+3A_w_prior">W_prior</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">n</code> matrix of prior inclusion probabilities for <code class="reqn">W</code></p>
</td></tr>
<tr><td><code id="W_priors_+3A_symmetric_prior">symmetric_prior</code></td>
<td>
<p>Binary value. Should the estimated adjacency matrix <code class="reqn">\Omega</code> be symmetric (default: FALSE)?
if TRUE: <code class="reqn">\Omega</code> is forced symmetric; if FALSE: <code class="reqn">\Omega</code> not necessarily symmetric.</p>
</td></tr>
<tr><td><code id="W_priors_+3A_row_standardized_prior">row_standardized_prior</code></td>
<td>
<p>Binary value. Should the estimated <code class="reqn">W</code> matrix be row-standardized (default: TRUE)?
if TRUE: row-stochastic <code class="reqn">W</code>; if FALSE: <code class="reqn">W</code> not row-standardized.</p>
</td></tr>
<tr><td><code id="W_priors_+3A_nr_neighbors_prior">nr_neighbors_prior</code></td>
<td>
<p>An <code class="reqn">n</code> dimensional vector of prior weights on the number of neighbors
(i.e. the row sums of the adjacency matrix <code class="reqn">\Omega</code>), where the first element denotes the prior probability
of zero neighbors and the last those of <code class="reqn">n-1</code>. A prior using only fixed inclusion probabilities
for the entries in <code class="reqn">\Omega</code> would be an <code class="reqn">n</code> dimensional vector of <code class="reqn">1/n</code>. Defaults to
a <code><a href="#topic+bbinompdf">bbinompdf</a></code> prior, with prior parameters <code class="reqn">a = 1</code>, <code class="reqn">b = 1</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='W_sampler'>An R6 class for sampling the elements of <code class="reqn">W</code></h2><span id='topic+W_sampler'></span>

<h3>Description</h3>

<p>An R6 class for sampling the elements of <code class="reqn">W</code>
</p>
<p>An R6 class for sampling the elements of <code class="reqn">W</code>
</p>


<h3>Format</h3>

<p>An <code>R6Class</code> generator object
</p>


<h3>Details</h3>

<p>This class samples the spatial weight matrix. Use the function <a href="#topic+W_priors">W_priors</a> class for setup.
</p>
<p>The sampling procedure relies on conditional Bernoulli posteriors outlined in
Krisztin and Piribauer (2022).
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>W_prior</code></dt><dd><p>The current <code><a href="#topic+W_priors">W_priors</a></code></p>
</dd>
<dt><code>curr_w</code></dt><dd><p>numeric, non-negative <code class="reqn">n</code> by <code class="reqn">n</code> spatial weight matrix with zeros
on the main diagonal. Depending on the <code><a href="#topic+W_priors">W_priors</a></code> settings can be symmetric and/or
row-standardized.</p>
</dd>
<dt><code>curr_W</code></dt><dd><p>binary <code class="reqn">n</code> by <code class="reqn">n</code> spatial connectivity matrix <code class="reqn">\Omega</code></p>
</dd>
<dt><code>curr_A</code></dt><dd><p>The current spatial projection matrix <code class="reqn">I - \rho W</code>.</p>
</dd>
<dt><code>curr_AI</code></dt><dd><p>The inverse of <code>curr_A</code></p>
</dd>
<dt><code>curr_logdet</code></dt><dd><p>The current log-determinant of <code>curr_A</code></p>
</dd>
<dt><code>curr_rho</code></dt><dd><p>single number between -1 and 1 or NULL, depending on whether the sampler updates
the spatial autoregressive parameter <code class="reqn">\rho</code>. Set while invoking <code>initialize</code>
or using the function <code>set_rho</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-W_sampler-new"><code>W_sampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-W_sampler-set_rho"><code>W_sampler$set_rho()</code></a>
</p>
</li>
<li> <p><a href="#method-W_sampler-sample"><code>W_sampler$sample()</code></a>
</p>
</li></ul>


<hr>
<a id="method-W_sampler-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>W_sampler$new(W_prior, curr_rho = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>W_prior</code></dt><dd><p>The list returned by <code><a href="#topic+W_priors">W_priors</a></code></p>
</dd>
<dt><code>curr_rho</code></dt><dd><p>optional single number between -1 and 1. Value of the spatial autoregressive
parameter <code class="reqn">\rho</code>. Defaults to NULL, in which case no updates of the log-determinant, the spatial
projection matrix, and its inverse are carried out.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-W_sampler-set_rho"></a>



<h4>Method <code>set_rho()</code></h4>

<p>If the spatial autoregressive parameter <code class="reqn">\rho</code> is updated during the sampling procedure the log determinant, the
spatial projection matrix <code class="reqn">I - \rho W</code> and it's inverse must be updated. This function should be
used for a consistent update. At least the new scalar value for <code class="reqn">\rho</code> must be supplied.
</p>


<h5>Usage</h5>

<div class="r"><pre>W_sampler$set_rho(new_rho, newLogdet = NULL, newA = NULL, newAI = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_rho</code></dt><dd><p>single, number; must be between -1 and 1.</p>
</dd>
<dt><code>newLogdet</code></dt><dd><p>An optional value for the log determinant corresponding to <code>newW</code> and <code>curr_rho</code></p>
</dd>
<dt><code>newA</code></dt><dd><p>An optional value for the spatial projection matrix using <code>newW</code> and <code>curr_rho</code></p>
</dd>
<dt><code>newAI</code></dt><dd><p>An optional value for the matrix inverse of <code>newA</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-W_sampler-sample"></a>



<h4>Method <code>sample()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>W_sampler$sample(Y, curr_sigma, mu, lag_mu = matrix(0, nrow(tY), ncol(tY)))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">tt</code> matrix of responses</p>
</dd>
<dt><code>curr_sigma</code></dt><dd><p>The variance parameter <code class="reqn">\sigma^2</code></p>
</dd>
<dt><code>mu</code></dt><dd><p>The <code class="reqn">n</code> by <code class="reqn">tt</code> matrix of means.</p>
</dd>
<dt><code>lag_mu</code></dt><dd><p><code class="reqn">n</code> by <code class="reqn">tt</code> matrix of means that will be spatially lagged with
the estimated <code class="reqn">W</code>. Defaults to a matrix with zero elements.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Krisztin, T., and Piribauer, P. (2022) A Bayesian approach for the estimation
of weight matrices in spatial autoregressive models. <em>Spatial Economic Analysis</em>, 1-20.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
