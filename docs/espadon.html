<!DOCTYPE html><html><head><title>Help for package espadon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {espadon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#espadon-package'><p>espadon: Easy Study of Patient DICOM Data in Oncology</p></a></li>
<li><a href='#add.margin'><p>Adding or removing a margin to a volume</p></a></li>
<li><a href='#bin.closing'><p>Binary volume closing</p></a></li>
<li><a href='#bin.clustering'><p>Binary volume clustering</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#bin.dilation'><p>Binary volume dilation</p></a></li>
<li><a href='#bin.erosion'><p>Binary volume erosion</p></a></li>
<li><a href='#bin.from.roi'><p>Creation of a binary volume according to RoI</p></a></li>
<li><a href='#bin.from.vol'><p>Creation of a binary volume according to the voxel values of a volume</p></a></li>
<li><a href='#bin.intersection'><p>Intersection of two binaries</p></a></li>
<li><a href='#bin.inversion'><p>Inversion of a binary</p></a></li>
<li><a href='#bin.opening'><p>Binary volume opening</p></a></li>
<li><a href='#bin.subtraction'><p>Subtraction of two binaries</p></a></li>
<li><a href='#bin.sum'><p>Sum of two binaries</p></a></li>
<li><a href='#castlow.str'><p>Cast of a character string</p></a></li>
<li><a href='#castup.str'><p>Cast of a character string</p></a></li>
<li><a href='#dicom.browser'><p>DICOM raw data browser</p></a></li>
<li><a href='#dicom.parser'><p>Conversion of DICOM raw data into a dataframe or a list of DICOM TAG information</p></a></li>
<li><a href='#dicom.patient.anonymiser'><p>Anonymisation of a patient's DICOM files</p></a></li>
<li><a href='#dicom.raw.data.anonymizer'><p>DICOM anonymizer</p></a></li>
<li><a href='#dicom.raw.data.loader'><p>DICOM file loading in raw data</p></a></li>
<li><a href='#dicom.set.tag.value'><p>Change TAG value in DICOM raw data</p></a></li>
<li><a href='#dicom.tag.dictionary'><p>DICOM TAG dictionary</p></a></li>
<li><a href='#dicom.tag.parser'><p>DICOM TAG parser</p></a></li>
<li><a href='#dicom.to.Rdcm.converter'><p>Conversion of DICOM object into files that can be interpreted by the <span class="pkg">espadon</span></p>
package</a></li>
<li><a href='#dicom.viewer'><p>DICOM content viewer</p></a></li>
<li><a href='#display.2D.histo'><p>Display of a 2D histogram</p></a></li>
<li><a href='#display.3D.contour'><p>Display the 3D contours of the RoI</p></a></li>
<li><a href='#display.3D.mesh'><p>3D display of a mesh</p></a></li>
<li><a href='#display.3D.sections'><p>Display 3D sections of a patient</p></a></li>
<li><a href='#display.3D.stack'><p>Display in 3D the selected planes of an <span class="pkg">espadon</span> class volume</p></a></li>
<li><a href='#display.dV_dx'><p>Display of the volume density of a histogram</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#display.DVH'><p>Display of a DVH</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#display.DVH.pc'><p>Display of a cumulative DVH in percent of total volume</p></a></li>
<li><a href='#display.histo'><p>Display of the counts of a histogram</p></a></li>
<li><a href='#display.kplane'><p>Display of a plane of a volume</p></a></li>
<li><a href='#display.legend'><p>Display of the RoI legend</p></a></li>
<li><a href='#display.obj.links'><p>Display patient objects links</p></a></li>
<li><a href='#display.palette'><p>Display of the color scale of a color palette</p></a></li>
<li><a href='#display.plane'><p>Display the transverse frontal or sagittal view in the patient reference system</p></a></li>
<li><a href='#espadon.class'><p>ESPADON class</p></a></li>
<li><a href='#export'><p>Export espadon objects in dicom format</p></a></li>
<li><a href='#fan.beam'><p>Creation of pyramid fan object with constant angle step.</p></a></li>
<li><a href='#fan.planar'><p>Creation of pyramid fan object passing through pixels of a plane.</p></a></li>
<li><a href='#fan.sphere'><p>Creation of spherical fan object.</p></a></li>
<li><a href='#fan.to.voxel'><p>Indices of voxels crossed by a fan</p></a></li>
<li><a href='#get.extreme.pt'><p>Coordinates of the extreme points</p></a></li>
<li><a href='#get.ijk.from.index'><p>Conversion of the indices of a point into ijk vector</p></a></li>
<li><a href='#get.ijk.from.xyz'><p>Indices relating to the coordinates of the points</p></a></li>
<li><a href='#get.line'><p>Image value along an axis</p></a></li>
<li><a href='#get.obj.connection'><p>List of connections between objects</p></a></li>
<li><a href='#get.plane'><p>Extracting a plane from a volume</p></a></li>
<li><a href='#get.rigid.M'><p>Transfer matrix between two frames of reference</p></a></li>
<li><a href='#get.roi.connection'><p>List of inter-connections between RoI</p></a></li>
<li><a href='#get.value.from.ijk'><p>Value of the volume at a selection of DICOM indices</p></a></li>
<li><a href='#get.value.from.mesh'><p>Voxel value at a given depth of a mesh</p></a></li>
<li><a href='#get.value.from.xyz'><p>Voxel values on a selection of points</p></a></li>
<li><a href='#get.volume.from.bin'><p>Volume selected by binary volume</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#get.volume.from.roi'><p>Volume of a region of interest (RoI)</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#get.xyz.from.index'><p>Conversion of the indices of a point, into xyz coordinate vector in the patient's</p>
frame of reference</a></li>
<li><a href='#grid.equal'><p>Comparison of the grids of two volume objects</p></a></li>
<li><a href='#histo.2D'><p>2D histograms of 2 volumes</p></a></li>
<li><a href='#histo.DVH'><p>Cumulative Dose Volume Histogram</p></a></li>
<li><a href='#histo.from.bin'><p>Histogram according to a binary</p></a></li>
<li><a href='#histo.from.roi'><p>Histogram according to a RoI</p></a></li>
<li><a href='#histo.vol'><p>Histogram of a volume</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#load.obj.data'><p>Load data of an <span class="pkg">espadon</span> class object</p></a></li>
<li><a href='#load.obj.from.dicom'><p>Loading an <span class="pkg">espadon</span> object from DICOM files or folder</p></a></li>
<li><a href='#load.obj.from.Rdcm'><p>Loading an <span class="pkg">espadon</span> object from *.Rdcm file</p></a></li>
<li><a href='#load.patient.from.dicom'><p>Loading patient data from DICOM files</p></a></li>
<li><a href='#load.patient.from.Rdcm'><p>Loading patient data from *.Rdcm files</p></a></li>
<li><a href='#load.Rdcm.raw.data'><p>Loading a *.Rdcm file</p></a></li>
<li><a href='#load.T.MAT'><p>Loading of information about transfer matrices between frames of reference of</p>
patient Rdcm objects.</a></li>
<li><a href='#mesh.from.bin'><p>Creation of a mesh according to a binary volume</p></a></li>
<li><a href='#mesh.in.new.ref'><p>Change of frame of reference of a mesh</p></a></li>
<li><a href='#mesh.repair'><p>Repair of a mesh</p></a></li>
<li><a href='#mesh.spheric.proj'><p>Adding spherical coordinates to a mesh</p></a></li>
<li><a href='#nesting.bin'><p>Restrict volume to a binary selection</p></a></li>
<li><a href='#nesting.cube'><p>Restriction of a volume to a rectangular parallelepiped</p></a></li>
<li><a href='#nesting.roi'><p>Restrict volume to RoI</p></a></li>
<li><a href='#obj.create'><p>Espadon object creating</p></a></li>
<li><a href='#orientation.create'><p>Creation of orientation</p></a></li>
<li><a href='#pal.rainbow'><p>Rainbow palette</p></a></li>
<li><a href='#pal.RVV'><p>Conversion of Hounsfied Units to Realistic Volume Vizualization colors</p></a></li>
<li><a href='#plot'><p>plot a 2D cut of a 3D object</p></a></li>
<li><a href='#Rdcm.inventory'><p>Inventory of <span class="pkg">espadon</span> objects from Rdcm files</p></a></li>
<li><a href='#Rdcm.upgrade'><p>Updating Rdcm files.</p></a></li>
<li><a href='#ref.add'><p>Adding a frame of reference in T.MAT</p></a></li>
<li><a href='#ref.cutplane.add'><p>Adding volume's cutting planes frame of reference in T.MAT</p></a></li>
<li><a href='#ref.remove'><p>Deletion of a frame of reference in T.MAT</p></a></li>
<li><a href='#ref.srctodest.add'><p>Linking two existing frames of reference in T.MAT</p></a></li>
<li><a href='#rt.chi.index'><p>Chi index 2D - 3D</p></a></li>
<li><a href='#rt.gamma.index'><p>Gamma index 2D - 3D</p></a></li>
<li><a href='#rt.indices.from.bin'><p>Dosimetry, volume, conformity, homogeneity indices from binary selection</p></a></li>
<li><a href='#rt.indices.from.roi'><p>Dosimetry, volume, conformity, homogeneity indices from RoI</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#save.T.MAT'><p>Save a T.MAT class object</p></a></li>
<li><a href='#save.to.Rdcm'><p>Save a <span class="pkg">espadon</span> object in a pre-formatted *.Rdcm file</p></a></li>
<li><a href='#select.names'><p>Regions of Interest (RoI) indices</p></a></li>
<li><a href='#set.reference.obj'><p>Set the reference objects of a espadon object</p></a></li>
<li><a href='#sp.similarity.from.bin'><p>Volume-based spatial similarity metrics calculated from binary modality 3D volumes.</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#sp.similarity.from.mesh'><p>Distance-based spatial similarity metrics calculated from the mesh.</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#struct.clustering'><p>Clustering volumes by RoI</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#struct.from.bin'><p>Creation of struct class object from a binary volume</p></a></li>
<li><a href='#struct.from.mesh'><p>Creation of struct class object from an espadon mesh</p></a></li>
<li><a href='#struct.in.new.ref'><p>Change of frame of reference of a &quot;struct&quot; class object.</p></a></li>
<li><a href='#struct.merge'><p>Merging of structures into a new structure</p></a></li>
<li><a href='#study.deployment'><p>Deployment of DICOM files from multiple patients</p></a></li>
<li><a href='#toy.dicom.raw'><p>toy DICOM raw data</p></a></li>
<li><a href='#toy.load.patient'><p>Load a toy patient for test</p></a></li>
<li><a href='#vector.product'><p>Vector product of two vectors</p></a></li>
<li><a href='#vol.copy'><p>Creating a volume from another one</p></a></li>
<li><a href='#vol.create'><p>Volume creating</p></a></li>
<li><a href='#vol.from.bin'><p>Volume class object according to binary selection</p></a></li>
<li><a href='#vol.gradient'><p>Gradient of a volume</p></a></li>
<li><a href='#vol.in.new.ref'><p>Change of frame of reference of a volume</p></a></li>
<li><a href='#vol.median'><p>Median filter on a volume</p></a></li>
<li><a href='#vol.oversampling'><p>Oversampling a volume</p></a></li>
<li><a href='#vol.regrid'><p>Transform the grid of a volume class object into the grid of another</p></a></li>
<li><a href='#vol.repair'><p>repairing missing planes of volumes</p></a></li>
<li><a href='#vol.subsampling'><p>Subsampling a volume</p></a></li>
<li><a href='#vol.sum'><p>Sum of 2 volumes</p></a></li>
<li><a href='#xlsx.from.dcm'><p>Converting DICOM files to .xlsx files</p></a></li>
<li><a href='#xlsx.from.Rdcm'><p>Converting .Rdcm files to .xlsx files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Easy Study of Patient DICOM Data in Oncology</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Exploitation, processing and 2D-3D visualization of DICOM-RT files (structures, dosimetry, imagery) for medical physics and clinical research, in a patient-oriented perspective.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://espadon.cnrs.fr">https://espadon.cnrs.fr</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, DT, graphics, grDevices, igraph, js, mathjaxr,
Matrix, methods, misc3d, Morpho, openxlsx, progress, qs, Rcpp
(&ge; 1.0.10), Rdpack, rgl (&ge; 1.2.1), Rvcg (&ge; 0.22.1), shiny,
shinyWidgets, sodium, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr, Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, sf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-10 12:51:02 UTC; cfontbonne</td>
</tr>
<tr>
<td>Author:</td>
<td>Cathy Fontbonne [aut, cre] (LPC-CAEN, France),
  Jean-Marc Fontbonne [aut] (LPC-CAEN, France),
  Nathan Azemar [ctb] (LPC-CAEN, France)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cathy Fontbonne &lt;contact.espadon@lpccaen.in2p3.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-10 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='espadon-package'>espadon: Easy Study of Patient DICOM Data in Oncology</h2><span id='topic+espadon-package'></span><span id='topic+espadon'></span>

<h3>Description</h3>

<p>Exploitation, processing and 2D-3D visualization of DICOM-RT files (structures, dosimetry, imagery) for medical physics and clinical research, in a patient-oriented perspective.
</p>
<p><span class="pkg">espadon</span> works in a native way (user friendly):
</p>

<ul>
<li><p> on images (CT, MR, PT) and fully manages changes of referential (REG)
</p>
</li>
<li><p> on dosimetry (rt-dose)
</p>
</li>
<li><p> on structures (rt-struct)
</p>
</li></ul>

<p>It is also able to use any DICOM format file, as long as the user knows where to look for the information.
In addition to the simplified use of the above-mentioned formats, espadon contains many functions that allow the user to rework documents to produce new features that can be integrated into machine learning.
</p>
<p><strong><span class="pkg">espadon</span> integrates functionalities:</strong>
</p>

<ul>
<li><p> file loading, patient-centered information fusion
</p>
</li>
<li><p> handling of 3D images
</p>

<ul>
<li><p> changes of referential
</p>
</li>
<li><p> resampling, filtering
</p>
</li></ul>

</li>
<li><p> Contour manipulation, allowing the creation of new contours
</p>

<ul>
<li><p> fusion, intersection, inversion, erosion, dilation, opening, closing
</p>
</li>
<li><p> segmentation based on the image
</p>
</li></ul>

</li>
<li><p> 2D representation
</p>

<ul>
<li><p> with application of masks
</p>
</li>
<li><p> and transport of structures in the new reference frames
</p>
</li></ul>

</li>
<li><p> ... and 3D
</p>

<ul>
<li><p> production of mesh for the representation
</p>
</li></ul>

</li>
<li><p> for measurements
</p>

<ul>
<li><p> calculation of histograms (1D, 2D), DVH (integrating Monte-Carlo to simulate organ movements)
</p>
</li>
<li><p> Measurement of surfaces, radii of curvature (on the mesh) and volumes
</p>
</li></ul>

</li>
<li><p> measurement of standard dosimetry indicators
</p>
</li></ul>

<p>In the calculation flow, various objects are created and accessible to the developer for his own use.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Cathy Fontbonne <a href="mailto:contact.espadon@lpccaen.in2p3.fr">contact.espadon@lpccaen.in2p3.fr</a> (LPC-CAEN, France)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jean-Marc Fontbonne (LPC-CAEN, France)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Nathan Azemar (LPC-CAEN, France) [contributor]
</p>
</li></ul>

<p>Cathy &amp; Jean-Marc Fontbonne
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://espadon.cnrs.fr">https://espadon.cnrs.fr</a>
</p>
</li></ul>


<hr>
<h2 id='add.margin'>Adding or removing a margin to a volume</h2><span id='topic+add.margin'></span>

<h3>Description</h3>

<p>The <code>add.margin</code> function adds or subtracts a margin of the
rectangular parallelepiped circumscribed by a volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.margin(vol, xyz.margin, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.margin_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="add.margin_+3A_xyz.margin">xyz.margin</code></td>
<td>
<p>Vector of the 3 positive or negative x, y and z margins in
mm, in the frame of reference of volume cutting planes.</p>
</td></tr>
<tr><td><code id="add.margin_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object</p>
</td></tr>
<tr><td><code id="add.margin_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object.
If <code>description = NULL</code> (default value), it will be set to <code>vol$description</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), in which 3D volume is restricted  or increased by the
requested margins.
If the created volume exceeds the initial volume, new voxels are set to <code>NA</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+nesting.cube">nesting.cube</a>, <a href="#topic+nesting.roi">nesting.roi</a> and
<a href="#topic+nesting.bin">nesting.bin</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "ct", roi.name = "", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]

# Calculation of new volumes decreased by 10 mm in all directions.
new.CT &lt;- add.margin (CT, xyz.margin = c (-10, -10, 10), alias = "new CT")
# display of the CT before and after, in the middle cutting plane
z.mid &lt;- apply (get.extreme.pt (CT), 1, mean)[3]
display.plane (bottom = CT, view.coord = z.mid, bottom.col = pal.RVV(1000),
               bg = "#00ffff", interpolate = FALSE)
display.plane (bottom = new.CT, view.coord = z.mid, bottom.col = pal.RVV(1000),
               bg = "#00ffff", interpolate = FALSE)

</code></pre>

<hr>
<h2 id='bin.closing'>Binary volume closing</h2><span id='topic+bin.closing'></span>

<h3>Description</h3>

<p>The <code>bin.closing</code> function performs a morphological
operation of closing, using a sphere, on a &quot;volume&quot; class object of &quot;binary&quot; modality.
Closing is useful for :
</p>

<ul>
<li><p> filling holes that are smaller than the <code>radius</code>,
</p>
</li>
<li><p> merging two shapes close to each other.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bin.closing(vol, radius = 10, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.closing_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;binary&quot; modality</p>
</td></tr>
<tr><td><code id="bin.closing_+3A_radius">radius</code></td>
<td>
<p>Positive number, in millimeters. By default, radius = 10.</p>
</td></tr>
<tr><td><code id="bin.closing_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.closing_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol$object.alias, "closing r =", radius)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of &quot;binary&quot; modality
(see <a href="#topic+espadon.class">espadon.class</a> for class definitions),  with the same grid
as <code>vol</code>, in which <code>$vol3D.data</code> has been transformed  by the closing
operation.
</p>


<h3>Note</h3>

<p>Closing can be time consuming, try to reduce the <code>binary</code>
volume to the strict minimum, before any operations.
</p>


<h3>See Also</h3>

<p><a href="#topic+bin.dilation">bin.dilation</a>, <a href="#topic+bin.erosion">bin.erosion</a>,
<a href="#topic+bin.opening">bin.opening</a>, <a href="#topic+add.margin">add.margin</a>, <a href="#topic+nesting.cube">nesting.cube</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "mr", roi.name = "", 
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]

# generation of a binary volume
b &lt;- bin.from.vol(MR, min = 15, max = 30)

b.closing &lt;- bin.closing (b, radius = step)
display.plane (bottom = MR, top = b, main = "Before closing", 
               view.coord = -20, interpolate = FALSE)
display.plane (bottom = MR, top = b.closing, main = "After closing", 
               view.coord = -20, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.clustering'>Binary volume clustering
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+bin.clustering'></span>

<h3>Description</h3>

<p>The <code>bin.clustering</code> function groups and labels TRUE voxels
that have a 6-connectivity (i.e. sharing a common side).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.clustering(vol, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.clustering_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of <code>"binary"</code> modality</p>
</td></tr>
<tr><td><code id="bin.clustering_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.clustering_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol$object.alias,"clustering")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), of <code>"cluster"</code> modality. This object contains the
<code>$cluster.info</code> field, detailing the label and volumes in \(cm^{3}\)
of the different clusters. Note that the label &quot;0&quot; is used for the background.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "ct", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]

# generation of a binary volume
b &lt;- bin.from.vol(CT, min = -80, max = 20)

# Display of the n = 3 largest volumes
n &lt;- 3
cluster.b &lt;- bin.clustering (b)

col &lt;- c ("#00000000", rainbow (n))
breaks &lt;- seq (-0.5, n + 0.5, length.out = n+2)
display.plane (CT, top = b, main = "Before clustering",
               view.coord = 50, top.col = col, top.breaks = breaks, 
               interpolate = FALSE)
display.plane (CT, top = cluster.b, main = "After clustering", 
               view.coord = 50, top.col = col, top.breaks = breaks, 
               interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.dilation'>Binary volume dilation</h2><span id='topic+bin.dilation'></span>

<h3>Description</h3>

<p>The <code>bin.dilation</code> function enlarges a
&quot;volume&quot; class object, of <code>"binary"</code> modality, by means of
convolution with a sphere.
Dilation is useful for :
</p>

<ul>
<li><p> filling holes that are smaller than the <code>radius</code>,
</p>
</li>
<li><p> enlarging capes,
</p>
</li>
<li><p> filling narrow channels,
</p>
</li>
<li><p> merging two shapes close to each other.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bin.dilation(vol, radius = 10, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.dilation_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of <code>"binary"</code> modality</p>
</td></tr>
<tr><td><code id="bin.dilation_+3A_radius">radius</code></td>
<td>
<p>Positive number, in millimeters. By default, radius = 10.</p>
</td></tr>
<tr><td><code id="bin.dilation_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.dilation_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code>
(default value), it will be set to <code>paste (vol$object.alias, "dilataion r =", radius)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of <code>"binary"</code> modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with
the same grid as <code>vol</code>, in which the selected volume has been enlarged
by the <code>radius</code>.
</p>


<h3>Note</h3>

<p>Dilation can be time consuming, try to reduce the <code>binary</code>
volume to the strict minimum, before any operations.
</p>


<h3>See Also</h3>

<p><a href="#topic+bin.erosion">bin.erosion</a>, <a href="#topic+bin.opening">bin.opening</a>,
<a href="#topic+bin.closing">bin.closing</a>, <a href="#topic+add.margin">add.margin</a>, <a href="#topic+nesting.cube">nesting.cube</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "mr", roi.name = "", 
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]

# generation of a binary volume
b &lt;- bin.from.vol(MR, min = 15,max = 30)

b.dilation &lt;- bin.dilation (b, radius = step)
display.plane (bottom = MR, top = b, main = "Before dilation", 
               view.coord = -20, interpolate = FALSE)
display.plane (bottom = MR, top = b.dilation, main = "After dilation", 
               view.coord = -20,interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.erosion'>Binary volume erosion</h2><span id='topic+bin.erosion'></span>

<h3>Description</h3>

<p>The <code>bin.erosion</code> function decreases a
&quot;volume&quot; class object, of <code>"binary"</code> modality, by means of
convolution with a sphere.
Erosion is useful for :
</p>

<ul>
<li><p> removing volumes that are smaller than the <code>radius</code>,
</p>
</li>
<li><p> eliminating narrow capes,
</p>
</li>
<li><p> enlarging  channels,
</p>
</li>
<li><p> turning  peninsulas into islands.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bin.erosion(vol, radius = 10, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.erosion_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of <code>"binary"</code> modality</p>
</td></tr>
<tr><td><code id="bin.erosion_+3A_radius">radius</code></td>
<td>
<p>Positive number, in millimeters. By default, radius = 10.</p>
</td></tr>
<tr><td><code id="bin.erosion_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.erosion_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol$object.alias, "erosion r =", radius)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of <code>"binary"</code> modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with the same grid as
<code>vol</code>, in which the selected volume has been reduced
by the <code>radius</code>.
</p>


<h3>Note</h3>

<p>Erosion can be time consuming, try to reduce the <code>binary</code>
volume to the strict minimum, before any operations.
</p>


<h3>See Also</h3>

<p><a href="#topic+bin.dilation">bin.dilation</a>, <a href="#topic+bin.opening">bin.opening</a>,
<a href="#topic+bin.closing">bin.closing</a>, <a href="#topic+add.margin">add.margin</a>, <a href="#topic+nesting.cube">nesting.cube</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "mr", roi.name = "", 
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]

# generation of a binary volume
b &lt;- bin.from.vol(MR, min = 15,max = 30)

b.erosion &lt;- bin.erosion (b, radius = step)
display.plane (bottom = MR, top = b, main = "Before erosion", 
               view.coord = -20, interpolate = FALSE)
display.plane (bottom = MR, top = b.erosion, main = "After erosion", 
               view.coord = -20, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.from.roi'>Creation of a binary volume according to RoI</h2><span id='topic+bin.from.roi'></span>

<h3>Description</h3>

<p>The <code>bin.from.roi</code> function creates a &quot;volume&quot; class
object, of &quot;binary&quot; modality, in which all the voxels of a RoI are set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.from.roi(
  vol,
  struct,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  T.MAT = NULL,
  within = TRUE,
  alias = "",
  description = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.from.roi_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the <code>struct</code> object.
By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>struct</code>
object.
By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or <a href="#topic+load.T.MAT">load.T.MAT</a>. If
<code>T.MAT = NULL</code>, <code>struct$ref.pseudo</code> must be equal to
<code>vol$ref.pseudo</code> or set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_within">within</code></td>
<td>
<p>Boolean, defaults to <code>TRUE</code>. If <code>within = TRUE</code>, the
contours included in a RoI are managed,
depending on their <code>$level</code> field. If <code>within = FALSE</code>, only the
<code>$level = 0</code> fields of the RoI are used (i.e. only the external outlines).</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code>
(default value), it will be set to <code>struct$roi.info$roi.pseudo[roi.idx]</code>.</p>
</td></tr>
<tr><td><code id="bin.from.roi_+3A_...">...</code></td>
<td>
<p>additional argument such as verbose</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> must select
only one RoI.
</p>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of &quot;binary&quot; modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with the same grid as
<code>vol</code>, in which the voxels in the RoI are set to TRUE.
</p>


<h3>See Also</h3>

<p><a href="#topic+bin.from.vol">bin.from.vol</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 3
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), 
                             roi.name =  c("eye", "optical nerve", "brain"), 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

# "optical nerve" binary without inclusions management
bin &lt;- bin.from.roi (CT, struct = S, roi.sname = "left optical", 
                     alias = "left_optical_nerve", verbose = FALSE)
display.plane (CT, top = bin, struct = S,
               view.coord = S$roi.info[S$roi.info$roi.pseudo == "leftopticalnerve",]$Gz, 
               legend.shift = -80, interpolate = FALSE, main = "Left nerve selection")

## Not run: 
# with a smaller step
step &lt;- 1
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), 
                             roi.name =  c("eye", "optical nerve", "brain"), 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

# "optical nerve" binary without inclusions management
bin &lt;- bin.from.roi (CT, struct = S, roi.sname = "left optical", 
                     alias = "left_optical_nerve", within = FALSE,
                     verbose = FALSE)
display.plane (CT, top = bin, struct = S,
               view.coord = S$roi.info[S$roi.info$roi.pseudo == "leftopticalnerve",]$Gz, 
               legend.shift = -80, interpolate = FALSE, main = "Left nerve selection")

# "optical nerve" binary with inclusions management
bin &lt;- bin.from.roi (CT, struct = S, roi.sname = "left optical", 
                     alias = "left_optical_nerve", within = TRUE,
                     verbose = FALSE)
display.plane (CT, top = bin, struct = S,
               view.coord = S$roi.info[S$roi.info$roi.pseudo == "leftopticalnerve",]$Gz, 
               legend.shift = -80, interpolate = FALSE, main = "Left nerve selection") 

## End(Not run)
</code></pre>

<hr>
<h2 id='bin.from.vol'>Creation of a binary volume according to the voxel values of a volume</h2><span id='topic+bin.from.vol'></span>

<h3>Description</h3>

<p>The <code>bin.from.vol</code> function creates a &quot;volume&quot; class
object, of &quot;binary&quot; modality, in which the voxels fulfilling a condition on
their value are selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.from.vol(
  vol,
  min = -Inf,
  max = Inf,
  in.selection = TRUE,
  alias = "",
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.from.vol_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="bin.from.vol_+3A_min">min</code></td>
<td>
<p>Minimum value of the selected voxel. Default to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="bin.from.vol_+3A_max">max</code></td>
<td>
<p>Maximum value of the selected voxel. Default to <code>+Inf</code>.</p>
</td></tr>
<tr><td><code id="bin.from.vol_+3A_in.selection">in.selection</code></td>
<td>
<p>Boolean, defaults to <code>TRUE</code>. If <code>in.selection = FALSE</code>,
the selected pixels are those whose value is not between <code>min</code> and <code>max</code>.</p>
</td></tr>
<tr><td><code id="bin.from.vol_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.from.vol_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (min, vol$object.alias, max, sep = "&lt;=")</code> or if
<code>in.selection = FALSE</code>, <code>paste ("!(", description, ")")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of <code>"binary"</code> modality,
with the same grid as <code>vol</code>, in which the selected voxels
(i.e. set to TRUE) are those satisfying the following conditions :
</p>

<ul>
<li><p> If <code>in.selection = TRUE</code>, then <code>min &lt;= vol$vol3D.data &lt;= max</code>.
</p>
</li>
<li><p> If <code>in.selection = FALSE</code>, then <code>vol$vol3D.data &lt; min</code> or
<code>max &lt; vol$vol3D.data</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 3
patient &lt;- toy.load.patient (modality = "ct", roi.name = "", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]

bin.bone &lt;- bin.from.vol (CT, min = 300, max = 3000, alias = "bone")
display.plane (CT, top = bin.bone, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.intersection'>Intersection of two binaries</h2><span id='topic+bin.intersection'></span>

<h3>Description</h3>

<p>The <code>bin.intersection</code> function creates a &quot;volume&quot;
class object, of &quot;binary&quot; modality, representing the intersection (logical
<code>AND</code>) of two binary objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.intersection(vol1, vol2, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.intersection_+3A_vol1">vol1</code>, <code id="bin.intersection_+3A_vol2">vol2</code></td>
<td>
<p>&quot;volume&quot; class objects, of &quot;binary&quot; modality.</p>
</td></tr>
<tr><td><code id="bin.intersection_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.intersection_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol1$object.alias, "&amp;", vol2$object.alias)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of &quot;binary&quot; modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with the same grid as
<code>vol1</code> and <code>vol2</code>, intersection of <code>vol1</code> and <code>vol2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 3
patient &lt;- toy.load.patient (modality = c("mr", "rtstruct"), 
                             roi.name = c("brain", "labyrinth processing unit"), 
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]
S &lt;- patient$rtstruct[[1]]

z.brain &lt;- S$roi.info$Gz[S$roi.info$roi.pseudo == "brain"]

# Try to discriminate the processing unit with binary selections
bin.brain &lt;- bin.from.roi (MR, struct = S, roi.name = "brain",
                           alias = "brain", T.MAT = patient$T.MAT,
                           verbose = FALSE)
bin.pu.density &lt;- bin.from.vol (MR, min = 160)   
   
display.plane (MR, top = bin.pu.density, display.ref = S$ref.pseudo,
               view.coord = z.brain, T.MAT = patient$T.MAT, 
               interpolate = FALSE, main = "before brain intersection")                      
bin.pu &lt;- bin.intersection (vol1 = bin.pu.density, vol2 = bin.brain, 
                            alias = "processing unit")
display.plane (MR, top = bin.pu, display.ref = S$ref.pseudo,
               view.coord = z.brain, T.MAT = patient$T.MAT, 
               interpolate = FALSE, main = "after brain intersection")
</code></pre>

<hr>
<h2 id='bin.inversion'>Inversion of a binary</h2><span id='topic+bin.inversion'></span>

<h3>Description</h3>

<p>The <code>bin.inversion</code> function creates a &quot;volume&quot; class object,
of &quot;binary&quot; modality, representing the inverse (logical <code>NOT</code>) of another binary object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.inversion(vol, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.inversion_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;binary&quot; modality</p>
</td></tr>
<tr><td><code id="bin.inversion_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.inversion_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste ("!", vol$object.alias, sep = "")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of &quot;binary&quot; modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with the same grid as
<code>vol</code>, inverse of <code>vol</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), roi.name = "", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

bin.patient &lt;- bin.from.roi (CT, struct = S, roi.name = c ("patient"),
                             alias = "patient", verbose = FALSE)
inverse.patient &lt;- bin.inversion (bin.patient, alias = "inv (patient)")

display.plane(CT, top = inverse.patient, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.opening'>Binary volume opening</h2><span id='topic+bin.opening'></span>

<h3>Description</h3>

<p>The <code>bin.opening</code> function performs a morphological operation
of opening, using a sphere, on a &quot;volume&quot; class object of &quot;binary&quot; modality.
Opening is useful for :
</p>

<ul>
<li><p> removing volumes that are smaller than the <code>radius</code>,
</p>
</li>
<li><p> smoothing shapes.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bin.opening(vol, radius = 10, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.opening_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;binary&quot; modality.</p>
</td></tr>
<tr><td><code id="bin.opening_+3A_radius">radius</code></td>
<td>
<p>Positive number, in millimeters. By default, radius = 10.</p>
</td></tr>
<tr><td><code id="bin.opening_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.opening_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol$object.alias, "opening r =", radius)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of &quot;binary&quot; modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with the same grid as
<code>vol</code>, in which <code>$vol3D.data</code> has been transformed by the opening
operation.
</p>


<h3>Note</h3>

<p>Opening can be time consuming, try to reduce the <code>binary</code>
volume to the strict minimum, before any operations.
</p>


<h3>See Also</h3>

<p><a href="#topic+bin.dilation">bin.dilation</a>, <a href="#topic+bin.erosion">bin.erosion</a>,
<a href="#topic+bin.closing">bin.closing</a>, <a href="#topic+add.margin">add.margin</a>, <a href="#topic+nesting.cube">nesting.cube</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "mr", roi.name = "", 
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]

# generation of a binary volume
b &lt;- bin.from.vol(MR, min = 15,max = 30)

b.opening &lt;- bin.opening (b, radius = step)
display.plane (bottom = MR, top = b, main = "Before opening", 
               view.coord = -20, interpolate = FALSE)
display.plane (bottom = MR, top = b.opening, main = "After opening", 
               view.coord = -20, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.subtraction'>Subtraction of two binaries</h2><span id='topic+bin.subtraction'></span>

<h3>Description</h3>

<p>The <code>bin.subtraction</code> function creates a &quot;volume&quot; class
object of &quot;binary&quot; modality, representing the subtraction of two binary objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.subtraction(vol1, vol2, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.subtraction_+3A_vol1">vol1</code>, <code id="bin.subtraction_+3A_vol2">vol2</code></td>
<td>
<p>&quot;volume&quot; class objects of &quot;binary&quot; modality.</p>
</td></tr>
<tr><td><code id="bin.subtraction_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.subtraction_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol1$object.alias, "-", vol2$object.alias)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of &quot;binary&quot; modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with the same grid as
<code>vol1</code> and <code>vol2</code>, in which <code>vol2</code> is subtracted from <code>vol1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("mr", "rtstruct"), roi.name = "", 
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]
S &lt;- patient$rtstruct[[1]]

z.ptv &lt;- S$roi.info$Gz[S$roi.info$roi.pseudo == "ptv"]

# binaries
bin.patient &lt;- bin.from.roi (MR, struct = S, roi.name = "patient",
                           alias = "patient", T.MAT = patient$T.MAT,
                           verbose = FALSE)
bin.ptv &lt;- bin.from.roi (MR, struct = S, roi.name = "ptv",
                           alias = "ptv", T.MAT = patient$T.MAT,
                           verbose = FALSE)

#' calculation of the 'patient - ptv' binary
bin &lt;- bin.subtraction (bin.patient, bin.ptv, alias = "patient - ptv")
display.plane (MR, top = bin, view.coord = z.ptv, 
               display.ref = S$ref.pseudo, T.MAT = patient$T.MAT,
               interpolate = FALSE)
</code></pre>

<hr>
<h2 id='bin.sum'>Sum of two binaries</h2><span id='topic+bin.sum'></span>

<h3>Description</h3>

<p>The <code>bin.sum</code> function creates a &quot;volume&quot; class object
of &quot;binary&quot; modality, representing the sum (logical <code>OR</code>) of two binary
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.sum(vol1, vol2, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.sum_+3A_vol1">vol1</code>, <code id="bin.sum_+3A_vol2">vol2</code></td>
<td>
<p>&quot;volume&quot; class objects of &quot;binary&quot; modality.</p>
</td></tr>
<tr><td><code id="bin.sum_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="bin.sum_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol1$object.alias, "+", vol2$object.alias)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object of &quot;binary&quot; modality (see
<a href="#topic+espadon.class">espadon.class</a> for class definitions), with the same grid as
<code>vol1</code> and <code>vol2</code>, sum of <code>vol1</code> and <code>vol2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), roi.name = "eye",
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

z.leye&lt;- S$roi.info$Gz[S$roi.info$roi.pseudo == "lefteye"]


# 'left eye' et 'right eye' binaries
bin.left.eye &lt;- bin.from.roi (CT, struct = S, roi.sname = "lefteye",
                              alias = "left eye", verbose = FALSE)
bin.right.eye &lt;- bin.from.roi (CT, struct = S, roi.name = "righteye",
                               alias = "right eye", verbose = FALSE)
bin.eyes &lt;- bin.sum (bin.left.eye, bin.right.eye, alias = "eyes")

display.plane (CT, top = bin.eyes, struct = S, roi.sname = "eye",
               view.coord = z.leye, legend.shift = -90 ,
               interpolate = FALSE)
</code></pre>

<hr>
<h2 id='castlow.str'>Cast of a character string</h2><span id='topic+castlow.str'></span>

<h3>Description</h3>

<p>The <code>castlow.str</code> function converts a word to lowercase,
without accents and spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>castlow.str(st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="castlow.str_+3A_st">st</code></td>
<td>
<p>character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ASCII//TRANSLIT transcription of the word <code>st</code>,
without accents, spaces and in lowercase letters.
</p>


<h3>See Also</h3>

<p><a href="#topic+castup.str">castup.str</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>castlow.str (st = c("Right eye", "Left_Lung", "Right-Lung"))
</code></pre>

<hr>
<h2 id='castup.str'>Cast of a character string</h2><span id='topic+castup.str'></span>

<h3>Description</h3>

<p>The <code>castup.str</code> function converts a word to upper case,
without accents and spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>castup.str(st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="castup.str_+3A_st">st</code></td>
<td>
<p>character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ASCII//TRANSLIT transcription of the word <code>st</code>,
without accents, spaces and in capitals.
</p>


<h3>See Also</h3>

<p><a href="#topic+castlow.str">castlow.str</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>castup.str (st = c("Right eye", "Left_Lung", "Right-Lung"))
</code></pre>

<hr>
<h2 id='dicom.browser'>DICOM raw data browser</h2><span id='topic+dicom.browser'></span>

<h3>Description</h3>

<p>the <code>dicom.browser</code> function creates a dataframe describing
the tags contained in the raw data of a DICOM file, as well as the information
to access them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.browser(
  dicom.raw.data,
  nbTAG = 0,
  stop.tag = "",
  stop.level = 0,
  full.info = FALSE,
  tag.dictionary = dicom.tag.dictionary()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.browser_+3A_dicom.raw.data">dicom.raw.data</code></td>
<td>
<p>Raw vector, representing the binary extraction of the
DICOM file.</p>
</td></tr>
<tr><td><code id="dicom.browser_+3A_nbtag">nbTAG</code></td>
<td>
<p>Integer. If <code>nbTAG = 0</code> (default), and <code>stop.tag = ""</code>,
all the DICOM raw data is browsed. Otherwise, the function only browses the
first <code>nbTAG</code> tags.</p>
</td></tr>
<tr><td><code id="dicom.browser_+3A_stop.tag">stop.tag</code></td>
<td>
<p>Character string, representing the tag that stops the browse
of the <code>dicom.raw.data</code>.</p>
</td></tr>
<tr><td><code id="dicom.browser_+3A_stop.level">stop.level</code></td>
<td>
<p>Positive integer, specifying the encapsulation level of the
<code>stop.tag</code> in <code>dicom.raw.data</code>.</p>
</td></tr>
<tr><td><code id="dicom.browser_+3A_full.info">full.info</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, more information about the DICOM
data is returned.</p>
</td></tr>
<tr><td><code id="dicom.browser_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe if <code>dicom.raw.data</code> is DICOM raw data,
<code>NULL</code> otherwise.
</p>
<p>If <code>full.info = FALSE</code>, dataframe columns are
</p>

<ul>
<li><p> tag : the tags contained in <code>dicom.raw.data</code>,
</p>
</li>
<li><p> VR : value representation of the content of the tag,
</p>
</li>
<li><p> endian : the endianness of the tag content,
</p>
</li>
<li><p> start : the start address in <code>dicom.raw.data</code> of the tag content.
</p>
</li>
<li><p> stop : the stop address  in <code>dicom.raw.data</code> of the tag content.
</p>
</li></ul>

<p>If <code>full.info = TRUE</code>, the following columns are added :
</p>

<ul>
<li><p> encaps.load : If the tag contains nested data, this column gives
the number of bytes remaining until the end of the nesting. If there
are several levels of nesting, these numbers are collapsed and separated
by a space.
</p>
</li>
<li><p> load.start : the start address in <code>dicom.raw.data</code> of the tag load size.
</p>
</li>
<li><p> load.stop : the stop address in <code>dicom.raw.data</code>of the tag load size.
</p>
</li>
<li><p> tag.start : the start address in <code>dicom.raw.data</code> of the tag.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+dicom.raw.data.loader">dicom.raw.data.loader</a>, <a href="#topic+dicom.tag.parser">dicom.tag.parser</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DICOM information dataframe of the dummy raw data toy.dicom.raw ()
df &lt;- dicom.browser (toy.dicom.raw (), full.info = TRUE)
str (df)
</code></pre>

<hr>
<h2 id='dicom.parser'>Conversion of DICOM raw data into a dataframe or a list of DICOM TAG information</h2><span id='topic+dicom.parser'></span>

<h3>Description</h3>

<p>The <code>dicom.parser</code> function creates a dataframe or a list from
DICOM raw data. The created dataframe or list provides information about the
content of the DICOM TAGs included in the raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.parser(
  dcm,
  as.txt = TRUE,
  nested.list = FALSE,
  try.parse = FALSE,
  txt.sep = "\\",
  txt.length = 100,
  tag.dictionary = dicom.tag.dictionary(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.parser_+3A_dcm">dcm</code></td>
<td>
<p>espadon object of class &quot;volume&quot;, &quot;rtplan&quot;, &quot;struct&quot; provided by
DICOM files, or DICOM filename, or Rdcm filename, or raw vector  representing
the binary extraction of the DICOM file.</p>
</td></tr>
<tr><td><code id="dicom.parser_+3A_as.txt">as.txt</code></td>
<td>
<p>Boolean. If <code>as.txt = TRUE</code>, the function returns a
dataframe, a list otherwise.</p>
</td></tr>
<tr><td><code id="dicom.parser_+3A_nested.list">nested.list</code></td>
<td>
<p>Boolean. Only used if <code>as.txt = FALSE</code>. If
<code>nested.list = FALSE</code>, the returned list consists  of nested lists.</p>
</td></tr>
<tr><td><code id="dicom.parser_+3A_try.parse">try.parse</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the tag with unknown DICOM VR
(value representation) is converted into string if possible.</p>
</td></tr>
<tr><td><code id="dicom.parser_+3A_txt.sep">txt.sep</code></td>
<td>
<p>String. Used if <code>as.txt = TRUE</code>. Separator of the tag value elements.</p>
</td></tr>
<tr><td><code id="dicom.parser_+3A_txt.length">txt.length</code></td>
<td>
<p>Positive integer. Used if <code>as.txt = TRUE</code>. Maximum number
of letters in the representation of the TAG value.</p>
</td></tr>
<tr><td><code id="dicom.parser_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to <a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="dicom.parser_+3A_...">...</code></td>
<td>
<p>Additional argument <code>dicom.browser</code> when previously calculated by
<a href="#topic+dicom.browser">dicom.browser</a>. Argument dicom.raw.data (deprecated) replaced by
<code>dcm</code> argument. Argument <code>nb</code> or <code>dicom.nb</code> representing the
number of DICOM file, when <code>dcm</code> contains multiple DICOM files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of elements or a dataframe, depending on  <code>as.list</code>.
</p>
<p>If it returns a dataframe, the columns are names TAG, VR (value representation),
VM (value multiplicity), loadsize and Value. The field <code>$Value</code> is a string
representation of the true value.
</p>
<p>If it returns a list, each of its elements, named by a TAG, is either
a vector or a string, depending of the TAG included in <code>dicom.raw.data</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+dicom.raw.data.loader">dicom.raw.data.loader</a>, <a href="#topic+dicom.tag.parser">dicom.tag.parser</a>,
<a href="#topic+dicom.viewer">dicom.viewer</a>,<a href="#topic+xlsx.from.dcm">xlsx.from.dcm</a>,<a href="#topic+xlsx.from.Rdcm">xlsx.from.Rdcm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># content of the dummy raw data toy.dicom.raw (), as a list.
L &lt;- dicom.parser (toy.dicom.raw (), as.txt = FALSE)
str(L[40:57])

L &lt;- dicom.parser (toy.dicom.raw (), as.txt = FALSE, nested.list = TRUE)
str(L[40:45])

# content of the dummy raw data toy.dicom.raw (), as a dataframe.
L &lt;- dicom.parser (toy.dicom.raw (), as.txt = TRUE)
str (L)
</code></pre>

<hr>
<h2 id='dicom.patient.anonymiser'>Anonymisation of a patient's DICOM files</h2><span id='topic+dicom.patient.anonymiser'></span>

<h3>Description</h3>

<p>the <code>dicom.patient.anonymiser</code> function anonymises all DICOM
files in a patient's directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.patient.anonymiser(
  dcm.files,
  pat.dest.dir,
  offset = 0,
  new.PIN = "Anonymous patient",
  reset.private.tag = FALSE,
  tag.dictionary = dicom.tag.dictionary(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.patient.anonymiser_+3A_dcm.files">dcm.files</code></td>
<td>
<p>String vector, representing the list of the full names of the
DICOM files of the same patient, or its directories.</p>
</td></tr>
<tr><td><code id="dicom.patient.anonymiser_+3A_pat.dest.dir">pat.dest.dir</code></td>
<td>
<p>Character string,representing the full name of the patient's
directory, which will contain the patient's anonymized files.</p>
</td></tr>
<tr><td><code id="dicom.patient.anonymiser_+3A_offset">offset</code></td>
<td>
<p>Integer, default to 0. Each date of the DICOM will be shifted
by this offset expressed in days.</p>
</td></tr>
<tr><td><code id="dicom.patient.anonymiser_+3A_new.pin">new.PIN</code></td>
<td>
<p>Character string, representing the PIN remplacing the old one.</p>
</td></tr>
<tr><td><code id="dicom.patient.anonymiser_+3A_reset.private.tag">reset.private.tag</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, the value of tags that are
not in the <code>tag.dictionary</code> is removed.</p>
</td></tr>
<tr><td><code id="dicom.patient.anonymiser_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>, whose structure it must keep. This
dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="dicom.patient.anonymiser_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, a progress bar indicates loading progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creation of the <code>pat.dest.dir</code> directory, with anonymous DICOM files
</p>


<h3>Note</h3>

<p>The files are anonymized as follows:
</p>

<ul>
<li><p> Each date of the DICOM file will be shifted by <code>offset</code> expressed in days.
</p>
</li>
<li><p> Each patient's name, and patient'ID are remplaced by <code>new.PIN</code>
</p>
</li>
<li><p> All other patient data are deleted, except age, weight, height, gender
and shifted birthday.
</p>
</li>
<li><p> All address, phone, physician, operator, author, reviewer, service.
</p>
</li>
<li><p> If <code>reset.private.tag = TRUE</code>, the values of the tags not contained
in the <code>tag.dictionary</code> are deleted.
</p>
</li></ul>

<p>File names are composed of their modality and the SOP UID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy.dicom.raw () raw data to a temporary file pat.dir for testing.
temp &lt;- tempdir()
pat.dir &lt;- file.path (temp, "toy_dcm") 
dir.create (pat.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "toyrtplan", tmpdir = pat.dir,
                          fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)

# Files anonymisation
anonymous.pat.dir &lt;- file.path (temp, "anonymous") 
dicom.patient.anonymiser (dcm.files = pat.dir, pat.dest.dir = anonymous.pat.dir,
                          offset = 0, new.PIN = "Anonymous patient",
                          reset.private.tag = TRUE)
lf &lt;- list.files(anonymous.pat.dir, full.names = TRUE)  
dp &lt;- dicom.parser(lf[1])   
dp[grep("^[(]0008|^[(]0010", dp$TAG),]       

# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)            
</code></pre>

<hr>
<h2 id='dicom.raw.data.anonymizer'>DICOM anonymizer</h2><span id='topic+dicom.raw.data.anonymizer'></span>

<h3>Description</h3>

<p>the <code>dicom.raw.data.anonymizer</code> function anonymizes
<code>dicom.raw.data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.raw.data.anonymizer(
  dicom.raw.data,
  offset = 0,
  new.PIN = "Anonymous ",
  reset.private.tag = FALSE,
  tag.dictionary = dicom.tag.dictionary()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.raw.data.anonymizer_+3A_dicom.raw.data">dicom.raw.data</code></td>
<td>
<p>Raw vector, representing the binary extraction of the
DICOM file.</p>
</td></tr>
<tr><td><code id="dicom.raw.data.anonymizer_+3A_offset">offset</code></td>
<td>
<p>Integer, default to 0. Each date of the DICOM will be shifted
by this offset expressed in days.</p>
</td></tr>
<tr><td><code id="dicom.raw.data.anonymizer_+3A_new.pin">new.PIN</code></td>
<td>
<p>Character string, representing the PIN remplacing the old one.</p>
</td></tr>
<tr><td><code id="dicom.raw.data.anonymizer_+3A_reset.private.tag">reset.private.tag</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, the value of tags that are
not in the <code>tag.dictionary</code> is removed.</p>
</td></tr>
<tr><td><code id="dicom.raw.data.anonymizer_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>, whose structure it must keep. This
dataframe is used to parse DICOM files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an anonymyzed raw vector. See Note.
</p>


<h3>Note</h3>

<p>The raw data is anonymized as follows:
</p>

<ul>
<li><p> Each date of the DICOM file will be shifted by <code>offset</code> expressed in days.
</p>
</li>
<li><p> Each patient's name, and patient'ID are remplaced by <code>new.PIN</code>
</p>
</li>
<li><p> All other patient data are deleted, except age, weight, height, gender
and shifted birthday.
</p>
</li>
<li><p> All address, phone, physician, operator, author, reviewer, service.
</p>
</li>
<li><p> If <code>reset.private.tag = TRUE</code>, the values of the tags not contained in the <code>tag.dictionary</code> are
deleted.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># pseudomization of the dummy raw data toy.dicom.raw ()
an.raw.data &lt;- dicom.raw.data.anonymizer (toy.dicom.raw (), offset = -2)
data &lt;- dicom.parser (toy.dicom.raw ())
an.data &lt;- dicom.parser (an.raw.data) 

# Checking for differences
flag.dif &lt;- data$Value !=  an.data$Value  
df &lt;- cbind (data[flag.dif, c ("VM","Value")], an.data[flag.dif, "Value"])      
colnames (df) &lt;-   c ("VM","old Value","new Value")    
df                                     

# save data in a the new file
#############################
# new.file.name &lt;- "an.dcm"
# zz &lt;- file (new.file.name, "wb")
# writeBin (an.raw.data, zz, size = 1)
# close (zz)
</code></pre>

<hr>
<h2 id='dicom.raw.data.loader'>DICOM file loading in raw data</h2><span id='topic+dicom.raw.data.loader'></span>

<h3>Description</h3>

<p>the <code>dicom.raw.data.loader</code> function loads a DICOM file as
raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.raw.data.loader(dcm.filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.raw.data.loader_+3A_dcm.filename">dcm.filename</code></td>
<td>
<p>Character string, representing the full name of a DICOM file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of raw data from <code>dcm.filename</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+dicom.browser">dicom.browser</a>, <a href="#topic+dicom.tag.parser">dicom.tag.parser</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy.dicom.raw () raw data to a temporary file for testing.
pat.src.dir &lt;- file.path (tempdir(), "toy_dcm")
dir.create (pat.src.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "toyrtplan", tmpdir = pat.src.dir,
                          fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)

# loading of file
dicom.raw.data &lt;- dicom.raw.data.loader (dcm.filename)

# checks if it is consistent with the original raw data
all ( dicom.raw.data == toy.dicom.raw () )

# Cleaning  temporary directory
unlink (pat.src.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='dicom.set.tag.value'>Change TAG value in DICOM raw data</h2><span id='topic+dicom.set.tag.value'></span>

<h3>Description</h3>

<p>The <code>dicom.set.tag.value</code> function changes, in the DICOM
raw data, the values of the TAG whose VR is a string of characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.set.tag.value(
  dicom.raw.data,
  tag,
  tag.value,
  tag.dictionary = dicom.tag.dictionary(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.set.tag.value_+3A_dicom.raw.data">dicom.raw.data</code></td>
<td>
<p>Raw vector, representing the binary extraction of the DICOM file.</p>
</td></tr>
<tr><td><code id="dicom.set.tag.value_+3A_tag">tag</code></td>
<td>
<p>String vector, representing the list of tags whose value is to be
changed. See note 1.</p>
</td></tr>
<tr><td><code id="dicom.set.tag.value_+3A_tag.value">tag.value</code></td>
<td>
<p>String vector,representing the list of new tag values.</p>
</td></tr>
<tr><td><code id="dicom.set.tag.value_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to <a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="dicom.set.tag.value_+3A_...">...</code></td>
<td>
<p>Additional arguments <code>dicom.browser</code> when previously calculated by
<a href="#topic+dicom.browser">dicom.browser</a>  with argument <code>full.info = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a raw vector, with new tag values.
</p>


<h3>Note</h3>

<p>1- The list of tags included in the DICOM file are given by the first columns
of the dataframe provided by the functions <a href="#topic+dicom.browser">dicom.browser</a> and
<a href="#topic+dicom.parser">dicom.parser</a>.
</p>
<p>2-  The <code>dicom.set.tag.value</code> function may take some processing time.
To minimize this time, it is recommended to prepare in advance all the tags to
be modified, and use the <code>dicom.set.tag.value</code> function only once, as shown in
the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># change the value of tags "(0010,0010)" and "(0010,0020)" in the
# dummy raw data toy.dicom.raw ()
new.raw.data &lt;- dicom.set.tag.value (toy.dicom.raw (), 
                                     tag =  c ("(0010,0010)", "(0010,0020)"),
                                     tag.value = c ("unknown", "000001"))
# change control 
data &lt;- dicom.parser (new.raw.data) 
data[data$TAG %in% c ("(0010,0010)", "(0010,0020)"), ]

# save data in a the new file
#############################
# new.file.name &lt;- "new.dcm"
# zz &lt;- file (new.file.name, "wb")
# writeBin (new.raw.data  , zz, size = 1)
# close (zz)
</code></pre>

<hr>
<h2 id='dicom.tag.dictionary'>DICOM TAG dictionary</h2><span id='topic+dicom.tag.dictionary'></span>

<h3>Description</h3>

<p>The <code>dicom.tag.dictionary</code> function gives the dictionary of
tags used by default in the <span class="pkg">espadon</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.tag.dictionary(add.dict = c("raysearch.tag"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.tag.dictionary_+3A_add.dict">add.dict</code></td>
<td>
<p>Vector of the list of additional dictionaries. Put to NULL, if
no additional dictionary is requested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-column dataframe, describing the VR (value representation)
and the name of each DICOM TAG.
</p>
<p>This dataframe is the fusion of the &quot;nema.tag&quot; dictionary, provided
by <em>nema</em> <strong>[1]</strong>, with the dictionaries defined in the
<code>add.dict</code> vector:
</p>

<ul>
<li><p> &quot;raysearch.tag&quot; dictionary is provided by <em>RaySearch laboratories</em> <strong>[2]</strong>
</p>
</li></ul>



<h3>References</h3>

<p><strong>[1]</strong> DICOM nema (Online; accessed 2022-02-16).
&ldquo;Current Edition.&rdquo;
<a href="https://www.dicomstandard.org/current">https://www.dicomstandard.org/current</a>.
</p>
<p><strong>[2]</strong> Raysearch Laboratories (Online; accessed 2022-04-25).
&ldquo;RAYPLAN 11A, DICOM Conformance Statement.&rdquo;
<a href="https://www.raysearchlabs.com/siteassets/raystation-landing-page/dicom-conformance-statements/raystation-pdfs/rsl-d-rs-11a-dcs-en-1.0-2021-05-07-raystation-11a-dicom-conformance-statement.pdf">https://www.raysearchlabs.com/siteassets/raystation-landing-page/dicom-conformance-statements/raystation-pdfs/rsl-d-rs-11a-dcs-en-1.0-2021-05-07-raystation-11a-dicom-conformance-statement.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str (dicom.tag.dictionary ())
str (dicom.tag.dictionary (NULL))
</code></pre>

<hr>
<h2 id='dicom.tag.parser'>DICOM TAG parser</h2><span id='topic+dicom.tag.parser'></span>

<h3>Description</h3>

<p>the <code>dicom.tag.parser</code> function decodes the content between
two DICOM raw data addresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.tag.parser(start, stop, VR, endian, dicom.raw.data, try.parse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.tag.parser_+3A_start">start</code></td>
<td>
<p>Positive integer. Index of the first raw data to parse in the
<code>dicom.raw.data</code>.</p>
</td></tr>
<tr><td><code id="dicom.tag.parser_+3A_stop">stop</code></td>
<td>
<p>Positive integer. Index of the last raw data to parse in the
<code>dicom.raw.data</code>.</p>
</td></tr>
<tr><td><code id="dicom.tag.parser_+3A_vr">VR</code></td>
<td>
<p>Character string, representing the value representation of DICOM
data. See DICOM standard.</p>
</td></tr>
<tr><td><code id="dicom.tag.parser_+3A_endian">endian</code></td>
<td>
<p>Character string, equal to &quot;little&quot; or &quot;big&quot;.</p>
</td></tr>
<tr><td><code id="dicom.tag.parser_+3A_dicom.raw.data">dicom.raw.data</code></td>
<td>
<p>Raw vector, representing the binary extraction of the
DICOM file.</p>
</td></tr>
<tr><td><code id="dicom.tag.parser_+3A_try.parse">try.parse</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the value, with an undocumented VR,
is considered, as far as possible, as a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>dicom.raw.data</code> content between the addresses
<code>start</code> and <code>stop</code>. Depending on the representation of the value
(<code>VR</code>), it can be a character string or a numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creation of the toy.dicom.raw () addresses dataframe:
df &lt;- dicom.browser (toy.dicom.raw ())

# search for modality of toy.dicom.raw ()
idx &lt;- grep ("^[(]0008,0060[)]$", df$tag)
modality  &lt;- dicom.tag.parser (df$start[idx], df$stop[idx], df$VR[idx], 
                               df$endian[idx], toy.dicom.raw ())
modality
</code></pre>

<hr>
<h2 id='dicom.to.Rdcm.converter'>Conversion of DICOM object into files that can be interpreted by the <span class="pkg">espadon</span>
package</h2><span id='topic+dicom.to.Rdcm.converter'></span>

<h3>Description</h3>

<p>The <code>dicom.to.Rdcm.converter</code> function creates, for each DICOM
object, a *.Rdcm file usefull for using <span class="pkg">espadon</span> package. Each Rdcm file created is
referenced by the date of acquisition of the object (if it is not available,
its creation date), the patient's PIN, a reference number, an object number
in this reference system, and the object modality (mr, ct, rtstruct...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.to.Rdcm.converter(
  dcm.files,
  pat.dest.dir,
  update = TRUE,
  ignore.duplicates = FALSE,
  tag.dictionary = dicom.tag.dictionary(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.to.Rdcm.converter_+3A_dcm.files">dcm.files</code></td>
<td>
<p>String vector, representing the list of the full names of
the DICOM files of the same patient, or its directory.</p>
</td></tr>
<tr><td><code id="dicom.to.Rdcm.converter_+3A_pat.dest.dir">pat.dest.dir</code></td>
<td>
<p>Character string representing the full name of the patient's
directory, which will contain files converted into Rdcm objects.</p>
</td></tr>
<tr><td><code id="dicom.to.Rdcm.converter_+3A_update">update</code></td>
<td>
<p>Boolean. If set to <code>TRUE</code>, and if <code>pat.dest.dir</code>
contains previously converted files, these files are updated,even if they are
duplicated. They retain the same <span class="pkg">espadon</span> reference frame assignment.</p>
</td></tr>
<tr><td><code id="dicom.to.Rdcm.converter_+3A_ignore.duplicates">ignore.duplicates</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function ignores duplicated objects.</p>
</td></tr>
<tr><td><code id="dicom.to.Rdcm.converter_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="dicom.to.Rdcm.converter_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, a progress bar indicates the progress
of the conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the list of basenames of the created files.
</p>
<p>Returns <code>NULL</code> if there are no DICOM files in <code>dcm.files</code>
</p>


<h3>Note</h3>

<p>For each DICOM object, <code>dicom.to.Rdcm.converter</code>
creates a *.Rdcm file whose basename is made up of the date of the acquisition
(or creation date if previous not found), the patient's PIN, the pseudonym of
the frame of reference (&quot;ref1&quot;, &quot;ref2&quot;...), the number of the volume object
in the directory in this frame of reference (&quot;do1&quot;, &quot;do2&quot;...), and the object
modality (&quot;mr&quot;, &quot;ct&quot;, &quot;rtdose&quot;, &quot;rtstruct&quot;...).
</p>
<p>For example: <code>BASE = "20160514_a008e9ac_ref2_do1_mr"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy.dicom.raw () raw data to a temporary file for testing.
pat.src.dir &lt;- file.path (tempdir(), "PM_dcm") 
dir.create (pat.src.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "PM_rtplan", tmpdir = pat.src.dir,
                          fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)

# Create a temporary destination directory where the *.Rdcm file will be saved
pat.dest.dir &lt;- file.path (tempdir(), "PM_Rdcm")

dicom.to.Rdcm.converter (pat.src.dir, pat.dest.dir, update = TRUE)
# or
dicom.to.Rdcm.converter (dcm.filename, pat.dest.dir, update = TRUE)

list.files (pat.dest.dir)

# Cleaning  temporary directories
unlink (pat.src.dir, recursive = TRUE)
unlink (pat.dest.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='dicom.viewer'>DICOM content viewer</h2><span id='topic+dicom.viewer'></span>

<h3>Description</h3>

<p>the <code>dicom.viewer</code> function displays the data of a DICOM file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom.viewer(
  dcm,
  txt.sep = "\\",
  txt.length = 100,
  tag.dictionary = dicom.tag.dictionary(),
  height = 600,
  width = 900,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom.viewer_+3A_dcm">dcm</code></td>
<td>
<p>espadon object of class &quot;volume&quot;, &quot;rtplan&quot;, &quot;struct&quot; provided by
DICOM files, or DICOM filename, or Rdcm filename, or raw vector  representing
the binary extraction of the DICOM file.</p>
</td></tr>
<tr><td><code id="dicom.viewer_+3A_txt.sep">txt.sep</code></td>
<td>
<p>String. Used if <code>as.txt = TRUE</code>. Separator of the tag value elements.</p>
</td></tr>
<tr><td><code id="dicom.viewer_+3A_txt.length">txt.length</code></td>
<td>
<p>Positive integer. Used if <code>as.txt = TRUE</code>. Maximum number
of letters in the representation of the TAG value.</p>
</td></tr>
<tr><td><code id="dicom.viewer_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to <a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="dicom.viewer_+3A_height">height</code>, <code id="dicom.viewer_+3A_width">width</code></td>
<td>
<p>Height and width in pixel of the DICOM table.</p>
</td></tr>
<tr><td><code id="dicom.viewer_+3A_...">...</code></td>
<td>
<p>Additional argument <code>dicom.browser</code> when previously calculated by
<a href="#topic+dicom.browser">dicom.browser</a>. Argument <code>nb</code> or <code>dicom.nb</code> representing the
number of DICOM file, when <code>dcm</code> contains multiple DICOM files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the DICOM file description in a browser window.
</p>


<h3>See Also</h3>

<p><a href="#topic+xlsx.from.dcm">xlsx.from.dcm</a>, <a href="#topic+xlsx.from.Rdcm">xlsx.from.Rdcm</a>, <a href="#topic+dicom.parser">dicom.parser</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive ()) dicom.viewer (toy.dicom.raw ())
</code></pre>

<hr>
<h2 id='display.2D.histo'>Display of a 2D histogram</h2><span id='topic+display.2D.histo'></span>

<h3>Description</h3>

<p>The <code>display.2D.histo</code> function displays the density map of
a &quot;histo2D&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.2D.histo(
  histo.2D,
  add = TRUE,
  main = NULL,
  x.lab = NULL,
  y.lab = NULL,
  x.lim = NULL,
  y.lim = NULL,
  bg = "#000000",
  i.rng = NULL,
  display.mode = c("mono.color", "rainbow.color", "line"),
  col = "#ffffff",
  alpha = 1,
  line.pc.levels = c(1, 100),
  line.lwd = 2,
  line.lty = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.2D.histo_+3A_histo.2d">histo.2D</code></td>
<td>
<p>&quot;histo2D&quot; class object.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_add">add</code></td>
<td>
<p>Boolean indicating whether to display the background image.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_main">main</code></td>
<td>
<p>Title of the background image. If <code>main = NULL</code>,
the title indicates &quot;2D histogram&quot;.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_x.lab">x.lab</code></td>
<td>
<p>Label of the x-axis of the background image. If <code>x.lab = NULL</code>,
this label is <code>histo.2D$x.file.src</code></p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_y.lab">y.lab</code></td>
<td>
<p>Label of the y-axis of the background image. If <code>y.lab = NULL</code>,
this label is <code>histo.2D$y.file.src</code>.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_x.lim">x.lim</code></td>
<td>
<p>Vector, representing the range of the x-axis.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_y.lim">y.lim</code></td>
<td>
<p>Vector, representing the range of the y-axis.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_bg">bg</code></td>
<td>
<p>Background color of the image. By default, this color is black.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_i.rng">i.rng</code></td>
<td>
<p>Vector of 2 elements giving the minimum and the maximum intensity
of the image. If <code>i.rng = NULL</code>, then the minimum is 0 and the maximum the
maximum density.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_display.mode">display.mode</code></td>
<td>
<p>function display mode. See Details.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_col">col</code></td>
<td>
<p>Color of the color gradient in <code>display.mode = "mono.color"</code>,
or of the level lines in <code>display.mode = "line"</code>. By default, this color
is white.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_alpha">alpha</code></td>
<td>
<p>A number from 0 to 1, indicating the opacity of the image in
<code>"rainbow.color"</code> mode. Default alpha = 1.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_line.pc.levels">line.pc.levels</code></td>
<td>
<p>Vector of level lines in percent of maximum density
in <code>display.mode = "line"</code>. By default lines 1% and 100% are displayed.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_line.lwd">line.lwd</code></td>
<td>
<p>Line thickness of the level lines in <code>display.mode = "line"</code>.</p>
</td></tr>
<tr><td><code id="display.2D.histo_+3A_line.lty">line.lty</code></td>
<td>
<p>Type of lines for level lines in <code>display.mode = "line"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>display.mode</code> argument can be set to three values:
<code>"mono.color"</code>, <code>"rainbow.color"</code>, or <code>"line"</code>. The 2D
histogram graph is displayed by default in <code>"mono.color"</code> mode.
</p>

<ul>
<li><p> The <code>"mono.color"</code> mode displays a gradient of the color defined
by the col argument, depending on the intensity of <code>$density.map</code> 2-dimensional
array.
</p>
</li>
<li><p> The <code>"rainbow.color"</code> mode makes a display according to the
<code>"rainbow"</code> palette, while managing the opacity of the colors.
</p>
</li>
<li><p> The <code>"line"</code> mode draws level lines defined in percent by the
<code>line.pc.levels</code> argument.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a display of the density map of <code>histo.2D</code>. This one must
be an object of class &quot;histo2D&quot;. See <a href="#topic+espadon.class">espadon.class</a> for
class definitions.
</p>


<h3>See Also</h3>

<p><a href="#topic+histo.2D">histo.2D</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "mr", "rtstruct"), 
                             roi.name =  "brain", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
MR &lt;- patient$mr[[1]]
S &lt;- patient$rtstruct[[1]]
T.MAT &lt;- patient$T.MAT

# restriction of the volume around the RoI
CT.on.roi &lt;- nesting.roi (CT, S, roi.name = "brain", vol.restrict = TRUE,
                          xyz.margin = c (1, 1, 1), alias = CT$description)
MR.on.CT &lt;- vol.regrid (vol = MR, back.vol = CT.on.roi, interpolate = TRUE,
                        T.MAT = T.MAT, alias = CT$description,
                        description = NULL)
# selection of voxels included in the RoI.
roi.bin &lt;- bin.from.roi (vol = CT.on.roi, struct = S, roi.sname = "brain",
                         verbose = FALSE)
MR.select &lt;- vol.from.bin (MR.on.CT, roi.bin, alias = MR$description)
CT.select &lt;- vol.from.bin (CT.on.roi, roi.bin, alias = CT$description)
# 2D histogram
H2D &lt;- histo.2D (MR.select, CT.select, x.breaks = seq (50, 400, 10),
			  y.breaks = seq (50, 400, 10), alias = "H2D MR1 MR2")
display.2D.histo (H2D, display.mode = "mono.color", col = "#ffff00", 
                  main ="mono color mode")
display.2D.histo (H2D, display.mode = "rainbow.color", main ="rainbow mode")
display.2D.histo (H2D, display.mode = "line", main ="level lines mode",
                  line.pc.levels = c (0, 25, 50, 75, 100), col = "#ff0000")
</code></pre>

<hr>
<h2 id='display.3D.contour'>Display the 3D contours of the RoI</h2><span id='topic+display.3D.contour'></span>

<h3>Description</h3>

<p>The <code>display.3D.contour</code> function performs a 3D display of the selected RoI in the chosen coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.3D.contour(
  struct,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  roi.col = NULL,
  roi.print = FALSE,
  roi.lwd = 1,
  roi.cex = 1,
  display.ref = struct$ref.pseudo,
  T.MAT = NULL,
  FoR.axis = FALSE,
  FoR.col = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.3D.contour_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object. See <a href="#topic+espadon.class">espadon.class</a> for
class definitions.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the <code>struct</code> object.
By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>struct</code> object.
By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_roi.col">roi.col</code></td>
<td>
<p>Color of the RoI. If <code>roi.col = NULL</code> (default),the RoI
colors are specified in the <code>struct$roi.info</code>.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_roi.print">roi.print</code></td>
<td>
<p>Boolean vector indicating whether to display the pseudonym
of the RoI.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_roi.lwd">roi.lwd</code></td>
<td>
<p>Line width of the RoI, by default at 1.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_roi.cex">roi.cex</code></td>
<td>
<p>Numeric character expansion factor of RoI name if
<code>roi.print = TRUE</code>, defaults to 1.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_display.ref">display.ref</code></td>
<td>
<p>Pseudonym of frame of reference of the display.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or
<a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT = NULL</code>, <code>display.ref</code> must be equal to <code>NULL</code> or to
<code>struct$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_for.axis">FoR.axis</code></td>
<td>
<p>Boolean or numeric, by default set to <code>FALSE</code>. If <code>FoR.axis = TRUE</code>,
the function displays 200 mm length director vectors of the frame of reference.
If <code>FoR.axis</code> is numeric, it represent the length in mm of the director vectors.</p>
</td></tr>
<tr><td><code id="display.3D.contour_+3A_for.col">FoR.col</code></td>
<td>
<p>Color of the frame of reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are all
<code>NULL</code>, then all of the RoI are selected.
</p>


<h3>Value</h3>

<p>If the concerned regions of interest (RoI) <code>struct</code> exist,
it displays the 3D contours of these RoI in the current <span class="pkg">RGL</span> window if it exists,
in a new window otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "rtstruct", roi.name = "eye",
                             dxyz = rep (step, 3))
library (rgl)
open3d()
bg3d ("black")
display.3D.contour (struct = patient$rtstruct[[1]], roi.print = TRUE)
</code></pre>

<hr>
<h2 id='display.3D.mesh'>3D display of a mesh</h2><span id='topic+display.3D.mesh'></span>

<h3>Description</h3>

<p>The <code>display.3D.mesh</code> function performs a 3D display of a mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.3D.mesh(mesh, display.ref = mesh$ref.pseudo, T.MAT = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.3D.mesh_+3A_mesh">mesh</code></td>
<td>
<p>&quot;mesh&quot; class object, created by the <a href="#topic+mesh.from.bin">mesh.from.bin</a>
function. See <a href="#topic+espadon.class">espadon.class</a> for class definitions.</p>
</td></tr>
<tr><td><code id="display.3D.mesh_+3A_display.ref">display.ref</code></td>
<td>
<p>Character string. Pseudonym of the frame of reference used for display.</p>
</td></tr>
<tr><td><code id="display.3D.mesh_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or
<a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT</code> is <code>NULL</code>, <code>mesh</code> must be
displayed in <code>display.ref = mesh$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="display.3D.mesh_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="rgl.html#topic+shade3d">shade3d</a> as <code>color</code>, <code>specular</code>,
<code>alpha</code>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a display of <code>mesh</code> in the current <span class="pkg">RGL</span> window if it exists,
in a new window otherwise.
</p>


<h3>See Also</h3>

<p><a href="#topic+mesh.from.bin">mesh.from.bin</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), roi.name = "",
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

# creation of the patient mesh
bin &lt;- bin.from.roi (CT, struct = S, roi.name = "patient", verbose = FALSE)
mesh.patient &lt;- mesh.from.bin (bin, alias = "patient", verbose = FALSE)

# display of the patient mesh, with transparency
library (rgl)
open3d()
display.3D.mesh (mesh.patient, color = "burlywood2", specular = "#404040")
</code></pre>

<hr>
<h2 id='display.3D.sections'>Display 3D sections of a patient</h2><span id='topic+display.3D.sections'></span>

<h3>Description</h3>

<p>The <code>display.3D.sections</code> function displays transverse,
sagittal and frontal views at a point in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.3D.sections(
  vol,
  cross.pt = c(0, 0, 0),
  display.ref = vol$ref.pseudo,
  T.MAT = NULL,
  col = grey.colors(10, start = 0, end = 1, alpha = c(rep(0, 1), rep(1, 9))),
  breaks = NULL,
  trans = TRUE,
  sagi = TRUE,
  front = TRUE,
  border = TRUE,
  border.col = "#379DA2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.3D.sections_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object to display. See <a href="#topic+espadon.class">espadon.class</a> for
class definitions.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_cross.pt">cross.pt</code></td>
<td>
<p>Vector of x, y, z coordinates, representing the cross point of the 3 planes.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_display.ref">display.ref</code></td>
<td>
<p>Character string. Pseudonym of the frame of reference used for display.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or
<a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT</code> is <code>NULL</code>, <code>vol</code> must be
displayed in <code>display.ref = vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_col">col</code></td>
<td>
<p>Vector, representing the color palette of the image. Transparent
colors are not represented.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_breaks">breaks</code></td>
<td>
<p>One of :
</p>

<ul>
<li> <p><code>NULL</code> : the minimum and the maximum value of the <code>vol</code> define the range.
</p>
</li>
<li><p> Vector giving the breakpoints of each color.
</p>
</li></ul>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_trans">trans</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the transverse view is displayed.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_sagi">sagi</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the sagittal view is displayed.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_front">front</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the frontal view is displayed.</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_border">border</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the borders of the planes are displayed</p>
</td></tr>
<tr><td><code id="display.3D.sections_+3A_border.col">border.col</code></td>
<td>
<p>Color of planes borders</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a display of transverse, sagittal and frontal views of <code>vol</code>
at <code>cross.pt</code>  in the current <span class="pkg">RGL</span> window if it exists, in a new
window otherwise. Palette colors are managed by <code>col</code> and <code>breaks</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "ct", dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]

library (rgl)
open3d()
display.3D.sections(CT, cross.pt= c(0, 50, 80),
                    col= pal.RVV(200, alpha= c(rep(0,90), rep(1,110))))
</code></pre>

<hr>
<h2 id='display.3D.stack'>Display in 3D the selected planes of an <span class="pkg">espadon</span> class volume</h2><span id='topic+display.3D.stack'></span>

<h3>Description</h3>

<p>The <code>display.3D.stack</code> function displays in 3D the requested
cutting planes of a &quot;volume&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.3D.stack(
  vol,
  k.idx = unique(vol$k.idx[seq(1, vol$n.ijk[3], length.out = 10)]),
  display.ref = vol$ref.pseudo,
  T.MAT = NULL,
  col = grey.colors(10, start = 0, end = 1, alpha = c(rep(0, 1), rep(1, 9))),
  breaks = NULL,
  cube = TRUE,
  border = TRUE,
  ktext = TRUE,
  line.col = "#379DA2",
  line.lwd = 1,
  cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.3D.stack_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object to display.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_k.idx">k.idx</code></td>
<td>
<p>vector of cutting plane numbers to be displayed, to be chosen in
<code>vol$k.idx</code>. By default <code>k.idx</code> is a vector of 10 uniformly
distributed cutting planes in the volume.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_display.ref">display.ref</code></td>
<td>
<p>Character string. Pseudonym of the frame of reference used
for display.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT</code> is <code>NULL</code>, <code>vol</code> must
be displayed in <code>display.ref = vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_col">col</code></td>
<td>
<p>Vector, representing the color palette of the image. Transparent
colors are not represented.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_breaks">breaks</code></td>
<td>
<p>One of :
</p>

<ul>
<li> <p><code>NULL</code> : The minimum and the maximum value of the <code>vol</code> define
the range.
</p>
</li>
<li><p> Vector giving the breakpoints of each color.
</p>
</li></ul>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_cube">cube</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the &quot;volume&quot; edges are displayed.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_border">border</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the borders of the planes defined
in <code>k.idx</code> are displayed.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_ktext">ktext</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the  selected cutting plane numbers
are displayed.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_line.col">line.col</code></td>
<td>
<p>Color of cube, planes and texts displayed.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_line.lwd">line.lwd</code></td>
<td>
<p>Line width of the border and cube, by default at 1.</p>
</td></tr>
<tr><td><code id="display.3D.stack_+3A_cex">cex</code></td>
<td>
<p>Numeric character expansion factor of displayed plan numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a display of the <code>k.idx</code> cutting planes of <code>vol</code>,
in the current <span class="pkg">RGL</span> window if it exists, in a new window otherwise. The
colors of the palettes are managed by <code>col</code> and <code>breaks</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "ct", dxyz = rep (step, 3))

# display o 3 planes
library (rgl)
open3d()
display.3D.stack (patient$ct[[1]],
                  col = pal.RVV (200, alpha = c(rep(0,90), rep (1, 110))))
</code></pre>

<hr>
<h2 id='display.dV_dx'>Display of the volume density of a histogram
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+display.dV_dx'></span>

<h3>Description</h3>

<p>The <code>display.dV_dx</code> function displays the volume density
of a &quot;histo&quot; class object. Y-units are \(cm^3.Gy^{-1}\).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.dV_dx(
  histo,
  add = FALSE,
  xgrid = TRUE,
  ygrid = TRUE,
  MC.plot = FALSE,
  MC.col = grey.colors(4, rev = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.dV_dx_+3A_histo">histo</code></td>
<td>
<p>&quot;histo&quot; class object. See <a href="#topic+espadon.class">espadon.class</a> for class definitions.</p>
</td></tr>
<tr><td><code id="display.dV_dx_+3A_add">add</code></td>
<td>
<p>Boolean indicating whether to display the background image.</p>
</td></tr>
<tr><td><code id="display.dV_dx_+3A_xgrid">xgrid</code></td>
<td>
<p>Boolean indicating the display of the x grid.</p>
</td></tr>
<tr><td><code id="display.dV_dx_+3A_ygrid">ygrid</code></td>
<td>
<p>Boolean indicating the display of the y grid.</p>
</td></tr>
<tr><td><code id="display.dV_dx_+3A_mc.plot">MC.plot</code></td>
<td>
<p>Boolean. If <code>MC.plot = TRUE</code>, then <code>display.dV_dx</code> displays,
if they exist, the quantile zones (Prob = 0, .025, .25, .5, .75, .975, 1)
of variations in volume density.</p>
</td></tr>
<tr><td><code id="display.dV_dx_+3A_mc.col">MC.col</code></td>
<td>
<p>Character string, a valid palette with 4 colours corresponding
to 100%, 95%, 50% and median of MC data.</p>
</td></tr>
<tr><td><code id="display.dV_dx_+3A_...">...</code></td>
<td>
<p>Additional arguments xlab, ylab, xlim, ylim, main, type, col, lwd, lty and log
managed by the <a href="base.html#topic+plot">plot</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of the differential histogram included in <code>histo</code>,
with its median, and the quantile areas (0%-100%), (2.5%-97.5%) and (25%-75%)
of the <code>histo$dv_dx</code> variations, if they exist.
</p>


<h3>See Also</h3>

<p><a href="#topic+display.histo">display.histo</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"),
                             roi.name = "gizzard", dxyz = rep (step, 3), 
                             beam.nb = 3)

# Calculation of the differential histogram
H &lt;- histo.from.roi (patient$rtdose[[1]], patient$rtstruct[[1]], 
                     roi.name = "gizzard", breaks = seq (0, 60, by = 2))
display.dV_dx (H, lwd = 2, col = '#00ff00', ylim = c (0,10))
</code></pre>

<hr>
<h2 id='display.DVH'>Display of a DVH
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+display.DVH'></span>

<h3>Description</h3>

<p>The <code>display.DVH</code> function displays the
Dose Volume Histogram of a &quot;dvh&quot; class object. Y-units are \(cm^3\).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.DVH(
  dvh,
  add = FALSE,
  xgrid = TRUE,
  ygrid = TRUE,
  MC.plot = FALSE,
  MC.col = grey.colors(4, rev = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.DVH_+3A_dvh">dvh</code></td>
<td>
<p>&quot;dvh&quot; class object.</p>
</td></tr>
<tr><td><code id="display.DVH_+3A_add">add</code></td>
<td>
<p>Boolean indicating whether to display the background image.</p>
</td></tr>
<tr><td><code id="display.DVH_+3A_xgrid">xgrid</code></td>
<td>
<p>Boolean indicating the display of the x grid.</p>
</td></tr>
<tr><td><code id="display.DVH_+3A_ygrid">ygrid</code></td>
<td>
<p>Boolean indicating the display of the y grid.</p>
</td></tr>
<tr><td><code id="display.DVH_+3A_mc.plot">MC.plot</code></td>
<td>
<p>Boolean. If <code>MC.plot = TRUE</code>, then <code>display.DVH</code> displays,
if they exist, the quantile zones (Prob = 0, .025, .25, .5, .75, .975, 1)
of MC DVH variations.</p>
</td></tr>
<tr><td><code id="display.DVH_+3A_mc.col">MC.col</code></td>
<td>
<p>Character string, a valid palette with 4 colours corresponding
to 100%, 95%, 50% and median of MC data.</p>
</td></tr>
<tr><td><code id="display.DVH_+3A_...">...</code></td>
<td>
<p>Additional arguments xlab, ylab, xlim, ylim, main, type, col, lwd, lty and log
managed by the <a href="base.html#topic+plot">plot</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of the cumulative histogram included in <code>dvh</code>,
with its median, and the quantile areas (0%-100%), (2.5%-97.5%) and (25%-75%)
of the <code>dvh$vol</code> variations, if they exist.
</p>


<h3>See Also</h3>

<p><a href="#topic+display.DVH.pc">display.DVH.pc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DVH without MCMC
# loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 5 
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), roi.name = "",
                             dxyz = rep (step, 3), beam.nb = 3)
H &lt;- histo.from.roi (patient$rtdose[[1]], patient$rtstruct[[1]], roi.name = "ptv", 
                     breaks = seq (0, 60, by = 2))
DVH &lt;- histo.DVH (H)
display.DVH (DVH)

## Not run: 
# loading of toy-patient objects
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), 
                             roi.name = "gizzard",
                             dxyz = c (2, 2, 2), beam.nb = 3)

# Calculation of the histogram
H &lt;- histo.from.roi (patient$rtdose[[1]], patient$rtstruct[[1]], 
                     roi.name = "gizzard", 
                     breaks = seq (0, 60, by = 1), MC = 100)

# DVH
DVH &lt;- histo.DVH (H)
display.DVH (DVH, MC.plot = TRUE, ylim = c (0, 40))

## End(Not run)
</code></pre>

<hr>
<h2 id='display.DVH.pc'>Display of a cumulative DVH in percent of total volume</h2><span id='topic+display.DVH.pc'></span>

<h3>Description</h3>

<p>The <code>display.DVH.pc</code> function displays the Dose Volume
Histogram of &quot;dvh&quot; class object. Y-units are percents of total volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.DVH.pc(
  dvh,
  add = FALSE,
  xgrid = TRUE,
  ygrid = TRUE,
  MC.plot = FALSE,
  MC.col = grey.colors(4, rev = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.DVH.pc_+3A_dvh">dvh</code></td>
<td>
<p>&quot;dvh&quot; class object. See <a href="#topic+espadon.class">espadon.class</a> for class definitions.</p>
</td></tr>
<tr><td><code id="display.DVH.pc_+3A_add">add</code></td>
<td>
<p>Boolean indicating whether to display the background image.</p>
</td></tr>
<tr><td><code id="display.DVH.pc_+3A_xgrid">xgrid</code></td>
<td>
<p>Boolean indicating the display of the x grid.</p>
</td></tr>
<tr><td><code id="display.DVH.pc_+3A_ygrid">ygrid</code></td>
<td>
<p>Boolean indicating the display of the y grid.</p>
</td></tr>
<tr><td><code id="display.DVH.pc_+3A_mc.plot">MC.plot</code></td>
<td>
<p>Boolean. If <code>MC.plot = TRUE</code>, then <code>display.DVH.pc</code>
displays, if they exist, the quantile zones (Prob = 0, .025, .25, .5, .75, .975, 1)
of MC DVH variations.</p>
</td></tr>
<tr><td><code id="display.DVH.pc_+3A_mc.col">MC.col</code></td>
<td>
<p>Character string, a valid palette with 4 colours corresponding
to 100%, 95%, 50% and median of MC data.</p>
</td></tr>
<tr><td><code id="display.DVH.pc_+3A_...">...</code></td>
<td>
<p>Arguments xlab, ylab, xlim, ylim, main, type, col, lwd, lty and log
managed by the <a href="base.html#topic+plot">plot</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot in percent of total volume of the cumulative histogram
included in <code>dvh</code>, with its median, and the quantile areas (0%-100%),
(2.5%-97.5%) and (25%-75%) of the <code>dvh$pcv</code> variations, if they exist.
</p>


<h3>See Also</h3>

<p><a href="#topic+display.DVH">display.DVH</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), 
                             roi.name = "gizzard", dxyz = rep (step, 3), 
                             beam.nb = 3)

# Calculation of the histogram
H &lt;- histo.from.roi (patient$rtdose[[1]], patient$rtstruct[[1]], 
                     roi.name = "gizzard", 
                     breaks = seq (0, 60, by = 1))

# DVH
DVH &lt;- histo.DVH (H)
display.DVH.pc (DVH)
</code></pre>

<hr>
<h2 id='display.histo'>Display of the counts of a histogram</h2><span id='topic+display.histo'></span>

<h3>Description</h3>

<p>The <code>display.histo</code> function displays the counts of
&quot;histo&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.histo(
  histo,
  add = FALSE,
  xgrid = TRUE,
  ygrid = TRUE,
  MC.plot = FALSE,
  MC.col = grey.colors(4, rev = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.histo_+3A_histo">histo</code></td>
<td>
<p>&quot;histo&quot; class object.</p>
</td></tr>
<tr><td><code id="display.histo_+3A_add">add</code></td>
<td>
<p>Boolean indicating whether to display the background image.</p>
</td></tr>
<tr><td><code id="display.histo_+3A_xgrid">xgrid</code></td>
<td>
<p>Boolean indicating the display of the x grid.</p>
</td></tr>
<tr><td><code id="display.histo_+3A_ygrid">ygrid</code></td>
<td>
<p>Boolean indicating the display of the y grid.</p>
</td></tr>
<tr><td><code id="display.histo_+3A_mc.plot">MC.plot</code></td>
<td>
<p>Boolean. If <code>MC.plot = TRUE</code>, then <code>display.histo</code> displays,
if they exist, the quantile zones (Prob = 0, .05, .25, .5, .75, .95, 1)
of variations in counts.</p>
</td></tr>
<tr><td><code id="display.histo_+3A_mc.col">MC.col</code></td>
<td>
<p>Character string, a valid palette with 4 colours corresponding to
100%, 95%, 50% and median of MC data.</p>
</td></tr>
<tr><td><code id="display.histo_+3A_...">...</code></td>
<td>
<p>Additional arguments xlab, ylab, xlim, ylim, main, type, col, lwd, lty and log
managed by the <a href="base.html#topic+plot">plot</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of the counts included in <code>histo</code>, with its median,
and the quantile areas (0%-100%), (2.5%-97.5%) and (25%-75%) of the <code>histo$counts</code>
variations, if they exist.
</p>


<h3>See Also</h3>

<p><a href="#topic+display.dV_dx">display.dV_dx</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 3
patient &lt;- toy.load.patient (modality = "ct", dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]

# histogram and display
H &lt;- histo.vol (CT, breaks = seq (3, ceiling (CT$max.pixel), 1), 
                alias = "CT_hist")
display.histo (H, log = "y", lwd = 2)
</code></pre>

<hr>
<h2 id='display.kplane'>Display of a plane of a volume</h2><span id='topic+display.kplane'></span>

<h3>Description</h3>

<p>The <code>display.kplane</code> function displays the requested plane
of a &quot;volume&quot; class object. This function is low-level, used for example
in the function <a href="#topic+display.plane">display.plane</a> with more intuitive arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.kplane(
  vol,
  k = vol$k.idx[ceiling(length(vol$k.idx)/2)],
  pt00 = c(0, 0),
  dxy = c(1, 1),
  col = grey.colors(255, start = 0, end = 1),
  breaks = NULL,
  sat.transp = FALSE,
  add = FALSE,
  main = NULL,
  abs.lab = "i",
  ord.lab = "j",
  flip = FALSE,
  flop = FALSE,
  bg = "#000000",
  abs.rng = NULL,
  ord.rng = NULL,
  interpolate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.kplane_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object to display. See <a href="#topic+espadon.class">espadon.class</a>
for class definitions.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_k">k</code></td>
<td>
<p>Number of the plane to display. By default <code>k</code> is located at
mid-plane of the volume.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_pt00">pt00</code></td>
<td>
<p>Origin point of the displayed plane. By default <code>pt00 = c (0, 0)</code>,
corresponding to the bottom left of the displayed non-flipped image.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_dxy">dxy</code></td>
<td>
<p>width and height of a pixel in the plane. If <code>dxy = c (1, 1)</code>
(default) abcissa and ordinate correspond to pixel number in the plane.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_col">col</code></td>
<td>
<p>Vector, representing the color palette of the image.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_breaks">breaks</code></td>
<td>
<p>One of :
</p>

<ul>
<li> <p><code>NULL</code> : the minimum and the maximum value of the <code>vol</code> define
the range.
</p>
</li>
<li><p> Vector giving the breakpoints of each color. Outside values are transparent,
leaving the background visible, depending on <code>sat.transp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="display.kplane_+3A_sat.transp">sat.transp</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, outside values are transparent, else
set to <code>breaks</code> limits colors.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_add">add</code></td>
<td>
<p>Boolean indicating whether to display the background image.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_main">main</code></td>
<td>
<p>Title of the background image. If <code>main = NULL</code>,
the title just indicates the value of <code>k</code>.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_abs.lab">abs.lab</code></td>
<td>
<p>Label of the image abcissa. By default <code>abs.lab = 'i'</code>.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_ord.lab">ord.lab</code></td>
<td>
<p>Label of the image ordinate. By default <code>ord.lab = 'j'</code>.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_flip">flip</code></td>
<td>
<p>Boolean defaults to <code>FALSE</code> flipping the horizontal axis
of the background image.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_flop">flop</code></td>
<td>
<p>Boolean defaults to <code>FALSE</code> flipping the vertical axis
of the background image.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_bg">bg</code></td>
<td>
<p>Background color of the image. By default, this color is black.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_abs.rng">abs.rng</code></td>
<td>
<p>Vector of 2 elements indicating the minimum and maximum
background image abscissa to display.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_ord.rng">ord.rng</code></td>
<td>
<p>Vector of 2 elements indicating the minimum and maximum
background image ordinate to display.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, indicating whether to apply linear interpolation
to the image.</p>
</td></tr>
<tr><td><code id="display.kplane_+3A_...">...</code></td>
<td>
<p>others argument of plot function like xaxt, yaxt...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a display of the  \(k^{th}\) image plane of <code>vol</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+display.plane">display.plane</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("ct","mr", "rtdose"),
                             dxyz = rep (step, 3), beam.nb = 3)
MR &lt;- patient$mr[[1]]
CT &lt;- patient$ct[[1]]
D &lt;- patient$rtdose[[1]]

# display

display.kplane (CT)

display.kplane (MR, k = floor (length(MR$k.idx)*5/8), 
                col = grey.colors (256, start = 0, end = 1),
                breaks = seq (0, 500, length.out = 257), bg = "darkblue")


display.kplane (D, k = floor (length(D$k.idx)*3/8),
                col = rainbow (256, s = seq (1, 0, length.out = 256),
                               start = 0, end = 4/6,
                               alpha = seq (0.8, 0, length.out=256),
                               rev = TRUE),
                bg = "darkblue", ord.flip = TRUE, sat.transp = FALSE,
                interpolate = FALSE)

display.kplane (CT, k = floor (length(CT$k.idx)/3), col = pal.RVV (1000),
                bg = "darkblue", ord.flip = TRUE, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='display.legend'>Display of the RoI legend</h2><span id='topic+display.legend'></span>

<h3>Description</h3>

<p>The <code>display.legend</code> function displays in an image the list
of requested RoI and their associated color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.legend(
  struct = NULL,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  lwd = 1,
  cex = 1,
  displayed.roi.name = NULL,
  bg = "black",
  text.col = "white"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.legend_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="display.legend_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.legend_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the
<code>struct</code> object. By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.legend_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>struct</code>
object. By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.legend_+3A_lwd">lwd</code></td>
<td>
<p>Line thickness, defaults to 1</p>
</td></tr>
<tr><td><code id="display.legend_+3A_cex">cex</code></td>
<td>
<p>Font size, default to 1.</p>
</td></tr>
<tr><td><code id="display.legend_+3A_displayed.roi.name">displayed.roi.name</code></td>
<td>
<p>Vector. If different from <code>NULL</code>, it represents
the replacement names of selected RoI if needed.</p>
</td></tr>
<tr><td><code id="display.legend_+3A_bg">bg</code></td>
<td>
<p>color of the background.</p>
</td></tr>
<tr><td><code id="display.legend_+3A_text.col">text.col</code></td>
<td>
<p>color of the legend text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code>
indicates the RoI to display. If all three are set to NULL, all RoI are selected.
</p>


<h3>Value</h3>

<p>Returns  display of the RoI names and their associated color in the
active graphics window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
patient &lt;- toy.load.patient (modality = c("rtstruct"), dxyz = c (5, 5, 5))
S &lt;- patient$rtstruct[[1]]

display.legend (struct = S, roi.idx = 2:10, lwd = 2)
</code></pre>

<hr>
<h2 id='display.obj.links'>Display patient objects links</h2><span id='topic+display.obj.links'></span>

<h3>Description</h3>

<p>The <code>display.obj.links</code> function displays a graph of
connections between objects of a patient.
The name of the objects corresponds to their modality (ct, mr, rtdose...)
followed by their position in their respective lists in the patient list objects.
Connected objects are linked by arrows. Objects sharing the same frame of reference
have the same color except for objects with warnings, errors or missing planes
which are all in grey.
Approved objects are circled in green.
By default, objects shapes are circles, except rtdose represented as squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.obj.links(
  pat,
  obj.selected = NULL,
  exclusion = NULL,
  square = "rtdose",
  group.by.connected.FoR = TRUE,
  interactive = FALSE,
  random.seed = 314
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.obj.links_+3A_pat">pat</code></td>
<td>
<p>&quot;patient&quot; class object, as loaded using <a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>,
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or <a href="#topic+toy.load.patient">toy.load.patient</a>.</p>
</td></tr>
<tr><td><code id="display.obj.links_+3A_obj.selected">obj.selected</code></td>
<td>
<p>Dataframe (default to NULL) containing the objects already selected,
created by a previous call of <code>display.obj.links</code> for example.</p>
</td></tr>
<tr><td><code id="display.obj.links_+3A_exclusion">exclusion</code></td>
<td>
<p>Vector of patient file modalities that should not be displayed,
as for instance <code>"mr"</code>...</p>
</td></tr>
<tr><td><code id="display.obj.links_+3A_square">square</code></td>
<td>
<p>Vector of patient file modalities that should be enclosed by a
square, as for instance <code>c ("ct", "mr")</code>...
If <code>NULL</code> no object name is squared.</p>
</td></tr>
<tr><td><code id="display.obj.links_+3A_group.by.connected.for">group.by.connected.FoR</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), all objects
sharing the same frame of reference or connected by a registration matrix have
the same color. If <code>group.by.connected.FoR =FALSE</code>, only objects sharing
the same FoR have the same color.</p>
</td></tr>
<tr><td><code id="display.obj.links_+3A_interactive">interactive</code></td>
<td>
<p>Boolean. If <code>interactive = TRUE</code>, buttons are available
on the graph to get information about the objects and select or remove them from
the data frame of the selected objects.
Then simply click on the name of the object on which to apply the chosen action.
If <code>interactive = FALSE</code> no interaction possible with the plot.</p>
</td></tr>
<tr><td><code id="display.obj.links_+3A_random.seed">random.seed</code></td>
<td>
<p>Positive Integer or <code>NULL</code>. If <code>random.seed = NULL</code>,
the objects are laid out randomly. The layout is otherwise fixed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function displays all patient objects, linked by an
arrow when they are connected or a line when they belongs to the same DICOM
object, and with a color and a shape depending on <code>square</code>, <code>group.by.connected.FoR</code>.
</p>
<p>When <code>interactive = TRUE</code>, it returns a dataframe of the selected objects,
or NULL if no object is selected.
</p>
<p>Items are circled in green when the DICOM file has been approved.
They are circled in red, when the DICOM series is incomplete (e.g. missing plan).
</p>


<h3>See Also</h3>

<p><a href="#topic+get.obj.connection">get.obj.connection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
patient &lt;- toy.load.patient (dxyz = c (5, 5, 5), beam.nb = 1)
display.obj.links (patient, group.by.connected.FoR = FALSE)
display.obj.links (patient, group.by.connected.FoR = TRUE)
display.obj.links (patient, group.by.connected.FoR = TRUE, random.seed=NULL)
</code></pre>

<hr>
<h2 id='display.palette'>Display of the color scale of a color palette</h2><span id='topic+display.palette'></span>

<h3>Description</h3>

<p>The <code>Display.palette</code> function displays the color scale as it is used for representations
in espadon functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.palette(
  col,
  breaks = NULL,
  factors = NULL,
  override.breaks = FALSE,
  new.window = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.palette_+3A_col">col</code></td>
<td>
<p>Vector of colors like the ones generated by <code>rainbow</code>,
<code>heat.colors</code>, etc.</p>
</td></tr>
<tr><td><code id="display.palette_+3A_breaks">breaks</code></td>
<td>
<p>Vector of breaks for the color palette. It is the usual option
for images or dose, for instance. Its length must be one unit more than <code>col</code> length.</p>
</td></tr>
<tr><td><code id="display.palette_+3A_factors">factors</code></td>
<td>
<p>Vector containing the labels associated to each <code>col</code>. It should be used for
tissue identification or image segment labelling. Its length must be <code>col</code> length.</p>
</td></tr>
<tr><td><code id="display.palette_+3A_override.breaks">override.breaks</code></td>
<td>
<p>Boolean. When <code>FALSE</code> (by default) ordinates are set to breaks. when <code>TRUE</code>
colors are uniformely displayed, and associated breaks set to the correct ordinates for the given colors.</p>
</td></tr>
<tr><td><code id="display.palette_+3A_new.window">new.window</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, it opens a new window for displaying
the palette.</p>
</td></tr>
<tr><td><code id="display.palette_+3A_...">...</code></td>
<td>
<p>others parameters of plot or axis functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns in a new device (if <code>new.window = TRUE</code>), or in the
active graphics window  (if <code>new.window = FALSE</code>), the palette color defined
by <code>col</code> and <code>breaks</code> in priority, or by <code>col</code> and <code>factors</code>.
</p>


<h3>Note</h3>

<p>the breaks are not necessarily evenly spaced. In this case, the colour palette
can be represented as the breaks are defined (default option) or by choosing a
constant spacing for each colour and displaying the associated abscissa
calculated from the breaks (override.breaks = TRUE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:                 
# simple example for breaks and factors

display.palette (c ("red", "green", "blue"), breaks = c(0, 1, 3, 7), 
                 ylab = "a simple color palette")
display.palette (c ("red", "green", "blue"), breaks = c(0, 1, 3, 7), 
                 override.breaks = TRUE)
display.palette (c ("red", "green", "blue"), 
                 factors = c("red", "green", "blue"))
display.palette (c ("grey", "green", "blue"), factors = c(NA, 1, 2))

# for RVV palette, the function computes breaks between -1000 and 1000
display.palette (pal.RVV (255), new.window = TRUE)

# a palette for dose, for instance
display.palette (rainbow (255, start = 0, end = 4/6, rev = TRUE), 
                 breaks = seq (0, 60, length.out = 256), new.window = TRUE)

# black &amp; white palette for CTs or MRs
display.palette (grey.colors (255, start = 0, end = 1), 
                 breaks = seq (0, 60, length.out = 256), new.window = TRUE)

# transparency affects colors depending on background (black in first exemple,
# white in the second one)
display.palette (pal.rainbow(255), breaks = seq (0, 60, length.out=256))
display.palette (pal.rainbow(255), breaks = seq (0, 60, length.out=256), 
                 bg = "white", new.window = TRUE)

## End(Not run)                         
# colors contracted range using non uniform breaks in the plot window
display.palette (pal.rainbow(255),
                 breaks = seq (0, 1, length.out = 256)^0.25 * 60, bg="grey", 
                 new.window = FALSE)

# the same using breaks override
display.palette (pal.rainbow(255),
                 breaks = seq (0, 1, length.out = 256)^0.25 * 60, bg="grey", 
                 override.breaks = TRUE, new.window = FALSE)

</code></pre>

<hr>
<h2 id='display.plane'>Display the transverse frontal or sagittal view in the patient reference system</h2><span id='topic+display.plane'></span>

<h3>Description</h3>

<p>The <code>display.plane</code> function displays an overlay of images and RoI
closed planar contours on a plane defined by the equations x = constant (sagittal
view), or y = constant (frontal view) or z = constant (transverse view) in a
frame of reference chosen by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.plane(
  bottom = NULL,
  top = NULL,
  struct = NULL,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  struct.dxyz = c(0.5, 0.5, struct$thickness),
  display.ref = NULL,
  T.MAT = NULL,
  interpolate = TRUE,
  view.type = c("trans", "front", "sagi"),
  view.coord = 0,
  bg = "#000000",
  abs.rng = NULL,
  ord.rng = NULL,
  bottom.col = grey.colors(255, start = 0, end = 1),
  top.col = pal.rainbow(255),
  bottom.breaks = NULL,
  top.breaks = NULL,
  sat.transp = FALSE,
  struct.lwd = 2,
  main = NULL,
  legend.plot = TRUE,
  legend.shift = 0,
  legend.roi.pseudo = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.plane_+3A_bottom">bottom</code></td>
<td>
<p>&quot;volume&quot; class object, displayed using <code>bottom.col</code>
palette. If <code>bottom = NULL</code>, no bottom image is displayed.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_top">top</code></td>
<td>
<p>&quot;volume&quot; class object, displayed as an overlay, using <code>top.col</code>
palette. If <code>top = NULL</code>, no overlay image is displayed.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object. If <code>NULL</code>, no RoI is displayed. Only
RoI of closed planar or point type are displayed.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the <code>struct</code>
object. By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>struct</code>
object. By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_struct.dxyz">struct.dxyz</code></td>
<td>
<p>3D vector. Used in case of <code>bottom</code> and
<code>top</code> are set to <code>NULL</code>. It represents the voxel size in the <code>display.ref</code>
frame of reference, used to calculate contours in frontal or sagittal view.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_display.ref">display.ref</code></td>
<td>
<p>Character string. Pseudonym of the frame of reference used
for display. If <code>NULL</code> (default), the bottom image FoR, or top image FoR
(when no bottom image), or struct FoR (when no volume displayed).</p>
</td></tr>
<tr><td><code id="display.plane_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT</code> is <code>NULL</code>, <code>bottom</code>,
<code>top</code> and <code>struct</code> must have the same frame of reference.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, indicating whether to apply linear interpolation,
when calculating the bottom and top cuts,and then when displaying them.
If <code>interpolate = FALSE</code>, the values of the nearest voxels are used. When <code>TRUE</code> (by delfault),
trilinear interpolation is used.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_view.type">view.type</code></td>
<td>
<p>Character string, defining the view to display. It must be set to
</p>

<ul>
<li> <p><code>"trans"</code> for a transverse view,
</p>
</li>
<li> <p><code>"front"</code> for a frontal view or,
</p>
</li>
<li> <p><code>"sagi"</code> for a sagittal view.
</p>
</li></ul>
</td></tr>
<tr><td><code id="display.plane_+3A_view.coord">view.coord</code></td>
<td>
<p>Numeric vector of the coordinates along the normal vector of
the selected view.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_bg">bg</code></td>
<td>
<p>Background color of the image. By default, this color is black.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_abs.rng">abs.rng</code></td>
<td>
<p>Vector of 2 elements indicating the minimum and maximum abscissa
to display on the background image.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_ord.rng">ord.rng</code></td>
<td>
<p>Vector of 2 elements indicating the minimum and maximum ordinate
to display on the background image.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_bottom.col">bottom.col</code>, <code id="display.plane_+3A_top.col">top.col</code></td>
<td>
<p>Vectors, representing the palette color of
<code>bottom</code> and <code>top</code>.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_bottom.breaks">bottom.breaks</code>, <code id="display.plane_+3A_top.breaks">top.breaks</code></td>
<td>
<p>One of :
</p>

<ul>
<li> <p><code>NULL</code> : the minimum and the maximum value of <code>bottom</code> or
<code>top</code> define the range.
</p>
</li>
<li><p> Vector giving the breakpoints of each color. Outside values are transparent,
leaving the background visible, depending on <code>sat.transp</code>.
</p>
</li></ul>

<p>When breaks are specified, the number of breaks must be one unit more then the number of colors.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_sat.transp">sat.transp</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, outside values are transparent, else set
to <code>bottom.breaks</code> or <code>top.breaks</code> limits.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_struct.lwd">struct.lwd</code></td>
<td>
<p>Line thickness of the RoI contours.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_main">main</code></td>
<td>
<p>Character string. When <code>main</code> different from <code>NULL</code>,
it replaces the title, and removes the subtitle and the maximum dose indication
if <code>top</code> is of modality rtdose.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_legend.plot">legend.plot</code></td>
<td>
<p>Boolean, that indicates whether the RoI legend should be
displayed on the image. It is displayed by default.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_legend.shift">legend.shift</code></td>
<td>
<p>Numeric. It shifts (in mm) the display of the RoI legend
on x-axis.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_legend.roi.pseudo">legend.roi.pseudo</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the name used
for a RoI in the legend comes from the <code>struct$roi.info$roi.pseudo</code>
column, otherwise the <code>struct$roi.info$name</code> column.</p>
</td></tr>
<tr><td><code id="display.plane_+3A_...">...</code></td>
<td>
<p>others parameters of plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are
all set to <code>NULL</code>, all closed planar or point RoI are selected.
If a RoI is not present in the requested plane, the RoI legend won't mention it.
</p>


<h3>Value</h3>

<p>Returns a display of the  transverse, sagittal or frontal plane. This plane
has the coordinate z = view.coord (transverse), y = view.coord (sagittal) pr
x = view.coord (frontal). The display is an overlay of:
</p>

<ul>
<li><p> a background image of uniform color <code>bg</code>
</p>
</li>
<li><p> the bottom image if it exists
</p>
</li>
<li><p> the top image if it exists
</p>
</li>
<li><p> the contours of the regions of interest if they exist in the plane considered.
</p>
</li></ul>



<h3>Note</h3>

<p>1- The main title is given by <code>bottom</code>, the
subtitle by <code>top</code>.
</p>
<p>2- When <code>top</code> is in the &quot;rtdose&quot; modality, the maximum dose is
written on the image.
</p>


<h3>See Also</h3>

<p><a href="#topic+display.kplane">display.kplane</a>, <a href="#topic+plot.volume">plot.volume</a>,
<a href="#topic+plot.struct">plot.struct</a>, <a href="#topic+plot.mesh">plot.mesh</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "mr", "rtstruct", "rtdose"), 
                             roi.name  = "",
                             dxyz = rep (step, 3), beam.nb = 3)
CT &lt;- patient$ct[[1]]
MR &lt;- patient$mr[[1]]
D &lt;- patient$rtdose[[1]]
S &lt;- patient$rtstruct[[1]]

display.plane (bottom = CT, top = D, struct = S, view.coord = -30, 
               interpolate = FALSE, legend.shift = -80)
# Display of CT in reference frame "ref1" and  MR in "ref2"               
display.plane (bottom = CT, top = MR, interpolate = FALSE)

# Display of CT and MR in reference frame "ref2"
display.plane (bottom = CT, top = MR, interpolate = FALSE, display.ref ="ref2",
               T.MAT = patient$T.MAT)
</code></pre>

<hr>
<h2 id='espadon.class'>ESPADON class</h2><span id='topic+espadon.class'></span>

<h3>Description</h3>

<p>ESPADON class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>espadon.class()
</code></pre>


<h3>Value</h3>

<p>Returns a vector of <span class="pkg">espadon</span> class names.
</p>


<h3>Note</h3>

<p>Each object of a class has specific features that are used to display or
process that object.
</p>
<p><em>- the &quot;patient&quot; class includes :</em>
</p>

<ul>
<li> <p><code>$patient</code> : dataframe providing patient's information as PIN,
birth date and gender.
</p>
</li>
<li> <p><code>$pat.pseudo</code> : patient's pseudonym, initialized to the patient's
PIN of <code>$patient</code> dataframe.
</p>
</li>
<li> <p><code>$description</code> : dataframe describing the patient's DICOM objects:
their modality (rtstruct, ct, mr, rtplan ...), the base name of the relevant
source file in the patient's directory, the pseudonym of their frame of reference
(ref1, ref2 ...), their number of sub-objects, their description if any, their
numbers of slices/RoI for all sub-objects, their maximum voxels (for volume
sub-objects), and finally the aliases of the sub-objects.
</p>
</li>
<li> <p><code>$description.by.reg</code>: list of DICOM objects descriptions that are
linked by a transfer matrix.
</p>
</li>
<li> <p><code>$T.MAT</code> : list of class &quot;t.mat&quot; containing the information of the
transfer matrices to move from one frame of reference to another.
See <a href="#topic+load.T.MAT">load.T.MAT</a>.
</p>
</li>
<li> <p><code>$ct</code> : list of CT, if any. They are named by their <code>$object.alias</code>
See <a href="#topic+load.obj.from.Rdcm">load.obj.from.Rdcm</a>.
</p>
</li>
<li> <p><code>$mr</code> : list of MRI, if any. They are formatted like the <code>$ct</code>.
</p>
</li>
<li> <p><code>$rtdose</code> : list of dose matrices. They are formatted like the <code>$ct</code>.
</p>
</li>
<li> <p><code>$rtstruct</code>: list of struct objects.
</p>
</li>
<li><p> ...any DICOM objects other than the reg files, and those previously mentioned, or
any modalities created by <span class="pkg">espadon</span>.
</p>
</li>
<li> <p><code>$dicom.dvh</code>: if any, list of DVH computed in rt-dose DICOM files.
</p>
</li></ul>

<p><em>- the &quot;t.mat&quot; class includes :</em>
</p>

<ul>
<li> <p><code>$ref.info</code>: dataframe giving the correspondence between the frame of
reference (column <code>$ref</code>) of the DICOM object (TAG (0020,0052) ) and its
pseudonym (column <code>$ref_pseudo</code>).
</p>
</li>
<li> <p><code>$reg.info</code>: list of dataframes : the first one gives the PID,
birthday, and sex of the patient, the second one gives the name of the source
file of transfer matrices.
</p>
</li>
<li> <p><code>$matrix.description</code>: dataframe giving the transfer matrix names
(column <code>$t</code>), its source frame of reference (column <code>$src</code>), the
destination frame of reference (column <code>$dest</code>), and its type (<code>$type</code>).
Note that only the RIGID type is supported.
</p>
</li>
<li> <p><code>$matrix.list</code>: list of 4X4 transfer matrices. This list contains
at least as many Identity matrices as there are <code>ref.pseudo</code>.
</p>
</li></ul>

<p>A <span class="pkg">espadon</span> object  of class &quot;dvh&quot;, &quot;fan&quot;, &quot;histo&quot;,&quot;histo2D&quot;,&quot;mesh&quot;, &quot;reg&quot;,
&quot;struct&quot;, &quot;t.mat&quot;,&quot;undef&quot;,&quot;volume&quot; is a list containing at least:
</p>

<ul>
<li> <p><code>$patient</code>: patient's PIN.
</p>
</li>
<li> <p><code>$patient.name</code>: patient's name.
</p>
</li>
<li> <p><code>$patient.bd</code>: patient's birthday.
</p>
</li>
<li> <p><code>$patient.sex</code>: patient's sex
</p>
</li>
<li> <p><code>$file.basename</code>: vector of .Rdcm or .dcm file basenames of the
object, if it exists
</p>
</li>
<li> <p><code>$file.dirname </code>: directory including the  .Rdcm or .dcm file,
if it exists
</p>
</li>
<li> <p><code>$object.name</code>: name of the object.
</p>
</li>
<li> <p><code>$object.alias</code>: alias of the object.
</p>
</li>
<li> <p><code>$frame.of.reference</code>: value of TAG (0020,0052).
</p>
</li>
<li> <p><code>$ref.pseudo</code>: pseudonym of the <code>$frame.of.reference</code>
</p>
</li>
<li> <p><code>$modality</code>: modality of the object (e.g. ct, mr, bin, rtplan..)
</p>
</li>
<li> <p><code>$description</code>: description of the object.
</p>
</li>
<li> <p><code>$acq.date </code>: date of the content (TAG (0008,0023) for ct and mr
and rtimage, TAG (300A,0006) for rtplan, TAG (3006,0008) for rtstruct)
</p>
</li>
<li> <p><code>$creation.date </code>: creation date of the object.
</p>
</li></ul>

<p>If the object was generated from a DICOM file, the list also contains:
</p>

<ul>
<li> <p><code>$object.info</code>: Information of the object. It includes:
</p>

<table>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the SOP ID (value of TAG (0008,0016)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the transfer syntax UID (value of TAG (0002,0010)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the SOP implementation ID (value of TAG (0002,0012)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the SOP type (value of TAG (0008,0008)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the study ID (value of TAG (0020,0010)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the study UID (value of TAG (0020,000D)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the serie UID (value of TAG (0020,000E)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the scanning sequence (value of TAG (0018,0020)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the list of SOP labels (values of TAG (0008,0018)),</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the dicom source files,</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the encoding of the content of text tags (values of TAG (0008,0005))</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the description of the study (values of TAG (0008,1030)) in which all
letters whose ASCCI code is not between 32 and 125 are deleted,</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the description of the serie (values of TAG (0008,103E)) in which all
letters whose ASCCI code is not between 32 and 125 are deleted,</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the number of sub-objects.
</td>
</tr>

</table>

</li></ul>

<p>if the object is linked to another DICOM object, the list also contains:
</p>

<ul>
<li> <p><code>$ref.object.alias</code>: Alias of the reference object.
</p>
</li>
<li> <p><code>$ref.object.info</code>: Information of the reference object (not available
for mr and ct). It includes:
</p>

<table>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the SOP ID of the reference object,</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> the list of SOP names of the reference object.
</td>
</tr>

</table>

</li></ul>

<p><em>- the &quot;dvh&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$nb.MC</code>: set to <code>histo$nb.MC</code>.
</p>
</li>
<li> <p><code>$breaks</code>: vector breakpoints.
</p>
</li>
<li> <p><code>$mids</code>: vector of cell centers.
</p>
</li>
<li> <p><code>$mids.unit</code>: Character string, representing the unit of the abcissa
of the DVH. For instance, &quot;Gy&quot;.
</p>
</li>
<li> <p><code>$vol</code>: cumulative volume receiving at least the doses defined by <code>$mids</code>.
</p>
</li>
<li> <p><code>$pcv</code>: percentage of the total volume receiving at least the doses defined by <code>$mids</code>.
</p>
</li>
<li><p> if <code>$nb.MC</code> is different from 0, the arrays <code>MC.vol</code>, <code>MC.pcv</code> and
<code>MC.dxyz</code> are added. See <a href="#topic+histo.DVH">histo.DVH</a>.
</p>
</li></ul>

<p><em>- the &quot;fan&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$origin</code>: the xyz-coordinates of the source point.
</p>
</li>
<li> <p><code>$direction</code>: the xyz-coordinates of the main direction of the fan.
</p>
</li>
<li> <p><code>$orientation</code>: the xyz-coordinates of the two unit vectors of the plane orthogonal to the <code>$direction</code>.
</p>
</li>
<li> <p><code>$xyz</code>: the xyz-coordinates of the unit vectors of the fan rays
</p>
</li>
<li> <p><code>$local</code>: depending on the generation of the fan rays, it can be the spherical coordinates,
the deflection angles, the voxel coordinates...
</p>
</li></ul>

<p><em>- the &quot;histo&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$nb.MC</code>: number of Monte-Carlo simulations
</p>
</li>
<li> <p><code>$breaks</code>: vector breakpoints
</p>
</li>
<li> <p><code>$mids</code>: vector of cell centers.
</p>
</li>
<li> <p><code>$mids.unit</code>: Character string, representing the unit of the abcissa
of the histogram. For instance, &quot;Gy&quot;.
</p>
</li>
<li> <p><code>counts</code>: count of voxels whose value is included in the limits
defined by <code>$breaks</code>.
</p>
</li>
<li> <p><code>dV_dx</code>: differential histogram, expressed in \(cm^3\) by voxel units,
at each <code>$mids</code>.
</p>
</li>
<li><p> if <code>$nb.MC</code> is different from 0, the arrays <code>MC.counts</code>, <code>MC.dV_dx</code> and
<code>MC.dxyz</code> are added. See <a href="#topic+histo.from.roi">histo.from.roi</a>.
</p>
</li></ul>

<p><em>- the &quot;histo2D&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$nb.pixels</code>: number of elements in the <code>density.map</code>.
</p>
</li>
<li> <p><code>$x.file.src</code>: x label. See <a href="#topic+histo.2D">histo.2D</a>.
</p>
</li>
<li> <p><code>$y.file.src</code>: y label. See <a href="#topic+histo.2D">histo.2D</a>.
</p>
</li>
<li> <p><code>x.breaks</code>: vector of x-axis breakpoints.
</p>
</li>
<li> <p><code>y.breaks</code>: vector of y-axis breakpoints.
</p>
</li>
<li> <p><code>x.mids</code>: vector of x-axis cell centers.
</p>
</li>
<li> <p><code>y.mids</code>: vector of y-axis cell centers.
</p>
</li>
<li> <p><code>density.map</code>: array of densities.
</p>
</li>
<li> <p><code>total.counts</code>: number of counted voxels.
</p>
</li></ul>

<p><em>- the &quot;mesh&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$nb.faces</code>: set to the number of faces of the mesh.
</p>
</li>
<li> <p><code>$mesh</code>: list of 3 elements defining the mesh :<code>$vb</code>, <code>$it</code>
and <code>$normals</code>. See <a href="#topic+mesh.from.bin">mesh.from.bin</a>.
</p>
</li></ul>

<p><em>- the &quot;reg&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$nb.of.ref</code>: number of transfer matrices.
</p>
</li>
<li> <p><code>$ref.data</code>: list including the lists of information on transfer
matrices, namely: the source frame of reference (<code>$src</code>), the matrix type
(<code>$type</code>, for example 'RIGID') and the transfer matrix (<code>$matrix</code>).
</p>
</li></ul>

<p><em>- the &quot;rtplan&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$approval.status</code>: value of TAG (300E,0002).
</p>
</li>
<li> <p><code>$number</code>: sub-object number.
</p>
</li>
<li> <p><code>$plan.info</code>: dataframe containing, if they exist,
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$label</code> the label for the treatment plan,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$plan.name</code> the name for the treatment plan,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$plan.description</code> description of treatment plan,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$tt.protocol</code> the treatment protocol,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$plan.intent</code> the intent of this plan,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$tt.site</code> describing the anatomical treatment site,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$geometry</code> describing whether RT Plan is based on patient or
treatment device geometry.
</td>
</tr>

</table>

</li>
<li> <p><code>$presc.dose</code>: dataframe containing, if they exist,
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$ref.roi.nb</code> value of TAG (3006,0084),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$dose.ref.nb</code> value of TAG (300A,0012),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$dose.ref.id</code> value of TAG (300A,0013),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$struct.type</code> value of TAG (300A,0014),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$description</code> value of TAG (300A,0016),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$pt.coord</code> value of TAG (300A,0018),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$nominal.prior.dose</code> value of TAG (300A,001A),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$dose.type</code> value of TAG (300A,0020),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$constraint.weight</code> value of TAG (300A,0021),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$deliv.warn.dose</code> value of TAG (300A,0022),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$deliv.max.dose</code> value of TAG (300A,0023),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$targ.min.dose</code> value of TAG (300A,0025),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$targ.presc.dose</code> value of TAG (300A,0026),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$targ.max.dose</code> value of TAG (300A,0027),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$targ.underdose.vol.frac</code> value of TAG (300A,0028),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$org.risk.full.vol.dose</code> value of TAG (300A,002A),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$org.risk.lim.dose</code> value of TAG (300A,002B),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$org.risk.max.dose</code> value of TAG (300A,002C),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$org.risk.overdose.vol.frac</code> value of TAG (300A,002D)
</td>
</tr>

</table>

</li>
<li> <p><code>$fraction.info</code>: dataframe containing, if they exist,
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$fraction.id</code> the id of the fraction group,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$description</code> its description,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$planned.frac.nb</code> the total number of treatments (Fractions)
prescribed for current fraction group,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$frac.pattern.digit.per.day.nb</code> the number of digits in <code>$frac.pattern</code>
used to represent one day,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$repeat.frac.cycle.le</code> the number of weeks needed to describe
treatment pattern,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$frac.pattern</code> the value of TAG (300A,007B) describing treatment
pattern every day,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$nb.of.beam</code> the number of beams in current fraction group,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.dose.meaning</code> the value of TAG (300A,008B) indicating the
meaning of Beam Dose,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$nb.of.brachy.app</code> the number of brachy application setups in current
fraction group.
</td>
</tr>

</table>

</li>
<li> <p><code>$fraction.beam</code> (in case of beam treatment): dataframe containing, if
they exist,
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$fraction.id</code>,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$nb.of.frac.planned</code>,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.dose</code> the value of TAG (00A,0084),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.specif.pt</code> the value of TAG (300A,0082),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.meterset</code> the value of TAG (300A,0086),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.type</code> the value of TAG (300A,0090,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$alt.dose</code> the value of TAG (300A,0091),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$alt.type</code> the value of TAG (300A,0092,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$duration.lim</code> the value of TAG (300A,00C5),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.nb</code> the value of TAG (300C,0006) or (300A,00C0),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

</li>
<li> <p><code>$beam.info</code> (in case of beam treatment): dataframe containing, if
they exist,
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.nb</code> the value of TAG (300C,0006) or (300A,00C0),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.name</code> the value of TAG (300A,00C2),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.description</code> the value of TAG (300A,00C3),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.type</code> the value of TAG (300A,00C4),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$radiation.type</code> the value of TAG (300A,00C6),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$high.dose.technique.type</code> the value of TAG (300A,00C7),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$treatment.machine.name</code> the value of TAG (300A,00B2),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$device.serial.nb</code> the value of TAG (0018,1000),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$primary.dosimeter.unit</code> the value of TAG (300A,00B3),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$referenced.tolerance.table.nb</code> the value of TAG (300C,00A0),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$src.axis.dist</code> the value of TAG (300A,00B4),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$referenced.patient.setup.nb</code> the value of TAG (300C,006A),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$treatment.delivery.type</code> the value of TAG (300A,00CE),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$wedges.nb</code> the value of TAG (300A,00D0),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$compensators.nb</code> the value of TAG (300A,00E0),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$total.compensator.tray.factor</code> the value of TAG (300A,00E2),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$boli.nb</code> the value of TAG (300A,00ED),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$blocks.nb</code> the value of TAG (300A,00F0),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$total.block.tray.factor</code> the value of TAG (300A,00F2),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$final.cumul.meterset.weight</code> the value of TAG (300A,010E),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$ctl.pts.nb</code> the value of TAG (300A,0110),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$radiation.mass.nb</code> the value of TAG (300A,0302),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$radiation.atomic.nb</code> the value of TAG (300A,0304),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$radiation.charge.state</code> the value of TAG (300A,0306),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$scan.mode</code> the value of TAG (300A,0308),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$modulated.scan.mode.type</code> the value of TAG (300A,0309),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$virtual.src.axis.dist</code> the value of TAG (300A,030A),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$total.wedge.tray.water.equ.thickness</code> the value of TAG (300A,00D7),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$total.compensator.tray.water.equ.thickness</code> the value of TAG (300A,02E3),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$total.block.tray.water.equ.thickness</code> the value of TAG (300A,00F3),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$range.shifters.nb</code> the value of TAG (300A,0312),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$lateral.spreading.devices.nb</code> the value of TAG (300A,0330),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$range.modulators.nb</code> the value of TAG (300A,0340),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$fixation.light.azimuthal.angle</code> the value of TAG (300A,0356),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$fixation.light.polar.angle</code> the value of TAG (300A,0358).
</td>
</tr>

</table>

</li>
<li> <p><code>$beam.ctl.pt</code> (in case of beam treatment): list containing, for each
beam,
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$info</code> a data.frame of control points information from DICOM</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.source</code> the coordinates of the source in the patient frame of reference</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.direction</code> the coordinates of the beam direction in the patient frame of reference</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.direction</code> the coordinates of the beam orientation in the patient frame of reference</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$beam.isocenter</code> the coordinates of the isocenter in the patient frame of reference</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$spot.map</code>, if they exist,the coordinates of the spots in the patient frame of reference</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>For the moment, only the rotations of the gantry and the patient support, and
the position of the isocenter are taken into account in the calculation of these coordinates.
</p>
</li>
<li> <p><code>$brachy.info</code> (in case of brachy treatment): dataframe containing, if they exist,
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$fraction.id</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$nb.of.frac.planned</code>,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$brachy.dose</code> the value of TAG (300A,00A4),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$brachy.nb</code> the value of TAG (300C,000C),</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$brachy.specif.pt</code> the value of TAG (300A,00A).
</td>
</tr>

</table>

</li></ul>

<p><em>- the &quot;struct&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$nb.of.roi</code>: number of regions of interest (RoI).
</p>
</li>
<li> <p><code>$thickness</code>: thickness between two consecutive planes of a contour.
</p>
</li>
<li> <p><code>$ref.from.contour</code>: reference frame change matrix, from the contour
reference frame to the ref.pseudo reference frame
</p>
</li>
<li> <p><code>$roi.info</code>: dataframe. Information on RoI contours. It includes the
followings columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$number</code>: value of TAG (3006,0084) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$name</code>: value of TAG (3006,0026) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$description</code>: value of TAG (3006,0028) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$generation.algorithm</code>: value of TAG (3006,0036) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$color</code>: value of TAG (3006,002A) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$dz</code>: z step between planes for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$roi.pseudo</code>: pseudonym of the RoI <code>$name</code>. It can be changed by the user.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$min.x</code>: minimum value x in mm of the RoI. Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$max.x</code>: maximum value x in mm of the RoI. Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$min.y</code>: minimum value y in mm of the RoI. Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$max.y</code>: maximum value y in mm of the RoI. Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$min.z</code>: minimum value z in mm of the RoI. Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$max.z</code>: maximum value z in mm of the RoI. Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$vol</code>: volume in mm^3 of the RoI. Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$Gx</code>: position x in mm of the RoI center of gravity.
Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> -<code>$Gy</code>: position y in mm of the RoI center of gravity.
Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> -<code>$Gz</code>: position z in mm of the RoI center of gravity.
Absent when <code>data = FALSE</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
-</td><td style="text-align: left;"> -<code>$continue</code>: boolean, indicating whether the contours are on adjacent planes.
</td>
</tr>

</table>

</li>
<li> <p><code>$roi.obs</code>: dataframe. RT RoI observations (sequence TAG (3006,0080)).
It includes the followings columns :
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$nb</code>: value of TAG (3006,0082) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$roi.nb</code>: value of TAG (3006,0084) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$label</code>: value of TAG (3006,0085) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$code.value</code>: value of TAG (0008,0100) in the Identification code sequence.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$code.scheme</code>: value of TAG (0008,0102) in the Identification code sequence.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$code.scheme.v</code>: value of TAG (0008,0103) in the Identification code sequence.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$code.meaning</code>: value of TAG (0008,0104) in the Identification code sequence.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$type</code>: value of TAG (3006,00A4) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> -<code>$interpreter</code>:value of TAG (3006,00A6) for the concerned RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

</li>
<li> <p><code>$roi.data</code>: exists only if the data is loaded. Contains the list
of contour coordinates. The RoI of list number i is that of line i of roi.info.
Each element of the list is a list giving the contour
information for each plane, namely:
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$type</code>: value of TAG (3006,0042).</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$pt</code>: dataframe of the coordinates of the contour points.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> If the contour is closed (i.e.<code>$type = "CLOSED_PLANAR"</code>), </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> then the first point is repeated at the end.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$level</code>: contour inclusion level. If this number is even,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> the inside of the closed contour belongs to the RoI.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> Otherwise, if odd, the inside of the closed contour is excluded from the RoI.
</td>
</tr>

</table>

</li></ul>

<p><em>- the &quot;undef&quot; class :</em> is used for DICOM objects that will not be
processed further by <span class="pkg">espadon</span> functions. It can
also include what the user wants.
</p>
<p><em>- the &quot;volume&quot; class also includes :</em>
</p>

<ul>
<li> <p><code>$number</code>: sub-object number.
</p>
</li>
<li> <p><code>$unit</code>: unit of the voxel
</p>
</li>
<li> <p><code>$rtdose.info</code>: for rtdose only, dataframe with the type, the dose
summation type and referenced beam number.
</p>
</li>
<li> <p><code>$n.ijk</code>: vector defining the number of indices i, j, k. The product
<code>prod(...$n.ijk)</code> represents the number of voxels in the 3D volume.
</p>
</li>
<li> <p><code>$slice.thickness</code>: thickness in mm of a plane.
</p>
</li>
<li> <p><code>$min.pixel</code>: minimum value of voxels in the volume.
</p>
</li>
<li> <p><code>$max pixel</code>: maximum value of voxels in the volume.
</p>
</li>
<li> <p><code>$dxyz</code>: x, y, z steps in mm.
</p>
</li>
<li> <p><code>$orientation</code>: value of TAG (0020,0037).
Vector, comprising the vectors i and j defining the orientation of the patient
with respect to the volume planes.
</p>
</li>
<li> <p><code>$xyz0</code>: in the patient frame of reference, position of the
first voxel of each plane.
</p>
</li>
<li> <p><code>$xyz.from.ijk</code>: transfer matrix of the voxels i, j, k indices to
the position x, y, z in mm in the patient's frame of reference.
</p>
</li>
<li> <p><code>$k.idx</code>: index of planes in the 3D volume.
</p>
</li>
<li> <p><code>$missing.k.idx</code>: Boolean, indicating if k is a continuous sequence of integers.
</p>
</li>
<li> <p><code>$cube.idx</code>: 3D volume vertices indices.
</p>
</li>
<li> <p><code>$vol3D.data</code>: exists only if the data is loaded. 3D array of the voxel
values of the 3D volume.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+toy.load.patient">toy.load.patient</a>, <a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>,
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>, <a href="#topic+load.T.MAT">load.T.MAT</a>
<a href="#topic+histo.DVH">histo.DVH</a>, <a href="#topic+histo.vol">histo.vol</a>,
<a href="#topic+histo.from.roi">histo.from.roi</a>, <a href="#topic+histo.from.bin">histo.from.bin</a>,
<a href="#topic+histo.2D">histo.2D</a>, <a href="#topic+mesh.from.bin">mesh.from.bin</a>,
<a href="#topic+load.obj.from.Rdcm">load.obj.from.Rdcm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat ("espadon class names are:", paste (espadon.class(), collapse = ", "))
</code></pre>

<hr>
<h2 id='export'>Export espadon objects in dicom format</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>The <code>export</code> function exports struct class objects and
volume class objects with CT or RTDOSE modality in DICOM format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(
  obj,
  format = "dcm",
  ref.obj.list = NULL,
  use.original.UIs = FALSE,
  use.original.ref.UIs = TRUE,
  file.prefix = "",
  file.dirname = ".",
  file.name = NULL,
  tag.dictionary = dicom.tag.dictionary(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_+3A_obj">obj</code></td>
<td>
<p>espadon object of rtstruct, ct or rtdose modality to be exported.</p>
</td></tr>
<tr><td><code id="export_+3A_format">format</code></td>
<td>
<p>Format of the export. For next use.</p>
</td></tr>
<tr><td><code id="export_+3A_ref.obj.list">ref.obj.list</code></td>
<td>
<p>List of espadon objects which are referenced objects of <code>obj</code>. See Details.</p>
</td></tr>
<tr><td><code id="export_+3A_use.original.uis">use.original.UIs</code>, <code id="export_+3A_use.original.ref.uis">use.original.ref.UIs</code></td>
<td>
<p>Booleans. If <code>TRUE</code>, study instance UID, serie instance
UID and image type attribute are those indicated in <code>$object.info</code> item.
Otherwise,They are regenerated. See Details.</p>
</td></tr>
<tr><td><code id="export_+3A_file.prefix">file.prefix</code></td>
<td>
<p>String. Prefix added to the generated filename, in case of <code>file.name</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="export_+3A_file.dirname">file.dirname</code></td>
<td>
<p>String. Name of the directory in which files are generated.</p>
</td></tr>
<tr><td><code id="export_+3A_file.name">file.name</code></td>
<td>
<p>String. Base name of the generated files. in CT modality, a slice number is added as a suffix.</p>
</td></tr>
<tr><td><code id="export_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>, whose structure it must keep. This
dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>Additional settings such as NAvalue (for &quot;volume&quot; data), '(0020,000D)',
'(0020,000E)', '(0008,0008)'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object you want to export may be known in a TPS thanks to these
Unique Identifiers (UIs). If you want to create a DICOM object that is different
and recognised by your TPS, it is important that the DICOM files you want to
create have new UIs: in this case, set the <code>use.original.UIs</code> argument
to <code>FALSE</code>. Otherwise, UIs in <code>$object.info</code> item of your object
will be used.
</p>
<p>Your object may have been created from another DICOM object (i.e. a
reference object). You can, for example, see these links with the function
<a href="#topic+display.obj.links">display.obj.links</a>.
</p>
<p>If you want to keep this links, you must indicate which objects are
references in the <code>ref.obj.list</code> argument, in the form of a list of espadon
objects. If these reference objects have their own identifier and you wish to
keep them, you must set the <code>use.original.ref.UIs</code> argument to <code>TRUE</code>.
</p>
<p>Otherwise (<code>use.original.ref.UIs=FALSE</code>), the UIs of the reference
objects will be regenerated. It is therefore important that the reference objects
contain all their data such as <code>vol3D.data</code> or <code>roi.data</code>.
</p>
<p>It may be useful to impose a study number (tag '(0020,000D)'), serial
number (tag '(0020,000E)'), or your Image Type Attribute (tag '(0008,0008)').
In this case, you need to add the arguments <code>'(0020,000D)' = your_study_UID</code>,
<code>'(0020,000E)' = your_serial_UID</code>, <code>'(0008,0008)' = your_image_type_attribute</code>.
</p>


<h3>Value</h3>

<p>Returns nothing, but generate DICOM files if conditions are required,
and indicates the name or number of files created
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy patient objects to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), roi.name = "", 
                             dxyz = c (6, 6, 6))
dicom.dir &lt;- file.path (tempdir(), "PM_dcm") 
export(patient$rtstruct[[1]], ref.obj.list = list (patient$ct[[1]]),
       file.dirname = dicom.dir,file.name="RS")
export(patient$ct[[1]], file.dirname = dicom.dir,file.name="CT")
list.files(dicom.dir)

# check that the links have been preserved.
pat &lt;- load.patient.from.dicom (dicom.dir, verbose = FALSE)
display.obj.links (pat)

# Cleaning  temporary directories
unlink (dicom.dir, recursive = TRUE)

</code></pre>

<hr>
<h2 id='fan.beam'>Creation of pyramid fan object with constant angle step.</h2><span id='topic+fan.beam'></span>

<h3>Description</h3>

<p>The <code>fan.beam</code> function creates a &quot;fan&quot; class object
containing, among others, the coordinates of the unit director vectors of
the rays of rectangular pyramid fan. Rays are uniformly distributed by angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fan.beam(
  alpha,
  dalpha,
  orientation = c(0, 0, 1, 1, 0, 0),
  origin = c(0, 0, 0),
  ref.pseudo = "ref1",
  frame.of.reference = "",
  alias = "",
  description = "beam fan"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fan.beam_+3A_alpha">alpha</code></td>
<td>
<p>Positive number specifying the half-angle of the conical beam.</p>
</td></tr>
<tr><td><code id="fan.beam_+3A_dalpha">dalpha</code></td>
<td>
<p>Positive number specifying the step of the angle between the
rays of the cone beam.</p>
</td></tr>
<tr><td><code id="fan.beam_+3A_orientation">orientation</code></td>
<td>
<p>Vector orientation of the pyramid base composed by the
2 orthonormal vectors coordinates.</p>
</td></tr>
<tr><td><code id="fan.beam_+3A_origin">origin</code></td>
<td>
<p>Numeric vector, giving the xyz coordinates of the fan origin.
By default <code>c (0, 0, 0)</code>.</p>
</td></tr>
<tr><td><code id="fan.beam_+3A_ref.pseudo">ref.pseudo</code></td>
<td>
<p>Character string, frame of reference pseudonym of the
created object.</p>
</td></tr>
<tr><td><code id="fan.beam_+3A_frame.of.reference">frame.of.reference</code></td>
<td>
<p>Character string, frame of reference of the
created object.</p>
</td></tr>
<tr><td><code id="fan.beam_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="fan.beam_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;fan&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions) containing, among others,
</p>

<ul>
<li> <p><code>$xyz</code> : a matrix of 3 columns giving the xyz coordinates of the fan rays.
</p>
</li>
<li> <p><code>$local</code> : a matrix of 2 columns indicating the deflection angle (in rad) in
the main directions defined by <code>orientation</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+fan.planar">fan.planar</a>, <a href="#topic+fan.sphere">fan.sphere</a>, <a href="#topic+fan.to.voxel">fan.to.voxel</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fan &lt;- fan.beam (alpha = 30, dalpha = 1)
head (fan$xyz)
library (rgl)
open3d ()
points3d (fan$xyz)
</code></pre>

<hr>
<h2 id='fan.planar'>Creation of pyramid fan object passing through pixels of a plane.</h2><span id='topic+fan.planar'></span>

<h3>Description</h3>

<p>The <code>fan.planar</code> function creates a &quot;fan&quot; class object
containing, among others, the coordinates of the unit director vectors of
the rays of rectangular pyramid fan. Rays are passing through all pixels of a
plane, which represent the pyramid basis. It is for instance useful to compute
rt-image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fan.planar(
  vol,
  k = vol$k.idx[ceiling(length(vol$k.idx)/2)],
  origin = c(0, 0, 0),
  alias = "",
  description = "planar fan"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fan.planar_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="fan.planar_+3A_k">k</code></td>
<td>
<p>Positive number specifying the plane index that the rays of the fan must cross.
By default, k is the central plane.</p>
</td></tr>
<tr><td><code id="fan.planar_+3A_origin">origin</code></td>
<td>
<p>Numeric vector, giving the xyz coordinates of the fan origin.
By default <code>c (0, 0, 0)</code>.</p>
</td></tr>
<tr><td><code id="fan.planar_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="fan.planar_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;fan&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions) containing, among others,
</p>

<ul>
<li> <p><code>$xyz</code> : a matrix of 3 columns giving the xyz coordinates of the fan rays.
</p>
</li>
<li> <p><code>$local.coords</code> : a list of the ijkt DICOM coordinates of the crossed plane,
and the transfer matrix to xyz.from.ijk to compute xyz coordinates in <code>$ref.pseudo</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+fan.sphere">fan.sphere</a>, <a href="#topic+fan.beam">fan.beam</a>,
<a href="#topic+fan.to.voxel">fan.to.voxel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("ct"), dxyz = rep (step, 3))
fan &lt;- fan.planar (patient$ct[[1]], origin = patient$ct[[1]]$xyz0[1,])
head (fan$xyz)
library (rgl)
open3d ()
points3d (fan$xyz)
</code></pre>

<hr>
<h2 id='fan.sphere'>Creation of spherical fan object.</h2><span id='topic+fan.sphere'></span>

<h3>Description</h3>

<p>The <code>fan.sphere</code> function  creates a &quot;fan&quot; class object
containing, among others, the coordinates of the unit director vectors of
the rays of a spherical fan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fan.sphere(
  angle = 1,
  method = c("regular", "random"),
  origin = c(0, 0, 0),
  ref.pseudo = "ref1",
  frame.of.reference = "",
  alias = "",
  description = "spherical fan"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fan.sphere_+3A_angle">angle</code></td>
<td>
<p>Positive number specifying the angle (or mean angle in case of
<code>method = "random"</code>) between two nearest vectors.</p>
</td></tr>
<tr><td><code id="fan.sphere_+3A_method">method</code></td>
<td>
<p>Requested method of fan calculation from among 'regular' and
'random'. By default, <code>method = regular</code>. See details.</p>
</td></tr>
<tr><td><code id="fan.sphere_+3A_origin">origin</code></td>
<td>
<p>Numeric vector, giving the xyz coordinates of the fan origin.
By default <code>c (0, 0, 0)</code>.</p>
</td></tr>
<tr><td><code id="fan.sphere_+3A_ref.pseudo">ref.pseudo</code></td>
<td>
<p>Character string, frame of reference pseudonym of the
created object.</p>
</td></tr>
<tr><td><code id="fan.sphere_+3A_frame.of.reference">frame.of.reference</code></td>
<td>
<p>Character string, frame of reference of the
created object.</p>
</td></tr>
<tr><td><code id="fan.sphere_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="fan.sphere_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;regular&quot; and &quot;random&quot; method are explained by <em>Deserno</em> <strong>[1]</strong>.
</p>

<ul>
<li><p> If <code>method = "regular"</code>, the returned vectors composing <code>$xyz</code> matrix
are regularly equidistributed  at the specified angle.
</p>
</li>
<li><p> If <code>method = "random"</code>, the returned vectors composing <code>$xyz</code> matrix
are randomly equidistributed at the specified angle.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a &quot;fan&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions) containing, among others,
</p>

<ul>
<li> <p><code>$xyz</code> : a matrix of 3 columns giving the xyz coordinates of the fan rays.
</p>
</li>
<li> <p><code>$local</code> : a matrix of 2 columns indicating the polar angle
<code>theta</code> (rad) and the azimuthal angle <code>phi</code> (rad) of each ray are added.
</p>
</li></ul>



<h3>References</h3>

<p><strong>[1]</strong> Deserno, Markus (Online; accessed 2022-08-24).
&ldquo;How to generate equidistributed points on the surface of a sphere.&rdquo;
<a href="https://www.cmu.edu/biolphys/deserno/pdf/sphere_equi.pdf">https://www.cmu.edu/biolphys/deserno/pdf/sphere_equi.pdf</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+fan.beam">fan.beam</a>, <a href="#topic+fan.planar">fan.planar</a>, <a href="#topic+fan.to.voxel">fan.to.voxel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>regular.fan &lt;- fan.sphere (angle = 30)
head (regular.fan$xyz)
random.fan &lt;- fan.sphere (angle = 30, method = "random")
head (random.fan$xyz)
library (rgl)
open3d ()
points3d (regular.fan$xyz)
open3d ()
points3d (random.fan$xyz)
</code></pre>

<hr>
<h2 id='fan.to.voxel'>Indices of voxels crossed by a fan</h2><span id='topic+fan.to.voxel'></span>

<h3>Description</h3>

<p>The <code>fan.to.voxel</code> function computes the indices of voxels
crossed by a fan. It is useful for retrieving voxel values and voxel indices
of a volume (dose or ct) along the fan rays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fan.to.voxel(vol, fan, restrict = FALSE, vol.value = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fan.to.voxel_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="fan.to.voxel_+3A_fan">fan</code></td>
<td>
<p>&quot;fan&quot; class object created by <a href="#topic+fan.sphere">fan.sphere</a> for example.</p>
</td></tr>
<tr><td><code id="fan.to.voxel_+3A_restrict">restrict</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the voxels with a value equal
to <code>vol.value</code> are taken into account.</p>
</td></tr>
<tr><td><code id="fan.to.voxel_+3A_vol.value">vol.value</code></td>
<td>
<p>Value of the voxels taken into account, in case of <code>restrict = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe of 4 columns. Each line gives:
</p>

<ul>
<li><p> column &quot;ray.index&quot;: the index (i.e. the row number) of the ray
concerned in <code>fan$dxyz</code>,
</p>
</li>
<li><p> column &quot;vol.index&quot;: the index of the voxel crossed in <code>vol$vol.3Ddata</code>,
</p>
</li>
<li><p> column &quot;l.in&quot;: the distance between fan source (i.e. <code>fan$origin</code>)
and the first face of the voxel crossed by the ray,
</p>
</li>
<li><p> column &quot;dl&quot;: the distance crossed by the ray in the voxel.
</p>
</li></ul>

<p>If the rays do not cross any voxel, the dataframe has no row.
</p>


<h3>See Also</h3>

<p><a href="#topic+fan.beam">fan.beam</a>, <a href="#topic+fan.planar">fan.planar</a>, <a href="#topic+fan.sphere">fan.sphere</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vol &lt;- vol.create (pt000 = c(1,10,10), dxyz = c (1 , 1, 1),
                   n.ijk = c(100, 100, 100)) 
fan.origin &lt;- c (50,50,50)                         
fan &lt;- fan.sphere (angle = 10, origin = fan.origin)
fan.voxel &lt;- fan.to.voxel (vol = vol, fan = fan)
head (fan.voxel)

# Use of the 2nd column of fan.voxel to select voxels 
bin &lt;- vol.copy (vol, modality = "binary")
bin$vol3D.data[] &lt;- FALSE
bin$vol3D.data[fan.voxel[,2]] &lt;- TRUE
bin$max.pixel &lt;- TRUE
bin$min.pixel &lt;- FALSE
display.kplane(bin, k=10)
</code></pre>

<hr>
<h2 id='get.extreme.pt'>Coordinates of the extreme points</h2><span id='topic+get.extreme.pt'></span>

<h3>Description</h3>

<p>The <code>get.extreme.pt</code> function returns the x, y, z coordinates
of the 2 extreme voxels of the rectangular parallelepiped, containing
the objet <code>obj</code> of class volume, struct or mesh. These coordinates are given in
the <code>ref.pseudo</code> frame of reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.extreme.pt(obj, ref.pseudo = obj$ref.pseudo, T.MAT = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.extreme.pt_+3A_obj">obj</code></td>
<td>
<p>object of class volume or struct or mesh.</p>
</td></tr>
<tr><td><code id="get.extreme.pt_+3A_ref.pseudo">ref.pseudo</code></td>
<td>
<p>Pseudonym of the frame of reference in which you want the
coordinates.</p>
</td></tr>
<tr><td><code id="get.extreme.pt_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or <a href="#topic+load.T.MAT">load.T.MAT</a>. If
<code>T.MAT = NULL</code>, <code>ref.pseudo</code> must be equal to <code>obj$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="get.extreme.pt_+3A_...">...</code></td>
<td>
<p>Additional arguments <code>min</code>, <code>max</code> (of voxel) if <code>obj</code>
is of class 'volume'. Arguments <code>roi.name</code>, <code>roi.sname</code>, <code>roi.idx</code>
if <code>obj</code> is of class 'struct'. Arguments <code>vol</code> (depracated), replaced by <code>obj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe of min and max columns, and x, y and z rows.
</p>

<ul>
<li><p> If <code>obj</code> is a member of the class volume: the returned dataframe
represents the coordinates of the 2 extreme points of the rectangle parallelepiped
including all the voxels such as <code>min &lt;= obj$vol3D.data &lt;= max</code>,
if the arguments <code>min</code> or <code>max</code> exist, or including all the voxels otherwise.
</p>
</li>
<li><p> If <code>obj</code> is a member of the class struct: the returned dataframe
represents the coordinates of the 2 extreme points of the rectangular parallelepiped
including all the selected RoI.
</p>
</li>
<li><p> if <code>obj</code> is a member of the class mesh: the returned dataframe
represents the coordinates of the 2 extreme points of the rectangular parallelepiped
including all the mesh.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
patient &lt;- toy.load.patient (modality = "ct", roi.name = "", dxyz = c (5, 5, 5))
CT &lt;- patient$ct[[1]]

# xyz extreme coordinate
get.extreme.pt (CT)
get.extreme.pt (CT, min = 0)
</code></pre>

<hr>
<h2 id='get.ijk.from.index'>Conversion of the indices of a point into ijk vector</h2><span id='topic+get.ijk.from.index'></span>

<h3>Description</h3>

<p>The <code>get.ijk.from.index</code> function converts the voxel indices
of <code>vol$vol3D.data</code> (for example, obtained with the function <code>which</code>)
into a vector or matrix of DICOM indices i, j, k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.ijk.from.index(idx, vol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.ijk.from.index_+3A_idx">idx</code></td>
<td>
<p>Index, or matrix of voxel indices of the array <code>vol$vol3D.data</code>.</p>
</td></tr>
<tr><td><code id="get.ijk.from.index_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an i, j, k column matrix of the DICOM indices of the points
of <code>vol$vol3D.data</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+get.value.from.ijk">get.value.from.ijk</a>, <a href="#topic+display.kplane">display.kplane</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "rtdose", roi.name = "", 
                             dxyz = rep (step, 3), beam.nb = 3)
D &lt;- patient$rtdose[[1]]

# voxels location where the dose is greater than 99.9% Dmax
Dmax &lt;- max (D$vol3D.data, na.rm = TRUE) # D$max.pixel
get.ijk.from.index (which (D$vol3D.data &gt;= 0.999 * Dmax), D)
# or
get.ijk.from.index (which (D$vol3D.data &gt;= 0.999 * Dmax, arr.ind = TRUE), D)

ijk &lt;- as.numeric (get.ijk.from.index (which.max (D$vol3D.data), D))
display.kplane (D, k = ijk[3]) 
</code></pre>

<hr>
<h2 id='get.ijk.from.xyz'>Indices relating to the coordinates of the points</h2><span id='topic+get.ijk.from.xyz'></span>

<h3>Description</h3>

<p>The <code>get.ijk.from.xyz</code> function calculates the i, j, k DICOM
indices of the points given in the patient's reference frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.ijk.from.xyz(xyz = matrix(c(0, 0, 0), ncol = 3), vol, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.ijk.from.xyz_+3A_xyz">xyz</code></td>
<td>
<p>Vector of length 3, corresponding to the x, y, z coordinates (in mm) of a point in
the patient's frame of reference, or 3-column matrix of x, y, z coordinates of several points.</p>
</td></tr>
<tr><td><code id="get.ijk.from.xyz_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="get.ijk.from.xyz_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>. If <code>verbose = TRUE</code>, then the <code>xyz</code> coordinates
are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or a matrix of the i, j, k DICOM indices of the x, y, z coordinate points
in the patient's frame of reference.
</p>


<h3>Note</h3>

<p>The vector or matrix is made up of real numbers. It is up to the user to make the indices as integer.
</p>
<p>The indices of the first voxel <code>vol</code> are 0, 0, 0.
WARNING: As i,j,k are DICOM indices, they are not directly related to array indices.
To get the value of the <code>vol$vol3D.data</code>, use the function
<a href="#topic+get.value.from.ijk">get.value.from.ijk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "ct", roi.name = "", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]

get.ijk.from.xyz (xyz = CT$xyz0[1,], vol = CT, verbose = TRUE)
get.ijk.from.xyz (xyz = c (1,1,1), vol = CT, verbose = TRUE)

index &lt;- get.ijk.from.xyz (xyz = c (1,1,1), vol = CT)
floor (index)

index &lt;- get.ijk.from.xyz (xyz = matrix (c (0,0,0,1,1,1), ncol = 3, byrow = TRUE), 
                           vol = CT)
floor (index)
</code></pre>

<hr>
<h2 id='get.line'>Image value along an axis</h2><span id='topic+get.line'></span>

<h3>Description</h3>

<p>The <code>get.line</code> function calculates the value of the points
of a volume <code>vol</code> along an axis in any direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.line(
  vol,
  origin = c(0, 0, 0),
  orientation = c(1, 0, 0),
  grid = seq(-100, 100, 1),
  interpolate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.line_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="get.line_+3A_origin">origin</code></td>
<td>
<p>Vector of x, y, z coordinates belonging to the line to extract.
If <code>interpolate = FALSE</code>, these coordinates are replaced by the coordinates
of the voxel closest to <code>origin</code>.</p>
</td></tr>
<tr><td><code id="get.line_+3A_orientation">orientation</code></td>
<td>
<p>Directing vector of the line in the <code>vol</code> frame of
reference. This vector is internally normalized.</p>
</td></tr>
<tr><td><code id="get.line_+3A_grid">grid</code></td>
<td>
<p>Vector, representing the curvilinear coordinates on the line to extract.</p>
</td></tr>
<tr><td><code id="get.line_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, default to <code>TRUE</code>. If <code>interpolate = TRUE</code>, a
trilinear interpolation of the value of the voxels, relative to the values of
adjacent voxels, is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe, composed of the columns <code>$x</code>, <code>$y</code>, <code>$z</code>,
representing the coordinates of the points where the values are taken in
<code>vol</code> volume, the column <code>$s</code> representing the curvilinear abcissa,
and the column <code>$value</code> representing values along <code>$s</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "rtdose", roi.name = "", 
                             dxyz = rep (step, 3), beam.nb = 3)
D &lt;- patient$rtdose[[1]]

# Dose at maximum dose
origin &lt;- get.xyz.from.index (which.max (D$vol3D.data), D)
display.plane (bottom = D, view.coord =  origin[3], 
               bg = "#0000ff")

# Dose profile at x = origin[1] and z = origin[3].
l &lt;- get.line (vol = D, origin = origin,
               orientation = c (0, 1, 0), interpolate = FALSE)
plot (l$y, l$value, type = "l")
grid ()

# Dose profile at y = origin[2] and z = origin[3].
l &lt;- get.line (D, origin = origin,
               orientation = c (1, 0, 0), interpolate = FALSE)
plot (l$s, l$value, type = "l")
grid ()
</code></pre>

<hr>
<h2 id='get.obj.connection'>List of connections between objects</h2><span id='topic+get.obj.connection'></span>

<h3>Description</h3>

<p>The <code>get.obj.connection</code> function describes with 4 matrices
the different connections between the DICOM objects of the patient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.obj.connection(pat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.obj.connection_+3A_pat">pat</code></td>
<td>
<p>&quot;patient&quot; class object, as loaded using <a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>,
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or <a href="#topic+toy.load.patient">toy.load.patient</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of 4 named matrices:
</p>

<ul>
<li><p> the <code>$adjacency</code> matrix matrix specifies the source objects that
generated the destination objects: the column names correspond to the
destinations, and the row names to the sources.
</p>
</li>
<li><p> the <code>$same.object</code> matrix specifies the elements belonging to the same
DICOM object.
</p>
</li>
<li><p> the <code>$components</code> matrix specifies the objects belonging to the same study.
</p>
</li>
<li><p> the <code>$same.ref</code> matrix specifies the objects that share the same frame of
reference, or with frames of reference linked in T.MAT (by a DICOM reg file
for instance)
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+display.obj.links">display.obj.links</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
patient &lt;- toy.load.patient (dxyz = c (5, 5, 5), beam.nb = 1)
get.obj.connection (patient)
display.obj.links (patient)
</code></pre>

<hr>
<h2 id='get.plane'>Extracting a plane from a volume</h2><span id='topic+get.plane'></span>

<h3>Description</h3>

<p>The <code>get.plane</code> function extracts a plane from a &quot;volume&quot;
class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.plane(
  vol,
  origin = c(0, 0, 0),
  plane.orientation = c(1, 0, 0, 0, 1, 0),
  alias = "plane.n",
  xgrid = NULL,
  ygrid = NULL,
  interpolate = TRUE,
  method = c("NN", "Av")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.plane_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="get.plane_+3A_origin">origin</code></td>
<td>
<p>Vector of x, y, z coordinates, representing the origin of the
plane to extract. If <code>interpolate = FALSE</code>, these coordinates are replaced
by the coordinates of the voxel closest to <code>origin</code>.</p>
</td></tr>
<tr><td><code id="get.plane_+3A_plane.orientation">plane.orientation</code></td>
<td>
<p>Vector orientation of the plane in the <code>vol</code>
frame of reference, composed by the 2 vectors coordinates of the orthonormal
basis of the plane. First vector is x-axis, and second one is y-axis.</p>
</td></tr>
<tr><td><code id="get.plane_+3A_alias">alias</code></td>
<td>
<p><code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="get.plane_+3A_xgrid">xgrid</code></td>
<td>
<p>Vector, representing the grid of the plane abscissa. See note.</p>
</td></tr>
<tr><td><code id="get.plane_+3A_ygrid">ygrid</code></td>
<td>
<p>Vector, representing the grid of the plane ordinates. See note.
If <code>ygrid = NULL</code>, the ordinate is the line intercepting the volume and the
step is set to the projection of <code>vol$dxyz</code> onto the ordinate orientation.</p>
</td></tr>
<tr><td><code id="get.plane_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get.plane_+3A_method">method</code></td>
<td>
<p>method of interpolation, defaulted to 'NN' ie 'Nearest Neighbor'. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interpolation method is chosen from:
</p>

<ul>
<li> <p><code>'NN'</code>: the value of a voxel is calculated from its nearest adajcent neighbors.
</p>
</li>
<li> <p><code>'Av'</code>: the value of a voxel is the weighted average of
the voxels contained in a box, whose sides are automatically calculated from
the <code>back.bol$dxyz</code> steps.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object, containing only a single plane,
at <code>k = 0</code>, in the same frame of reference as <code>vol</code>.
This returned object has 2 new fields <code>local.xgrid</code>, and <code>local.ygrid</code>,
representing the local grids of the abscissa (columns) and ordinate (rows)
of the plane.
</p>
<p>Returns <code>NULL</code> if plane doesn't exist.
</p>


<h3>Note</h3>

<p><em>Determination of axes</em> :
</p>

<ul>
<li><p> the x-axis has <code>plane.orientation[1:3]</code> as unit vector.
</p>
</li>
<li><p> the y-axis has <code>plane.orientation[4:6]</code> as unit vector.
</p>
</li>
<li><p> If <code>xgrid</code> is not <code>NULL</code>, <code>origin + x.grid * plane.orientation[1:3]</code>
are the coordinates of the points on the x axis.
</p>
</li>
<li><p> If <code>ygrid</code> is not <code>NULL</code>, <code>origin + y.grid * plane.orientation[4:6]</code>
are the coordinates of the points on the y axis.
</p>
</li>
<li><p> If <code>xgrid</code> or <code>ygrid</code> are NULL, they are determined to represent
as closely as possible the initial volume in the required cut.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "mr", dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]] 
    
# mid-volume point 
mid.point &lt;- apply (get.extreme.pt (MR),1,mean)

plane &lt;- get.plane (MR, origin = mid.point, interpolate = TRUE)
display.kplane (plane, interpolate = FALSE)

plane &lt;- get.plane (MR, origin = mid.point, xgrid = seq (-50, 50, 1), 
                    ygrid = seq (-50, 50, 1), interpolate = TRUE)
display.kplane (plane, interpolate = FALSE)

# 3 points on the inclined plane
pts &lt;- t ((MR$xyz.from.ijk %*% MR$cube.idx) [1:3 , c (1, 2, 7)])
orientation &lt;- orientation.create (A = pts[1,], B = pts[2,], C = pts[3,])
origin &lt;- apply (pts, 2, mean)
plane &lt;- get.plane (MR, origin = origin, 
                    plane.orientation = orientation, interpolate = TRUE)
display.kplane (plane, interpolate = FALSE)

orientation &lt;- orientation.create (A = c (0, 0, 0) , B = c (1, 1, 0), 
                                   C = c (-1, 1, 0))
plane &lt;- get.plane (MR, origin = origin, 
                    plane.orientation = orientation, interpolate = TRUE) 
display.kplane (plane, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='get.rigid.M'>Transfer matrix between two frames of reference</h2><span id='topic+get.rigid.M'></span>

<h3>Description</h3>

<p>The function <code>get.rigid.M</code> provides, from the T.MAT list created
by the functions <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a> or <a href="#topic+load.T.MAT">load.T.MAT</a>, the 4x4
transfer matrix from the FoR (frame o reference) pseudonym <code>src.ref</code> to
the FoR pseudonym <code>dest.ref</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rigid.M(T.MAT, src.ref, dest.ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.rigid.M_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by the functions
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>, <a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a></p>
</td></tr>
<tr><td><code id="get.rigid.M_+3A_src.ref">src.ref</code></td>
<td>
<p>Pseudonym of the source frame of reference</p>
</td></tr>
<tr><td><code id="get.rigid.M_+3A_dest.ref">dest.ref</code></td>
<td>
<p>Pseudonym of the destination frame of reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the 4x4 transfer matrix <code>dest.ref</code> from <code>src.ref</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
patient &lt;- toy.load.patient (modality = c ("ct", "mr"), roi.name = "",
                             dxyz = c(5, 5, 5))
get.rigid.M (patient$T.MAT, "ref1", "ref2")
</code></pre>

<hr>
<h2 id='get.roi.connection'>List of inter-connections between RoI</h2><span id='topic+get.roi.connection'></span>

<h3>Description</h3>

<p>The <code>get.roi.connection</code> function describes the interconnections
between Regions of Interest (RoI), from an imaging volume of &quot;cluster&quot; modality,
created by struct.clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.roi.connection(vol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.roi.connection_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object of &quot;cluster&quot; modality, created by
<a href="#topic+struct.clustering">struct.clustering</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the list of regions of interest (RoI), where each item in the
list gives the inter-connections with other RoI.
</p>


<h3>See Also</h3>

<p><a href="#topic+struct.clustering">struct.clustering</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c ("mr", "rtstruct"),  
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]
S &lt;- patient$rtstruct[[1]]
cluster.vol &lt;- struct.clustering (MR, S, T.MAT = patient$T.MAT, verbose = FALSE)

get.roi.connection (cluster.vol)

</code></pre>

<hr>
<h2 id='get.value.from.ijk'>Value of the volume at a selection of DICOM indices</h2><span id='topic+get.value.from.ijk'></span>

<h3>Description</h3>

<p>The <code>get.value.from.ijk</code> function calculates the value of
a &quot;volume&quot; class object at DICOM indices i, j, k, whether they are
integers or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.value.from.ijk(ijk, vol, interpolate = TRUE, s.ijk = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.value.from.ijk_+3A_ijk">ijk</code></td>
<td>
<p>Vector or 3-column matrix of DICOM indices.</p>
</td></tr>
<tr><td><code id="get.value.from.ijk_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="get.value.from.ijk_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, default to <code>TRUE</code>. If <code>interpolate = TRUE</code>, a
trilinear interpolation of the value of the voxels, relative to the values of
adjacent voxels, is performed.</p>
</td></tr>
<tr><td><code id="get.value.from.ijk_+3A_s.ijk">s.ijk</code></td>
<td>
<p>Vector of 3 positive numbers greater than or equal to 1,
representing the new voxel ijk-sizes in which averaging is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of the values of the volume at the requested DICOM
indices.
</p>


<h3>See Also</h3>

<p><a href="#topic+get.ijk.from.index">get.ijk.from.index</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "rtdose", roi.name = "", 
                             dxyz = rep (step, 3), beam.nb = 3)
D &lt;- patient$rtdose[[1]]
# isodose
Dmax &lt;- max (D$vol3D.data, na.rm = TRUE)
Dmax
idx &lt;- which (D$vol3D.data &gt;= (Dmax -1) &amp; D$vol3D.data &lt;= (Dmax - 0.2))
ijk &lt;- get.ijk.from.index (idx, D)
get.value.from.ijk (ijk, vol = D, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='get.value.from.mesh'>Voxel value at a given depth of a mesh</h2><span id='topic+get.value.from.mesh'></span>

<h3>Description</h3>

<p>The <code>get.value.from.mesh</code> function is used to retrieve
the values of an object of class &quot;volume&quot; at the desired depth of a surface
described by a mesh. If the mesh corresponds to the &quot;patient&quot; contour,
the zero depth is the skin, positive depths enter the patient and negative depths exit to the outside.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.value.from.mesh(
  mesh,
  vol,
  method = c("point", "disk", "sphere"),
  depth = 0,
  radius = 5,
  spacing = 1,
  T.MAT = NULL,
  FUN = median,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.value.from.mesh_+3A_mesh">mesh</code></td>
<td>
<p>espadon &quot;mesh&quot; class object, or rgl/Rvcg &quot;mesh3d&quot; class object. &quot;mesh3d&quot; class object
shall an additional field &quot;ref.pseudo&quot; specifying the mesh frame of reference.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_method">method</code></td>
<td>
<p>string specifying the desired method for retrieving measurements in <code>vol</code>.
by default &quot;point&quot;. Other methods exist, for example &quot;disk&quot; or &quot;sphere. See details.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_depth">depth</code></td>
<td>
<p>Numeric value, representing the depth, relative to the surface
of the mesh, at which values are retrieved. 0 corresponds to the surface,
positive values enter the volume used to define the mesh and negative values leave it.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_radius">radius</code></td>
<td>
<p>Positive number, defining the radius of the disk or sphere,
depending on the desired method.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_spacing">spacing</code></td>
<td>
<p>spacing of the measurement points on the disk or sphere.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.T.MAT">load.T.MAT</a> or <a href="#topic+ref.add">ref.add</a>.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_fun">FUN</code></td>
<td>
<p>function to be applied to reduce the data (&quot;disk&quot; or &quot;sphere&quot; method)
to a single value.
Default, median value.</p>
</td></tr>
<tr><td><code id="get.value.from.mesh_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>FUN</code> if needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>get.value.from.mesh</code> function works at each vertex of the mesh.
It moves along the normal at that point to the desired depth.
</p>

<ul>
<li><p> When the method is &quot;point&quot;, it simply retrieves the value of the volume
<code>vol</code> specified at that point.
</p>
</li>
<li><p> When the method is &quot;disk&quot;, the values are retrieved on the disk orthogonal
to the normal,with radius <code>radius</code>.
</p>
</li>
<li><p> When the method is &quot;sphere&quot;, the values are retrieved inside the sphere
of radius <code>radius</code>.
</p>
</li></ul>

<p>For &quot;disk&quot; or &quot;sphere&quot;, the measurement points are
spaced by <code>spacing</code>. For <code>radius=5</code> and <code>spacing=1</code>, &quot;disk&quot; and &quot;sphere&quot; perform
78 and 523 measurements respectively.
In both cases, the measured values must be reduced to a single result using the
<code>FUN</code> function. By default, espadon uses the median, but it can be
provided with more complex functions to filter the data efficiently (see example below).
</p>


<h3>Value</h3>

<p>Returns a vector of values measured at the requested depth, with the
desired method, filtered by <code>FUN</code>, at each vertex of the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), roi.name = "",
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

# creation of the patient mesh
bin &lt;- bin.from.roi (CT, struct = S, roi.name = "patient", 
                     verbose = FALSE)
mesh.patient &lt;- mesh.from.bin (bin, alias = "patient", verbose = FALSE)

# density value on the skin contour, extracted from CT
density &lt;- get.value.from.mesh (mesh.patient, CT ,depth = 0) 

# Display of mesh, with RVV pal
density[density &lt; -1000] &lt;- -1000
density[density &gt; 1000] &lt;- 1000
col &lt;- pal.RVV(255)[cut (density, seq (-1000, 1000, length.out = 256), 
                        include.lowest=TRUE)]
library (rgl)
open3d ()
display.3D.mesh (mesh.patient, col = col)
</code></pre>

<hr>
<h2 id='get.value.from.xyz'>Voxel values on a selection of points</h2><span id='topic+get.value.from.xyz'></span>

<h3>Description</h3>

<p>The <code>get.value.from.xyz</code> function calculates the voxel values at
the x, y, z coordinate points in the chosen frame of reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.value.from.xyz(
  xyz,
  vol,
  xyz.ref.pseudo = NULL,
  T.MAT = NULL,
  interpolate = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.value.from.xyz_+3A_xyz">xyz</code></td>
<td>
<p>Vector of length 3, corresponding to the x, y, z
coordinates (in mm) of a point in <code>xyz.ref.pseudo</code> frame of
reference, or 3-column matrix  or dataframe of x, y, z coordinates of several points.</p>
</td></tr>
<tr><td><code id="get.value.from.xyz_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="get.value.from.xyz_+3A_xyz.ref.pseudo">xyz.ref.pseudo</code></td>
<td>
<p><code>ref.pseudo</code> in which the <code>xyz</code>
coordinate points are given. This <code>ref.pseudo</code> must exist in the <code>T.MAT</code>
list. If <code>ref.pseudo</code> is <code>NULL</code> then the point with coordinates xyz
is considered to be in the patient frame of reference <code>vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="get.value.from.xyz_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a> or <a href="#topic+load.T.MAT">load.T.MAT</a>. If
<code>T.MAT = NULL</code>, <code>xyz.ref.pseudo</code> must be equal to <code>vol$ref.pseudo</code>
or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get.value.from.xyz_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>. If <code>interpolate = TRUE</code>, a
trilinear interpolation of the value of the voxels, relative to the values of
adjacent voxels, is performed.</p>
</td></tr>
<tr><td><code id="get.value.from.xyz_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>. If <code>verbose = TRUE</code>, then
the xyz coordinates are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of the voxel values at the requested coordinates.
</p>


<h3>See Also</h3>

<p><a href="#topic+get.xyz.from.index">get.xyz.from.index</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "rtdose", roi.name = "", 
                             dxyz = rep (step, 3), beam.nb = 3)
D &lt;- patient$rtdose[[1]]
get.value.from.xyz (xyz = matrix (c (0, 0, 0, 10, 10, 10), 
                    ncol = 3, byrow = TRUE), vol = D)

# isodose
Dmax &lt;- max (D$vol3D.data, na.rm = TRUE)
idx &lt;- which (D$vol3D.data &gt;= (Dmax -1) &amp; D$vol3D.data &lt;= (Dmax - 0.3))
pt &lt;- get.xyz.from.index (idx, D)
get.value.from.xyz (pt, vol = D, interpolate = FALSE, verbose = TRUE)
</code></pre>

<hr>
<h2 id='get.volume.from.bin'>Volume selected by binary volume
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+get.volume.from.bin'></span>

<h3>Description</h3>

<p>The <code>get.volume.from.bin</code> function calculates the volume in
\(cm^3\) of the selection specified by a &quot;volume&quot; class object
of <code>"binary"</code> modality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.volume.from.bin(bin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.volume.from.bin_+3A_bin">bin</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;binary&quot; modality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the volume of the binary selection, in \(cm^3\).
</p>


<h3>See Also</h3>

<p><a href="#topic+get.volume.from.roi">get.volume.from.roi</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
step &lt;- 4
patient &lt;- toy.load.patient (modality = c ("ct", "rtstruct"), roi.name = "brain",
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]] 

# creation of a binary object
bin.brain &lt;- bin.from.roi (vol = CT, struct = S, roi.sname = "bra", 
                           verbose = FALSE)
# Volume calculation
get.volume.from.bin (bin.brain)
</code></pre>

<hr>
<h2 id='get.volume.from.roi'>Volume of a region of interest (RoI)
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+get.volume.from.roi'></span>

<h3>Description</h3>

<p>The <code>get.volume.from.roi</code> function extracts the volume
in\(cm^3\) of one or more RoI, from the <code>$roi.info</code> of the
&quot;struct&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.volume.from.roi(struct, roi.name = NULL, roi.sname = NULL, roi.idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.volume.from.roi_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="get.volume.from.roi_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="get.volume.from.roi_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the <code>struct</code>
object. By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="get.volume.from.roi_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>struct</code>
object. By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are all set
to NULL, all RoI are selected.
</p>


<h3>Value</h3>

<p>Returns a vector of the volumes in \(cm^3\) of the requested
RoI.
</p>


<h3>See Also</h3>

<p><a href="#topic+get.volume.from.bin">get.volume.from.bin</a>, <a href="#topic+select.names">select.names</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
step &lt;- 4
patient &lt;- toy.load.patient (modality = c ("rtstruct"), 
                             dxyz = rep (step, 3))
S &lt;- patient$rtstruct[[1]] 

# Volume extraction
vol &lt;- get.volume.from.roi (S, roi.sname = "bra", roi.idx = c (1, 3))
names (vol)
vol
</code></pre>

<hr>
<h2 id='get.xyz.from.index'>Conversion of the indices of a point, into xyz coordinate vector in the patient's
frame of reference</h2><span id='topic+get.xyz.from.index'></span>

<h3>Description</h3>

<p>The <code>get.xyz.from.index</code> function converts the indices of a
voxel of <code>vol$vol3D.data</code> (for example, obtained with the function
<code>which</code>) into a vector or matrix of x, y, z coordinates in the patient's
frame of reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.xyz.from.index(idx, vol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.xyz.from.index_+3A_idx">idx</code></td>
<td>
<p>Index, or matrix of voxel indices in the array <code>vol$vol3D.data</code>.
The first index of the array is 1.</p>
</td></tr>
<tr><td><code id="get.xyz.from.index_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a column-matrix of coordinates in the patient's reference frame,
corresponding to the indices <code>idx</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for better
# result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = "rtdose", roi.name = "", 
                             dxyz = rep (step, 3), beam.nb = 3)
D &lt;- patient$rtdose[[1]]

# voxels location where the dose is greater than 99.9% Dmax
Dmax &lt;- max (D$vol3D.data, na.rm = TRUE) # D$max.pixel
get.xyz.from.index (which (D$vol3D.data &gt;= 0.99 * Dmax), D)
# or
get.xyz.from.index (which (D$vol3D.data &gt;= 0.99 * Dmax, arr.ind = TRUE), D)
</code></pre>

<hr>
<h2 id='grid.equal'>Comparison of the grids of two volume objects</h2><span id='topic+grid.equal'></span>

<h3>Description</h3>

<p>The <code>grid.equal</code> function checks that two volumes share the
same grid, i.e. the same frame of reference, the same origin point, and the
same dx, dy, dz steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.equal(vol1, vol2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.equal_+3A_vol1">vol1</code>, <code id="grid.equal_+3A_vol2">vol2</code></td>
<td>
<p>&quot;volume&quot; class objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the 2 volumes share the same grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
patient &lt;- toy.load.patient (modality = c ("ct","mr","rtdose"), roi.name = "", 
                             dxyz = c (4, 4, 4), beam.nb = 1)

# Comparison of the grids
grid.equal (patient$rtdose[[1]], patient$ct[[1]])
grid.equal (patient$mr[[1]], patient$ct[[1]])
</code></pre>

<hr>
<h2 id='histo.2D'>2D histograms of 2 volumes</h2><span id='topic+histo.2D'></span>

<h3>Description</h3>

<p>The <code>histo.2D</code> function creates a &quot;histo2D&quot; class object,
containing the two-dimensional array of histograms of two &quot;volume&quot; class
objects  that have the same grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histo.2D(
  x.vol,
  y.vol,
  x.breaks = NULL,
  y.breaks = NULL,
  include.outer = TRUE,
  alias = "",
  description = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histo.2D_+3A_x.vol">x.vol</code>, <code id="histo.2D_+3A_y.vol">y.vol</code></td>
<td>
<p>&quot;volume&quot; class objects. The 2 volumes must have the
grid (i.e. share the same voxels location).</p>
</td></tr>
<tr><td><code id="histo.2D_+3A_x.breaks">x.breaks</code>, <code id="histo.2D_+3A_y.breaks">y.breaks</code></td>
<td>
<p>Vectors giving the breakpoints of x and y axes. See
Details.</p>
</td></tr>
<tr><td><code id="histo.2D_+3A_include.outer">include.outer</code></td>
<td>
<p>Boolean. If <code>include.outer = TRUE</code>, the values out
the <code>x.breaks</code> and <code>y.breaks</code> of each volume are counted in the first
and the last cell of the histograms. They are not taken into account otherwise.</p>
</td></tr>
<tr><td><code id="histo.2D_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object</p>
</td></tr>
<tr><td><code id="histo.2D_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>x.breaks</code> and <code>y.breaks</code> represent the scales
of the x and y axes of 2D-histogram graph. If they are <code>NULL</code>, the
<code>histo.2D</code> function defaults to 256 cells between the values
<code>vol$min.pixel</code> and <code>vol$max.pixel</code>.
</p>


<h3>Value</h3>

<p>Returns a &quot;histo2D&quot; class object. This is a list including:
</p>

<ul>
<li> <p><code>$patient</code>: set to <code>x.vol$patient</code>.
</p>
</li>
<li> <p><code>$patient.name</code>: set to <code>x.vol$patient.name</code>.
</p>
</li>
<li> <p><code>$patient.bd</code>: set to <code>x.vol$patient.bd</code>.
</p>
</li>
<li> <p><code>$patient.sex</code>: set to <code>x.vol$patient.sex</code>.
</p>
</li>
<li> <p><code>$file.basename</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$file.dirname</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.name</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.alias</code>: alias of the histo2D object.
</p>
</li>
<li> <p><code>$frame.of.reference</code>: set to <code>x.vol$frame.of.reference</code>.
</p>
</li>
<li> <p><code>$ref.pseudo</code> : set to <code>x.vol$ref.pseudo</code>.
</p>
</li>
<li> <p><code>$modality</code> : set to <code>"histo2D"</code>.
</p>
</li>
<li> <p><code>$description</code>: description of the histo2D object.
</p>
</li>
<li> <p><code>$creation.date</code>: set to <code>Sys.Date</code>.
</p>
</li>
<li> <p><code>$nb.pixels</code>: number of elements in the <code>density.map</code>.
</p>
</li>
<li> <p><code>$x.file.src</code>: set to x.vol$object.alias
</p>
</li>
<li> <p><code>$y.file.src</code>: set to y.vol$object.alias
</p>
</li>
<li> <p><code>x.breaks</code>: vector of x-axis breakpoints.
</p>
</li>
<li> <p><code>y.breaks</code>: vector of y-axis breakpoints.
</p>
</li>
<li> <p><code>x.mids</code>: vector of x-axis cell centers.
</p>
</li>
<li> <p><code>y.mids</code>: vector of y-axis cell centers.
</p>
</li>
<li> <p><code>density.map</code>: array of densities.
</p>
</li>
<li> <p><code>total.counts</code>: number of counted voxels.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+display.2D.histo">display.2D.histo</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "mr", "rtstruct"), 
                             roi.name =  "brain", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
MR &lt;- patient$mr[[1]]
S &lt;- patient$rtstruct[[1]]
T.MAT &lt;- patient$T.MAT

# restriction of the volume around the RoI
CT.on.roi &lt;- nesting.roi (CT, S, roi.name = "brain", vol.restrict = TRUE,
                          xyz.margin = c (1, 1, 1), alias = CT$description)
MR.on.CT &lt;- vol.regrid (vol = MR, back.vol = CT.on.roi, interpolate = TRUE,
                        T.MAT = T.MAT, alias = CT$description,
                        description = NULL)
# selection of voxels included in the RoI.
roi.bin &lt;- bin.from.roi (vol = CT.on.roi, struct = S, roi.sname = "brain", 
                         verbose = FALSE)
MR.select &lt;- vol.from.bin (MR.on.CT, roi.bin, alias = MR$description)
CT.select &lt;- vol.from.bin (CT.on.roi, roi.bin, alias = CT$description)
# 2D histogram
H2D &lt;- histo.2D (MR.select, CT.select, x.breaks = seq (50, 400, 10),
			  y.breaks = seq (50, 400, 10), alias = "H2D MR CT")
str (H2D)
</code></pre>

<hr>
<h2 id='histo.DVH'>Cumulative Dose Volume Histogram</h2><span id='topic+histo.DVH'></span>

<h3>Description</h3>

<p>The <code>histo.DVH</code> function calculates, for each dose,
the volume receiving at least this dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histo.DVH(histo, alias = "", description = histo$description)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histo.DVH_+3A_histo">histo</code></td>
<td>
<p>&quot;histo&quot; class object.</p>
</td></tr>
<tr><td><code id="histo.DVH_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="histo.DVH_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.
If the <code>description = NULL</code> (default value), it will be set to
<code>histo$description</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;dvh&quot; class object. This is a list including:
</p>

<ul>
<li> <p><code>$patient</code>: set to <code>histo$patient</code>.
</p>
</li>
<li> <p><code>$patient.name</code>: set to <code>histo$patient.name</code>.
</p>
</li>
<li> <p><code>$patient.bd</code>: set to <code>histo$patient.bd</code>.
</p>
</li>
<li> <p><code>$patient.sex</code>: set to <code>histo$patient.sex</code>.
</p>
</li>
<li> <p><code>$file.basename</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$file.dirname</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.name</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.alias</code>: alias of the dvh object..
</p>
</li>
<li> <p><code>$frame.of.reference</code>: set to <code>histo$frame.of.reference</code>.
</p>
</li>
<li> <p><code>$ref.pseudo</code> : set to <code>histo$ref.pseudo</code>.
</p>
</li>
<li> <p><code>$modality</code> : set to <code>"dvh"</code>.
</p>
</li>
<li> <p><code>$description</code>: description of  the dvh object. By default,
set to <code>histo$description</code>.
</p>
</li>
<li> <p><code>$creation.date</code>: set to <code>Sys.Date</code>.
</p>
</li>
<li> <p><code>$nb.MC</code>: set to <code>histo$nb.MC</code>.
</p>
</li>
<li> <p><code>$breaks</code>: vector breakpoints.
</p>
</li>
<li> <p><code>$mids</code>: vector of cell centers.
</p>
</li>
<li> <p><code>$mids.unit</code>: Character string, representing the unit of the abcissa
of the DVH. For instance, &quot;Gy&quot;, when <code>vol</code> is a rtdose.
</p>
</li>
<li> <p><code>$vol</code>: cumulative volume receiving at least the doses defined by <code>$mids</code>.
</p>
</li>
<li> <p><code>$pcv</code>: percentage of the total volume receiving at least the doses defined by <code>$mids</code>.
</p>
</li>
<li> <p><code>$MC.vol</code>: cumulative volume associated with <code>histo$MC.dV_dx</code>, if it exists.
</p>
</li>
<li> <p><code>$MC.pcv</code>: percentage of the total volume associated with <code>histo$MC.dV_dx</code>, if it exists.
</p>
</li>
<li> <p><code>$MC.dxyz</code>: set to <code>histo$MC.dxyz</code>, if it exists.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+histo.from.roi">histo.from.roi</a>, <a href="#topic+histo.from.bin">histo.from.bin</a>,
<a href="#topic+histo.vol">histo.vol</a>, <a href="#topic+display.DVH">display.DVH</a>, <a href="#topic+display.DVH.pc">display.DVH.pc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), 
                             roi.name = "gizzard", dxyz = rep (step, 3), 
                             beam.nb = 3)

# Calculation of the histogram
H &lt;- histo.from.roi (patient$rtdose[[1]], patient$rtstruct[[1]], 
                     roi.name = "gizzard", 
                     breaks = seq (0, 60, by = 1))

# DVH
DVH &lt;- histo.DVH (H)
str (DVH)
</code></pre>

<hr>
<h2 id='histo.from.bin'>Histogram according to a binary</h2><span id='topic+histo.from.bin'></span>

<h3>Description</h3>

<p>The <code>histo.from.bin</code> function computes the voxels histogram
of the selection defined by the binary object <code>sel.bin</code> of a &quot;volume&quot;
class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histo.from.bin(vol, sel.bin, breaks = NULL, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histo.from.bin_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object</p>
</td></tr>
<tr><td><code id="histo.from.bin_+3A_sel.bin">sel.bin</code></td>
<td>
<p>&quot;volume&quot; class object, of <code>binary</code> modality</p>
</td></tr>
<tr><td><code id="histo.from.bin_+3A_breaks">breaks</code></td>
<td>
<p>Vector giving the breakpoints between histogram cells. If
<code>breaks = NULL</code>, the chosen breakpoints are those used by the
<a href="graphics.html#topic+hist">hist</a> function by default. If <code>breaks</code> are specified,
outside values of <code>vol$vol3D.data</code> are not taken into account.</p>
</td></tr>
<tr><td><code id="histo.from.bin_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object</p>
</td></tr>
<tr><td><code id="histo.from.bin_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object. If the
<code>description = NULL</code> (default value),it will be set to <code>vol$description</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;histo&quot; class object. See <a href="#topic+histo.vol">histo.vol</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+histo.from.roi">histo.from.roi</a>, <a href="#topic+histo.vol">histo.vol</a>,
<a href="#topic+display.histo">display.histo</a>, <a href="#topic+display.dV_dx">display.dV_dx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("ct","rtstruct"), roi.name = "", 
                             dxyz = rep (step, 3))
bin.patient &lt;- bin.from.roi (patient$ct[[1]], struct = patient$rtstruct[[1]],
                             roi.name = "patient", verbose = FALSE)
# ct histogram in patient  volume
H &lt;- histo.from.bin (patient$ct[[1]], sel.bin = bin.patient, breaks = NULL, 
                     alias = "patient_hist")
str(H)

## Not run:     
# Skin dose histogram 
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), roi.name = "", 
                             dxyz = c (2, 2, 2), beam.nb = 3)
D &lt;- patient$rtdose[[1]]
S &lt;- patient$rtstruct[[1]]

# Creation of the skin contour of 3 mm
bin.patient &lt;- bin.from.roi (D, struct = S, roi.name = "patient", 
                             alias = "patient", verbose = FALSE)
inverse.patient &lt;- bin.inversion (bin.patient, alias = "inv (patient)")
expansion &lt;- bin.dilation (inverse.patient, radius = 3, 
                           alias = "inv (patient) + 3")
contour.3mm &lt;- bin.intersection (bin.patient, expansion, 
                                 alias = "contour 3 mm")

# Dose histogram in this volume
H &lt;- histo.from.bin (D, sel.bin = contour.3mm, breaks = NULL, 
                     alias = "Skin dose")
str(H)

## End(Not run)
</code></pre>

<hr>
<h2 id='histo.from.roi'>Histogram according to a RoI</h2><span id='topic+histo.from.roi'></span>

<h3>Description</h3>

<p>The <code>histo.from.roi</code> function calculates the histogram of
the volume voxels belonging to a RoI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histo.from.roi(
  vol,
  struct,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  T.MAT = NULL,
  breaks = NULL,
  MC = NULL,
  sd = c(1, 1, 1),
  offset = c(0, 0, 0),
  over.sampling.factor = 1,
  alias = "",
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histo.from.roi_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_roi.name">roi.name</code></td>
<td>
<p>Exact name of a RoI in <code>struct</code> object. By default
<code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Name or part of name of a RoI in <code>struct</code> object.
By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Value of the index of a RoI that belong to the <code>struct</code>
object. By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a> or <a href="#topic+load.T.MAT">load.T.MAT</a>. If
<code>T.MAT = NULL</code>, <code>struct$ref.pseudo</code> must be equal to
<code>vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_breaks">breaks</code></td>
<td>
<p>Vector giving the breakpoints between histogram cells. If
<code>breaks = NULL</code>, the chosen breakpoints are those used by the
<a href="graphics.html#topic+hist">hist</a> function by default. If <code>breaks</code> are specified,
outside values of <code>vol$vol3D.data</code> are not taken into account.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_mc">MC</code></td>
<td>
<p>If different from <code>NULL</code> (default value), number of calculations
that will be performed, by Monte-Carlo, by randomly moving the chosen RoI
over a random distance, generated according to a normal distribution with
mean translation defined by <code>offset</code> and
standard deviation <code>sd</code>.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_sd">sd</code></td>
<td>
<p>Vector representing the standard deviation of distances in the 3
directions x, y and z.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_offset">offset</code></td>
<td>
<p>Vector representing the translation of the RoI in the 3
directions x, y and z.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_over.sampling.factor">over.sampling.factor</code></td>
<td>
<p>Strictly positive integer, or a vector of 3 strictly
positive integers, default to 1. Defined to oversample grids of <code>vol</code>.
Oversampling can be very time consuming.</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object</p>
</td></tr>
<tr><td><code id="histo.from.roi_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object. If
the <code>description = NULL</code> (default value), it will be set to
<code>struct$roi.info$roi.pseudo[roi.idx]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> must select
only one RoI.
</p>


<h3>Value</h3>

<p>Returns &quot;histo&quot; class object. This is a list including:
</p>

<ul>
<li> <p><code>$alias</code>: alias of the histo object.
</p>
</li>
<li> <p><code>$description</code>: description of the histo object.
</p>
</li>
<li> <p><code>$breaks</code>: vector breakpoints
</p>
</li>
<li> <p><code>$mids</code>: vector of cell centers.
</p>
</li>
<li> <p><code>$mids.unit</code>: Character string, representing the unit of the abcissa
of the histogram. For instance, &quot;Gy&quot;, when <code>vol</code> is a rtdose.
</p>
</li>
<li> <p><code>counts</code>: count of voxels whose value is included in the limits
defined by <code>$breaks</code>.
</p>
</li>
<li> <p><code>dV_dx</code>: differential histogram, expressed in cm3 by voxel units,
at each <code>$mids</code>.
</p>
</li>
<li> <p><code>MC.counts</code>: array of <code>MC</code> rows. Each row <code>i</code> represents
the histogram of the voxels
contained in the RoI, whose points have been shifted by <code>$MC.dxyz[i,]</code>.
</p>
</li>
<li> <p><code>MC.dV_dx</code>: array of <code>MC</code> rows. Each row <code>i</code> represents
the differential histogram
of the voxels contained in the RoI, the points of which have been shifted by
<code>$MC.dxyz[i,]</code>.
</p>
</li>
<li> <p><code>MC.dxyz</code>: array of <code>MC</code> rows, representing the offset applied
to the RoI.
</p>
</li></ul>



<h3>Note</h3>

<p>Using Monte-Carlo can be time consuming for large RoI.
</p>
<p>If you only want the result just for a translation, use the arguments
<code>MC = 1</code>, <code>sd = 0</code> and <code>offset =</code> desired translation vector.
</p>


<h3>See Also</h3>

<p><a href="#topic+histo.vol">histo.vol</a>, <a href="#topic+histo.from.bin">histo.from.bin</a>,
<a href="#topic+display.histo">display.histo</a>, <a href="#topic+display.dV_dx">display.dV_dx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for better
# result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), 
                             roi.name = "gizzard", dxyz = rep (step, 3), 
                             beam.nb = 3)

# Calculation of the histogram
H &lt;- histo.from.roi (patient$rtdose[[1]], patient$rtstruct[[1]], 
                     roi.name = "gizzard", 
                     breaks = seq (0, 60, by = 1))
str (H)
</code></pre>

<hr>
<h2 id='histo.vol'>Histogram of a volume
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+histo.vol'></span>

<h3>Description</h3>

<p>The <code>histo.vol</code> function calculates the voxel values
histogram of &quot;volume&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histo.vol(vol, breaks = NULL, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histo.vol_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="histo.vol_+3A_breaks">breaks</code></td>
<td>
<p>Vector giving the breakpoints between histogram cells. If
<code>breaks = NULL</code>,
the chosen breakpoints are those used by the <a href="graphics.html#topic+hist">hist</a> function
by default. If <code>breaks</code> are specified, outside values of <code>vol$vol3D.data</code>
are not taken into account.</p>
</td></tr>
<tr><td><code id="histo.vol_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="histo.vol_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object. If the
<code>description = NULL</code> (default value), it will be set to <code>vol$description</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;histo&quot; class object. This is a list including:
</p>

<ul>
<li> <p><code>$patient</code>: set to <code>vol$patient</code>.
</p>
</li>
<li> <p><code>$patient.name</code>: set to <code>vol$patient.name</code>.
</p>
</li>
<li> <p><code>$patient.bd</code>: set to <code>vol$patient.bd</code>.
</p>
</li>
<li> <p><code>$patient.sex</code>: set to <code>vol$patient.sex</code>.
</p>
</li>
<li> <p><code>$file.basename</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$file.dirname</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.name</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.alias</code>: alias of the histo object.
</p>
</li>
<li> <p><code>$frame.of.reference</code>: set to <code>vol$frame.of.reference</code>.
</p>
</li>
<li> <p><code>$ref.pseudo</code> : set to <code>vol$ref.pseudo</code>.
</p>
</li>
<li> <p><code>$modality</code> : set to <code>"histo"</code>.
</p>
</li>
<li> <p><code>$description</code>: description of the histo object.
</p>
</li>
<li> <p><code>$creation.date</code>: set to <code>Sys.Date</code>.
</p>
</li>
<li> <p><code>$nb.MC</code>: set to 0.
</p>
</li>
<li> <p><code>$breaks</code>: vector breakpoints
</p>
</li>
<li> <p><code>$mids</code>: vector of cell centers.
</p>
</li>
<li> <p><code>$mids.unit</code>: Character string, representing the unit of the abcissa
of the histogram. For instance, &quot;Gy&quot;, when <code>vol</code> is a rtdose.
</p>
</li>
<li> <p><code>counts</code>: count of voxels whose value is included in the limits
defined by <code>$breaks</code>.
</p>
</li>
<li> <p><code>dV_dx</code>: differential histogram, expressed in \(cm^3\) by voxel units,
at each <code>$mids</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+histo.from.roi">histo.from.roi</a>, <a href="#topic+histo.from.bin">histo.from.bin</a>,
<a href="#topic+display.histo">display.histo</a>, <a href="#topic+display.dV_dx">display.dV_dx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
step &lt;- 3
patient &lt;- toy.load.patient (modality = "ct", dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]

# histogram and display
H &lt;- histo.vol (CT, breaks = seq (3, ceiling (CT$max.pixel), 1), 
                alias = "CT_hist")
str (H)
</code></pre>

<hr>
<h2 id='load.obj.data'>Load data of an <span class="pkg">espadon</span> class object</h2><span id='topic+load.obj.data'></span>

<h3>Description</h3>

<p>The <code>load.obj.data</code> function loads all the data of an <span class="pkg">espadon</span>
object of class '<code>struct</code>' or '<code>volume</code>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.obj.data(obj, tag.dictionary = dicom.tag.dictionary())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.obj.data_+3A_obj">obj</code></td>
<td>
<p><code>struct</code> or &quot;volume&quot; class object</p>
</td></tr>
<tr><td><code id="load.obj.data_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>, whose structure it must keep.
This dataframe is used to parse DICOM files in case obj was extracted from DICOM files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <span class="pkg">espadon</span> object with data <code>$vol3D.data</code> or <code>$roi.data</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+load.obj.from.dicom">load.obj.from.dicom</a> and <a href="#topic+load.obj.from.Rdcm">load.obj.from.Rdcm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy patient objects to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = c (4, 4, 4))
save.to.Rdcm (patient$ct[[1]], dirname = pat.dir)
rm( patient)


patient &lt;- load.patient.from.Rdcm (pat.dir, data = FALSE)
CT &lt;- load.obj.data (patient$ct[[1]])
str (CT, max.level = 2)
# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='load.obj.from.dicom'>Loading an <span class="pkg">espadon</span> object from DICOM files or folder</h2><span id='topic+load.obj.from.dicom'></span>

<h3>Description</h3>

<p>Loading an <span class="pkg">espadon</span> object from DICOM files or folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.obj.from.dicom(
  dcm.files,
  data = TRUE,
  ref.pseudo = "ref1",
  tag.dictionary = dicom.tag.dictionary(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.obj.from.dicom_+3A_dcm.files">dcm.files</code></td>
<td>
<p>String vector, representing the list of the full names of the
DICOM files of the same DICOM object, or its directory.</p>
</td></tr>
<tr><td><code id="load.obj.from.dicom_+3A_data">data</code></td>
<td>
<p>Boolean. Only valid for objects usable by the <span class="pkg">espadon</span> package,
namely ct, mr, rtdose, rtstruct, pt... If <code>data = TRUE</code>, either the values
of the voxels when modality is (ct, mr, rtdose, pt), or the coordinates of the
RoI when modality is rtstruct, are loaded into memory.</p>
</td></tr>
<tr><td><code id="load.obj.from.dicom_+3A_ref.pseudo">ref.pseudo</code></td>
<td>
<p>String, <code>$ref.pseudo</code> (i.e. pseudonym of the frame of
reference)
to assign to the loaded object.</p>
</td></tr>
<tr><td><code id="load.obj.from.dicom_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="load.obj.from.dicom_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, a progress bar indicates the progress
of the conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <span class="pkg">espadon</span> object of class &quot;dvh&quot;,&quot;histo&quot;,&quot;histo2D&quot;,&quot;mesh&quot;,
&quot;rtplan&quot;,&quot;struct&quot;, &quot;undef&quot; or &quot;volume&quot; depending on the object modality. See
<a href="#topic+espadon.class">espadon.class</a> for class definitions.
</p>


<h3>See Also</h3>

<p><a href="#topic+load.obj.data">load.obj.data</a> and <a href="#topic+load.obj.from.Rdcm">load.obj.from.Rdcm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy.dicom.raw () raw data to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_dcm") 
dir.create (pat.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "toyrtplan", tmpdir = pat.dir,
                          fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)

# loading of rt-plan object
RTplan &lt;- load.obj.from.dicom (dcm.filename)
str (RTplan)
# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='load.obj.from.Rdcm'>Loading an <span class="pkg">espadon</span> object from *.Rdcm file</h2><span id='topic+load.obj.from.Rdcm'></span>

<h3>Description</h3>

<p>The <code>load.obj.from.Rdcm</code> function loads a DICOM object into
memory, creating a list containing the information necessary for its subsequent
use with the <span class="pkg">espadon</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.obj.from.Rdcm(
  Rdcm.filename,
  data = TRUE,
  nb = NULL,
  upgrade.to.latest.version = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.obj.from.Rdcm_+3A_rdcm.filename">Rdcm.filename</code></td>
<td>
<p>Character string, representing the full name of a *.Rdcm
file created by <a href="#topic+dicom.to.Rdcm.converter">dicom.to.Rdcm.converter</a>.</p>
</td></tr>
<tr><td><code id="load.obj.from.Rdcm_+3A_data">data</code></td>
<td>
<p>Boolean. Only works for objects usable by the <span class="pkg">espadon</span> package, namely
ct, mr, rtdose, rtstruct, pt... If <code>data = TRUE</code>, either the values of the
voxels when modality is (ct, mr, rtdose), or the coordinates of the RoI when modality
is rtstruct, are loaded into memory.</p>
</td></tr>
<tr><td><code id="load.obj.from.Rdcm_+3A_nb">nb</code></td>
<td>
<p>Vector of integers, active only if <code>data = TRUE</code>, and only
operating on rtstruct. If <code>nb = NULL</code>, all the RoI of rtstruct are
loaded into memory. Otherwise only data of the RoI indices defined by the vector
<code>nb</code> are loaded.</p>
</td></tr>
<tr><td><code id="load.obj.from.Rdcm_+3A_upgrade.to.latest.version">upgrade.to.latest.version</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function attempts
to upgrade to the latest version, parsing the DICOM data. It may take longer
to load the data. Consider using the <a href="#topic+Rdcm.upgrade">Rdcm.upgrade</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <span class="pkg">espadon</span> object of class &quot;dvh&quot;,&quot;histo&quot;,&quot;histo2D&quot;,&quot;mesh&quot;,
&quot;rtplan&quot;,&quot;struct&quot;, &quot;undef&quot; or &quot;volume&quot; depending on the object modality. See
<a href="#topic+espadon.class">espadon.class</a> for class definitions.
</p>


<h3>See Also</h3>

<p><a href="#topic+load.obj.data">load.obj.data</a> and <a href="#topic+load.obj.from.dicom">load.obj.from.dicom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy patient objects to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = c (4, 4, 4))
save.to.Rdcm (patient$ct[[1]], dirname = pat.dir)
save.to.Rdcm (patient$mr[[1]], dirname = pat.dir)
save.T.MAT (patient$T.MAT, dirname = pat.dir)
# Rdcm files in pat.dir
list.files(pat.dir)

CT &lt;- load.obj.from.Rdcm (file.path (pat.dir, 
                                     list.files(pat.dir, pattern="ct1[.]Rdcm")[1]),
                          data=TRUE)
MR &lt;- load.obj.from.Rdcm (file.path (pat.dir, 
                                     list.files(pat.dir, pattern="mr1[.]Rdcm")[1]),
                          data=TRUE)
Reg &lt;-load.obj.from.Rdcm (file.path (pat.dir,"ref1_from_ref2.Rdcm"), data=TRUE)     
str(Reg)

# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)  
</code></pre>

<hr>
<h2 id='load.patient.from.dicom'>Loading patient data from DICOM files</h2><span id='topic+load.patient.from.dicom'></span>

<h3>Description</h3>

<p>The <code>load.patient.from.dicom</code> function is used to load or
pre-load in memory all patient objects from DICOM files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.patient.from.dicom(
  dcm.files,
  data = FALSE,
  dvh = FALSE,
  ignore.duplicates = FALSE,
  tag.dictionary = dicom.tag.dictionary(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.patient.from.dicom_+3A_dcm.files">dcm.files</code></td>
<td>
<p>String vector, representing the list of the full names of the
DICOM files of the same patient, or its directories.</p>
</td></tr>
<tr><td><code id="load.patient.from.dicom_+3A_data">data</code></td>
<td>
<p>Boolean. If <code>data = TRUE</code>, the voxels value of the &quot;volume&quot;
class objects, or the coordinates of the RoI (region of interest)
of the <code>struct</code> class objects, are loaded into memory.</p>
</td></tr>
<tr><td><code id="load.patient.from.dicom_+3A_dvh">dvh</code></td>
<td>
<p>Boolean. if <code>dvh = TRUE</code> and if they exist, patient DVH are
loaded, for convenience. They are not used as is in <span class="pkg">espadon</span> package.</p>
</td></tr>
<tr><td><code id="load.patient.from.dicom_+3A_ignore.duplicates">ignore.duplicates</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function ignores duplicated objects.</p>
</td></tr>
<tr><td><code id="load.patient.from.dicom_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to
<a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
<tr><td><code id="load.patient.from.dicom_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, a progress bar indicates loading progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <span class="pkg">espadon</span> object of class &quot;patient&quot;, describing the
information from <code>dcm.files</code>. See <a href="#topic+espadon.class">espadon.class</a> for a
description of the &quot;patient&quot; class.
</p>


<h3>See Also</h3>

<p><a href="#topic+dicom.to.Rdcm.converter">dicom.to.Rdcm.converter</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.obj.data">load.obj.data</a>,  <a href="#topic+load.obj.from.dicom">load.obj.from.dicom</a>,
<a href="#topic+load.obj.from.Rdcm">load.obj.from.Rdcm</a> and <a href="#topic+load.T.MAT">load.T.MAT</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy.dicom.raw () raw data to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "toy_dcm") 
dir.create (pat.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "toyrtplan", tmpdir = pat.dir,
                          fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)

# loading patient. Here the toy patient ha only a unique rt-plan object
patient &lt;- load.patient.from.dicom (pat.dir, data = FALSE)
str (patient, max = 2)
# description of object
patient$description
# transfer matrices :
patient$T.MAT
# rt-plan object
str (patient$rtplan[[1]])
# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='load.patient.from.Rdcm'>Loading patient data from *.Rdcm files</h2><span id='topic+load.patient.from.Rdcm'></span>

<h3>Description</h3>

<p>The <code>load.patient.from.Rdcm</code> function is used to load or
pre-load in memory all patient objects converted in *.Rdcm files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.patient.from.Rdcm(
  dirname,
  data = FALSE,
  dvh = FALSE,
  upgrade.to.latest.version = FALSE,
  ignore.duplicates = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.patient.from.Rdcm_+3A_dirname">dirname</code></td>
<td>
<p>Full paths of the directories of a single patient, or vector
of full.path of Rdcm.files.</p>
</td></tr>
<tr><td><code id="load.patient.from.Rdcm_+3A_data">data</code></td>
<td>
<p>Boolean. If <code>data = TRUE</code>, the voxels value of the &quot;volume&quot;
class objects, or the coordinates of the RoI (region of interest)
of the <code>struct</code> class objects, are loaded into memory.</p>
</td></tr>
<tr><td><code id="load.patient.from.Rdcm_+3A_dvh">dvh</code></td>
<td>
<p>Boolean. if <code>dvh = TRUE</code> and if they exist, patient DVH are
loaded, for convenience. They are not used as is in <span class="pkg">espadon</span> package.</p>
</td></tr>
<tr><td><code id="load.patient.from.Rdcm_+3A_upgrade.to.latest.version">upgrade.to.latest.version</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function attempts
to upgrade to the latest version, parsing the DICOM data. It may take longer
to load the data. Consider using the<a href="#topic+Rdcm.upgrade">Rdcm.upgrade</a> function.</p>
</td></tr>
<tr><td><code id="load.patient.from.Rdcm_+3A_ignore.duplicates">ignore.duplicates</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function ignores duplicated objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <span class="pkg">espadon</span> object of class &quot;patient&quot;, describing the
information contained in <code>dirname</code>. See <a href="#topic+espadon.class">espadon.class</a> for a
description of the &quot;patient&quot; class.
</p>


<h3>See Also</h3>

<p><a href="#topic+dicom.to.Rdcm.converter">dicom.to.Rdcm.converter</a>, <a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>,
<a href="#topic+load.obj.data">load.obj.data</a>, <a href="#topic+load.obj.from.dicom">load.obj.from.dicom</a>,
<a href="#topic+load.obj.from.Rdcm">load.obj.from.Rdcm</a> and <a href="#topic+load.T.MAT">load.T.MAT</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy patient objects to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = c (4, 4, 4))
save.to.Rdcm (patient$ct[[1]], dirname = pat.dir)
save.to.Rdcm (patient$mr[[1]], dirname = pat.dir)
save.T.MAT (patient$T.MAT, dirname = pat.dir)
# Rdcm files in pat.dir
list.files(pat.dir)

# loading patient from Rdcm files with data: 
new.patient &lt;- load.patient.from.Rdcm (pat.dir, data = TRUE)
str (new.patient, max.level = 2 )

# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='load.Rdcm.raw.data'>Loading a *.Rdcm file</h2><span id='topic+load.Rdcm.raw.data'></span>

<h3>Description</h3>

<p>the <code>load.Rdcm.raw.data</code> function loads the content of a *.Rdcm file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.Rdcm.raw.data(
  Rdcm.filename,
  address = TRUE,
  data = TRUE,
  upgrade.to.latest.version = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.Rdcm.raw.data_+3A_rdcm.filename">Rdcm.filename</code></td>
<td>
<p>Character string, representing the full name of a *.Rdcm
file created by <a href="#topic+dicom.to.Rdcm.converter">dicom.to.Rdcm.converter</a>.</p>
</td></tr>
<tr><td><code id="load.Rdcm.raw.data_+3A_address">address</code></td>
<td>
<p>Boolean. If TRUE, a dataframe with the address of the tags in
the raw DICOM data is returned.</p>
</td></tr>
<tr><td><code id="load.Rdcm.raw.data_+3A_data">data</code></td>
<td>
<p>Boolean. If TRUE, the DICOM information are returned as an R list.</p>
</td></tr>
<tr><td><code id="load.Rdcm.raw.data_+3A_upgrade.to.latest.version">upgrade.to.latest.version</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function attempts
to upgrade to the latest version, parsing the DICOM data. It may take longer
to load the data. Consider using the <a href="#topic+Rdcm.upgrade">Rdcm.upgrade</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the information, converted by <span class="pkg">espadon</span>, of a
DICOM object..
</p>


<h3>See Also</h3>

<p><a href="#topic+dicom.to.Rdcm.converter">dicom.to.Rdcm.converter</a>, <a href="#topic+load.obj.from.Rdcm">load.obj.from.Rdcm</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For testing, save first toy.dicom.raw () raw data to a temporary file, and
# convert it in Rdcm fie
pat.src.dir &lt;- file.path (tempdir(), "PM_dcm") 
dir.create (pat.src.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "PM_rtplan", tmpdir = pat.src.dir,
                          fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm")
dicom.to.Rdcm.converter (pat.src.dir, pat.dir, update = TRUE)
lf &lt;- list.files (pat.dir, pattern = "[.]Rdcm$", full.names = TRUE)
lf

# Inspect Rdcm raw data
L &lt;- load.Rdcm.raw.data (lf[1])
str (L, max.level =3)

# Cleaning  temporary directory
unlink (pat.src.dir, recursive = TRUE)  
</code></pre>

<hr>
<h2 id='load.T.MAT'>Loading of information about transfer matrices between frames of reference of
patient Rdcm objects.</h2><span id='topic+load.T.MAT'></span>

<h3>Description</h3>

<p>The <code>load.T.MAT</code> function lists all the frames of reference
of the objects included in the patient directory. It concatenates all the
information of the reg matrices of a directory, creating, among  other things,
a list of 4x4 transfer matrices between frames of reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.T.MAT(dirname, upgrade.to.latest.version = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.T.MAT_+3A_dirname">dirname</code></td>
<td>
<p>Full paths of the directories of a single patient, or vector
of full.path of Rdcm.files.</p>
</td></tr>
<tr><td><code id="load.T.MAT_+3A_upgrade.to.latest.version">upgrade.to.latest.version</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function attempts
to upgrade to the latest version, parsing the DICOM data. It may take longer
to load the data. Consider using the <a href="#topic+Rdcm.upgrade">Rdcm.upgrade</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;t.mat&quot; class object. It is a list that includes :
</p>

<ul>
<li> <p><code>$ref.info</code>: dataframe giving the correspondence between the frame of
reference (column <code>$ref</code>) of the DICOM object (TAG (0020,0052) ) and its
pseudonym (column <code>$ref_pseudo</code>).
</p>
</li>
<li> <p><code>$reg.info</code>:list of dataframes : the first one gives the PID,
birthday, and sex of the patient, the second one gives the name of the source
file of transfer matrices.
</p>
</li>
<li> <p><code>$matrix.description</code>: dataframe giving the transfer matrix names
(column <code>$t</code>), its source frame of reference (column <code>$src</code>), the
destination frame of reference (column <code>$dest</code>), and its type (<code>$type</code>).
Note: only the RIGID type is supported.
</p>
</li>
<li> <p><code>$matrix.list</code>: list of 4X4 transfer matrices. This list contains
at least as many Identity matrices as there are <code>ref.pseudo</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># First, save toy patient objects to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = c (4, 4, 4))
save.to.Rdcm (patient$ct[[1]], dirname = pat.dir)
save.to.Rdcm (patient$mr[[1]], dirname = pat.dir)
save.T.MAT (patient$T.MAT, dirname = pat.dir)
# Rdcm files in pat.dir
list.files(pat.dir)

T.MAT &lt;- load.T.MAT (pat.dir)
T.MAT

# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='mesh.from.bin'>Creation of a mesh according to a binary volume</h2><span id='topic+mesh.from.bin'></span>

<h3>Description</h3>

<p>The <code>mesh.from.bin</code> function creates a <code>mesh</code> class
object from a volume object of &quot;binary&quot; modality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.from.bin(
  bin,
  alias = "",
  tol = min(abs(bin$dxyz))/2,
  smooth.iteration = 10,
  smooth.type = c("taubin", "laplace", "HClaplace", "fujiLaplace", "angWeight",
    "surfPreserveLaplace"),
  smooth.lambda = 0.5,
  smooth.mu = -0.53,
  smooth.delta = 0.1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh.from.bin_+3A_bin">bin</code></td>
<td>
<p>&quot;volume&quot; class object of &quot;binary&quot; modality.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the mesh defining
the <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_tol">tol</code></td>
<td>
<p>Tolerance in mm, applied for mesh simplification. See <a href="Rvcg.html#topic+vcgClean">vcgClean</a>.
The default value, equal to half the smallest voxel edge, limits meshing errors.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_smooth.iteration">smooth.iteration</code></td>
<td>
<p>Number of iterations applied in the smoothing algorithm.
See <a href="Rvcg.html#topic+vcgSmooth">vcgSmooth</a>.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_smooth.type">smooth.type</code></td>
<td>
<p>character: select smoothing algorithm. Available are &quot;taubin&quot;,
&quot;laplace&quot;, &quot;HClaplace&quot;, &quot;fujiLaplace&quot;, &quot;angWeight&quot; (and any sensible abbreviations).
By default, set to &quot;taubin&quot;. See <a href="Rvcg.html#topic+vcgSmooth">vcgSmooth</a>.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_smooth.lambda">smooth.lambda</code></td>
<td>
<p>numeric: parameter for Taubin smooth. See <a href="Rvcg.html#topic+vcgSmooth">vcgSmooth</a>.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_smooth.mu">smooth.mu</code></td>
<td>
<p>numeric: parameter for Taubin smooth. See <a href="Rvcg.html#topic+vcgSmooth">vcgSmooth</a>.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_smooth.delta">smooth.delta</code></td>
<td>
<p>numeric: parameter for Scale dependent laplacian smoothing
(see reference below).and maximum allowed angle (in radians) for deviation
between normals Laplacian (surface preserving). See <a href="Rvcg.html#topic+vcgSmooth">vcgSmooth</a>.</p>
</td></tr>
<tr><td><code id="mesh.from.bin_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, by default set to <code>FALSE</code>. Allows you to inhibit comments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;mesh&quot; class object. This is a list including the
following 6 elements:
</p>

<ul>
<li> <p><code>$patient</code>: set to <code>bin$patient</code>.
</p>
</li>
<li> <p><code>$patient.bd</code>: set to <code>bin$patient.bd</code>.
</p>
</li>
<li> <p><code>$patient.name</code>: set to <code>bin$patient.name</code>.
</p>
</li>
<li> <p><code>$patient.sex</code>: set to <code>bin$patient.sex</code>.
</p>
</li>
<li> <p><code>$file.basename</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$file.dirname</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.name</code>: set to &quot;&quot;.
</p>
</li>
<li> <p><code>$object.alias</code>: set to the <code>alias</code> argument of the function.
</p>
</li>
<li> <p><code>$frame.of.reference</code>: set to <code>bin$frame.of.reference</code>.
</p>
</li>
<li> <p><code>$ref.pseudo</code> : set to <code>bin$ref.pseudo</code>.
</p>
</li>
<li> <p><code>$modality</code> : set to <code>"mesh"</code>.
</p>
</li>
<li> <p><code>$description</code>: By default, set to <code>paste (bin$object.alias, "mesh")</code>.
</p>
</li>
<li> <p><code>$creation.date</code>: set to <code>Sys.Date</code>.
</p>
</li>
<li> <p><code>$nb.faces</code>: set to the number of faces of the mesh.
</p>
</li>
<li> <p><code>$mesh</code>: list of 3 elements defining the mesh:
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$vb</code>: array made up of the generalized coordinates (x, y, z, 1) of the vertices of the triangles.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> There are as many columns as there are vertices.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$it</code>: array of the 3 indices of the vertices forming a triangle, arranged by column.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> There are as many columns as there are triangles in the mesh.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> - <code>$normals</code>: array made up of the generalized coordinates (x, y, z, 1) of the normal vectors of each triangle.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> There are as many columns as there are vertices.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

</li></ul>



<h3>Note</h3>

<p>To compute the mesh, all NA voxels of the binary volume <code>bin</code> are
set to FALSE. If all voxels are equal to FALSE, the function returns the code <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><a href="Rvcg.html#topic+vcgSmooth">vcgSmooth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), roi.name = "",
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

# creation of the patient mesh
bin &lt;- bin.from.roi (CT, struct = S, roi.name = "patient", verbose = FALSE)
mesh.patient &lt;- mesh.from.bin (bin, alias = "patient", verbose = FALSE)
str (mesh.patient)
</code></pre>

<hr>
<h2 id='mesh.in.new.ref'>Change of frame of reference of a mesh</h2><span id='topic+mesh.in.new.ref'></span>

<h3>Description</h3>

<p>The <code>mesh.in.new.ref</code> function allows you to change the frame
of reference of a mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.in.new.ref(
  mesh,
  new.ref.pseudo,
  T.MAT = NULL,
  alias = "",
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh.in.new.ref_+3A_mesh">mesh</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="mesh.in.new.ref_+3A_new.ref.pseudo">new.ref.pseudo</code></td>
<td>
<p>pseudonym of the frame of reference in which the mesh
should be located. This <code>new.ref.pseudo</code> must exist in the <code>T.MAT</code> list.</p>
</td></tr>
<tr><td><code id="mesh.in.new.ref_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.T.MAT">load.T.MAT</a> or <a href="#topic+ref.add">ref.add</a>.</p>
</td></tr>
<tr><td><code id="mesh.in.new.ref_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="mesh.in.new.ref_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be that of the <code>mesh</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;mesh&quot; class object in the new frame of reference <code>new.ref.pseudo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct", "mr"), 
                             roi.name = "", dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

#creation of the patient mesh
bin &lt;- bin.from.roi (CT, struct = S, roi.name = "patient", verbose = FALSE)
mesh.patient &lt;- mesh.from.bin (bin, alias = "patient", verbose = FALSE)

# mesh in the MR frame of reference
new.mesh &lt;- mesh.in.new.ref (mesh.patient, patient$mr[[1]]$ref.pseudo, 
                             T.MAT = patient$T.MAT)

str (new.mesh, max.level = 2)                             
</code></pre>

<hr>
<h2 id='mesh.repair'>Repair of a mesh</h2><span id='topic+mesh.repair'></span>

<h3>Description</h3>

<p>The <code>mesh.repair</code> function repairs holes in a <code>mesh</code>
class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.repair(mesh, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh.repair_+3A_mesh">mesh</code></td>
<td>
<p>&quot;mesh&quot; class object.</p>
</td></tr>
<tr><td><code id="mesh.repair_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, by default set to <code>FALSE</code>. Allows you to inhibit
comments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a mesh, repaired by removing degenerated triangles and filling holes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), 
                             roi.name = "gizzard", dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

# creation of the gizzard mesh
bin &lt;- bin.from.roi (CT, struct = S, roi.name = "gizzard", verbose = FALSE)
mesh.gizzard &lt;- mesh.from.bin (bin, alias = "gizzard", verbose = FALSE)

repair.mesh.gizzard &lt;- mesh.repair (mesh.gizzard, verbose = FALSE)
str (mesh.gizzard)
str (repair.mesh.gizzard)
</code></pre>

<hr>
<h2 id='mesh.spheric.proj'>Adding spherical coordinates to a mesh</h2><span id='topic+mesh.spheric.proj'></span>

<h3>Description</h3>

<p>The <code>mesh.spheric.proj</code> function adds latitude and longitude
coordinates to a mesh. These features map the mesh surface to a sphere.
Latitude and longitude are computed using the heat diffusion approach explained by
<em>Brechbhler and al</em> <strong>[1]</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.spheric.proj(mesh, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh.spheric.proj_+3A_mesh">mesh</code></td>
<td>
<p>&quot;mesh&quot; class object.</p>
</td></tr>
<tr><td><code id="mesh.spheric.proj_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, by default set to <code>FALSE</code>. Allows you to inhibit
comments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a &quot;mesh&quot; class object in which <code>$mesh</code> contains <code>Lat</code>
and <code>lon</code> evaluated at vertices.
The function allows to have a parameterized surface  for later computations
as curvature or shape index, hence, nor the surface, nor the angles are preserved.
In the DICOM frame of reference, latitude goes along Z axis (from feet = -1 to
head = +1) and longitude turns counter clockwise (from -1 to +1).
</p>


<h3>Note</h3>

<p>This funtion is time consuming.
</p>


<h3>References</h3>

<p><strong>[1]</strong> Brechbuhler C, Gerig G, Kubler O (1995).
&ldquo;Parametrization of Closed Surfaces for 3-D Shape Description.&rdquo;
<em>Computer Vision and Image Understanding</em>, <b>61</b>(2), 154-170.
ISSN 1077-3142, <a href="https://doi.org/10.1006/cviu.1995.1013">doi:10.1006/cviu.1995.1013</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), roi.name = "", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

#creation of the patient mesh
bin &lt;- bin.from.roi (CT, struct = S, roi.name = "patient", verbose = FALSE)
m.patient &lt;- mesh.from.bin (bin)
m.skin &lt;- mesh.repair (m.patient, verbose = FALSE)

m.proj &lt;- mesh.spheric.proj (m.skin, verbose = FALSE)

library (rgl)
col &lt;- hcl.colors (12, "Blue-Red 3")
open3d()
shade3d (m.proj$mesh, meshColors = "vertices",
         color = col[round ((m.proj$mesh$Lat/2 + 0.5) * 11) + 1],
         specular = "#404040")
open3d()         
shade3d (m.proj$mesh, meshColors = "vertices",
         color = col[round ((m.proj$mesh$Lon/2 + 0.5) * 11) + 1],
         specular = "#404040")

</code></pre>

<hr>
<h2 id='nesting.bin'>Restrict volume to a binary selection</h2><span id='topic+nesting.bin'></span>

<h3>Description</h3>

<p>The <code>nesting.bin</code> function restricts a &quot;volume&quot; class
object to the rectangular parallelepiped circumscribed to the selected voxels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nesting.bin(
  obj,
  sel.bin,
  alias = "",
  description = NULL,
  xyz.margin = c(0, 0, 0),
  obj.restrict = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nesting.bin_+3A_obj">obj</code></td>
<td>
<p>&quot;volume&quot; class object, containing data to restrict.</p>
</td></tr>
<tr><td><code id="nesting.bin_+3A_sel.bin">sel.bin</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;binary&quot; modality, specifying the selected voxels.</p>
</td></tr>
<tr><td><code id="nesting.bin_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="nesting.bin_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.
If <code>description = NULL</code>, it will be
<code>paste (obj$description,"restricted to", sel.bin$description)</code>.</p>
</td></tr>
<tr><td><code id="nesting.bin_+3A_xyz.margin">xyz.margin</code></td>
<td>
<p>Numeric vector of length 3, by default set to <code>c (0, 0, 0)</code>.
See details.</p>
</td></tr>
<tr><td><code id="nesting.bin_+3A_obj.restrict">obj.restrict</code></td>
<td>
<p>Boolean. Used if <code>obj</code> is of class &quot;volume&quot;. If
<code>obj.restrict = TRUE</code>, the rectangular parallelepiped circumscribed to
the selected voxels, enlarged by xyz.margin cannot exceed the initial volume.</p>
</td></tr>
<tr><td><code id="nesting.bin_+3A_...">...</code></td>
<td>
<p>Argument such as T.MAT, or for deprecated arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>obj</code> is of class &quot;volume&quot;, <code>xyz.margin</code> represents the
distances in mm to be added to the x, y and z directions of the rectangular
parallelepiped circumscribed to the voxels selected in <code>sel.bin</code>, in the
<code>obj</code> frame of reference.
</p>
<p>If <code>obj</code> is of class &quot;mesh&quot;, <code>sel.bin</code> will undergo margin
expansion any operation on the <code>obj</code>.
</p>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object, in which 3D volume is limited to the
rectangular parallelepiped circumscribed to the voxels selected by <code>sel.bin</code>, increased by the
requested margins.
</p>


<h3>See Also</h3>

<p><a href="#topic+add.margin">add.margin</a>, <a href="#topic+nesting.cube">nesting.cube</a> and
<a href="#topic+nesting.roi">nesting.roi</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for  better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), 
                             roi.name = "brain", dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
b &lt;- bin.from.vol (CT, min = 0, max =200)

CT.restricted &lt;- nesting.bin (CT, b, xyz.margin =  rep (step, 3))
display.plane (bottom = CT.restricted, top = b, view.type = "sagi",
             bottom.col = pal.RVV (1000),
             bottom.breaks = seq (-1000, 1000, length.out = 1001),
             bg = "#00ff00",  interpolate  = FALSE)
</code></pre>

<hr>
<h2 id='nesting.cube'>Restriction of a volume to a rectangular parallelepiped</h2><span id='topic+nesting.cube'></span>

<h3>Description</h3>

<p>The <code>nesting.cube</code> function restricts or increases
a volume to the rectangular parallelepiped defined by its 2 extreme vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nesting.cube(obj, pt.min, pt.max, alias = "", description = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nesting.cube_+3A_obj">obj</code></td>
<td>
<p>object of class volume or mesh.</p>
</td></tr>
<tr><td><code id="nesting.cube_+3A_pt.min">pt.min</code></td>
<td>
<p>minimum x, y, z coordinates of the rectangular parallelepiped vertex.</p>
</td></tr>
<tr><td><code id="nesting.cube_+3A_pt.max">pt.max</code></td>
<td>
<p>maximum x, y, z coordinates of the rectangular parallelepiped vertex.</p>
</td></tr>
<tr><td><code id="nesting.cube_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="nesting.cube_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object. If
the <code>description = NULL</code> (default value), it will be set to <code>obj$description</code>.</p>
</td></tr>
<tr><td><code id="nesting.cube_+3A_...">...</code></td>
<td>
<p>Additional arguments <code>vol</code> (depracated), replaced by <code>obj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object, in which 3D volume is restricted
or increased to be circumscribed to the requested rectangular parallelepiped.
If the created volume exceeds the initial volume, new voxels are set to <code>NA</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+add.margin">add.margin</a>, <a href="#topic+nesting.roi">nesting.roi</a> and
<a href="#topic+nesting.bin">nesting.bin</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = "ct", roi.name = "", 
                             dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
# Calculation of the new CT restricted to the parallelepiped reduced by 10 mm.
pt.CT &lt;- get.extreme.pt (CT) # extreme points of CT
new.pt.CT &lt;- pt.CT + matrix (rep (c (+ 12, -12), 3), ncol = 2, byrow = TRUE)
new.CT &lt;- nesting.cube (CT, new.pt.CT$min, new.pt.CT$max, alias = "new CT")
## Not run:   
# check for change
display.3D.stack (CT)
display.3D.stack (new.CT, line.col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='nesting.roi'>Restrict volume to RoI</h2><span id='topic+nesting.roi'></span>

<h3>Description</h3>

<p>The <code>nesting.roi</code> function restricts a &quot;volume&quot; class
object to the rectangular parallelepiped circumscribed to the chosen RoI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nesting.roi(
  obj,
  struct,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  xyz.margin = c(0, 0, 0),
  obj.restrict = FALSE,
  T.MAT = NULL,
  alias = "",
  description = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nesting.roi_+3A_obj">obj</code></td>
<td>
<p>object of class volume or mesh.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Names or parts of names of the RoI in the <code>struct</code> object.
By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Index of the RoI that belong to the <code>struct</code> object.
By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_xyz.margin">xyz.margin</code></td>
<td>
<p>Vector of length 3, representing the distances in mm to be added
to the x, y and z directions of the rectangular parallelepiped circumscribed
to the chosen RoI, in the cutting planes frame of reference. By default
xyz.margin = c (0, 0, 0).</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_obj.restrict">obj.restrict</code></td>
<td>
<p>Boolean. Used if <code>obj</code> is of class&quot;volume&quot;. If
<code>obj.restrict = TRUE</code>, the rectangular parallelepiped circumscribed to
the selected voxels, enlarged by xyz.margin cannot exceed the initial volume.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT = NULL</code>, <code>struct$ref.pseudo</code>
must be equal to <code>obj$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.
If <code>description = NULL</code>, it will be that of the <code>obj</code>, plus
&quot;restricted to&quot; the selected RoI.</p>
</td></tr>
<tr><td><code id="nesting.roi_+3A_...">...</code></td>
<td>
<p>Additional arguments such as <code>vol</code> (depracated), replaced by <code>obj</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are all set
to NULL, all RoI are selected.
</p>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object, in which 3D volume is limited to the
rectangular parallelepiped circumscribed to the chosen RoI, increased by the
requested margins.
</p>


<h3>See Also</h3>

<p><a href="#topic+add.margin">add.margin</a>, <a href="#topic+nesting.cube">nesting.cube</a> and
<a href="#topic+nesting.bin">nesting.bin</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for  better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "rtstruct"), 
                             roi.name = "brain", dxyz = rep (step, 3))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

CT.brain &lt;- nesting.roi (CT, S, roi.sname = "brain")
CT.brain.with.margin &lt;- nesting.roi (CT, S, roi.sname = "brain",
                                         xyz.margin = c (10,10,10))

# display at the center of gravity of the cerebellum Gz
Gz &lt;- S$roi.info [grep("^brain",S$roi.info$roi.pseudo),]$Gz
display.plane (bottom = CT.brain, view.coord = Gz,
               struct = S, bottom.col = pal.RVV (1000),
               bottom.breaks = seq (-1000, 1000, length.out = 1001),
               bg = "#00ff00",  interpolate  = FALSE, legend.shift = -20)
display.plane (bottom = CT.brain.with.margin,view.coord = Gz,
               struct = S,  bottom.col = pal.RVV (1000),
               bottom.breaks = seq(-1000, 1000, length.out = 1001),
               bg = "#00ff00", interpolate  = FALSE, legend.shift = -20)
</code></pre>

<hr>
<h2 id='obj.create'>Espadon object creating</h2><span id='topic+obj.create'></span>

<h3>Description</h3>

<p>The <code>obj.create</code> function creates an espadon object with
the essential properties it must have.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.create(class = c("", "volume", "struct", "mesh"), alias = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.create_+3A_class">class</code></td>
<td>
<p>Character string, representing an espadon class from among
&quot;volume&quot;, &quot;struct&quot; or &quot;mesh&quot;.</p>
</td></tr>
<tr><td><code id="obj.create_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a espadon class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of an espadon mesh of a cube
M &lt;- obj.create (class = "mesh")
M$mesh &lt;- Rvcg::vcgIsotropicRemeshing (Rvcg::vcgBox(),0.5) 
M$nb.faces &lt;- ncol (M$mesh$it)
rgl::wire3d (M$mesh)
</code></pre>

<hr>
<h2 id='orientation.create'>Creation of orientation</h2><span id='topic+orientation.create'></span>

<h3>Description</h3>

<p>The <code>orientation.create</code> function creates the orientation
vectors of a plane:
</p>

<ul>
<li><p> from 3 points A, B and C (see details),
</p>
</li>
<li><p> or from 2 vectors B and C, resp. defining x and y-axis (see details),
</p>
</li>
<li><p> or from 2 points A, B defining x-axis, and the normal vector to the plane (see details),
</p>
</li>
<li><p> or from a vector B defining x-axis, and the normal vector to the plane (see details).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>orientation.create(A = c(0, 0, 0), B = NULL, C = NULL, normal = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orientation.create_+3A_a">A</code></td>
<td>
<p>Vector of the x, y and z coordinates of point <code>A</code>, by default
equal to <code>c(0,0,0)</code> in the case where <code>B</code> and <code>C</code> are vectors.</p>
</td></tr>
<tr><td><code id="orientation.create_+3A_b">B</code></td>
<td>
<p>Vector of x, y and z coordinates of point or vector <code>B</code>.</p>
</td></tr>
<tr><td><code id="orientation.create_+3A_c">C</code></td>
<td>
<p>Vector of x, y and z coordinates of point or vector <code>C</code>.</p>
</td></tr>
<tr><td><code id="orientation.create_+3A_normal">normal</code></td>
<td>
<p>Vector of x, y and z coordinates of normal vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>B</code> and <code>C</code>, <code>B-A</code> define the x-axis
unit vector. The unit vector of the y-axis is orthonormal to the x-axis, coplanar
with <code>A</code>, <code>B</code> and <code>C</code>, and in the direction of <code>A</code> to <code>C</code>.
</p>
<p>When using <code>B</code> and <code>normal</code>, the unit vector of the x-axis is
orthonormal to the <code>normal</code> vector, in the direction of <code>A</code> to <code>B</code>.
The unit vector of the y-axis is defined so as to constitute a direct orthonormal
basis with the unit vector of the x-axis and the normal vector of the plane.
</p>


<h3>Value</h3>

<p>Returns the orientation of the plane.
That means the concatenation of 2 vectors, defining an orthonormal basis of
the plane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c (-29.93, 18.85, 4.34)
B &lt;- c (28.73, 15.36, 4.46)
C &lt;- c (1.53, 75.21, 13.51)
orientation.create (A, B, C)
</code></pre>

<hr>
<h2 id='pal.rainbow'>Rainbow palette</h2><span id='topic+pal.rainbow'></span>

<h3>Description</h3>

<p>The <code>pal.rainbow</code> function produces a color palette adapted
to dose repesentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pal.rainbow(n, alpha = seq(0.8, 0, length.out = n))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pal.rainbow_+3A_n">n</code></td>
<td>
<p>Integer, number of colors to be in the palette</p>
</td></tr>
<tr><td><code id="pal.rainbow_+3A_alpha">alpha</code></td>
<td>
<p>Vector representing the opacity, in the range of 0 (transparent)
to 1 (opaque). If <code>alpha = NULL</code>, all colors are opaque.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a color-labeled vector of size <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pal &lt;- pal.rainbow (255)

image (x = seq (0, 70, length.out = 255), y = 1,
       z = matrix (seq (0, 70, length.out = 255), ncol = 1),
       col = pal,
       main = "Rainbow colors")
</code></pre>

<hr>
<h2 id='pal.RVV'>Conversion of Hounsfied Units to Realistic Volume Vizualization colors</h2><span id='topic+pal.RVV'></span>

<h3>Description</h3>

<p>The <code>RVV.pal</code> function produces a color palette where
Hounsfield Units in the range -1000 HU to 1000 HU are converted into
realistically colorized virtual anatomy (for use with CT), developped by
<em>J.C. Silverstein and al</em> [1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pal.RVV(n, alpha = NULL, min.col = "#000000", max.col = "#FFFFFF")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pal.RVV_+3A_n">n</code></td>
<td>
<p>Integer, number of colors to be in the palette</p>
</td></tr>
<tr><td><code id="pal.RVV_+3A_alpha">alpha</code></td>
<td>
<p>Vector representing the opacity, in the range of 0 (transparent)
to 1 (opaque). If <code>alpha = NULL</code> (default), all colors are opaque, and
no alpha channel is added to the colors.</p>
</td></tr>
<tr><td><code id="pal.RVV_+3A_min.col">min.col</code>, <code id="pal.RVV_+3A_max.col">max.col</code></td>
<td>
<p>respectively the color below -1000HU (by default, black,
i.e. <code>"#000000"</code>) and above +1000HU (by default, white, i.e. <code>"#FFFFFF"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a color-labeled vector of size <code>n</code>.
</p>


<h3>References</h3>

<p>[1] Silverstein JC, Parsad NM, Tsirline V (2008).
&ldquo;Automatic perceptual color map generation for realistic volume visualization.&rdquo;
<em>Journal of Biomedical Informatics</em>, <b>41</b>(6), 927-935.
ISSN 1532-0464, <a href="https://doi.org/10.1016/j.jbi.2008.02.008">doi:10.1016/j.jbi.2008.02.008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pal &lt;- pal.RVV (256)

image (x = seq (-1000, 1000, length.out = 1024), y = 1,
       z = matrix (seq (-1100, 1100, length.out = 1024), ncol = 1),
       col = pal,
       main = "Realistic Volume Vizualization colors")
</code></pre>

<hr>
<h2 id='plot'>plot a 2D cut of a 3D object</h2><span id='topic+plot'></span><span id='topic+plot.volume'></span><span id='topic+plot.struct'></span><span id='topic+plot.mesh'></span>

<h3>Description</h3>

<p>The <code>plot</code> function displays the requested map
of espadon objects of class &quot;volume&quot;, &quot;struct&quot;, &quot;mesh&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'volume'
plot(
  x,
  ...,
  view.type = "trans",
  view.coord = NULL,
  flip = FALSE,
  flop = FALSE,
  cut.interpolate = TRUE,
  display.interpolate = FALSE,
  col = grey.colors(255, start = 0, end = 1),
  breaks = NULL,
  sat.transp = FALSE
)

## S3 method for class 'struct'
plot(
  x,
  ...,
  view.type = "trans",
  view.coord = NULL,
  flip = FALSE,
  flop = FALSE,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  back.dxyz = c(0.5, 0.5, x$thickness)
)

## S3 method for class 'mesh'
plot(
  x,
  ...,
  view.type = "trans",
  view.coord = NULL,
  flip = FALSE,
  flop = FALSE,
  col = "#ff0000"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>object of class &quot;volume&quot;, &quot;struct&quot; or &quot;mesh&quot;. See <a href="#topic+espadon.class">espadon.class</a></p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>others parameters of plot functions. See details</p>
</td></tr>
<tr><td><code id="plot_+3A_view.type">view.type</code></td>
<td>
<p>character string among the values 'ij', 'ji', 'ik', 'ki',
'jk', 'kj', 'yx', 'xz', 'zx', 'yz', 'zy', 'trans', 'front' or 'sagi&quot;
representing the map to be displayed.</p>
</td></tr>
<tr><td><code id="plot_+3A_view.coord">view.coord</code></td>
<td>
<p>value representing the coordinate where the map is displayed.
This parameter can be a 3D-vector, representing the coordinate of the point on
the displayed map. If <code>NULL</code>, the display is located in the center of the object.</p>
</td></tr>
<tr><td><code id="plot_+3A_flip">flip</code></td>
<td>
<p>Boolean defaults to <code>FALSE</code> flipping the horizontal axis
of the background image.</p>
</td></tr>
<tr><td><code id="plot_+3A_flop">flop</code></td>
<td>
<p>Boolean defaults to <code>FALSE</code> flipping the vertical axis
of the background image.</p>
</td></tr>
<tr><td><code id="plot_+3A_cut.interpolate">cut.interpolate</code></td>
<td>
<p>Boolean, indicating whether to calculate the volume cut
using linear interpolation.</p>
</td></tr>
<tr><td><code id="plot_+3A_display.interpolate">display.interpolate</code></td>
<td>
<p>Boolean, indicating whether to apply linear
interpolation when displaying the cut.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>Vector, representing the color palette of the image, if <code>x</code>
is of class 'volume'. Color of the mesh outline if object <code>x</code> is of class 'mesh'.</p>
</td></tr>
<tr><td><code id="plot_+3A_breaks">breaks</code></td>
<td>
<p>One of :
</p>

<ul>
<li> <p><code>NULL</code> : the minimum and the maximum value of the object <code>x</code> define
the range.
</p>
</li>
<li><p> Vector giving the breakpoints of each color. Outside values are transparent,
leaving the background visible, depending on <code>sat.transp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_+3A_sat.transp">sat.transp</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, outside values are transparent, else
set to <code>breaks</code> limits colors.</p>
</td></tr>
<tr><td><code id="plot_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="plot_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the <code>struct</code>
object. By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="plot_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>struct</code>
object. By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="plot_+3A_back.dxyz">back.dxyz</code></td>
<td>
<p>3D vector of voxel size, used to calculate contours in frontal
or sagittal view.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>... can be xlim, ylim, add, bg etc. If <code>view.type</code> is egal to
'trans' or 'front' or 'sagi', the direction of xlim and ylim is ignored.
</p>
<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are
all set to <code>NULL</code>, all closed planar or point RoI, present at <code>view.coord</code>
are selected.
</p>


<h3>Value</h3>

<p>Returns a display of the  \(k^{th}\) image plane of <code>x</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+display.plane">display.plane</a>, <a href="#topic+display.kplane">display.kplane</a>,
<a href="#topic+display.palette">display.palette</a>, <a href="#topic+pal.RVV">pal.RVV</a>, <a href="#topic+pal.rainbow">pal.rainbow</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("ct","mr", "rtdose", "rtstruct"),
                             dxyz = rep (step, 3), beam.nb = 3)
MR &lt;- patient$mr[[1]]
CT &lt;- patient$ct[[1]]
D &lt;- patient$rtdose[[1]]
S &lt;- patient$rtstruct[[1]]

# display 1
layout (matrix(c(1,1,2,3), ncol=2), widths=c(1,0.2))
plot (CT, view.coord = 0, col = pal.RVV(255))
S_plot &lt;- plot (S, view.coord = 0, add = TRUE, lwd = 2)
display.palette (col = pal.RVV(255), main="HU")
display.legend (S_plot, bg="white", text.col="black", lwd = 2, cex = 1.1)
# display 2
layout (matrix(c (1, 1, 2, 3), ncol = 2), widths = c (1, 0.2))
# Coordinates of the PTV barycenter in CT frame of reference
G &lt;- as.numeric (S$roi.info[S$roi.info$roi.pseudo == "ptv", 
                            c ("Gx", "Gy", "Gz")])
# Coordinates of the PTV baricenter in MR frame of reference
G_MR &lt;- as.numeric (c(G, 1) %*% 
                   t(get.rigid.M(CT$ref.pseudo, MR$ref.pseudo, 
                               T.MAT = patient$T.MAT)))[1:3]
plot (MR, view.type = "sagi", view.coord =  G_MR,
      col = grey.colors (255, start = 0, end = 1),
      breaks = seq (0, 500, length.out = 256) , bg = "darkblue")
plot (vol.in.new.ref(D, MR$ref.pseudo, T.MAT = patient$T.MAT),
      view.type = "sagi", view.coord = G_MR,
      col = pal.rainbow(255), add = TRUE)
display.palette (col = grey.colors (255, start = 0, end = 1),
                 breaks = seq (0, 500, length.out = 256), main="MR")
display.palette (col =  pal.rainbow(255),
                 breaks = seq (D$min.pixel, D$max.pixel, length.out = 256),
                 main="Gy")
layout(1)
</code></pre>

<hr>
<h2 id='Rdcm.inventory'>Inventory of <span class="pkg">espadon</span> objects from Rdcm files</h2><span id='topic+Rdcm.inventory'></span>

<h3>Description</h3>

<p>The <code>Rdcm.inventory</code> function creates, from Rdcm files in a
patient's directory, a dataframe describing objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rdcm.inventory(dirname, upgrade.to.latest.version = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rdcm.inventory_+3A_dirname">dirname</code></td>
<td>
<p>Character string, representing the full name of patient
directory, including Rdcm files.</p>
</td></tr>
<tr><td><code id="Rdcm.inventory_+3A_upgrade.to.latest.version">upgrade.to.latest.version</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function attempts
to upgrade to the latest version, parsing the DICOM data. It may take longer
to load the data. Consider using the <a href="#topic+Rdcm.upgrade">Rdcm.upgrade</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe, providing information of DICOM objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy patient objects to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = c (4, 4, 4))
save.to.Rdcm (patient$ct[[1]], dirname = pat.dir)
save.to.Rdcm (patient$mr[[1]], dirname = pat.dir)
save.T.MAT (patient$T.MAT, dirname = pat.dir)


Rdcm.inventory (pat.dir)

# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='Rdcm.upgrade'>Updating Rdcm files.</h2><span id='topic+Rdcm.upgrade'></span>

<h3>Description</h3>

<p>The <code>Rdcm.upgrade</code> function updates Rdcm files that were
created with a previous version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rdcm.upgrade(Rdcm.files)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rdcm.upgrade_+3A_rdcm.files">Rdcm.files</code></td>
<td>
<p>String vector, representing the list of the full names of the
Rdcm files, or its directories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Saves the updated Rdcm files. If the Rdcm files were generated from
the dicom files, the data is updated from the DICOM fields.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy patient objects to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = c (4, 4, 4))
save.to.Rdcm (patient$ct[[1]], dirname = pat.dir)
save.to.Rdcm (patient$mr[[1]], dirname = pat.dir)
save.T.MAT (patient$T.MAT, dirname = pat.dir)
# Rdcm files in pat.dir
list.files(pat.dir)

# test of Rdcm.upgrade

Rdcm.upgrade (pat.dir)
# or
Rdcm.upgrade (list.files (pat.dir, full.names = TRUE))

# Cleaning  temporary directories
unlink (pat.dir, recursive = TRUE)

</code></pre>

<hr>
<h2 id='ref.add'>Adding a frame of reference in T.MAT</h2><span id='topic+ref.add'></span>

<h3>Description</h3>

<p>The <code>ref.add</code> function adds the transfer matrices from or
to a new frame of reference defined from 2 unit vectors and an origin point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.add(
  src.ref,
  orientation = c(1, 0, 0, 0, 1, 0),
  origin = c(0, 0, 0),
  new.ref.pseudo = "newref",
  T.MAT = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref.add_+3A_src.ref">src.ref</code></td>
<td>
<p>Character string, pseudonym of the frame of reference in which
the <code>orientation</code> vector and the origin point <code>origin</code> are defined.</p>
</td></tr>
<tr><td><code id="ref.add_+3A_orientation">orientation</code></td>
<td>
<p>Vector of 6 or 9 elements, composed of the coordinates of the 2 orthonormal vectors (i, j),
or of the 3 orthonormal vectors (i, j, k) of the new coordinate system,
in the <code>src.ref</code> frame of reference.</p>
</td></tr>
<tr><td><code id="ref.add_+3A_origin">origin</code></td>
<td>
<p>Vector of the x, y, z coordinates of the origin point of the
new frame of reference in the <code>src.ref</code> frame of reference. Default to
c (0, 0, 0).</p>
</td></tr>
<tr><td><code id="ref.add_+3A_new.ref.pseudo">new.ref.pseudo</code></td>
<td>
<p>Character string, pseudonym of the new frame of
reference to add.</p>
</td></tr>
<tr><td><code id="ref.add_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object created by
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT = NULL</code>, then only the link
between <code>src.ref</code> and <code>new.ref.pseudo</code> is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;t.mat&quot; class object, which contains the transfer
matrices from or to <code>new.ref.pseudo</code> pseudonym of the new frame
of reference. If the <code>T.MAT</code> is <code>NULL</code>, then the returned object
will contain only 4 matrices: &quot;src.ref&lt;-src.ref&quot;, &quot;src.ref&lt;-new.ref.pseudo&quot;,
&quot;new.ref.pseudo&lt;- new.ref.pseudo&quot;, &quot;new.ref.pseudo&lt;-src.ref&quot;.
</p>
<p>Returns a <code>NULL</code> if  <code>orientation</code> is not well defined.
</p>


<h3>See Also</h3>

<p><a href="#topic+ref.cutplane.add">ref.cutplane.add</a>, <a href="#topic+ref.remove">ref.remove</a>,
<a href="#topic+ref.srctodest.add">ref.srctodest.add</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Adding of the reference frame "ref1_60", which is a 60 degree rotation of 
# reference frame "ref1".
orientation &lt;- c (cos (pi / 3), sin (pi / 3), 0, 
                  -sin (pi / 3), cos (pi / 3), 0)

local.Tmat &lt;- ref.add (src.ref = "ref1", orientation = orientation,
                  new.ref.pseudo = "ref1_60")

str(local.Tmat)
</code></pre>

<hr>
<h2 id='ref.cutplane.add'>Adding volume's cutting planes frame of reference in T.MAT</h2><span id='topic+ref.cutplane.add'></span>

<h3>Description</h3>

<p>The <code>ref.cutplane.add</code> function adds in T.MAT the transfer
matrices from or to volume's cutting planes frame of reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.cutplane.add(
  vol,
  origin = c(0, 0, 0),
  ref.cutplane = paste0(vol$ref.pseudo, "m"),
  T.MAT = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref.cutplane.add_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="ref.cutplane.add_+3A_origin">origin</code></td>
<td>
<p>Vector of the x, y, z coordinates of the origin point of
the cutting planes frame of reference.</p>
</td></tr>
<tr><td><code id="ref.cutplane.add_+3A_ref.cutplane">ref.cutplane</code></td>
<td>
<p>Name of the volume's cutting planes frame of reference.
By default <code>ref.cutplane = paste0 (vol$ref.pseudo,".m")</code>.</p>
</td></tr>
<tr><td><code id="ref.cutplane.add_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object created by
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT = NULL</code>, then only the link
between <code>vol$ref.pseudo</code> and <code>ref.name</code> is established.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;t.mat&quot; class object, which contains the transfer matrices
from or to volume's cutting planes frame of reference. If the <code>T.MAT</code> is <code>NULL</code>,
then the returned object will contain only 4 matrices: &quot;src.ref&lt;-src.ref&quot;,
&quot;src.ref&lt;-ref.cutplane&quot;, &quot;ref.cutplane&lt;-ref.cutplane&quot;, &quot;ref.cutplane&lt;-src.ref&quot;.
</p>


<h3>See Also</h3>

<p><a href="#topic+ref.add">ref.add</a>, <a href="#topic+ref.srctodest.add">ref.srctodest.add</a>,
<a href="#topic+ref.remove">ref.remove</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects
patient &lt;- toy.load.patient (modality = "mr", roi.name = "", dxyz = c (4, 4, 4))
MR &lt;- patient$mr[[1]]
MR$xyz.from.ijk

# creation of t.mat, containing the transfer matrix to the frame of reference 
# of the MR cutting planes
t.mat &lt;- ref.cutplane.add (MR)

# Change of frame of reference
MR.m &lt;- vol.in.new.ref (MR, paste0 (MR$ref.pseudo, "m"), t.mat)

MR.m$xyz.from.ijk
</code></pre>

<hr>
<h2 id='ref.remove'>Deletion of a frame of reference in T.MAT</h2><span id='topic+ref.remove'></span>

<h3>Description</h3>

<p>The <code>ref.remove</code> function removes the management of a frame
of reference in T.MAT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.remove(ref.name, T.MAT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref.remove_+3A_ref.name">ref.name</code></td>
<td>
<p>Character string, pseudonym of the frame of reference to delete.</p>
</td></tr>
<tr><td><code id="ref.remove_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object in which the <code>ref.name</code> frame of
reference is to be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;t.mat&quot; class object, which no longer contains transfer
matrices from or to the ref.pseudo <code>ref.name</code>.
<a href="#topic+ref.cutplane.add">ref.cutplane.add</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Adding of the reference frame "ref1_60", which is a 60 degree rotation of 
# reference frame "ref1".
orientation &lt;- c (cos (pi / 3), sin (pi / 3), 0, 
                  -sin (pi / 3), cos (pi / 3), 0)

local.Tmat &lt;- ref.add (src.ref = "ref1", orientation = orientation,
                  new.ref.pseudo = "ref1_60")
str(local.Tmat)

# Removal of  "ref1_60"
local.Tmat &lt;- ref.remove (ref.name =  "ref1_60", T.MAT = local.Tmat)
str(local.Tmat)
</code></pre>

<hr>
<h2 id='ref.srctodest.add'>Linking two existing frames of reference in T.MAT</h2><span id='topic+ref.srctodest.add'></span>

<h3>Description</h3>

<p>The <code>ref.srctodest.add</code> function links the source frame of
reference with the destination frame of reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.srctodest.add(src.ref, dest.ref, TM = diag(4), T.MAT = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref.srctodest.add_+3A_src.ref">src.ref</code></td>
<td>
<p>Character string, pseudonym of the source frame of reference.</p>
</td></tr>
<tr><td><code id="ref.srctodest.add_+3A_dest.ref">dest.ref</code></td>
<td>
<p>Character string, pseudonym of the destination frame of reference.</p>
</td></tr>
<tr><td><code id="ref.srctodest.add_+3A_tm">TM</code></td>
<td>
<p>4x4 tansfert matrix for moving from <code>src.ref</code> to <code>dest.ref</code>.</p>
</td></tr>
<tr><td><code id="ref.srctodest.add_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object created by
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT = NULL</code>, then only the link
between <code>src.ref</code> and <code>dest.ref</code> is established.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;t.mat&quot; class object, which contains the transfer
matrices from or to <code>dest.ref</code> pseudonym of the new frame
of reference. If the <code>T.MAT</code> is <code>NULL</code>, then the returned object
will contain only 4 matrices: &quot;src.ref&lt;-src.ref&quot;,
&quot;src.ref&lt;-dest.ref&quot;, &quot;dest.ref&lt;- dest.ref&quot;, &quot;dest.ref&lt;-src.ref&quot;.
</p>


<h3>See Also</h3>

<p><a href="#topic+ref.add">ref.add</a>, <a href="#topic+ref.cutplane.add">ref.cutplane.add</a>,
<a href="#topic+ref.remove">ref.remove</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local.Tmat &lt;-  ref.srctodest.add ("ref1","ref2", 
                                  TM = matrix(c (0.5, -sin (pi / 3), 0, 0,
                                                 sin (pi / 3), 0.5, 0, 0,
                                                 0, 0, 1, 0, 0, 0, 0, 1),
                                              ncol = 4))
str (local.Tmat)   
</code></pre>

<hr>
<h2 id='rt.chi.index'>Chi index 2D - 3D</h2><span id='topic+rt.chi.index'></span>

<h3>Description</h3>

<p>The <code>rt.chi.index</code> function computes the local or global
Chi index from a measurement and a reference. These latter are &quot;volume&quot; class
objects containing one (2D) or several planes (3D).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rt.chi.index(
  vol,
  vol.ref,
  abs = TRUE,
  vol.max = vol.ref$max.pixel,
  dose.th = 0.02,
  delta.r = 3,
  analysis.th = 0.05,
  local = FALSE,
  local.th = 0.3,
  project.to.isocenter = TRUE,
  alias = "",
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rt.chi.index_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, which represents the measured volume.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_vol.ref">vol.ref</code></td>
<td>
<p>&quot;volume&quot; class object, which represents the reference volume.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_abs">abs</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), the absolute value of Chi is computed.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_vol.max">vol.max</code></td>
<td>
<p>Positive number, by default equal to the maximum value of the reference volume.
See Details.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_dose.th">dose.th</code></td>
<td>
<p>Number between 0 and 1, used to determine the dose difference criterion. See Details.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_delta.r">delta.r</code></td>
<td>
<p>Positive number, in mm. Distance difference criterion.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_analysis.th">analysis.th</code></td>
<td>
<p>Number between 0 and 1. Only the voxels whose value are
greater than or equal <code>analyse.th * vol.max</code> are processed.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_local">local</code></td>
<td>
<p>Boolean. If <code>local = FALSE</code> (default), a global Chi index
is computed, and a local Chi index otherwise.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_local.th">local.th</code></td>
<td>
<p>Number between 0 and 1. Local threshold, only used if
<code>local = TRUE</code>. See Details.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_project.to.isocenter">project.to.isocenter</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, and if <code>vol</code> and
<code>vol.ref</code> are of modality &quot;rtimage&quot;, the size of the pixels is corrected
to correspond to that found if the sensor was at the isocenter.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="rt.chi.index_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to Chi index setup.
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Chi index of a voxel \(n\) was defined by <em>Bakai and al</em> <strong>[1]</strong>.
It is computed from the formulae:
\[\chi_n = \frac{D_i-Dref_n}{\sqrt{{\Delta D}^2 + {\Delta r}^2~\cdot~\Vert \nabla Dref_n \Vert^2}}\]
If <code>abs = TRUE</code>, the used formulae is :
\[\chi_n = \frac{\vert D_i-Dref_n\vert}{\sqrt{{\Delta D}^2 + {\Delta r}^2~\cdot~\Vert \nabla Dref_n \Vert^2}}\]
with \(D_i\) the measured dose at voxel \(i\),
\(Dref_n\) the reference dose at voxel \(n\),
\(\nabla Dref_n\) the gradient of reference dose at voxel \(n\),
\(\Delta r\) the distance difference criterion equal to <code>delta.r</code>, and
\(\Delta D\) the distance difference criterion at voxel \(n\) defined as follows:
</p>

<ul>
<li><p> If <code>local = FALSE</code> a global Chi index is computed and
\(\Delta D~=~dose.th~\cdot~vol.max\).
</p>
</li>
<li><p> If <code>local = TRUE</code>, then \(\Delta D~=~dose.th~\cdot~Dref_n\) when
\(Dref_n~\ge~local.th~\cdot~vol.max\), and
\(\Delta D~=~dose.th~\cdot~local.th~\cdot~vol.max\) otherwise.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions).  The <code>$vol3D.data</code> field represents the Chi index.
Two fields are added:
the <code>$setup</code> field recalls the calculation setup, and the <code>$chi.info</code> field
details the number of dose points, the number of evaluated dose points,the rate
of evaluated dose points, the rate of absolute values of the Chi index below 1,
above 1.2 and 1.5,the max and the mean Chi index.
</p>


<h3>References</h3>

<p><strong>[1]</strong> Bakai A, Alber A, Nsslin F (2003).
&ldquo;A revision of the Gamma-evaluation concept for the comparison of dose distributions.&rdquo;
<em>Physics in Medicine and Biologys</em>, <b>48</b>(21), 3543&ndash;3553.
</p>


<h3>See Also</h3>

<p><a href="#topic+rt.gamma.index">rt.gamma.index</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of a reference volume  and measured volume
# loading of toy-patient objects (decrease dxyz for  better result)
patient &lt;- toy.load.patient (modality = c ("rtdose", "rtstruct"), 
                             roi.name = "ptv", dxyz = c (3, 3, 3))
D.ref &lt;- patient$rtdose[[1]]  
# We will assume that the measured dose is equal to the reference dose shifted
# by 3 pixels on the x axis
D.meas &lt;- vol.copy (D.ref, alias = "measured_dose")
D.meas$vol3D.data[1:(D.meas$n.ijk[1] - 3) ,,] &lt;- D.ref$vol3D.data[4:D.ref$n.ijk[1],,] 
D.max &lt;- as.numeric(quantile(as.numeric(D.ref$vol3D.data), 
                             probs = 99.99/100, na.rm = TRUE))
abs_chi &lt;- rt.chi.index (D.meas, D.ref, vol.max = D.max, delta.r = 6)  
abs_chi$chi.info  

# Display chi index at isocenter
G.iso &lt;- patient$rtstruct[[1]]$roi.info$Gz[
  patient$rtstruct[[1]]$roi.info$name == "ptv"]
display.plane(abs_chi, view.coord = G.iso, 
              bottom.col = c ("#00FF00", "#007F00", "#FF8000", "#FF0000", 
                              "#AF0000"),
              bottom.breaks = c (0, 0.8, 1, 1.2, 1.5, abs_chi$max.pixel),
              interpolate = FALSE, bg = "blue")
</code></pre>

<hr>
<h2 id='rt.gamma.index'>Gamma index 2D - 3D</h2><span id='topic+rt.gamma.index'></span>

<h3>Description</h3>

<p>The <code>rt.gamma.index</code> function computes the local or global
Gamma index from a measurement and a reference. These latter are &quot;volume&quot; class
objects containing one (2D) or several planes (3D).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rt.gamma.index(
  vol,
  vol.ref,
  over.sampling.factor = 1,
  vol.max = vol.ref$max.pixel,
  dose.th = 0.02,
  delta.r = 3,
  analysis.th = 0.05,
  local = FALSE,
  local.th = 0.3,
  project.to.isocenter = TRUE,
  alias = "",
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rt.gamma.index_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, which represents the measured volume.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_vol.ref">vol.ref</code></td>
<td>
<p>&quot;volume&quot; class object, which represents the reference volume.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_over.sampling.factor">over.sampling.factor</code></td>
<td>
<p>Strictly positive integer, or a vector of 3 strictly
positive integers, default to 1. Defined to oversample grids of <code>vol</code> and <code>vol.ref</code>.
Oversampling can be very time consuming.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_vol.max">vol.max</code></td>
<td>
<p>Positive number, by default equal to the maximum value of the reference volume.
See Details.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_dose.th">dose.th</code></td>
<td>
<p>Number between 0 and 1, used to determine the dose difference criterion. See Details.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_delta.r">delta.r</code></td>
<td>
<p>Positive number, in mm. Distance difference criterion.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_analysis.th">analysis.th</code></td>
<td>
<p>Number between 0 and 1. Only the voxels whose value is
greater than or equal <code>analyse.th*vol.max</code> are processed.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_local">local</code></td>
<td>
<p>Boolean. If <code>local = FALSE</code> (default), a global Gamma index
is computed, and a local Gamma index otherwise.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_local.th">local.th</code></td>
<td>
<p>Number between 0 and 1. Local threshold, only used if
<code>local = TRUE</code>. See Details.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_project.to.isocenter">project.to.isocenter</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, and if <code>vol</code> and
<code>vol.ref</code> are of modality &quot;rtimage&quot;, the size of the pixels is corrected
to correspond to that found if the sensor was at the isocenter.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="rt.gamma.index_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to Gamma index setup.
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gamma index of a voxel \(n\) was defined by <em>Low and al</em> <strong>[1]</strong>.
It is computed from the formulae:
\[\gamma_n = min \left( \sqrt{\frac{(D_i-Dref_n)^2}{{\Delta D}^2} + \frac{{r_i}^2}{{\Delta r}^2}}\right)\]
whith \(D_i\) the measured dose at voxel \(i\),
\(Dref_n\) the reference dose at voxel \(n\),
\(r_i\) the distance between voxels \(i\) and \(n\),
\(\Delta r\) the distance difference criterion equal to <code>delta.r</code>,
\(\Delta D\) the distance difference criterion at voxel \(n\) defined as follows:
</p>

<ul>
<li><p> If <code>local = FALSE</code> a global Gamma index is computed and
\(\Delta D~=~dose.th~\cdot~vol.max\).
</p>
</li>
<li><p> If <code>local = TRUE</code>, then \(\Delta D~=~dose.th~\cdot~Dref_n\) when
\(Dref_n~\ge~local.th~\cdot~vol.max\), and
\(\Delta D~=~dose.th~\cdot~local.th~\cdot~vol.max\) otherwise.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions).  The <code>$vol3D.data</code> field represents the Gamma index.
Two fields are added:
the <code>$setup</code> field recalls the calculation setup, and the <code>$gamma.info</code> field
details the number of dose points, the number of evaluated dose points,the rate
of evaluated dose points, the rate of Gamma indices below 1, above 1.2 and 1.5,
the max and the mean Gamma index.
</p>


<h3>References</h3>

<p><strong>[1]</strong> Low DA, Harms WB, Mutic S, Purdy JA (1998).
&ldquo;A technique for the quantitative evaluation of dose distributions.&rdquo;
<em>Medical Physics</em>, <b>25</b>(5), 656&ndash;661.
</p>


<h3>See Also</h3>

<p><a href="#topic+rt.chi.index">rt.chi.index</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of a reference volume  and measured volume
# loading of toy-patient objects (decrease dxyz for  better result)
patient &lt;- toy.load.patient (modality = c ("rtdose", "rtstruct"), 
                             roi.name = "ptv", dxyz = c (3, 3, 3))
D.ref &lt;- patient$rtdose[[1]]  
# We will assume that the measured dose is equal to the reference dose shifted
# by 3 pixels on the x axis
D.meas &lt;- vol.copy (D.ref, alias = "measured_dose")
D.meas$vol3D.data[1:(D.meas$n.ijk[1] - 3) ,,] &lt;- D.ref$vol3D.data[4:D.ref$n.ijk[1],,] 
D.max &lt;- as.numeric(quantile(as.numeric(D.ref$vol3D.data), 
                             probs = 99.99/100, na.rm = TRUE))
gamma &lt;- rt.gamma.index (D.meas, D.ref, delta.r = 6, vol.max = D.max)  
gamma$gamma.info  

# Display gamma index at isocenter
G.iso &lt;- patient$rtstruct[[1]]$roi.info$Gz[
  patient$rtstruct[[1]]$roi.info$name == "ptv"]
display.plane(gamma, view.coord = G.iso, 
              bottom.col = c ("#00FF00", "#007F00", "#FF8000", "#FF0000", 
                              "#AF0000"),
              bottom.breaks = c (0, 0.8, 1, 1.2, 1.5, gamma$max.pixel), 
              bg = "blue", interpolate = FALSE)
</code></pre>

<hr>
<h2 id='rt.indices.from.bin'>Dosimetry, volume, conformity, homogeneity indices from binary selection</h2><span id='topic+rt.indices.from.bin'></span>

<h3>Description</h3>

<p>The <code>rt.indices.from.bin</code> function calculates, from a
&quot;volume&quot; class object of modality &quot;rtdose&quot;, all the standard
indicators of radiotherapy, as long as their options are transmitted, for the
target and healthy &quot;volume&quot; object of modality &quot;binary&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rt.indices.from.bin(
  vol,
  target.bin.list = NULL,
  healthy.bin.list = NULL,
  T.MAT = NULL,
  presc.dose = NA,
  healthy.tol.dose = NA,
  healthy.weight = 1,
  dosimetry = c("D.min", "D.max", "D.mean", "STD"),
  volume.indices = c("V.tot", "area", "V.prescdose"),
  conformity.indices = c("PITV", "CI.lomax2003", "CN", "NCI", "DSC", "CI.distance",
    "CI.abs_distance", "CDI", "CS3", "ULF", "OHTF", "gCI", "COIN", "G_COSI", "COSI"),
  homogeneity.indices = c("HI.RTOG.max_ref", "HI.RTOG.5_95", "HI.ICRU.max_min",
    "HI.ICRU.2.98_ref", "HI.ICRU.2.98_50", "HI.ICRU.5.95_ref", "HI.mayo2010",
    "HI.heufelder"),
  gradient.indices = c("GI.ratio.50"),
  D.xpc = NULL,
  D.xcc = NULL,
  V.xpc = NULL,
  V.xGy = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rt.indices.from.bin_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;rtdose&quot; modality.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_target.bin.list">target.bin.list</code></td>
<td>
<p>list of &quot;volume&quot; class objects, of &quot;binary&quot;
modality. The <code>$object.alias</code> field of each <code>target.bin.list</code> object
represents the name of the selected region of interest of the target volume.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_healthy.bin.list">healthy.bin.list</code></td>
<td>
<p>list of &quot;volume&quot; class objects, of &quot;binary&quot;
modality. The <code>$object.alias</code> field of each <code>healthy.bin.list</code> object
represents the name of the selected region of interest of the healthy tissues.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT = NULL</code>, all <code>$ref.pseudo</code>
of <code>bin.list</code> elements must be equal to <code>vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_presc.dose">presc.dose</code></td>
<td>
<p>vector of prescription doses that serve as reference doses
for the target RoI.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_healthy.tol.dose">healthy.tol.dose</code></td>
<td>
<p>vector of tolerance dose of each healthy RoI.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_healthy.weight">healthy.weight</code></td>
<td>
<p>Vector of weight, indicating the importance of the healthy
RoI.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_dosimetry">dosimetry</code></td>
<td>
<p>Vector indicating the requested dose indicators from among
'D.min', 'D.max', 'D.mean' and 'STD'. If <code>D.xpc</code> is different from
<code>NULL</code>, it will be added.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_volume.indices">volume.indices</code></td>
<td>
<p>Vector indicating the requested volume indices from among
'V.tot',  'V.prescdose' (i.e. volume over <code>presc.dose</code>) and 'area'. If
<code>V.xGy</code> is different from <code>NULL</code>, it will be added.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_conformity.indices">conformity.indices</code></td>
<td>
<p>Vector. Requested conformity indices from among 'PITV',
'PDS', 'CI.lomax2003', 'CN', 'NCI', 'DSC', 'CI.distance', 'CI.abs_distance',
'CDI', 'CS3', 'ULF', 'OHTF', 'gCI', 'COIN', 'COSI' and 'G_COSI'.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_homogeneity.indices">homogeneity.indices</code></td>
<td>
<p>Vector. Requested homogeneity indices from among
'HI.RTOG.max_ref', 'HI.RTOG.5_95', 'HI.ICRU.max_min', 'HI.ICRU.2.98_ref',
'HI.ICRU.2.98_50', 'HI.ICRU.5.95_ref', 'HI.mayo2010' and 'HI.heufelder.'</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_gradient.indices">gradient.indices</code></td>
<td>
<p>Vector. Requested gradient indices from among
'GI.ratio.50', 'mGI'.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_d.xpc">D.xpc</code></td>
<td>
<p>Vector of the percentage of the volume, for which the dose coverage
is requested.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_d.xcc">D.xcc</code></td>
<td>
<p>Vector of the volume in \(cm^3\), for which the dose
coverage is requested.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_v.xpc">V.xpc</code></td>
<td>
<p>Vector of the percentage of the reference dose, received by the volume to be
calculated.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_v.xgy">V.xGy</code></td>
<td>
<p>Vector of the minimum dose in Gy, received by the volume to be
calculated.</p>
</td></tr>
<tr><td><code id="rt.indices.from.bin_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. if <code>TRUE</code> (default) a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return  a list of  indices dataframe. For details, see
<a href="#topic+rt.indices.from.roi">rt.indices.from.roi</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+rt.indices.from.roi">rt.indices.from.roi</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for better
# result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), roi.name = "eye",
                             dxyz = rep (step, 3), beam.nb = 3)
D &lt;- patient$rtdose[[1]]
struct &lt;- patient$rtstruct[[1]]
T.MAT &lt;- patient$T.MAT

# creation of the list of target binary volumes
target.roi.idx &lt;- select.names (struct$roi.info$roi.pseudo, roi.sname = "ptv")
healthy.roi.idx &lt;- select.names (struct$roi.info$roi.pseudo, roi.sname = "eye")
target.bin.list &lt;- lapply (target.roi.idx , function (idx) {
  vr &lt;- nesting.roi (D, struct, roi.idx = idx, xyz.margin = c (5, 5, 5),
                     T.MAT = T.MAT, alias = struct$roi.info$name[idx])
  b &lt;- bin.from.roi(vr, struct, roi.idx = idx, T.MAT = T.MAT,
                    alias = struct$roi.info$name[idx], verbose = FALSE)
  })
names (target.bin.list) &lt;- struct$roi.info$name[target.roi.idx]

healthy.bin.list &lt;- lapply (healthy.roi.idx , function (idx) {
  vr &lt;- nesting.roi (D, struct, roi.idx = idx, xyz.margin = c (5, 5, 5),
                     T.MAT = T.MAT, alias = struct$roi.info$name[idx])
  b &lt;- bin.from.roi(vr, struct, roi.idx = idx, T.MAT = T.MAT,
                    alias = struct$roi.info$name[idx], verbose = FALSE)
})
names (healthy.bin.list) &lt;- struct$roi.info$name[healthy.roi.idx]

indices &lt;- rt.indices.from.bin (D, target.bin.list, healthy.bin.list,
                                presc.dose = 50,
                                conformity.indices = c("PITV", "PDS", "CI.lomax2003", 
                                                       "CN", "NCI", "DSC","COIN"),
                                verbose = FALSE)
indices
</code></pre>

<hr>
<h2 id='rt.indices.from.roi'>Dosimetry, volume, conformity, homogeneity indices from RoI
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+rt.indices.from.roi'></span>

<h3>Description</h3>

<p>The <code>rt.indices.from.roi</code> function calculates, from a &quot;volume&quot;
class object of modality &quot;rtdose&quot;, standard indicators of radiotherapy
in relation to the target and healthy RoI, as long as their options are transmitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rt.indices.from.roi(
  vol,
  struct = NULL,
  T.MAT = NULL,
  target.roi.name = NULL,
  target.roi.sname = NULL,
  target.roi.idx = NULL,
  healthy.roi.name = NULL,
  healthy.roi.sname = NULL,
  healthy.roi.idx = NULL,
  presc.dose = NA,
  healthy.tol.dose = NA,
  healthy.weight = 1,
  dosimetry = c("D.min", "D.max", "D.mean", "STD"),
  volume.indices = c("V.tot", "area", "V.prescdose"),
  conformity.indices = c("PITV", "PDS", "CI.lomax2003", "CN", "NCI", "DSC",
    "CI.distance", "CI.abs_distance", "CDI", "CS3", "ULF", "OHTF", "gCI", "COIN",
    "G_COSI", "COSI"),
  homogeneity.indices = c("HI.RTOG.max_ref", "HI.RTOG.5_95", "HI.ICRU.max_min",
    "HI.ICRU.2.98_ref", "HI.ICRU.2.98_50", "HI.ICRU.5.95_ref", "HI.mayo2010",
    "HI.heufelder"),
  gradient.indices = c("GI.ratio.50", "mGI"),
  D.xpc = NULL,
  D.xcc = NULL,
  V.xpc = NULL,
  V.xGy = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rt.indices.from.roi_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;rtdose&quot; modality.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>
or  <a href="#topic+load.T.MAT">load.T.MAT</a>. If <code>T.MAT = NULL</code>, <code>struct$ref.pseudo</code>
must be equal to <code>vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_target.roi.name">target.roi.name</code></td>
<td>
<p>Exact name of target RoI in <code>struct</code> object.
By default <code>target.roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_target.roi.sname">target.roi.sname</code></td>
<td>
<p>Name or part of name of target RoI in <code>struct</code>
object. By default <code>target.roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_target.roi.idx">target.roi.idx</code></td>
<td>
<p>Value of the index of target RoI that belong to the
<code>struct</code> object. By default <code>target.roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_healthy.roi.name">healthy.roi.name</code></td>
<td>
<p>Exact name of healthy RoI in <code>struct</code> object.
By default <code>healthy.roi.name = NULL</code>.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_healthy.roi.sname">healthy.roi.sname</code></td>
<td>
<p>Name or part of name of healthy RoI in <code>struct</code>
object. By default <code>healthy.roi.sname = NULL</code>.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_healthy.roi.idx">healthy.roi.idx</code></td>
<td>
<p>Value of the index of healthy RoI that belong to the
<code>struct</code> object. By default <code>healthy.roi.idx = NULL</code>.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_presc.dose">presc.dose</code></td>
<td>
<p>Vector of prescription doses that serve as reference doses
for the target RoI.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_healthy.tol.dose">healthy.tol.dose</code></td>
<td>
<p>Vector of tolerance doses of each healthy RoI.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_healthy.weight">healthy.weight</code></td>
<td>
<p>Vector of weights, indicating the importance of the
healthy RoI.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_dosimetry">dosimetry</code></td>
<td>
<p>Vector indicating the requested dose indicators from among
'D.min', 'D.max', 'D.mean' and 'STD'. If <code>D.xpc</code> is different from
<code>NULL</code>, it will be added.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_volume.indices">volume.indices</code></td>
<td>
<p>Vector indicating the requested volume indices from among
'V.tot',  'V.prescdose' (i.e. volume over <code>presc.dose</code>) and 'area'. If
<code>V.xGy</code> is different from <code>NULL</code>, it will be added.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_conformity.indices">conformity.indices</code></td>
<td>
<p>Vector. Requested conformity indices from among 'PITV',
'PDS', 'CI.lomax2003', 'CN', 'NCI', 'DSC', 'CI.distance', 'CI.abs_distance',
'CDI', 'CS3', 'ULF', 'OHTF', 'gCI', 'COIN', 'COSI' and 'G_COSI'.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_homogeneity.indices">homogeneity.indices</code></td>
<td>
<p>Vector. Requested homogeneity indices from among
'HI.RTOG.max_ref', 'HI.RTOG.5_95', 'HI.ICRU.max_min', 'HI.ICRU.2.98_ref',
'HI.ICRU.2.98_50', 'HI.ICRU.5.95_ref', 'HI.mayo2010' and 'HI.heufelder.'</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_gradient.indices">gradient.indices</code></td>
<td>
<p>Vector. Requested gradient indices from among
'GI.ratio.50', 'mGI'.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_d.xpc">D.xpc</code></td>
<td>
<p>Vector of the percentage of the volume, for which the dose coverage
is requested.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_d.xcc">D.xcc</code></td>
<td>
<p>Vector of the volume in \(cm^3\), for which the dose
coverage is requested.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_v.xpc">V.xpc</code></td>
<td>
<p>Vector of the percentage of the reference dose, received by the volume to be
calculated.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_v.xgy">V.xGy</code></td>
<td>
<p>Vector of the minimum dose in Gy, received by the volume to be
calculated.</p>
</td></tr>
<tr><td><code id="rt.indices.from.roi_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. if <code>TRUE</code> (default) a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>target.roi.name</code>, <code>target.roi.sname</code>, and
<code>target.roi.idx</code> are all set to <code>NULL</code>, all RoI containing 'ptv'
(if they exist) are selected.
</p>
<p>If <code>target.roi.name</code>, <code>target.roi.sname</code>, and <code>target.roi.idx</code>
are all set to <code>NULL</code>,no target RoI are selected.
</p>
<p>If <code>healthy.roi.name</code>, <code>healthy.roi.sname</code>, and
<code>healthy.roi.idx</code> are all set to <code>NULL</code>, no healthy RoI are selected.
</p>


<h3>Value</h3>

<p>Returns  a list containing (if requested)
</p>
<p>\(-~dosimetry\) : dataframe containing, for all target and
healthy structures:
</p>

<ul>
<li><p> the requested <code>dosimetry</code> : <code>D.min</code> (Gy), <code>D.max</code> (Gy),
<code>D.mean</code> (Gy) and <code>STD</code> (Gy), respectively the minimum, maximum,
mean and standard deviation of the dose in the regions of interest.
</p>
</li>
<li><p> the requested <code>$D.x%</code> : (Gy) Dose covering x percent of structure volume.
</p>
</li>
<li><p> the requested <code>$D.xcc</code> : (Gy) Dose covering x (\(cm^3\))
of structure volume.
</p>
</li></ul>

<p>\(-~volume\) : dataframe containing, for all target and
healthy structures, and isodoses:
</p>

<ul>
<li><p> the requested <code>volume.indices</code> : <code>V_tot</code> (\(cm^3\))
(except for isodose) the total volume of the regions of interest, <code>area</code>
(\(cm^2\)) (except for isodose) their surface areas,
<code>V.prescdose</code> (\(cm^3\)) the volumes  receiving at least
<code>presc.dose</code> Gy,
</p>
</li>
<li><p> the requested <code>V.xGy</code> (\(cm^3\)):
volumes receiving at least x Gy.
</p>
</li>
<li><p> the requested <code>V.xpc</code> (\(cm^3\))
Volume receiving at least x% of the reference dose.
</p>
</li></ul>

<p>\(-~conformity\) : dataframe containing, if requested,
</p>

<ul>
<li> <p><code>PITV</code> : (1) Prescription Isodose Target Volume, or conformity index
defined by <em>E.Shaw</em> <strong>[1]</strong>
\[PITV = \frac{V_{presc.dose}}{V_{target}}\]
</p>
</li>
<li> <p><code>PDS</code> : (1) Prescription Dose Spillage
defined by <em>SABR UK Consortium 2019</em> <strong>[2]</strong>
\[PDS = \frac{V_{presc.dose}}{V_{target ~\ge~ presc.dose}} = 
\frac{V_{presc.dose}}{V_{target} ~\cap~ V_{presc.dose}}\]
</p>
</li>
<li> <p><code>CI.lomax2003</code> : (1) Conformity Index defined by <em>Lomax and al</em>
<strong>[3]</strong>
\[CI_{lomax2003} = \frac{V_{target ~\ge~ presc.dose}}{V_{presc.dose}} = 
\frac{V_{target} ~\cap~ V_{presc.dose}}{V_{presc.dose}}\]
</p>
</li>
<li> <p><code>CN</code> : (1) Conformation Number defined by <em>Van't Riet and al</em>
<strong>[4]</strong>. It corresponds to conformity index defined by <em>Paddick</em>
<strong>[5]</strong>
\[CN = CI_{paddick2000} =\frac{V_{target ~\ge~ presc.dose}^2}{V_{target}~\cdot~V_{presc.dose}} = 
\frac{(V_{target} ~\cap~ V_{presc.dose})^2}{V_{target}~\cdot~V_{presc.dose}}\]
</p>
</li>
<li> <p><code>NCI</code> : (1) New conformity index, inverse of CN, defined by
<em>Nakamura and al</em> <strong>[6]</strong>
\[NCI  =\frac{1}{CN}\]
</p>
</li>
<li> <p><code>DSC</code> : (1) Dice Similarity Coefficient <strong>[7]</strong>
\[DSC =  2 ~\cdot~\frac{V_{target ~\ge~ presc.dose}}{V_{target} + V_{presc.dose}} =
2 ~\cdot~\frac{V_{target} ~\cap~ V_{presc.dose}}{V_{target} + V_{presc.dose}}\]
</p>
</li>
<li> <p><code>CI.distance</code> : (1) Conformity Index based on distance defined by
<em>Park and al</em> <strong>[8]</strong>
\[CI.distance = \frac{100}{N} \sum^N \frac{dist_{S_{presc.dose}~\to~G_{target}} - 
dist_{S_{target}~\to~G_{target}}}{dist_{S_{target}~\to~G_{target}}}\]
where \(dist_{S_{presc.dose}~\to~G_{target}}\) is the distance between
the surface of the prescription dose volume and the centroid of the target,
and \(dist_{S_{target}~\to~G_{target}}\) the surface of the target
volume and the centroid of the target.
\(N\) is the number of directions where the distances are calculated.
These directions are computed every 1. If the centroid is not within the target
volume, then <code>CI.distance = NA</code>.
</p>
</li>
<li> <p><code>CI.abs_distance</code> : (1) Conformity Index based on distance defined
by <em>Park and al</em> <strong>[8]</strong>
\[CI.abs_distance = \frac{100}{N} \sum^N \frac{|dist_{S_{presc.dose}~\to~G_{target}} - 
dist_{S_{target}~\to~G_{target}}|}{dist_{S_{target}~\to~G_{target}}}\]
</p>
</li>
<li> <p><code>CDI</code> : (1) Conformity Distance Index defined by <em>Wu and al</em>
<strong>[9]</strong>
\[CDI = 2 \frac{V_{presc.dose} + V_{target} - 2~V_{target ~\ge~ presc.dose}}
{S_{target} + S_{presc.dose}} = \frac{V_{presc.dose} + V_{target} - 2~\cdot~V_{target} ~\cap~ V_{presc.dose}}
{S_{target} + S_{presc.dose}}\]
where \(S_{target}\) is the surface of the target volume and
\(S_{presc.dose}\) is the surface of the prescription dose volume.
</p>
</li>
<li> <p><code>CS3</code> : (1) Triple Point Conformity Scale defined by <em>Ansari
and al</em> <strong>[10]</strong>
\[CS3 = \frac{V_{0.95~\cdot~presc.dose} +  V_{presc.dose} +
 V_{1.05~\cdot~presc.dose}}{3~\cdot~V_{target}}\]
</p>
</li>
<li> <p><code>ULF</code> : (1) Underdosed lesion factor defined by <em>Lefkopoulos
and al</em> <strong>[11]</strong>
\[ULF = \frac{V_{target ~<~ presc.dose}}{V_{target}}=
 \frac{V_{target} ~\cap~ \overline{V_{presc.dose}}}{V_{target}}\]
</p>
</li>
<li> <p><code>OHTF</code> :(1) Overdosed healthy tissues factor defined by <em>Lefkopoulos
and al</em> <strong>[11]</strong>
\[OHTF = \frac{\sum V_{healthy ~\ge~ presc.dose}}{V_{target}} = 
\frac{\sum V_{healthy} ~\cap~ V_{presc.dose}}{V_{target}} \]
</p>
</li>
<li> <p><code>gCI</code> : (1) Geometric Conformity Index  defined by
<em>Lefkopoulos and al</em> <strong>[11]</strong>
\[gCI = ULF + OHTF\]
</p>
</li>
<li> <p><code>COIN</code> : Conformity Index defined by <em>Baltas and al</em> <strong>[12]</strong>
\[COIN  =\frac{V_{target ~\ge~ presc.dose}^2}{V_{target}~\cdot~V_{presc.dose}}~\cdot~
  \prod^{N_{healthy}} \left( 1 -\frac{V_{healthy ~\ge~ presc.dose}}{V_{healthy}}\right)\]
</p>
</li>
<li> <p><code>gCOSI</code> : generalized COSI, defined by <em>Menhel and al</em> <strong>[13]</strong>.
\[gCOSI  = 1- \sum^{N_{healthy}}  healthy.weight~\cdot~
\frac{\frac{V_{healthy ~\ge~ healthy.tol.dose}}{V_{healthy}}}{\frac{V_{target ~\ge~ presc.dose}}{V_{target}}}\]
</p>
</li></ul>

<p>\(-~COSI\) : if &quot;COSI&quot; is requested in <code>conformity.indices</code>,
it returns a dataframe of Critical Organ Scoring Index for each healthy organ,
at each <code>presc.dose</code>, and for each target. COSI is defined by
<em>Menhel and al</em> <strong>[13]</strong>
\[COSI  = 1- 
\frac{\frac{V_{healthy ~\ge~ healthy.tol.dose}}{V_{healthy}}}{\frac{V_{target ~\ge~ presc.dose}}{V_{target}}}\]
</p>
<p>\(-~homogeneity\) : dataframe containing
</p>

<ul>
<li> <p><code>HI.RTOG.max_ref</code> : (1) Homogeneity Index from RTOG defined by
<em>E.Shaw</em> <strong>[1]</strong>
\[HI.RTOG.max_-ref = \frac{D_{~max}}{presc.dose}\]
where \(D_{max}\) is the maximum dose in the target volume.
</p>
</li>
<li> <p><code>HI.RTOG.5_95</code> : (1) Homogeneity Index from RTOG <strong>[1]</strong>
\[HI.RTOG.5_-95 = \frac{D.5pc}{D.95pc}\]
where \(D.5pc\) and \(D.95pc\) are respectively the doses
at 5% and 95% of the target volume in cumulative dose-volume histogram.
</p>
</li>
<li> <p><code>HI.ICRU.max_min</code> : (1) Homogeneity Index from <em>ICRU report 62</em>
<strong>[14]</strong>
\[HI.ICRU.max_-min = \frac{D_{~max}}{D_{~min}}\]
where \(D_{max}\) and \(D_{min}\) are respectively the
maximum and the minimum dose in the target volume.
</p>
</li>
<li> <p><code>HI.ICRU.2.98_ref</code> : (1) Homogeneity Index from <em>ICRU report 83</em>
<strong>[15]</strong>
\[HI.ICRU.2.98_-ref = 100 \frac{D.2pc - D.98pc}{presc.dose}\]
where \(D.2pc\) and \(D.98pc\) are respectively the doses
at 2% and 98% of the target volume in cumulative dose-volume histogram.
</p>
</li>
<li> <p><code>HI.ICRU.2.98_50 </code> : (1) Homogeneity Index from <em>ICRU report 83</em>
<strong>[15]</strong>
\[HI.ICRU.2.98_-50 = 100 \frac{D.2pc - D.98pc}{D.50pc}\]
where \(D.2pc\), \(D.98pc\) and \(D.50pc\) are
respectively the doses
at 2%, 98% and 50% of the target volume in cumulative dose-volume histogram.
</p>
</li>
<li> <p><code>HI.ICRU.5.95_ref</code> : (1) Homogeneity Index from <em>ICRU report 83</em>
<strong>[15]</strong>
\[HI.ICRU.5.95_-ref = 100 \frac{D.5pc - D.95pc}{presc.dose}\]
where \(D.5pc\) and \(D.95pc\) are respectively the doses
at 5% and 95% of the target volume in cumulative dose-volume histogram.
</p>
</li>
<li> <p><code>HI.mayo2010</code> : (1) Homogeneity Index defined by <em>Mayo and al</em>
<strong>[16]</strong>
\[HI.mayo2010 =\sqrt{\frac{D_{~max}}{presc.dose}~\cdot~(1 + 
\frac{\sigma_D}{presc.dose})}\]
where \(D_{max}\) is the maximum dose in the target volume, and
\(\sigma_D\) the standard deviation of the dose in the target volume.
</p>
</li>
<li> <p><code>HI.heufelder</code> : (1) Homogeneity Index defined by <em>Heufelder and al</em>
<strong>[17]</strong>
\[HI.heufelder = e^{-0.01~\cdot~ (1-\frac{\mu_D}{presc.dose})^2}~\cdot~
e^{-0.01~\cdot~ (\frac{\sigma_D}{presc.dose})^2}\]
where \(\mu_D\) and \(\sigma_D\) are
respectively the mean and the standard deviation of the dose in the target volume.
</p>
</li></ul>

<p>\(-~gradient\) : dataframe containing
</p>

<ul>
<li> <p><code>GI.ratio.50</code>: Gradient Index based on volumes ratio defined by
<em>Paddick and Lippitz</em> <strong>[18]</strong>
\[GI.ratio.50 = \frac {V_{0.5~\cdot~presc.dose}}{V_{presc.dose}}\]
</p>
</li>
<li> <p><code>mGI</code>: Modified Gradient Index defined by <em>SABR UK Consortium 2019</em>
<strong>[2]</strong>
\[mGI = \frac{V_{0.5~\cdot~presc.dose}}{V_{target ~\ge~ presc.dose}} = 
\frac{V_{0.5~\cdot~presc.dose}}{V_{target} ~\cap~ V_{presc.dose}}\]
</p>
</li></ul>



<h3>References</h3>

<p><strong>[1]</strong> Shaw E, Kline R, Gillin M, Souhami L, Hirschfeld A, Dinapoli R, Martin L (1993).
&ldquo;Radiation therapy oncology group: Radiosurgery quality assurance guidelines.&rdquo;
<em>International journal of radiation oncology, biology, physics</em>, <b>27</b>(5), 1231-1239.
ISSN 0360-3016, <a href="https://doi.org/10.1016/0360-3016%2893%2990548-A">doi:10.1016/0360-3016(93)90548-A</a>.
</p>
<p><strong>[2]</strong> UK SABR Consortium (Online; accessed 2022-04-01).
&ldquo;Stereotactic Ablative Radiation Therapy (SABR): a resource. v6.1, January 2019.&rdquo;
<a href="https://www.sabr.org.uk/wp-content/uploads/2019/04/SABRconsortium-guidelines-2019-v6.1.0.pdf">https://www.sabr.org.uk/wp-content/uploads/2019/04/SABRconsortium-guidelines-2019-v6.1.0.pdf</a>.
</p>
<p><strong>[3]</strong> Lomax NJ, Scheib SG (2003).
&ldquo;Quantifying the degree of conformity in radiosurgery treatment planning.&rdquo;
<em>International journal of radiation oncology, biology, physics</em>, <b>55</b>(5), 1409-1419.
ISSN 0360-3016, <a href="https://doi.org/10.1016/S0360-3016%2802%2904599-6">doi:10.1016/S0360-3016(02)04599-6</a>.
</p>
<p><strong>[4]</strong> Riet AV, Mak AC, Moerland MA, Elders LH, Van der Zee W (1997).
&ldquo;A conformation number to quantify the degree of conformality in brachytherapy and external beam irradiation: Application to the prostate.&rdquo;
<em>International journal of radiation oncology, biology, physics</em>, <b>37</b>(3), 731-736.
ISSN 0360-3016, <a href="https://doi.org/10.1016/S0360-3016%2896%2900601-3">doi:10.1016/S0360-3016(96)00601-3</a>.
</p>
<p><strong>[5]</strong> Paddick I (2000).
&ldquo;A simple scoring ratio to index the conformity of radiosurgical treatment plans. Technical note.&rdquo;
<em>Journal of neurosurgery</em>, <b>93 Suppl 3</b>, 219-222.
</p>
<p><strong>[6]</strong> Nakamura J, Verhey L, Smith V, Petti P, Lamborn K, Larson D, Wara W, Mcdermott M, Sneed P (2002).
&ldquo;Dose conformity of Gamma Knife radiosurgery and risk factors for complications.&rdquo;
<em>International journal of radiation oncology, biology, physics</em>, <b>51</b>, 1313-9.
<a href="https://doi.org/10.1016/S0360-3016%2801%2901757-6">doi:10.1016/S0360-3016(01)01757-6</a>.
</p>
<p><strong>[7]</strong> Dice LR (1945).
&ldquo;Measures of the Amount of Ecologic Association Between Species.&rdquo;
<em>Ecology</em>, <b>26</b>(3), 297&ndash;302.
ISSN 00129658, 19399170.
</p>
<p><strong>[8]</strong> Park JM, Park S, Ye S, Kim J, Carlson J, Wu H (2014).
&ldquo;New conformity indices based on the calculation of distances between the target volume and the volume of reference isodose.&rdquo;
<em>The British journal of radiology</em>, <b>87</b>, 20140342.
<a href="https://doi.org/10.1259/bjr.20140342">doi:10.1259/bjr.20140342</a>.
</p>
<p><strong>[9]</strong> Wu Q, Wessels BW, Einstein DB, Maciunas RJ, Kim EY, Kinsella TJ (2003).
&ldquo;Quality of coverage: Conformity measures for stereotactic radiosurgery.&rdquo;
<em>Journal of Applied Clinical Medical Physics</em>, <b>4</b>, 374-381.
</p>
<p><strong>[10]</strong> Ansari S, Satpathy S, Singh P, Lad S, Thappa N, Singh B (2018).
&ldquo;A new index: Triple Point Conformity Scale (CS3) and its implication in qualitative evaluation of radiotherapy plan.&rdquo;
<em>Journal of Radiotherapy in Practice</em>, <b>17</b>, 1-4.
<a href="https://doi.org/10.1017/S1460396917000772">doi:10.1017/S1460396917000772</a>.
</p>
<p><strong>[11]</strong> Lefkopoulos D, Dejean C, balaa ZE, Platoni K, Grandjean P, Foulquier J, Schlienger M (2000).
&ldquo;Determination of dose-volumes parameters to characterise the conformity of stereotactic treatment plans.&rdquo;
In chapter XIII, 356-358.
Springer Berlin Heidelberg.
ISBN 978-3-540-67176-3, <a href="https://doi.org/10.1007/978-3-642-59758-9_135">doi:10.1007/978-3-642-59758-9_135</a>.
</p>
<p><strong>[12]</strong> Baltas D, Kolotas C, Geramani KN, Mould RF, Ioannidis G, Kekchidi M, Zamboglou N (1998).
&ldquo;A conformal index (COIN) to evaluate implant quality and dose specification in brachytherapy.&rdquo;
<em>International journal of radiation oncology, biology, physics</em>, <b>40 2</b>, 515-24.
<a href="https://doi.org/10.1016/s0360-3016%2897%2900732-3">doi:10.1016/s0360-3016(97)00732-3</a>.
</p>
<p><strong>[13]</strong> Menhel J, Levin D, Alezra D, Symon Z, Pfeffer R (2006).
&ldquo;Assessing the quality of conformal treatment planning: a new tool for quantitative comparison.&rdquo;
<em>Physics in Medicine and Biology</em>, <b>51</b>(20), 5363&ndash;5375.
</p>
<p><strong>[14]</strong> Landberg T, Chavaudra J, Dobbs J, Gerard J, Hanks G, Horiot J, Johansson K, Mller T, Purdy J, Suntharalingam N, Svensson H (1999).
&ldquo;ICRU Report 62: Prescribing, Recording and Reporting Photon Beam Therapy (Supplement to ICRU Report 50),3. Absorbed Doses.&rdquo;
<em>Reports of the International Commission on Radiation Units and Measurements</em>, <b>os-32</b>(1), 21-25.
</p>
<p><strong>[15]</strong> ICRU (2010).
&ldquo;Report 83 : Prescribing, Recording, and Reporting Photon-Beam Intensity-Modulated Radiation Therapy (IMRT).&rdquo;
<em>Reports of the International Commission on Radiation Units and Measurements</em>, <b>10</b>(1), 1-3.
</p>
<p><strong>[16]</strong> Mayo CS, Ding L, Addesa A, Kadish S, Fitzgerald TJ, Moser R (2010).
&ldquo;Initial Experience With Volumetric IMRT (RapidArc) for Intracranial Stereotactic Radiosurgery.&rdquo;
<em>International Journal of Radiation Oncology*Biology*Physics</em>, <b>78</b>(5), 1457-1466.
ISSN 0360-3016, <a href="https://doi.org/10.1016/j.ijrobp.2009.10.005">doi:10.1016/j.ijrobp.2009.10.005</a>.
</p>
<p><strong>[17]</strong> Heufelder J, Zink K, Scholz M, Kramer K, Welker K (2003).
&ldquo;Eine Methode zur automatisierten Bewertung von CT-basierten Bestrahlungsplanen in der perkutanen Strahlentherapie.&rdquo;
<em>Zeitschrift fur Medizinische Physik</em>, <b>13</b>(4), 231-239.
ISSN 0939-3889, <a href="https://doi.org/10.1078/0939-3889-00175">doi:10.1078/0939-3889-00175</a>.
</p>
<p><strong>[18]</strong> Paddick I, Lippitz BE (2006).
&ldquo;A simple dose gradient measurement tool to complement the conformity index.&rdquo;
<em>Journal of neurosurgery</em>, <b>105 Suppl</b>, 194-201.
</p>
<p>All this references are compiled by
</p>

<ul>
<li> <p>Kaplan LP, Korreman SS (2021).
&ldquo;A systematically compiled set of quantitative metrics to describe spatial characteristics of radiotherapy dose distributions and aid in treatment planning.&rdquo;
<em>Physica Medica</em>, <b>90</b>, 164-175.
ISSN 1120-1797, <a href="https://doi.org/10.1016/j.ejmp.2021.09.014">doi:10.1016/j.ejmp.2021.09.014</a>. and
</p>
</li>
<li> <p>Patel G, Mandal A, Choudhary S, Mishra R, Shende R (2020).
&ldquo;Plan evaluation indices: A journey of evolution.&rdquo;
<em>Reports of Practical Oncology &amp; Radiotherapy</em>, <b>25</b>.
<a href="https://doi.org/10.1016/j.rpor.2020.03.002">doi:10.1016/j.rpor.2020.03.002</a>..
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+rt.indices.from.bin">rt.indices.from.bin</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb 
#  for better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("rtdose", "rtstruct"), roi.name = "eye",
                             dxyz = rep (step, 3), beam.nb = 3)
indices &lt;- rt.indices.from.roi (patient$rtdose[[1]],  patient$rtstruct[[1]],
                                target.roi.sname = "ptv",
                                healthy.roi.sname = "eye", presc.dose = 50,
                                conformity.indices = c("PITV", "PDS", "CI.lomax2003", 
                                                       "CN", "NCI", "DSC","COIN"),
                                verbose = FALSE)
indices
</code></pre>

<hr>
<h2 id='save.T.MAT'>Save a T.MAT class object</h2><span id='topic+save.T.MAT'></span>

<h3>Description</h3>

<p>The <code>save.T.MAT</code> function saves the data required by
<a href="#topic+load.T.MAT">load.T.MAT</a>, <a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a> or
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> to generate <code>T.MAT</code>, as
pre-formatted Rdcm files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.T.MAT(T.MAT, dirname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.T.MAT_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object to save.</p>
</td></tr>
<tr><td><code id="save.T.MAT_+3A_dirname">dirname</code></td>
<td>
<p>Directory where new reg .Rdcm files will be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reg files from DICOM files cannot be updated with the <code>save.T.MAT</code>
function. Only transfer matrices added with <a href="#topic+ref.add">ref.add</a> or
<a href="#topic+ref.cutplane.add">ref.cutplane.add</a> will be saved.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code>, if all reg files generating T.MAT are saved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for  better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = rep (step, 3))
                             
# Save T.MAT to a temporary file pat.dir
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
save.T.MAT (patient$T.MAT, dirname = pat.dir)
list.files(pat.dir)

# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='save.to.Rdcm'>Save a <span class="pkg">espadon</span> object in a pre-formatted *.Rdcm file</h2><span id='topic+save.to.Rdcm'></span>

<h3>Description</h3>

<p>The function <code>save.to.Rdcm</code> allows you to save an object
created by <span class="pkg">espadon</span> in a pre-formatted *.Rdcm file. This object will also be
accessible by the <code>load.patient.from.Rdcm</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.to.Rdcm(obj, object.name = obj$object.alias, dirname = obj$file.dirname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.to.Rdcm_+3A_obj">obj</code></td>
<td>
<p><span class="pkg">espadon</span> object of class <code>"volume"</code>, <code>"struct"</code>, <code>"mesh"</code>,
<code>"histo"</code>, <code>"dvh"</code>, <code>"histo2D"</code>.</p>
</td></tr>
<tr><td><code id="save.to.Rdcm_+3A_object.name">object.name</code></td>
<td>
<p>Character string, representing the name of the object,
default to <code>obj$object.alias</code>.</p>
</td></tr>
<tr><td><code id="save.to.Rdcm_+3A_dirname">dirname</code></td>
<td>
<p>Directory where new files from <code>obj</code> will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code>, if <code>paste0(object.name,".Rdcm")</code> exists in
<code>dirname</code>.
</p>
<p>Returns <code>FALSE</code>, if <code>object.name</code> is not a valid file name,
or if the file that is created would replace a *.Rdcm file created by
<a href="#topic+dicom.to.Rdcm.converter">dicom.to.Rdcm.converter</a>.
</p>


<h3>Note</h3>

<p><code>save.to.Rdcm</code> can not replace an *.Rdcm file created by
<a href="#topic+dicom.to.Rdcm.converter">dicom.to.Rdcm.converter</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = rep (step, 3))
                             
# Save T.MAT to a temporary file pat.dir
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
save.to.Rdcm (patient$ct[[1]], dirname = pat.dir)
save.to.Rdcm (patient$mr[[1]], dirname = pat.dir)
list.files(pat.dir)

# Cleaning  temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='select.names'>Regions of Interest (RoI) indices</h2><span id='topic+select.names'></span>

<h3>Description</h3>

<p>The select.names function allows you to select words from a
vector of words, according to several criteria, eliminating spaces and case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.names(names, roi.name = NULL, roi.sname = NULL, roi.idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.names_+3A_names">names</code></td>
<td>
<p>Words vector</p>
</td></tr>
<tr><td><code id="select.names_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of words to compare to <code>names</code>. By default
<code>roi.name = NULL</code>. See Details</p>
</td></tr>
<tr><td><code id="select.names_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of words or parts of words to compare. By default
<code>roi.sname = NULL</code>. See Details</p>
</td></tr>
<tr><td><code id="select.names_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Index vector. By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are all
<code>NULL</code>, then all RoI are selected.
</p>


<h3>Value</h3>

<p>Returns the indices of the elements of the word vector <code>names</code>
satisfying one or more of the following conditions:
</p>

<ul>
<li><p> ASCII // TRANSLIT transcriptions, without spaces, of <code>names</code> and
<code>roi.name</code>, are identical.
</p>
</li>
<li><p> ASCII // TRANSLIT transcriptions, without spaces of <code>roi.sname</code>
are identical to part of ASCII // TRANSLIT transcriptions, without spaces of
<code>names</code>.
</p>
</li>
<li> <p><code>names</code> indices belong to the index vector <code>roi.idx</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># loading patient objects
names &lt;- c ("Eye left", "EyeR", "OPTICAL nerve L", "opical nervR", "chiasma")

# RoI selection.
select.names (names = names, roi.name = c("eye left", "eye right"))
select.names (names = names, roi.sname = c("eye", "ner"))
select.names (names = names, roi.idx = 4:9)
</code></pre>

<hr>
<h2 id='set.reference.obj'>Set the reference objects of a espadon object</h2><span id='topic+set.reference.obj'></span>

<h3>Description</h3>

<p>The function <code>set.reference.obj</code> adds to an espadon object
the information identifying the espadon objects from which it derives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.reference.obj(obj, ref.obj, add = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.reference.obj_+3A_obj">obj</code></td>
<td>
<p>espadon object of class &quot;dvh&quot;, &quot;fan&quot;, &quot;histo&quot;, &quot;histo2D&quot;, &quot;mesh&quot;,
&quot;rtplan&quot;, &quot;struct&quot;, &quot;undef&quot; or &quot;volume&quot;.</p>
</td></tr>
<tr><td><code id="set.reference.obj_+3A_ref.obj">ref.obj</code></td>
<td>
<p>espadon object of class &quot;dvh&quot;, &quot;fan&quot;, &quot;histo&quot;, &quot;histo2D&quot;, &quot;mesh&quot;,
&quot;rtplan&quot;, &quot;struct&quot;, &quot;undef&quot; or &quot;volume&quot;. List of espadon objects.</p>
</td></tr>
<tr><td><code id="set.reference.obj_+3A_add">add</code></td>
<td>
<p>Boolean. If TRUE, the reference objects are added to those already
contained by <code>obj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the espadon object <code>obj</code>, containing the ref.object.alias
and ref.object.info fields identifying its reference objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 6
pat &lt;- toy.load.patient (modality = c("ct", "rtdose", "rtstruct"),
                         roi.name = c("eye"), dxyz = rep (step, 3),
                         beam.nb = 3)
display.obj.links(pat)                          
pat$rtstruct[[1]] &lt;- set.reference.obj(pat$rtstruct[[1]],pat$ct[[1]])  
display.obj.links(pat)                          
</code></pre>

<hr>
<h2 id='sp.similarity.from.bin'>Volume-based spatial similarity metrics calculated from binary modality 3D volumes.
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+sp.similarity.from.bin'></span>

<h3>Description</h3>

<p>The <code>sp.similarity.from.bin</code> function computes volumetric Dice
similarity coefficient, Dice-Jaccard coefficient and Dice surface similarity coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.similarity.from.bin(
  vol.A,
  vol.B,
  coeff = c("DSC", "DJC", "MDC", "under.MDC", "over.MDC")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp.similarity.from.bin_+3A_vol.a">vol.A</code>, <code id="sp.similarity.from.bin_+3A_vol.b">vol.B</code></td>
<td>
<p>&quot;volume&quot; class objects, of <code>"binary"</code> modality. <code>vol.B</code> is the reference for MDC calculation.</p>
</td></tr>
<tr><td><code id="sp.similarity.from.bin_+3A_coeff">coeff</code></td>
<td>
<p>Vector indicating the requested metrics from among
'DSC' (Dice similarity coefficient),'DJC' (Dice-Jaccard coefficient),
and 'MDC' (mean distance to conformity). Equal to <code>NULL</code> if not requested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe containing (if requested):
</p>

<ul>
<li><p> volumetric Dice similarity coefficient <code>DSC</code> defined by :
\[DSC = 2 \frac{V_{A} ~\cap~ V_{B}}{V_{A} + V_{B}}\]
</p>
</li>
<li><p> Dice-Jaccard coefficient <code>DJC</code> defined by :
\[DJC = \frac{V_{A} ~\cap~ V_{B}}{V_{A} ~\cup~ V_{B}}\]
</p>
</li>
<li><p> mean distance to conformity <code>MDC</code>, over-contouring mean distance
<code>over.MDC</code> and under-contouring mean distance <code>under.MDC</code>, defined by
<em>Jena et al</em> <strong>[1]</strong>
</p>
</li></ul>



<h3>References</h3>

<p><strong>[1]</strong> Jena R, et al. (2010).
&ldquo;A novel algorithm for the morphometric assessment of radiotherapy treatment planning volumes.&rdquo;
<em>Br J Radiol.</em>, <b>83</b>(985), 44-51.
<a href="https://doi.org/10.1259/bjr/27674581">doi:10.1259/bjr/27674581</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+sp.similarity.from.mesh">sp.similarity.from.mesh</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creation of to volume" class objects, of "binary" modality
vol.A &lt;- vol.create (pt000 = c(-25,-25,0), dxyz = c (1 , 1, 1),
                    n.ijk = c(50, 50, 1), default.value = FALSE,
                    ref.pseudo = "ref1",
                    alias = "vol.A", modality = "binary",
                    description = "") 
vol.B &lt;- vol.copy (vol.A,alias = "vol.B")   
vol.A$vol3D.data [as.matrix(expand.grid(15:35,20:35,1))] &lt;- TRUE
vol.A$max.pixel &lt;- TRUE
vol.B$vol3D.data [as.matrix(expand.grid(16:36,18:37,1))] &lt;- TRUE
vol.B$max.pixel &lt;- TRUE
display.plane (vol.A, vol.B, interpolate = FALSE, 
               main = "vol.A &amp; vol.B @ z = 0 mm") 
               
sp.similarity.from.bin (vol.A, vol.B)
</code></pre>

<hr>
<h2 id='sp.similarity.from.mesh'>Distance-based spatial similarity metrics calculated from the mesh.
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+sp.similarity.from.mesh'></span>

<h3>Description</h3>

<p>The <code>sp.similarity.from.mesh</code> function computes Hausdorff
distances and surface Dice similarity coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.similarity.from.mesh(
  mesh1,
  mesh2,
  hausdorff.coeff = c("HD.max", "HD.mean"),
  hausdorff.quantile = c(0.5, 0.95),
  surface.tol = seq(0, 10, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp.similarity.from.mesh_+3A_mesh1">mesh1</code>, <code id="sp.similarity.from.mesh_+3A_mesh2">mesh2</code></td>
<td>
<p>espadon mesh class objects</p>
</td></tr>
<tr><td><code id="sp.similarity.from.mesh_+3A_hausdorff.coeff">hausdorff.coeff</code></td>
<td>
<p>Vector indicating the requested Hausdorff distance metrics from among
'HD.max','HD.mean'. Equal to <code>NULL</code> if not requested.
<code>NULL</code>, it will be added.</p>
</td></tr>
<tr><td><code id="sp.similarity.from.mesh_+3A_hausdorff.quantile">hausdorff.quantile</code></td>
<td>
<p>numeric vector of probabilities with values between 0 and 1,
representing the quantiles of the unsigned distances between <code>mesh1</code> and <code>mesh2</code>.
Equal to <code>NULL</code> if not requested.</p>
</td></tr>
<tr><td><code id="sp.similarity.from.mesh_+3A_surface.tol">surface.tol</code></td>
<td>
<p>numeric vector representing the maximum margins of
deviation which may be tolerated without penalty. Equal to <code>NULL</code> if not requested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing (if requested):
</p>

<ul>
<li> <p><code>Hausdorff</code> : dataframe including the maximum, mean and quantiles
</p>
</li>
<li> <p><code>smetrics</code> : dataframe with the columns:
</p>

<ul>
<li> <p><code>tol</code> : the requested tolerances
</p>
</li>
<li> <p><code>sDSC</code> : the surface Dice similarity coefficients,defined by
<em>Nikolov et al</em> <strong>[1]</strong>
</p>
</li>
<li> <p><code>sAPL</code> : the surface Added Path Length in \(mm^{2}\),
introduced (in pixels) by  <em>Vaassen et al</em> <strong>[2]</strong>
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p><strong>[1]</strong> Nikolov S, et al. (2018).
&ldquo;Deep learning to achieve clinically applicable segmentation of head and neck anatomy for radiotherapy.&rdquo;
<em>ArXiv</em>, <b>abs/1809.04430</b>.
</p>
<p><strong>[2]</strong> Vaassen S, et al. (2020).
&ldquo;Evaluation of measures for assessing time-saving of automatic organ-at-risk segmentation in radiotherapy.&rdquo;
<em>Physics and Imaging in Radiation Oncology</em>, <b>13</b>, 1-6.
</p>


<h3>See Also</h3>

<p><a href="#topic+sp.similarity.from.bin">sp.similarity.from.bin</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library (Rvcg)
# espadon mesh of two spheres of radius R1=10 and R2=11, separated by dR = 3
sph &lt;- vcgSphere ()
mesh1 &lt;- obj.create ("mesh")
mesh1$nb.faces &lt;- ncol (sph$it)
mesh1$mesh &lt;- sph
mesh2 &lt;-  mesh1

R1 &lt;- 10
R2 &lt;- 11
dR &lt;- 3
mesh1$mesh$vb[1:3,] &lt;- R1 * mesh1$mesh$normals[1:3,] + mesh1$mesh$vb[1:3,]
mesh2$mesh$vb[1:3,] &lt;- R2 * mesh2$mesh$normals[1:3,] + mesh2$mesh$vb[1:3,] +
                 matrix (c (dR, 0, 0), ncol = ncol (mesh2$mesh$vb), nrow = 3)
             
sp.similarity.from.mesh (mesh1 , mesh2, 
                         hausdorff.quantile = seq (0, 1, 0.05),
                         surface.tol = seq (0, dR + abs(R2-R1), 0.5))
</code></pre>

<hr>
<h2 id='struct.clustering'>Clustering volumes by RoI
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+struct.clustering'></span>

<h3>Description</h3>

<p>The <code>struct.clustering</code> function creates a new volume
in which voxels are clustered and labeled by region of interest defined in an
rt-struct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.clustering(
  vol,
  struct,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  T.MAT = NULL,
  alias = "",
  description = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.clustering_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the <code>struct</code> object.
By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>struct</code> object.
By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by
<a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a> or <a href="#topic+load.T.MAT">load.T.MAT</a>. If
<code>T.MAT = NULL</code>, <code>struct$ref.pseudo</code> must be equal to
<code>vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (struct$object.alias,"clustering")</code></p>
</td></tr>
<tr><td><code id="struct.clustering_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. if <code>TRUE</code> (default), the RoI studied are listed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are
all set to <code>NULL</code>, all RoI are selected.
</p>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), of <code>"cluster"</code> modality. This object contains the
<code>$cluster.info</code> field, detailing the label and volumes in \(cm^{3}\)
of the different clusters. Note that the label <code>NA</code> or value 0 is used for the voxels
which are not contained in any RoI (air for instance).
</p>


<h3>See Also</h3>

<p><a href="#topic+get.roi.connection">get.roi.connection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c ("mr", "rtstruct"),  
                             dxyz = rep (step, 3))
MR &lt;- patient$mr[[1]]
S &lt;- patient$rtstruct[[1]]
cluster.vol &lt;- struct.clustering (MR, S, T.MAT = patient$T.MAT, verbose = FALSE)
head (cluster.vol$cluster.info)

# Display
n = nrow(cluster.vol$cluster.info)
col = paste0(c ("#000000", rainbow (n-1)),"af")
breaks &lt;- seq (cluster.vol$min.pixel - 0.5, cluster.vol$max.pixel + 0.5, 
              length.out = n+1)
par0 &lt;- par()
par(mfrow = c(1,2), mar = c(1,15,1,1))
display.palette(col, factors = cluster.vol$cluster.info$label)
par(mar = c(1, 1, 1, 1))
display.plane (MR, cluster.vol, main = "RoI clustering", view.coord = 0,
               top.col = col, top.breaks = breaks, interpolate = FALSE)
par(mfrow= par0$mfrow,mar=par0$mar)
</code></pre>

<hr>
<h2 id='struct.from.bin'>Creation of struct class object from a binary volume</h2><span id='topic+struct.from.bin'></span>

<h3>Description</h3>

<p>The <code>struct.from.bin</code> function creates a struct object with
a unique RoI, defined by the contours of binary volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.from.bin(
  vol,
  roi.name = vol$description,
  roi.nb = 1,
  roi.color = "#379DA2",
  roi.type = c("", "EXTERNAL", "PTV", "CTV", "GTV", "TREATED_VOLUME", "IRRAD_VOLUME",
    "OAR", "BOLUS", "AVOIDANCE", "ORGAN", "MARKER", "REGISTRATION", "ISOCENTER",
    "CONTRAST_AGENT", "CAVITY", "BRACHY_CHANNEL", "BRACHY_ACCESSORY", "BRACHY_SRC_APP",
    "BRACHY_CHNL_SHLD", "SUPPORT", "FIXATION", "DOSE_REGION", "CONTROL",
    "DOSE_MEASUREMENT"),
  external.only = FALSE,
  alias = "",
  description = paste("RoI from", vol$object.alias)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.from.bin_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, of binary modality.</p>
</td></tr>
<tr><td><code id="struct.from.bin_+3A_roi.name">roi.name</code></td>
<td>
<p>Character string, representing the name of created RoI.</p>
</td></tr>
<tr><td><code id="struct.from.bin_+3A_roi.nb">roi.nb</code></td>
<td>
<p>Positive integer, representing the number of created RoI.</p>
</td></tr>
<tr><td><code id="struct.from.bin_+3A_roi.color">roi.color</code></td>
<td>
<p>Color of the created RoI, in hex code format (&quot;#RRGGBB&quot;).</p>
</td></tr>
<tr><td><code id="struct.from.bin_+3A_roi.type">roi.type</code></td>
<td>
<p>Type of RoI, from among &quot;&quot;, &quot;EXTERNAL&quot;, &quot;PTV&quot;, &quot;CTV&quot;, &quot;GTV&quot;,
&quot;TREATED_VOLUME&quot;, &quot;IRRAD_VOLUME&quot;, &quot;OAR&quot;, &quot;BOLUS&quot;, &quot;AVOIDANCE&quot;, &quot;ORGAN&quot;, &quot;MARKER&quot;,
&quot;REGISTRATION&quot;, &quot;ISOCENTER&quot;, &quot;CONTRAST_AGENT&quot;, &quot;CAVITY&quot;, &quot;BRACHY_CHANNEL&quot;,
&quot;BRACHY_ACCESSORY&quot;, &quot;BRACHY_SRC_APP&quot;, &quot;BRACHY_CHNL_SHLD&quot;, &quot;SUPPORT&quot;, &quot;FIXATION&quot;,
&quot;DOSE_REGION&quot;,&quot;CONTROL&quot; and &quot;DOSE_MEASUREMENT&quot;</p>
</td></tr>
<tr><td><code id="struct.from.bin_+3A_external.only">external.only</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only external contours are kept.</p>
</td></tr>
<tr><td><code id="struct.from.bin_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="struct.from.bin_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;struct&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definition), including the unique <code>roi.name</code> as region of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Contours of a sphere of 10 mm radius
b.sphere &lt;- vol.create (n.ijk = c (40, 40, 40), dxyz = c(1,1,1), 
                        mid.pt = c (0, 0, 0), modality = "binary", 
                        default.value = FALSE)
xyz &lt;- expand.grid (-20:19, -20:19, -20:19)
R &lt;- 10
Sphere.flag &lt;- (xyz[, 1]^2 + xyz[, 2]^2 + xyz[, 3]^2) &lt;= R^2
b.sphere$vol3D.data[Sphere.flag] &lt;- TRUE
b.sphere$max.pixel &lt;- TRUE
S.sphere &lt;- struct.from.bin (b.sphere, roi.name = "sphere", external.only = TRUE)
str (S.sphere$roi.info)                 
</code></pre>

<hr>
<h2 id='struct.from.mesh'>Creation of struct class object from an espadon mesh</h2><span id='topic+struct.from.mesh'></span>

<h3>Description</h3>

<p>The <code>struct.from.mesh</code> function creates a struct object with
a unique RoI, defined by the contours of a mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.from.mesh(
  mesh,
  z,
  thickness = NULL,
  roi.name = mesh$object.alias,
  roi.nb = 1,
  roi.color = "#ff0000",
  roi.type = "",
  alias = "",
  description = NULL,
  force.closed = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.from.mesh_+3A_mesh">mesh</code></td>
<td>
<p>espadon mesh class object.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_z">z</code></td>
<td>
<p>z-coordinate vector where mesh contours are computed.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_thickness">thickness</code></td>
<td>
<p>struct thickness between 2 adjacent contours. If NULL (default),
it is deduced from <code>z</code>.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_roi.name">roi.name</code></td>
<td>
<p>Character string, representing the name of created RoI.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_roi.nb">roi.nb</code></td>
<td>
<p>Positive integer, representing the number of created RoI.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_roi.color">roi.color</code></td>
<td>
<p>Color of the created RoI, in hex code format (&quot;#RRGGBB&quot;).</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_roi.type">roi.type</code></td>
<td>
<p>Type of RoI, from among &quot;&quot;, &quot;EXTERNAL&quot;, &quot;PTV&quot;, &quot;CTV&quot;, &quot;GTV&quot;,
&quot;TREATED_VOLUME&quot;, &quot;IRRAD_VOLUME&quot;, &quot;OAR&quot;, &quot;BOLUS&quot;, &quot;AVOIDANCE&quot;, &quot;ORGAN&quot;, &quot;MARKER&quot;,
&quot;REGISTRATION&quot;, &quot;ISOCENTER&quot;, &quot;CONTRAST_AGENT&quot;, &quot;CAVITY&quot;, &quot;BRACHY_CHANNEL&quot;,
&quot;BRACHY_ACCESSORY&quot;, &quot;BRACHY_SRC_APP&quot;, &quot;BRACHY_CHNL_SHLD&quot;, &quot;SUPPORT&quot;, &quot;FIXATION&quot;,
&quot;DOSE_REGION&quot;,&quot;CONTROL&quot; and &quot;DOSE_MEASUREMENT&quot;.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_force.closed">force.closed</code></td>
<td>
<p>Boolean. Set to <code>TRUE</code> when the mesh represents the
surface of a closed volume.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), a progress bar indicates
the state of calculation.</p>
</td></tr>
<tr><td><code id="struct.from.mesh_+3A_...">...</code></td>
<td>
<p>Others parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;struct&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definition), including the unique <code>roi.name</code> as region of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of an espadon mesh of a cube
M &lt;- obj.create (class = "mesh")
M$mesh &lt;- Rvcg::vcgIsotropicRemeshing (Rvcg::vcgBox(),0.5) 
M$nb.faces &lt;- ncol (M$mesh$it)

S &lt;- struct.from.mesh (M, z = seq(-1,1,0.5))
display.3D.contour(S)
</code></pre>

<hr>
<h2 id='struct.in.new.ref'>Change of frame of reference of a &quot;struct&quot; class object.</h2><span id='topic+struct.in.new.ref'></span>

<h3>Description</h3>

<p>The <code>struct.in.new.ref</code> function allows you to change the
frame of reference of a struct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.in.new.ref(struct, new.ref.pseudo, T.MAT, alias = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.in.new.ref_+3A_struct">struct</code></td>
<td>
<p>&quot;struct&quot; class object.</p>
</td></tr>
<tr><td><code id="struct.in.new.ref_+3A_new.ref.pseudo">new.ref.pseudo</code></td>
<td>
<p>pseudonym of the frame of reference in which the struct
should be located. This <code>new.ref.pseudo</code> must exist in the <code>T.MAT</code> list.</p>
</td></tr>
<tr><td><code id="struct.in.new.ref_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.T.MAT">load.T.MAT</a> or <a href="#topic+ref.add">ref.add</a>.</p>
</td></tr>
<tr><td><code id="struct.in.new.ref_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;struct&quot; class object in the new frame of reference
<code>new.ref.pseudo</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+vol.in.new.ref">vol.in.new.ref</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for better result)
step &lt;- 4
patient &lt;- toy.load.patient (modality = c("mr", "rtstruct"), roi.name = "", 
                             dxyz = rep (step, 3))
S &lt;- patient$rtstruct[[1]]
S.in.new.ref &lt;- struct.in.new.ref (S, patient$mr[[1]]$ref.pseudo, patient$T.MAT)
</code></pre>

<hr>
<h2 id='struct.merge'>Merging of structures into a new structure</h2><span id='topic+struct.merge'></span>

<h3>Description</h3>

<p>The <code>struct.merge</code> function merges two structures
into a new one. It is useful for comparing contours, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.merge(
  ref.struct,
  add.struct,
  roi.name = NULL,
  roi.sname = NULL,
  roi.idx = NULL,
  suffix = "",
  alias = "",
  description = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.merge_+3A_ref.struct">ref.struct</code></td>
<td>
<p>struct class object. All RoI of this structure are kept.</p>
</td></tr>
<tr><td><code id="struct.merge_+3A_add.struct">add.struct</code></td>
<td>
<p>struct class object. Only the selected RoI are kept for merging.</p>
</td></tr>
<tr><td><code id="struct.merge_+3A_roi.name">roi.name</code></td>
<td>
<p>Vector of exact names of the RoI in the <code>add.struct</code> object.
By default <code>roi.name = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="struct.merge_+3A_roi.sname">roi.sname</code></td>
<td>
<p>Vector of names or parts of names of the RoI in the
<code>add.struct</code> object. By default <code>roi.sname = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="struct.merge_+3A_roi.idx">roi.idx</code></td>
<td>
<p>Vector of indices of the RoI that belong to the <code>add.struct</code>
object. By default <code>roi.idx = NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="struct.merge_+3A_suffix">suffix</code></td>
<td>
<p>Character string. <code>'-suffix'</code> is added to RoI name.</p>
</td></tr>
<tr><td><code id="struct.merge_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the resulted object.</p>
</td></tr>
<tr><td><code id="struct.merge_+3A_description">description</code></td>
<td>
<p>Character string, describing the the resulted object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>roi.name</code>, <code>roi.sname</code>, and <code>roi.idx</code> are all
<code>NULL</code>, then all RoI of add.struct are selected.
</p>


<h3>Value</h3>

<p>Returns a struct class object. See <a href="#topic+espadon.class">espadon.class</a> for
class definitions.
</p>


<h3>Note</h3>

<p>Beware that, when merging structures, some RoI may have same name or
<code>roi.info$roi.pseudo</code>. In this case <code>struct.merge</code> prints a warning
message. Consider changing <code>suffix</code> to avoid the ambiguity.
</p>


<h3>See Also</h3>

<p><a href="#topic+struct.from.bin">struct.from.bin</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c("rtdose"),
                             dxyz = rep (step, 3), beam.nb = 3)
D &lt;- patient$rtdose[[1]]  

# isodose 50% Dmax Gy and 90% Dmax
bin50 &lt;- bin.from.vol (D, min = 0.5 * D$max.pixel)
bin90 &lt;- bin.from.vol (D, min = 0.9 * D$max.pixel)
S.isodose50 &lt;- struct.from.bin (bin50, roi.name = "50pc" , 
                                roi.color = "#00FFFF") 
S.isodose90 &lt;- struct.from.bin (bin90, roi.name = "90pc" , 
                                roi.color = "#FFFF00")
S &lt;- struct.merge (S.isodose50, S.isodose90, alias = "isodose",
                   description = paste ("isodose of", D$object.alias)) 
# Dmax location :
z.dmax &lt;- get.xyz.from.index(which (D$vol3D.data == D$max.pixel), D)[1,3]                 
display.plane(top = D, struct = S, view.coord = z.dmax, legend.shift = -50)                               
</code></pre>

<hr>
<h2 id='study.deployment'>Deployment of DICOM files from multiple patients</h2><span id='topic+study.deployment'></span>

<h3>Description</h3>

<p>The <code>study.deployment</code> function duplicates DICOM data from
multiple patients, so that it becomes data independent of the original data.
This function simplifies the analysis of multi-center or multi-expert studies
in dosimetry challenges, contouring consensus searches, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>study.deployment(
  pats.dir,
  deploy.dir,
  design.matrix = matrix(TRUE, nrow = length(dir(pats.dir)), ncol = 1, dimnames =
    list(basename(dir(pats.dir)), "expert_1")),
  pid.prefix = "",
  white.list = c("instance", "reference"),
  black.list = c("frame of reference", "class"),
  tag.dictionary = dicom.tag.dictionary()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="study.deployment_+3A_pats.dir">pats.dir</code></td>
<td>
<p>Name of the directory in which all patient directories are
stored, each containing the DICOM files to be duplicated.</p>
</td></tr>
<tr><td><code id="study.deployment_+3A_deploy.dir">deploy.dir</code></td>
<td>
<p>Name of the directory where all patient files will be
duplicated.</p>
</td></tr>
<tr><td><code id="study.deployment_+3A_design.matrix">design.matrix</code></td>
<td>
<p>Boolean matrix. See Details.</p>
</td></tr>
<tr><td><code id="study.deployment_+3A_pid.prefix">pid.prefix</code></td>
<td>
<p>string vector of length 1 or string vector of length
<code>ncol(design.matrix)</code>, representing the prefix added to the new
unique identifier of the deployed patient (tag (0010,0020)).</p>
</td></tr>
<tr><td><code id="study.deployment_+3A_white.list">white.list</code></td>
<td>
<p>Names vector, representing a part of the DICOM tag name
UI value representation, other than those defined by the DICOM
standard, which will be modified. By default, the UID name containing 'instance'
or 'reference' will be modified.</p>
</td></tr>
<tr><td><code id="study.deployment_+3A_black.list">black.list</code></td>
<td>
<p>Names vector, representing a part of the DICOM tag name
UI value representation, other than those defined by the DICOM
standard, which will not be modified. By default, the frame of reference UID
will not be modified.</p>
</td></tr>
<tr><td><code id="study.deployment_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to <a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>design.matrix</code> argument defines how patients DICOM files will be deployed.
The names of the lines must match the names of the directories contained in <code>pats.dir</code>.
The names of the columns are for example the different experts or hospitals
who will study the patient files. These experts will only review the patients
files defined by <code>rownames(design.matrix)[design.matrix[,"expert"]]</code>.
</p>


<h3>Value</h3>

<p>Creates the <code>deploy.dir</code> directory, containing the expert
directories defined by the <code>design.matrix</code> column names. Each expert
directory contains as many patient directories as defined by the
<code>design.matrix</code> row names. All patients will be independent of each other.
The new created patients have the pats.dir as name, and expert name as first
name, and an independent patient ID, with prefix <code>pid.prefix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy.dicom.raw () raw data to a temporary file/pats.dir/toy_PM 
# for testing.
toy_PM.dir &lt;- file.path (tempdir(), "pats.dir","toy_PM") 
dir.create (toy_PM.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "toyrtplan", tmpdir = toy_PM.dir,
                          fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)

# function test:
pats.dir &lt;- dirname (toy_PM.dir)
deploy.dir &lt;- file.path (tempdir(), "deploy.dir") 
design.matrix &lt;- matrix(TRUE, nrow = length (dir (pats.dir)), ncol=3,
                        dimnames = list (basename (dir (pats.dir)),
                                         c("Dr Quinn","Dr Who","Dr House")))
design.matrix
study.deployment (pats.dir, deploy.dir, design.matrix, 
                 pid.prefix = c("zz_", "yy_", "xx_"))

# check result
list.files(deploy.dir, recursive = TRUE)
load.patient.from.dicom(deploy.dir)$patient
# Cleaning  temporary directory
unlink (pats.dir, recursive = TRUE)
unlink (deploy.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='toy.dicom.raw'>toy DICOM raw data</h2><span id='topic+toy.dicom.raw'></span>

<h3>Description</h3>

<p>The <code>toy.dicom.raw</code> loads raw data from a dummy DICOM file.
It is used for the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toy.dicom.raw()
</code></pre>


<h3>Value</h3>

<p>Returns the raw data of a dummy DICOM file of rtplan modality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toy.dicom.raw ()
</code></pre>

<hr>
<h2 id='toy.load.patient'>Load a toy patient for test</h2><span id='topic+toy.load.patient'></span>

<h3>Description</h3>

<p>The <code>toy.load.patient</code> creates a dummy &quot;patient&quot; class object.
It is used for the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toy.load.patient(
  modality = c("ct", "mr", "rtdose", "rtstruct"),
  roi.name = c("eye", "optical nerve", "brain", "labyrinth processing unit",
    "energy unit", "gizzard", "ghost container", "exhaust valve"),
  dxyz = c(1, 1, 1),
  beam.nb = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toy.load.patient_+3A_modality">modality</code></td>
<td>
<p>String vector, whose elements are chosen among the modalities
&quot;ct&quot;, &quot;mr&quot;, &quot;rtstruct&quot; and &quot;rtdose&quot;.</p>
</td></tr>
<tr><td><code id="toy.load.patient_+3A_roi.name">roi.name</code></td>
<td>
<p>String vector, whose elements are chosen among the regions of
interest (RoI) &quot;eye&quot;, &quot;optical nerve&quot;, &quot;brain&quot;, &quot;labyrinth processing unit&quot;,
&quot;energy unit&quot;, &quot;gizzard&quot;, &quot;ghost container&quot; and &quot;exhaust valve&quot;. Note that the
RoI &quot;couch&quot;, &quot;patient&quot; and &quot;ptv&quot; are still present.</p>
</td></tr>
<tr><td><code id="toy.load.patient_+3A_dxyz">dxyz</code></td>
<td>
<p>Vector of length 3, representing the x, y, z steps in mm, between
ct, mr and rtdose voxels.</p>
</td></tr>
<tr><td><code id="toy.load.patient_+3A_beam.nb">beam.nb</code></td>
<td>
<p>Positive integer. Number of radiotherapy beams in rtdose modality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an toy object of &quot;patient&quot; class, containing the modalities
defined in <code>modality</code>. See <a href="#topic+espadon.class">espadon.class</a> for class definitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for  better result)
step &lt;- 5
pat &lt;- toy.load.patient (dxyz = rep (step, 3), beam.nb = 2)
str (pat, max.level = 2)
</code></pre>

<hr>
<h2 id='vector.product'>Vector product of two vectors</h2><span id='topic+vector.product'></span>

<h3>Description</h3>

<p>Vector product of two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.product(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector.product_+3A_v1">v1</code></td>
<td>
<p>Vector of x, y, z coordinates</p>
</td></tr>
<tr><td><code id="vector.product_+3A_v2">v2</code></td>
<td>
<p>Vector of x, y, z coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the x, y, z coordinates of the vector product of v1 and v2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vector.product(c (1, 0, 0), c (0, 1, 0))

</code></pre>

<hr>
<h2 id='vol.copy'>Creating a volume from another one</h2><span id='topic+vol.copy'></span>

<h3>Description</h3>

<p>The <code>vol.copy</code> function creates a &quot;volume&quot; class object,
with the same grid as the <code>vol</code> volume object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.copy(vol, alias = "", modality = NULL, description = NULL, number = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.copy_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, template of the created object.</p>
</td></tr>
<tr><td><code id="vol.copy_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$object.alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.copy_+3A_modality">modality</code></td>
<td>
<p>Character string, modality of the created volume. If
<code>modality = NULL</code>, then the created object will have the modality of
<code>vol</code>.</p>
</td></tr>
<tr><td><code id="vol.copy_+3A_description">description</code></td>
<td>
<p>Character string, description of the returned object. If
<code>descritption = NULL</code>, then the created object will have the description
of <code>vol</code>.</p>
</td></tr>
<tr><td><code id="vol.copy_+3A_number">number</code></td>
<td>
<p>number of the returned volume. If <code>number = NULL</code>, then
the returned object will have the number of <code>vol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), with the same grid as <code>vol</code>, in which <code>$vol3D.data</code>
is initialized to <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for  better result)
patient &lt;- toy.load.patient (modality = "ct", roi.name = "",dxyz = c (4, 4, 4))
CT &lt;- patient$ct[[1]]

# creating a volume
vol.from.CT &lt;- vol.copy (CT, alias = "ct reference")
str (vol.from.CT)
</code></pre>

<hr>
<h2 id='vol.create'>Volume creating</h2><span id='topic+vol.create'></span>

<h3>Description</h3>

<p>The <code>vol.create</code> function creates a volume object from a
user-defined grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.create(
  n.ijk,
  dxyz,
  mid.pt = NULL,
  pt000 = NULL,
  default.value = NA,
  ref.pseudo = "ref1",
  frame.of.reference = "",
  alias = "",
  modality = "",
  description = "",
  number = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.create_+3A_n.ijk">n.ijk</code></td>
<td>
<p>Vector of length 3, representing the number of elements on the i,
j and k axes.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_dxyz">dxyz</code></td>
<td>
<p>Vector of length 3, representing the x, y, z steps in mm, between
voxels. See details.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_mid.pt">mid.pt</code></td>
<td>
<p>Vector of length 3, representing the x, y, z coordinates of the
midpoint  of the volume. See details.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_pt000">pt000</code></td>
<td>
<p>Vector of length 3, representing the x, y, z coordinates of the
first voxel of the first plane.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_default.value">default.value</code></td>
<td>
<p>Numerical or boolean value, representing the default
value of the voxels.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_ref.pseudo">ref.pseudo</code></td>
<td>
<p>Character string, frame of reference pseudonym of the
created object.By defaukt equal to &quot;ref1&quot;</p>
</td></tr>
<tr><td><code id="vol.create_+3A_frame.of.reference">frame.of.reference</code></td>
<td>
<p>Character string, frame of reference of the
created object.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_modality">modality</code></td>
<td>
<p>Character string, <code>$modality</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.</p>
</td></tr>
<tr><td><code id="vol.create_+3A_number">number</code></td>
<td>
<p>Integer, by default set to 0, number of the created object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mid.pt</code> and <code>pt000</code> are both equal to <code>NULL</code>,
then <code>mid.pt = c (0, 0, 0)</code> by default.
If <code>mid.pt</code> and <code>pt000</code> are both different from <code>NULL</code>, then
only <code>mid.pt</code> is taken into account.
</p>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), in which the grid is defined by  <code>pt000</code> or
<code>mid.pt</code>, <code>dxyz</code> <code>n.ijk</code>. If <code>default.value</code> are
initialized to <code>FALSE</code>, then <code>modality = "binary"</code>.
The orientation of the patient is orthonormal to the grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new.vol &lt;- vol.create (pt000 = c(1,10,10), dxyz = c (1 , 1, 1),
                       n.ijk = c(100, 100, 100),
                       ref.pseudo = "ref1",
                       frame.of.reference = "toyref1",
                       alias = "new ct", modality = "ct",
                       description = "")
str (new.vol)
</code></pre>

<hr>
<h2 id='vol.from.bin'>Volume class object according to binary selection</h2><span id='topic+vol.from.bin'></span>

<h3>Description</h3>

<p>The <code>vol.from.bin</code> function selects a part of a &quot;volume&quot;
class object of &quot;binary&quot; modality which has the same grid. It is especially
useful to restrict voxel data in region of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.from.bin(vol, sel.bin, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.from.bin_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object, containing data to restrict.</p>
</td></tr>
<tr><td><code id="vol.from.bin_+3A_sel.bin">sel.bin</code></td>
<td>
<p>&quot;volume&quot; class object, of &quot;binary&quot; modality.
<code>vol</code> and <code>sel.bin</code> must have the same grid.</p>
</td></tr>
<tr><td><code id="vol.from.bin_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object</p>
</td></tr>
<tr><td><code id="vol.from.bin_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object.
If <code>description = NULL</code> (default value),
it will be set to <code>paste (vol$object.alias, "from", sel.bin$object.alias)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), in which non-selected voxels have the value <code>NA</code>,
and selected voxels have the original value of <code>vol</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for  better result)
patient &lt;- toy.load.patient (modality = c ("ct", "rtstruct"), 
                             roi.name = "brain", dxyz = c (4, 4, 4))
CT &lt;- patient$ct[[1]]
S &lt;- patient$rtstruct[[1]]

# select the brain in the volume
bin.brain &lt;- bin.from.roi (vol = CT, struct = S, roi.name = "brain",
                           verbose = FALSE)
vol.brain &lt;- vol.from.bin (CT, bin.brain)
# display at the center of gravity of the brain Gz
Gz &lt;- S$roi.info [grep("^brain", S$roi.info$roi.pseudo),]$Gz
display.plane (bottom = vol.brain, view.coord = Gz, struct = S,
               roi.sname = "brain", bg = "#00ff00", interpolate = FALSE)
</code></pre>

<hr>
<h2 id='vol.gradient'>Gradient of a volume</h2><span id='topic+vol.gradient'></span>

<h3>Description</h3>

<p>The <code>vol.gradient</code> function calculates the 3D gradient of a
&quot;volume&quot; class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.gradient(vol, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.gradient_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="vol.gradient_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.gradient_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol$object.alias, "gradient")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), with the same grid and modality
as <code>vol</code>, gradient of <code>vol</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 3
pat &lt;- toy.load.patient (modality = c ("ct"), dxyz = rep (step, 3))
CT.gradient &lt;- vol.gradient (pat$ct[[1]])

display.plane (CT.gradient, view.type = "sagi", view.coord = 61, 
               interpolate = FALSE)
</code></pre>

<hr>
<h2 id='vol.in.new.ref'>Change of frame of reference of a volume</h2><span id='topic+vol.in.new.ref'></span>

<h3>Description</h3>

<p>The <code>vol.in.new.ref</code> function allows you to change the
frame of reference of a volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.in.new.ref(vol, new.ref.pseudo, T.MAT, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.in.new.ref_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="vol.in.new.ref_+3A_new.ref.pseudo">new.ref.pseudo</code></td>
<td>
<p>pseudonym of the frame of reference in which the volume
should be located. This <code>new.ref.pseudo</code> must exist in the <code>T.MAT</code>
list.</p>
</td></tr>
<tr><td><code id="vol.in.new.ref_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.T.MAT">load.T.MAT</a> or <a href="#topic+ref.add">ref.add</a>.</p>
</td></tr>
<tr><td><code id="vol.in.new.ref_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.in.new.ref_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be that of the <code>vol</code> volume.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;volume&quot; class object in the new frame of reference
<code>new.ref.pseudo</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+struct.in.new.ref">struct.in.new.ref</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz for  better result)
patient &lt;- toy.load.patient (modality = c("ct", "mr"), roi.name = "", 
                             dxyz = c (4, 4, 4))
CT &lt;- patient$ct[[1]]
CT.in.new.ref &lt;- vol.in.new.ref (CT, patient$mr[[1]]$ref.pseudo, patient$T.MAT)
</code></pre>

<hr>
<h2 id='vol.median'>Median filter on a volume</h2><span id='topic+vol.median'></span>

<h3>Description</h3>

<p>The <code>vol.median</code> function applies a 26-connectivity median
filter on all the voxels of a &quot;volume&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.median(vol, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.median_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="vol.median_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.median_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol$object.alias, "median")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), with the same grid and modality
as <code>vol</code>, in which voxels are filtered by a 26-connectivity median filter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 3
pat &lt;- toy.load.patient (modality = c ("ct"), dxyz = rep (step, 3))
CT.median &lt;- vol.median (pat$ct[[1]])

display.plane (CT.median, view.type = "sagi", view.coord = 61, 
               interpolate = FALSE)
</code></pre>

<hr>
<h2 id='vol.oversampling'>Oversampling a volume</h2><span id='topic+vol.oversampling'></span>

<h3>Description</h3>

<p>The <code>vol.oversampling</code> function oversamples the grid of a &quot;volume&quot; class
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.oversampling(
  vol,
  fact.ijk = 2,
  alias = "",
  interpolate = TRUE,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.oversampling_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="vol.oversampling_+3A_fact.ijk">fact.ijk</code></td>
<td>
<p>Strictly positive integer, or a vector of 3 strictly positive integers.</p>
</td></tr>
<tr><td><code id="vol.oversampling_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.oversampling_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, default to <code>TRUE</code>. If <code>interpolate = TRUE</code>, a
trilinear interpolation of the value of the voxels, relative to the values of
adjacent voxels, is performed.</p>
</td></tr>
<tr><td><code id="vol.oversampling_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.
If <code>description = NULL</code>, it will be <code>paste ("oversampling" ,vol$description)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object, in which 3D volume grid is
oversampled: the voxel size is divided by <code>fact.ijk</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+vol.subsampling">vol.subsampling</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vol &lt;- vol.create(n.ijk = c(10,10,1),dxyz = c(2,2,2), ref.pseudo = "ref1", 
                  modality ="test", pt000 = c(0,0,0))
vol$vol3D.data[] &lt;- array(1:prod(vol$n.ijk), dim = vol$n.ijk)
vol$max.pixel &lt;- prod(vol$n.ijk)
vol$min.pixel &lt;- 1
mid &lt;- as.numeric (apply (get.extreme.pt (vol), 1, mean))
 
vol_os &lt;- vol.oversampling (vol, fact.ijk= c(2,2,1))
mid_os &lt;- as.numeric (apply (get.extreme.pt (vol_os), 1, mean))

display.plane(vol,interpolate = FALSE, view.coord = mid[3], 
              abs.rng = c(-5,25), ord.rng = c(-5,25), bg="green")
points (mid[1], mid[2], pch=16, col="red")
display.plane(vol_os,interpolate = FALSE, view.coord = mid_os[3], 
              abs.rng = c(-5,25), ord.rng = c(-5,25), bg="green")
points (mid_os[1], mid_os[2], pch=16, col="red")
</code></pre>

<hr>
<h2 id='vol.regrid'>Transform the grid of a volume class object into the grid of another</h2><span id='topic+vol.regrid'></span>

<h3>Description</h3>

<p>The <code>vol.regrid</code> function transforms the grid of a volume
according to the grid of another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.regrid(
  vol,
  back.vol,
  T.MAT = NULL,
  interpolate = TRUE,
  method = c("NN", "Av"),
  alias = "",
  description = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.regrid_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object to regrid.</p>
</td></tr>
<tr><td><code id="vol.regrid_+3A_back.vol">back.vol</code></td>
<td>
<p>&quot;volume&quot; class object whose grid will be used for regriding.
Its <code>$ref.pseudo</code> must exist in the <code>T.MAT</code> list.</p>
</td></tr>
<tr><td><code id="vol.regrid_+3A_t.mat">T.MAT</code></td>
<td>
<p>&quot;t.mat&quot; class object, created by
<a href="#topic+load.patient.from.dicom">load.patient.from.dicom</a>, <a href="#topic+load.patient.from.Rdcm">load.patient.from.Rdcm</a>,
<a href="#topic+load.T.MAT">load.T.MAT</a> or <a href="#topic+ref.add">ref.add</a>. If <code>T.MAT = NULL</code>,
<code>back.vol$ref.pseudo</code> must be equal to <code>vol$ref.pseudo</code>.</p>
</td></tr>
<tr><td><code id="vol.regrid_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vol.regrid_+3A_method">method</code></td>
<td>
<p>method of interpolation, defaulted to 'NN' ie 'Nearest Neighbor'. See Details.</p>
</td></tr>
<tr><td><code id="vol.regrid_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.regrid_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.
If <code>description = NULL</code>, it will be that of <code>vol</code>.</p>
</td></tr>
<tr><td><code id="vol.regrid_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. if <code>TRUE</code> (default) a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interpolation method is chosen from:
</p>

<ul>
<li> <p><code>'NN'</code>: the value of a voxel is calculated from its nearest adajcent neighbors.
</p>
</li>
<li> <p><code>'Av'</code>: the value of a voxel is the weighted average of
the voxels contained in a box, whose sides are automatically calculated from
the <code>back.bol$dxyz</code> steps.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a copy of <code>vol</code>, in which grid is that of <code>back.vol</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 5
patient &lt;- toy.load.patient (modality = c ("mr", "rtdose"), 
                             dxyz = rep (step, 3), beam.nb = 4)
MR &lt;- patient$mr[[1]]
D &lt;- patient$rtdose[[1]]

# change grid
D.on.MR &lt;- vol.regrid (vol = D, back.vol = MR, interpolate = TRUE,
                       T.MAT = patient$T.MAT, alias = "",
                       description = NULL, verbose = FALSE)

# maximum dose location
max.dose.in.MR &lt;- get.xyz.from.index (which.max (D.on.MR$vol3D.data), D.on.MR)
display.plane (bottom = MR, view.coord = max.dose.in.MR[3],
               top= D.on.MR, bottom.col = grey.colors(255, start = 0, end = 1),
               bottom.breaks = seq (0, 500, length.out = 256),
               bg = "#00ff00", interpolate = FALSE)
</code></pre>

<hr>
<h2 id='vol.repair'>repairing missing planes of volumes</h2><span id='topic+vol.repair'></span>

<h3>Description</h3>

<p>The <code>vol.repair</code> function repairs missing planes in volumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.repair(vol, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.repair_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="vol.repair_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.repair_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol$object.alias, "repair")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing planes at download can generate errors or unpredictible results
in espadon processing. The <code>vol.repair</code> function detects such missing
planes and recreates their value by interpolation.
</p>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), with no missing plane, if <code>vol</code> is to be repaired.
Returns <code>vol</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>step &lt;- 4
patient &lt;- toy.load.patient (modality = c("ct", "mr", "rtstruct", "rtdose"),
                             roi.name  = "",
                             dxyz = rep (step, 3), beam.nb = 3)
CT &lt;- patient$ct[[1]]

# this function removes a plane in a volume in order to simulate
# a dicom transfer issue
remove.plane &lt;- function (vol, k) {
  idx &lt;- which (vol$k.idx == k)
  vol$n.ijk[3] &lt;- vol$n.ijk[3] - 1
  vol$xyz0 &lt;- vol$xyz0[-idx, ]
  vol$k.idx &lt;- vol$k.idx[-idx]
  vol$missing.k.idx &lt;- TRUE
  vol$vol3D.data &lt;- vol$vol3D.data[, , -idx]
  return (vol)
}

# Creation of CT.damaged without the 29th slice.
CT.damaged&lt;- remove.plane (CT, 29)
CT.fix &lt;- vol.repair (CT.damaged)

# Display 
par (mfrow=c(3, 3))
for (k in 28:30) {
display.kplane (CT, k, main = paste("CT @ k =",k),interpolate = FALSE)
display.kplane (CT.damaged, k, main = "damaged CT",interpolate = FALSE)
display.kplane (CT.fix, k, main = "fixed CT", interpolate = FALSE)
}
</code></pre>

<hr>
<h2 id='vol.subsampling'>Subsampling a volume</h2><span id='topic+vol.subsampling'></span>

<h3>Description</h3>

<p>The <code>vol.subsampling</code> function sub-samples the grid of a &quot;volume&quot; class
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.subsampling(
  vol,
  fact.ijk = 2,
  interpolate = TRUE,
  method = c("NN", "Av"),
  alias = "",
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.subsampling_+3A_vol">vol</code></td>
<td>
<p>&quot;volume&quot; class object.</p>
</td></tr>
<tr><td><code id="vol.subsampling_+3A_fact.ijk">fact.ijk</code></td>
<td>
<p>Strictly positive integer, or a vector of 3 strictly positive integers.</p>
</td></tr>
<tr><td><code id="vol.subsampling_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean, default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vol.subsampling_+3A_method">method</code></td>
<td>
<p>method of interpolation, defaulted to 'NN' ie 'Nearest Neighbor'. See Details.</p>
</td></tr>
<tr><td><code id="vol.subsampling_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.subsampling_+3A_description">description</code></td>
<td>
<p>Character string, describing the the created object.
If <code>description = NULL</code>, it will be <code>paste ("subsampling" ,vol$description)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interpolation method is chosen from:
</p>

<ul>
<li> <p><code>'NN'</code>: the value of a voxel is calculated from its nearest adajcent neighbors.
</p>
</li>
<li> <p><code>'Av'</code>: the value of a voxel is the weighted average of
the voxels contained in a box, whose sides are automatically calculated from
the <code>back.bol$dxyz</code> steps.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object, in which 3D volume grid is
subsampled: the voxel size is multiplied by <code>fact.ijk</code> and the center location
of the volume is invariant.
</p>


<h3>See Also</h3>

<p><a href="#topic+vol.oversampling">vol.oversampling</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vol &lt;- vol.create(n.ijk = c(10,10,1),dxyz = c(2,2,2), ref.pseudo = "ref1", 
                  modality ="test", pt000 = c(0,0,0))
vol$vol3D.data[] &lt;- array(1:prod(vol$n.ijk), dim = vol$n.ijk)
vol$max.pixel &lt;- prod(vol$n.ijk)
vol$min.pixel &lt;- 1
mid &lt;- as.numeric (apply (get.extreme.pt (vol), 1, mean))
vol_ss &lt;- vol.subsampling (vol, fact.ijk= 2)
mid_ss &lt;- as.numeric (apply (get.extreme.pt (vol_ss), 1, mean))
display.plane(vol,interpolate = FALSE, view.coord = mid[3], 
              abs.rng = c(-5,25), ord.rng = c(-5,25), bg="green")
points (mid[1], mid[2], pch=16, col="red")
display.plane(vol_ss,interpolate = FALSE, view.coord = mid_ss[3], 
              abs.rng = c(-5,25), ord.rng = c(-5,25), bg="green")
points (mid_ss[1], mid_ss[2], pch=16, col="red")
</code></pre>

<hr>
<h2 id='vol.sum'>Sum of 2 volumes</h2><span id='topic+vol.sum'></span>

<h3>Description</h3>

<p>The <code>vol.sum</code> function adds two &quot;volume&quot; class objects
of the same grid and of the same modality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.sum(vol1, vol2, alias = "", description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.sum_+3A_vol1">vol1</code>, <code id="vol.sum_+3A_vol2">vol2</code></td>
<td>
<p>&quot;volume&quot; class objects. The
2 volumes must have the same modality, and the same grid (i.e. share the same
position of the voxels).</p>
</td></tr>
<tr><td><code id="vol.sum_+3A_alias">alias</code></td>
<td>
<p>Character string, <code>$alias</code> of the created object.</p>
</td></tr>
<tr><td><code id="vol.sum_+3A_description">description</code></td>
<td>
<p>Character string, describing the created object. If
<code>description = NULL</code> (default value), it will be set to
<code>paste (vol1$object.alias, "+", vol2$object.alias)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a &quot;volume&quot; class object (see <a href="#topic+espadon.class">espadon.class</a>
for class definitions), with the same grid and modality
as <code>vol1</code> and <code>vol2</code>, sum of <code>vol1</code> and <code>vol2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading of toy-patient objects (decrease dxyz and increase beam.nb for 
# better result)
step &lt;- 5
pat&lt;- toy.load.patient (modality = c ( "rtdose"), dxyz = rep (step, 3),
                        beam.nb = 3)

# Double dose
D &lt;- vol.sum (pat$rtdose[[1]], pat$rtdose[[1]])
pat$rtdose[[1]]$max.pixel
D$max.pixel
</code></pre>

<hr>
<h2 id='xlsx.from.dcm'>Converting DICOM files to .xlsx files</h2><span id='topic+xlsx.from.dcm'></span>

<h3>Description</h3>

<p>The <code>xlsx.from.dcm</code> function creates an Excel file from
DICOM files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx.from.dcm(
  dcm.filenames,
  xlsx.filenames,
  multipage = TRUE,
  txt.sep = "\\",
  txt.length = 100,
  tag.dictionary = dicom.tag.dictionary()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx.from.dcm_+3A_dcm.filenames">dcm.filenames</code></td>
<td>
<p>String vector, representing the list of full names of
DICOM files.</p>
</td></tr>
<tr><td><code id="xlsx.from.dcm_+3A_xlsx.filenames">xlsx.filenames</code></td>
<td>
<p>String vector, representing the list of full names of
created *.xlsx files. If <code>multipage = TRUE</code>, only the <code>xlsx.filenames[1]</code>
is used.</p>
</td></tr>
<tr><td><code id="xlsx.from.dcm_+3A_multipage">multipage</code></td>
<td>
<p>Boolean. If TRUE, all <code>dcm.filenames</code> are converted into
multiple pages of the same *.xlsx file.</p>
</td></tr>
<tr><td><code id="xlsx.from.dcm_+3A_txt.sep">txt.sep</code></td>
<td>
<p>String. Used if <code>as.txt = TRUE</code>. Separator of the tag value elements.</p>
</td></tr>
<tr><td><code id="xlsx.from.dcm_+3A_txt.length">txt.length</code></td>
<td>
<p>Positive integer. Used if <code>as.txt = TRUE</code>. Maximum number
of letters in the representation of the TAG value.</p>
</td></tr>
<tr><td><code id="xlsx.from.dcm_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to <a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a boolean vector, establishing the existence of the created
Excel files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, save toy.dicom.raw () raw data to a temporary file pat.dir for testing.
pat.dir &lt;- file.path (tempdir(), "PM_dcm") 
dir.create (pat.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "PMrtplan", tmpdir = pat.dir, fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)
list.files (pat.dir)

# Creating an Excel file
xlsx.fnames &lt;- file.path (pat.dir, 
                          paste (basename (dcm.filename),"xlsx", sep = "."))
xlsx.from.dcm (dcm.filename, xlsx.fnames)
list.files (pat.dir)

# Cleaning temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='xlsx.from.Rdcm'>Converting .Rdcm files to .xlsx files</h2><span id='topic+xlsx.from.Rdcm'></span>

<h3>Description</h3>

<p>A *.Rdcm file contains the list of contents, in dataframe form,
of the DICOM files of the same object.
The <code>xlsx.from.Rdcm</code> function creates, from a *.Rdcm file, an Excel file,
in which each page contains the dataframe representation of a DICOM file of
the same object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx.from.Rdcm(
  Rdcm.filenames,
  dest.dirname = dirname(Rdcm.filenames),
  txt.sep = "\\",
  txt.length = 100,
  tag.dictionary = dicom.tag.dictionary()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx.from.Rdcm_+3A_rdcm.filenames">Rdcm.filenames</code></td>
<td>
<p>String vector, representing the *.Rdcm filenames to be
converted.</p>
</td></tr>
<tr><td><code id="xlsx.from.Rdcm_+3A_dest.dirname">dest.dirname</code></td>
<td>
<p>String vector of the same length as <code>Rdcm.filenames</code>,
indicating the directory where the *.xlsx files will be created.</p>
</td></tr>
<tr><td><code id="xlsx.from.Rdcm_+3A_txt.sep">txt.sep</code></td>
<td>
<p>String. Used if <code>as.txt = TRUE</code>. Separator of the tag value elements.</p>
</td></tr>
<tr><td><code id="xlsx.from.Rdcm_+3A_txt.length">txt.length</code></td>
<td>
<p>Positive integer. Used if <code>as.txt = TRUE</code>. Maximum number
of letters in the representation of the TAG value.</p>
</td></tr>
<tr><td><code id="xlsx.from.Rdcm_+3A_tag.dictionary">tag.dictionary</code></td>
<td>
<p>Dataframe, by default equal to <a href="#topic+dicom.tag.dictionary">dicom.tag.dictionary</a>,
whose structure it must keep. This dataframe is used to parse DICOM files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a boolean vector, establishing the existence of the
created Excel files which have the same basenames as the *.Rdcm files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, create a Rdcm file from toy.dicom.raw () to a temporary file for testing.
pat.dir &lt;- file.path (tempdir(), "PM_Rdcm") 
dir.create (pat.dir, recursive = TRUE) 
dcm.filename &lt;- tempfile (pattern = "PM_rtplan", tmpdir = pat.dir, fileext = ".dcm")
zz &lt;- file (dcm.filename, "wb")
writeBin (toy.dicom.raw (), zz, size = 1)
close (zz)
dicom.to.Rdcm.converter (dcm.filename, pat.dir, update = TRUE)
file.remove (dcm.filename)
list.files (pat.dir)

# Creating an Excel file
Rdcm.filenames &lt;- list.files (pat.dir, pattern = "[.]Rdcm$",
                              recursive = TRUE, full.names = TRUE)
xlsx.from.Rdcm (Rdcm.filenames)
list.files (pat.dir)

# Cleaning temporary directory
unlink (pat.dir, recursive = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
