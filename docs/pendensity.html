<!DOCTYPE html><html lang="en"><head><title>Help for package pendensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pendensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pendensity-package'>
<p>The package 'pendensity' offers routines for estimating penalized unconditional and conditional (on factor groups) densities.</p></a></li>
<li><a href='#Allianz'><p>Daily final prices (DAX) of the German stock Allianz in the years 2006 and 2007</p></a></li>
<li><a href='#bias.par'><p>Calculating the bias of the parameter beta</p></a></li>
<li><a href='#ck'><p>Calculating the actual weights ck</p></a></li>
<li><a href='#D.m'><p>Calculating the penalty matrix</p></a></li>
<li><a href='#Derv1'><p>Calculating the first derivative of the pendensity likelihood function w.r.t. parameter beta</p></a></li>
<li><a href='#Derv2'><p>Calculating the second order derivative with and without penalty</p></a></li>
<li><a href='#DeutscheBank'><p>Daily final prices (DAX) of the German stock Deutsche Bank in the years 2006 and 2007</p></a></li>
<li><a href='#distr.func'><p>These functions are used for calculating the empirical and theoretical distribution functions.</p></a></li>
<li><a href='#dpendensity'><p>Calculating the fitted density or distribution</p></a></li>
<li><a href='#f.hat'><p>Calculating the actual fitted values 'f.hat' of the estimated density function f for the response y</p></a></li>
<li><a href='#L.mat'><p>Calculates the difference matrix of order m</p></a></li>
<li><a href='#marg.likelihood'><p>Calculating the marginal likelihood</p></a></li>
<li><a href='#my.AIC'><p>Calculating the AIC value</p></a></li>
<li><a href='#my.bspline'><p>my.bspline</p></a></li>
<li><a href='#my.positive.definite.solve'><p>my.positive.definite.solve</p></a></li>
<li><a href='#new.beta.val'><p>Calculating the new parameter beta</p></a></li>
<li><a href='#new.lambda'><p>Calculating new penalty parameter lambda</p></a></li>
<li><a href='#pen.log.like'><p>Calculating the log likelihood</p></a></li>
<li><a href='#pendenForm'><p>Formula interpretation and data transfer</p></a></li>
<li><a href='#pendensity'><p>Calculating penalized density</p></a></li>
<li><a href='#plot.pendensity'><p>Plotting estimated penalized densities</p></a></li>
<li><a href='#print.pendensity'><p>Printing the main results of the (conditional) penalized density estimation</p></a></li>
<li><a href='#test.equal'><p>Testing pairwise equality of densities</p></a></li>
<li><a href='#variance.par'><p>Calculating the variance of the parameters</p></a></li>
<li><a href='#variance.val'><p>Calculating variance and standard deviance of each observation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Density Estimation with a Penalized Mixture Approach</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-07</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1), lattice, fda</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Schellhase</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Schellhase &lt;christian.schellhase@gmx.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of univariate (conditional) densities using penalized B-splines with automatic selection of optimal smoothing parameter.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-07 21:11:37 UTC; christian</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-07 22:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='pendensity-package'>
The package 'pendensity' offers routines for estimating penalized unconditional and conditional (on factor groups) densities.
</h2><span id='topic+pendensity-package'></span>

<h3>Description</h3>

<p>The package 'pendensity' offers routines for estimating penalized
unconditional and conditional (on factor groups) densities. For details
see the description of the function pendensity.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pendensity</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2.12</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-04-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: GPL (&gt;= 2)
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The packages contributes the function 'pendensity()' for estimating densities using penalized splines techniques. 
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;christian.schellhase@gmx.net&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(100)
test &lt;- pendensity(y~1)
plot(test)

#################

#second simple example
#with covariate

x &lt;- rep(c(0,1),200)
y &lt;- rnorm(400,x*0.2,1)
test &lt;- pendensity(y~as.factor(x),lambda0=2e+07)
plot(test)

#################

#calculate the value at some (maybe not observed) value yi=c(0,1) of the estimated density

plot(test,val=c(0,1))

#################

#density-example of the stock exchange Allianz in 2006

data(Allianz)
time.Allianz &lt;- strptime(Allianz[,1],form="%d.%m.%y")

#looking for all dates in 2006
data.Allianz &lt;- Allianz[which(time.Allianz$year==106),2]

#building differences of first order
d.Allianz &lt;- diff(data.Allianz)

#estimating the density, choosing a special start value for lambda
density.Allianz &lt;- pendensity(d.Allianz~1,lambda0=90000)
plot(density.Allianz)

</code></pre>

<hr>
<h2 id='Allianz'>Daily final prices (DAX) of the German stock Allianz in the years 2006 and 2007</h2><span id='topic+Allianz'></span>

<h3>Description</h3>

<p>Containing the daily final prices of the German stock Allianz in the years 2006 and 2007.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Allianz)</code></pre>


<h3>Format</h3>

<p>A data frame with 507 observations of the following 2 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>Date</p>
</dd>
<dt><code>ClosingPrice</code></dt><dd><p>ClosingPrice</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(Allianz)

form&lt;-'%d.%m.%y'

time.Allianz &lt;- strptime(Allianz[,1],form)

#looking for all dates in 2006
data.Allianz &lt;- Allianz[which(time.Allianz$year==106),2]

#building differences of first order
d.Allianz &lt;- diff(data.Allianz)

#estimating the density
density.Allianz &lt;- pendensity(d.Allianz~1,)
plot(density.Allianz)
</code></pre>

<hr>
<h2 id='bias.par'>Calculating the bias of the parameter beta</h2><span id='topic+bias.par'></span>

<h3>Description</h3>

<p>Calculating the bias of the parameter beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bias.par(penden.env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bias.par_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bias of the parameter beta is calculated as the product of the penalty parameter lambda, the penalized second order derivative of the log likelihood function w.r.t. beta 'Derv.pen', the penalty matrix 'Dm' and the parameter set 'beta'.
</p>
<p style="text-align: center;"><code class="reqn">Bias(\beta)= - \lambda  {Derv2.pen(\beta)}^{-1} D_m \beta</code>
</p>

<p>The needed values are saved in the environment.
</p>


<h3>Value</h3>

<p>Returning the bias of the parameter beta.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='ck'>Calculating the actual weights ck</h2><span id='topic+ck'></span>

<h3>Description</h3>

<p>Calculating the actual weights ck for each factor combination of the covariates combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck(penden.env, beta.val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ck_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="ck_+3A_beta.val">beta.val</code></td>
<td>
<p>actual parameter beta</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weights in depending of the covariate 'x' are calculated as follows.
</p>
<p><code class="reqn"> c_k(x,\beta)=\frac{\exp(Z(x)\beta_k)}{\sum_{j=-K}^{K}\exp(Z(x)\beta_j)}</code>
</p>
<p>For estimations without covariates, Z doesn't appear in calculations.
</p>
<p><code class="reqn">c_k(\beta)=\frac{\exp(\beta_k)}{\sum_{k=-K}^{K}\exp(\beta_k)}</code>
</p>
<p>Starting density calculation, the groupings of the covariates are
indexed in the main program. The groupings are saved in 'x.factor', the index which response
belongs to which group is saved in 'Z.index'. Therefore, one can link to
the rows in 'x.factor' to calculate the weights 'ck'. 
</p>
<p>The needed values are saved in the environment.
</p>


<h3>Value</h3>

<p>Returning the actual weights ck, depending on the actual parameter beta in a matrix with rows.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='D.m'>Calculating the penalty matrix</h2><span id='topic+D.m'></span>

<h3>Description</h3>

<p>calculating the penalty matrix depending on the number of covariates 'p', the order of differences to be penalized 'm', the corresponding difference matrix 'L' of order 'm', the covariate matrix 'Z', the number of observations 'n' and the number of knots 'K'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.m(penden.env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D.m_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The penalty matrix is calculated as
</p>
<p><code class="reqn">D_m=(L^T \otimes I_p) (I_{K-m} \otimes \frac{Z^T Z}{n}) (L \otimes I_p)</code>
</p>
<p>The needed values are saved in the environment.
</p>


<h3>Value</h3>

<p>Returning the penalty matrix.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='Derv1'>Calculating the first derivative of the pendensity likelihood function w.r.t. parameter beta</h2><span id='topic+Derv1'></span>

<h3>Description</h3>

<p>Calculating the first derivative of the pendensity likelihood function w.r.t. parameter beta. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Derv1(penden.env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Derv1_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We calculate the first derivative of the pendensity likelihood function w.r.t. the parameter beta. The calculation of the first derivative of the pendensity likelihood function w.r.t. parameter beta is done in four steps. The first derivative equals in the case of covariates
</p>
<p style="text-align: center;"><code class="reqn">s(\beta)= {\partial l(\beta)}/{\partial \beta}= \sum_{i=1}^n s_i(\beta)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">s_i(\beta) = {{\bf \mathcal{Z}}^T(x_i)} {{\bf \mathcal{C}}^T (x_i,\beta)} \frac{\tilde{\boldsymbol\phi}_i}{\hat{f}(y_i|x_i)}</code>
</p>
<p><br />
Without covariates, the matrix 'Z' doesn't appear. Starting density calculation, the groupings of the covariates are indexed in the main program. The groupings are saved in 'x.factor'. Creating an index that reports which response belongs to which covariate group, saving in 'Z.index'. Therefore, one can link to the rows in the object 'ck' to calculate the matrix 'C.bold', which depends only on the grouping of the covariate. Without any covariate, 'C.bold' is equal for every observation.<br />
The calculation of the first derivative of the pendensity likelihood function w.r.t. parameter beta is done in four steps. Firstly, we calculate the matrix 'C.bold', depending on the groups of 'x.factor'.<br />
Secondly, for calculating we need the fitted values of each observation, 'f.hat'. These values are calculated for the actual parameter set beta in the program 'f.hat'. Of course, we need the value of the base for each observation, <code class="reqn">\phi[i]</code>.<br />
Moreover, for the case of conditional density estimation, we need a Z-Matrix, due to the rules for derivations of the function 'exp()'. This Z-matrix doesn't appear directly in the calculations. We construct the multiplication with this Z-matrix with using an outer product between the corresponding grouping in 'x.factor' and the product of the corresponding values 'C.bold' and 'base.den', divided by the fitted value 'f.hat'. Finally, we add some penalty on the derivative, which is calculated in the fourth step. The penalty equals <code class="reqn">-\lambda D_m \beta </code>.<br />
For later use, we save the unpenalized first derivative as a matrix, in which the i-th column contains the first derivative of the pendensity likelihood function, evaluated for the i-th value of the response. The needed values are saved in the environment.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Derv1.cal</code></td>
<td>
<p>matrix, in which the i-th column contains the first derivative, evaluated for the i-th value of the response variable without penalty. Needed for calculating the second order derivative, called <code class="reqn">s(\beta)</code></p>
</td></tr>
<tr><td><code>Derv1.pen</code></td>
<td>
<p>first order derivation of the penalized likelihood function w.r.t. parameter beta, called </p>
<p style="text-align: center;"><code class="reqn">s_p(\beta)</code>
</p>
 </td></tr>
<tr><td><code>f.hat.val</code></td>
<td>
<p>fitted values of the response for actual parameter beta, called <code class="reqn">\hat{f}</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='Derv2'>Calculating the second order derivative with and without penalty</h2><span id='topic+Derv2'></span>

<h3>Description</h3>

<p>Calculating the second order derivative of the likelihood function of the pendensity approach w.r.t. the parameter beta. Thereby, for later use, the program returns the second order derivative with and without the penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Derv2(penden.env, lambda0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Derv2_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="Derv2_+3A_lambda0">lambda0</code></td>
<td>
<p>smoothing parameter lambda</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We approximate the second order derivative in this approach with the negative fisher information. 
</p>
<p style="text-align: center;"><code class="reqn">J(\beta)= -  \frac{\partial^2 l(\beta)}{\partial \beta \ \partial \beta^T} \approx \sum_{i=1}^n s_i(\beta) s_i^T(\beta) .</code>
</p>

<p>Therefore we construct the second order derivative of the i-th observation w.r.t. beta with the outer product of the matrix Derv1.cal and the i-th row of the matrix Derv1.cal.<br />
The penalty is computed as </p>
<p style="text-align: center;"><code class="reqn">\lambda D_m</code>
</p>
<p>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Derv2.pen</code></td>
<td>
<p>second order derivative w.r.t. beta with penalty</p>
</td></tr>
<tr><td><code>Derv2.cal</code></td>
<td>
<p>second order derivative w.r.t. beta without penalty. Needed for calculating of e.g. AIC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='DeutscheBank'>Daily final prices (DAX) of the German stock Deutsche Bank in the years 2006 and 2007</h2><span id='topic+DeutscheBank'></span>

<h3>Description</h3>

<p>Containing the daily final prices of the German stock Deutsche Bank in the years 2006 and 2007.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DeutscheBank)</code></pre>


<h3>Format</h3>

<p>A data frame with 507 observations of the following 2 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>Date</p>
</dd>
<dt><code>ClosingPrice</code></dt><dd><p>ClosingPrice</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(DeutscheBank)

form&lt;-'%d.%m.%y'

time.DeutscheBank &lt;- strptime(DeutscheBank[,1],form)

#looking for all dates in 2006
data.DeutscheBank &lt;- DeutscheBank[which(time.DeutscheBank$year==106),2]

#building differences of first order
d.DeutscheBank &lt;- diff(data.DeutscheBank)

#estimating the density
density.DeutscheBank &lt;- pendensity(d.DeutscheBank~1)
plot(density.DeutscheBank)
</code></pre>

<hr>
<h2 id='distr.func'>These functions are used for calculating the empirical and theoretical distribution functions.</h2><span id='topic+distr.func'></span><span id='topic+distr.func.help'></span><span id='topic+cal.int'></span><span id='topic+poly.part'></span>

<h3>Description</h3>

<p>These functions cooperate with each other for calculating the distribution functions. 'distr.func' is the main program, calling 'distr.func.help',generating an environment with needed values for calculating the distribution of each interval between two neighbouring knots. 'distr.func' returns analytical functions of the distribution of each interval between two neighbouring knots. Therefore the function 'poly.part' is needed to construct these functions. 'cal.int' evaluates these integrals, considering if the whole interval should be evaluated or if any discrete value 'yi' is of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.func(yi = NULL, obj, help.env=distr.func.help(obj))
distr.func.help(obj)
cal.int(len.b, q, help.env, knots.val)
poly.part(i,j,knots.val,help.env,q, yi=NULL, poly=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distr.func_+3A_yi">yi</code></td>
<td>
<p>if the distribution at any discrete point is of interest, you can call for it. Default=NULL doesn't consider any discrete point </p>
</td></tr>
<tr><td><code id="distr.func_+3A_obj">obj</code></td>
<td>
<p>a object of class pendensity</p>
</td></tr>
<tr><td><code id="distr.func_+3A_help.env">help.env</code></td>
<td>
<p>object is generated with calling distr.func.help(obj)</p>
</td></tr>
<tr><td><code id="distr.func_+3A_len.b">len.b</code></td>
<td>
<p>length of B-Spline</p>
</td></tr>
<tr><td><code id="distr.func_+3A_q">q</code></td>
<td>
<p>order of the B-Spline</p>
</td></tr>
<tr><td><code id="distr.func_+3A_knots.val">knots.val</code></td>
<td>
<p>values of the used knots</p>
</td></tr>
<tr><td><code id="distr.func_+3A_poly">poly</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="distr.func_+3A_i">i</code></td>
<td>
<p>internal values for calculating the polynomials of each B-Spline</p>
</td></tr>
<tr><td><code id="distr.func_+3A_j">j</code></td>
<td>
<p>internal values for calculating the polynomials of each B-Spline</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>distr.func</code></td>
<td>
<p>returns analytical functions of the distributions between each two neighbouring intervals</p>
</td></tr>
<tr><td><code>distr.func.help</code></td>
<td>
<p>creating environment 'help.env', creating help points between each two neighbouring knots and calculates the polynomial-coefficients of each base part</p>
</td></tr>
<tr><td><code>cal.int</code></td>
<td>
<p>evaluating the result of distr.func. Thereby it's possible to call for an explicit distribution values F(yi)</p>
</td></tr>
<tr><td><code>poly.part</code></td>
<td>
<p>using in 'distr.func' for creating the polynomial functions of each interval of each two neighbouring knots</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='dpendensity'>Calculating the fitted density or distribution</h2><span id='topic+dpendensity'></span><span id='topic+ppendensity'></span>

<h3>Description</h3>

<p>Calculating the fitted density or distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpendensity(x,val)
ppendensity(x,val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpendensity_+3A_x">x</code></td>
<td>
<p>Object of class pendensity</p>
</td></tr>
<tr><td><code id="dpendensity_+3A_val">val</code></td>
<td>
<p>Vector of values where to calculate the density</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='f.hat'>Calculating the actual fitted values 'f.hat' of the estimated density function f for the response y</h2><span id='topic+f.hat'></span>

<h3>Description</h3>

<p>Calculating the actual fitted values of the response, depending on the actual parameter set beta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.hat(penden.env,ck.temp=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f.hat_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="f.hat_+3A_ck.temp">ck.temp</code></td>
<td>
<p>actual weights, depending on the actual parameter set beta. If NULL, the beta parameter is caught in th environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculating the actual fitted values of the response, depending on the actual parameter set beta. Multiplying the actual set of parameters <code class="reqn">c_k</code> with the base 'base.den' delivers the fitted values, depending on the group of covariates, listed in 'x.factor'.
</p>


<h3>Value</h3>

<p>The returned value is a vector of the fitted value for each observation of y.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='L.mat'>Calculates the difference matrix of order m</h2><span id='topic+L.mat'></span>

<h3>Description</h3>

<p>Calculating the differences matrix 'L' of order 'm', depending on the number of knots 'k'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L.mat(penden.env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L.mat_+3A_penden.env">penden.env</code></td>
<td>
<p>Environment of pendensity()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the difference matrix of order 'm' for given number of knots 'K'.
</p>
<p>The needed values are saved in the environment.
</p>


<h3>Note</h3>

<p>Right now, the difference matrix is implemented for m=1,2,3,4.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='marg.likelihood'>Calculating the marginal likelihood</h2><span id='topic+marg.likelihood'></span>

<h3>Description</h3>

<p>Calculating the marginal likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg.likelihood(penden.env,pen.likelihood)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marg.likelihood_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="marg.likelihood_+3A_pen.likelihood">pen.likelihood</code></td>
<td>
<p>penalized log likelihood</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculating is done using a Laplace approximation for the integral of the marginal likelihood.
</p>
<p>The needed values are saved in the environment.
</p>


<h3>Value</h3>

<p>Returning the marginal likelihood.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='my.AIC'>Calculating the AIC value</h2><span id='topic+my.AIC'></span>

<h3>Description</h3>

<p>Calculating the AIC value of the density estimation. Therefore, we add the unpenalized log likelihood of the estimation and the degree of freedom, which are 	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.AIC(penden.env, lambda0, opt.Likelihood = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my.AIC_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="my.AIC_+3A_lambda0">lambda0</code></td>
<td>
<p>penalty parameter lambda</p>
</td></tr>
<tr><td><code id="my.AIC_+3A_opt.likelihood">opt.Likelihood</code></td>
<td>
<p>optimal unpenalized likelihood of the density estimation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AIC is calculated as
<code class="reqn">AIC(\lambda)= - l(\hat{\beta}) + df(\lambda)</code>
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>myAIC</code></td>
<td>
<p>sum of the negative unpenalized log likelihood and mytrace</p>
</td></tr>
<tr><td><code>mytrace</code></td>
<td>
<p>calculated mytrace as the sum of the diagonal matrix df, which results as the product of the inverse of the penalized second order derivative of the log likelihood with the unpenalized second order derivative of the log likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='my.bspline'>my.bspline</h2><span id='topic+my.bspline'></span>

<h3>Description</h3>

<p>Integrates the normal B-Spline Base to a value of one. The dimension of the base depends on the input of number of knots 'k' and of the order of the B-Spline base 'q'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.bspline(h, q, knots.val, y, K, plot.bsp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my.bspline_+3A_h">h</code></td>
<td>
<p>if equidistant knots are just (default in pendensity()), h is the distance between two neighbouring knots</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_q">q</code></td>
<td>
<p>selected order of the B-Spline base</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_knots.val">knots.val</code></td>
<td>
<p>selected values for the knots</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_y">y</code></td>
<td>
<p>values of the response variable y</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_k">K</code></td>
<td>
<p>the number of knots K for the construction of the base</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_plot.bsp">plot.bsp</code></td>
<td>
<p>Indicator variable TRUE/FALSE if the integrated B-Spline base should be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, the function constructs the B-Spline base to the given number of knots 'K' and the given locations of the knots 'knots.val\$val. Due to the recursive construction of the B-Spline, for all orders greater than 2, the dimension of the B-Spline base of given K grows up with help.degree=q-2. Avoiding open B-Splines at the boundary, we simulate 6 extra knots at both ends of the support, saved in knots.val\$all. Therefore, we get normal B-Splines at the given knots 'knots.val\$val'. For these knots, we construct the B-Spline base of order 'q' and for order 'q+1' (using for calculation the distribution). Additionally, we save q-1 knots at both ends of the support of 'knots.val\$val'. After construction, we get a base of dimension K=K+help.degree. So, we define our value K and cut our B-Spline base at both ends to get the adequate base due to the order 'q' and the number of knots 'K'. For the base of order 'q+1', we need to get an additional base, due to the construction of the B-Splines. Due to the fact, that we use equidistant knots, we can integrate our B-Splines very simple to the value of 1. The integration is done by the well-known factor q/(knots.val\$help[i+q]-knots.val\$help[i]). This results the standardization coefficients 'stand.num' for each B-spline (which are identically for equidistant knots). Moreover, one can draw the integrated base and, if one calls this function with the argument 'plot.bsp=TRUE'.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>base.den</code></td>
<td>
<p>The integrated B-Spline base of order q</p>
</td></tr>
<tr><td><code>base.den2</code></td>
<td>
<p>The integrated B-Spline base of order q+1</p>
</td></tr>
<tr><td><code>stand.num</code></td>
<td>
<p>The coefficients for standardization of the ordinary B-Spline base</p>
</td></tr>
<tr><td><code>knots.val</code></td>
<td>
<p>This return is a list. It consider of the used knots 'knots.val\$val', the help knots 'knots.val\$help' and the additional knots 'knots.val\$all', used for the construction of the base and the calculation of the distribution function of each B-Spline.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The transformed value of K, due to used order 'q' and the input of 'K'</p>
</td></tr>
<tr><td><code>help.degree</code></td>
<td>
<p>Due to the recursive construction of the B-Spline, for all orders greater than 2, the dimension of the B-Spline base of given K grows up with 'help.degree=q-2'. This value is returned for later use.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This functions uses the fda-package for the construction of the B-Spline Base.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>

<hr>
<h2 id='my.positive.definite.solve'>my.positive.definite.solve</h2><span id='topic+my.positive.definite.solve'></span>

<h3>Description</h3>

<p>Reverses a quadratic positive definite matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.positive.definite.solve(A, eps = 1e-15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my.positive.definite.solve_+3A_a">A</code></td>
<td>
<p>quadratic positive definite matrix</p>
</td></tr>
<tr><td><code id="my.positive.definite.solve_+3A_eps">eps</code></td>
<td>
<p>level of the lowest eigenvalue to consider</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program makes an eigenvalue decomposition of the positive definite matrix A and searches all eigenvalues greater than eps. The value of return is the inverse matrix of A, constructed with the matrix product of the corresponding eigenvalues and eigenvectors. </p>


<h3>Value</h3>

<p>The return is the inverse matrix of A.</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>

<hr>
<h2 id='new.beta.val'>Calculating the new parameter beta</h2><span id='topic+new.beta.val'></span>

<h3>Description</h3>

<p>Calculating the direction of the Newton-Raphson step for the known beta and iterate a step size bisection to control the maximizing of the penalized likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.beta.val(llold, penden.env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new.beta.val_+3A_llold">llold</code></td>
<td>
<p>log likelihood of the algorithm one step before</p>
</td></tr>
<tr><td><code id="new.beta.val_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We terminate the search for the new beta, when the new log likelihood is smaller than the old likelihood and the step size is smaller or equal 1e-3. We calculate the direction of the Newton Raphson step for the known <code class="reqn">beta_t</code> and iterate a step size bisection to control the maximizing of the penalized likelihood </p>
<p style="text-align: center;"><code class="reqn">l_p(\beta_t,\lambda_0)</code>
</p>
<p>. This means we set </p>
<p style="text-align: center;"><code class="reqn">\beta_{t+1}=\beta_t - 2^{-v} \{s_p(\beta_t,\lambda_0) \cdot (-J_p(\beta_t,\lambda_0))^{-1}\}</code>
</p>
<p> with <code class="reqn">s_p</code> as penalized first order derivative and <code class="reqn">J_p</code> as penalized second order derivative. We begin with <code class="reqn">v=0</code>. Not yielding a new maximum for a current v, we increase v step by step respectively bisect the step size. We terminate the iteration, if the step size is smaller than some reference value epsilon (eps=1e-3) without yielding a new maximum. We iterate for new parameter beta until the new log likelihood depending on the new estimated parameter beta differ less than 0.1 log-likelihood points from the log likelihood estimated before.<br />
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Likelie</code></td>
<td>
<p>corresponding log likelihood</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>used step size</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='new.lambda'>Calculating new penalty parameter lambda</h2><span id='topic+new.lambda'></span>

<h3>Description</h3>

<p>Calculating new penalty parameter lambda. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.lambda(penden.env,lambda0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new.lambda_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="new.lambda_+3A_lambda0">lambda0</code></td>
<td>
<p>actual penalty parameter lambda</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterating for the lambda is stopped, when the changes between the old and the new lambda is smaller than 0.01*lambda0. If this criterion isn't reached, the iteration is terminated after 11 iterations.
</p>
<p>The iteration formulae is
</p>
<p style="text-align: center;"><code class="reqn">\lambda^{-1}=\frac{\hat{\beta}^T D_m \hat{\beta}}{df(\hat{\lambda})-(m-1)}.</code>
</p>



<h3>Value</h3>

<p>Returning the new lambda.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='pen.log.like'>Calculating the log likelihood</h2><span id='topic+pen.log.like'></span>

<h3>Description</h3>

<p>Calculating the considered log likelihood. If one chooses lambda0=0, one gets the (actual) unpenalized log likelihood. Otherwise, one gets the penalized log likelihood for the used fitted values of the response y and the actual parameter set beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.log.like(penden.env,lambda0,f.hat.val=NULL,beta.val=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pen.log.like_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="pen.log.like_+3A_lambda0">lambda0</code></td>
<td>
<p>penalty parameter lambda</p>
</td></tr>
<tr><td><code id="pen.log.like_+3A_f.hat.val">f.hat.val</code></td>
<td>
<p>matrix contains the fitted values of the response, if NULL the matrix is caught in the environment</p>
</td></tr>
<tr><td><code id="pen.log.like_+3A_beta.val">beta.val</code></td>
<td>
<p>actual parameter set beta, if NULL the vector is caught in the environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation depends on the fitted values of the response as well as on the penalty parameter lambda and the penalty matrix Dm.<br />
</p>
<p style="text-align: center;"><code class="reqn">l(\beta)=\sum_{i=1}^{n} \left[ \log \{\sum_{k=-K}^K c_k(x_i,\beta) \boldsymbol\phi_k(y_i)\}  \right]- \frac 12 \lambda \beta^T D_m \beta</code>
</p>
<p>.
</p>
<p>The needed values are saved in the environment.
</p>


<h3>Value</h3>

<p>Returns the log likelihood depending on the penalty parameter lambda.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='pendenForm'>Formula interpretation and data transfer</h2><span id='topic+pendenForm'></span><span id='topic+string.help'></span>

<h3>Description</h3>

<p>Function 'pendenForm' interprets the input 'form' of the function pendensity(),transfers the response and covariates data back to the main program and categorize the values to groupings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pendenForm(penden.env)
string.help(string, star = " ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pendenForm_+3A_penden.env">penden.env</code></td>
<td>
<p>environment used in pendensity()</p>
</td></tr>
<tr><td><code id="pendenForm_+3A_string">string</code></td>
<td>
<p>string of the formula</p>
</td></tr>
<tr><td><code id="pendenForm_+3A_star">star</code></td>
<td>
<p>separating letter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returning the values and the structure of response and covariates.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>

<hr>
<h2 id='pendensity'>Calculating penalized density</h2><span id='topic+pendensity'></span>

<h3>Description</h3>

<p>Main program for estimation penalized densities. The estimation can be done for response with or without any covariates. The covariates have to be factors. The response is called 'y', the covariates 'x'. We estimate densities using penalized splines. This done by using a number of knots and a penalty parameter, which are sufficient large. We penalize the m-order differences of the beta-coefficients to estimate the weights 'ck' of the used base functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pendensity(form, base, no.base, max.iter, lambda0, q, sort, with.border, m, data,eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pendensity_+3A_form">form</code></td>
<td>
<p>formula describing the density, the formula is<br />
</p>
<p style="text-align: center;"><code class="reqn">y \sim x_1 + x_2 + \dots x_n</code>
</p>

<p>where 'x' have to be factors.</p>
</td></tr>
<tr><td><code id="pendensity_+3A_base">base</code></td>
<td>
<p>supported bases are &quot;bspline&quot; or &quot;gaussian&quot;</p>
</td></tr>
<tr><td><code id="pendensity_+3A_no.base">no.base</code></td>
<td>
<p>how many knots 'K', following the approach to use 2'no.base'+1 knots, if 'no.base' is NULL, default is K=41.</p>
</td></tr>
<tr><td><code id="pendensity_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iteration, the default is max.iter=20.</p>
</td></tr>
<tr><td><code id="pendensity_+3A_lambda0">lambda0</code></td>
<td>
<p>start penalty parameter, the default is lambda0=500</p>
</td></tr>
<tr><td><code id="pendensity_+3A_q">q</code></td>
<td>
<p>order of B-Spline base, the default is 'q=3'</p>
</td></tr>
<tr><td><code id="pendensity_+3A_sort">sort</code></td>
<td>
<p>TRUE or FALSE, if TRUE the response and the covariates should be sorted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pendensity_+3A_with.border">with.border</code></td>
<td>
<p>determining the number of additional knots on the left and the right of the support of the response. The number of knots 'no.base' is not influenced by this parameter. The amount of knots 'no.base' are placed on the support of the response. The amount of knots determined in 'with.border' is placed outside the support and reduce the amount of knots on the support about its value. Default is NULL.</p>
</td></tr>
<tr><td><code id="pendensity_+3A_m">m</code></td>
<td>
<p>m-th order difference for penalization. Default is m=q.</p>
</td></tr>
<tr><td><code id="pendensity_+3A_data">data</code></td>
<td>
<p>reference to the data. Default reference is the data=parent.frame().</p>
</td></tr>
<tr><td><code id="pendensity_+3A_eps">eps</code></td>
<td>
<p>Level of percentage to determine calculation of optimal lambda, default=0.01</p>
</td></tr>
</table>


<h3>Details</h3>

<p>pendensity() begins with setting the parameters for the estimation. Checking the formula and transferring the data into the program, setting the knots and creating the base, depending on the chosen parameter 'base'. Moreover the penalty matrix is constructed. At the beginning of the first iteration the beta parameter are set equal to zero. With this setup, the first log likelihood is calculated and is used for the first iteration for a new beta parameter.<br />
The iteration for a new beta parameter is done with a Newton-Raphson-Iteration and implemented in the function 'new.beta.val'. We calculate the direction of the Newton Raphson step for the known <code class="reqn">beta_t</code> and iterate a step size bisection to control the maximizing of the penalized likelihood </p>
<p style="text-align: center;"><code class="reqn">l_p(\beta_t,\lambda_0)</code>
</p>
<p>. This means we set </p>
<p style="text-align: center;"><code class="reqn">\beta_{t+1}=\beta_t - 2^{-v} \{s_p(\beta_t,\lambda_0) \cdot (-J_p(\beta_t,\lambda_0))^{-1}\}</code>
</p>
<p> with <code class="reqn">s_p</code> as penalized first order derivative and <code class="reqn">J_p</code> as penalized second order derivative. We begin with <code class="reqn">v=0</code>. Not yielding a new maximum for a current v, we increase v step by step respectively bisect the step size. We terminate the iteration, if the step size is smaller than some reference value epsilon (eps=1e-3) without yielding a new maximum. We iterate for new parameter beta until the new log likelihood depending on the new estimated parameter beta differ less than 0.1 log-likelihood points from the log likelihood estimated before.<br />
After reaching the new parameter beta, we iterate for a new penalty parameter lambda. This iteration is done by the function 'new.lambda'. The iteration formula is </p>
<p style="text-align: center;"><code class="reqn"> {\lambda}^{-1}=\frac{\hat{\beta}^T D_m \hat{\beta}}{df(\hat{\lambda})-p(m-1)}</code>
</p>
<p><br />
The iteration for the new lambda is terminated, if the approximate degree of freedom minus p*(m-1) is smaller than some epsilon2 (eps2=0.01). Moreover, we terminate the iteration if the new lambda is approximatively converted, i.e. the new lambda differs only 0.001*old lambda (*) from the old lambda. If these both criteria doesn't fit, the lambda iteration is terminated after eleven iterations. <br />
We begin a new iteration with the new lambda, restarting with parameter
beta setting equal to zero again. This procedure is repeated until
convergence of lambda, i.e. that the new lambda fulfills the criteria
(*). If this criteria is not fulfilled after 20 iterations, the total iteration terminates.<br />
After terminating all iterations, the final AIC, ck and beta are saved in the output.<br />
For speediness, all values, matrices, vectors etc. are saved in an environment called 'penden.env'. Most of the used programs get only this environment as input.
</p>


<h3>Value</h3>

<p>Returning an object of class pendensity.
The class pendensity consists of the &quot;call&quot; and three main groups &quot;values&quot;, &quot;splines&quot; and &quot;results&quot;.
</p>
<p>call: the formula prompted for calculation of the penalized density.
</p>
<p>#####
</p>
<p>\$values contains:
y: the values of the response variable
x: the values of the covariate(s)
sort: TRUE/FALSE if TRUE the response (and covariates) have been sorted in increasing order of the response
</p>
<p>\$values\$covariate contains 
Z: matrix Z
levels: existing levels of each covariate
how.levels: number of existing levels of all covariates
how.combi: number of combination of levels
x.factor: list of all combination of levels
</p>
<p>#####
</p>
<p>\$splines contains 
K: number of knots
N: number of coefficients estimated for each base, depending on the number of covariates.
MeanW: values of the knots used for splines and means of the Gaussian densities
Stand.abw: values of the standard deviance of the Gaussian densities
h: distance between the equidistant knots
m: used difference order for penalization
q: used order of the B-Spline base
stand.num: calculated values for standardization getting B-Spline densities
base: used kind of base, &quot;bspline&quot; or &quot;gaussian&quot;
base.den: values of the base of order q created with knots=knots.val$val
base.den2: values of the base of order q+1 created with knots=knots.val$val. Used for calculating the distribution function(s).
L: used difference matrix
Dm: used penalty matrix, depending on lambda0, L (,Z) and n=number of observations
help.degree: additional degree(s) depending on the number of knots K and the used order q
</p>
<p>\$splines\$knots.val contains:
val: list of the used knots in the support of the response
all: list of the used knots extended with additional knots used for constructing
</p>
<p>#####
</p>
<p>results contains:
ck: final calculated weights ck
beta.val: final calculated parameter beta
lambda0: final calculated lambda0
fitted: fitted values of the density f(y)
variance.par: final variances of the parameter beta
bias.par: final bias of the parameter beta
</p>
<p>results\$AIC contains:
my.AIC: final AIC value
my.trace: trace component of the final AIC
</p>
<p>results\$Derv contains:
Derv2.pen: final penalized second order derivation 
Derv2.cal: final non-penalized second order derivation 
Derv1.cal: final non-penalized first order derivation 
</p>
<p>results\$iterations contains:
list.opt.results: list of the final results of each iteration of new beta + new lambda
all.lists: list of lists. Each list contains the result of one iteration
</p>
<p>results\$likelihood contains:
pen.Likelihood: final penalized log likelihood
opt.Likelihood: final log likelihood
marg.Likelihood: final marginal likelihood
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='plot.pendensity'>Plotting estimated penalized densities</h2><span id='topic+plot.pendensity'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Plotting estimated penalized densities, need object of class 'pendensity'. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pendensity'
plot(x, plot.val = 1, val=NULL, latt = FALSE, kernel = FALSE, confi = TRUE,
 main = NULL, sub = NULL, xlab = NULL, ylab = NULL, plot.base = FALSE,
 lwd=NULL,legend.txt=NULL,plot.dens=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pendensity_+3A_x">x</code></td>
<td>
<p>object of class pendensity</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_plot.val">plot.val</code></td>
<td>
<p>if plot.val=1 the density is plotted, if plot.val=2
the distribution function of the observation values is plotted, if
plot.val=3 the distribution function is plotted as function</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_val">val</code></td>
<td>
<p>vector of y, at which the estimated density should be calculated. If plot.val=2, the calculated values of distribution are returned and the values are pointed in the distribution function of the observed values.</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_latt">latt</code></td>
<td>
<p>TRUE/FALSE, if TRUE the lattice interface should be used for plotting, default=FALSE</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_kernel">kernel</code></td>
<td>
<p>TRUE/FALSE, if TRUE a kernel density estimation should be added to the density plots, default=FALSE</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_confi">confi</code></td>
<td>
<p>TRUE/FALSE, if TRUE confidence intervals should be added to the density plots, default=TRUE </p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_main">main</code></td>
<td>
<p>Main of the density plot, if NULL main contains settings 'K', 'AIC' and 'lambda0' of the estimation</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_sub">sub</code></td>
<td>
<p>sub of the density plot, if NULL sub contains settings used base 'base' and used order of B-Spline 'q'</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_xlab">xlab</code></td>
<td>
<p>xlab of the density plot, if NULL xlab contains 'y'</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_ylab">ylab</code></td>
<td>
<p>ylab of the density plot, if NULL ylab contains 'density'</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_plot.base">plot.base</code></td>
<td>
<p>TRUE/FALSE, if TRUE the weighted base should be added to the density plot, default=FALSE</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_lwd">lwd</code></td>
<td>
<p>lwd of the lines of density plot, if NULL lwd=3, the confidence bands are plotted with lwd=2</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_legend.txt">legend.txt</code></td>
<td>
<p>if FALSE no legend is plotted, legend.txt can get a
vector of characters with length of the groupings. legend.txt works
only for plot.val=1</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_plot.dens">plot.dens</code></td>
<td>
<p>TRUE/FALSE, if the estimated density should be plotted. Default=TRUE. Interesting for evaluating densities in values 'val', while this special plot is not needed.</p>
</td></tr>
<tr><td><code id="plot.pendensity_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each grouping of factors is plotted. Therefore, equidistant help values are constructed in the support of the response for each grouping of factors. Weighting these help values with knots weights ck results in the density estimation for each grouping of factors. If asked for, pointwise confidence intervals are computed and plotted.
</p>


<h3>Value</h3>

<p>If the density function is plotted, function returns two values
</p>
<table role = "presentation">
<tr><td><code>help.env</code></td>
<td>
<p>Contains the constructed help values for the response, the corresponding values for the densities and if asked for the calculated confidence intervals</p>
</td></tr>
<tr><td><code>combi</code></td>
<td>
<p>list of all combinations of the covariates</p>
</td></tr>
</table>
<p>If additionally the function is called with a valid argument for 'val',
a list returns with
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>values at which the estimated density has been calculated</p>
</td></tr>
<tr><td><code>fy</code></td>
<td>
<p>calculated density values in y</p>
</td></tr>
<tr><td><code>sd.up.y.val</code></td>
<td>
<p>the values of the upper confidence interval of y</p>
</td></tr>
<tr><td><code>sd.down.y.val</code></td>
<td>
<p>the values of the lower confidence interval of y</p>
</td></tr>
</table>
<p>If the empirical distribution function is plotted, the function returns
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>containing the observed values y</p>
</td></tr>
<tr><td><code>sum</code></td>
<td>
<p>containing the empirical distribution of each observation y</p>
</td></tr>
</table>
<p>If the theoretical distribution function is plotted, the function returns an environment. For plotting the theoretical distributions, each interval between two knots is evaluated at 100 equidistant simulated points between the two knots considered. These points are saved in the environment with the name &quot;paste(&quot;x&quot;,i,sep=&quot;&quot;)&quot; for each interval i, the calculated distribution is save with the name &quot;paste(&quot;F(x)&quot;,i,sep=&quot;&quot;)&quot; for each interval i. For these points, the distribution is calculated. 
</p>


<h3>Note</h3>

<p>For plotting the density and e.g. the empirical distributions, use e.g. 'X11()' before calling the second plot to open a new graphic device.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(100)
test &lt;- pendensity(y~1)
plot(test)

#distribution
plot(test,plot.val=2)
</code></pre>

<hr>
<h2 id='print.pendensity'>Printing the main results of the (conditional) penalized density estimation</h2><span id='topic+print.pendensity'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>Printing the call of the estimation, the resulting weights, the final lambda0 and the corresponding value of AIC. Need an object of class pendensity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pendensity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pendensity_+3A_x">x</code></td>
<td>
<p>x has to be object of class pendensity</p>
</td></tr>
<tr><td><code id="print.pendensity_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>

<hr>
<h2 id='test.equal'>Testing pairwise equality of densities</h2><span id='topic+test.equal'></span>

<h3>Description</h3>

<p>Every group of factor combination is tested pairwise for equality to all other groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.equal(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.equal_+3A_obj">obj</code></td>
<td>
<p>object of class pendensity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the distribution of the integrated B-Spline density base. This is saved in the program in the object named 'mat1'. Moreover, we use the variance 'var.par' of the estimation, the weights and some matrices 'C' of the two compared densities to construct the matrix 'W'. We simulate the distribution of the test statistic using a spectral decomposition of W.
</p>


<h3>Value</h3>

<p>Returning a list of p-values for testing pairwise for equality.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='variance.par'>Calculating the variance of the parameters</h2><span id='topic+variance.par'></span>

<h3>Description</h3>

<p>Calculating the variance of the parameters of the estimation, depending on the second order derivative and the penalized second order derivative of the density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance.par(penden.env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance.par_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the parameters of the estimation results as the product of the inverse of the penalized second order derivative times the second order derivative without penalization time the inverse of the penalized second order derivative.
</p>
<p><code class="reqn">V(\beta, \lambda_0)=I_p^{-1}(\beta, \lambda) I_p(\beta, \lambda=0) I_p^{-1}(\beta, \lambda)</code> with <code class="reqn">I_p(\beta^{-1}, \lambda)=E_{f(y)}\bigl\{J_p(\beta, \lambda)\bigr\}</code>
</p>
<p>The needed values are saved in the environment.
</p>


<h3>Value</h3>

<p>The return is a variance matrix of the dimension (K-1)x(K-1).
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

<hr>
<h2 id='variance.val'>Calculating variance and standard deviance of each observation.</h2><span id='topic+variance.val'></span>

<h3>Description</h3>

<p>Calculating the variance and standard deviance of each observation. Therefore we use the variance of the parameter set beta, called 'var.par'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance.val(base.den, var.par, weight, K, x, list.len, Z, x.factor, y.val=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance.val_+3A_base.den">base.den</code></td>
<td>
<p>base values</p>
</td></tr>
<tr><td><code id="variance.val_+3A_var.par">var.par</code></td>
<td>
<p>variance of the parameter set beta</p>
</td></tr>
<tr><td><code id="variance.val_+3A_weight">weight</code></td>
<td>
<p>weights ck</p>
</td></tr>
<tr><td><code id="variance.val_+3A_k">K</code></td>
<td>
<p>number of knots</p>
</td></tr>
<tr><td><code id="variance.val_+3A_x">x</code></td>
<td>
<p>covariates</p>
</td></tr>
<tr><td><code id="variance.val_+3A_list.len">list.len</code></td>
<td>
<p>number of covariate combinations</p>
</td></tr>
<tr><td><code id="variance.val_+3A_z">Z</code></td>
<td>
<p>covariate matrix</p>
</td></tr>
<tr><td><code id="variance.val_+3A_x.factor">x.factor</code></td>
<td>
<p>list of covariate combinations</p>
</td></tr>
<tr><td><code id="variance.val_+3A_y.val">y.val</code></td>
<td>
<p>optimal values for calculating the variance in any point
yi in the case of a factorial density</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returning a vector with the standard deviance of each observation.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld&gt;</p>


<h3>References</h3>

<p>Density Estimation with a Penalized Mixture Approach, Schellhase C. and Kauermann G. (2012), Computational Statistics 27 (4), p. 757-777.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
