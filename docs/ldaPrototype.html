<!DOCTYPE html><html><head><title>Help for package ldaPrototype</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ldaPrototype}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.LDABatch'><p>LDABatch Constructor</p></a></li>
<li><a href='#as.LDARep'><p>LDARep Constructor</p></a></li>
<li><a href='#cosineTopics'><p>Pairwise Cosine Similarities</p></a></li>
<li><a href='#dendTopics'><p>Topic Dendrogram</p></a></li>
<li><a href='#getJob'><p>Getter and Setter for LDARep and LDABatch</p></a></li>
<li><a href='#getPrototype'><p>Determine the Prototype LDA</p></a></li>
<li><a href='#getSCLOP'><p>Getter for PrototypeLDA</p></a></li>
<li><a href='#getSimilarity'><p>Getter for TopicSimilarity</p></a></li>
<li><a href='#getTopics'><p>Getter for LDA</p></a></li>
<li><a href='#jaccardTopics'><p>Pairwise Jaccard Coefficients</p></a></li>
<li><a href='#jsTopics'><p>Pairwise Jensen-Shannon Similarities (Divergences)</p></a></li>
<li><a href='#LDA'><p>LDA Object</p></a></li>
<li><a href='#LDABatch'><p>LDA Replications on a Batch System</p></a></li>
<li><a href='#LDAPrototype'><p>Determine the Prototype LDA</p></a></li>
<li><a href='#ldaPrototype-package'><p>ldaPrototype: Prototype of Multiple Latent Dirichlet Allocation Runs</p></a></li>
<li><a href='#LDARep'><p>LDA Replications</p></a></li>
<li><a href='#mergeBatchTopics'><p>Merge LDA Topic Matrices</p></a></li>
<li><a href='#mergeRepTopics'><p>Merge LDA Topic Matrices</p></a></li>
<li><a href='#mergeTopics'><p>Merge LDA Topic Matrices</p></a></li>
<li><a href='#pruneSCLOP'><p>Local Pruning State of Topic Dendrograms</p></a></li>
<li><a href='#rboTopics'><p>Pairwise RBO Similarities</p></a></li>
<li><a href='#reuters'><p>A Snippet of the Reuters Dataset</p></a></li>
<li><a href='#SCLOP'><p>Similarity/Stability of multiple sets of Objects using Clustering with Local Pruning</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Prototype of Multiple Latent Dirichlet Allocation Runs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Determine a Prototype from a number of runs of Latent Dirichlet Allocation (LDA) measuring its similarities with S-CLOP: A procedure to select the LDA run with highest mean pairwise similarity, which is measured by S-CLOP (Similarity of multiple sets by Clustering with Local Pruning), to all other runs. LDA runs are specified by its assignments leading to estimators for distribution parameters. Repeated runs lead to different results, which we encounter by choosing the most representative LDA run as prototype.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JonasRieger/ldaPrototype">https://github.com/JonasRieger/ldaPrototype</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JonasRieger/ldaPrototype/issues">https://github.com/JonasRieger/ldaPrototype/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>batchtools (&ge; 0.9.11), checkmate (&ge; 1.8.5), colorspace (&ge;
1.4-1), data.table (&ge; 1.11.2), dendextend, fs (&ge; 1.2.0),
future, lda (&ge; 1.4.2), parallelMap, progress (&ge; 1.1.1),
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, RColorBrewer (&ge; 1.1-2), testthat, tosca</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-01 15:55:37 UTC; riege</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Rieger <a href="https://orcid.org/0000-0002-0007-4478"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Rieger &lt;jonas.rieger@tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-02 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.LDABatch'>LDABatch Constructor</h2><span id='topic+as.LDABatch'></span><span id='topic+is.LDABatch'></span>

<h3>Description</h3>

<p>Constructs a <code><a href="#topic+LDABatch">LDABatch</a></code> object for given elements <code>reg</code>,
<code>job</code> and <code>id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.LDABatch(reg, job, id)

is.LDABatch(obj, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.LDABatch_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="batchtools.html#topic+makeRegistry">Registry</a></code>]<br />
Registry. See <code><a href="batchtools.html#topic+findJobs">findDone</a></code>.</p>
</td></tr>
<tr><td><code id="as.LDABatch_+3A_job">job</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A data.frame or data.table with a column named &quot;job.id&quot; or a vector of integerish job ids.
See <code><a href="batchtools.html#topic+reduceResultsList">reduceResultsList</a></code>.</p>
</td></tr>
<tr><td><code id="as.LDABatch_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A name for the registry. If not passed, the folder's name is extracted from <code>reg</code>.</p>
</td></tr>
<tr><td><code id="as.LDABatch_+3A_obj">obj</code></td>
<td>
<p>[<code>R</code> object]<br />
Object to test.</p>
</td></tr>
<tr><td><code id="as.LDABatch_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should test information be given in the console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code><a href="batchtools.html#topic+makeRegistry">Registry</a></code> the function returns
a <code><a href="#topic+LDABatch">LDABatch</a></code> object, which can be handled using the getter functions
at <code><a href="#topic+getJob">getJob</a></code>.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries <code>id</code> for the registry's folder name,
<code>jobs</code> for the submitted jobs' ids and its parameter settings and
<code>reg</code> for the registry itself.
</p>


<h3>See Also</h3>

<p>Other constructor functions: 
<code><a href="#topic+LDA">LDA</a>()</code>,
<code><a href="#topic+as.LDARep">as.LDARep</a>()</code>
</p>
<p>Other batch functions: 
<code><a href="#topic+LDABatch">LDABatch</a>()</code>,
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+mergeBatchTopics">mergeBatchTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
batch = LDABatch(docs = reuters_docs, vocab = reuters_vocab, K = 15, chunk.size = 20)
batch

batch2 = as.LDABatch(reg = getRegistry(batch))
batch2
head(getJob(batch2))

batch3 = as.LDABatch()
batch3

### one way of loading an existing registry ###
batchtools::loadRegistry("LDABatch")
batch = as.LDABatch()

## End(Not run)

</code></pre>

<hr>
<h2 id='as.LDARep'>LDARep Constructor</h2><span id='topic+as.LDARep'></span><span id='topic+as.LDARep.default'></span><span id='topic+as.LDARep.LDARep'></span><span id='topic+is.LDARep'></span>

<h3>Description</h3>

<p>Constructs a <code><a href="#topic+LDARep">LDARep</a></code> object for given elements <code>lda</code>,
<code>job</code> and <code>id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.LDARep(...)

## Default S3 method:
as.LDARep(lda, job, id, ...)

## S3 method for class 'LDARep'
as.LDARep(x, ...)

is.LDARep(obj, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.LDARep_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="as.LDARep_+3A_lda">lda</code></td>
<td>
<p>[<code>named list</code>]<br />
List of <code><a href="#topic+LDA">LDA</a></code> objects, named by the corresponding &quot;job.id&quot; (<code>integerish</code>).
If list is unnamed, names are set.</p>
</td></tr>
<tr><td><code id="as.LDARep_+3A_job">job</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>named vector</code>]<br />
A data.frame or data.table with named columns (at least)
&quot;job.id&quot; (<code>integerish</code>), &quot;K&quot;, &quot;alpha&quot;, &quot;eta&quot; and &quot;num.iterations&quot;
or a named vector with entries (at least) &quot;K&quot;, &quot;alpha&quot;, &quot;eta&quot; and &quot;num.iterations&quot;.
If not passed, it is interpreted from <code>param</code> of each LDA.</p>
</td></tr>
<tr><td><code id="as.LDARep_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A name for the computation. If not passed, it is set to &quot;LDARep&quot;.</p>
</td></tr>
<tr><td><code id="as.LDARep_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+LDABatch">LDABatch</a></code> or <code><a href="#topic+LDARep">LDARep</a></code> object.</p>
</td></tr>
<tr><td><code id="as.LDARep_+3A_obj">obj</code></td>
<td>
<p>[<code>R</code> object]<br />
Object to test.</p>
</td></tr>
<tr><td><code id="as.LDARep_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should test information be given in the console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of <code><a href="#topic+LDA">LDA</a></code> objects the function returns
a <code><a href="#topic+LDARep">LDARep</a></code> object, which can be handled using the getter functions
at <code><a href="#topic+getJob">getJob</a></code>.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries <code>id</code> for computation's name,
<code>jobs</code> for the parameter settings and <code>lda</code> for the results themselves.
</p>


<h3>See Also</h3>

<p>Other constructor functions: 
<code><a href="#topic+LDA">LDA</a>()</code>,
<code><a href="#topic+as.LDABatch">as.LDABatch</a>()</code>
</p>
<p>Other replication functions: 
<code><a href="#topic+LDAPrototype">LDAPrototype</a>()</code>,
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+mergeRepTopics">mergeRepTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 7, num.iterations = 20)
lda = getLDA(res)

res2 = as.LDARep(lda, id = "newName")
res2
getJob(res2)
getJob(res)

## Not run: 
batch = LDABatch(docs = reuters_docs, vocab = reuters_vocab, n = 4, id = "TEMP", K = 30)
res3 = as.LDARep(batch)
res3
getJob(res3)

## End(Not run)

</code></pre>

<hr>
<h2 id='cosineTopics'>Pairwise Cosine Similarities</h2><span id='topic+cosineTopics'></span>

<h3>Description</h3>

<p>Calculates the similarity of all pairwise topic combinations using the
Cosine Similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosineTopics(topics, progress = TRUE, pm.backend, ncpus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosineTopics_+3A_topics">topics</code></td>
<td>
<p>[<code>named matrix</code>]<br />
The counts of vocabularies/words (row wise) in topics (column wise).</p>
</td></tr>
<tr><td><code id="cosineTopics_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown? Turning it off, could lead to significantly
faster calculation. Default is <code>TRUE</code>.
If <code>pm.backend</code> is set, parallelization is done and no progress bar will be shown.</p>
</td></tr>
<tr><td><code id="cosineTopics_+3A_pm.backend">pm.backend</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;multicore&quot;, &quot;socket&quot; or &quot;mpi&quot;.
If <code>pm.backend</code> is set, <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is
called before computation is started and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code>
is called after.</p>
</td></tr>
<tr><td><code id="cosineTopics_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of (physical) CPUs to use. If <code>pm.backend</code> is passed,
default is determined by <code><a href="future.html#topic+availableCores">availableCores</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cosine Similarity for two topics <code class="reqn">\bm z_{i}</code> and <code class="reqn">\bm z_{j}</code>
is calculated by
</p>
<p style="text-align: center;"><code class="reqn"> \cos(\theta | \bm z_{i}, \bm z_{j}) = \frac{ \sum_{v=1}^{V}{n_{i}^{(v)} n_{j}^{(v)}} }{ \sqrt{\sum_{v=1}^{V}{\left(n_{i}^{(v)}\right)^2}} \sqrt{\sum_{v=1}^{V}{\left(n_{j}^{(v)}\right)^2}} }</code>
</p>

<p>with <code class="reqn">\theta</code> determining the angle between the corresponding
count vectors <code class="reqn">\bm z_{i}</code> and <code class="reqn">\bm z_{j}</code>,
<code class="reqn">V</code> is the vocabulary size and <code class="reqn">n_k^{(v)}</code> is the count of
assignments of the <code class="reqn">v</code>-th word to the <code class="reqn">k</code>-th topic.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>sims</code></dt><dd><p>[<code>lower triangular named matrix</code>] with all pairwise
similarities of the given topics.</p>
</dd>
<dt><code>wordslimit</code></dt><dd><p>[<code>integer</code>] = vocabulary size. See
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> for original purpose.</p>
</dd>
<dt><code>wordsconsidered</code></dt><dd><p>[<code>integer</code>] = vocabulary size. See
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> for original purpose.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter
<code>type</code> [<code>character(1)</code>] <code>= "Cosine Similarity"</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other TopicSimilarity functions: 
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+jsTopics">jsTopics</a>()</code>,
<code><a href="#topic+rboTopics">rboTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
cosine = cosineTopics(topics)
cosine

sim = getSimilarity(cosine)
dim(sim)

</code></pre>

<hr>
<h2 id='dendTopics'>Topic Dendrogram</h2><span id='topic+dendTopics'></span><span id='topic+plot.TopicDendrogram'></span>

<h3>Description</h3>

<p>Builds a dendrogram for topics based on their pairwise similarities using the
cluster algorithm <code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dendTopics(sims, ind, method = "complete")

## S3 method for class 'TopicDendrogram'
plot(x, pruning, pruning.par, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dendTopics_+3A_sims">sims</code></td>
<td>
<p>[<code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> object
or <code>lower triangular named matrix</code>]<br />
<code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> object or
pairwise jaccard similarities of underlying topics as the <code>sims</code> element
from <code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> objects. The topic names should be
formatted as &lt;<em>Run X</em>&gt;.&lt;<em>Topic Y</em>&gt;, so that the name before the
first dot identifies the LDA run.</p>
</td></tr>
<tr><td><code id="dendTopics_+3A_ind">ind</code></td>
<td>
<p>[<code>integer</code>, <code>logical</code> or <code>character</code>]<br />
An integerish vector (or logical of the same length as the number of rows and columns)
for specifying the topics taken into account. Alternatively
a character vector can be passed. Then, all topics are taken for which the name
contain at least one of the phrases in <code>ind</code> (see <code><a href="base.html#topic+grep">grepl</a></code>).
By default all topics are considered.</p>
</td></tr>
<tr><td><code id="dendTopics_+3A_method">method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The agglomeration method. See <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="dendTopics_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="dendTopics_+3A_pruning">pruning</code></td>
<td>
<p>[<code>list of <a href="stats.html#topic+dendrogram">dendrogram</a>s</code>]<br />
<code><a href="#topic+pruneSCLOP">PruningSCLOP</a></code> object specifying the best possible
local pruning state.</p>
</td></tr>
<tr><td><code id="dendTopics_+3A_pruning.par">pruning.par</code></td>
<td>
<p>[<code>list</code>]<br />
List of parameters to mark the pruning. See section &quot;Details&quot; at <code><a href="#topic+dendTopics">dendTopics</a></code>
for default parameters. Types for marking the pruning state are <code>"abline"</code>,
<code>"color"</code> and <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="dendTopics_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The label´s colors are determined based on their Run belonging using
<code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code> by default. Colors can be manipulated
using <code><a href="dendextend.html#topic+labels_colors">labels_colors</a></code>. Analogously, the labels
themself can be  manipulated using <code><a href="dendextend.html#topic+labels.hclust">labels</a></code>.
For both the function <code><a href="stats.html#topic+order.dendrogram">order.dendrogram</a></code> is useful.
</p>
<p>The resulting <code><a href="stats.html#topic+dendrogram">dendrogram</a></code> can be plotted. In addition,
it is possible to mark a pruning state in the plot, either by color or by
separator lines (or both) setting <code>pruning.par</code>. For the default values
of <code>pruning.par</code> call the corresponding function on any
<code><a href="#topic+pruneSCLOP">PruningSCLOP</a></code> object.
</p>


<h3>Value</h3>

<p>[<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>] <code><a href="#topic+dendTopics">TopicDendrogram</a></code> object
(and <code><a href="stats.html#topic+dendrogram">dendrogram</a></code> object) of all considered topics.
</p>


<h3>See Also</h3>

<p>Other plot functions: 
<code><a href="#topic+pruneSCLOP">pruneSCLOP</a>()</code>
</p>
<p>Other TopicSimilarity functions: 
<code><a href="#topic+cosineTopics">cosineTopics</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+jsTopics">jsTopics</a>()</code>,
<code><a href="#topic+rboTopics">rboTopics</a>()</code>
</p>
<p>Other workflow functions: 
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+SCLOP">SCLOP</a>()</code>,
<code><a href="#topic+getPrototype">getPrototype</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+mergeTopics">mergeTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
jacc = jaccardTopics(topics, atLeast = 2)
sim = getSimilarity(jacc)

dend = dendTopics(jacc)
dend2 = dendTopics(sim)


plot(dend)
plot(dendTopics(jacc, ind = c("Rep2", "Rep3")))


pruned = pruneSCLOP(dend)

plot(dend, pruning = pruned)
plot(dend, pruning = pruned, pruning.par = list(type = "color"))
plot(dend, pruning = pruned, pruning.par = list(type = "both", lty = 1, lwd = 2, col = "red"))

dend2 = dendTopics(jacc, ind = c("Rep2", "Rep3"))
plot(dend2, pruning = pruneSCLOP(dend2), pruning.par = list(lwd = 2, col = "darkgrey"))


</code></pre>

<hr>
<h2 id='getJob'>Getter and Setter for LDARep and LDABatch</h2><span id='topic+getJob'></span><span id='topic+getID'></span><span id='topic+getRegistry'></span><span id='topic+getLDA'></span><span id='topic+setFileDir'></span>

<h3>Description</h3>

<p>Returns the job ids and its parameter set (<code>getJob</code>) or the (registry's)
id (<code>getID</code>) for a <code><a href="#topic+LDABatch">LDABatch</a></code> or <code><a href="#topic+LDARep">LDARep</a></code> object.
<code>getRegistry</code> returns the registry itself for a <code><a href="#topic+LDABatch">LDABatch</a></code>
object. <code>getLDA</code> returns the list of <code><a href="#topic+LDA">LDA</a></code> objects for a
<code><a href="#topic+LDABatch">LDABatch</a></code> or <code><a href="#topic+LDARep">LDARep</a></code> object. In addition, you can
specify one or more LDAs by their id(s).<br />
<code>setFilDir</code> sets the registry's file directory for a
<code><a href="#topic+LDABatch">LDABatch</a></code> object. This is useful if you move the registry´s folder,
e.g. if you do your calculations on a batch system, but want to do your
evaluation on your desktop computer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getJob(x)

getID(x)

getRegistry(x)

getLDA(x, job, reduce, all)

setFileDir(x, file.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getJob_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+LDABatch">LDABatch</a></code> or <code><a href="#topic+LDARep">LDARep</a></code> object.</p>
</td></tr>
<tr><td><code id="getJob_+3A_job">job</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A data.frame or data.table with a column named &quot;job.id&quot; or a vector of integerish job ids.</p>
</td></tr>
<tr><td><code id="getJob_+3A_reduce">reduce</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If the list of LDAs contains only one element, should the list be reduced and
the single (unnamed) element be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getJob_+3A_all">all</code></td>
<td>
<p>not implemented for <code><a href="#topic+LDABatch">LDABatch</a></code> and <code><a href="#topic+LDARep">LDARep</a></code>
object. See <code><a href="#topic+getSCLOP">getLDA</a></code></p>
</td></tr>
<tr><td><code id="getJob_+3A_file.dir">file.dir</code></td>
<td>
<p>[Vector to be coerced to a <code><a href="fs.html#topic+fs_path">fs_path</a></code> object.]<br />
New file directory to overwrite the registry's old one. This can be useful
if the registry is transferred from a batch system.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other getter functions: 
<code><a href="#topic+getSCLOP">getSCLOP</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>,
<code><a href="#topic+getTopics">getTopics</a>()</code>
</p>
<p>Other replication functions: 
<code><a href="#topic+LDAPrototype">LDAPrototype</a>()</code>,
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+as.LDARep">as.LDARep</a>()</code>,
<code><a href="#topic+mergeRepTopics">mergeRepTopics</a>()</code>
</p>
<p>Other batch functions: 
<code><a href="#topic+LDABatch">LDABatch</a>()</code>,
<code><a href="#topic+as.LDABatch">as.LDABatch</a>()</code>,
<code><a href="#topic+mergeBatchTopics">mergeBatchTopics</a>()</code>
</p>

<hr>
<h2 id='getPrototype'>Determine the Prototype LDA</h2><span id='topic+getPrototype'></span><span id='topic+getPrototype.LDARep'></span><span id='topic+getPrototype.LDABatch'></span><span id='topic+getPrototype.default'></span>

<h3>Description</h3>

<p>Returns the Prototype LDA of a set of LDAs. This set is given as
<code><a href="#topic+LDABatch">LDABatch</a></code> object, <code><a href="#topic+LDARep">LDARep</a></code> object, or as list of LDAs.
If the matrix of S-CLOP scores <code>sclop</code> is passed, no calculation is needed/done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPrototype(...)

## S3 method for class 'LDARep'
getPrototype(
  x,
  vocab,
  limit.rel,
  limit.abs,
  atLeast,
  progress = TRUE,
  pm.backend,
  ncpus,
  keepTopics = FALSE,
  keepSims = FALSE,
  keepLDAs = FALSE,
  sclop,
  ...
)

## S3 method for class 'LDABatch'
getPrototype(
  x,
  vocab,
  limit.rel,
  limit.abs,
  atLeast,
  progress = TRUE,
  pm.backend,
  ncpus,
  keepTopics = FALSE,
  keepSims = FALSE,
  keepLDAs = FALSE,
  sclop,
  ...
)

## Default S3 method:
getPrototype(
  lda,
  vocab,
  id,
  job,
  limit.rel,
  limit.abs,
  atLeast,
  progress = TRUE,
  pm.backend,
  ncpus,
  keepTopics = FALSE,
  keepSims = FALSE,
  keepLDAs = FALSE,
  sclop,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPrototype_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+LDABatch">LDABatch</a></code> or <code><a href="#topic+LDARep">LDARep</a></code> object.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_vocab">vocab</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies taken into consideration for merging topic matrices.
Not considered, if <code>sclop</code> is passed. Default is the vocabulary of the first LDA.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_limit.rel">limit.rel</code></td>
<td>
<p>[0,1]<br />
See <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>. Default is <code>1/500</code>.
Not considered for calculation, if <code>sclop</code> is passed. But should be
passed determining the correct value for the resulting object.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_limit.abs">limit.abs</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
See <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>. Default is <code>10</code>.
Not considered for calculation, if <code>sclop</code> is passed. But should be
passed determining the correct value for the resulting object.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_atleast">atLeast</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
See <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>. Default is <code>0</code>.
Not considered for calculation, if <code>sclop</code> is passed. But should be
passed determining the correct value for the resulting object.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown for the steps of <code><a href="#topic+mergeTopics">mergeTopics</a></code>
and <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>? Turning it off, could lead to significantly
faster calculation. Default ist <code>TRUE</code>.
Not considered, if <code>sclop</code> is passed.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_pm.backend">pm.backend</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;multicore&quot;, &quot;socket&quot; or &quot;mpi&quot;.
If <code>pm.backend</code> is set, <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is
called before computation is started and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code>
is called after.
Not considered, if <code>sclop</code> is passed.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of (physical) CPUs to use. If <code>pm.backend</code> is passed,
default is determined by <code><a href="future.html#topic+availableCores">availableCores</a></code>.
Not considered, if <code>sclop</code> is passed.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_keeptopics">keepTopics</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the merged topic matrix from <code><a href="#topic+mergeTopics">mergeTopics</a></code> be kept?
Not considered, if <code>sclop</code> is passed.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_keepsims">keepSims</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the calculated topic similarities matrix from <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>
be kept? Not considered, if <code>sclop</code> is passed.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_keepldas">keepLDAs</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the considered LDAs be kept?</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_sclop">sclop</code></td>
<td>
<p>[<code>symmetrical named matrix</code>]<br />
(optional) All pairwise S-CLOP scores of the given LDA runs determined by
<code><a href="#topic+SCLOP.pairwise">SCLOP.pairwise</a></code>. Matching of names is not implemented yet, so order matters.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_lda">lda</code></td>
<td>
<p>[<code>named list</code>]<br />
List of <code><a href="#topic+LDA">LDA</a></code> objects, named by the corresponding &quot;job.id&quot;.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A name for the computation. If not passed, it is set to &quot;LDARep&quot;.
Not considered for <code><a href="#topic+LDABatch">LDABatch</a></code> or <code><a href="#topic+LDARep">LDARep</a></code> objects.</p>
</td></tr>
<tr><td><code id="getPrototype_+3A_job">job</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>named vector</code>]<br />
A data.frame or data.table with named columns (at least)
&quot;job.id&quot; (<code>integerish</code>), &quot;K&quot;, &quot;alpha&quot;, &quot;eta&quot; and &quot;num.iterations&quot;
or a named vector with entries (at least) &quot;K&quot;, &quot;alpha&quot;, &quot;eta&quot; and &quot;num.iterations&quot;.
If not passed, it is interpreted from <code>param</code> of each LDA.
Not considered for <code><a href="#topic+LDABatch">LDABatch</a></code> or <code><a href="#topic+LDARep">LDARep</a></code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code><a href="#topic+LDAPrototype">LDAPrototype</a></code> marks the overall shortcut for performing
multiple LDA runs and choosing the Prototype of them, <code>getPrototype</code>
just hooks up at determining the Prototype. The generation of multiple LDAs
has to be done before use of this function. The function is flexible enough
to use it at at least two steps/parts of the analysis: After generating the
LDAs (no matter whether as LDABatch or LDARep object) or after determing
the pairwise SCLOP values.
</p>
<p>To save memory a lot of interim calculations are discarded by default.
</p>
<p>If you use parallel computation, no progress bar is shown.
</p>
<p>For details see the details sections of the workflow functions.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>id</code></dt><dd><p>[<code>character(1)</code>] See above.</p>
</dd>
<dt><code>protoid</code></dt><dd><p>[<code>character(1)</code>] Name (ID) of the determined Prototype LDA.</p>
</dd>
<dt><code>lda</code></dt><dd><p>List of <code><a href="#topic+LDA">LDA</a></code> objects of the determined Prototype LDA
and - if <code>keepLDAs</code> is <code>TRUE</code> - all considered LDAs.</p>
</dd>
<dt><code>jobs</code></dt><dd><p>[<code>data.table</code>] with parameter specifications for the LDAs.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter specifications for
<code>limit.rel</code> [0,1], <code>limit.abs</code> [<code>integer(1)</code>] and
<code>atLeast</code> [<code>integer(1)</code>]. See above for explanation.</p>
</dd>
<dt><code>topics</code></dt><dd><p>[<code>named matrix</code>] with the count of vocabularies
(row wise) in topics (column wise).</p>
</dd>
<dt><code>sims</code></dt><dd><p>[<code>lower triangular named matrix</code>] with all pairwise
jaccard similarities of the given topics.</p>
</dd>
<dt><code>wordslimit</code></dt><dd><p>[<code>integer</code>] with counts of words determined as
relevant based on <code>limit.rel</code> and <code>limit.abs</code>.</p>
</dd>
<dt><code>wordsconsidered</code></dt><dd><p>[<code>integer</code>] with counts of considered
words for similarity calculation. Could differ from <code>wordslimit</code>, if
<code>atLeast</code> is greater than zero.</p>
</dd>
<dt><code>sclop</code></dt><dd><p>[<code>symmetrical named matrix</code>] with all pairwise
S-CLOP scores of the given LDA runs.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other shortcut functions: 
<code><a href="#topic+LDAPrototype">LDAPrototype</a>()</code>
</p>
<p>Other PrototypeLDA functions: 
<code><a href="#topic+LDAPrototype">LDAPrototype</a>()</code>,
<code><a href="#topic+getSCLOP">getSCLOP</a>()</code>
</p>
<p>Other workflow functions: 
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+SCLOP">SCLOP</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+mergeTopics">mergeTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab,
   n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
jacc = jaccardTopics(topics, atLeast = 2)
dend = dendTopics(jacc)
sclop = SCLOP.pairwise(jacc)

getPrototype(lda = getLDA(res), sclop = sclop)

proto = getPrototype(res, vocab = reuters_vocab, keepSims = TRUE,
   limit.abs = 20, atLeast = 10)
proto
getPrototype(proto) # = getLDA(proto)
getConsideredWords(proto)
# &gt; 10 if there is more than one word which is the 10-th often word (ties)
getRelevantWords(proto)
getSCLOP(proto)
</code></pre>

<hr>
<h2 id='getSCLOP'>Getter for PrototypeLDA</h2><span id='topic+getSCLOP'></span><span id='topic+getSimilarity.PrototypeLDA'></span><span id='topic+getRelevantWords.PrototypeLDA'></span><span id='topic+getConsideredWords.PrototypeLDA'></span><span id='topic+getMergedTopics'></span><span id='topic+getPrototypeID'></span><span id='topic+getLDA.PrototypeLDA'></span><span id='topic+getID.PrototypeLDA'></span><span id='topic+getParam.PrototypeLDA'></span><span id='topic+getJob.PrototypeLDA'></span>

<h3>Description</h3>

<p>Returns the corresponding element of a <code><a href="#topic+getPrototype">PrototypeLDA</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSCLOP(x)

## S3 method for class 'PrototypeLDA'
getSimilarity(x)

## S3 method for class 'PrototypeLDA'
getRelevantWords(x)

## S3 method for class 'PrototypeLDA'
getConsideredWords(x)

getMergedTopics(x)

getPrototypeID(x)

## S3 method for class 'PrototypeLDA'
getLDA(x, job, reduce = TRUE, all = FALSE)

## S3 method for class 'PrototypeLDA'
getID(x)

## S3 method for class 'PrototypeLDA'
getParam(x)

## S3 method for class 'PrototypeLDA'
getJob(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSCLOP_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+getPrototype">PrototypeLDA</a></code> object.</p>
</td></tr>
<tr><td><code id="getSCLOP_+3A_job">job</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A data.frame or data.table with a column named &quot;job.id&quot; or a vector of
integerish job ids. Default is the (integerish) ID of the Prototype LDA.</p>
</td></tr>
<tr><td><code id="getSCLOP_+3A_reduce">reduce</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If the list of LDAs contains only one element, should the list be reduced and
the single (unnamed) element be returned? Default is <code>TRUE</code>.
Not considered, if <code>all</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getSCLOP_+3A_all">all</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Shortcut for <code>job</code>: Should all stored LDAs be returned?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other getter functions: 
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>,
<code><a href="#topic+getTopics">getTopics</a>()</code>
</p>
<p>Other PrototypeLDA functions: 
<code><a href="#topic+LDAPrototype">LDAPrototype</a>()</code>,
<code><a href="#topic+getPrototype">getPrototype</a>()</code>
</p>

<hr>
<h2 id='getSimilarity'>Getter for TopicSimilarity</h2><span id='topic+getSimilarity'></span><span id='topic+getRelevantWords'></span><span id='topic+getConsideredWords'></span><span id='topic+getParam.TopicSimilarity'></span>

<h3>Description</h3>

<p>Returns the corresponding element of a <code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimilarity(x)

getRelevantWords(x)

getConsideredWords(x)

## S3 method for class 'TopicSimilarity'
getParam(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSimilarity_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other getter functions: 
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+getSCLOP">getSCLOP</a>()</code>,
<code><a href="#topic+getTopics">getTopics</a>()</code>
</p>
<p>Other TopicSimilarity functions: 
<code><a href="#topic+cosineTopics">cosineTopics</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+jsTopics">jsTopics</a>()</code>,
<code><a href="#topic+rboTopics">rboTopics</a>()</code>
</p>

<hr>
<h2 id='getTopics'>Getter for LDA</h2><span id='topic+getTopics'></span><span id='topic+getAssignments'></span><span id='topic+getDocument_sums'></span><span id='topic+getDocument_expects'></span><span id='topic+getLog.likelihoods'></span><span id='topic+getParam'></span><span id='topic+getK'></span><span id='topic+getAlpha'></span><span id='topic+getEta'></span><span id='topic+getNum.iterations'></span><span id='topic+getEstimators'></span>

<h3>Description</h3>

<p>Returns the corresponding element of a <code><a href="#topic+LDA">LDA</a></code> object.
<code>getEstimators</code> computes the estimators for <code>phi</code> and <code>theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTopics(x)

getAssignments(x)

getDocument_sums(x)

getDocument_expects(x)

getLog.likelihoods(x)

getParam(x)

getK(x)

getAlpha(x)

getEta(x)

getNum.iterations(x)

getEstimators(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTopics_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+LDA">LDA</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimators for <code>phi</code> and <code>theta</code> in
</p>
<p style="text-align: center;"><code class="reqn">w_n^{(m)} \mid T_n^{(m)}, \bm\phi_k  \sim \textsf{Discrete}(\bm\phi_k),</code>
</p>

<p style="text-align: center;"><code class="reqn">\bm\phi_k  \sim \textsf{Dirichlet}(\eta),</code>
</p>

<p style="text-align: center;"><code class="reqn">T_n^{(m)} \mid \bm\theta_m  \sim \textsf{Discrete}(\bm\theta_m),</code>
</p>

<p style="text-align: center;"><code class="reqn">\bm\theta_m  \sim \textsf{Dirichlet}(\alpha)</code>
</p>

<p>are calculated referring to Griffiths and Steyvers (2004) by
</p>
<p style="text-align: center;"><code class="reqn">\hat{\phi}_{k, v} = \frac{n_k^{(v)} + \eta}{n_k + V \eta},</code>
</p>

<p style="text-align: center;"><code class="reqn">\hat{\theta}_{m, k} = \frac{n_k^{(m)} + \alpha}{N^{(m)} + K \alpha}</code>
</p>

<p>with <code class="reqn">V</code> is the vocabulary size, <code class="reqn">K</code> is the number of modeled topics;
<code class="reqn">n_k^{(v)}</code> is the count of assignments of the <code class="reqn">v</code>-th word to
the <code class="reqn">k</code>-th topic. Analogously, <code class="reqn">n_k^{(m)}</code> is the count of assignments
of the <code class="reqn">m</code>-th text to the <code class="reqn">k</code>-th topic. <code class="reqn">N^{(m)}</code> is the total
number of assigned tokens in text <code class="reqn">m</code> and <code class="reqn">n_k</code> the total number of
assigned tokens to topic <code class="reqn">k</code>.
</p>


<h3>References</h3>

<p>Griffiths, Thomas L. and Mark Steyvers (2004). &quot;Finding scientific topics&quot;.
In: <em>Proceedings of the National Academy of Sciences</em> <b>101</b> (suppl 1), pp.5228&ndash;5235,
doi: <a href="https://doi.org/10.1073/pnas.0307752101">10.1073/pnas.0307752101</a>.
</p>


<h3>See Also</h3>

<p>Other getter functions: 
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+getSCLOP">getSCLOP</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>
</p>
<p>Other LDA functions: 
<code><a href="#topic+LDABatch">LDABatch</a>()</code>,
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+LDA">LDA</a>()</code>
</p>

<hr>
<h2 id='jaccardTopics'>Pairwise Jaccard Coefficients</h2><span id='topic+jaccardTopics'></span>

<h3>Description</h3>

<p>Calculates the similarity of all pairwise topic combinations using a modified
Jaccard Coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccardTopics(
  topics,
  limit.rel,
  limit.abs,
  atLeast,
  progress = TRUE,
  pm.backend,
  ncpus
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccardTopics_+3A_topics">topics</code></td>
<td>
<p>[<code>named matrix</code>]<br />
The counts of vocabularies/words (row wise) in topics (column wise).</p>
</td></tr>
<tr><td><code id="jaccardTopics_+3A_limit.rel">limit.rel</code></td>
<td>
<p>[0,1]<br />
A relative lower bound limit for which words are taken into account. Those words
are taken as relevant for a topic that have a count higher than <code>limit.rel</code>
multiplied by the total count of the given topic. Default is <code>1/500</code>.</p>
</td></tr>
<tr><td><code id="jaccardTopics_+3A_limit.abs">limit.abs</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
An absolute lower bound limit for which words are taken into account. All words
are taken as relevant for a topic that have a count higher than <code>limit.abs</code>.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="jaccardTopics_+3A_atleast">atLeast</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
An absolute count of how many words are at least considered as relevant for a topic.
Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jaccardTopics_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown? Turning it off, could lead to significantly
faster calculation. Default is <code>TRUE</code>.
If <code>pm.backend</code> is set, parallelization is done and no progress bar will be shown.</p>
</td></tr>
<tr><td><code id="jaccardTopics_+3A_pm.backend">pm.backend</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;multicore&quot;, &quot;socket&quot; or &quot;mpi&quot;.
If <code>pm.backend</code> is set, <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is
called before computation is started and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code>
is called after.</p>
</td></tr>
<tr><td><code id="jaccardTopics_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of (physical) CPUs to use. If <code>pm.backend</code> is passed,
default is determined by <code><a href="future.html#topic+availableCores">availableCores</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modified Jaccard Coefficient for two topics <code class="reqn">\bm z_{i}</code> and
<code class="reqn">\bm z_{j}</code> is calculated by
</p>
<p style="text-align: center;"><code class="reqn">J_m(\bm z_{i}, \bm z_{j} \mid \bm c) = \frac{\sum_{v = 1}^{V} 1_{\left\{n_{i}^{(v)} &gt; c_i ~\wedge~ n_{j}^{(v)} &gt; c_j\right\}}\left(n_{i}^{(v)}, n_{j}^{(v)}\right)}{\sum_{v = 1}^{V} 1_{\left\{n_{i}^{(v)} &gt; c_i ~\vee~ n_{j}^{(v)} &gt; c_j\right\}}\left(n_{i}^{(v)}, n_{j}^{(v)}\right)}</code>
</p>

<p>with <code class="reqn">V</code> is the vocabulary size and <code class="reqn">n_k^{(v)}</code> is the count of
assignments of the <code class="reqn">v</code>-th word to the <code class="reqn">k</code>-th topic. The threshold vector <code class="reqn">\bm c</code>
is determined by the maximum threshold of the user given lower bounds <code>limit.rel</code>
and <code>limit.abs</code>. In addition, at least <code>atLeast</code> words per topic are
considered for calculation. According to this, if there are less than
<code>atLeast</code> words considered as relevant after applying <code>limit.rel</code>
and <code>limit.abs</code> the <code>atLeast</code> most common words per topic are taken
to determine topic similarities.
</p>
<p>The procedure of determining relevant words is executed for each topic individually.
The values <code>wordslimit</code> and <code>wordsconsidered</code> describes the number
of relevant words per topic.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>sims</code></dt><dd><p>[<code>lower triangular named matrix</code>] with all pairwise
jaccard similarities of the given topics.</p>
</dd>
<dt><code>wordslimit</code></dt><dd><p>[<code>integer</code>] with counts of words determined as
relevant based on <code>limit.rel</code> and <code>limit.abs</code>.</p>
</dd>
<dt><code>wordsconsidered</code></dt><dd><p>[<code>integer</code>] with counts of considered
words for similarity calculation. Could differ from <code>wordslimit</code>, if
<code>atLeast</code> is greater than zero.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter specifications for
<code>type</code> [<code>character(1)</code>] <code>= "Jaccard Coefficient"</code>,
<code>limit.rel</code> [0,1], <code>limit.abs</code> [<code>integer(1)</code>] and
<code>atLeast</code> [<code>integer(1)</code>]. See above for explanation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other TopicSimilarity functions: 
<code><a href="#topic+cosineTopics">cosineTopics</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>,
<code><a href="#topic+jsTopics">jsTopics</a>()</code>,
<code><a href="#topic+rboTopics">rboTopics</a>()</code>
</p>
<p>Other workflow functions: 
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+SCLOP">SCLOP</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getPrototype">getPrototype</a>()</code>,
<code><a href="#topic+mergeTopics">mergeTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
jacc = jaccardTopics(topics, atLeast = 2)
jacc

n1 = getConsideredWords(jacc)
n2 = getRelevantWords(jacc)
(n1 - n2)[n1 - n2 != 0]

sim = getSimilarity(jacc)
dim(sim)

# Comparison to Cosine and Jensen-Shannon (more interesting on large datasets)
cosine = cosineTopics(topics)
js = jsTopics(topics)

sims = list(jaccard = sim, cosine = getSimilarity(cosine), js = getSimilarity(js))
pairs(do.call(cbind, lapply(sims, as.vector)))

</code></pre>

<hr>
<h2 id='jsTopics'>Pairwise Jensen-Shannon Similarities (Divergences)</h2><span id='topic+jsTopics'></span>

<h3>Description</h3>

<p>Calculates the similarity of all pairwise topic combinations using the
Jensen-Shannon Divergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsTopics(topics, epsilon = 1e-06, progress = TRUE, pm.backend, ncpus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsTopics_+3A_topics">topics</code></td>
<td>
<p>[<code>named matrix</code>]<br />
The counts of vocabularies/words (row wise) in topics (column wise).</p>
</td></tr>
<tr><td><code id="jsTopics_+3A_epsilon">epsilon</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Numerical value added to <code>topics</code> to ensure computability. See details.
Default is <code>1e-06</code>.</p>
</td></tr>
<tr><td><code id="jsTopics_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown? Turning it off, could lead to significantly
faster calculation. Default is <code>TRUE</code>.
If <code>pm.backend</code> is set, parallelization is done and no progress bar will be shown.</p>
</td></tr>
<tr><td><code id="jsTopics_+3A_pm.backend">pm.backend</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;multicore&quot;, &quot;socket&quot; or &quot;mpi&quot;.
If <code>pm.backend</code> is set, <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is
called before computation is started and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code>
is called after.</p>
</td></tr>
<tr><td><code id="jsTopics_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of (physical) CPUs to use. If <code>pm.backend</code> is passed,
default is determined by <code><a href="future.html#topic+availableCores">availableCores</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jensen-Shannon Similarity for two topics <code class="reqn">\bm z_{i}</code> and
<code class="reqn">\bm z_{j}</code> is calculated by
</p>
<p style="text-align: center;"><code class="reqn">JS(\bm z_{i}, \bm z_{j}) = 1 - \left( KLD\left(\bm p_i, \frac{\bm p_i + \bm p_j}{2}\right) + KLD\left(\bm p_j, \frac{\bm p_i + \bm p_j}{2}\right) \right)/2</code>
</p>

<p style="text-align: center;"><code class="reqn">= 1 - KLD(\bm p_i, \bm p_i + \bm p_j)/2 - KLD(\bm p_j, \bm p_i + \bm p_j)/2 - \log(2)</code>
</p>

<p>with <code class="reqn">V</code> is the vocabulary size, <code class="reqn">\bm p_k = \left(p_k^{(1)}, ..., p_k^{(V)}\right)</code>,
and <code class="reqn">p_k^{(v)}</code> is the proportion of assignments of the
<code class="reqn">v</code>-th word to the <code class="reqn">k</code>-th topic. KLD defines the Kullback-Leibler
Divergence calculated by
</p>
<p style="text-align: center;"><code class="reqn">KLD(\bm p_{k}, \bm p_{\Sigma}) = \sum_{v=1}^{V} p_k^{(v)} \log{\frac{p_k^{(v)}}{p_{\Sigma}^{(v)}}}.</code>
</p>

<p>There is an <code>epsilon</code> added to every <code class="reqn">n_k^{(v)}</code>, the count
(not proportion) of assignments to ensure computability with respect to zeros.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>sims</code></dt><dd><p>[<code>lower triangular named matrix</code>] with all pairwise
similarities of the given topics.</p>
</dd>
<dt><code>wordslimit</code></dt><dd><p>[<code>integer</code>] = vocabulary size. See
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> for original purpose.</p>
</dd>
<dt><code>wordsconsidered</code></dt><dd><p>[<code>integer</code>] = vocabulary size. See
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> for original purpose.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter specifications for
<code>type</code> [<code>character(1)</code>] <code>= "Cosine Similarity"</code> and
<code>epsilon</code> [<code>numeric(1)</code>]. See above for explanation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other TopicSimilarity functions: 
<code><a href="#topic+cosineTopics">cosineTopics</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+rboTopics">rboTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
js = jsTopics(topics)
js

sim = getSimilarity(js)
dim(sim)

js1 = jsTopics(topics, epsilon = 1)
sim1 = getSimilarity(js1)
summary((sim1-sim)[lower.tri(sim)])
plot(sim, sim1, xlab = "epsilon = 1e-6", ylab = "epsilon = 1")

</code></pre>

<hr>
<h2 id='LDA'>LDA Object</h2><span id='topic+LDA'></span><span id='topic+as.LDA'></span><span id='topic+is.LDA'></span>

<h3>Description</h3>

<p>Constructor for LDA objects used in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDA(
  x,
  param,
  assignments,
  topics,
  document_sums,
  document_expects,
  log.likelihoods
)

as.LDA(
  x,
  param,
  assignments,
  topics,
  document_sums,
  document_expects,
  log.likelihoods
)

is.LDA(obj, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDA_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
Output from <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>. Alternatively each
element can be passed for individual results. Individually set elements
overwrite elements from <code>x</code>.</p>
</td></tr>
<tr><td><code id="LDA_+3A_param">param</code></td>
<td>
<p>[<code>named list</code>]<br />
Parameters of the function call <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>.
List always should contain names &quot;K&quot;, &quot;alpha&quot;, &quot;eta&quot; and &quot;num.iterations&quot;.</p>
</td></tr>
<tr><td><code id="LDA_+3A_assignments">assignments</code></td>
<td>
<p>Individual element for LDA object.</p>
</td></tr>
<tr><td><code id="LDA_+3A_topics">topics</code></td>
<td>
<p>Individual element for LDA object.</p>
</td></tr>
<tr><td><code id="LDA_+3A_document_sums">document_sums</code></td>
<td>
<p>Individual element for LDA object.</p>
</td></tr>
<tr><td><code id="LDA_+3A_document_expects">document_expects</code></td>
<td>
<p>Individual element for LDA object.</p>
</td></tr>
<tr><td><code id="LDA_+3A_log.likelihoods">log.likelihoods</code></td>
<td>
<p>Individual element for LDA object.</p>
</td></tr>
<tr><td><code id="LDA_+3A_obj">obj</code></td>
<td>
<p>[<code>R</code> object]<br />
Object to test.</p>
</td></tr>
<tr><td><code id="LDA_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should test information be given in the console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>LDA</code> and <code>as.LDA</code> do exactly the same. If you call
<code>LDA</code> on an object <code>x</code> which already is of the structure of an
<code>LDA</code> object (in particular a <code>LDA</code> object itself),
the additional arguments <code>param, assignments, ...</code>
may be used to override the specific elements.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] LDA object.
</p>


<h3>See Also</h3>

<p>Other constructor functions: 
<code><a href="#topic+as.LDABatch">as.LDABatch</a>()</code>,
<code><a href="#topic+as.LDARep">as.LDARep</a>()</code>
</p>
<p>Other LDA functions: 
<code><a href="#topic+LDABatch">LDABatch</a>()</code>,
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+getTopics">getTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 1, K = 10)
lda = getLDA(res)

LDA(lda)
# does not change anything

LDA(lda, assignments = NULL)
# creates a new LDA object without the assignments element

LDA(param = getParam(lda), topics = getTopics(lda))
# creates a new LDA object with elements param and topics

</code></pre>

<hr>
<h2 id='LDABatch'>LDA Replications on a Batch System</h2><span id='topic+LDABatch'></span>

<h3>Description</h3>

<p>Performs multiple runs of Latent Dirichlet Allocation on a batch system using
the <code><a href="batchtools.html#topic+batchtools-package">batchtools-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDABatch(
  docs,
  vocab,
  n = 100,
  seeds,
  id = "LDABatch",
  load = FALSE,
  chunk.size = 1,
  resources,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDABatch_+3A_docs">docs</code></td>
<td>
<p>[<code>list</code>]<br />
Documents as received from <code><a href="tosca.html#topic+LDAprep">LDAprep</a></code>.</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_vocab">vocab</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies passed to <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>.
For additional (and necessary) arguments passed, see ellipsis (three-dot argument).</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of Replications.</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_seeds">seeds</code></td>
<td>
<p>[<code>integer(n)</code>]<br />
Random Seeds for each Replication.</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the registry's folder.</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_load">load</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If a folder with name <code>id</code> exists: should the existing registry be loaded?</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_chunk.size">chunk.size</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Requested chunk size for each single chunk. See <code><a href="batchtools.html#topic+chunk">chunk</a></code>.</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_resources">resources</code></td>
<td>
<p>[<code>named list</code>]<br />
Computational resources for the jobs to submit. See <code><a href="batchtools.html#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="LDABatch_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>.
Arguments will be coerced to a vector of length <code>n</code>.
Default parameters are <code>alpha = eta = 1/K</code> and <code>num.iterations = 200</code>.
There is no default for <code>K</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates multiple LDA runs with the possibility of
using a batch system. The integration is done by the
<code><a href="batchtools.html#topic+batchtools-package">batchtools-package</a></code>. After all jobs of the
corresponding registry are terminated, the whole registry can be ported to
your local computer for further analysis.
</p>
<p>The function returns a <code>LDABatch</code> object. You can receive results and
all other elements of this object with getter functions (see <code><a href="#topic+getJob">getJob</a></code>).
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries <code>id</code> for the registry's folder name,
<code>jobs</code> for the submitted jobs' ids and its parameter settings and
<code>reg</code> for the registry itself.
</p>


<h3>See Also</h3>

<p>Other batch functions: 
<code><a href="#topic+as.LDABatch">as.LDABatch</a>()</code>,
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+mergeBatchTopics">mergeBatchTopics</a>()</code>
</p>
<p>Other LDA functions: 
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+LDA">LDA</a>()</code>,
<code><a href="#topic+getTopics">getTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
batch = LDABatch(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 15)
batch
getRegistry(batch)
getJob(batch)
getLDA(batch, 2)

batch2 = LDABatch(docs = reuters_docs, vocab = reuters_vocab, K = 15, chunk.size = 20)
batch2
head(getJob(batch2))

## End(Not run)

</code></pre>

<hr>
<h2 id='LDAPrototype'>Determine the Prototype LDA</h2><span id='topic+LDAPrototype'></span>

<h3>Description</h3>

<p>Performs multiple runs of LDA and computes the Prototype LDA of
this set of LDAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDAPrototype(
  docs,
  vocabLDA,
  vocabMerge = vocabLDA,
  n = 100,
  seeds,
  id = "LDARep",
  pm.backend,
  ncpus,
  limit.rel,
  limit.abs,
  atLeast,
  progress = TRUE,
  keepTopics = FALSE,
  keepSims = FALSE,
  keepLDAs = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDAPrototype_+3A_docs">docs</code></td>
<td>
<p>[<code>list</code>]<br />
Documents as received from <code><a href="tosca.html#topic+LDAprep">LDAprep</a></code>.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_vocablda">vocabLDA</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies passed to <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>.
For additional (and necessary) arguments passed, see ellipsis (three-dot argument).</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_vocabmerge">vocabMerge</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies taken into consideration for merging topic matrices.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of Replications.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_seeds">seeds</code></td>
<td>
<p>[<code>integer(n)</code>]<br />
Random Seeds for each Replication.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the computation.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_pm.backend">pm.backend</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;multicore&quot;, &quot;socket&quot; or &quot;mpi&quot;.
If <code>pm.backend</code> is set, <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is
called before computation is started and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code>
is called after.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of (physical) CPUs to use. If <code>pm.backend</code> is passed,
default is determined by <code><a href="future.html#topic+availableCores">availableCores</a></code>.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_limit.rel">limit.rel</code></td>
<td>
<p>[0,1]<br />
See <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>. Default is <code>1/500</code>.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_limit.abs">limit.abs</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
See <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>. Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_atleast">atLeast</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
See <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown for the steps of <code><a href="#topic+mergeTopics">mergeTopics</a></code>
and <code><a href="#topic+jaccardTopics">jaccardTopics</a></code>? Turning it off, could lead to significantly
faster calculation. Default ist <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_keeptopics">keepTopics</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the merged topic matrix from <code><a href="#topic+mergeTopics">mergeTopics</a></code> be kept?</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_keepsims">keepSims</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the calculated topic similarities matrix from <code><a href="#topic+jaccardTopics">jaccardTopics</a></code> be kept?</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_keepldas">keepLDAs</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the considered LDAs be kept?</p>
</td></tr>
<tr><td><code id="LDAPrototype_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>.
Arguments will be coerced to a vector of length <code>n</code>.
Default parameters are <code>alpha = eta = 1/K</code> and <code>num.iterations = 200</code>.
There is no default for <code>K</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>LDAPrototype</code> marks the overall shortcut for performing
multiple LDA runs and choosing the Prototype of them, <code><a href="#topic+getPrototype">getPrototype</a></code>
just hooks up at determining the Prototype. The generation of multiple LDAs
has to be done before use of <code>getPrototype</code>.
</p>
<p>To save memory a lot of interim calculations are discarded by default.
</p>
<p>If you use parallel computation, no progress bar is shown.
</p>
<p>For details see the details sections of the workflow functions at <code><a href="#topic+getPrototype">getPrototype</a></code>.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>id</code></dt><dd><p>[<code>character(1)</code>] See above.</p>
</dd>
<dt><code>protoid</code></dt><dd><p>[<code>character(1)</code>] Name (ID) of the determined Prototype LDA.</p>
</dd>
<dt><code>lda</code></dt><dd><p>List of <code><a href="#topic+LDA">LDA</a></code> objects of the determined Prototype LDA
and - if <code>keepLDAs</code> is <code>TRUE</code> - all considered LDAs.</p>
</dd>
<dt><code>jobs</code></dt><dd><p>[<code>data.table</code>] with parameter specifications for the LDAs.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter specifications for
<code>limit.rel</code> [0,1], <code>limit.abs</code> [<code>integer(1)</code>] and
<code>atLeast</code> [<code>integer(1)</code>]. See above for explanation.</p>
</dd>
<dt><code>topics</code></dt><dd><p>[<code>named matrix</code>] with the count of vocabularies
(row wise) in topics (column wise).</p>
</dd>
<dt><code>sims</code></dt><dd><p>[<code>lower triangular named matrix</code>] with all pairwise
jaccard similarities of the given topics.</p>
</dd>
<dt><code>wordslimit</code></dt><dd><p>[<code>integer</code>] with counts of words determined as
relevant based on <code>limit.rel</code> and <code>limit.abs</code>.</p>
</dd>
<dt><code>wordsconsidered</code></dt><dd><p>[<code>integer</code>] with counts of considered
words for similarity calculation. Could differ from <code>wordslimit</code>, if
<code>atLeast</code> is greater than zero.</p>
</dd>
<dt><code>sclop</code></dt><dd><p>[<code>symmetrical named matrix</code>] with all pairwise
S-CLOP scores of the given LDA runs.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other shortcut functions: 
<code><a href="#topic+getPrototype">getPrototype</a>()</code>
</p>
<p>Other PrototypeLDA functions: 
<code><a href="#topic+getPrototype">getPrototype</a>()</code>,
<code><a href="#topic+getSCLOP">getSCLOP</a>()</code>
</p>
<p>Other replication functions: 
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+as.LDARep">as.LDARep</a>()</code>,
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+mergeRepTopics">mergeRepTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDAPrototype(docs = reuters_docs, vocabLDA = reuters_vocab,
   n = 4, K = 10, num.iterations = 30)
res
getPrototype(res) # = getLDA(res)
getSCLOP(res)

res = LDAPrototype(docs = reuters_docs, vocabLDA = reuters_vocab,
   n = 4, K = 10, num.iterations = 30, keepLDAs = TRUE)
res
getLDA(res, all = TRUE)
getPrototypeID(res)
getParam(res)

</code></pre>

<hr>
<h2 id='ldaPrototype-package'>ldaPrototype: Prototype of Multiple Latent Dirichlet Allocation Runs</h2><span id='topic+ldaPrototype'></span><span id='topic+ldaPrototype-package'></span>

<h3>Description</h3>

<p>Determine a Prototype from a number of runs of Latent Dirichlet
Allocation (LDA) measuring its similarities with S-CLOP: A procedure to select
the LDA run with highest mean pairwise similarity, which is measured by S-CLOP
(Similarity of multiple sets by Clustering with Local Pruning), to all other
runs. LDA runs are specified by its assignments leading to estimators for
distribution parameters. Repeated runs lead to different results, which we
encounter by choosing the most representative LDA run as prototype.<br />
For bug reports and feature requests please use the issue tracker:
<a href="https://github.com/JonasRieger/ldaPrototype/issues">https://github.com/JonasRieger/ldaPrototype/issues</a>. Also have a look at
the (detailed) example at <a href="https://github.com/JonasRieger/ldaPrototype">https://github.com/JonasRieger/ldaPrototype</a>.
</p>


<h3>Data</h3>

<p><code><a href="#topic+reuters">reuters</a></code> Example Dataset (91 articles from Reuters) for testing.
</p>


<h3>Constructor</h3>

<p><code><a href="#topic+LDA">LDA</a></code> LDA objects used in this package.<br />
<code><a href="#topic+as.LDARep">as.LDARep</a></code> LDARep objects.<br />
<code><a href="#topic+as.LDABatch">as.LDABatch</a></code> LDABatch objects.
</p>


<h3>Getter</h3>

<p><code><a href="#topic+getTopics">getTopics</a></code> Getter for <code><a href="#topic+LDA">LDA</a></code> objects.<br />
<code><a href="#topic+getJob">getJob</a></code> Getter for <code><a href="#topic+LDARep">LDARep</a></code> and <code><a href="#topic+LDABatch">LDABatch</a></code> objects.<br />
<code><a href="#topic+getSimilarity">getSimilarity</a></code> Getter for <code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> objects.<br />
<code><a href="#topic+getSCLOP">getSCLOP</a></code> Getter for <code><a href="#topic+getPrototype">PrototypeLDA</a></code> objects.<br />
<code><a href="#topic+getPrototype">getPrototype</a></code> Determine the Prototype LDA.
</p>


<h3>Performing multiple LDAs</h3>

<p><code><a href="#topic+LDARep">LDARep</a></code> Performing multiple LDAs locally (using parallelization).<br />
<code><a href="#topic+LDABatch">LDABatch</a></code> Performing multiple LDAs on Batch Systems.
</p>


<h3>Calculation Steps (Workflow) to determine the Prototype LDA</h3>

<p><code><a href="#topic+mergeTopics">mergeTopics</a></code> Merge topic matrices from multiple LDAs.<br />
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> Calculate topic similarities using the Jaccard coefficient (see Similarity Measures for other possible measures).<br />
<code><a href="#topic+dendTopics">dendTopics</a></code> Create a dendrogram from topic similarities.<br />
<code><a href="#topic+SCLOP">SCLOP</a></code> Determine various S-CLOP values.<br />
<code><a href="#topic+pruneSCLOP">pruneSCLOP</a></code> Prune <code><a href="#topic+dendTopics">TopicDendrogram</a></code> objects.
</p>


<h3>Similarity Measures</h3>

<p><code><a href="#topic+cosineTopics">cosineTopics</a></code> Cosine Similarity.<br />
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> Jaccard Coefficient.<br />
<code><a href="#topic+jsTopics">jsTopics</a></code> Jensen-Shannon Divergence.<br />
<code><a href="#topic+rboTopics">rboTopics</a></code> rank-biased overlap.
</p>


<h3>Shortcuts</h3>

<p><code><a href="#topic+getPrototype">getPrototype</a></code> Shortcut which includes all calculation steps.<br />
<code><a href="#topic+LDAPrototype">LDAPrototype</a></code> Shortcut which performs multiple LDAs and
determines their Prototype.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jonas Rieger <a href="mailto:jonas.rieger@tu-dortmund.de">jonas.rieger@tu-dortmund.de</a> (<a href="https://orcid.org/0000-0002-0007-4478">ORCID</a>)
</p>


<h3>References</h3>

<p>Rieger, Jonas (2020). &quot;ldaPrototype: A method in R to get a Prototype of multiple Latent
Dirichlet Allocations&quot;. Journal of Open Source Software, <b>5</b>(51), 2181,
doi: <a href="https://doi.org/10.21105/joss.02181">10.21105/joss.02181</a>.
</p>
<p>Rieger, Jonas, Jörg Rahnenführer and Carsten Jentsch (2020).
&quot;Improving Latent Dirichlet Allocation: On Reliability of the Novel Method LDAPrototype&quot;.
In: <em>Natural Language Processing and Information Systems, NLDB 2020.</em> LNCS 12089, pp. 118&ndash;125,
doi: <a href="https://doi.org/10.1007/978-3-030-51310-8_11">10.1007/978-3-030-51310-8_11</a>.
</p>
<p>Rieger, Jonas, Lars Koppers, Carsten Jentsch and Jörg Rahnenführer (2020).
&quot;Improving Reliability of Latent Dirichlet Allocation by Assessing Its Stability using Clustering Techniques on Replicated Runs&quot;.
arXiv 2003.04980, URL <a href="https://arxiv.org/abs/2003.04980">https://arxiv.org/abs/2003.04980</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/JonasRieger/ldaPrototype">https://github.com/JonasRieger/ldaPrototype</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/JonasRieger/ldaPrototype/issues">https://github.com/JonasRieger/ldaPrototype/issues</a>
</p>
</li></ul>


<hr>
<h2 id='LDARep'>LDA Replications</h2><span id='topic+LDARep'></span>

<h3>Description</h3>

<p>Performs multiple runs of Latent Dirichlet Allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDARep(docs, vocab, n = 100, seeds, id = "LDARep", pm.backend, ncpus, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDARep_+3A_docs">docs</code></td>
<td>
<p>[<code>list</code>]<br />
Documents as received from <code><a href="tosca.html#topic+LDAprep">LDAprep</a></code>.</p>
</td></tr>
<tr><td><code id="LDARep_+3A_vocab">vocab</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies passed to <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>.
For additional (and necessary) arguments passed, see ellipsis (three-dot argument).</p>
</td></tr>
<tr><td><code id="LDARep_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of Replications.</p>
</td></tr>
<tr><td><code id="LDARep_+3A_seeds">seeds</code></td>
<td>
<p>[<code>integer(n)</code>]<br />
Random Seeds for each Replication.</p>
</td></tr>
<tr><td><code id="LDARep_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the computation.</p>
</td></tr>
<tr><td><code id="LDARep_+3A_pm.backend">pm.backend</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;multicore&quot;, &quot;socket&quot; or &quot;mpi&quot;.
If <code>pm.backend</code> is set, <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is
called before computation is started and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code>
is called after.</p>
</td></tr>
<tr><td><code id="LDARep_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of (physical) CPUs to use. If <code>pm.backend</code> is passed,
default is determined by <code><a href="future.html#topic+availableCores">availableCores</a></code>.</p>
</td></tr>
<tr><td><code id="LDARep_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code>.
Arguments will be coerced to a vector of length <code>n</code>.
Default parameters are <code>alpha = eta = 1/K</code> and <code>num.iterations = 200</code>.
There is no default for <code>K</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates multiple LDA runs with the possibility of
using parallelization. The integration is done by the
<code><a href="parallelMap.html#topic+parallelMap">parallelMap-package</a></code>.
</p>
<p>The function returns a <code>LDARep</code> object. You can receive results and
all other elements of this object with getter functions (see <code><a href="#topic+getJob">getJob</a></code>).
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries <code>id</code> for computation's name,
<code>jobs</code> for the parameter settings and <code>lda</code> for the results itself.
</p>


<h3>See Also</h3>

<p>Other replication functions: 
<code><a href="#topic+LDAPrototype">LDAPrototype</a>()</code>,
<code><a href="#topic+as.LDARep">as.LDARep</a>()</code>,
<code><a href="#topic+getJob">getJob</a>()</code>,
<code><a href="#topic+mergeRepTopics">mergeRepTopics</a>()</code>
</p>
<p>Other LDA functions: 
<code><a href="#topic+LDABatch">LDABatch</a>()</code>,
<code><a href="#topic+LDA">LDA</a>()</code>,
<code><a href="#topic+getTopics">getTopics</a>()</code>
</p>
<p>Other workflow functions: 
<code><a href="#topic+SCLOP">SCLOP</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getPrototype">getPrototype</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+mergeTopics">mergeTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, seeds = 1:4,
   id = "myComputation", K = 7:10, alpha = 1, eta = 0.01, num.iterations = 20)
res
getJob(res)
getID(res)
getLDA(res, 4)


LDARep(docs = reuters_docs, vocab = reuters_vocab,
   K = 10, num.iterations = 100, pm.backend = "socket")


</code></pre>

<hr>
<h2 id='mergeBatchTopics'>Merge LDA Topic Matrices</h2><span id='topic+mergeBatchTopics'></span><span id='topic+mergeBatchTopics.LDABatch'></span><span id='topic+mergeBatchTopics.default'></span>

<h3>Description</h3>

<p>Collects LDA results from a given registry and merges their topic matrices for
a given set of vocabularies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeBatchTopics(...)

## S3 method for class 'LDABatch'
mergeBatchTopics(x, vocab, progress = TRUE, ...)

## Default S3 method:
mergeBatchTopics(vocab, reg, job, id, progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeBatchTopics_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="mergeBatchTopics_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+LDABatch">LDABatch</a></code> object. Alternatively <code>job</code>, <code>reg</code> and
<code>id</code> can be passed or their defaults are taken.</p>
</td></tr>
<tr><td><code id="mergeBatchTopics_+3A_vocab">vocab</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies taken into consideration for merging topic matrices. Default is
the vocabulary of the first LDA.</p>
</td></tr>
<tr><td><code id="mergeBatchTopics_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown? Turning it off, could lead to significantly
faster calculation. Default ist <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mergeBatchTopics_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="batchtools.html#topic+makeRegistry">Registry</a></code>]<br />
Registry. See <code><a href="batchtools.html#topic+reduceResultsList">reduceResultsList</a></code>.</p>
</td></tr>
<tr><td><code id="mergeBatchTopics_+3A_job">job</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A data.frame or data.table with a column named &quot;job.id&quot; or a vector of integerish job ids.
See <code><a href="batchtools.html#topic+reduceResultsList">reduceResultsList</a></code>.</p>
</td></tr>
<tr><td><code id="mergeBatchTopics_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A name for the registry. If not passed, the folder's name is extracted from <code>reg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details and examples see <code><a href="#topic+mergeTopics">mergeTopics</a></code>.
</p>


<h3>Value</h3>

<p>[<code>named matrix</code>] with the count of vocabularies (row wise) in topics (column wise).
</p>


<h3>See Also</h3>

<p>Other merge functions: 
<code><a href="#topic+mergeRepTopics">mergeRepTopics</a>()</code>,
<code><a href="#topic+mergeTopics">mergeTopics</a>()</code>
</p>
<p>Other batch functions: 
<code><a href="#topic+LDABatch">LDABatch</a>()</code>,
<code><a href="#topic+as.LDABatch">as.LDABatch</a>()</code>,
<code><a href="#topic+getJob">getJob</a>()</code>
</p>

<hr>
<h2 id='mergeRepTopics'>Merge LDA Topic Matrices</h2><span id='topic+mergeRepTopics'></span><span id='topic+mergeRepTopics.LDARep'></span><span id='topic+mergeRepTopics.default'></span>

<h3>Description</h3>

<p>Collects LDA results from a list of replicated runs and merges their topic
matrices for a given set of vocabularies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeRepTopics(...)

## S3 method for class 'LDARep'
mergeRepTopics(x, vocab, progress = TRUE, ...)

## Default S3 method:
mergeRepTopics(lda, vocab, id, progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeRepTopics_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="mergeRepTopics_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+LDARep">LDARep</a></code> object. Alternatively <code>lda</code> and <code>id</code> can be passed.</p>
</td></tr>
<tr><td><code id="mergeRepTopics_+3A_vocab">vocab</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies taken into consideration for merging topic matrices. Default is
the vocabulary of the first LDA.</p>
</td></tr>
<tr><td><code id="mergeRepTopics_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown? Turning it off, could lead to significantly
faster calculation. Default ist <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mergeRepTopics_+3A_lda">lda</code></td>
<td>
<p>[<code>named list</code>]<br />
List of <code><a href="#topic+LDA">LDA</a></code> objects, named by the corresponding &quot;job.id&quot;.</p>
</td></tr>
<tr><td><code id="mergeRepTopics_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the computation. Default is &quot;LDARep&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details and examples see <code><a href="#topic+mergeTopics">mergeTopics</a></code>.
</p>


<h3>Value</h3>

<p>[<code>named matrix</code>] with the count of vocabularies (row wise) in topics (column wise).
</p>


<h3>See Also</h3>

<p>Other merge functions: 
<code><a href="#topic+mergeBatchTopics">mergeBatchTopics</a>()</code>,
<code><a href="#topic+mergeTopics">mergeTopics</a>()</code>
</p>
<p>Other replication functions: 
<code><a href="#topic+LDAPrototype">LDAPrototype</a>()</code>,
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+as.LDARep">as.LDARep</a>()</code>,
<code><a href="#topic+getJob">getJob</a>()</code>
</p>

<hr>
<h2 id='mergeTopics'>Merge LDA Topic Matrices</h2><span id='topic+mergeTopics'></span>

<h3>Description</h3>

<p>Generic function, which collects LDA results and merges their topic matrices
for a given set of vocabularies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeTopics(x, vocab, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTopics_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+LDARep">LDARep</a></code> or <code><a href="#topic+LDABatch">LDABatch</a></code> object.</p>
</td></tr>
<tr><td><code id="mergeTopics_+3A_vocab">vocab</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies taken into consideration for merging topic matrices.</p>
</td></tr>
<tr><td><code id="mergeTopics_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown? Turning it off, could lead to significantly
faster calculation. Default ist <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the function <code><a href="#topic+mergeRepTopics">mergeRepTopics</a></code> or
<code><a href="#topic+mergeBatchTopics">mergeBatchTopics</a></code>. The topic matrices are transponed and cbinded,
so that the resulting matrix contains the counts of vocabularies/words (row wise)
in topics (column wise).
</p>


<h3>Value</h3>

<p>[<code>named matrix</code>] with the count of vocabularies (row wise) in topics (column wise).
</p>


<h3>See Also</h3>

<p>Other merge functions: 
<code><a href="#topic+mergeBatchTopics">mergeBatchTopics</a>()</code>,
<code><a href="#topic+mergeRepTopics">mergeRepTopics</a>()</code>
</p>
<p>Other workflow functions: 
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+SCLOP">SCLOP</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getPrototype">getPrototype</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
dim(topics)
length(reuters_vocab)

## Not run: 
res = LDABatch(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
dim(topics)
length(reuters_vocab)

## End(Not run)
</code></pre>

<hr>
<h2 id='pruneSCLOP'>Local Pruning State of Topic Dendrograms</h2><span id='topic+pruneSCLOP'></span><span id='topic+plot.PruningSCLOP'></span><span id='topic+pruning.par'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+SCLOP">SCLOP</a></code> calculates the S-CLOP value for the best possible
local pruning state of a dendrogram from <code><a href="#topic+dendTopics">dendTopics</a></code>.
The function <code>pruneSCLOP</code> supplies the corresponding pruning state itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruneSCLOP(dend)

## S3 method for class 'PruningSCLOP'
plot(x, dend, pruning.par, ...)

pruning.par(pruning)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneSCLOP_+3A_dend">dend</code></td>
<td>
<p>[<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>]<br />
<code><a href="#topic+dendTopics">TopicDendrogram</a></code>
(and <code><a href="stats.html#topic+dendrogram">dendrogram</a></code>) object of all considered topics as the
output from <code><a href="#topic+dendTopics">dendTopics</a></code>.</p>
</td></tr>
<tr><td><code id="pruneSCLOP_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="pruneSCLOP_+3A_pruning.par">pruning.par</code></td>
<td>
<p>[<code>list</code>]<br />
List of parameters to mark the pruning. See section &quot;Details&quot; at <code><a href="#topic+dendTopics">dendTopics</a></code>
for default parameters. Types for marking the pruning state are <code>"abline"</code>,
<code>"color"</code> and <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="pruneSCLOP_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="pruneSCLOP_+3A_pruning">pruning</code></td>
<td>
<p>[<code>list of <a href="stats.html#topic+dendrogram">dendrogram</a>s</code>]<br />
<code><a href="#topic+pruneSCLOP">PruningSCLOP</a></code> object specifying the best possible
local pruning state.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of computing the S-CLOP values see <code><a href="#topic+SCLOP">SCLOP</a></code>.
</p>
<p>For details and examples of plotting the pruning state see <code><a href="#topic+dendTopics">dendTopics</a></code>.
</p>


<h3>Value</h3>

<p>[<code>list of <a href="stats.html#topic+dendrogram">dendrogram</a>s</code>]
<code><a href="#topic+pruneSCLOP">PruningSCLOP</a></code> object specifying the best possible
local pruning state.
</p>


<h3>See Also</h3>

<p>Other plot functions: 
<code><a href="#topic+dendTopics">dendTopics</a>()</code>
</p>
<p>Other SCLOP functions: 
<code><a href="#topic+SCLOP">SCLOP</a>()</code>
</p>

<hr>
<h2 id='rboTopics'>Pairwise RBO Similarities</h2><span id='topic+rboTopics'></span>

<h3>Description</h3>

<p>Calculates the similarity of all pairwise topic combinations using the
rank-biased overlap (RBO) Similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rboTopics(topics, k, p, progress = TRUE, pm.backend, ncpus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rboTopics_+3A_topics">topics</code></td>
<td>
<p>[<code>named matrix</code>]<br />
The counts of vocabularies/words (row wise) in topics (column wise).</p>
</td></tr>
<tr><td><code id="rboTopics_+3A_k">k</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximum depth for evaluation. Words down to this rank are considered for the calculation of similarities.</p>
</td></tr>
<tr><td><code id="rboTopics_+3A_p">p</code></td>
<td>
<p>[0,1]<br />
Weighting parameter. Lower values emphasizes top ranked words while values
that go towards 1 correspond to equal weights for each evaluation depth.</p>
</td></tr>
<tr><td><code id="rboTopics_+3A_progress">progress</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a nice progress bar be shown? Turning it off, could lead to significantly
faster calculation. Default is <code>TRUE</code>.
If <code>pm.backend</code> is set, parallelization is done and no progress bar will be shown.</p>
</td></tr>
<tr><td><code id="rboTopics_+3A_pm.backend">pm.backend</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;multicore&quot;, &quot;socket&quot; or &quot;mpi&quot;.
If <code>pm.backend</code> is set, <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is
called before computation is started and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code>
is called after.</p>
</td></tr>
<tr><td><code id="rboTopics_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of (physical) CPUs to use. If <code>pm.backend</code> is passed,
default is determined by <code><a href="future.html#topic+availableCores">availableCores</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RBO Similarity for two topics <code class="reqn">\bm z_{i}</code> and <code class="reqn">\bm z_{j}</code>
is calculated by
</p>
<p style="text-align: center;"><code class="reqn">RBO(\bm z_{i}, \bm z_{j} \mid k, p) = 2p^k\frac{\left|Z_{i}^{(k)} \cap Z_{j}^{(k)}\right|}{\left|Z_{i}^{(k)}\right| + \left|Z_{j}^{(k)}\right|} + \frac{1-p}{p} \sum_{d=1}^k 2 p^d\frac{\left|Z_{i}^{(d)} \cap Z_{j}^{(d)}\right|}{\left|Z_{i}^{(d)}\right| + \left|Z_{j}^{(d)}\right|}</code>
</p>

<p>with <code class="reqn">Z_{i}^{(d)}</code> is the vocabulary set of topic <code class="reqn">\bm z_{i}</code> down to
rank <code class="reqn">d</code>. Ties in ranks are resolved by taking the minimum.
</p>
<p>The value <code>wordsconsidered</code> describes the number of words per topic
ranked at rank <code class="reqn">k</code> or above.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>sims</code></dt><dd><p>[<code>lower triangular named matrix</code>] with all pairwise
similarities of the given topics.</p>
</dd>
<dt><code>wordslimit</code></dt><dd><p>[<code>integer</code>] = vocabulary size. See
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> for original purpose.</p>
</dd>
<dt><code>wordsconsidered</code></dt><dd><p>[<code>integer</code>] = vocabulary size. See
<code><a href="#topic+jaccardTopics">jaccardTopics</a></code> for original purpose.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter
<code>type</code> [<code>character(1)</code>] <code>= "RBO Similarity"</code>,
<code>k</code> [<code>integer(1)</code>] and <code>p</code> [0,1]. See above for explanation.</p>
</dd>
</dl>



<h3>References</h3>

<p>Webber, William, Alistair Moffat and Justin Zobel (2010).
&quot;A similarity measure for indefinite rankings&quot;.
In: <em>ACM Transations on Information Systems</em> 28(4), p.20:1–-20:38,
DOI 10.1145/1852102.1852106,
URL <a href="https://doi.acm.org/10.1145/1852102.1852106">https://doi.acm.org/10.1145/1852102.1852106</a>
</p>


<h3>See Also</h3>

<p>Other TopicSimilarity functions: 
<code><a href="#topic+cosineTopics">cosineTopics</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getSimilarity">getSimilarity</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+jsTopics">jsTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
rbo = rboTopics(topics, k = 12, p = 0.9)
rbo

sim = getSimilarity(rbo)
dim(sim)

</code></pre>

<hr>
<h2 id='reuters'>A Snippet of the Reuters Dataset</h2><span id='topic+reuters'></span><span id='topic+reuters_docs'></span><span id='topic+reuters_vocab'></span><span id='topic+docs'></span><span id='topic+vocab'></span>

<h3>Description</h3>

<p>Example Dataset from Reuters consisting of 91 articles. It can be used to
familiarize with the bunch of functions offered by this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(reuters_docs)

data(reuters_vocab)
</code></pre>


<h3>Format</h3>

<p><code>reuters_docs</code> is a list of documents of length 91 prepared by <code><a href="tosca.html#topic+LDAprep">LDAprep</a></code>.
</p>
<p><code>reuters_vocab</code> is
</p>
<p>An object of class <code>character</code> of length 2141.
</p>


<h3>Source</h3>

<p>temporarily unavailable: http://ronaldo.cs.tcd.ie/esslli07/data/reuters21578-xml/
</p>


<h3>References</h3>

<p>Lewis, David (1997). <em>Reuters-21578 Text Categorization Collection Distribution 1.0</em>.
<a href="http://kdd.ics.uci.edu/databases/reuters21578/reuters21578.html">http://kdd.ics.uci.edu/databases/reuters21578/reuters21578.html</a>
</p>
<p>Luz, Saturnino. <em>XML-encoded version of Reuters-21578</em>.
http://ronaldo.cs.tcd.ie/esslli07/data/reuters21578-xml/ (temporarily unavailable)
</p>

<hr>
<h2 id='SCLOP'>Similarity/Stability of multiple sets of Objects using Clustering with Local Pruning</h2><span id='topic+SCLOP'></span><span id='topic+disparitySum'></span><span id='topic+SCLOP.pairwise'></span>

<h3>Description</h3>

<p>The function <code>SCLOP</code> calculates the S-CLOP value for the best possible
local pruning state of a dendrogram from <code><a href="#topic+dendTopics">dendTopics</a></code>.
The function <code><a href="#topic+pruneSCLOP">pruneSCLOP</a></code> supplies the corresponding pruning state itself.<br />
To get all pairwise S-CLOP scores of two LDA runs, the function <code>SCLOP.pairwise</code>
can be used. It returns a matrix of the pairwise S-CLOP scores.<br />
All three functions use the function <code>disparitySum</code> to calculate the
least possible sum of disparities (on the best possible local pruning state)
on a given dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCLOP(dend)

disparitySum(dend)

SCLOP.pairwise(sims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCLOP_+3A_dend">dend</code></td>
<td>
<p>[<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>]<br />
Output from <code><a href="#topic+dendTopics">dendTopics</a></code>.</p>
</td></tr>
<tr><td><code id="SCLOP_+3A_sims">sims</code></td>
<td>
<p>[<code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> object
or <code>lower triangular named matrix</code>]<br />
<code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> object or
pairwise jaccard similarities of underlying topics as the <code>sims</code> element
from <code><a href="#topic+jaccardTopics">TopicSimilarity</a></code> objects. The topic names should be
formatted as &lt;<em>Run X</em>&gt;.&lt;<em>Topic Y</em>&gt;, so that the name before the
first dot identifies the LDA run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one specific cluster <code class="reqn">g</code> and <code class="reqn">R</code> LDA Runs the disparity is calculated by
</p>
<p style="text-align: center;"><code class="reqn">U(g) := \frac{1}{R} \sum_{r=1}^R \vert t_r^{(g)} - 1 \vert \cdot \sum_{r=1}^R t_r^{(g)},</code>
</p>

<p>while <code class="reqn">\bm t^{(g)} = (t_1^{(g)}, ..., t_R^{(g)})^T</code>
contains the number of topics that belong to the different LDA runs and that
occur in cluster <code class="reqn">g</code>.
</p>
<p>The function <code>disparitySum</code> returns the least possible sum of disparities
<code class="reqn">U_{\Sigma}(G^*)</code> for the best possible pruning state <code class="reqn">G^*</code>
with <code class="reqn">U_{\Sigma}(G) = \sum_{g \in G} U(g) \to \min</code>.
The highest possible value for <code class="reqn">U_{\Sigma}(G^*)</code> is limited by
</p>
<p style="text-align: center;"><code class="reqn">U_{\Sigma,\textsf{max}} := \sum_{g \in \tilde{G}} U(g) = N \cdot \frac{R-1}{R},</code>
</p>

<p>with <code class="reqn">\tilde{G}</code> denotes the corresponding worst case pruning state. This worst
case scenario is useful for normalizing the SCLOP scores.
</p>
<p>The function <code>SCLOP</code> then calculates the value
</p>
<p style="text-align: center;"><code class="reqn">\textsf{S-CLOP}(G^*) := 1 - \frac{1}{U_{\Sigma,\textsf{max}}} \cdot \sum_{g \in G^*} U(g) ~\in [0,1],</code>
</p>

<p>where <code class="reqn">\sum\limits_{g \in G^*} U(g) = U_{\Sigma}(G^*)</code>.
</p>


<h3>Value</h3>


<dl>
<dt><code>SCLOP</code></dt><dd><p>[0,1] value specifying the S-CLOP for the best possible
local pruning state of the given dendrogram.</p>
</dd>
<dt><code>disparitySum</code></dt><dd><p>[<code>numeric(1)</code>] value specifying the least
possible sum of disparities on the given dendrogram.</p>
</dd>
<dt><code>SCLOP.pairwise</code></dt><dd><p>[<code>symmetrical named matrix</code>] with all
pairwise S-CLOP scores of the given LDA runs.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other SCLOP functions: 
<code><a href="#topic+pruneSCLOP">pruneSCLOP</a>()</code>
</p>
<p>Other workflow functions: 
<code><a href="#topic+LDARep">LDARep</a>()</code>,
<code><a href="#topic+dendTopics">dendTopics</a>()</code>,
<code><a href="#topic+getPrototype">getPrototype</a>()</code>,
<code><a href="#topic+jaccardTopics">jaccardTopics</a>()</code>,
<code><a href="#topic+mergeTopics">mergeTopics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res = LDARep(docs = reuters_docs, vocab = reuters_vocab, n = 4, K = 10, num.iterations = 30)
topics = mergeTopics(res, vocab = reuters_vocab)
jacc = jaccardTopics(topics, atLeast = 2)
dend = dendTopics(jacc)

SCLOP(dend)
disparitySum(dend)

SCLOP.pairwise(jacc)
SCLOP.pairwise(getSimilarity(jacc))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
