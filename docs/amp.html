<!DOCTYPE html><html><head><title>Help for package amp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {amp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accept_rate'><p>Estimate the local acceptance rate</p></a></li>
<li><a href='#add_oth_pvals'><p>Add Other p-values</p></a></li>
<li><a href='#calc_gam_star'><p>A helper function for <code>mv_pn_test</code>, calculating the test statistic</p>
for both the vector of parameter estimates, and the draws from
the corresponding estimated limiting distribution.</a></li>
<li><a href='#est_pows'><p>A helper function to estimate the power using the generated test statistic,</p>
and estimated distribution of the test statistic.</a></li>
<li><a href='#find_mag'><p>A helper function to find the multiplicative distance of a specified</p>
alternative from the alternative in the same direction that obtains
a power of 80%.</a></li>
<li><a href='#gen_boot_sample'><p>A helper function to generate a multiplier bootstrap sample</p></a></li>
<li><a href='#get_test_stat'><p>Helper function for the Zhang and Laber test.</p></a></li>
<li><a href='#ic.data.examp'><p>Function for calculating the influence function used for</p>
the real data example.</a></li>
<li><a href='#ic.pearson'><p>Pearson Correlation IC and estimate</p></a></li>
<li><a href='#ic.proj.rr'><p>Estimate both the parameter, and the influence</p>
curves used for estimating the projected risk ratio. The first column
of your data should correspond to the variable of interest.</a></li>
<li><a href='#ic.proj.rr.nolas'><p>Estimate both the parameter, and or the influence</p>
curves used for estimating the projected risk ratio (not using lasso).
The first column of your data should correspond to the variable of interest.</a></li>
<li><a href='#l_p_norm'><p>A function used to calculate various L_p norms</p></a></li>
<li><a href='#look_IC'><p>This a function used to look at the IC.</p></a></li>
<li><a href='#mag_for_pow'><p>This function is used to estimate the magnitude needed for a</p>
certain direction to achieve 80% power for a proposed alternative.</a></li>
<li><a href='#make_data'><p>Generate data using one of the four specified models</p>
from MCKEAGUE and QIAN paper</a></li>
<li><a href='#mv_pn_test'><p>Runs a multivariate point null test. This function returns</p>
an approximate p-value for the specified test statistic.</a></li>
<li><a href='#pval_for_mag'><p>A helper function that calculates the estimated p-value for a given</p>
observed alternative and a given norm.</a></li>
<li><a href='#rr.msm.ic'><p>Estimate both the parameter, and the influence</p>
curves used for estimating the projected risk ratio from a working
marginal structural mean model.</a></li>
<li><a href='#rr.msm.jn.ic'><p>Estimate both the parameter, and the influence</p>
curves used for estimating the projected risk ratio from a working
marginal structural mean model.  This function only uses elastic net
for the estimation (rather than also using other learners).</a></li>
<li><a href='#test.control'><p>Control function for the adaptive norm test</p></a></li>
<li><a href='#ZL'><p>Carry out a simplified version of the Zhang and Laber test.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Test for the Multivariate Point Null Hypotheses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A testing framework for testing the multivariate point null hypothesis. 
    A testing framework described in Elder et al. (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2203.01897">doi:10.48550/arXiv.2203.01897</a>&gt; to test the multivariate point null hypothesis.  After the user selects a parameter of interest and defines the assumed data generating mechanism, this information should be encoded in functions for the parameter estimator and its corresponding influence curve. Some parameter and data generating mechanism combinations have codings in this package, and are explained in detail in the article.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adam-s-elder/amp/issues">https://github.com/adam-s-elder/amp/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, stats, SuperLearner, glmnet, dplyr, rlang, ggplot2,
tidyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-25 16:00:34 UTC; adamelder</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Elder <a href="https://orcid.org/0000-0003-1665-2639"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Marco Carone <a href="https://orcid.org/0000-0003-2106-0953"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths],
  Alex Luedtke <a href="https://orcid.org/0000-0002-9936-3236"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Elder &lt;shmelder@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-06 07:32:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='accept_rate'>Estimate the local acceptance rate</h2><span id='topic+accept_rate'></span>

<h3>Description</h3>

<p>This a helper function used to estimate the acceptance rate for a
simple norm based test under a sequence of local alternatives in
a given direction given the estimated limiting distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accept_rate(mc_limit_dstr, dir, null_quants, norms_idx = 2, norm_type = "lp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accept_rate_+3A_mc_limit_dstr">mc_limit_dstr</code></td>
<td>
<p>MC draws from an estimate of the
(centered) limiting distribution. Data where columns correspond
to different covariates, and rows are independent observations.</p>
</td></tr>
<tr><td><code id="accept_rate_+3A_dir">dir</code></td>
<td>
<p>a vector in the direction for which we wish to estimate power.</p>
</td></tr>
<tr><td><code id="accept_rate_+3A_null_quants">null_quants</code></td>
<td>
<p>the cutoff values for the distribution under the null
for each lp norm.</p>
</td></tr>
<tr><td><code id="accept_rate_+3A_norms_idx">norms_idx</code></td>
<td>
<p>the index of the norms to be used (ideally integers).</p>
</td></tr>
<tr><td><code id="accept_rate_+3A_norm_type">norm_type</code></td>
<td>
<p>string indicating the class of norms to select over
(sum of squares (&quot;ssq&quot;) or lp norms (&quot;lp&quot;) are currently supported).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated acceptance rate for the specified norm-based test
for a given local alternative.
</p>

<hr>
<h2 id='add_oth_pvals'>Add Other p-values</h2><span id='topic+add_oth_pvals'></span>

<h3>Description</h3>

<p>Add pvalues for the Liu and Xie and Bonferroni based
tests using the estimated parameter estimates and
corresponding standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_oth_pvals(test_result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_oth_pvals_+3A_test_result">test_result</code></td>
<td>
<p>The test result from mv_pn_test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same test result object with additional p-values for
the Liu and Xie (2021) test (liu_xie_pvalue) and the Bonferroni based
test (bonf_pvalue)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: More monte-carlo samples should be taken are taken here.  This is
## only done to lower computation time.
set.seed(10)
test &lt;- mv_pn_test(data.frame(y = rnorm(100), x = rnorm(100)),
                   ic.pearson, test.control(n_peld_mc_samples = 20,
                                            ts_ld_bs_samp = 20))
test_with_extra &lt;- add_oth_pvals(test)
test_with_extra[c("pvalue", "liu_xie_pvalue", "bonf_pvalue")]
</code></pre>

<hr>
<h2 id='calc_gam_star'>A helper function for <code>mv_pn_test</code>, calculating the test statistic
for both the vector of parameter estimates, and the draws from
the corresponding estimated limiting distribution.</h2><span id='topic+calc_gam_star'></span>

<h3>Description</h3>

<p>A helper function for <code>mv_pn_test</code>, calculating the test statistic
for both the vector of parameter estimates, and the draws from
the corresponding estimated limiting distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_gam_star(obs_data, param_est, control, lm_dst = NULL, return_lmd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_gam_star_+3A_obs_data">obs_data</code></td>
<td>
<p>The observed data used to calculate the test statistic.
Each row is an observation and each column corresponds to either the
outcome (first column) or a covariate.</p>
</td></tr>
<tr><td><code id="calc_gam_star_+3A_param_est">param_est</code></td>
<td>
<p>A function used to estimate both they parameter of interest
and the IC of the corresponding estimator.</p>
</td></tr>
<tr><td><code id="calc_gam_star_+3A_control">control</code></td>
<td>
<p>A list providing control arguments for the function.</p>
</td></tr>
<tr><td><code id="calc_gam_star_+3A_lm_dst">lm_dst</code></td>
<td>
<p>A list containing an estimate of the limiting distribution and
corresponding norm specific test cutoffs if it is provided.</p>
</td></tr>
<tr><td><code id="calc_gam_star_+3A_return_lmd">return_lmd</code></td>
<td>
<p>Boolean for whether to return the estimated
limiting distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculated test statistic for the given data.
</p>

<hr>
<h2 id='est_pows'>A helper function to estimate the power using the generated test statistic,
and estimated distribution of the test statistic.</h2><span id='topic+est_pows'></span>

<h3>Description</h3>

<p>A helper function to estimate the power using the generated test statistic,
and estimated distribution of the test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_pows(tr_lm_dstr, ts_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_pows_+3A_tr_lm_dstr">tr_lm_dstr</code></td>
<td>
<p>limiting distribution of the test statistic</p>
</td></tr>
<tr><td><code id="est_pows_+3A_ts_vec">ts_vec</code></td>
<td>
<p>Vector containing the test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the estimated power of the test based for
each of the possible sum of squares norms
</p>

<hr>
<h2 id='find_mag'>A helper function to find the multiplicative distance of a specified
alternative from the alternative in the same direction that obtains
a power of 80%.</h2><span id='topic+find_mag'></span>

<h3>Description</h3>

<p>A helper function to find the multiplicative distance of a specified
alternative from the alternative in the same direction that obtains
a power of 80%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_mag(one_obs, dir, cutoff, nrm_idx, nrm_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_mag_+3A_one_obs">one_obs</code></td>
<td>
<p>A single observed value from the limiting distribution.</p>
</td></tr>
<tr><td><code id="find_mag_+3A_dir">dir</code></td>
<td>
<p>The shift by which the single observation will moved.  Generally
the estimated parameter.</p>
</td></tr>
<tr><td><code id="find_mag_+3A_cutoff">cutoff</code></td>
<td>
<p>The cutoff value of the normed limiting distribution. The
estimated parameters which will be the mean of the multiplier bootstrap
sample.</p>
</td></tr>
<tr><td><code id="find_mag_+3A_nrm_idx">nrm_idx</code></td>
<td>
<p>index of the potential norms to be used.</p>
</td></tr>
<tr><td><code id="find_mag_+3A_nrm_type">nrm_type</code></td>
<td>
<p>specifies the type of norm to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The magnitude by which the shift must be multiplied to surpass the
cutoff for the given observation.
</p>

<hr>
<h2 id='gen_boot_sample'>A helper function to generate a multiplier bootstrap sample</h2><span id='topic+gen_boot_sample'></span>

<h3>Description</h3>

<p>A helper function to generate a multiplier bootstrap sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_boot_sample(epsilon_mat, obs_ic, center = TRUE, param_est = 0, rate = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_boot_sample_+3A_epsilon_mat">epsilon_mat</code></td>
<td>
<p>The matrix of Normal observations with independent
observations from a normal with an identity Covariance matrix.</p>
</td></tr>
<tr><td><code id="gen_boot_sample_+3A_obs_ic">obs_ic</code></td>
<td>
<p>The empirical estimate of the influence curve to be
used in the multiplier bootstrap.</p>
</td></tr>
<tr><td><code id="gen_boot_sample_+3A_center">center</code></td>
<td>
<p>Boolean.  If true, the bootstrapped data will be centered at
zero.  Otherwise, it will be centered at param_est.</p>
</td></tr>
<tr><td><code id="gen_boot_sample_+3A_param_est">param_est</code></td>
<td>
<p>The estimated parameters which will be the mean of the
multiplier bootstrap sample.</p>
</td></tr>
<tr><td><code id="gen_boot_sample_+3A_rate">rate</code></td>
<td>
<p>Normalizing constant. Should either be <code>"n"</code> or
<code>"rootn"</code>.</p>
</td></tr>
<tr><td><code id="gen_boot_sample_+3A_n">n</code></td>
<td>
<p>Number of desired observations from your bootstrapped sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sample of size <code>n</code> generated using a multiplier bootstrap
with a variance given by t(<code>obs_ic</code>)
</p>

<hr>
<h2 id='get_test_stat'>Helper function for the Zhang and Laber test.</h2><span id='topic+get_test_stat'></span>

<h3>Description</h3>

<p>Helper function for the Zhang and Laber test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_test_stat(obs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_test_stat_+3A_obs_data">obs_data</code></td>
<td>
<p>The observed data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the estimated t-statistics for the Zhang and Laber tests.
</p>

<hr>
<h2 id='ic.data.examp'>Function for calculating the influence function used for
the real data example.</h2><span id='topic+ic.data.examp'></span>

<h3>Description</h3>

<p>Function for calculating the influence function used for
the real data example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.data.examp(obs_data, what = "both", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.data.examp_+3A_obs_data">obs_data</code></td>
<td>
<p>the observed data.  The first column should be the outcome.</p>
</td></tr>
<tr><td><code id="ic.data.examp_+3A_what">what</code></td>
<td>
<p>the desired return value. Should be one of <code>"ic"</code>
(influence curve), <code>"est"</code> (estimate), or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="ic.data.examp_+3A_control">control</code></td>
<td>
<p>any other control parameters to be passed to the estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>what</code> is
</p>
<p>- <code>"est"</code>, then return the estimated parameter.
</p>
<p>- <code>"ic"</code>, then return the estimated IC of the parameter estimate.
</p>
<p>- <code>"both"</code>, then return both the parameter estimate and
corresponding estimated IC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
expit &lt;- function(x) exp(x) / (1 + exp(x))
ws &lt;- matrix(rnorm(3000), ncol = 3)
probs &lt;- expit(ws  %*% c(-1, 0, 2))
y &lt;- rbinom(n = nrow(probs), size = 1, prob = probs[, 1])
wts &lt;-   abs(rnorm(length(y))) + 1
wts &lt;- length(wts) * wts / sum(wts)
cats &lt;- rep(1:10, 100)
obs_dat &lt;- cbind(y, "cat" = cats, "wt" = wts, ws)
est_ic &lt;- ic.data.examp(obs_dat, what = "both")
my_est &lt;- est_ic$est
my_ic &lt;- est_ic$ic / nrow(ws)
var_mat &lt;- t(my_ic) %*% my_ic
sqrt(diag(var_mat))
for(cov_idx in 1:ncol(ws)){
 print(summary(stats::glm(y ~ ws[, cov_idx], weights = obs_dat[, "wt"],
                    family = binomial))$coefficients[2, 1:2])
}

</code></pre>

<hr>
<h2 id='ic.pearson'>Pearson Correlation IC and estimate</h2><span id='topic+ic.pearson'></span>

<h3>Description</h3>

<p>This function takes a set of observations, and returns an estimate
and its corresponding estimated IC matrix for the estimates of the
pearson correlation. Estimates of the covariance are generated using
the empirical influence function.  The first column of your data should
correspond to the variable of interest (the variable for which pearson
correlation is calculated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.pearson(observ, what = "both", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.pearson_+3A_observ">observ</code></td>
<td>
<p>the observed data.  The first column should be the outcome.</p>
</td></tr>
<tr><td><code id="ic.pearson_+3A_what">what</code></td>
<td>
<p>the desired return value. Should be one of <code>"ic"</code>
(influence curve), <code>"est"</code> (estimate), or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="ic.pearson_+3A_control">control</code></td>
<td>
<p>any other control parameters to be passed to the estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>what</code> is:
</p>
<p>- <code>"est"</code>, then return the estimated person correlation.
</p>
<p>- <code>"ic"</code>, then return the estimated IC of the person correlation estimate.
</p>
<p>- <code>"both"</code>, then return both the estimated pearson correlation and the
estimated IC of the person correlation estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- matrix(rnorm(80), nrow = 20)
ic.pearson(dat, what = "both")
## Note that the estimate is the same as what is found using \code{cor}
cor(dat)[1, ]

</code></pre>

<hr>
<h2 id='ic.proj.rr'>Estimate both the parameter, and the influence
curves used for estimating the projected risk ratio. The first column
of your data should correspond to the variable of interest.</h2><span id='topic+ic.proj.rr'></span>

<h3>Description</h3>

<p>Estimate both the parameter, and the influence
curves used for estimating the projected risk ratio. The first column
of your data should correspond to the variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.proj.rr(obs_data, what = "both", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.proj.rr_+3A_obs_data">obs_data</code></td>
<td>
<p>the observed data.  The first column should be the outcome.</p>
</td></tr>
<tr><td><code id="ic.proj.rr_+3A_what">what</code></td>
<td>
<p>the desired return value. Should be one of <code>"ic"</code>
(influence curve), <code>"est"</code> (estimate), or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="ic.proj.rr_+3A_control">control</code></td>
<td>
<p>any other control parameters to be passed to the estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>what</code> is
</p>
<p>- <code>"est"</code>, then return the estimated parameter.
</p>
<p>- <code>"ic"</code>, then return the estimated IC of the parameter estimate.
</p>
<p>- <code>"both"</code>, then return both the parameter estimate and
corresponding estimated IC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run (make sure to load in SuperLearner if running)
# set.seed(1010)
# fake_dat &lt;- data.frame(y = rbinom(100, size = 1, prob = 0.5),
#                       delta = rbinom(100, size =  1, prob = 0.5),
#                      w = matrix(rnorm(500), ncol = 5))
# ic.proj.rr.nolas(fake_dat)


</code></pre>

<hr>
<h2 id='ic.proj.rr.nolas'>Estimate both the parameter, and or the influence
curves used for estimating the projected risk ratio (not using lasso).
The first column of your data should correspond to the variable of interest.</h2><span id='topic+ic.proj.rr.nolas'></span>

<h3>Description</h3>

<p>Estimate both the parameter, and or the influence
curves used for estimating the projected risk ratio (not using lasso).
The first column of your data should correspond to the variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.proj.rr.nolas(obs_data, what = "both", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.proj.rr.nolas_+3A_obs_data">obs_data</code></td>
<td>
<p>the observed data.  The first column should be the outcome.</p>
</td></tr>
<tr><td><code id="ic.proj.rr.nolas_+3A_what">what</code></td>
<td>
<p>the desired return value. Should be one of <code>"ic"</code>
(influence curve), <code>"est"</code> (estimate), or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="ic.proj.rr.nolas_+3A_control">control</code></td>
<td>
<p>any other control parameters to be passed to the estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>what</code> is
</p>
<p>- <code>"est"</code>, then return the estimated parameter.
</p>
<p>- <code>"ic"</code>, then return the estimated IC of the parameter estimate.
</p>
<p>- <code>"both"</code>, then return both the parameter estimate and
corresponding estimated IC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run (make sure to load in SuperLearner if running)
# set.seed(1010)
# fake_dat &lt;- data.frame(y = rbinom(100, size = 1, prob = 0.5),
#                       delta = rbinom(100, size =  1, prob = 0.5),
#                      w = matrix(rnorm(500), ncol = 5))
# ic.proj.rr.nolas(fake_dat)

</code></pre>

<hr>
<h2 id='l_p_norm'>A function used to calculate various L_p norms</h2><span id='topic+l_p_norm'></span>

<h3>Description</h3>

<p>A function used to calculate various L_p norms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_p_norm(x, p = "max", type = "lp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_p_norm_+3A_x">x</code></td>
<td>
<p>Observed data</p>
</td></tr>
<tr><td><code id="l_p_norm_+3A_p">p</code></td>
<td>
<p>index of the norm</p>
</td></tr>
<tr><td><code id="l_p_norm_+3A_type">type</code></td>
<td>
<p>Kind of norm used (currently only lp and
sum of squares norms are supported)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The norm of x, of type <code>type</code> of index p.  For example,
the euclidean norm x has <code>p = 2, type = "lp"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(3, 4)
l_p_norm(x, p = 2, type = "lp")
l_p_norm(x, p = 2, type = "ssq")
l_p_norm(x, p = "max", type = "lp")
l_p_norm(x, p = 1, type = "ssq")

y &lt;- c(3, 4, 5, 6)
l_p_norm(y, p = 4, type = "lp")
l_p_norm(y, p = 3, type = "ssq")

</code></pre>

<hr>
<h2 id='look_IC'>This a function used to look at the IC.</h2><span id='topic+look_IC'></span>

<h3>Description</h3>

<p>This a function used to look at the IC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>look_IC(IC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="look_IC_+3A_ic">IC</code></td>
<td>
<p>an influence curve evaluated at each observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Histogram of the IC at each obeservation for each covariate.
Vertical lines indicate the mean of the IC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20)
ic &lt;- amp::ic.pearson(matrix(rnorm(120), ncol = 6))$ic
look_IC(ic)

</code></pre>

<hr>
<h2 id='mag_for_pow'>This function is used to estimate the magnitude needed for a
certain direction to achieve 80% power for a proposed alternative.</h2><span id='topic+mag_for_pow'></span>

<h3>Description</h3>

<p>This function is used to estimate the magnitude needed for a
certain direction to achieve 80% power for a proposed alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mag_for_pow(mc_limit_dstr, dir, norms_idx = 2, null_quants, norm_type = "lp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mag_for_pow_+3A_mc_limit_dstr">mc_limit_dstr</code></td>
<td>
<p>MC draws from the estimated (centered)
limiting distribution. Columns correspond to different covariates,
and rows are independent observations.</p>
</td></tr>
<tr><td><code id="mag_for_pow_+3A_dir">dir</code></td>
<td>
<p>the direction for which we wish to find the magnitude needed
to achieve 80% power.</p>
</td></tr>
<tr><td><code id="mag_for_pow_+3A_norms_idx">norms_idx</code></td>
<td>
<p>the norms to be considered.</p>
</td></tr>
<tr><td><code id="mag_for_pow_+3A_null_quants">null_quants</code></td>
<td>
<p>ninety five percent quantiles for each of the
different norms</p>
</td></tr>
<tr><td><code id="mag_for_pow_+3A_norm_type">norm_type</code></td>
<td>
<p>the class of norms to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Magnitude for the specified lp norm for a given local alternative.
</p>

<hr>
<h2 id='make_data'>Generate data using one of the four specified models
from MCKEAGUE and QIAN paper</h2><span id='topic+make_data'></span>

<h3>Description</h3>

<p>Generate data using one of the four specified models
from MCKEAGUE and QIAN paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data(ss, dim, rho, model = 1, b = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_data_+3A_ss">ss</code></td>
<td>
<p>sample size (number of generated observations)</p>
</td></tr>
<tr><td><code id="make_data_+3A_dim">dim</code></td>
<td>
<p>dimension of the generated data</p>
</td></tr>
<tr><td><code id="make_data_+3A_rho">rho</code></td>
<td>
<p>between x correlation</p>
</td></tr>
<tr><td><code id="make_data_+3A_model">model</code></td>
<td>
<p>number indicating which model should be used</p>
</td></tr>
<tr><td><code id="make_data_+3A_b">b</code></td>
<td>
<p>local alternative to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with outcome in the first column and covariates
in the others.  Data are generated according to the models described
originally in McKeague and Qian (2015).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
null_dat &lt;- make_data(ss = 100, dim = 10, rho = 0, model = 1)
model_two_dat &lt;- make_data(ss = 100, dim = 10, rho = 0, model = 2)
model_three_dat &lt;- make_data(ss = 100, dim = 10, rho = 0, model = 2)

</code></pre>

<hr>
<h2 id='mv_pn_test'>Runs a multivariate point null test. This function returns
an approximate p-value for the specified test statistic.</h2><span id='topic+mv_pn_test'></span>

<h3>Description</h3>

<p>Runs a multivariate point null test. This function returns
an approximate p-value for the specified test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv_pn_test(obs_data, param_est = NULL, control = test.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv_pn_test_+3A_obs_data">obs_data</code></td>
<td>
<p>The observed data to be used for finding the optimal
norm (training), and finding the test statistic (testing).  Similar to
above, each row is an observation and each column corresponds to either
the outcome (first column) or a covariate.</p>
</td></tr>
<tr><td><code id="mv_pn_test_+3A_param_est">param_est</code></td>
<td>
<p>Function used to estimate the parameter and corresponding
influence curve.</p>
</td></tr>
<tr><td><code id="mv_pn_test_+3A_control">control</code></td>
<td>
<p>List used to define controls for test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The test will always return the following output:
</p>
<p>- <code>pvalue</code>: The approximate value of the test statistic
</p>
<p>- <code>test_stat</code>: The approximate value of the test statistic
</p>
<p>- <code>test_st_eld</code>: The approximate limiting distribution of the test statistic
(with length equal to <code>ts_ld_bs_samp</code>).
</p>
<p>- <code>chosen_norm</code>: A vector indicating which norm was chosen by
the adaptive test
</p>
<p>- <code>param_ests</code>: The parameter estimate.
</p>
<p>- <code>param_ses</code>: An estimate of the standard error of
each element of <code>param_ests</code>
</p>
<p>- <code>oth_ic_inf</code>: Any other information provided by the <code>param_est</code>
function when calculating the IC and parameter estimates.
Additional information may be returned by specifying it in the
test.control function:
</p>
<p>- If <code>"var_est"</code> is contained in <code>other_output</code>, the test output
will contain will have <code>var_mat</code> returned which is the empirical
second moment of the IC (equal asymptotically to the variance estimator).
</p>
<p>- If <code>"obs_data"</code> is contained in the <code>other_output</code>, the test
output will return the data passed to the testing function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
## NOTE: More monte-carlo samples should be taken are taken here.  This is
## only done to lower computation time.
test &lt;- mv_pn_test(data.frame(y = rnorm(100), x = rnorm(100)),
                   ic.pearson, test.control(n_peld_mc_samples = 20,
                                            ts_ld_bs_samp = 20))

</code></pre>

<hr>
<h2 id='pval_for_mag'>A helper function that calculates the estimated p-value for a given
observed alternative and a given norm.</h2><span id='topic+pval_for_mag'></span>

<h3>Description</h3>

<p>A helper function that calculates the estimated p-value for a given
observed alternative and a given norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_for_mag(mc_limit_dstr, dir, norms_idx = 2, norm_type = "lp", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval_for_mag_+3A_mc_limit_dstr">mc_limit_dstr</code></td>
<td>
<p>the simulated data draw from
the limiting distribution under the null</p>
</td></tr>
<tr><td><code id="pval_for_mag_+3A_dir">dir</code></td>
<td>
<p>the observed estimate of the parameter</p>
</td></tr>
<tr><td><code id="pval_for_mag_+3A_norms_idx">norms_idx</code></td>
<td>
<p>the index for the norm used</p>
</td></tr>
<tr><td><code id="pval_for_mag_+3A_norm_type">norm_type</code></td>
<td>
<p>the type of norm used</p>
</td></tr>
<tr><td><code id="pval_for_mag_+3A_...">...</code></td>
<td>
<p>additional arguments that may be passed to
pval_for_mag, but which will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value for a test with estimate given by
<code>dir</code> and limiting distribution given by <code>mc_limit_dstr</code>.
</p>

<hr>
<h2 id='rr.msm.ic'>Estimate both the parameter, and the influence
curves used for estimating the projected risk ratio from a working
marginal structural mean model.</h2><span id='topic+rr.msm.ic'></span>

<h3>Description</h3>

<p>The function takes a dataset, and will returns the estimate for the
parameter, and or the estimated influence curve at each observation.
The first column of obs_data should be the binary outcome of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rr.msm.ic(obs_data, what = "both", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rr.msm.ic_+3A_obs_data">obs_data</code></td>
<td>
<p>the observed data.  The first column should be the outcome.</p>
</td></tr>
<tr><td><code id="rr.msm.ic_+3A_what">what</code></td>
<td>
<p>the desired return value. Should be one of '&quot;ic&quot;'
(influence curve), '&quot;est&quot;' (estimate), or '&quot;both&quot;'.</p>
</td></tr>
<tr><td><code id="rr.msm.ic_+3A_control">control</code></td>
<td>
<p>any other control parameters to be passed to the estimator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of this code has been copied and slightly modified from the
ltmle package and is copyrighted by Joshua Schwab under the terms of
the GPL-2 license.
</p>
<p>Obtain an estimator of the probability delta = 1 given w
</p>


<h3>Value</h3>

<p>If 'what' is
</p>
<p>- '&quot;est&quot;', then return the estimated parameter.
</p>
<p>- '&quot;ic&quot;', then return the estimated IC of the parameter estimate.
</p>
<p>- '&quot;both&quot;', then return both the parameter estimate and
corresponding estimated IC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#not run (make sure to load in SuperLearner if running)
#set.seed(1010)
#fake_dat &lt;- data.frame(y = rbinom(100, size = 1, prob = 0.5),
#                      a = rbinom(100, size =  1, prob = 0.5),
#                       w = matrix(rnorm(500), ncol = 5))
# rr.msm.ic(fake_dat)

</code></pre>

<hr>
<h2 id='rr.msm.jn.ic'>Estimate both the parameter, and the influence
curves used for estimating the projected risk ratio from a working
marginal structural mean model.  This function only uses elastic net
for the estimation (rather than also using other learners).</h2><span id='topic+rr.msm.jn.ic'></span>

<h3>Description</h3>

<p>The function takes a dataset, and will returns the estimate for the
parameter, and or the estimated influence curve at each observation.
The first column of obs_data should be the binary outcome of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rr.msm.jn.ic(obs_data, what = "both", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rr.msm.jn.ic_+3A_obs_data">obs_data</code></td>
<td>
<p>the observed data.  The first column should be the outcome.</p>
</td></tr>
<tr><td><code id="rr.msm.jn.ic_+3A_what">what</code></td>
<td>
<p>the desired return value. Should be one of '&quot;ic&quot;'
(influence curve), '&quot;est&quot;' (estimate), or '&quot;both&quot;'.</p>
</td></tr>
<tr><td><code id="rr.msm.jn.ic_+3A_control">control</code></td>
<td>
<p>any other control parameters to be passed to the estimator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the code for this function has been copied and slightly modified
from the ltmle package and is copyrighted by Joshua Schwab under the terms of
the GPL-2 license.
</p>
<p>Obtain an estimator of the probability delta = 1 given w
</p>


<h3>Value</h3>

<p>If 'what' is
</p>
<p>- '&quot;est&quot;', then return the estimated parameter.
</p>
<p>- '&quot;ic&quot;', then return the estimated IC of the parameter estimate.
</p>
<p>- '&quot;both&quot;', then return both the parameter estimate and
corresponding estimated IC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#not run (make sure to load in SuperLearner if running)
# set.seed(1010)
# fake_dat &lt;- data.frame(y = rbinom(100, size = 1, prob = 0.5),
#                        delta = rbinom(100, size =  1, prob = 0.5),
#                        w = matrix(rnorm(500), ncol = 5))
# rr.msm.jn.ic(fake_dat)

</code></pre>

<hr>
<h2 id='test.control'>Control function for the adaptive norm test</h2><span id='topic+test.control'></span>

<h3>Description</h3>

<p>Control function for the adaptive norm test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.control(
  n_peld_mc_samples = 300,
  nrm_type = "lp",
  perf_meas = "est_acc",
  pos_lp_norms = c(1, 2, 3, "max"),
  ld_est_meth = "par_boot",
  ts_ld_bs_samp = 250,
  other_output = c(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.control_+3A_n_peld_mc_samples">n_peld_mc_samples</code></td>
<td>
<p>Number of samples to be used in approximating the
estimated limiting distribution of the parameter estimate under the null.
Increasing this value reduces the approximation error of the test statistic.</p>
</td></tr>
<tr><td><code id="test.control_+3A_nrm_type">nrm_type</code></td>
<td>
<p>The type of norm to be used for the test.
Generally the l_p norm</p>
</td></tr>
<tr><td><code id="test.control_+3A_perf_meas">perf_meas</code></td>
<td>
<p>the preferred measure used to generate the test statistic.</p>
</td></tr>
<tr><td><code id="test.control_+3A_pos_lp_norms">pos_lp_norms</code></td>
<td>
<p>The index of the norms to be considered.  For example if
we use the l_p norm, norms_indx specifies the different p's to try.</p>
</td></tr>
<tr><td><code id="test.control_+3A_ld_est_meth">ld_est_meth</code></td>
<td>
<p>String indicating method for estimating the limiting
distribution of the test statistic parametric bootstrap or permutation.</p>
</td></tr>
<tr><td><code id="test.control_+3A_ts_ld_bs_samp">ts_ld_bs_samp</code></td>
<td>
<p>The number of test statistic limiting distribution
bootstrap samples to be drawn.</p>
</td></tr>
<tr><td><code id="test.control_+3A_other_output">other_output</code></td>
<td>
<p>A vector indicating additional data that should be
returned. Currently only <code>"var_est"</code> and <code>data</code> is supported.</p>
</td></tr>
<tr><td><code id="test.control_+3A_...">...</code></td>
<td>
<p>Other arguments needed in other places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that provide controls for <code>mv_pn_test</code> (specified by the
arguments passed to <code>test.control</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.control()

</code></pre>

<hr>
<h2 id='ZL'>Carry out a simplified version of the Zhang and Laber test.</h2><span id='topic+ZL'></span>

<h3>Description</h3>

<p>Carry out a simplified version of the Zhang and Laber test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZL(observed_data, ts_sims, ld_sims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZL_+3A_observed_data">observed_data</code></td>
<td>
<p>The observed data.</p>
</td></tr>
<tr><td><code id="ZL_+3A_ts_sims">ts_sims</code></td>
<td>
<p>The number of draws from the test statistic distribution</p>
</td></tr>
<tr><td><code id="ZL_+3A_ld_sims">ld_sims</code></td>
<td>
<p>The number of draws from the limiting distribution to
estimate each test statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<p>- pvalue: The p-value of the test
</p>
<p>- test_stat: The corresponding test statistic
</p>
<p>- test_st_eld: The corresponding estimated limiting distribution of
the test statistic.
</p>
<p>- param_ests: The estimates of the measure of association (correlation)
</p>
<p>- param_ses: The corresponding standard errors of the estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ZL(data.frame(z = rnorm(100), x1 = rnorm(100), x2 = rnorm(100)), 10, 10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
