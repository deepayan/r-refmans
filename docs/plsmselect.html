<!DOCTYPE html><html><head><title>Help for package plsmselect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plsmselect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cbh'><p>Internal Function</p></a></li>
<li><a href='#create_dataset'><p>Function to create the simulated dataset</p></a></li>
<li><a href='#cumbasehaz'><p>Cumulative Baseline Hazard of a gamlasso object</p></a></li>
<li><a href='#find_family'><p>Internal Function</p></a></li>
<li><a href='#formula_setup'><p>Internal Function</p></a></li>
<li><a href='#gamlasso'><p>Fitting a gamlasso model</p></a></li>
<li><a href='#gamlassoChecks'><p>Checking data before fitting gamlasso</p></a></li>
<li><a href='#gamlassoFit'><p>The function fitting a gamlasso model</p></a></li>
<li><a href='#lasso_gam_loop'><p>Internal Function</p></a></li>
<li><a href='#meandist'><p>Internal Function</p></a></li>
<li><a href='#nzeros'><p>Internal Function</p></a></li>
<li><a href='#predict.gamlasso'><p>Prediction from a fitted gamlasso model</p></a></li>
<li><a href='#print.gamlasso'><p>Print a gamlasso object</p></a></li>
<li><a href='#readconfirm'><p>Internal Function</p></a></li>
<li><a href='#simData'><p>Simulated dataset to be used for gamlasso</p></a></li>
<li><a href='#summary.gamlasso'><p>Summary for a gamlasso fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Linear and Smooth Predictor Modelling with Penalisation and
Variable Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit a model with potentially many linear and smooth predictors. Interaction
    effects can also be quantified. Variable selection is done using penalisation. For l1-type penalties
    we use iterative steps alternating between using linear predictors (lasso) and smooth predictors
    (generalised additive model).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.8), glmnet (&ge; 2.0.16), mgcv (&ge; 1.8.26),
survival (&ge; 2.43.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, kableExtra, purrr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-24 09:19:03 UTC; Indrayudh</td>
</tr>
<tr>
<td>Author:</td>
<td>Indrayudh Ghosal [aut, cre],
  Matthias Kormaksson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Indrayudh Ghosal &lt;ig248@cornell.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-24 09:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cbh'>Internal Function</h2><span id='topic+cbh'></span>

<h3>Description</h3>

<p>Undocumented function. Do not use directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbh(lp, event.time, status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbh_+3A_lp">lp</code></td>
<td>
<p>The linear predictor to be used as offset</p>
</td></tr>
<tr><td><code id="cbh_+3A_event.time">event.time</code></td>
<td>
<p>The event times</p>
</td></tr>
<tr><td><code id="cbh_+3A_status">status</code></td>
<td>
<p>Status indicating the complement of censoring</p>
</td></tr>
</table>

<hr>
<h2 id='create_dataset'>Function to create the simulated dataset</h2><span id='topic+create_dataset'></span>

<h3>Description</h3>

<p>Undocumented function. Do not use directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_dataset()
</code></pre>

<hr>
<h2 id='cumbasehaz'>Cumulative Baseline Hazard of a gamlasso object</h2><span id='topic+cumbasehaz'></span>

<h3>Description</h3>

<p>This is only used when with family=&quot;cox&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumbasehaz(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumbasehaz_+3A_object">object</code></td>
<td>
<p>fitted model object of the class <code>gamlasso</code> as
produced by <code>gamlasso</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the cumulative baseline hazard function of
a <code>gamlasso</code> object if fitted using <code>family = "cox"</code>. More
specifically, cumbasehaz(object) is the cumulative baseline hazard function
corresponding to the linear predictor predict(object).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlasso">gamlasso</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plsmselect)

data(simData)

## Fit Cox gamlasso model using the formula approach:
## (L1-penalty both on X terms and smooth terms (bs="ts"))
simData$X = model.matrix(~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10, data=simData)[,-1]

cfit = gamlasso(time ~ X +
                  s(z1, bs="ts", k=5) +
                  s(z2, bs="ts", k=5) +
                  s(z3, bs="ts", k=5) +
                  s(z4, bs="ts", k=5),
                data = simData,
                family = "cox",
                weights="status",
                seed=1)

## Obtain and plot predicted cumulative baseline hazard:
H0.pred &lt;- cumbasehaz(cfit)

time.seq &lt;- seq(0, 60, by=1)
plot(time.seq, H0.pred(time.seq), type="l", ylab="Predicted Cumulative Baseline Hazard")

## Obtain predicted survial probabilities at month 1 and 2 (days 30 &amp; 60):

lp &lt;- predict(cfit) # estimated linear predictor

S.pred &lt;- cbind(exp(-H0.pred(30)*exp(lp)), exp(-H0.pred(60)*exp(lp)))

## Obtain predicted survival at month 1 and 2 directly:
S.pred2 &lt;- predict(cfit, type="response", new.event.times=c(30,60))

## Confirm that the two arrived at the same values:
all.equal(S.pred, S.pred2)

# See ?gamlasso for an example fitting a gaussian response model
# See ?summary.gamlasso for an example fitting a binomial response model
# See ?predict.gamlasso for an example fitting a poisson response model
</code></pre>

<hr>
<h2 id='find_family'>Internal Function</h2><span id='topic+find_family'></span>

<h3>Description</h3>

<p>Undocumented function. Do not use directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_family(fam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_family_+3A_fam">fam</code></td>
<td>
<p>Family in character form</p>
</td></tr>
</table>

<hr>
<h2 id='formula_setup'>Internal Function</h2><span id='topic+formula_setup'></span>

<h3>Description</h3>

<p>Undocumented function. Do not use directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_setup(
  formula = NULL,
  response.name = NULL,
  linear.name = NULL,
  smooth.name = NULL,
  family = NULL,
  smooth.penalty = NULL,
  num.knots = NULL,
  offset.name = NULL,
  interactions = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula_setup_+3A_formula">formula</code></td>
<td>
<p>A formula to be parsed</p>
</td></tr>
<tr><td><code id="formula_setup_+3A_response.name">response.name</code></td>
<td>
<p>The name of the response variable. Vector of two if
<code>family = "binomial"</code></p>
</td></tr>
<tr><td><code id="formula_setup_+3A_linear.name">linear.name</code></td>
<td>
<p>The names of the variables to be used as linear predictors</p>
</td></tr>
<tr><td><code id="formula_setup_+3A_smooth.name">smooth.name</code></td>
<td>
<p>The names of the variables to be used as smoothers</p>
</td></tr>
<tr><td><code id="formula_setup_+3A_family">family</code></td>
<td>
<p>The family describing the error distribution and link function
to be used in the model. A character string which can only be
<code>"gaussian"</code> (default), <code>"binomial"</code>, <code>"poisson"</code> or
<code>"cox"</code>. For <code>family = "binomial"</code>, <code>response</code> can be
a vector of two and for <code>family="cox"</code>, <code>weights</code> must
be provided (see details below).</p>
</td></tr>
<tr><td><code id="formula_setup_+3A_smooth.penalty">smooth.penalty</code></td>
<td>
<p>The penalty used on the smoothers. Can be 1 or 2</p>
</td></tr>
<tr><td><code id="formula_setup_+3A_num.knots">num.knots</code></td>
<td>
<p>Number of knots for each smoothers. Can be a single integer
(recycled for each smoother variable) or a vector of integers the same length
as the number of smoothers.</p>
</td></tr>
<tr><td><code id="formula_setup_+3A_offset.name">offset.name</code></td>
<td>
<p>The name of the offset variable. <code>NULL</code> (default) if not provided</p>
</td></tr>
<tr><td><code id="formula_setup_+3A_interactions">interactions</code></td>
<td>
<p>logical. Should interactions be included.</p>
</td></tr>
</table>

<hr>
<h2 id='gamlasso'>Fitting a gamlasso model</h2><span id='topic+gamlasso'></span><span id='topic+gamlasso.formula'></span><span id='topic+gamlasso.default'></span>

<h3>Description</h3>

<p>This function will fit a gamlasso model with the given penalties. For some
special cases using <code><a href="mgcv.html#topic+gam">gam</a></code> or <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
might be more efficient and/or flexible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
gamlasso(
  formula,
  data,
  family = "gaussian",
  linear.penalty = "l1",
  smooth.penalty = "l2",
  num.knots = 5,
  offset = NULL,
  weights = NULL,
  interactions = F,
  seed = .Random.seed[1],
  num.iter = 100,
  tolerance = 1e-04,
  ...
)

## Default S3 method:
gamlasso(
  response,
  linear.terms,
  smooth.terms,
  data,
  family = "gaussian",
  linear.penalty = "l1",
  smooth.penalty = "l2",
  num.knots = 5,
  offset = NULL,
  weights = NULL,
  interactions = F,
  seed = .Random.seed[1],
  num.iter = 100,
  tolerance = 1e-04,
  prompts = F,
  verbose = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlasso_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model to be fitted</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_response">response</code></td>
<td>
<p>The name of the response variable. Could be two variables
in case of a general binomial fit (see details below)</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_linear.terms">linear.terms</code></td>
<td>
<p>The names of the variables to be used as linear predictors</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_smooth.terms">smooth.terms</code></td>
<td>
<p>The names of the variables to be used as smoothers</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_data">data</code></td>
<td>
<p>The data with which to fit the model</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_family">family</code></td>
<td>
<p>The family describing the error distribution and link function
to be used in the model. A character string which can only be
<code>"gaussian"</code> (default), <code>"binomial"</code>, <code>"poisson"</code> or
<code>"cox"</code>. For <code>family = "binomial"</code>, <code>response</code> can be
a vector of two and for <code>family="cox"</code>, <code>weights</code> must
be provided (see details below).</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_linear.penalty">linear.penalty</code></td>
<td>
<p>The penalty used on the linear predictors. A character
string which can be <code>"none"</code> (default), <code>"l1"</code> or <code>"l2"</code>. If
<code>"l1"</code> is used then we use the gam and lasso loop. Otherwise only a
gam model is fitted (with penalities on parametric terms if
<code>linear.penalty = "l2"</code> ).</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_smooth.penalty">smooth.penalty</code></td>
<td>
<p>The penalty used on the smoothers. A character
string which can be <code>"l1"</code> or <code>"l2"</code> (default). <code>"l2"</code> refers
to the inherent second order penalty smoothers have for controlling their
shape, so <code>"none"</code> is not an option. For <code>"l1"</code> basis is specified
by <code>bs='ts'</code>, else <code>bs='tp'</code> is used. (see <code><a href="mgcv.html#topic+gam">gam</a></code>
for details on basis types)</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_num.knots">num.knots</code></td>
<td>
<p>Number of knots for each smoothers. Can be a single integer
(recycled for each smoother variable) or a vector of integers the same length
as the number of smoothers.</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_offset">offset</code></td>
<td>
<p>The name of the offset variable. <code>NULL</code> (default) if not provided</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_weights">weights</code></td>
<td>
<p>The name of the weights variable. <code>NULL</code> (default) if not
provided. See details below.</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_interactions">interactions</code></td>
<td>
<p>logical. Should interactions be included as covariates.
If <code>TRUE</code> then the smoothers are fitted with <code><a href="mgcv.html#topic+ti">ti</a></code>
instead of <code><a href="mgcv.html#topic+s">s</a></code> so that the added effects of the interactions
can be quantified separately.</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_seed">seed</code></td>
<td>
<p>The random seed can be specified for reproducibility. This is used
for fitting the gam and lasso models, or fixed before each loop of gamlasso.</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_num.iter">num.iter</code></td>
<td>
<p>Number of iterations for the gamlasso loop</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for covergence of the gamlasso loop</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_prompts">prompts</code></td>
<td>
<p>logical. Should <code>gamlassoChecks</code> provide interactive
user prompts for corrective action when needed.</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_verbose">verbose</code></td>
<td>
<p>logical. Should there be &quot;progress reports&quot; printed to the
console while fitting the model.</p>
</td></tr>
<tr><td><code id="gamlasso_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gamlasso</code> allows for specifying models in two ways:
1) with the the formula approach, and 2) with the term specification approach.
</p>
<p>The formula approach is appropriate for when the user wants an L1-penalty on the
linear terms of the model, in which case the user is required to specify the linear terms
in a model matrix named &quot;X&quot; appended to the input data frame. A typical formula specification
would be &quot;<code>y ~ X + s(z) + ...</code>&quot; where &quot;<code>X</code>&quot; corresponds to the model-matrix of
linear terms subject to an L1-penalty, while everything to the right of &quot;<code>X</code>&quot; is
considered part of the gam formula (i.e. all smooth terms). In light of the above formula,
gamlasso iterates (until convergence) between the following two lines of pseudo code:
</p>

<ul>
<li> <p><code>model.cv.glmnet &lt;- cv.glmnet(y=y, x=X, offset="model.gam fitted values")</code>
</p>
</li>
<li> <p><code>model.gam &lt;- gam(y ~ s(z) + ..., offset="model.cv.glmnet fitted values")</code>
</p>
</li></ul>

<p>The term specification approach can fit the same type of models as the formula approach
(i.e. models with L1-penalty on the linear terms). However, it is more flexible in terms
of penalty-structure and can be useful if the user has big data sets with lots of variables
making the formula specification cumbersome. In the term specification approach
the user simply specifies the names of the data columns corresponding to the
<code>response</code>, <code>linear.terms</code> and <code>smooth.terms</code> and then specifies
whether to put a <code>linear.penalty="l1"</code>, <code>"l2"</code> or <code>"none"</code>
(on <code>linear.terms</code>) and whether to put a <code>smooth.penalty="l1"</code> or
<code>"l2"</code> (on <code>smooth.terms</code>).
</p>
<p>While fitting a binomial model for binary responses (0/1) include the response
variable before &quot;~&quot; if using the formula approach or when using the term-
specification approach the <code>response</code> argument will be a single variable name.
In general if the responses are success/failure counts then the formula should
start with something similar to <code>cbind(success,failure) ~ ...</code> and for
using the term-specification approach the <code>response</code> argument should be a
vector of length two giving the success and failure variable names.
</p>
<p>If <code>family="cox"</code> then the <code>weights</code> argument must be provided
and should correspond to a status variable (1-censor). For other models
it should correspond to a custom weights variables to be used for the
weighted log-likelihood, for example the total counts for fitting a
binomial model. (weights for families other than &quot;cox&quot; currently not
implemented)
</p>
<p>Both the formula and term-specification approaches can fit interaction models as
well. There are three kinds of interactions - those between two linear predictors,
between two smooth predictors and between linear and smooth predictors. For the
formula approach the first type of interaction must be included as additional
columns in the &quot;<code>X</code>&quot; matrix and the other two types must be mentioned in the
smooth terms part of the formula. For the term-specification approach the argument
<code>interaction</code> must be <code>TRUE</code> in which case all the pairwise
interactions are used as predictors and variable selection is done on all of them.
</p>


<h3>Value</h3>

<p>If the arguments fail the basic checking by <code>gamlassoChecks</code>
then returns <code>NULL</code>. Else the function calls <code>gamlassoFit</code> which
returns a list of two models, <code>gam</code> and <code>cv.glmnet</code>.
Either of these could be <code>NULL</code> but if both are non-null then
<code>convergence</code>, a matrix of values determining the convergence
of the gamlasso loop is also returned.
<code>gamlassoFit</code> also returns <code>inherit</code>, a list of select
arguments used to fit the <code>gamlasso</code> model and some more values needed
for prediction.
</p>


<h3>Note</h3>

<p>The default values of <code>num.iter</code> and <code>tolerance</code> are
essentially arbitrary. Also for each step when we check for convergence
between the new and old predictions by the gam and lasso predictions,
we use the following distance metric
</p>
<p style="text-align: center;"><code class="reqn"> d(x,y) = \frac{1}{length(x)} \sum_{i=1}^{length(x)} (x_i - y_i)^2 </code>
</p>



<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plsmselect)

data(simData)

## Fit gaussian gamlasso model using the formula approach:
## (L1-penalty both on model matrix (X) and smooth terms (bs="ts"))
simData$X = model.matrix(~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10, data=simData)[,-1]

gfit = gamlasso(Yg ~ X +
                   s(z1, k=5, bs="ts") +
                   s(z2, k=5, bs="ts") +
                   s(z3, k=5, bs="ts") +
                   s(z4, k=5, bs="ts"),
                   data = simData,
                   seed=1)

## Equivalently with term specification approach:
gfit = gamlasso(response="Yg",
                  linear.terms=paste0("x",1:10),
                  smooth.terms=paste0("z",1:4),
                  data=simData,
                  linear.penalty = "l1",
                  smooth.penalty = "l1",
                  num.knots = 5,
                  seed=1)

## The two main components of gfit are
## gfit$cv.glmnet (LASSO component) and gfit$gam (GAM components):

## Extract lasso estimates of linear terms:
coef(gfit$cv.glmnet, s="lambda.min")

## Plot the estimates of the smooth effects:
plot(gfit$gam, pages=1)

# See ?summary.gamlasso for an example fitting a binomial response model
# See ?predict.gamlasso for an example fitting a poisson response model
# See ?cumbasehaz for an example fitting a survival response model
</code></pre>

<hr>
<h2 id='gamlassoChecks'>Checking data before fitting gamlasso</h2><span id='topic+gamlassoChecks'></span>

<h3>Description</h3>

<p>This function checks if the arguments entered for fitting a gamlasso model
are compatible with each other. Not recommended to call directly. Only use
if cleaning data prior to fitting <code><a href="#topic+gamlassoFit">gamlassoFit</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlassoChecks(
  data,
  response.name,
  linear.name,
  smooth.name,
  family,
  linear.penalty,
  smooth.penalty,
  offset.name,
  weights.name,
  num.knots,
  num.iter,
  tolerance,
  seed,
  prompts
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlassoChecks_+3A_data">data</code></td>
<td>
<p>The training data for fitting the model</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_response.name">response.name</code></td>
<td>
<p>The name of the response variable. Vector of two if
<code>family = "binomial"</code></p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_linear.name">linear.name</code></td>
<td>
<p>The names of the variables to be used as linear predictors</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_smooth.name">smooth.name</code></td>
<td>
<p>The names of the variables to be used as smoothers</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_family">family</code></td>
<td>
<p>The family describing the error distribution and link function
to be used in the model. A character string which can only be
<code>"gaussian"</code> (default), <code>"binomial"</code>, <code>"poisson"</code> or
<code>"cox"</code>. For <code>family = "binomial"</code>, <code>response</code> can be
a vector of two and for <code>family="cox"</code>, <code>weights</code> must
be provided (see details below).</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_linear.penalty">linear.penalty</code></td>
<td>
<p>The penalty used on the linear predictors. Can be 0, 1 or 2</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_smooth.penalty">smooth.penalty</code></td>
<td>
<p>The penalty used on the smoothers. Can be 1 or 2</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_offset.name">offset.name</code></td>
<td>
<p>The name of the offset variable. <code>NULL</code> (default) if not provided</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_weights.name">weights.name</code></td>
<td>
<p>The name of the weights variable. <code>NULL</code> (default)
if not provided. See <code>Details</code> of <code><a href="#topic+gamlasso">gamlasso</a></code>.</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_num.knots">num.knots</code></td>
<td>
<p>Number of knots for each smoothers. Can be a single integer
(recycled for each smoother variable) or a vector of integers the same length
as the number of smoothers.</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_num.iter">num.iter</code></td>
<td>
<p>Number of iterations for the gamlasso loop</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for covergence of the gamlasso loop</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_seed">seed</code></td>
<td>
<p>The random seed can be specified for reproducibility. This is used
for fitting the gam and lasso models, or fixed before each loop of gamlasso.</p>
</td></tr>
<tr><td><code id="gamlassoChecks_+3A_prompts">prompts</code></td>
<td>
<p>logical. Should <code>gamlassoChecks</code> provide interactive
user prompts for corrective action when needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gamlassoChecks</code> produces a series of logical values:
<code>allcheck</code> indicating if the arguments passed all the checks,
<code>fit.smoothgam</code> indicating if there aren't any linear predictors and
a model with only smoothers should be fitted, <code>fit.glmnet</code>
is the counterpart for smooth predictors. It also returns the cleaned
(if needed) arguments as a list named <code>cleandata</code> who's elements are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>train.data</code> </td><td style="text-align: left;"> The training data with unnecessary columns deleted </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>linear.name</code>, <code>smooth.name</code>, <code>num.knots</code> </td><td style="text-align: left;"> The changed
     variable names and number of knots </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>linear.penalty</code>, <code>smooth.penalty</code> </td><td style="text-align: left;"> The changed penalties for linear and smooth
    terms. Reset to their default values only
    in the rare case of too few predictors
  </td>
</tr>

</table>



<h3>Note</h3>

<p>The arguments <code>offset.name</code>, <code>num.iter</code>, <code>tolerance</code>
and <code>seed</code> are not currently not being used in testing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Usage similar to gamlassoFit
</code></pre>

<hr>
<h2 id='gamlassoFit'>The function fitting a gamlasso model</h2><span id='topic+gamlassoFit'></span>

<h3>Description</h3>

<p>This function is the workhorse for fitting a gamlasso model. Not recommended
to call directly. It is slightly more efficient than <code>gamlasso.default</code> since
it doesn't perform any quality checks. Only use if the data has been cleaned
and no errors are expected to occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlassoFit(
  data,
  formula = NULL,
  response.name = NULL,
  linear.name = NULL,
  smooth.name = NULL,
  family = "gaussian",
  linear.penalty = 0,
  smooth.penalty = 2,
  offset.name = NULL,
  weights.name = NULL,
  num.knots = 5,
  num.iter = 100,
  interactions = F,
  tolerance = 1e-04,
  seed = .Random.seed[1],
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlassoFit_+3A_data">data</code></td>
<td>
<p>The training data for fitting the model</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model to be fitted</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_response.name">response.name</code></td>
<td>
<p>The name of the response variable. Vector of two if
<code>family = "binomial"</code></p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_linear.name">linear.name</code></td>
<td>
<p>The names of the variables to be used as linear predictors</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_smooth.name">smooth.name</code></td>
<td>
<p>The names of the variables to be used as smoothers</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_family">family</code></td>
<td>
<p>The family describing the error distribution and link function
to be used in the model. A character string which can only be
<code>"gaussian"</code> (default), <code>"binomial"</code>, <code>"poisson"</code> or
<code>"cox"</code>. For <code>family = "binomial"</code>, <code>response</code> can be
a vector of two and for <code>family="cox"</code>, <code>weights</code> must
be provided (see details below).</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_linear.penalty">linear.penalty</code></td>
<td>
<p>The penalty used on the linear predictors. Can be 0, 1 or 2</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_smooth.penalty">smooth.penalty</code></td>
<td>
<p>The penalty used on the smoothers. Can be 1 or 2</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_offset.name">offset.name</code></td>
<td>
<p>The name of the offset variable. <code>NULL</code> (default) if not provided</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_weights.name">weights.name</code></td>
<td>
<p>The name of the weights variable. <code>NULL</code> (default)
if not provided. See <code>Details</code> of <code><a href="#topic+gamlasso">gamlasso</a></code>.</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_num.knots">num.knots</code></td>
<td>
<p>Number of knots for each smoothers. Can be a single integer
(recycled for each smoother variable) or a vector of integers the same length
as the number of smoothers.</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_num.iter">num.iter</code></td>
<td>
<p>Number of iterations for the gamlasso loop</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_interactions">interactions</code></td>
<td>
<p>logical. Should interactions be included.</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for covergence of the gamlasso loop</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_seed">seed</code></td>
<td>
<p>The random seed can be specified for reproducibility. This is used
for fitting the gam and lasso models, or fixed before each loop of gamlasso.</p>
</td></tr>
<tr><td><code id="gamlassoFit_+3A_verbose">verbose</code></td>
<td>
<p>logical. Should there be &quot;progress reports&quot; printed to the
console while fitting the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="#topic+gamlasso">gamlasso</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not recommended to use directly. Please see examples of gamlasso
</code></pre>

<hr>
<h2 id='lasso_gam_loop'>Internal Function</h2><span id='topic+lasso_gam_loop'></span>

<h3>Description</h3>

<p>Undocumented function. Do not use directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso_gam_loop(
  data,
  response.name,
  families,
  formulae,
  num.iter,
  tolerance,
  offset.name,
  weights,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso_gam_loop_+3A_data">data</code></td>
<td>
<p>The data with value for all the linear and smooth predictors</p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_response.name">response.name</code></td>
<td>
<p>The name of the response variable. Vector of two if
<code>family = "binomial"</code></p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_families">families</code></td>
<td>
<p>List of two families as returned by <code>find_family</code></p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_formulae">formulae</code></td>
<td>
<p>List of formulae as returned by <code>formula_setup</code></p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_num.iter">num.iter</code></td>
<td>
<p>Number of iterations for the gamlasso loop</p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for covergence of the gamlasso loop</p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_offset.name">offset.name</code></td>
<td>
<p>The name of the offset variable. <code>NULL</code> (default) if not provided</p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_weights">weights</code></td>
<td>
<p>Vector with values of the weights variable if it exists.
<code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code id="lasso_gam_loop_+3A_seed">seed</code></td>
<td>
<p>The random seed can be specified for reproducibility. This is used
for fitting the gam and lasso models, or fixed before each loop of gamlasso.</p>
</td></tr>
</table>

<hr>
<h2 id='meandist'>Internal Function</h2><span id='topic+meandist'></span>

<h3>Description</h3>

<p>Undocumented function. Do not use directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meandist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meandist_+3A_x">x</code>, <code id="meandist_+3A_y">y</code></td>
<td>
<p>Vectors of the same length</p>
</td></tr>
</table>

<hr>
<h2 id='nzeros'>Internal Function</h2><span id='topic+nzeros'></span>

<h3>Description</h3>

<p>Undocumented function. Do not use directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzeros(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nzeros_+3A_x">x</code>, <code id="nzeros_+3A_y">y</code></td>
<td>
<p>Vectors of the same length</p>
</td></tr>
</table>

<hr>
<h2 id='predict.gamlasso'>Prediction from a fitted gamlasso model</h2><span id='topic+predict.gamlasso'></span>

<h3>Description</h3>

<p>Takes a fitted <code>gamlasso</code> object produced by <code>gamlasso</code> and
returns predictions given a new set of values of the linear and smooth
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlasso'
predict(
  object,
  newdata = NULL,
  type = "link",
  s = "lambda.min",
  new.event.times = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gamlasso_+3A_object">object</code></td>
<td>
<p>fitted model object of the class <code>gamlasso</code> as
produced by <code>gamlasso</code></p>
</td></tr>
<tr><td><code id="predict.gamlasso_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the values of the linear and smooth
variables for which predictions are to be made. If not provided then
predictions corresponding to the original data used to fit <code>object</code>
is returned. If provided then the variable names (column names) should
match with the variable names used to fit <code>object</code>: the code throws
an error if not.</p>
</td></tr>
<tr><td><code id="predict.gamlasso_+3A_type">type</code></td>
<td>
<p>When this has the value <code>"link"</code> (default) then the
linear predictor (with offset added if needed) is returned. When
<code>type = "response"</code> predictions on the response scale is returned,
depending on the family used while fitting <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.gamlasso_+3A_s">s</code></td>
<td>
<p>Value of the lasso penalty parameter <code>lambda</code> at which
predictions are required. Default is <code>"lambda.min"</code> but alternatively
<code>"lambda.1se"</code> can be used.</p>
</td></tr>
<tr><td><code id="predict.gamlasso_+3A_new.event.times">new.event.times</code></td>
<td>
<p>A vector of new event times to be used for predicting
survival times when <code>type = "response"</code> for a gamlasso object fitted
with <code>family = "cox"</code></p>
</td></tr>
<tr><td><code id="predict.gamlasso_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lasso models do not have standard errors so <code>predict.gamlasso</code>
does not provide them either. The standard errors for the gam part of the
model can be accesed by using <code>mgcv::predict.gam</code> with suitable options.
Offsets are always included in the prediction if present in the original call
to <code>gamlasso</code>. Also if <code>type</code> is anything other than <code>"link"</code>
or <code>"response"</code> then the function throws an error.
</p>


<h3>Value</h3>

<p>Returns a vector of the same length as <code>nrow(newdata)</code> with
the values of the linear predictor or on the response scale depending
on <code>type</code>. For <code>type = "link"</code> the value is simply the elementwise
sum of the predictions from the gam and lasso models in <code>object</code>.
For <code>type = "response"</code> the values are on the response scale, for
example exponential of the linear response is returned if
<code>object$inherit$family = "poisson"</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlasso">gamlasso</a></code>, <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>,
<code><a href="glmnet.html#topic+predict.glmnet">predict.glmnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plsmselect)

data(simData)

## Fit poisson gamlasso model using the term specification approach:
## (L2-penalty on linear terms &amp; L2-penalty on smooth terms)
pfit = gamlasso(response="Yp",
                linear.terms=paste0("x",1:10),
                smooth.terms=paste0("z",1:4),
                data=simData,
                linear.penalty = "l2",
                smooth.penalty = "l2",
                family="poisson",
                num.knots = 5,
                seed=1)

## fitted values (of linear predictor):
fitted.values &lt;- predict(pfit)

## predicted values on response scale:
pred.response &lt;- predict(pfit, type="response", newdata=simData)

## For same model as above, but with L1-penalty on linear terms
## i.e. L1-penalty on the model matrix (X) we can use formula approach:
simData$X = model.matrix(~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10, data=simData)[,-1]

pfit = gamlasso(Yp ~ X +
                   s(z1, k=5) + # L2-penalty (bs="tp") is default (see ?mgcv::s)
                   s(z2, k=5) +
                   s(z3, k=5) +
                   s(z4, k=5),
                 family="poisson",
                 data = simData,
                 seed=1)

# See ?gamlasso for an example fitting a gaussian response model
# See ?summary.gamlasso for an example fitting a binomial response model
# See ?cumbasehaz for an example fitting a survival response model
</code></pre>

<hr>
<h2 id='print.gamlasso'>Print a gamlasso object</h2><span id='topic+print.gamlasso'></span>

<h3>Description</h3>

<p>The default print method for a <code>gamlasso</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlasso'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gamlasso_+3A_x">x</code></td>
<td>
<p>fitted model object of the class <code>gamlasso</code> as
produced by <code>gamlasso</code></p>
</td></tr>
<tr><td><code id="print.gamlasso_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outputs a list of two. <code>lasso</code> prints the lasso
model (the same output as <code>print(object$cv.glmnet$glmnet.fit)</code>) if
it is non-null and <code>gam</code> prints the gam model (the same output
as <code>print(object$gam)</code>) if it is non-null.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlasso">gamlasso</a></code>, <code><a href="#topic+summary.gamlasso">summary.gamlasso</a></code>,
<code><a href="mgcv.html#topic+print.gam">print.gam</a></code>, <code><a href="glmnet.html#topic+print.glmnet">print.glmnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the examples in ?gamlasso
</code></pre>

<hr>
<h2 id='readconfirm'>Internal Function</h2><span id='topic+readconfirm'></span>

<h3>Description</h3>

<p>Internal Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readconfirm()
</code></pre>

<hr>
<h2 id='simData'>Simulated dataset to be used for gamlasso</h2><span id='topic+simData'></span>

<h3>Description</h3>

<p>The package includes a simulated dataset that we will use for the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simData)
</code></pre>


<h3>Format</h3>

<p>A 100-by-23 data frame. There are 10 variables
(<code>x1</code>,...,<code>x10</code>) corresponding to the linear predictors and 4
(<code>z1</code>,...,<code>z4</code>) corresponding to the smooth predictors. There are
7 response variables corresponding to the different models fitted -
</p>

<ul>
<li> <p><code>Yg</code> for the Gaussian response
</p>
</li>
<li> <p><code>Yb</code> as Bernoulli and <code>success</code> and <code>failure</code> as
Binomial count responses
</p>
</li>
<li> <p><code>Yp</code> as the Poisson response
</p>
</li>
<li> <p><code>time</code> and <code>status</code> as the survival model responses
</p>
</li></ul>

<p>The variables starting with <code>X</code> are the same as the linear predictors but are
concatenated into a matrix <code>X</code> to be used for the formula implementation of
<code>gamlasso</code></p>


<h3>Details</h3>

<p>The code for creating this simulated dataset is included in the
vignette of this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see examples in ?gamlasso
</code></pre>

<hr>
<h2 id='summary.gamlasso'>Summary for a gamlasso fit</h2><span id='topic+summary.gamlasso'></span>

<h3>Description</h3>

<p>Default sumary method for a <code>gamlasso</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlasso'
summary(object, s = "lambda.min", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gamlasso_+3A_object">object</code></td>
<td>
<p>fitted model object of the class <code>gamlasso</code> as
produced by <code>gamlasso</code></p>
</td></tr>
<tr><td><code id="summary.gamlasso_+3A_s">s</code></td>
<td>
<p>Value of the lasso penalty parameter <code>lambda</code> at which
predictions are required. Default is <code>"lambda.min"</code> but alternatively
<code>"lambda.1se"</code> can be used.</p>
</td></tr>
<tr><td><code id="summary.gamlasso_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outputs a list of two. <code>gam</code> prints a summary of the
gam model (the same output as <code>summary(object$gam)</code>) if it
is non-null. Objects of the class <code>cv.glmnet</code> do not have a
default summary method, so the list item <code>lasso</code> produces the
coefficients of the cross-vaidated lasso fit corresponding to the
lowest value of the <code class="reqn">\lambda</code> used ( the same output as
<code>coef(object$cv.glmnet, s = "lambda.min")</code> if it is non-null).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlasso">gamlasso</a></code>, <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code>,
<code><a href="glmnet.html#topic+coef.cv.glmnet">coef.cv.glmnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plsmselect)

data(simData)

## Fit binomial gamlasso model using the term specification
## approach with binomial counts response
## (L2-penalty on linear terms &amp; L1-penalty on smooth terms)
bfit = gamlasso(c("success","failure"),
                linear.terms=paste0("x",1:10),
                smooth.terms=paste0("z",1:4),
                data=simData,
                family = "binomial",
                linear.penalty = "l2",
                smooth.penalty = "l1",
                num.knots = 5,
                seed=1)

## Since the above model has linear.penalty = "l2" it is
## a pure GAM model (i.e. no LASSO component):
bfit$cv.glmnet

## Summary of model (here essentially the same as summary(bfit$gam)
## because there is no LASSO component, i.e. linear.penalty="l2")
summary(bfit)

## We could use the formula approach below to fit the same model as above:
simData$X = model.matrix(~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10, data=simData)[,-1]
bfit = gamlasso(cbind(success,failure) ~ X + s(z1, bs="ts") +
                 s(z2, bs="ts") + s(z3, bs="ts") + s(z4, bs="ts"),
                data = simData,
                family = "binomial",
                linear.penalty = "l2",
                smooth.penalty = "l1",
                seed=1)

## For a binary responses we only need one response variable in the formula
bfit2 = gamlasso(Yb ~ X + s(z1, bs="ts") + s(z2, bs="ts") + s(z3, bs="ts") + s(z4, bs="ts"),
                  data = simData,
                  family = "binomial",
                  seed=1)

# See ?gamlasso for an example fitting a gaussian response model
# See ?predict.gamlasso for an example fitting a poisson response model
# See ?cumbasehaz for an example fitting a survival response model
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
