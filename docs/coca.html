<!DOCTYPE html><html><head><title>Help for package coca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildMOC'><p>Build Matrix-Of-Clusters</p></a></li>
<li><a href='#chooseKusingAUC'><p>Choose number of clusters based on AUC</p></a></li>
<li><a href='#coca'><p>Cluster-Of-Clusters Analysis</p></a></li>
<li><a href='#computeAUC'><p>Compute Area Under the Curve (AUC)</p></a></li>
<li><a href='#consensusCluster'><p>Consensus clustering</p></a></li>
<li><a href='#expandMOC'><p>Expand matrix of clusters</p></a></li>
<li><a href='#fillMOC'><p>Fill Matrix-Of-Clusters</p></a></li>
<li><a href='#maximiseSilhouette'><p>Choose K that maximises the silhouette from a set of kernel matrices and</p>
clusterings</a></li>
<li><a href='#plotDeltaAUC'><p>Plot area under the curve</p></a></li>
<li><a href='#plotDunn2s'><p>Plot Dunn's alternative index</p></a></li>
<li><a href='#plotDunns'><p>Plot Dunn's index</p></a></li>
<li><a href='#plotMOC'><p>Plot Matrix-Of-Clusters</p></a></li>
<li><a href='#plotSilhouette'><p>Plot silhouette</p></a></li>
<li><a href='#plotWidestGap'><p>Plot widest gap</p></a></li>
<li><a href='#stratifiedSamplingForCV'><p>Divide data into 5 subsets using stratified sampling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cluster-of-Clusters Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandra Cabassi
    <a href="https://orcid.org/0000-0003-1605-652X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Paul DW Kirk <a href="https://orcid.org/0000-0002-5931-7489"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths]</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains the R functions needed to perform Cluster-Of-Clusters Analysis (COCA)  and Consensus Clustering (CC). For further details please see Cabassi and Kirk (2020) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa593">doi:10.1093/bioinformatics/btaa593</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/acabassi/coca">http://github.com/acabassi/coca</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/acabassi/coca/issues">http://github.com/acabassi/coca/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, cluster, fpc, glmnet, Matrix, nnet, pheatmap,
RColorBrewer, sparcl, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mclust, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-06 15:09:00 UTC; alessandracabassi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandra Cabassi &lt;alessandra.cabassi@mrc-bsu.cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-06 17:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildMOC'>Build Matrix-Of-Clusters</h2><span id='topic+buildMOC'></span>

<h3>Description</h3>

<p>This function creates a matrix of clusters starting from a list of
heterogeneous datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMOC(
  data,
  M,
  K = NULL,
  maxK = 10,
  methods = "hclust",
  distances = "euclidean",
  fill = FALSE,
  computeAccuracy = FALSE,
  fullData = FALSE,
  savePNG = FALSE,
  fileName = "buildMOC",
  widestGap = FALSE,
  dunns = FALSE,
  dunn2s = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildMOC_+3A_data">data</code></td>
<td>
<p>List of M datasets, each of size N X P_m, where m = 1, ..., M.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_m">M</code></td>
<td>
<p>Number of datasets.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_k">K</code></td>
<td>
<p>Vector containing the number of clusters in each dataset. If given
an integer instead of a vector it is assumed that each dataset has the same
number of clusters. If NULL, it is assumed that the true cluster numbers are
not known, therefore they will be estimated using the silhouette method.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_maxk">maxK</code></td>
<td>
<p>Vector of maximum cluster numbers to be considered for each
dataset if K is NULL. If given an integer instead of a vector it is assumed
that for each dataset the same maximum number of clusters must be considered.
Default is 10.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_methods">methods</code></td>
<td>
<p>Vector of strings containing the names of the clustering
methods to be used to cluster the observations in each dataset. Each can be
&quot;kmeans&quot; (k-means clustering), &quot;hclust&quot; (hierarchical clustering), or &quot;pam&quot;
(partitioning around medoids). If the vector is of length one, the same
clustering method is applied to all the datasets. Default is &quot;hclust&quot;.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_distances">distances</code></td>
<td>
<p>Distances to be used in the clustering step for each
dataset. If only one string is provided, then the same distance is used for
all datasets. If the number of strings provided is the same as the number of
datasets, then each distance will be used for the corresponding dataset.
Default is &quot;euclidean&quot;. Please note that not all distances are compatible
with all clustering methods. &quot;euclidean&quot; and &quot;manhattan&quot; work with all
available clustering algorithms. &quot;gower&quot; distance is only available for
partitioning around medoids. In addition, &quot;maximum&quot;, &quot;canberra&quot;, &quot;binary&quot; or
&quot;minkowski&quot; are available for k-means and hierarchical clustering.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_fill">fill</code></td>
<td>
<p>Boolean. If TRUE, if there are any missing observations in one or
more datasets, the corresponding cluster labels will be estimated through
generalised linear models on the basis of the available labels.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_computeaccuracy">computeAccuracy</code></td>
<td>
<p>Boolean. If TRUE, for each missing element, the
performance of the predictive model used to estimate the corresponding
missing label is computer.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_fulldata">fullData</code></td>
<td>
<p>Boolean. If TRUE, the full data matrices are used to estimate
the missing cluster labels (instead of just using the cluster labels of the
corresponding datasets).</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_savepng">savePNG</code></td>
<td>
<p>Boolean. If TRUE, plots of the silhouette for each datasets
are saved as png files. Default is FALSE.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_filename">fileName</code></td>
<td>
<p>If <code>savePNG</code> is TRUE, this is the string containing the
name of the output files. Can be used to specify the folder path too. Default
is &quot;buildMOC&quot;. The &quot;.png&quot; extension is automatically added to this string.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_widestgap">widestGap</code></td>
<td>
<p>Boolean. If TRUE, compute also widest gap index to choose
best number of clusters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_dunns">dunns</code></td>
<td>
<p>Boolean. If TRUE, compute also Dunn's index to choose best
number of clusters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="buildMOC_+3A_dunn2s">dunn2s</code></td>
<td>
<p>Boolean. If TRUE, compute also alternative Dunn's index to
choose best number of clusters. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list containing:
</p>
<table>
<tr><td><code>moc</code></td>
<td>
<p>the Matrix-Of-Clusters, a binary matrix of size N x sum(K)
where element (n,k) contains a 1 if observation n belongs to the
corresponding cluster, 0 otherwise.</p>
</td></tr>
<tr><td><code>datasetIndicator</code></td>
<td>
<p>a vector of length sum(K) in which
each element is the number of the dataset to which the cluster belongs.</p>
</td></tr>
<tr><td><code>number_nas</code></td>
<td>
<p>the total number of NAs in the matrix of clusters. (If the
MOC has been filled with imputed values, <code>number_nas</code> indicates the
number of NAs in the original MOC.)</p>
</td></tr>
<tr><td><code>clLabels</code></td>
<td>
<p>a matrix that is equivalent to the matrix of clusters, but is
in compact form, i.e. each column corresponds to a dataset, each row
represents an observation, and its values indicate the cluster labels.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>vector of cluster numbers in each dataset. If these are provided as
input, this is the same as the input (expanded to a vector if the input is an
integer). If the cluster numbers are not provided as input, this vector
contains the cluster numbers chosen via silhouette for each dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>The Cancer Genome Atlas, 2012. Comprehensive molecular portraits
of human breast tumours. Nature, 487(7407), pp.61–70.
</p>
<p>Rousseeuw, P.J., 1987. Silhouettes: a graphical aid to the
interpretation and validation of cluster analysis. Journal of computational
and applied mathematics, 20, pp.53-65.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- list()
data[[1]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "coca"), row.names = 1))
data[[2]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset2.csv",
package = "coca"), row.names = 1))
data[[3]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset3.csv",
package = "coca"), row.names = 1))

# Build matrix of clusters
outputBuildMOC &lt;- buildMOC(data, M = 3, K = 6, distances = "cor")

# Extract matrix of clusters
matrixOfClusters &lt;- outputBuildMOC$moc

</code></pre>

<hr>
<h2 id='chooseKusingAUC'>Choose number of clusters based on AUC</h2><span id='topic+chooseKusingAUC'></span>

<h3>Description</h3>

<p>This function allows to choose the number of clusters in a dataset
based on the area under the curve of the empirical distribution
function of a consensus matrix, calculated for different (consecutive)
cluster numbers, as explained in the article by Monti et al. (2003),
Section 3.3.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseKusingAUC(areaUnderTheCurve, savePNG = FALSE, fileName = "deltaAUC.png")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseKusingAUC_+3A_areaunderthecurve">areaUnderTheCurve</code></td>
<td>
<p>Vector of length maxK-1 containing the area
under the curve of the empirical distribution function of the
consensus matrices obtained with K varying from 2 to maxK.</p>
</td></tr>
<tr><td><code id="chooseKusingAUC_+3A_savepng">savePNG</code></td>
<td>
<p>Boolean. If TRUE, a plot of the area under the curve
for each value of K is saved as a png file. The file is saved in a
subdirectory of the working directory, called &quot;delta-auc&quot;. Default is FALSE.</p>
</td></tr>
<tr><td><code id="chooseKusingAUC_+3A_filename">fileName</code></td>
<td>
<p>If <code>savePNG</code> is TRUE, this is the name of the png file.
Can be used to specify the folder path too. Default is &quot;deltaAUC&quot;. The &quot;.png&quot;
extension is automatically added to this string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list containing:
</p>
<table>
<tr><td><code>deltaAUC</code></td>
<td>
<p>a vector of
length maxK-1 where element i is  the area under the curve for
K = i+1 minus the area under the curve for K = i (for i = 2 this
is simply the area under the curve for K = i)</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the lowest among the values of K that are chosen by the algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Monti, S., Tamayo, P., Mesirov, J. and Golub, T., 2003. Consensus
clustering: a resampling-based method for class discovery and visualization
of gene expression microarray data. Machine learning, 52(1-2), pp.91-118.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assuming that we want to choose among any value of K (number of clusters)
# between 2 and 10 and that the area under the curve is as follows:
areaUnderTheCurve &lt;- c(0.05, 0.15, 0.4, 0.5, 0.55, 0.56, 0.57, 0.58, 0.59)

# The optimal value of K can be chosen with:
K &lt;- chooseKusingAUC(areaUnderTheCurve)$K
</code></pre>

<hr>
<h2 id='coca'>Cluster-Of-Clusters Analysis</h2><span id='topic+coca'></span>

<h3>Description</h3>

<p>This function allows to do Cluster-Of-Clusters Analysis on a binary matrix
where each column is a clustering of the data, each row corresponds to a data
point and the element in position (i,j) is equal to 1 if data point i belongs
to cluster j, 0 otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coca(
  moc,
  K = NULL,
  maxK = 6,
  B = 1000,
  pItem = 0.8,
  hclustMethod = "average",
  choiceKmethod = "silhouette",
  ccClMethod = "kmeans",
  ccDistHC = "euclidean",
  maxIterKM = 1000,
  savePNG = FALSE,
  fileName = "coca",
  verbose = FALSE,
  widestGap = FALSE,
  dunns = FALSE,
  dunn2s = FALSE,
  returnAllMatrices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coca_+3A_moc">moc</code></td>
<td>
<p>N X C data matrix, where C is the total number of clusters
considered.</p>
</td></tr>
<tr><td><code id="coca_+3A_k">K</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="coca_+3A_maxk">maxK</code></td>
<td>
<p>Maximum number of clusters considered for the final clustering if
K is not known. Default is 6.</p>
</td></tr>
<tr><td><code id="coca_+3A_b">B</code></td>
<td>
<p>Number of iterations of the Consensus Clustering step.</p>
</td></tr>
<tr><td><code id="coca_+3A_pitem">pItem</code></td>
<td>
<p>Proportion of items sampled at each iteration of the Consensus
Cluster step.</p>
</td></tr>
<tr><td><code id="coca_+3A_hclustmethod">hclustMethod</code></td>
<td>
<p>Agglomeration method to be used by the hclust function to
perform hierarchical clustering on the consensus matrix. Can be &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot;, etc. For more details please see ?stats::hclust.</p>
</td></tr>
<tr><td><code id="coca_+3A_choicekmethod">choiceKmethod</code></td>
<td>
<p>Method used to choose the number of clusters if K is
NULL, can be either &quot;AUC&quot; (area under the curve, work in progress) or
&quot;silhouette&quot;. Default is &quot;silhouette&quot;.</p>
</td></tr>
<tr><td><code id="coca_+3A_ccclmethod">ccClMethod</code></td>
<td>
<p>Clustering method to be used by the Consensus Clustering
algorithm (CC). Can be either &quot;kmeans&quot; for k-means clustering or &quot;hclust&quot; for
hiearchical clustering. Default is &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code id="coca_+3A_ccdisthc">ccDistHC</code></td>
<td>
<p>Distance to be used by the hiearchical clustering algorithm
inside CC. Can be &quot;pearson&quot; (for 1 - Pearson correlation), &quot;spearman&quot; (for 1-
Spearman correlation), or any of the distances provided in stats::dist()
(i.e. &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or
&quot;minkowski&quot;). Default is &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="coca_+3A_maxiterkm">maxIterKM</code></td>
<td>
<p>Number of iterations for the k-means clustering algorithm.
Default is 1000.</p>
</td></tr>
<tr><td><code id="coca_+3A_savepng">savePNG</code></td>
<td>
<p>Boolean. Save plots as PNG files. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coca_+3A_filename">fileName</code></td>
<td>
<p>If <code>savePNG</code> is TRUE, this is the string containing (the
first part of) the name of the output files. Can be used to specify the
folder path too. Default is &quot;coca&quot;. The &quot;.png&quot; extension is automatically
added to this string.</p>
</td></tr>
<tr><td><code id="coca_+3A_verbose">verbose</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="coca_+3A_widestgap">widestGap</code></td>
<td>
<p>Boolean. If TRUE, compute also widest gap index to choose
best number of clusters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coca_+3A_dunns">dunns</code></td>
<td>
<p>Boolean. If TRUE, compute also Dunn's index to choose best
number of clusters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coca_+3A_dunn2s">dunn2s</code></td>
<td>
<p>Boolean. If TRUE, compute also alternative Dunn's index to
choose best number of clusters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coca_+3A_returnallmatrices">returnAllMatrices</code></td>
<td>
<p>Boolean. If TRUE, return consensus matrices for all
considered values of K. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list containing:
</p>
<table>
<tr><td><code>consensusMatrix</code></td>
<td>
<p>a symmetric matrix where the element in position
(i,j) corresponds to the proportion of times that items i and j have been
clustered together and a vector of cluster labels.</p>
</td></tr>
<tr><td><code>clusterLabels</code></td>
<td>
<p>the final cluster labels.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the final number of clusters. If provided by the user, this is
the same as the input. Otherwise, this is the number of clusters selected via
the requested method (see argument <code>choiceKmethod</code>).</p>
</td></tr>
<tr><td><code>consensusMatrices</code></td>
<td>
<p>if returnAllMatrices = TRUE, this array
also returned, containing the consensus matrices obtained for each of the
numbers of clusters considered by the algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>The Cancer Genome Atlas, 2012. Comprehensive molecular
portraits of human breast tumours. Nature, 487(7407), pp.61–70.
</p>
<p>Cabassi, A. and Kirk, P. D. W. (2019). Multiple kernel learning
for integrative consensus clustering of 'omic datasets. arXiv preprint.
arXiv:1904.07701.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- list()
data[[1]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "coca"), row.names = 1))
data[[2]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset2.csv",
package = "coca"), row.names = 1))
data[[3]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset3.csv",
package = "coca"), row.names = 1))

# Build matrix of clusters
outputBuildMOC &lt;- buildMOC(data, M = 3, K = 5, distances = "cor")

# Extract matrix of clusters
moc &lt;- outputBuildMOC$moc

# Do Cluster-Of-Clusters Analysis
outputCOCA &lt;- coca(moc, K = 5)

# Extract cluster labels
clusterLabels &lt;- outputCOCA$clusterLabels

</code></pre>

<hr>
<h2 id='computeAUC'>Compute Area Under the Curve (AUC)</h2><span id='topic+computeAUC'></span>

<h3>Description</h3>

<p>This function allows to compute the area under the curve of the empirical
distribution function of a consensus matrix as described in Monti et al.
(2003), Section 3.3.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAUC(consensusMatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeAUC_+3A_consensusmatrix">consensusMatrix</code></td>
<td>
<p>Consensus matrix, output of the
&quot;coca::consensusCluster&quot; function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the area under the curve.
</p>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='consensusCluster'>Consensus clustering</h2><span id='topic+consensusCluster'></span>

<h3>Description</h3>

<p>This function allows to perform consensus clustering using the k-means
clustering algorithm, for a fixed number of clusters. We consider the number
of clusters K to be fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensusCluster(
  data = NULL,
  K = 2,
  B = 100,
  pItem = 0.8,
  clMethod = "hclust",
  dist = "euclidean",
  hclustMethod = "average",
  sparseKmeansPenalty = NULL,
  maxIterKM = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensusCluster_+3A_data">data</code></td>
<td>
<p>N X P data matrix</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_k">K</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_b">B</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_pitem">pItem</code></td>
<td>
<p>Proportion of items sampled at each iteration.</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_clmethod">clMethod</code></td>
<td>
<p>Clustering algorithm. Can be &quot;hclust&quot; for hierarchical
clustering, &quot;kmeans&quot; for k-means clustering, &quot;pam&quot; for partitioning around
medoids, &quot;sparse-kmeans&quot; for sparse k-means clustering or &quot;sparse-hclust&quot;
for sparse hierarchical clustering. Default is &quot;hclust&quot;. However, if the data
contain at least one covariate that is a factor, the default clustering
algorithm is &quot;pam&quot;.</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_dist">dist</code></td>
<td>
<p>Distance used for hierarchical clustering. Can be &quot;pearson&quot; (for
1 - Pearson correlation), &quot;spearman&quot; (for 1- Spearman correlation), any of
the distances provided in stats::dist() (i.e. &quot;euclidean&quot;, &quot;maximum&quot;,
&quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;), or a matrix containing the
distances between the observations.</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_hclustmethod">hclustMethod</code></td>
<td>
<p>Hierarchical clustering method. Default is &quot;average&quot;. For
more details see <code>?hclust</code>.</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_sparsekmeanspenalty">sparseKmeansPenalty</code></td>
<td>
<p>If the selected clustering method is
&quot;sparse-kmeans&quot;, this is the value of the parameter &quot;wbounds&quot; of the
&quot;KMeansSparseCluster&quot; function. The default value is the square root of the
number of variables.</p>
</td></tr>
<tr><td><code id="consensusCluster_+3A_maxiterkm">maxIterKM</code></td>
<td>
<p>Number of iterations for the k-means clustering algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a consensus matrix, that is a symmetric matrix where
the element in position (i,j) corresponds to the proportion of times that
items i and j have been clustered together.
</p>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Monti, S., Tamayo, P., Mesirov, J. and Golub, T., 2003. Consensus
clustering: a resampling-based method for class discovery and visualization
of gene expression microarray data. Machine learning, 52(1-2), pp.91-118.
</p>
<p>Witten, D.M. and Tibshirani, R., 2010. A framework for feature
selection in clustering. Journal of the American Statistical Association,
105(490), pp.713-726.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load one dataset with 300 observations, 2 variables, 6 clusters
data &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "coca"), row.names = 1))

# Compute consensus clustering with K=5 clusters
cm &lt;- consensusCluster(data, K = 5)
</code></pre>

<hr>
<h2 id='expandMOC'>Expand matrix of clusters</h2><span id='topic+expandMOC'></span>

<h3>Description</h3>

<p>Expand matrix of cluster labels into matrix of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandMOC(clLabels, datasetNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandMOC_+3A_cllabels">clLabels</code></td>
<td>
<p>Matrix of cluster labels of size N x M.</p>
</td></tr>
<tr><td><code id="expandMOC_+3A_datasetnames">datasetNames</code></td>
<td>
<p>Vector of cluster names of length M. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list containing:
</p>
<table>
<tr><td><code>moc</code></td>
<td>
<p>the matrix of clusters.</p>
</td></tr>
<tr><td><code>datasetIndicator</code></td>
<td>
<p>a vector containing the dataset indicator.</p>
</td></tr>
<tr><td><code>datasetNames</code></td>
<td>
<p>an expanded vector of dataset names for the moc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- list()
data[[1]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "coca"), row.names = 1))
data[[2]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset2.csv",
package = "coca"), row.names = 1))
data[[3]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset3.csv",
package = "coca"), row.names = 1))

# Build matrix of clusters
outputBuildMOC &lt;- buildMOC(data, M = 3, K = 6, distances = "cor")

# Extract matrix of clusters
clLabels &lt;- outputBuildMOC$clLabels

# Impute missing values
outputFillMOC &lt;- fillMOC(clLabels, data = data)

# Replace matrix of cluster labels with new (full) one
clLabels &lt;- outputFillMOC$fullClLabels

# Expand matrix of cluster labels into matrix of clusters
outputExpandMOC &lt;- expandMOC(clLabels)
clLabels &lt;- outputExpandMOC$clLabels
</code></pre>

<hr>
<h2 id='fillMOC'>Fill Matrix-Of-Clusters</h2><span id='topic+fillMOC'></span>

<h3>Description</h3>

<p>This function fills in a matrix of clusters that contains NAs, by estimating
the missing cluster labels based on the available ones or based on the other
datasets. The predictive accuracy of this method can also be estimated via
cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillMOC(clLabels, data, computeAccuracy = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillMOC_+3A_cllabels">clLabels</code></td>
<td>
<p>N X M matrix containing cluster labels. Element (n,m)
contains the cluster label for element data point n in cluster m.</p>
</td></tr>
<tr><td><code id="fillMOC_+3A_data">data</code></td>
<td>
<p>List of M datasets to be used for the label imputation.</p>
</td></tr>
<tr><td><code id="fillMOC_+3A_computeaccuracy">computeAccuracy</code></td>
<td>
<p>Boolean. If TRUE, for each missing element, the
performance of the predictive model used to estimate the corresponding
missing label is computer. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fillMOC_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If TRUE, for each NA, the size of the matrix used to
estimate its values is printed to screen. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list containing:
</p>
<table>
<tr><td><code>fullClLabels</code></td>
<td>
<p>the same matrix of clusters as the input matrix
<code>clLabels</code>, where NAs have been replaced by their estimates, where
possible.</p>
</td></tr>
<tr><td><code>nRows</code></td>
<td>
<p>matrix where the item in position (i,j) indicates the
number of observations used in the predictive model used to estimate  the
corresponding missing label in the <code>fullClLabels</code> matrix.</p>
</td></tr>
<tr><td><code>nColumns</code></td>
<td>
<p>matrix where the item in position (i,j) indicates the
number of covariates used in the predictive model used to
estimate the corresponding missing label in the <code>fullClLabels</code> matrix.</p>
</td></tr>
<tr><td><code>accuracy</code></td>
<td>
<p>a matrix where each element
corresponds to the predictive accuracy of the predictive model used to
estimate the corresponding label in the cluster label matrix. This is only
returned if the argument <code>computeAccuracy</code> is set to TRUE.</p>
</td></tr>
<tr><td><code>accuracy_random</code></td>
<td>
<p>This is computed in the same way as <code>accuracy</code>,
but with the labels randomly shuffled. This can be used in order to assess
the predictive accuracy of the imputation algorithm and is returned only if
the argument <code>computeAccuracy</code> is set to TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>The Cancer Genome Atlas, 2012. Comprehensive molecular portraits
of human breast tumours. Nature, 487(7407), pp.61–70.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- list()
data[[1]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
                       package = "coca"), row.names = 1))
data[[2]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset2.csv",
                       package = "coca"), row.names = 1))
data[[3]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset3.csv",
                       package = "coca"), row.names = 1))

# Build matrix of clusters
outputBuildMOC &lt;- buildMOC(data, M = 3, K = 6, distances = "cor")

# Extract matrix of clusters
clLabels &lt;- outputBuildMOC$clLabels

# Impute missing values using full datasets
outputFillMOC &lt;- fillMOC(clLabels, data)

# Extract full matrix of cluster labels
clLabels2 &lt;- outputFillMOC$fullClLabels
</code></pre>

<hr>
<h2 id='maximiseSilhouette'>Choose K that maximises the silhouette from a set of kernel matrices and
clusterings</h2><span id='topic+maximiseSilhouette'></span>

<h3>Description</h3>

<p>Choose the number of clusters K that maximises the silhouette, starting from
a set of kernel matrices each corresponding to a different choice of K and
the corresponding clusterings of the data for each of those values of K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximiseSilhouette(
  kernelMatrix,
  clLabels,
  maxK,
  savePNG = FALSE,
  fileName = "silhouette",
  isDistance = FALSE,
  widestGap = FALSE,
  dunns = FALSE,
  dunn2s = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximiseSilhouette_+3A_kernelmatrix">kernelMatrix</code></td>
<td>
<p>N X N X (maxK-1) array of kernel matrices.</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_cllabels">clLabels</code></td>
<td>
<p>(maxK-1) X N matrix containing the clusterings obtained for
different values of K.</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_maxk">maxK</code></td>
<td>
<p>Maximum number of clusters considered.</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_savepng">savePNG</code></td>
<td>
<p>If TRUE, a plot of the silhouette is saved in the working
folder. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_filename">fileName</code></td>
<td>
<p>If <code>savePNG</code> is TRUE, this is the name of the png file.</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_isdistance">isDistance</code></td>
<td>
<p>Boolean. If TRUE, the kernel matrices are interpreted as
matrices of distances, otherwise as matrices of similarities.</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_widestgap">widestGap</code></td>
<td>
<p>Boolean. If TRUE, also computes widest gap index (and plots
it if <code>savePNG</code> is TRUE).</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_dunns">dunns</code></td>
<td>
<p>Boolean. If TRUE, also computes Dunn's index: minimum separation
/ maximum diameter (and plots it if <code>savePNG</code> is TRUE).</p>
</td></tr>
<tr><td><code id="maximiseSilhouette_+3A_dunn2s">dunn2s</code></td>
<td>
<p>Boolean. If TRUE, also computes an alternative version
of Dunn's index: minimum average dissimilarity between two cluster / maximum
average within cluster dissimilarity (and plots it if <code>savePNG</code> is
TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>silh</code></td>
<td>
<p>a vector of length <code>maxK-1</code> such that <code>silh[i]</code> is the
silhouette for <code>K = i+1</code></p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the lowest number of clusters for which the silhouette is
maximised.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='plotDeltaAUC'>Plot area under the curve</h2><span id='topic+plotDeltaAUC'></span>

<h3>Description</h3>

<p>Plot area under the curve for different values of K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDeltaAUC(deltaAUC, chosenK = NULL, fileName = "deltaAUC.png")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDeltaAUC_+3A_deltaauc">deltaAUC</code></td>
<td>
<p>Vector of the difference between the area under the curve
between each value K of the number of clusters and K-1. For the smallest
value considered (usually two) this is simply the area under the curve for
that value of cluster number.</p>
</td></tr>
<tr><td><code id="plotDeltaAUC_+3A_chosenk">chosenK</code></td>
<td>
<p>Chosen number of clusters. If specified, a vertical line is
plotted in correspondance of the indicated value. Default is NULL.</p>
</td></tr>
<tr><td><code id="plotDeltaAUC_+3A_filename">fileName</code></td>
<td>
<p>name of the png file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='plotDunn2s'>Plot Dunn's alternative index</h2><span id='topic+plotDunn2s'></span>

<h3>Description</h3>

<p>Plot Dunn's alternative index (minimum average dissimilarity between two
cluster divided by maximum average within cluster dissimilarity) for
different values of K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDunn2s(dunns, chosenK = NULL, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDunn2s_+3A_dunns">dunns</code></td>
<td>
<p>Vector of widest gap values for K from 2 to some value maxK.</p>
</td></tr>
<tr><td><code id="plotDunn2s_+3A_chosenk">chosenK</code></td>
<td>
<p>Chosen number of clusters. If specified, a vertical line is
plotted in correspondence of the indicated value. Default is NULL.</p>
</td></tr>
<tr><td><code id="plotDunn2s_+3A_filename">fileName</code></td>
<td>
<p>Name of the png file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='plotDunns'>Plot Dunn's index</h2><span id='topic+plotDunns'></span>

<h3>Description</h3>

<p>Plot Dunn's index (minimum separation / maximum diameter) for different
values of K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDunns(dunns, chosenK = NULL, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDunns_+3A_dunns">dunns</code></td>
<td>
<p>Vector of widest gap values for K from 2 to some value maxK.</p>
</td></tr>
<tr><td><code id="plotDunns_+3A_chosenk">chosenK</code></td>
<td>
<p>Chosen number of clusters. If specified, a vertical line is
plotted in correspondence of the indicated value. Default is NULL.</p>
</td></tr>
<tr><td><code id="plotDunns_+3A_filename">fileName</code></td>
<td>
<p>Name of the png file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='plotMOC'>Plot Matrix-Of-Clusters</h2><span id='topic+plotMOC'></span>

<h3>Description</h3>

<p>This function creates a matrix of clusters, starting from a list of
heterogeneous datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMOC(
  moc,
  datasetIndicator,
  datasetNames = NULL,
  annotations = NULL,
  clr = FALSE,
  clc = FALSE,
  savePNG = FALSE,
  fileName = "moc.png",
  showObsNames = FALSE,
  showClusterNames = FALSE,
  annotation_colors = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMOC_+3A_moc">moc</code></td>
<td>
<p>Matrix-Of-Clusters of size N x sumK.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_datasetindicator">datasetIndicator</code></td>
<td>
<p>Vector containing integers indicating which rows
correspond to some clustering of the same dataset.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_datasetnames">datasetNames</code></td>
<td>
<p>Vector containing the names of the datasets to which each
column of labels corresponds. If NULL, datasetNames will be the same as
datasetIndicator. Default is NULL.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_annotations">annotations</code></td>
<td>
<p>Dataframe containing annotations. Number of rows must be
N. If the annotations are integers, use <code>as.factor()</code> for a better
visual result.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_clr">clr</code></td>
<td>
<p>Cluster rows. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_clc">clc</code></td>
<td>
<p>Cluster columns. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_savepng">savePNG</code></td>
<td>
<p>Boolean. If TRUE, plot is saved as a png file.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_filename">fileName</code></td>
<td>
<p>If <code>savePNG</code> is TRUE, this is the string containing the
name of the moc figure. Can be used to specify the folder path too. Default
is &quot;moc&quot;. The &quot;.png&quot; extension is automatically added to this string.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_showobsnames">showObsNames</code></td>
<td>
<p>Boolean. If TRUE, the plot will also include the column
names (i.e. name of each observation). Default is FALSE, since there are
usually too many columns.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_showclusternames">showClusterNames</code></td>
<td>
<p>Boolean. If TRUE, plot cluster names next to
corresponding row. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotMOC_+3A_annotation_colors">annotation_colors</code></td>
<td>
<p>Optional. See annotation_colors in
pheatmap::pheatmap.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>The Cancer Genome Atlas, 2012. Comprehensive molecular portraits
of human breast tumours. Nature, 487(7407), pp.61–70.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- list()
data[[1]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "coca"), row.names = 1))
data[[2]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset2.csv",
package = "coca"), row.names = 1))
data[[3]] &lt;- as.matrix(read.csv(system.file("extdata", "dataset3.csv",
package = "coca"), row.names = 1))

# Create vector of dataset names, in the same order as they appear above
datasetNames &lt;- c("Dataset1", "Dataset2", "Dataset3")

# Build matrix of clusters
outputBuildMOC &lt;- buildMOC(data, M = 3, K = 6, distances = "cor")

# Extract matrix of clusters and dataset indicator vector
moc &lt;- outputBuildMOC$moc
datasetIndicator &lt;- outputBuildMOC$datasetIndicator

# Prepare annotations
true_labels &lt;- as.matrix(read.csv(
system.file("extdata", "cluster_labels.csv", package = "coca"),
row.names = 1))
annotations &lt;- data.frame(true_labels = as.factor(true_labels))

# Plot matrix of clusters
plotMOC(moc,
        datasetIndicator,
        datasetNames = datasetNames,
        annotations = annotations)
</code></pre>

<hr>
<h2 id='plotSilhouette'>Plot silhouette</h2><span id='topic+plotSilhouette'></span>

<h3>Description</h3>

<p>Plot average silhouette for different values of K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSilhouette(sil, chosenK = NULL, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSilhouette_+3A_sil">sil</code></td>
<td>
<p>vector of the average silhouette for K from 2 to some value maxK</p>
</td></tr>
<tr><td><code id="plotSilhouette_+3A_chosenk">chosenK</code></td>
<td>
<p>Chosen number of clusters. If specified, a vertical line is
plotted in correspondence of the indicated value. Default is NULL.</p>
</td></tr>
<tr><td><code id="plotSilhouette_+3A_filename">fileName</code></td>
<td>
<p>Name of the png file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='plotWidestGap'>Plot widest gap</h2><span id='topic+plotWidestGap'></span>

<h3>Description</h3>

<p>Plot widest gap for different values of K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotWidestGap(widestGap, chosenK = NULL, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotWidestGap_+3A_widestgap">widestGap</code></td>
<td>
<p>Vector of widest gap values for K from 2 to some value maxK.</p>
</td></tr>
<tr><td><code id="plotWidestGap_+3A_chosenk">chosenK</code></td>
<td>
<p>Chosen number of clusters. If specified, a vertical line is
plotted in correspondence of the indicated value. Default is NULL.</p>
</td></tr>
<tr><td><code id="plotWidestGap_+3A_filename">fileName</code></td>
<td>
<p>Name of the png file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='stratifiedSamplingForCV'>Divide data into 5 subsets using stratified sampling</h2><span id='topic+stratifiedSamplingForCV'></span>

<h3>Description</h3>

<p>This function is used to do stratified subsampling based on the
number of observations in each group in the response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratifiedSamplingForCV(response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratifiedSamplingForCV_+3A_response">response</code></td>
<td>
<p>Vector of categorical responses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector of labels to assign each observation to
a different fold
</p>


<h3>Author(s)</h3>

<p>Alessandra Cabassi  <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
