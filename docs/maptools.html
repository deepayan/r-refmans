<!DOCTYPE html><html><head><title>Help for package maptools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {maptools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.im'><p>Coercion between sp objects and spatstat im objects</p></a></li>
<li><a href='#as.linnet.SpatialLines'>
<p>Convert SpatialLines to Linear Network</p></a></li>
<li><a href='#as.owin'><p>Coercion between sp objects and spatstat owin objects</p></a></li>
<li><a href='#as.ppp'><p>Coercion between sp objects and spatstat ppp objects</p></a></li>
<li><a href='#as.psp'><p>Coercion between sp objects and spatstat psp objects</p></a></li>
<li><a href='#as.SpatialPolygons.tess'><p>Coercion of spatstat tess object to sp SpatialPolygons object</p></a></li>
<li><a href='#CCmaps'><p>Conditioned choropleth maps</p></a></li>
<li><a href='#checkPolygonsHoles'><p>Check holes in Polygons objects</p></a></li>
<li><a href='#ContourLines2SLDF'><p>Converter functions to build SpatialLinesDataFrame objects</p></a></li>
<li><a href='#dotsInPolys'><p>Put dots in polygons</p></a></li>
<li><a href='#elide-methods'><p>Methods for Function elide in Package &lsquo;maptools&rsquo;</p></a></li>
<li><a href='#gcDestination'><p>Find destination in geographical coordinates</p></a></li>
<li><a href='#GE_SpatialGrid'><p>Create SpatialGrid for PNG output to GE</p></a></li>
<li><a href='#getinfo.shape'><p>Get shapefile header information</p></a></li>
<li><a href='#getKMLcoordinates'><p>Get a list of coordinates out of a KML file</p></a></li>
<li><a href='#gpcholes'><p>Hisaji Ono's lake/hole problem</p></a></li>
<li><a href='#gzAzimuth'><p>Find azimuth for geographical coordinates</p></a></li>
<li><a href='#kmlLine'><p>Create and write a KML file on the basis of a given Lines object</p></a></li>
<li><a href='#kmlLines'><p>Create and write a KML file on the basis of a given Lines object</p></a></li>
<li><a href='#kmlOverlay'><p>Create and write KML file for PNG image overlay</p></a></li>
<li><a href='#kmlPoints'><p>Create and write a KML file on the basis of a given Points object</p></a></li>
<li><a href='#kmlPolygon'><p>Create and write a KML file on the basis of a given Polygons object</p></a></li>
<li><a href='#kmlPolygons'><p>Create and write a KML file on the basis of a given Polygons object or list of Polygons or SpatialPolygonsDataFrame</p></a></li>
<li><a href='#leglabs'><p>Make legend labels</p></a></li>
<li><a href='#lineLabel'>
<p>Line label placement with spplot and lattice.</p></a></li>
<li><a href='#map2SpatialPolygons'><p>Convert map objects to sp classes</p></a></li>
<li><a href='#nearestPointOnLine'>
<p>Get the nearest point on a line to a given point</p></a></li>
<li><a href='#nearestPointOnSegment'>
<p>Get the nearest point on a segment to a given point</p></a></li>
<li><a href='#nowrapRecenter'><p>Break polygons at meridian for recentering</p></a></li>
<li><a href='#nowrapSpatialLines'><p>Split SpatialLines components at offset</p></a></li>
<li><a href='#pal2SpatialPolygons'><p>Making SpatialPolygons objects from RArcInfo input</p></a></li>
<li><a href='#panel.pointLabel'><p>Label placement with spplot and lattice.</p></a></li>
<li><a href='#pointLabel'><p> Label placement for points to avoid overlaps</p></a></li>
<li><a href='#ppp-class'><p>Virtual class &quot;ppp&quot;</p></a></li>
<li><a href='#readAsciiGrid'><p> read/write to/from (ESRI) asciigrid format</p></a></li>
<li><a href='#readGPS'><p>GPSbabel read interface</p></a></li>
<li><a href='#readShapeLines'><p>Read arc shape files into SpatialLinesDataFrame objects</p></a></li>
<li><a href='#readShapePoints'><p>Read points shape files into SpatialPointsDataFrame objects</p></a></li>
<li><a href='#readShapePoly'><p>Read polygon shape files into SpatialPolygonsDataFrame objects</p></a></li>
<li><a href='#readShapeSpatial'><p>Read shape files into Spatial*DataFrame objects</p></a></li>
<li><a href='#readSplus'><p>Read exported WinBUGS maps</p></a></li>
<li><a href='#Rgshhs'><p>Read GSHHS data into sp object</p></a></li>
<li><a href='#snapPointsToLines'>
<p>Snap a set of points to a set of lines</p></a></li>
<li><a href='#sp2Mondrian'><p>write map data for Mondrian</p></a></li>
<li><a href='#sp2tmap'><p>Convert SpatialPolygons object for Stata tmap command</p></a></li>
<li><a href='#sp2WB'><p>Export SpatialPolygons object as S-Plus map for WinBUGS</p></a></li>
<li><a href='#SpatialLines2PolySet'><p>Convert sp line and polygon objects to PBSmapping PolySet objects</p></a></li>
<li><a href='#SpatialLinesMidPoints'><p>Line midpoints</p></a></li>
<li><a href='#spCbind-methods'><p>cbind for spatial objects</p></a></li>
<li><a href='#SplashDams'><p>Data for Splash Dams in western Oregon</p></a></li>
<li><a href='#spRbind-methods'><p>rbind for spatial objects</p></a></li>
<li><a href='#state.vbm'><p> US State Visibility Based Map</p></a></li>
<li><a href='#sun-methods'><p>Methods for sun ephemerides calculations</p></a></li>
<li><a href='#symbolsInPolys'><p>Place grids of points over polygons</p></a></li>
<li><a href='#thinnedSpatialPoly'><p>Douglas-Peuker line generalization for Spatial Polygons</p></a></li>
<li><a href='#unionSpatialPolygons'><p>Aggregate Polygons in a SpatialPolygons object</p></a></li>
<li><a href='#wrld_simpl'><p>Simplified world country polygons</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Handling Spatial Objects</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), sp (&ge; 1.0-11)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreign (&ge; 0.8), methods, grid, lattice, stats, utils,
grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgeos (&ge; 0.1-8), spatstat.geom (&ge; 1.65-0), PBSmapping,
maps, RColorBrewer, raster, polyclip, plotrix, spatstat.linnet
(&ge; 1.65-3), spatstat.utils (&ge; 1.19.0), spatstat (&ge; 2.0-0)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gpclib</td>
</tr>
<tr>
<td>Description:</td>
<td>Please note that 'maptools' will be retired by the end of 2023, plan transition at your earliest convenience; some functionality will be moved to 'sp'. Set of tools for manipulating geographic data. It includes binary access to 'GSHHG' shoreline files. The package also provides interface wrappers for exchanging spatial objects with packages such as 'PBSmapping', 'spatstat.geom', 'maps', and others.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://maptools.r-forge.r-project.org/">http://maptools.r-forge.r-project.org/</a>,
<a href="https://r-forge.r-project.org/projects/maptools/">https://r-forge.r-project.org/projects/maptools/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-17 16:25:21 UTC; rsb</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Bivand <a href="https://orcid.org/0000-0003-2392-6140"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Nicholas Lewin-Koh [aut],
  Edzer Pebesma [ctb],
  Eric Archer [ctb],
  Adrian Baddeley [ctb],
  Nick Bearman [ctb],
  Hans-Jörg Bibiko [ctb],
  Steven Brey [ctb],
  Jonathan Callahan [ctb],
  German Carrillo [ctb],
  Stéphane Dray [ctb],
  David Forrest [ctb],
  Michael Friendly [ctb],
  Patrick Giraudoux [ctb],
  Duncan Golicher [ctb],
  Virgilio Gómez Rubio [ctb],
  Patrick Hausmann [ctb],
  Karl Ove Hufthammer [ctb],
  Thomas Jagger [ctb],
  Kent Johnson [ctb],
  Matthew Lewis <a href="https://orcid.org/0000-0003-2244-4078"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Sebastian Luque [ctb],
  Don MacQueen [ctb],
  Andrew Niccolai [ctb],
  Edzer Pebesma [ctb],
  Oscar Perpiñán Lamigueiro [ctb],
  Ethan Plunkett [ctb],
  Ege Rubak <a href="https://orcid.org/0000-0002-6675-533X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Tom Short [ctb],
  Greg Snow [ctb],
  Ben Stabler [ctb],
  Murray Stokely [ctb],
  Rolf Turner [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-17 19:12:32 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.3.0; x86_64-pc-linux-gnu; 2022-04-20 09:29:12 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='as.im'>Coercion between sp objects and spatstat im objects</h2><span id='topic+as.im.SpatialGridDataFrame'></span><span id='topic+coerce+2CSpatialGridDataFrame+2Cim-method'></span><span id='topic+as.SpatialGridDataFrame.im'></span><span id='topic+coerce+2Cim+2CSpatialGridDataFrame-method'></span><span id='topic+as.im.RasterLayer'></span>

<h3>Description</h3>

<p>Functions to convert between <span class="pkg">spatstat</span>s raster format <code>im</code> and <span class="pkg">sp</span>s <code>SpatialGridDataFrame</code> as well as one-way conversion from <span class="pkg">raster</span>s <code>rasterLayer</code> to <code>im</code>. S4-style <code>as()</code> coercion can be used between <code>im</code> and <code>SpatialGridDataFrame</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.im.SpatialGridDataFrame(from)
as.SpatialGridDataFrame.im(from)
as.im.RasterLayer(from, factor.col.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.im_+3A_from">from</code></td>
<td>
<p>object to coerce from</p>
</td></tr>
<tr><td><code id="as.im_+3A_factor.col.name">factor.col.name</code></td>
<td>
<p>column name of <code>levels(from)</code> to be treated as a factor; if NULL defaults to last column of <code>from</code>. Ignored if <code>from</code> is not a raster with factor values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>SpatialGridDataFrame</code> object may contain several columns of 
data such that several values are associated with each grid cell. In contrast an
<code>im</code> object can only contain a single variable value for each cell. In
<code>as.im.SpatialGridDataFrame()</code> the first data column is used. To convert 
another column to <code>im</code> format simply extract this column first as shown in
the example below.</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialGridDataFrame", to = "im")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "im", to = "SpatialGridDataFrame")</code></p>
</dd>
</dl>



<h3>Warning</h3>

<p>In <span class="pkg">spatstat</span> all spatial objects are assumed to be planar. This means
that <span class="pkg">spatstat</span> is not designed to work directly with geographic
(longitude and latitude) coordinates. If a <span class="pkg">sp</span> object is declared to
have geographic (unprojected) coordinates <span class="pkg">maptools</span> refuses to convert
directly to <span class="pkg">spatstat</span> format. Rather, these should be projected first
using e.g. <code><a href="sp.html#topic+spTransform">spTransform</a></code>. If you know what you are doing, and
really want to force coercion, you can overwrite the <code>proj4string</code> of the
<span class="pkg">sp</span> object with <code>NA</code>, <code>proj4string(x) &lt;- CRS(NA)</code>, which
will fool the system to think that the data is in local planar coordinates.
This is probably not a good idea!
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>, Roger Bivand</p>


<h3>See Also</h3>

<p>Other converters between <span class="pkg">sp</span> and <span class="pkg">spatstat</span>:
<code><a href="maptools.html#topic+as.ppp.SpatialPoints">as.ppp.SpatialPoints</a></code>,
<code><a href="maptools.html#topic+as.psp.SpatialLines">as.psp.SpatialLines</a></code>,
<code><a href="maptools.html#topic+as.owin.SpatialPolygons">as.owin.SpatialPolygons</a></code>,
<code><a href="maptools.html#topic+as.SpatialPolygons.tess">as.SpatialPolygons.tess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require("spatstat.geom", quietly=TRUE)) run &lt;- TRUE
if (run) {
## Extract an example SpatialGridDataFrame and plot it
data(meuse.grid) # A data.frame
gridded(meuse.grid) = ~x+y # Now a SpatialPixelsDataFrame
fullgrid(meuse.grid) &lt;- TRUE # Finally a SpatialGridDataFrame
mg_dist &lt;- meuse.grid["dist"] # A SpatialGridDataFrame with a single column
image(mg_dist, axes=TRUE)
}
if (run) {
## Convert to im format and plot it
mg_im &lt;- as(mg_dist, "im")
plot(mg_im)
}
if (run) {
## Convert back to SpatialGridDataFrame and plot it again
mg2 &lt;- as.SpatialGridDataFrame.im(mg_im)
image(mg2, axes=TRUE)
}
run &lt;- run &amp;&amp; require(raster, quietly=TRUE)
if (run) {
## Convert SpatialGridDataFrame -&gt; RasterLayer -&gt; im and plot it
r &lt;- as(mg2, "RasterLayer")
r_im &lt;- as.im.RasterLayer(r)
plot(r_im)
}
if (run) {
rr &lt;- raster(nrow=2, ncol=3)
values(rr) &lt;- 1:6
rr &lt;- as.factor(rr)
rrr &lt;- rr
f &lt;- levels(rrr)[[1]]
f$name &lt;- c("vector", "of", "values")
f$name2 &lt;- letters[1:6]
levels(rrr) &lt;- f
print(levels(rrr))
}
if (run) {
iii &lt;- as.im.RasterLayer(rrr)
plot(iii)
}
if (run) {
iv &lt;- as.im.RasterLayer(rrr, factor.col.name = "name")
plot(iv)
}
if (run) {
}
</code></pre>

<hr>
<h2 id='as.linnet.SpatialLines'>
Convert SpatialLines to Linear Network
</h2><span id='topic+as.linnet.SpatialLines'></span><span id='topic+coerce+2CSpatialLines+2Clinnet-method'></span><span id='topic+coerce+2CSpatialLinesDataFrame+2Clinnet-method'></span>

<h3>Description</h3>

<p>Convert an object of class <code>SpatialLines</code> or
<code>SpatialLinesDataFrame</code> (from package <span class="pkg">sp</span>),
representing a collection of polygonal lines,
into an object of class <code>linnet</code> (from package <span class="pkg">spatstat</span>),
representing a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.linnet.SpatialLines(X, ..., fuse = TRUE)
  ## S4 method for signature 'SpatialLines,linnet'
coerce(from, to = "linnet", strict = TRUE)
  ## S4 method for signature 'SpatialLinesDataFrame,linnet'
coerce(from, to = "linnet",
    strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.linnet.SpatialLines_+3A_x">X</code>, <code id="as.linnet.SpatialLines_+3A_from">from</code></td>
<td>

<p>Object of class <code>SpatialLines</code> or
<code>SpatialLinesDataFrame</code> to be converted.
</p>
</td></tr>
<tr><td><code id="as.linnet.SpatialLines_+3A_to">to</code></td>
<td>
<p>output object of class &ldquo;linnet&rdquo;.</p>
</td></tr>
<tr><td><code id="as.linnet.SpatialLines_+3A_strict">strict</code></td>
<td>
<p>logical flag. If TRUE, the returned object must be strictly from the target class.</p>
</td></tr>
<tr><td><code id="as.linnet.SpatialLines_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="as.linnet.SpatialLines_+3A_fuse">fuse</code></td>
<td>

<p>Logical value indicating whether to join different curves
which have a common vertex.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts an object of class <code>SpatialLines</code>
or <code>SpatialLinesDataFrame</code> into an object of class <code>linnet</code>.
It is not a method for the <span class="pkg">spatstat</span> generic function
<code><a href="spatstat.linnet.html#topic+as.linnet">as.linnet</a></code>, but like other S4 coercion functions for
<span class="pkg">sp</span> classes to <span class="pkg">spatstat</span> classes, it may be called directly as a function.
</p>
<p>An object of class SpatialLines
or <code>SpatialLinesDataFrame</code> (from package <span class="pkg">sp</span>) represents
a list of lists of the coordinates of lines, such as a list of all roads in
a city. An object of class <code>linnet</code> in the <span class="pkg">spatstat</span> package
represents a linear network, such as a road network.
</p>
<p>If <code>fuse=FALSE</code>, each &ldquo;Line&rdquo; object in <code>X</code>
will be treated as if it were disconnected from the others.
The result is a network that consists of many disconnected sub-networks,
equivalent to the list of &ldquo;Line&rdquo; objects.
</p>
<p>If <code>fuse=TRUE</code> (the default), the code will
search for identical pairs of vertices occurring in different
&ldquo;Line&rdquo; objects, and will treat them as identical vertices,
effectively joining the two &ldquo;Line&rdquo; objects at this common
vertex.
</p>
<p>If <code>X</code> belongs to class <code>SpatialLinesDataFrame</code>,
the associated columns of data in the auxiliary data frame
<code>slot(X, "data")</code> will be copied to the output as the marks
attached to the line segments of the network. See the Examples.
</p>


<h3>Value</h3>

<p>An object of class <code>linnet</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.linnet.html#topic+as.linnet">as.linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if(require("spatstat.geom", quietly=TRUE) &amp;&amp;
  require("spatstat.linnet", quietly=TRUE)) run &lt;- TRUE
if (run) {
   dname &lt;- system.file("shapes", package="maptools")
   fname &lt;- file.path(dname, "fylk-val.shp")
   fylk &lt;- readShapeSpatial(fname, proj4string=CRS("+proj=utm +zone=33 +ellps=WGS84"))
   is.projected(fylk)
}
if (run) {
   L &lt;- as(fylk, "linnet")
   print(max(vertexdegree(L)))
}
if (run) {
   L0 &lt;- as.linnet.SpatialLines(fylk, fuse=FALSE)
   print(max(vertexdegree(L0)))
}
if (run) {
   ## extract data associated with each network segment
   head(marks(as.psp(L)))
}
if (run) {
   fname &lt;- file.path(dname, "fylk-val-ll.shp")
   fylk &lt;- readShapeSpatial(fname, proj4string=CRS("+proj=longlat +ellps=WGS84"))
   is.projected(fylk)
}
if (run) {
   try(L &lt;- as(fylk, "linnet"))
  }
</code></pre>

<hr>
<h2 id='as.owin'>Coercion between sp objects and spatstat owin objects</h2><span id='topic+as.owin.SpatialGridDataFrame'></span><span id='topic+coerce+2CSpatialGridDataFrame+2Cowin-method'></span><span id='topic+as.owin.SpatialPixelsDataFrame'></span><span id='topic+coerce+2CSpatialPixelsDataFrame+2Cowin-method'></span><span id='topic+as.owin.SpatialPolygons'></span><span id='topic+coerce+2CSpatialPolygons+2Cowin-method'></span><span id='topic+as.SpatialPolygons.owin'></span><span id='topic+coerce+2Cowin+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Functions to convert between <span class="pkg">spatstat</span>s observation window (<code>owin</code>)
format and various <span class="pkg">sp</span> formats. S4-style <code>as()</code> coercion can be used
as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.owin.SpatialPolygons(W, ..., fatal)
as.owin.SpatialGridDataFrame(W, ..., fatal)
as.owin.SpatialPixelsDataFrame(W, ..., fatal)
as.SpatialPolygons.owin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owin_+3A_w">W</code></td>
<td>
<p><code>SpatialPolygons</code> object to coerce to <code>owin</code></p>
</td></tr>
<tr><td><code id="as.owin_+3A_x">x</code></td>
<td>
<p><code>owin</code> object to coerce to <code>SpatialPolygons</code> format</p>
</td></tr>
<tr><td><code id="as.owin_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.owin_+3A_fatal">fatal</code></td>
<td>
<p>formal coercion argument; ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An observation window in <span class="pkg">spatstat</span> defines a planar region. It is
typically used to represent a sampling region. It comes in three different
formats: a simple rectangle, a polygon (vector format) or a binary mask (TRUE/FALSE grid; raster format). These can all be coerced to polygonal form internally in
<span class="pkg">spatstat</span> and then converted to <code>SpatialPolygons</code>, which is what
<code>as.SpatialPolygons.owin()</code> does. For objects of class
<code>SpatialPolygons</code> (and <code>SpatialPolygonsDataFrame</code>) the <span class="pkg">sp</span>
polygons are simply extracted and cast into <span class="pkg">spatstat</span>s polygon format
inside the <code>owin</code> object. For <code>SpatialPixelsDataFrame</code> and
<code>SpatialGridDataFrame</code> the grid is extracted and cast into <span class="pkg">spatstat</span>s
mask format inside the <code>owin</code> object. In all cases any data apart from the
spatial region itself are discarded.</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPolygons", to = "owin")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPixelsDataFrame", to = "owin")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialGridDataFrame", to = "owin")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "owin", to = "SpatialPolygons")</code></p>
</dd>
</dl>



<h3>Warning</h3>

<p>In <span class="pkg">spatstat</span> all spatial objects are assumed to be planar. This means
that <span class="pkg">spatstat</span> is not designed to work directly with geographic
(longitude and latitude) coordinates. If a <span class="pkg">sp</span> object is declared to
have geographic (unprojected) coordinates <span class="pkg">maptools</span> refuses to convert
directly to <span class="pkg">spatstat</span> format. Rather, these should be projected first
using e.g. <code><a href="sp.html#topic+spTransform">spTransform</a></code>. If you know what you are doing, and
really want to force coercion, you can overwrite the <code>proj4string</code> of the
<span class="pkg">sp</span> object with an empty string, <code>proj4string(x) &lt;- ""</code>, which
will fool the system to think that the data is in local planar coordinates.
This is probably not a good idea!
</p>


<h3>Note</h3>

<p>When coercing a SpatialPolygons object to an owin object, full 
topology checking is enabled by default. To avoid checking, set 
<code>spatstat.options(checkpolygons=FALSE)</code> (from spatstat (1.14-6)). 
To perform the checking later, <code>owinpolycheck(W, verbose=TRUE)</code>.</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>, Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require("spatstat.geom", quietly=TRUE)) run &lt;- TRUE
if (run) {
## SpatialPixelsDataFrame -&gt; owin
data(meuse.grid) # A data.frame
gridded(meuse.grid) = ~x+y # Now a SpatialPixelsDataFrame
mg_owin &lt;- as(meuse.grid, "owin")
mg_owin
}
if (run) {
## SpatialGridDataFrame -&gt; owin
fullgrid(meuse.grid) &lt;- TRUE # Now a SpatialGridDataFrame
mg_owin2 &lt;- as(meuse.grid, "owin")
}
if (run) {
## SpatialPolygons region with a hole
ho_sp &lt;- SpatialPolygons(list(Polygons(list(Polygon(cbind(c(0,1,1,0,0),
  c(0,0,1,1,0))), Polygon(cbind(c(0.6,0.4,0.4,0.6,0.6), 
  c(0.2,0.2,0.4,0.4,0.2)), hole=TRUE)), ID="ho")))
plot(ho_sp, col="red", pbg="pink")
}
if (run) {
## SpatialPolygons -&gt; owin
ho &lt;- as(ho_sp, "owin")
plot(ho)
}
if (run) {
## Define owin directly and check they are identical
ho_orig &lt;- owin(poly=list(list(x=c(0,1,1,0), y=c(0,0,1,1)),
  list(x=c(0.6,0.4,0.4,0.6), y=c(0.2,0.2,0.4,0.4))))
identical(ho, ho_orig)
}
if (run) {
## owin -&gt; SpatialPolygons
ho_sp1 &lt;- as(ho, "SpatialPolygons")
all.equal(ho_sp, ho_sp1, check.attributes=FALSE)
}
</code></pre>

<hr>
<h2 id='as.ppp'>Coercion between sp objects and spatstat ppp objects</h2><span id='topic+as.ppp.SpatialPoints'></span><span id='topic+coerce+2CSpatialPoints+2Cppp-method'></span><span id='topic+as.ppp.SpatialPointsDataFrame'></span><span id='topic+coerce+2CSpatialPointsDataFrame+2Cppp-method'></span><span id='topic+as.SpatialPoints.ppp'></span><span id='topic+coerce+2Cppp+2CSpatialPoints-method'></span><span id='topic+as.SpatialPointsDataFrame.ppp'></span><span id='topic+coerce+2Cppp+2CSpatialPointsDataFrame-method'></span><span id='topic+as.SpatialGridDataFrame.ppp'></span><span id='topic+coerce+2Cppp+2CSpatialGridDataFrame-method'></span>

<h3>Description</h3>

<p>Functions to convert between <span class="pkg">spatstat</span>s planar point pattern (<code>ppp</code>)
format and <span class="pkg">sp</span>s <code>SpatialPoints</code> and <code>SpatialPointsDataFrame</code> as
well as one-way conversion from <code>SpatialGridDataFrame</code> to <code>ppp</code>.
S4-style <code>as()</code> coercion can be used as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ppp.SpatialPoints(X)
as.ppp.SpatialPointsDataFrame(X)
as.SpatialPoints.ppp(from)
as.SpatialPointsDataFrame.ppp(from)
as.SpatialGridDataFrame.ppp(from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ppp_+3A_from">from</code>, <code id="as.ppp_+3A_x">X</code></td>
<td>
<p>object to coerce from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main conversion is between <span class="pkg">sp</span>s
<code>SpatialPoints</code>/<code>SpatialPointsDataFrame</code> and <span class="pkg">spatstat</span>s
<code>ppp</code>. Conversion between <code>SpatialGridDataFrame</code> and <code>ppp</code> should
rarely be used; using <code><a href="maptools.html#topic+as.owin.SpatialGridDataFrame">as.owin.SpatialGridDataFrame</a></code> is more transparent.</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPoints", to = "ppp")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPointsDataFrame", to = "ppp")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ppp", to = "SpatialGridDataFrame")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ppp", to = "SpatialPointsDataFrame")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ppp", to = "SpatialPoints")</code></p>
</dd>
</dl>



<h3>Warning</h3>

<p>In <span class="pkg">spatstat</span> all spatial objects are assumed to be planar. This means
that <span class="pkg">spatstat</span> is not designed to work directly with geographic
(longitude and latitude) coordinates. If a <span class="pkg">sp</span> object is declared to
have geographic (unprojected) coordinates <span class="pkg">maptools</span> refuses to convert
directly to <span class="pkg">spatstat</span> format. Rather, these should be projected first
using e.g. <code><a href="sp.html#topic+spTransform">spTransform</a></code>. If you know what you are doing, and
really want to force coercion, you can overwrite the <code>proj4string</code> of the
<span class="pkg">sp</span> object with <code>NA</code>, <code>proj4string(x) &lt;- CRS(NA)</code>, which
will fool the system to think that the data is in local planar coordinates.
This is probably not a good idea!
</p>


<h3>Note</h3>

<p>The <code>ppp</code> format requires an observation window which is the sampling
region. The <span class="pkg">sp</span> formats contain no such information and by default the
bounding box of the points is simply used. This is almost never the correct
thing to do! Rather, information about the sampling region should be converted
into <span class="pkg">spatstat</span>s <code><a href="spatstat.geom.html#topic+owin">owin</a></code> format and assigned as the
observation window. Usually conversion from <code>ppp</code> to <span class="pkg">sp</span> format simply
discards the <code>owin</code>. However, <code>as.SpatialGridDataFrame.ppp</code> actually
first discards the points(!), second checks that the corresponding <code>owin</code>
is in a grid format (matrix of TRUE/FALSE for inside/outside sampling region),
and finally converts the TRUE/FALSE grid to a <code>SpatialGridDataFrame</code>.</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>, Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require("spatstat.geom", quietly=TRUE)) run &lt;- TRUE
if (run) {
## Convert SpatialPointsDataFrame into a marked ppp
data(meuse)
coordinates(meuse) = ~x+y
meuse_ppp &lt;- as(meuse, "ppp")
meuse_ppp # Window is the bounding rectangle
}
if (run) {
plot(meuse_ppp, which.marks = "zinc")
}
if (run) {
## Convert SpatialPoints into an unmarked ppp
meuse2 &lt;- as(meuse, "SpatialPoints")
as(meuse2, "ppp")
}
if (run) {
## Get sampling region in grid format and assign it as observation window
data(meuse.grid)
gridded(meuse.grid) &lt;- ~x+y
mg_owin &lt;- as(meuse.grid, "owin")
Window(meuse_ppp) &lt;- mg_owin
meuse_ppp # Window is now a binary image mask (TRUE/FALSE grid)
}
if (run) {
plot(meuse_ppp, which.marks = "zinc")
}
if (run) {
## Convert marked ppp back to SpatialPointsDataFrame
rev_ppp_SPDF &lt;- as.SpatialPointsDataFrame.ppp(meuse_ppp)
summary(rev_ppp_SPDF)
}
if (run) {
## Convert marked ppp back to SpatialPoints (discarding marks)
rev_ppp_SP &lt;- as.SpatialPoints.ppp(meuse_ppp)
summary(rev_ppp_SP)
}
if (run) {
## Convert marked ppp back to SpatialGridDataFrame (extracting the window grid)
rev_ppp_SGDF &lt;- as.SpatialGridDataFrame.ppp(meuse_ppp)
summary(rev_ppp_SGDF)
}
</code></pre>

<hr>
<h2 id='as.psp'>Coercion between sp objects and spatstat psp objects</h2><span id='topic+as.psp.Line'></span><span id='topic+coerce+2CLine+2Cpsp-method'></span><span id='topic+as.psp.Lines'></span><span id='topic+coerce+2CLines+2Cpsp-method'></span><span id='topic+as.psp.SpatialLines'></span><span id='topic+coerce+2CSpatialLines+2Cpsp-method'></span><span id='topic+as.psp.SpatialLinesDataFrame'></span><span id='topic+coerce+2CSpatialLinesDataFrame+2Cpsp-method'></span><span id='topic+as.SpatialLines.psp'></span><span id='topic+coerce+2Cpsp+2CSpatialLines-method'></span>

<h3>Description</h3>

<p>Functions to convert between <span class="pkg">spatstat</span>s planar segment pattern (<code>psp</code>)
format and various <span class="pkg">sp</span> line formats. S4-style <code>as()</code> coercion can be
used as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.psp.Line(from, ..., window=NULL, marks=NULL, fatal)
as.psp.Lines(from, ..., window=NULL, marks=NULL, fatal)
as.psp.SpatialLines(from, ..., window=NULL, marks=NULL, characterMarks
                 = FALSE, fatal)
as.psp.SpatialLinesDataFrame(from, ..., window=NULL, marks=NULL, fatal)
as.SpatialLines.psp(from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.psp_+3A_from">from</code></td>
<td>
<p>object to coerce from</p>
</td></tr>
<tr><td><code id="as.psp_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.psp_+3A_window">window</code></td>
<td>
<p>window of class <code>owin</code> as defined in the spatstat package</p>
</td></tr>
<tr><td><code id="as.psp_+3A_marks">marks</code></td>
<td>
<p>marks as defined in the spatstat package</p>
</td></tr>
<tr><td><code id="as.psp_+3A_charactermarks">characterMarks</code></td>
<td>
<p>default FALSE, if TRUE, do not convert NULL marks to factor from character</p>
</td></tr>
<tr><td><code id="as.psp_+3A_fatal">fatal</code></td>
<td>
<p>formal coercion argument; ignored</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "Line", to = "psp")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "Lines", to = "psp")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialLines", to = "psp")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialLinesDataFrame", to = "psp")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "psp", to = "SpatialLines")</code></p>
</dd>
</dl>



<h3>Warning</h3>

<p>In <span class="pkg">spatstat</span> all spatial objects are assumed to be planar. This means
that <span class="pkg">spatstat</span> is not designed to work directly with geographic
(longitude and latitude) coordinates. If a <span class="pkg">sp</span> object is declared to
have geographic (unprojected) coordinates <span class="pkg">maptools</span> refuses to convert
directly to <span class="pkg">spatstat</span> format. Rather, these should be projected first
using e.g. <code><a href="sp.html#topic+spTransform">spTransform</a></code>. If you know what you are doing, and
really want to force coercion, you can overwrite the <code>proj4string</code> of the
<span class="pkg">sp</span> object with <code>NA</code>, <code>proj4string(x) &lt;- CRS(NA)</code>, which
will fool the system to think that the data is in local planar coordinates.
This is probably not a good idea!
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>, Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require("spatstat.geom", quietly=TRUE)) run &lt;- TRUE
if (run) {
data(meuse.riv)
mr &lt;- Line(meuse.riv)
mr_psp &lt;- as(mr, "psp")
mr_psp
}
if (run) {
plot(mr_psp)
}
if (run) {
xx_back &lt;- as(mr_psp, "SpatialLines")
plot(xx_back)
}
if (run) {
xx &lt;- readShapeLines(system.file("shapes/fylk-val.shp", package="maptools")[1],
 proj4string=CRS("+proj=utm +zone=33 +ellps=WGS84"))
xx_psp &lt;- as(xx["LENGTH"], "psp")
xx_psp
}
if (run) {
plot(xx_psp)
}
if (run) {
xx_back &lt;- as(xx_psp, "SpatialLines")
plot(xx_back)
}
if (run) {
xx &lt;- readShapeLines(system.file("shapes/fylk-val-ll.shp", package="maptools")[1], 
 proj4string=CRS("+proj=longlat +ellps=WGS84"))
try(xx_psp &lt;- as(xx["LENGTH"], "psp"))
}
</code></pre>

<hr>
<h2 id='as.SpatialPolygons.tess'>Coercion of spatstat tess object to sp SpatialPolygons object</h2><span id='topic+as.SpatialPolygons.tess'></span><span id='topic+coerce+2Ctess+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>This function coerces <span class="pkg">spatstat</span>s tessellation objects of class <code>tess</code>
to <span class="pkg">sp</span>s <code>SpatialPolygons</code> class. S4-style as() coercion works as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatialPolygons.tess(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialPolygons.tess_+3A_x">x</code></td>
<td>
<p><span class="pkg">spatstat</span> object of class <code>tess</code> to coerce from</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "tess", to = "SpatialPolygons")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>, Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require("spatstat.geom", quietly=TRUE)) run &lt;- TRUE
if (run) {
A &lt;- tess(xgrid=0:4,ygrid=0:4)
A_sp &lt;- as(A, "SpatialPolygons")
plot(A_sp)
text(coordinates(A_sp), labels=row.names(A_sp), cex=0.6)
}
</code></pre>

<hr>
<h2 id='CCmaps'>Conditioned choropleth maps</h2><span id='topic+CCmaps'></span>

<h3>Description</h3>

<p>Conditioned choropleth maps permit the conditioning of a map of a variable on the values of one or two other variables coded as factors or shingles. This function uses <a href="sp.html#topic+spplot">spplot</a> after constructing multiple subsets of the variable of interest defined by the intervals given by the conditioning variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCmaps(obj, zcol = NULL, cvar = NULL, cvar.names = NULL, ..., names.attr,
 scales = list(draw = FALSE), xlab = NULL, ylab = NULL,
 aspect = mapasp(obj, xlim, ylim), sp.layout = NULL, xlim = bbox(obj)[1, ],
 ylim = bbox(obj)[2, ])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCmaps_+3A_obj">obj</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></p>
</td></tr>
<tr><td><code id="CCmaps_+3A_zcol">zcol</code></td>
<td>
<p>single variable name as string</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_cvar">cvar</code></td>
<td>
<p>a list of one or two conditioning variables, which should be of class factor or shingle</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_cvar.names">cvar.names</code></td>
<td>
<p>names for conditioning variables, if not given, the names of the variables in the <code>cvar</code> list</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="sp.html#topic+spplot">spplot</a> and <a href="lattice.html#topic+levelplot">levelplot</a></p>
</td></tr>
<tr><td><code id="CCmaps_+3A_names.attr">names.attr</code></td>
<td>
<p>names to use in panel, if different from zcol names</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_scales">scales</code></td>
<td>
<p>scales argument to be passed to Lattice plots; use
<code>list(draw = TRUE)</code> to draw axes scales</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_aspect">aspect</code></td>
<td>
<p>aspect ratio for spatial axes; defaults to &quot;iso&quot; (one unit
on the x-axis equals one unit on the y-axis) but may be set to more
suitable values if the data are e.g. if coordinates are latitude/longitude</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_sp.layout">sp.layout</code></td>
<td>
<p>NULL or list; see <a href="sp.html#topic+spplot">spplot</a></p>
</td></tr>
<tr><td><code id="CCmaps_+3A_xlim">xlim</code></td>
<td>
<p>numeric; x-axis limits</p>
</td></tr>
<tr><td><code id="CCmaps_+3A_ylim">ylim</code></td>
<td>
<p>numeric; y-axis limits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a> object with the <code>zcol</code> variable and the partitions of the <code>cvars</code> list variables invisibly.
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>References</h3>

<p>Carr D, Wallin J, Carr D (2000) Two new templates for epidemiology applications: linked micromap plots and conditioned choropleth maps. <em>Statistics in Medicine</em> 19(17-18): 2521-2538
Carr D, White D, MacEachren A (2005) Conditioned choropleth maps and hypothesis generation. <em>Annals of the Association of American Geographers</em> 95(1): 32-53
Friendly M (2007) A.-M. Guerry's Moral Statistics of France: challenges for multivariable spatial analysis. <em>Statistical Science</em> 22(3): 368-399
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spplot">spplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nc.sids &lt;- readShapeSpatial(system.file("shapes/sids.shp",
 package="maptools")[1], IDvar="FIPSNO",
 proj4string=CRS("+proj=longlat +ellps=clrk66"))
nc.sids$ft.SID74 &lt;- sqrt(1000)*(sqrt(nc.sids$SID74/nc.sids$BIR74) +
 sqrt((nc.sids$SID74+1)/nc.sids$BIR74))
nc.sids$ft.NWBIR74 &lt;- sqrt(1000)*(sqrt(nc.sids$NWBIR74/nc.sids$BIR74) +
 sqrt((nc.sids$NWBIR74+1)/nc.sids$BIR74))
library(lattice)
sh_nw4 &lt;- equal.count(nc.sids$ft.NWBIR74, number=4, overlap=1/5)
CCmaps(nc.sids, "ft.SID74", list("Nonwhite_births"=sh_nw4),
 col.regions=colorRampPalette(c("yellow1", "brown3"))(20),
 main="Transformed SIDS rates 1974-8")
</code></pre>

<hr>
<h2 id='checkPolygonsHoles'>Check holes in Polygons objects</h2><span id='topic+checkPolygonsHoles'></span><span id='topic+rgeosStatus'></span><span id='topic+gpclibPermit'></span><span id='topic+gpclibPermitStatus'></span>

<h3>Description</h3>

<p>The function checks holes in Polygons objects. Use of the rgeos package functions is prefered, and if rgeos is available, they will be used automatically. In this case, member Polygon objects are checked against each other for containment, and the returned Polygons object has component hole slots set appropriately. In addition, the output Polygons object may be provided with a comment string, encoding the external and internal rings. For gpclib use, see details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPolygonsHoles(x, properly=TRUE, avoidGEOS=FALSE, useSTRtree=FALSE)
gpclibPermitStatus()
gpclibPermit()
rgeosStatus()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPolygonsHoles_+3A_x">x</code></td>
<td>
<p>An Polygons object as defined in package sp</p>
</td></tr>
<tr><td><code id="checkPolygonsHoles_+3A_properly">properly</code></td>
<td>
<p>default TRUE, use <code><a href="rgeos.html#topic+gContainsProperly">gContainsProperly</a></code> rather than <code><a href="rgeos.html#topic+gContains">gContains</a></code></p>
</td></tr>
<tr><td><code id="checkPolygonsHoles_+3A_avoidgeos">avoidGEOS</code></td>
<td>
<p>default FALSE; if TRUE force use of <span class="pkg">gpclib</span> even when <span class="pkg">rgeos</span> is available</p>
</td></tr>
<tr><td><code id="checkPolygonsHoles_+3A_usestrtree">useSTRtree</code></td>
<td>
<p>default FALSE, if TRUE, use <span class="pkg">rgeos</span> STRtree in checking holes, which is much faster, but uses a lot of memory and does not release it on completion (work in progress)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the gpclib package is used, an intersection between a gpc.poly object with one or more polygon contours and its bounding box is used to set the hole flag. The function will set single polygon contours to hole=FALSE, and if multiple polygon contours are holes, will set them TRUE. The <code>gpclibPermit</code> function is used to choose to permit the use of gpclib if installed, and <code>gpclibPermitStatus</code> reports its status. The licence for gpclib is not Free or Open Source and explicitly forbids commercial use. See <code>library(help=gpclib)</code>.</p>


<h3>Value</h3>

<p>An Polygons object re-created from the input object.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rgeosStatus()) {
nc1 &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
 proj4string=CRS("+proj=longlat +ellps=clrk66"))
pl &lt;- slot(nc1, "polygons")
sapply(slot(pl[[4]], "Polygons"), function(x) slot(x, "hole"))
pl[[4]] &lt;- Polygons(list(slot(pl[[4]], "Polygons")[[1]],
 Polygon(slot(slot(pl[[4]], "Polygons")[[2]], "coords"), hole=TRUE),
 slot(pl[[4]], "Polygons")[[3]]), slot(pl[[4]], "ID"))
sapply(slot(pl[[4]], "Polygons"), function(x) slot(x, "hole"))
pl_new &lt;- lapply(pl, checkPolygonsHoles)
sapply(slot(pl_new[[4]], "Polygons"), function(x) slot(x, "hole"))
srs &lt;- slot(slot(pl[[1]], "Polygons")[[1]], "coords")
hle2 &lt;- structure(c(-81.64093, -81.38380, -81.34165, -81.66833, -81.64093, 
 36.57865, 36.57234, 36.47603, 36.47894, 36.57865), .Dim = as.integer(c(5, 2)))
hle3 &lt;- structure(c(-81.47759, -81.39118, -81.38486, -81.46705, -81.47759, 
 36.56289, 36.55659, 36.49907, 36.50380, 36.56289), .Dim = as.integer(c(5, 2)))
x &lt;- Polygons(list(Polygon(srs), Polygon(hle2), Polygon(hle3)),
 ID=slot(pl[[1]], "ID"))
sapply(slot(x, "Polygons"), function(x) slot(x, "hole"))
res &lt;- checkPolygonsHoles(x)
sapply(slot(res, "Polygons"), function(x) slot(x, "hole"))
## Not run: 
opar &lt;- par(mfrow=c(1,2))
SPx &lt;- SpatialPolygons(list(x))
plot(SPx)
text(t(sapply(slot(x, "Polygons"), function(i) slot(i, "labpt"))),
 labels=sapply(slot(x, "Polygons"), function(i) slot(i, "hole")), cex=0.6)
title(xlab="Hole slot values before checking")
SPres &lt;- SpatialPolygons(list(res))
plot(SPres)
text(t(sapply(slot(res, "Polygons"), function(i) slot(i, "labpt"))),
 labels=sapply(slot(res, "Polygons"), function(i) slot(i, "hole")), cex=0.6)
title(xlab="Hole slot values after checking")
par(opar)
p1 &lt;- Polygon(cbind(x=c(0, 0, 10, 10, 0), y=c(0, 10, 10, 0, 0))) # I
p2 &lt;- Polygon(cbind(x=c(3, 3, 7, 7, 3), y=c(3, 7, 7, 3, 3))) # H
p8 &lt;- Polygon(cbind(x=c(1, 1, 2, 2, 1), y=c(1, 2, 2, 1, 1))) # H
p9 &lt;- Polygon(cbind(x=c(1, 1, 2, 2, 1), y=c(5, 6, 6, 5, 5))) # H
p3 &lt;- Polygon(cbind(x=c(20, 20, 30, 30, 20), y=c(20, 30, 30, 20, 20))) # I
p4 &lt;- Polygon(cbind(x=c(21, 21, 29, 29, 21), y=c(21, 29, 29, 21, 21))) # H
p14 &lt;- Polygon(cbind(x=c(21, 21, 29, 29, 21), y=c(21, 29, 29, 21, 21))) # H
p5 &lt;- Polygon(cbind(x=c(22, 22, 28, 28, 22), y=c(22, 28, 28, 22, 22))) # I
p15 &lt;- Polygon(cbind(x=c(22, 22, 28, 28, 22), y=c(22, 28, 28, 22, 22))) # I
p6 &lt;- Polygon(cbind(x=c(23, 23, 27, 27, 23), y=c(23, 27, 27, 23, 23))) # H
p7 &lt;- Polygon(cbind(x=c(13, 13, 17, 17, 13), y=c(13, 17, 17, 13, 13))) # I
p10 &lt;- Polygon(cbind(x=c(24, 24, 26, 26, 24), y=c(24, 26, 26, 24, 24))) # I
p11 &lt;- Polygon(cbind(x=c(24.25, 24.25, 25.75, 25.75, 24.25),
 y=c(24.25, 25.75, 25.75, 24.25, 24.25))) # H
p12 &lt;- Polygon(cbind(x=c(24.5, 24.5, 25.5, 25.5, 24.5),
 y=c(24.5, 25.5, 25.5, 24.5, 24.5))) # I
p13 &lt;- Polygon(cbind(x=c(24.75, 24.75, 25.25, 25.25, 24.75),
 y=c(24.75, 25.25, 25.25, 24.75, 24.75))) # H
lp &lt;- list(p1, p2, p13, p7, p6, p5, p4, p3, p8, p11, p12, p9, p10, p14, p15)
#           1   2    3   4   5   6   7   8   9   10   11  12   13   14   15
#           0   1   11   0   6   0   8   0   1   13    0   1    0  (7)  (6)
#           I   H    H   I   H   I   H   I   H    H    I   H    I   ?    ?
pls &lt;- Polygons(lp, ID="1")
comment(pls)
pls1 &lt;- checkPolygonsHoles(pls)
comment(pls1)
opar &lt;- par(mfrow=c(1,2))
plot(SpatialPolygons(list(pls)), col="magenta", pbg="cyan", usePolypath=FALSE)
title(xlab="Hole slot values before checking")
plot(SpatialPolygons(list(pls1)), col="magenta", pbg="cyan", usePolypath=FALSE)
title(xlab="Hole slot values after checking")
par(opar)

## End(Not run)
}
</code></pre>

<hr>
<h2 id='ContourLines2SLDF'>Converter functions to build SpatialLinesDataFrame objects</h2><span id='topic+ArcObj2SLDF'></span><span id='topic+ContourLines2SLDF'></span><span id='topic+MapGen2SL'></span>

<h3>Description</h3>

<p>These functions show how to build converters to SpatialLinesDataFrame objects: 
<code>ArcObj2SLDF</code> from the list returned by the <code>get.arcdata</code> function in the RArcInfo package; <code>ContourLines2SLDF</code> from the list returned by the <code>contourLines</code> function in the graphics package (here the data frame is just the contour levels, with one Lines object made up of at least one Line object per level); and <code>MapGen2SL</code> reads a file in &quot;Mapgen&quot; format into a <code>SpatialLines</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ArcObj2SLDF(arc, proj4string=CRS(as.character(NA)), IDs)
ContourLines2SLDF(cL, proj4string=CRS(as.character(NA)))
MapGen2SL(file, proj4string=CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ContourLines2SLDF_+3A_arc">arc</code></td>
<td>
<p>a list returned by the <code>get.arcdata</code> function in the RArcInfo package</p>
</td></tr>
<tr><td><code id="ContourLines2SLDF_+3A_ids">IDs</code></td>
<td>
<p>vector of unique character identifiers; if not given, suitable defaults will be used, and the same values inserted as data slot row names</p>
</td></tr>
<tr><td><code id="ContourLines2SLDF_+3A_cl">cL</code></td>
<td>
<p>a list returned by the <code>contourLines</code> function in the graphics package</p>
</td></tr>
<tr><td><code id="ContourLines2SLDF_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>"CRS"</code>; see <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</td></tr>
<tr><td><code id="ContourLines2SLDF_+3A_file">file</code></td>
<td>
<p>filename of a file containing a Mapgen line data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatialLinesDataFrame object
</p>


<h3>Note</h3>

<p>Coastlines of varying resolution may be chosen online and downloaded in &quot;Mapgen&quot; text format from <a href="https://www.ngdc.noaa.gov/mgg/shorelines/shorelines.html">https://www.ngdc.noaa.gov/mgg/shorelines/shorelines.html</a>, most conveniently using the interactive selection tool, but please note the 500,000 point limit on downloads, which is easy to exceed.</p>


<h3>Author(s)</h3>

<p> Roger Bivand; Edzer Pebesma </p>


<h3>See Also</h3>

 <p><a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(co37_d90_arc) # retrieved as: 
# library(RArcInfo)
# fl &lt;- "http://www.census.gov/geo/cob/bdy/co/co90e00/co37_d90_e00.zip"
# download.file(fl, "co37_d90_e00.zip")
# e00 &lt;- zip.file.extract("co37_d90.e00", "co37_d90_e00.zip")
# e00toavc(e00, "ncar")
# arc &lt;- get.arcdata(".", "ncar")
#res &lt;- arcobj2SLDF(arc)
#plot(res)
#invisible(title(""))
res &lt;- ContourLines2SLDF(contourLines(volcano))
plot(res, col=terrain.colors(nrow(as(res, "data.frame"))))
title("Volcano contours as SpatialLines")
</code></pre>

<hr>
<h2 id='dotsInPolys'>Put dots in polygons</h2><span id='topic+dotsInPolys'></span>

<h3>Description</h3>

<p>Make point coordinates for a dot density map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotsInPolys(pl, x, f = "random", offset, compatible = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotsInPolys_+3A_pl">pl</code></td>
<td>
<p>an object of class SpatialPolygons or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="dotsInPolys_+3A_x">x</code></td>
<td>
<p>integer vector of counts of same length as pl for dots</p>
</td></tr>
<tr><td><code id="dotsInPolys_+3A_f">f</code></td>
<td>
<p>type of sampling used to place points in polygons, either &quot;random&quot; or &quot;regular&quot;</p>
</td></tr>
<tr><td><code id="dotsInPolys_+3A_offset">offset</code></td>
<td>
<p> for regular sampling only: the offset (position) of the regular
grid; if not set, <code>c(0.5,0.5)</code>, that is the returned grid is
not random</p>
</td></tr>
<tr><td><code id="dotsInPolys_+3A_compatible">compatible</code></td>
<td>
<p>what to return, if TRUE a a list of matrices of point coordinates, one matrix for each member of pl, if false a SpatialPointsDataFrame with polygon ID values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With f=&quot;random&quot;, the dots are placed in the polygon at random, f=&quot;regular&quot; - in a grid pattern (number of dots not guaranteed to be the same as the count). When the polygon is made up of more than one part, the dots will be placed in proportion to the relative areas of the clockwise rings (anticlockwise are taken as holes). From maptools release 0.5-2, correction is made for holes in the placing of the dots, but depends on hole values being correctly set, which they often are not.  
</p>


<h3>Value</h3>

<p>If compatible=TRUE, the function returns a list of matrices of point coordinates, one matrix for each member of pl. If x[i] is zero, the list element is NULL, and can be tested when plotting - see the examples. If compatible=FALSE (default), it returns a SpatialPointsDataFrame with polygon ID values as the only column in the data slot.
</p>


<h3>Note</h3>

<p>Waller and Gotway (2004) Applied Spatial Statistics for Public Health Data (Wiley, Hoboken, NJ) explicitly warn that care is needed in plotting and interpreting dot density maps (pp. 81-83)</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spsample">spsample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nc_SP &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
 proj4string=CRS("+proj=longlat  +ellps=clrk66"))
## Not run: 
pls &lt;- slot(nc_SP, "polygons")
pls_new &lt;- lapply(pls, checkPolygonsHoles)
nc_SP &lt;- SpatialPolygonsDataFrame(SpatialPolygons(pls_new,
 proj4string=CRS(proj4string(nc_SP))), data=as(nc_SP, "data.frame"))

## End(Not run)
try1 &lt;- dotsInPolys(nc_SP, as.integer(nc_SP$SID74))
plot(nc_SP, axes=TRUE)
plot(try1, add=TRUE, pch=18, col="red")
try2 &lt;- dotsInPolys(nc_SP, as.integer(nc_SP$SID74), f="regular")
plot(nc_SP, axes=TRUE)
plot(try2, add=TRUE, pch=18, col="red")
</code></pre>

<hr>
<h2 id='elide-methods'>Methods for Function elide in Package &lsquo;maptools&rsquo;</h2><span id='topic+elide-methods'></span><span id='topic+elide+2CSpatialPoints-method'></span><span id='topic+elide+2CSpatialPointsDataFrame-method'></span><span id='topic+elide+2CSpatialLines-method'></span><span id='topic+elide+2CSpatialLinesDataFrame-method'></span><span id='topic+elide+2CSpatialPolygons-method'></span><span id='topic+elide+2CSpatialPolygonsDataFrame-method'></span><span id='topic+elide'></span>

<h3>Description</h3>

<p>Methods for function <code>elide</code> to translate and disguise coordinate placing in the real world. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elide(obj, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elide-methods_+3A_obj">obj</code></td>
<td>
<p>object to be elided</p>
</td></tr>
<tr><td><code id="elide-methods_+3A_...">...</code></td>
<td>
<p>other arguments:
</p>

<dl>
<dt>bb</dt><dd><p>if NULL, uses bounding box of object, otherwise the given bounding box</p>
</dd>
<dt>shift</dt><dd><p>values to shift the coordinates of the input object; this is made ineffective by the scale argument</p>
</dd>
<dt>reflect</dt><dd><p>reverse coordinate axes</p>
</dd>
<dt>scale</dt><dd><p>if NULL, coordinates not scaled; if TRUE, the longer dimension is scaled to lie within [0,1] and aspect maintained; if a scalar, the output range of [0,1] is multiplied by scale</p>
</dd>
<dt>flip</dt><dd><p>translate coordinates on the main diagonal</p>
</dd>
<dt>rotate</dt><dd><p>default 0, rotate angle degrees clockwise around center</p>
</dd>
<dt>center</dt><dd><p>default NULL, if not NULL, the rotation center, numeric of length two</p>
</dd>
<dt>unitsq</dt><dd><p>logical, default FALSE, if TRUE and scale TRUE, impose unit square bounding box (currently only points)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The methods return objects of the input class object with elided coordinates; the coordinate reference system is not set. Note that if the input coordinates or centroids are in the data slot data.frame of the input object, they should be removed before the use of these methods, otherwise they will betray the input positions.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;SpatialPoints&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialPointsDataFrame&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialLines&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialPolygons&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;</dt><dd><p>elides object</p>
</dd>
</dl>


<h3>Note</h3>

<p>Rotation code kindly contributed by Don MacQueen</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
coordinates(meuse) &lt;- c("x", "y")
proj4string(meuse) &lt;- CRS("+init=epsg:28992")
data(meuse.riv)
river_polygon &lt;- Polygons(list(Polygon(meuse.riv)), ID="meuse")
rivers &lt;- SpatialPolygons(list(river_polygon))
proj4string(rivers) &lt;- CRS("+init=epsg:28992")
rivers1 &lt;- elide(rivers, reflect=c(TRUE, TRUE), scale=TRUE)
meuse1 &lt;- elide(meuse, bb=bbox(rivers), reflect=c(TRUE, TRUE), scale=TRUE)
opar &lt;- par(mfrow=c(1,2))
plot(rivers, axes=TRUE)
plot(meuse, add=TRUE)
plot(rivers1, axes=TRUE)
plot(meuse1, add=TRUE)
par(opar)
meuse1 &lt;- elide(meuse, shift=c(10000, -10000))
bbox(meuse)
bbox(meuse1)
rivers1 &lt;- elide(rivers, shift=c(10000, -10000))
bbox(rivers)
bbox(rivers1)
meuse1 &lt;- elide(meuse, rotate=-30, center=apply(bbox(meuse), 1, mean))
bbox(meuse)
bbox(meuse1)
plot(meuse1, axes=TRUE)
</code></pre>

<hr>
<h2 id='gcDestination'>Find destination in geographical coordinates</h2><span id='topic+gcDestination'></span>

<h3>Description</h3>

<p>Find the destination in geographical coordinates at distance dist and for the given bearing from the starting point given by lon and lat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcDestination(lon, lat, bearing, dist, dist.units = "km",
 model = NULL, Vincenty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcDestination_+3A_lon">lon</code></td>
<td>
<p>longitude (Eastings) in decimal degrees (either scalar or vector)</p>
</td></tr>
<tr><td><code id="gcDestination_+3A_lat">lat</code></td>
<td>
<p>latitude (Northings) in decimal degrees (either scalar or vector)</p>
</td></tr>
<tr><td><code id="gcDestination_+3A_bearing">bearing</code></td>
<td>
<p>bearing from 0 to 360 degrees (either scalar or vector)</p>
</td></tr>
<tr><td><code id="gcDestination_+3A_dist">dist</code></td>
<td>
<p>distance travelled (scalar)</p>
</td></tr>
<tr><td><code id="gcDestination_+3A_dist.units">dist.units</code></td>
<td>
<p>units of distance &quot;km&quot; (kilometers), &quot;nm&quot; (nautical miles), &quot;mi&quot; (statute miles)</p>
</td></tr>
<tr><td><code id="gcDestination_+3A_model">model</code></td>
<td>
<p>choice of ellipsoid model (&quot;WGS84&quot;, &quot;GRS80&quot;, &quot;Airy&quot;, &quot;International&quot;, &quot;Clarke&quot;, &quot;GRS67&quot;</p>
</td></tr>
<tr><td><code id="gcDestination_+3A_vincenty">Vincenty</code></td>
<td>
<p>logical flag, default FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bearing argument may be a vector when lon and lat are scalar, representing a single point.
</p>


<h3>Value</h3>

<p>A matrix of decimal degree coordinates with Eastings in the first column and Northings in the second column. 
</p>


<h3>Author(s)</h3>

<p>Eric Archer and Roger Bivand</p>


<h3>References</h3>

<p><a href="http://www.movable-type.co.uk/scripts/latlong.html#ellipsoid">http://www.movable-type.co.uk/scripts/latlong.html#ellipsoid</a>, 
</p>
<p>the file earlier available at <code>http:\/\/williams.best.vwh.net/avform.htm</code>, 
</p>
<p><a href="http://www.movable-type.co.uk/scripts/latlong-vincenty.html#direct">http://www.movable-type.co.uk/scripts/latlong-vincenty.html#direct</a>, 
</p>
<p>Original reference <a href="https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf">https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf</a>:
</p>
<p>Vincenty, T. 1975.  Direct and inverse solutions of geodesics on 
the ellipsoid with application of nested equations.
Survey Review 22(176):88-93</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+gzAzimuth">gzAzimuth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)
res &lt;- gcDestination(state.center$x, state.center$y, 45, 250, "km")
plot(state.center$x, state.center$y, asp=1, pch=16)
arrows(state.center$x, state.center$y, res[,1], res[,2], length=0.05)
llist &lt;- vector(mode="list", length=length(state.center$x))
for (i in seq(along=llist)) llist[[i]] &lt;- gcDestination(state.center$x[i],
  state.center$y[i], seq(0, 360, 5), 250, "km")
plot(state.center$x, state.center$y, asp=1, pch=3)
nll &lt;- lapply(llist, lines)
</code></pre>

<hr>
<h2 id='GE_SpatialGrid'>Create SpatialGrid for PNG output to GE</h2><span id='topic+GE_SpatialGrid'></span><span id='topic+Sobj_SpatialGrid'></span>

<h3>Description</h3>

<p>The function sets up metadata in the form of a SpatialGrid object for defining the size and placing of a PNG image overlay in Google Earth. The internal function <code>Sobj_SpatialGrid</code> can also be called to build a grid for arbitrary Spatial* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GE_SpatialGrid(obj, asp = NA, maxPixels = 600)
Sobj_SpatialGrid(obj, asp=1, maxDim=100, n=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GE_SpatialGrid_+3A_obj">obj</code></td>
<td>
<p>a Spatial* object</p>
</td></tr>
<tr><td><code id="GE_SpatialGrid_+3A_asp">asp</code></td>
<td>
<p>if NA, will be set to the latitude corrected value</p>
</td></tr>
<tr><td><code id="GE_SpatialGrid_+3A_maxpixels">maxPixels</code></td>
<td>
<p>the maximum dimension of the output PNG</p>
</td></tr>
<tr><td><code id="GE_SpatialGrid_+3A_maxdim">maxDim</code></td>
<td>
<p>the maximum dimension of the output grid; ignored if <code>n</code> not NULL</p>
</td></tr>
<tr><td><code id="GE_SpatialGrid_+3A_n">n</code></td>
<td>
<p>if not NULL, the minimum number of cells in the returned grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used together with <code>kmlOverlay</code> to wrap around the opening of a PNG graphics device, plotting code, and the closing of the device. The computed values take account of the adjustment of the actual data bounding box to an integer number of rows and columns in the image file. 
</p>
<p>The approach may be used as an alternative to writing PNG files from SpatialGrid and SpatialPixel objects in <span class="pkg">rgdal</span> using <code>writeGDAL</code>, and to writing KML files using <code>writeOGR</code> for vector data objects. The output PNG files are likely to be very much smaller than large vector data KML files, and hinder the retrieval of exact positional information.
</p>
<p>Note that the geometries should be in geographical coordinates with datum WGS84 for export to KML.
</p>


<h3>Value</h3>

<p>returns an S3 object of class <code>GE_SG</code> with components:
</p>
<table>
<tr><td><code>height</code></td>
<td>
<p>Integer raster height for png call</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>Integer raster width for png call</p>
</td></tr>
<tr><td><code>SG</code></td>
<td>
<p>a SpatialGrid object with the grid topology of the output PNG</p>
</td></tr>
<tr><td><code>asp</code></td>
<td>
<p>the aspect value used</p>
</td></tr>
<tr><td><code>xlim</code></td>
<td>
<p>xlim taken from SG</p>
</td></tr>
<tr><td><code>ylim</code></td>
<td>
<p>ylim taken from SG</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Golicher, David Forrest and Roger Bivand</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+kmlOverlay">kmlOverlay</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>opt_exask &lt;- options(example.ask=FALSE)
qk &lt;- SpatialPointsDataFrame(quakes[, c(2:1)], quakes)
summary(Sobj_SpatialGrid(qk)$SG)
t2 &lt;- Sobj_SpatialGrid(qk, n=10000)$SG
summary(t2)
prod(slot(slot(t2, "grid"), "cells.dim"))
proj4string(qk) &lt;- CRS("+proj=longlat +ellps=WGS84")
tf &lt;- tempfile()
SGqk &lt;- GE_SpatialGrid(qk)
png(file=paste(tf, ".png", sep=""), width=SGqk$width, height=SGqk$height,
  bg="transparent")
par(mar=c(0,0,0,0), xaxs="i", yaxs="i")
plot(qk, xlim=SGqk$xlim, ylim=SGqk$ylim, setParUsrBB=TRUE)
dev.off()
kmlOverlay(SGqk, paste(tf, ".kml", sep=""), paste(tf, ".png", sep=""))
## Not run: 
qk0 &lt;- quakes
qk0$long &lt;- ifelse(qk0$long &lt;= 180, qk0$long, qk0$long-360)
qk0a &lt;- SpatialPointsDataFrame(qk0[, c(2:1)], qk0)
proj4string(qk0a) &lt;- CRS("+proj=longlat +ellps=WGS84")
# writeOGR(qk0a, paste(tf, "v.kml", sep=""), "Quakes", "KML")
# system(paste("googleearth ", tf, ".kml", sep=""))

## End(Not run)
options(example.ask=opt_exask)
</code></pre>

<hr>
<h2 id='getinfo.shape'>Get shapefile header information</h2><span id='topic+getinfo.shape'></span><span id='topic+print.shapehead'></span>

<h3>Description</h3>

<p>Get shapefile  header information; the file should be given including its &quot;.shp&quot; extension, and the function will reconstruct the names of the database (dbf) file and the index (shx) file from these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getinfo.shape(filen)
## S3 method for class 'shapehead'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getinfo.shape_+3A_filen">filen</code></td>
<td>
<p>name of file with *.shp extension</p>
</td></tr>
<tr><td><code id="getinfo.shape_+3A_x">x</code></td>
<td>
<p>a shapehead list as returned by getinfo.shape</p>
</td></tr>
<tr><td><code id="getinfo.shape_+3A_...">...</code></td>
<td>
<p>other arguments passed to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls code from shapelib to read shapefiles, a file format used by ESRI GIS software among others
</p>


<h3>Value</h3>

<p>The function returns a list of class shapehead.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>; shapelib by Frank Warmerdam</p>


<h3>References</h3>

<p><a href="http://shapelib.maptools.org/">http://shapelib.maptools.org/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- getinfo.shape(system.file("shapes/fylk-val.shp", package="maptools")[1])
res
str(res)
</code></pre>

<hr>
<h2 id='getKMLcoordinates'>Get a list of coordinates out of a KML file</h2><span id='topic+getKMLcoordinates'></span>

<h3>Description</h3>

<p>This function parses a KML file to get the content of <code>&lt;coordinates&gt;</code> tags and returns a list of matrices representing the longitude-latitute or if <code>ignoreAltitude</code> is <code>FALSE</code> the longitude-latitute-altitude coordinates of a KML geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKMLcoordinates(kmlfile, ignoreAltitude=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKMLcoordinates_+3A_kmlfile">kmlfile</code></td>
<td>
<p>connection object or a character string of the KML file</p>
</td></tr>
<tr><td><code id="getKMLcoordinates_+3A_ignorealtitude">ignoreAltitude</code></td>
<td>
<p>if set to <code>TRUE</code> the altitude values of a KML points will be ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coords</code> is a list of matrices representing the longitude-latitute or if <code>ignoreAltitude</code> is <code>FALSE</code> the longitude-latitute-altitude coordinates
</p>


<h3>Author(s)</h3>

<p>Hans-J. Bibiko</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+kmlPolygon">kmlPolygon</a></code>, <code><a href="maptools.html#topic+kmlLine">kmlLine</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wrld_simpl)
## creates a KML file containing the polygons of South Africa (plus hole)
sw &lt;- slot(wrld_simpl[wrld_simpl$NAME=="South Africa",], "polygons")[[1]]
tf &lt;- tempfile()
kmlPolygon(sw, kmlfile=tf, name="South Africa", col="#df0000aa", lwd=5, 
    border=4, kmlname="R Test", 
    kmldescription="This is &lt;b&gt;only&lt;/b&gt; a &lt;a href='http://www.r-project.org'&gt;R&lt;/a&gt; test.")
zz &lt;- getKMLcoordinates(tf, ignoreAltitude=TRUE)
str(zz)
zz &lt;- getKMLcoordinates(system.file("shapes/Testing.kml", package="maptools"))
str(zz)
</code></pre>

<hr>
<h2 id='gpcholes'>Hisaji Ono's lake/hole problem</h2><span id='topic+gpcholes'></span><span id='topic+h1pl'></span><span id='topic+h2pl'></span>

<h3>Description</h3>

<p>How to plot polygons with holes - holes are encoded by coordinates going anticlockwise, and overplotting is avoided by re-ordering the order in which polygons are plotted.
</p>
<p>This example is retained for historical interest only, other solutions are present in the sp package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gpcholes)</code></pre>


<h3>Details</h3>

<p>&quot;Date: Tue, 11 May 2004 12:54:20 +0900
From: Hisaji ONO 
To: r-help
</p>
<p>I've tried to create a polygon with one hole by gpclib using following
example script.
</p>
<p>holepoly &lt;- read.polyfile(system.file(&quot;poly-ex/hole-poly.txt&quot;, package=&quot;gpclib&quot;), nohole = FALSE)
area.poly(holepoly)
plot(holepoly,poly.args=list(col=&quot;red&quot;,border=&quot;blue&quot;))
</p>
<p>And I noticed plot function couldn't draw polygons with holes correctly.
</p>
<p>Does anyone know how to solve this situation?&quot;
</p>
<p>*(h1pl has reversed the y component of polygon 1, to make its ring direction clockwise, h2pl reverses the order of the two polygons in holepoly1@pts)*
</p>


<h3>Source</h3>

<p>Data file included in &quot;gpclib&quot; package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gpcholes)
opar &lt;- par(mfrow=c(1,2))
plot(SpatialPolygons(list(h2pl)), col="red", pbg="white", border="blue")
plot(SpatialPolygons(list(h1pl)), col="red", pbg="white", border="blue")
par(opar)
</code></pre>

<hr>
<h2 id='gzAzimuth'>Find azimuth for geographical coordinates</h2><span id='topic+gzAzimuth'></span><span id='topic+trackAzimuth'></span>

<h3>Description</h3>

<p>The function finds azimuth values for geographical coordinates given as decimal degrees from the <code>from</code> coordinates to the <code>to</code> coordinate. In function <code>trackAzimuth</code>, the azimuth values are found between successive rows of the input coordinate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gzAzimuth(from, to, type = "snyder_sphere")
trackAzimuth(track, type="snyder_sphere")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gzAzimuth_+3A_from">from</code></td>
<td>
<p>a two column matrix of geographical coordinates given as decimal degrees (longitude first)</p>
</td></tr>
<tr><td><code id="gzAzimuth_+3A_track">track</code></td>
<td>
<p>a two column matrix of geographical coordinates given as decimal degrees (longitude first)</p>
</td></tr>
<tr><td><code id="gzAzimuth_+3A_to">to</code></td>
<td>
<p>a one row, two column matrix or two element vector of geographical coordinates given as decimal degrees (longitude first)</p>
</td></tr>
<tr><td><code id="gzAzimuth_+3A_type">type</code></td>
<td>
<p>default is <code>"snyder_sphere"</code>, otherwise <code>"abdali"</code>; the results should be identical with slightly less trigonometry in <code>"abdali"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The azimuth is calculated on the sphere, using the formulae given by Snyder (1987, p. 30) and Abdali (1997, p. 17). The examples use data taken from Abdali (p. 17&ndash;18). There is a very interesting discussion of the centrality of azimuth-finding in the development of mathematics and mathematical geography in Abdali's paper. Among others, al-Khwarizmi was an important contributor. As Abdali puts it, &quot;This is a veritable who's who of medieval science&quot; (p. 3).
</p>


<h3>Value</h3>

<p>values in decimal degrees - zero is North - of the azimuth from the <code>from</code> coordinates to the <code>to</code> coordinate.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand, with contributions by Sebastian Luque</p>


<h3>References</h3>

<p>Snyder JP (1987) Map projections - a working manual, USGS Professional Paper 1395; Abdali SK (1997) &quot;The Correct Qibla&quot;, formerly at http://patriot.net/users/abdali/ftp/qibla.pdf</p>


<h3>Examples</h3>

<pre><code class='language-R'>name &lt;- c("Mecca", "Anchorage", "Washington")
long &lt;- c(39.823333, -149.883333, -77.0166667)
lat &lt;- c(21.423333, 61.2166667, 38.9)
x &lt;- cbind(long, lat)
row.names(x) &lt;- name
crib &lt;- c(-9.098363, 56.575960)
r1 &lt;- gzAzimuth(x[2:3,], x[1,])
r1
all.equal(r1, crib)
r2 &lt;- gzAzimuth(x[2:3,], x[1,], type="abdali")
r2
all.equal(r2, crib)
trackAzimuth(x)
</code></pre>

<hr>
<h2 id='kmlLine'>Create and write a KML file on the basis of a given Lines object</h2><span id='topic+kmlLine'></span>

<h3>Description</h3>

<p>The function is used to create and write a KML file on the basis of a given Lines object (a list of Line objects) for the usage in Google Earth resp. Google Maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmlLine(obj=NULL, kmlfile=NULL, 
    name="R Line", description="", col=NULL, visibility=1, lwd=1,
    kmlname="", kmldescription="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmlLine_+3A_obj">obj</code></td>
<td>
<p>a <code>Lines</code> or <code>SpatialLinesDataFrame</code> object</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_kmlfile">kmlfile</code></td>
<td>
<p>if not <code>NULL</code> the name as character string of the kml file to be written</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_name">name</code></td>
<td>
<p>the name of the KML line</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_description">description</code></td>
<td>
<p>the description of the KML line (HTML tags allowed)</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_col">col</code></td>
<td>
<p>the stroke color (see also Color Specification) of the KML line</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_visibility">visibility</code></td>
<td>
<p>if set to <code>1</code> or <code>TRUE</code> specifies that the KML line should be visible after loading</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_lwd">lwd</code></td>
<td>
<p>the stroke width for the KML line</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_kmlname">kmlname</code></td>
<td>
<p>the name of the KML layer</p>
</td></tr>
<tr><td><code id="kmlLine_+3A_kmldescription">kmldescription</code></td>
<td>
<p>the description of the KML layer (HTML tags allowed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to convert a given <code>Lines</code> object (a list of Line objects) or the first <code>Lines</code> object listed in a passed <code>SpatialLinesDataFrame</code> object into KML line(s). If <code>kmlfile</code> is not <code>NULL</code> the result will be written into that file. If <code>kmlfile</code> is <code>NULL</code> the generated KML lines will be returned (see also value). 
</p>
<p>For a passed <code>Lines</code> object the function generates a &lt;Style&gt; tag whereby its id attribute is set to the passed object's ID.
</p>
<p>Note that the geometries should be in geographical coordinates with datum WGS84.
</p>
<p>The resulting KML line will be embedded in <code>&lt;Placemark&gt;&lt;MultiGeometry&gt;&lt;LineString&gt;</code>.
</p>


<h3>Value</h3>

<p>x is a list with the elements <code>style</code> and <code>content</code> containing the generated lines of the KML file as character vectors if <code>kmlfile</code> is <code>NULL</code>.
</p>
<p>y is a list with the elements <code>header</code> and <code>footer</code> representing the KML file' header resp. footer if <code>obj</code> is <code>NULL</code>.
</p>


<h3>Color Specification</h3>

<p>The following color specifications are allowed: <code>'red'</code>, <code>2</code>, or as hex code <code>'#RRGGBB'</code> resp. <code>'#RRGGBBAA'</code> for passing the alpha value.
</p>


<h3>Author(s)</h3>

<p>Hans-J. Bibiko</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+kmlOverlay">kmlOverlay</a></code>, <code><a href="maptools.html#topic+kmlPolygon">kmlPolygon</a></code>, <code><a href="sp.html#topic+Line">Line</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- readShapeSpatial(system.file("shapes/fylk-val-ll.shp",
      package="maptools")[1], proj4string=CRS("+proj=longlat +ellps=WGS84"))
out &lt;- sapply(slot(xx, "lines"), function(x) { kmlLine(x,
    name=slot(x, "ID"), col="blue", lwd=1.5, 
    description=paste("river:", slot(x, "ID"))) })
tf &lt;- tempfile()
kmlFile &lt;- file(tf, "w")
tf
cat(kmlLine(kmlname="R Test", kmldescription="&lt;i&gt;Hello&lt;/i&gt;")$header, 
    file=kmlFile, sep="\n")
cat(unlist(out["style",]), file=kmlFile, sep="\n")
cat(unlist(out["content",]), file=kmlFile, sep="\n")
cat(kmlLine()$footer, file=kmlFile, sep="\n")
close(kmlFile)
</code></pre>

<hr>
<h2 id='kmlLines'>Create and write a KML file on the basis of a given Lines object</h2><span id='topic+kmlLines'></span>

<h3>Description</h3>

<p>The function is used to create and write a KML file on the basis of a given Lines object (a list of Line objects) for the usage in Google Earth and Google Maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmlLines(obj=NULL, kmlfile=NULL, 
        name="R Lines", description="", col=NULL, visibility=1, lwd=1,
        kmlname="", kmldescription="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmlLines_+3A_obj">obj</code></td>
<td>
<p>a <code>Lines</code> or <code>SpatialLinesDataFrame</code> object</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_kmlfile">kmlfile</code></td>
<td>
<p>if not <code>NULL</code> the name as character string of the kml file to be written</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_name">name</code></td>
<td>
<p>the name of the KML line</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_description">description</code></td>
<td>
<p>the description of the KML line (HTML tags allowed)</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_col">col</code></td>
<td>
<p>the stroke color (see also Color Specification) of the KML line</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_visibility">visibility</code></td>
<td>
<p>if set to <code>1</code> or <code>TRUE</code> specifies that the KML line should be visible after loading</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_lwd">lwd</code></td>
<td>
<p>the stroke width for the KML line</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_kmlname">kmlname</code></td>
<td>
<p>the name of the KML layer</p>
</td></tr>
<tr><td><code id="kmlLines_+3A_kmldescription">kmldescription</code></td>
<td>
<p>the description of the KML layer (HTML tags allowed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to convert a given <code>Lines</code> object (a list of Line objects) or the first <code>Lines</code> object listed in a passed <code>SpatialLinesDataFrame</code> object into KML line(s). If <code>kmlfile</code> is not <code>NULL</code> the result will be written into that file. If <code>kmlfile</code> is <code>NULL</code> the generated KML lines will be returned (see also value). Function no longer uses <code>append</code> greatly improving performance on large objects or lists. 
</p>
<p>For a passed <code>Lines</code> object the function generates a &lt;Style&gt; tag whereby its id attribute is set to the passed object's ID.
</p>
<p>Note that the geometries should be in geographical coordinates with datum WGS84.
</p>
<p>The resulting KML line will be embedded in <code>&lt;Placemark&gt;&lt;MultiGeometry&gt;&lt;LineString&gt;</code>.
</p>


<h3>Value</h3>

<p>x is a list with the elements <code>style</code> and <code>content</code> containing the generated lines of the KML file as character vectors if <code>kmlfile</code> is <code>NULL</code>.
</p>
<p>y is a list with the elements <code>header</code> and <code>footer</code> representing the KML file header and footer if <code>obj</code> is <code>NULL</code>.
</p>


<h3>Color Specification</h3>

<p>The following color specifications are allowed: <code>'red'</code>, <code>2</code>, or as hex code <code>'#RRGGBB'</code> resp. <code>'#RRGGBBAA'</code> for passing the alpha value.
</p>


<h3>Author(s)</h3>

<p>Hans-J. Bibiko, Jon Callahan, Steven Brey</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+kmlOverlay">kmlOverlay</a></code>, <code><a href="maptools.html#topic+kmlPolygon">kmlPolygon</a></code>, <code><a href="sp.html#topic+Line">Line</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Maptools library required
library(maptools)
# load line object
rivers &lt;- readShapeSpatial(system.file("shapes/fylk-val-ll.shp",
                           package="maptools")[1], proj4string=CRS("+proj=longlat +ellps=WGS84"))
# create kml file
td &lt;- tempdir()
kmlfile &lt;- paste(td, "rivers.kml", sep="/")
kmlLines(rivers, kmlfile = kmlfile, name = "R Lines", 
         description = "Hello!", col = "blue", visibility = 1, lwd = 1, 
         kmlname = "", kmldescription = "")
</code></pre>

<hr>
<h2 id='kmlOverlay'>Create and write KML file for PNG image overlay</h2><span id='topic+kmlOverlay'></span>

<h3>Description</h3>

<p>The function is used to create and write a KML file for a PNG image overlay for Google Earth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmlOverlay(obj, kmlfile = NULL, imagefile = NULL, name = "R image")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmlOverlay_+3A_obj">obj</code></td>
<td>
<p>a <code>GE_SG</code> object from <code>GE_SpatialGrid</code></p>
</td></tr>
<tr><td><code id="kmlOverlay_+3A_kmlfile">kmlfile</code></td>
<td>
<p>if not NULL the name of the kml file to be written</p>
</td></tr>
<tr><td><code id="kmlOverlay_+3A_imagefile">imagefile</code></td>
<td>
<p>the name of the PNG file containing the image - this should be either relative (same directory as kml file) or abosolute (fully qualified)</p>
</td></tr>
<tr><td><code id="kmlOverlay_+3A_name">name</code></td>
<td>
<p>the name used to describe the image overlay in GE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used together with <code>GE_SpatialGrid</code> to wrap around the opening of a PNG graphics device, plotting code, and the closing of the device. The computed values take account of the adjustment of the actual data bounding box to an integer number of rows and columns in the image file. 
</p>
<p>The approach may be used as an alternative to writing PNG files from SpatialGrid and SpatialPixel objects in <span class="pkg">rgdal</span> using <code>writeGDAL</code>, and to writing KML files using <code>writeOGR</code> for vector data objects. The output PNG files are likely to be very much smaller than large vector data KML files, and hinder the retrieval of exact positional information.
</p>
<p>Note that the geometries should be in geographical coordinates with datum WGS84.
</p>


<h3>Value</h3>

<p>x is a character vector containing the generated lines of the kml file
</p>


<h3>Author(s)</h3>

<p>Duncan Golicher, David Forrest and Roger Bivand</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+GE_SpatialGrid">GE_SpatialGrid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>opt_exask &lt;- options(example.ask=FALSE)
qk &lt;- SpatialPointsDataFrame(quakes[, c(2:1)], quakes)
proj4string(qk) &lt;- CRS("+proj=longlat +ellps=WGS84")
tf &lt;- tempfile()
SGqk &lt;- GE_SpatialGrid(qk)
png(file=paste(tf, ".png", sep=""), width=SGqk$width, height=SGqk$height,
  bg="transparent")
par(mar=c(0,0,0,0), xaxs="i", yaxs="i")
plot(qk, xlim=SGqk$xlim, ylim=SGqk$ylim, setParUsrBB=TRUE)
dev.off()
kmlOverlay(SGqk, paste(tf, ".kml", sep=""), paste(tf, ".png", sep=""))
## Not run: 
#library(rgdal)
#qk0 &lt;- quakes
#qk0$long &lt;- ifelse(qk0$long &lt;= 180, qk0$long, qk0$long-360)
#qk0a &lt;- SpatialPointsDataFrame(qk0[, c(2:1)], qk0)
#proj4string(qk0a) &lt;- CRS("+proj=longlat +ellps=WGS84")
#writeOGR(qk0a, paste(tf, "v.kml", sep=""), "Quakes", "KML")
#system(paste("googleearth ", tf, ".kml", sep=""))

## End(Not run)
options(example.ask=opt_exask)
</code></pre>

<hr>
<h2 id='kmlPoints'>Create and write a KML file on the basis of a given Points object</h2><span id='topic+kmlPoints'></span>

<h3>Description</h3>

<p>The function is used to create and write a KML file on the basis of a given SpatialPointsDataFrame object for the usage in Google Earth resp. Google Maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmlPoints(obj=NULL, kmlfile=NULL, kmlname="", kmldescription="",
    name=NULL, description="",
    icon="http://www.gstatic.com/mapspro/images/stock/962-wht-diamond-blank.png")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmlPoints_+3A_obj">obj</code></td>
<td>
<p>a <code>SpatialPointsDataFrame</code> object</p>
</td></tr>
<tr><td><code id="kmlPoints_+3A_kmlfile">kmlfile</code></td>
<td>
<p>if not <code>NULL</code> the name as character string of the kml file to be written</p>
</td></tr>
<tr><td><code id="kmlPoints_+3A_kmlname">kmlname</code></td>
<td>
<p>the name of the KML layer</p>
</td></tr>
<tr><td><code id="kmlPoints_+3A_kmldescription">kmldescription</code></td>
<td>
<p>the description of the KML layer (HTML tags allowed)</p>
</td></tr>
<tr><td><code id="kmlPoints_+3A_name">name</code></td>
<td>
<p>a character vector to be used as names for each KML Placemark</p>
</td></tr>
<tr><td><code id="kmlPoints_+3A_description">description</code></td>
<td>
<p>a character vector to be used as the description for each KML Placemark (HTML tags allowed)</p>
</td></tr>
<tr><td><code id="kmlPoints_+3A_icon">icon</code></td>
<td>
<p>a character vector of icon URLs to be used in the style associated with each KML Placemark</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to convert a given <code>SpatialPointsDataFrame</code> object into a series of KML Placemarks, each with a single Point. If <code>kmlfile</code> is not <code>NULL</code> the result will be written into that file. If <code>kmlfile</code> is <code>NULL</code> the generated KML lines will be returned (see also value). 
</p>
<p>If <code>name=NULL</code>, the &lt;name&gt; tag for each Placemark will be <code>'site #'</code>. If a single value is used for 
<code>name</code> or <code>description</code>, that value will be replicated for each Placemark. If a single value is used for
<code>icon</code>, only a single style will be created and that style will be referenced by each Placemark.
</p>
<p>Note that the geometries should be in geographical coordinates with datum WGS84.
</p>


<h3>Value</h3>

<p>x is a list with the elements <code>style</code> and <code>content</code> containing the generated lines of the KML file as character vectors if <code>kmlfile</code> is <code>NULL</code>.
</p>
<p>y is a list with the elements <code>header</code> and <code>footer</code> representing the KML file' header resp. footer if <code>obj</code> is <code>NULL</code>.
</p>


<h3>KML icons</h3>

<p>The default icon URL is <a href="http://www.gstatic.com/mapspro/images/stock/962-wht-diamond-blank.png">http://www.gstatic.com/mapspro/images/stock/962-wht-diamond-blank.png</a>. Additional icons are available at:
<a href="http://sites.google.com/site/gmapsdevelopment">http://sites.google.com/site/gmapsdevelopment</a>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+kmlLine">kmlLine</a></code>, <code><a href="maptools.html#topic+kmlOverlay">kmlOverlay</a></code>, <code><a href="maptools.html#topic+kmlPolygon">kmlPolygon</a></code>, <code><a href="sp.html#topic+Line">Line</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SplashDams)
num &lt;- length(SplashDams)
td &lt;- tempdir()
kmlfile &lt;- paste(td, "OregonSplashDams.kml", sep="/")
kmlname &lt;- "Oregon Splash Dams"
kmldescription &lt;- paste("Data for Splash Dams in western Oregon.",
 "See http://www.fs.fed.us/pnw/lwm/aem/people/burnett.html#projects_activities",
 "for more information.")
icon &lt;- "http://www.gstatic.com/mapspro/images/stock/962-wht-diamond-blank.png"
name &lt;- paste("Dam on",SplashDams$streamName)
description &lt;- paste("&lt;b&gt;owner:&lt;/b&gt;", SplashDams$owner, "&lt;br&gt;&lt;b&gt;dates:&lt;/b&gt;", SplashDams$datesUsed)

kmlPoints(SplashDams, kmlfile=kmlfile, name=name, description=description,
          icon=icon, kmlname=kmlname, kmldescription=kmldescription)
</code></pre>

<hr>
<h2 id='kmlPolygon'>Create and write a KML file on the basis of a given Polygons object</h2><span id='topic+kmlPolygon'></span>

<h3>Description</h3>

<p>The function is used to create and write a KML file on the basis of a given Polygons object (a list of Polygon objects) for the usage in Google Earth resp. Google Maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmlPolygon(obj=NULL, kmlfile=NULL, 
    name="R Polygon", description="", col=NULL, visibility=1, lwd=1, border=1,
    kmlname="", kmldescription="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmlPolygon_+3A_obj">obj</code></td>
<td>
<p>a <code>Polygons</code> or <code>SpatialPolygonsDataFrame</code> object</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_kmlfile">kmlfile</code></td>
<td>
<p>if not <code>NULL</code> the name as character string of the kml file to be written</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_name">name</code></td>
<td>
<p>the name of the KML polygon</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_description">description</code></td>
<td>
<p>the description of the KML polygon (HTML tags allowed)</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_col">col</code></td>
<td>
<p>the fill color (see also Color Specification) of the KML polygon</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_visibility">visibility</code></td>
<td>
<p>if set to <code>1</code> or <code>TRUE</code> specifies that the KML polygon should be visible after loading</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_lwd">lwd</code></td>
<td>
<p>the stroke width for the KML polygon</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_border">border</code></td>
<td>
<p>the stroke color (see also Color Specification) for the KML polygon</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_kmlname">kmlname</code></td>
<td>
<p>the name of the KML layer</p>
</td></tr>
<tr><td><code id="kmlPolygon_+3A_kmldescription">kmldescription</code></td>
<td>
<p>the description of the KML layer (HTML tags allowed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to convert a given <code>Polygons</code> object (a list of Polygon objects) or the first <code>Polygons</code> object listed in a passed <code>SpatialPolygonsDataFrame</code> object into KML polygon. If <code>kmlfile</code> is not <code>NULL</code> the result will be written into that file. If <code>kmlfile</code> is <code>NULL</code> the generated KML lines will be returned (see also value). 
</p>
<p>The conversion can also handle polygons which are marked as holes inside of the Polygons object if these holes are listed right after that polygon in which these holes appear. That implies that a given plot order set in the Polygons object will <b>not</b> be considered.
</p>
<p>For a passed <code>Polygons</code> object the function generates a &lt;Style&gt; tag whereby its id attribute is set to the passed object's ID.
</p>
<p>Note that the geometries should be in geographical coordinates with datum WGS84.
</p>
<p>The resulting KML polygon will be embedded in <code>&lt;Placemark&gt;&lt;MultiGeometry&gt;&lt;Polygon&gt;</code>.
</p>


<h3>Value</h3>

<p>x is a list with the elements <code>style</code> and <code>content</code> containing the generated lines of the KML file as character vectors if <code>kmlfile</code> is <code>NULL</code>.
</p>
<p>y is a list with the elements <code>header</code> and <code>footer</code> representing the KML file' header resp. footer if <code>obj</code> is <code>NULL</code> (see second example).
</p>


<h3>Color Specification</h3>

<p>The following color specifications are allowed: <code>'red'</code>, <code>2</code>, or as hex code <code>'#RRGGBB'</code> resp. <code>'#RRGGBBAA'</code> for passing the alpha value.
</p>


<h3>Author(s)</h3>

<p>Hans-J. Bibiko</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+kmlOverlay">kmlOverlay</a></code>, <code><a href="maptools.html#topic+kmlLine">kmlLine</a></code>, <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wrld_simpl)
## creates a KML file containing the polygons of South Africa (plus hole)
sw &lt;- slot(wrld_simpl[wrld_simpl$NAME=="South Africa",], "polygons")[[1]]
tf &lt;- tempfile()
kmlPolygon(sw, kmlfile=tf, name="South Africa", col="#df0000aa", lwd=5, 
    border=4, kmlname="R Test", 
    kmldescription="This is &lt;b&gt;only&lt;/b&gt; a &lt;a href='http://www.r-project.org'&gt;R&lt;/a&gt; test.")
tf

## creates a KML file containing the polygons of South Africa, Switzerland, and Canada
sw  &lt;- wrld_simpl[wrld_simpl$NAME %in% c("South Africa", "Switzerland", "Canada"),]
out &lt;- sapply(slot(sw, "polygons"), function(x) { kmlPolygon(x,
    name=as(sw, "data.frame")[slot(x, "ID"), "NAME"], 
    col="red", lwd=1.5, border='black', 
    description=paste("ISO3:", slot(x, "ID"))) })
tf &lt;- tempfile()
kmlFile &lt;- file(tf, "w")
tf
cat(kmlPolygon(kmlname="R Test", kmldescription="&lt;i&gt;Hello&lt;/i&gt;")$header, 
    file=kmlFile, sep="\n")
cat(unlist(out["style",]), file=kmlFile, sep="\n")
cat(unlist(out["content",]), file=kmlFile, sep="\n")
cat(kmlPolygon()$footer, file=kmlFile, sep="\n")
close(kmlFile)
</code></pre>

<hr>
<h2 id='kmlPolygons'>Create and write a KML file on the basis of a given Polygons object or list of Polygons or SpatialPolygonsDataFrame </h2><span id='topic+kmlPolygons'></span>

<h3>Description</h3>

<p>The function is used to create and write a KML file on the basis of a given Polygons object (a list of Polygon objects of SpatialPolygonsDataFrame class) for the usage in Google Earth and Google Maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmlPolygons(obj=NULL, kmlfile=NULL, 
    name="KML Polygons", description="", col=NULL, visibility=1, lwd=1,
    border="white", kmlname="", kmldescription="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmlPolygons_+3A_obj">obj</code></td>
<td>
<p>a <code>Polygons</code> or <code>SpatialPolygonsDataFrame</code> object or list of objects</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_kmlfile">kmlfile</code></td>
<td>
<p>if not <code>NULL</code> the name as character string of the kml file to be written to working directory as &quot;NAME.kml&quot;</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_name">name</code></td>
<td>
<p>the name of the KML polygon in Google Earth</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_description">description</code></td>
<td>
<p>the description of the KML polygon displayed in Google Earth or Maps (HTML tags allowed)</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_col">col</code></td>
<td>
<p>the fill color (see also Color Specification) of the KML polygon. If passing a list of <code>Polyons</code> or <code>SpatialPolygonsDataFrame</code> and <code>length(col)</code> is less than <code>length(object)</code> the first color in col will be applied to all objects in the list</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_visibility">visibility</code></td>
<td>
<p>if set to <code>1</code> or <code>TRUE</code> specifies that the KML polygon should be visible after loading</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_lwd">lwd</code></td>
<td>
<p>the stroke (polygon's border line) width for the KML polygon</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_border">border</code></td>
<td>
<p>the stroke color (see also Color Specification) for the KML polygon</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_kmlname">kmlname</code></td>
<td>
<p>the name of the KML layer</p>
</td></tr>
<tr><td><code id="kmlPolygons_+3A_kmldescription">kmldescription</code></td>
<td>
<p>the description of the KML layer (HTML tags allowed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to convert a given <code>Polygons</code> object (a list of Polygon objects) or the  <code>Polygons</code> object listed in a passed <code>SpatialPolygonsDataFrame</code> object into KML polygon. If <code>kmlfile</code> is not <code>NULL</code> the result will be written into that file. If <code>kmlfile</code> is <code>NULL</code> the generated KML lines will be returned (see also value).
</p>
<p>The conversion can also handle polygons which are marked as holes inside of the Polygons object if these holes are listed right after that polygon in which these holes appear. That implies that a given plot order set in the Polygons object will <b>not</b> be considered.
</p>
<p>For a passed <code>Polygons</code> object the function generates a &lt;Style&gt; tag whereby its id attribute is set to the passed object's ID.
</p>
<p>Note that the geometries should be in geographical coordinates with datum WGS84.
</p>
<p>The resulting KML polygon will be embedded in <code>&lt;Placemark&gt;&lt;MultiGeometry&gt;&lt;Polygon&gt;</code>.
</p>


<h3>Value</h3>

<p>x is a list with the elements <code>style</code> and <code>content</code> containing the generated lines of the KML file as character vectors if <code>kmlfile</code> is <code>NULL</code>.
</p>
<p>y is a list with the elements <code>header</code> and <code>footer</code> representing the KML file' header resp. footer if <code>obj</code> is <code>NULL</code> (see second example).
</p>


<h3>Color Specification</h3>

<p>The following color specifications are allowed: <code>'red'</code>, <code>2</code>, or as hex code <code>'#RRGGBB'</code> resp. <code>'#RRGGBBAA'</code> for passing the alpha value.
</p>


<h3>Author(s)</h3>

<p>Hans-J. Bibiko, Jon Callihan, Steven Brey</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+kmlPolygon">kmlPolygon</a></code>, <code><a href="maptools.html#topic+kmlLines">kmlLines</a></code>, <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>, <code>kmlPoints</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wrld_simpl)
td &lt;- tempdir()
kmlfile &lt;- paste(td, "worldPolitical.kml", sep="/")
## creates a KML file containing the polygons of a political world map
kmlPolygons(wrld_simpl, kmlfile = kmlfile, name = "KML Polygons", 
         description = "the world", col = "red",
         visibility = 1, lwd = 1, border = "white", kmlname = "R Test", 
         kmldescription = "This is &lt;b&gt;only&lt;/b&gt; a &lt;a href='http://www.r-project.org'&gt;R&lt;/a&gt; test.")

data(wrld_simpl)
## create a KML file containing the polygons of Brazil, Uganda, and Canada
regions &lt;- c("Brazil","Canada","Uganda")
wrld_simpl_subset &lt;- wrld_simpl[wrld_simpl$NAME %in% regions,]
kmlfile &lt;- paste(td, "worldPoliticalSubset.kml", sep="/")
kmlPolygons(wrld_simpl_subset, kmlfile = kmlfile,
 name = "KML Polygons subset", description = "three countries", col = "blue", 
 visibility = 1, lwd = 1, border = "white", kmlname = "R Test 2", 
 kmldescription = "This is &lt;b&gt;only&lt;/b&gt; a &lt;a href='http://www.r-project.org'&gt;R&lt;/a&gt; test.")
## combine to make a list of polygon objects to plot
polList &lt;- c(regions,wrld_simpl)
kmlfile &lt;- paste(td, "worldPoliticalandSubset.kml", sep="/")
kmlPolygons(wrld_simpl_subset, kmlfile = kmlfile,
 name = "KML Polygons subset", description = "three countries highlighted in world", 
 col = sample(colours(), length(polList)), visibility = 1, lwd = 1, border = "white", 
 kmlname = "R Test 2", 
 kmldescription = "This is &lt;b&gt;only&lt;/b&gt; a &lt;a href='http://www.r-project.org'&gt;R&lt;/a&gt; test.")

</code></pre>

<hr>
<h2 id='leglabs'>Make legend labels</h2><span id='topic+leglabs'></span>

<h3>Description</h3>

<p><code>leglabs</code> makes character strings from the same break points. The <code>plot.polylist()</code> function may be used as a generic S3 method. </p>


<h3>Usage</h3>

<pre><code class='language-R'>leglabs(vec, under="under", over="over", between="-", reverse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leglabs_+3A_vec">vec</code></td>
<td>
<p>vector of break values</p>
</td></tr>
<tr><td><code id="leglabs_+3A_under">under</code></td>
<td>
<p>character value for under</p>
</td></tr>
<tr><td><code id="leglabs_+3A_over">over</code></td>
<td>
<p>character value for over</p>
</td></tr>
<tr><td><code id="leglabs_+3A_between">between</code></td>
<td>
<p>character value for between</p>
</td></tr>
<tr><td><code id="leglabs_+3A_reverse">reverse</code></td>
<td>
<p>flag to reverse order of values, you will also need to reorder colours, see example</p>
</td></tr>



</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+findInterval">findInterval</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mappolys &lt;- readShapeSpatial(system.file("shapes/columbus.shp", package="maptools")[1], ID="NEIGNO")
brks &lt;- round(quantile(mappolys$CRIME, probs=seq(0,1,0.2)), digits=2)
colours &lt;- c("salmon1", "salmon2", "red3", "brown", "black")
plot(mappolys, col=colours[findInterval(mappolys$CRIME, brks,
 all.inside=TRUE)])
legend(x=c(5.8, 7.1), y=c(13, 14.5), legend=leglabs(brks),
  fill=colours, bty="n")
title(main=paste("Columbus OH: residential burglaries and vehicle",
 "thefts per thousand households, 1980", sep="\n"))
#legend with reversed order
plot(mappolys, col=colours[findInterval(mappolys$CRIME, brks,
 all.inside=TRUE)])
legend(x=c(5.8, 7.1), y=c(13, 14.5), legend=leglabs(brks, reverse = TRUE),
  fill=rev(colours), bty="n")
title(main=paste("Columbus OH: residential burglaries and vehicle",
 "thefts per thousand households, 1980 (reversed legend)", sep="\n"))
</code></pre>

<hr>
<h2 id='lineLabel'>
Line label placement with spplot and lattice.
</h2><span id='topic+lineLabel'></span><span id='topic+sp.lineLabel'></span><span id='topic+label'></span><span id='topic+sp.lineLabel-methods'></span><span id='topic+label-methods'></span><span id='topic+sp.lineLabel+2CLines-method'></span><span id='topic+sp.lineLabel+2CSpatialLines-method'></span><span id='topic+label+2CSpatialLines-method'></span>

<h3>Description</h3>

<p> The <code>lineLabel</code> function produces and draws text
grobs following the paths defined by a list of <code>Line</code>
objects. The <code>sp.lineLabel</code> methods use this function to work
easily with <code>spplot</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineLabel(line, label,
          spar=.6, position = c('above', 'below'),
          textloc = 'constantSlope',
          col = add.text$col,
          alpha = add.text$alpha,
          cex = add.text$cex,
          lineheight = add.text$lineheight,
          font = add.text$font,
          fontfamily = add.text$fontfamily,
          fontface = add.text$fontface,
          lty = add.line$lty,
          lwd = add.line$lwd, 
          col.line = add.line$col,
          identifier = 'lineLabel',
          ...)

sp.lineLabel(object, labels, byid=TRUE,...)

label(object, text, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineLabel_+3A_line">line</code></td>
<td>
<p>a <code>list</code> of <code>Lines</code>.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_object">object</code></td>
<td>
<p>A <code>Lines</code> or <code>SpatialLines</code> object.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_label">label</code>, <code id="lineLabel_+3A_labels">labels</code>, <code id="lineLabel_+3A_text">text</code></td>
<td>
<p>a string or expression to be printed
following the path of <code>line</code>. The <code>names</code> of <code>labels</code>
should match the values of the <code>ID</code> slot of the lines to
label. If <code>labels</code> is missing, the <code>ID</code> slot is used
instead. The <code>label</code> method is a wrapper function to extract
the <code>ID</code> slots and create a suitable <code>character</code> object
with the correct <code>names</code> values.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_byid">byid</code></td>
<td>
<p>If TRUE (default) only the longest line of each unique
<code>ID</code> value will be labelled.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_textloc">textloc</code></td>
<td>
<p>a character or a numeric. It may be 'constantSlope',
'minSlope' or 'maxDepth', or the numeric index of the location. If
it is a numeric, its length must coincide with the number of
<code>Lines</code>.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter. With values near zero, the label
will closely follow the line. Default value is .6. See smooth.spline for details.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_position">position</code></td>
<td>
<p>character string ('above' or 'below') to define where
the text must be placed.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_col">col</code>, <code id="lineLabel_+3A_alpha">alpha</code>, <code id="lineLabel_+3A_cex">cex</code>, <code id="lineLabel_+3A_lineheight">lineheight</code>, <code id="lineLabel_+3A_font">font</code>, <code id="lineLabel_+3A_fontfamily">fontfamily</code>, <code id="lineLabel_+3A_fontface">fontface</code></td>
<td>
<p>graphical arguments for the text. See gpar for details.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_lty">lty</code>, <code id="lineLabel_+3A_lwd">lwd</code>, <code id="lineLabel_+3A_col.line">col.line</code></td>
<td>
<p>graphical parameters for the line. See gpar for details.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_identifier">identifier</code></td>
<td>
<p>A character string to identify the grob to be created.</p>
</td></tr>
<tr><td><code id="lineLabel_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part of the label location code is adapted from <code><a href="lattice.html#topic+panel.levelplot">panel.levelplot</a></code>. 
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> is used to resample the segment of the line where the label is placed.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro.
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spplot">spplot</a></code>
<code><a href="maptools.html#topic+sp.pointLabel">sp.pointLabel</a></code>
<code><a href="car.html#topic+pointLabel">pointLabel</a></code>
<code><a href="lattice.html#topic+panel.levelplot">panel.levelplot</a></code>
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid)
coordinates(meuse.grid) = ~x+y
proj4string(meuse.grid) &lt;- CRS("+init=epsg:28992")
gridded(meuse.grid) = TRUE

data(meuse)
coordinates(meuse) = ~x+y
data(meuse.riv)
meuse.sl &lt;- SpatialLines(list(Lines(list(Line(meuse.riv)), "1")))

run &lt;- FALSE
if (require("RColorBrewer", quietly=TRUE)) run &lt;- TRUE
if (run) {
myCols &lt;- adjustcolor(colorRampPalette(brewer.pal(n=9, 'Reds'))(100), .85)

labs &lt;- label(meuse.sl, 'Meuse River')

## Maximum depth
sl1 &lt;- list('sp.lineLabel', meuse.sl, label=labs,
            position='below', textloc='maxDepth',
            spar=.2,
            col='darkblue', cex=1,
            fontfamily='Palatino',
            fontface=2)

spplot(meuse.grid["dist"],
       col.regions=myCols, 
       sp.layout = sl1)

## Constant slope
sl2 &lt;- modifyList(sl1, list(textloc = 'constantSlope')) ## Default

spplot(meuse.grid["dist"],
       col.regions=myCols, 
       sp.layout = sl2)

## Location defined by its numeric index
sl3 &lt;- modifyList(sl1, list(textloc = 140, position='above'))

spplot(meuse.grid["dist"],
       col.regions=myCols, 
       sp.layout = sl3)
}
</code></pre>

<hr>
<h2 id='map2SpatialPolygons'>Convert map objects to sp classes</h2><span id='topic+map2SpatialPolygons'></span><span id='topic+map2SpatialLines'></span><span id='topic+pruneMap'></span>

<h3>Description</h3>

<p>These functions may be used to convert map objects returned by the map function in the maps package to suitable objects defined in the sp package. In the examples below, arguments are shown for retrieving first polygons by name, then lines by window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map2SpatialPolygons(map, IDs, proj4string = CRS(as.character(NA)), checkHoles=FALSE)
map2SpatialLines(map, IDs=NULL, proj4string = CRS(as.character(NA)))
pruneMap(map, xlim=NULL, ylim=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map2SpatialPolygons_+3A_map">map</code></td>
<td>
<p>a map object defined in the maps package and returned by the map function</p>
</td></tr>
<tr><td><code id="map2SpatialPolygons_+3A_ids">IDs</code></td>
<td>
<p>Unique character ID values for each output Polygons object; the input IDs can be an integer or character vector with duplicates, where the duplicates will be combined as a single output Polygons object</p>
</td></tr>
<tr><td><code id="map2SpatialPolygons_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>"CRS"</code>;
holding a valid proj4 string</p>
</td></tr>
<tr><td><code id="map2SpatialPolygons_+3A_checkholes">checkHoles</code></td>
<td>
<p>default=FALSE, if TRUE call <code>checkPolygonsHoles</code>internally to check hole assignment, (by default no polygon objects are holes)</p>
</td></tr>
<tr><td><code id="map2SpatialPolygons_+3A_xlim">xlim</code>, <code id="map2SpatialPolygons_+3A_ylim">ylim</code></td>
<td>
<p>limits for pruning a map object - should only be used for lines, because polygons will not be closed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any zero area output geometries are dropped, and warnings are issued.</p>


<h3>Value</h3>

<p><code>map2SpatialPolygons</code> returns a SpatialPolygons object and <code>map2SpatialLines</code> returns a SpatialLines object (objects defined in the sp package); <code>pruneMap</code> returns a modified map object defined in the maps package
</p>


<h3>Note</h3>

<p>As the examples show, retrieval by name should be checked to see whether a window is not also needed: the &quot;norway&quot; polygons include &quot;Norway:Bouvet Island&quot;, which is in the South Atlantic. Here, the IDs argument is set uniformly to &quot;Norway&quot; for all the component polygons, so that the output object contains a single Polygons object with multiple component Polygon objects. When retrieving by window, pruning may be needed on lines which are included because they begin within the window; interior=FALSE is used to remove country boundaries in this case.</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>See Also</h3>

<p><code><a href="maps.html#topic+map">map</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if(require(maps)) run &lt;- TRUE
if (run) {
nor_coast_poly &lt;- map("world", "norway", fill=TRUE, col="transparent",
 plot=FALSE)
range(nor_coast_poly$x, na.rm=TRUE)
}
if (run) {
range(nor_coast_poly$y, na.rm=TRUE)
}
if (run) {
nor_coast_poly &lt;- map("world", "norway", fill=TRUE, col="transparent",
 plot=FALSE, ylim=c(58,72))
nor_coast_poly$names
}
if (run) {
IDs &lt;- sapply(strsplit(nor_coast_poly$names, ":"), function(x) x[1])
}
if (run) {
nor_coast_poly_sp &lt;- map2SpatialPolygons(nor_coast_poly, IDs=IDs,
 proj4string=CRS("+proj=longlat +datum=WGS84"))
sapply(slot(nor_coast_poly_sp, "polygons"),
 function(x) length(slot(x, "Polygons")))
}
if (run) {
plot(nor_coast_poly_sp, col="grey", axes=TRUE)
}
if (run) {
nor_coast_lines &lt;- map("world", interior=FALSE, plot=FALSE, xlim=c(4,32),
 ylim=c(58,72))
plot(nor_coast_lines, type="l")
}
if (run) {
nor_coast_lines &lt;- pruneMap(nor_coast_lines, xlim=c(4,32), ylim=c(58,72))
lines(nor_coast_lines, col="red")
nor_coast_lines_sp &lt;- map2SpatialLines(nor_coast_lines,
 proj4string=CRS("+proj=longlat +datum=WGS84"))
plot(nor_coast_poly_sp, col="grey", axes=TRUE)
}
if (run) {
plot(nor_coast_lines_sp, col="blue", add=TRUE)
}
if (run) {
worldmap &lt;- map("world", fill=TRUE, plot=FALSE)
worldmapPolys &lt;- map2SpatialPolygons(worldmap, 
 IDs=sapply(strsplit(worldmap$names, ":"), "[", 1L), 
 proj4string=CRS("+proj=longlat +datum=WGS84"))
if (rgeosStatus()) {
require(rgeos)
vals &lt;- rgeos::gIsValid(worldmapPolys, byid=TRUE, reason=TRUE)
print(table(sapply(strsplit(vals, "\\["), "[", 1)))
}
}
</code></pre>

<hr>
<h2 id='nearestPointOnLine'>
Get the nearest point on a line to a given point
</h2><span id='topic+nearestPointOnLine'></span>

<h3>Description</h3>

<p>This function calculates the coordinates of the nearest point on a line to a 
given point. This function does not work with geographic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestPointOnLine(coordsLine, coordsPoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestPointOnLine_+3A_coordsline">coordsLine</code></td>
<td>

<p>Matrix with coordinates of line vertices. Each row represents a vertex. 
</p>
</td></tr>
<tr><td><code id="nearestPointOnLine_+3A_coordspoint">coordsPoint</code></td>
<td>

<p>A vector representing the X and Y coordinates of the point.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the X and Y coordinates of the nearest point on a line to the 
given point.
</p>


<h3>Author(s)</h3>

<p>German Carrillo
</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+nearestPointOnSegment">nearestPointOnSegment</a></code>, <code><a href="maptools.html#topic+snapPointsToLines">snapPointsToLines</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordsLine = cbind(c(1,2,3),c(3,2,2))
coordsPoint = c(1.2,1.5)
nearestPointOnLine(coordsLine, coordsPoint)
</code></pre>

<hr>
<h2 id='nearestPointOnSegment'>
Get the nearest point on a segment to a given point
</h2><span id='topic+nearestPointOnSegment'></span>

<h3>Description</h3>

<p>This function calculates the coordinates of and the distance to the nearest 
point on a segment to a given point. This function does not work with 
geographic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestPointOnSegment(s, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestPointOnSegment_+3A_s">s</code></td>
<td>

<p>A matrix representing the coordinates of the segment. The matrix has 2x2 
dimension where each row represents one of the end points. 
</p>
</td></tr>
<tr><td><code id="nearestPointOnSegment_+3A_p">p</code></td>
<td>

<p>A vector representing the X and Y coordinates of the point.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with three numeric values representing X and Y coordinates of the 
nearest point on a segment to a given point as well as the distance between
both points.
</p>


<h3>Author(s)</h3>

<p>German Carrillo 
</p>


<h3>References</h3>

<p>The function was ported to R based on this code: http://pastebin.com/n9rUuGRh
</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+nearestPointOnLine">nearestPointOnLine</a></code>, <code><a href="maptools.html#topic+snapPointsToLines">snapPointsToLines</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segment = cbind(c(1,2),c(1,1.5))
point = c(1.2,1.5)
nearestPointOnSegment(segment, point)
</code></pre>

<hr>
<h2 id='nowrapRecenter'>Break polygons at meridian for recentering</h2><span id='topic+nowrapRecenter'></span><span id='topic+nowrapSpatialPolygons'></span>

<h3>Description</h3>

<p>When recentering a world map, say to change an &quot;Atlantic&quot; view with longitude range -180 to 180, to a &quot;Pacific&quot; view, with longitude range 0 to 360, polygons crossed by the new offset, here 0/360, need to be clipped into left and right sub.polygons to avoid horizontal scratches across the map. The <code>nowrapSpatialPolygons</code> function performs this operation using polygon intersection, and <code>nowrapRecenter</code> recenters the output SpatialPolygons object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nowrapRecenter(obj, offset = 0, eps = rep(.Machine$double.eps^(1/2.5), 2),
 avoidGEOS = FALSE)
nowrapSpatialPolygons(obj, offset = 0, eps=rep(.Machine$double.eps^(1/2.5), 2),
 avoidGEOS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nowrapRecenter_+3A_obj">obj</code></td>
<td>
<p> A SpatialPolygons object </p>
</td></tr>
<tr><td><code id="nowrapRecenter_+3A_offset">offset</code></td>
<td>
<p> offset from the Greenwich meridian </p>
</td></tr>
<tr><td><code id="nowrapRecenter_+3A_eps">eps</code></td>
<td>
<p>vector of two (left and right) fuzz factors to retract the ring from the offset (2.5 root to accommodate <span class="pkg">rgeos</span> precision rules)</p>
</td></tr>
<tr><td><code id="nowrapRecenter_+3A_avoidgeos">avoidGEOS</code></td>
<td>
<p>default FALSE; use <span class="pkg">polyclip</span> or <span class="pkg">gpclib</span> code even if <span class="pkg">rgeos</span> is available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatialPolygons object
</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+recenter-methods">recenter-methods</a></code>, <code><a href="maptools.html#topic+nowrapSpatialLines">nowrapSpatialLines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require(maps)) run &lt;- TRUE
## Not run: 
if (run) {
world &lt;- map("world", fill=TRUE, col="transparent", plot=FALSE)
worldSpP &lt;- map2SpatialPolygons(world, world$names, CRS("+proj=longlat +ellps=WGS84"))
worldSpP &lt;- worldSpP[-grep("Antarctica", row.names(worldSpP)),]
# incomplete polygons
worldSpP &lt;- worldSpP[-grep("Ghana", row.names(worldSpP)),]
# self-intersection mouth of Volta
worldSpP &lt;- worldSpP[-grep("UK:Great Britain", row.names(worldSpP)),]
# self-intersection Humber estuary
worldSpPr &lt;- recenter(worldSpP)
plot(worldSpPr)
title("Pacific view without polygon splitting")
}
if (run) {
worldSpPnr &lt;- nowrapRecenter(worldSpP)
plot(worldSpPnr)
title("Pacific view with polygon splitting")
}

## End(Not run)
if (!rgeosStatus()) run &lt;- FALSE
if (run) {
crds &lt;- matrix(c(-1, 1, 1, -1, 50, 50, 52, 52), ncol=2)
rcrds &lt;- rbind(crds, crds[1,])
SR &lt;- SpatialPolygons(list(Polygons(list(Polygon(rcrds)), ID="r1")),
 proj4string=CRS("+proj=longlat +ellps=WGS84"))
bbox(SR)
}
if (run) {
SRr &lt;- recenter(SR)
bbox(SRr)
}
if (run) {
SRnr &lt;- nowrapRecenter(SR)
bbox(SRnr)
}
</code></pre>

<hr>
<h2 id='nowrapSpatialLines'>Split SpatialLines components at offset</h2><span id='topic+nowrapSpatialLines'></span>

<h3>Description</h3>

<p>When recentering a world map, most often from the &quot;Atlantic&quot; view with longitudes with range -180 to 180, to the &quot;pacific&quot; view with longitudes with range 0 to 360, lines crossing the offset (0 for this conversion) get stretched horizonally. This function breaks Line objects at the offset (usually Greenwich), inserting a very small gap, and reassembling the Line objects created as Lines. The <span class="pkg">rgeos</span> package is required to use this function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nowrapSpatialLines(obj, offset = 0, eps = rep(.Machine$double.eps^(1/2.5), 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nowrapSpatialLines_+3A_obj">obj</code></td>
<td>
<p>A Spatial Lines object</p>
</td></tr>
<tr><td><code id="nowrapSpatialLines_+3A_offset">offset</code></td>
<td>
<p>default 0, untried for other values</p>
</td></tr>
<tr><td><code id="nowrapSpatialLines_+3A_eps">eps</code></td>
<td>
<p>vector of two fuzz values, both default 2.5 root of double.eps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spatial Lines object
</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+recenter-methods">recenter-methods</a></code>, <code><a href="maptools.html#topic+nowrapSpatialPolygons">nowrapSpatialPolygons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Sl &lt;- SpatialLines(list(Lines(list(Line(cbind(sin(seq(-4,4,0.4)),
 seq(1,21,1)))), "1")), proj4string=CRS("+proj=longlat +ellps=WGS84"))
summary(Sl)
if (require(rgeos)) {
nwSL &lt;- nowrapSpatialLines(Sl)
summary(nwSL)
if(require(maps)) {
worldmap &lt;- map("world", plot=FALSE)
worldmapLines &lt;- map2SpatialLines(worldmap, proj4string=CRS("+proj=longlat +datum=WGS84"))
bbox(worldmapLines)
t0 &lt;- nowrapSpatialLines(worldmapLines, offset=180)
bbox(t0)
}
}
</code></pre>

<hr>
<h2 id='pal2SpatialPolygons'>Making SpatialPolygons objects from RArcInfo input</h2><span id='topic+pal2SpatialPolygons'></span>

<h3>Description</h3>

<p>This function is used in making SpatialPolygons objects from RArcInfo input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pal2SpatialPolygons(arc, pal, IDs, dropPoly1=TRUE,
 proj4string=CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pal2SpatialPolygons_+3A_ids">IDs</code></td>
<td>
<p>Unique character ID values for each output Polygons object; the input IDs can be an integer or character vector with duplicates, where the duplicates will be combined as a single output Polygons object</p>
</td></tr>
<tr><td><code id="pal2SpatialPolygons_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>"CRS"</code>;
holding a valid proj4 string</p>
</td></tr>
<tr><td><code id="pal2SpatialPolygons_+3A_arc">arc</code></td>
<td>
<p>Object returned by <code>get.arcdata</code></p>
</td></tr>
<tr><td><code id="pal2SpatialPolygons_+3A_pal">pal</code></td>
<td>
<p>Object returned by <code>get.paldata</code></p>
</td></tr>
<tr><td><code id="pal2SpatialPolygons_+3A_droppoly1">dropPoly1</code></td>
<td>
<p>Should the first polygon in the AVC or e00 data be dropped; the first polygon is typically the compound boundary of the whole dataset, and can be detected by looking at the relative lengths of the list components in the second component of pal, which are the numbers of arcs making up the boundary of each polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return a SpatialPolygons object
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>Examples</h3>

<pre><code class='language-R'>nc1 &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1], ID="FIPS")
plot(nc1)
text(coordinates(nc1), labels=row.names(nc1), cex=0.6)
if(require(maps)){
ncmap &lt;- map("county", "north carolina", fill=TRUE, col="transparent",
 plot=FALSE)
IDs &lt;- sapply(strsplit(ncmap$names, "[,:]"), function(x) x[2])
nc2 &lt;- map2SpatialPolygons(ncmap, IDs)
plot(nc2)
text(coordinates(nc2), labels=row.names(nc2), cex=0.6)
}
#if(require(RArcInfo)) {
#td &lt;- tempdir()
#tmpcover &lt;- paste(td, "nc", sep="/")
#if (!file.exists(tmpcover)) e00toavc(system.file("share/co37_d90.e00",
# package="maptools")[1], tmpcover)
#arc &lt;- get.arcdata(td, "nc")
#pal &lt;- get.paldata(td, "nc")
#pat &lt;- get.tabledata(paste(td, "info", sep="/"), "NC.PAT")
#sapply(pal[[2]], function(x) length(x[[1]]))
#IDs &lt;- paste(pat$ST[-1], pat$CO[-1], sep="")
#nc3 &lt;- pal2SpatialPolygons(arc, pal, IDs=IDs)
#plot(nc3)
#text(coordinates(nc3), labels=row.names(nc3), cex=0.6)
#}
</code></pre>

<hr>
<h2 id='panel.pointLabel'>Label placement with spplot and lattice.</h2><span id='topic+panel.pointLabel'></span><span id='topic+sp.pointLabel'></span><span id='topic+sp.pointLabel-methods'></span><span id='topic+sp.pointLabel+2CSpatialPoints-method'></span>

<h3>Description</h3>

<p>Use optimization routines to find good locations for point labels
without overlaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.pointLabel(x, y = NULL,
                              labels = seq(along = x),
                              method = c("SANN", "GA"),
                              allowSmallOverlap = FALSE,
                              col = add.text$col,
                              alpha = add.text$alpha,
                              cex = add.text$cex,
                              lineheight = add.text$lineheight,
                              font = add.text$font,
                              fontfamily = add.text$fontfamily,
                              fontface = add.text$fontface,
                              fill='transparent',
                              ...)

sp.pointLabel(object, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.pointLabel_+3A_object">object</code></td>
<td>
<p>A <code>SpatialPoints</code> object.</p>
</td></tr>
<tr><td><code id="panel.pointLabel_+3A_x">x</code>, <code id="panel.pointLabel_+3A_y">y</code></td>
<td>
<p>coordinates for the point labels. See
<code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code> for details.</p>
</td></tr>
<tr><td><code id="panel.pointLabel_+3A_labels">labels</code></td>
<td>
<p>a character vector or expression.</p>
</td></tr>
<tr><td><code id="panel.pointLabel_+3A_method">method</code></td>
<td>
<p>the optimization method, either SANN for simulated
annealing (the default) or GA for a genetic algorithm.</p>
</td></tr>
<tr><td><code id="panel.pointLabel_+3A_allowsmalloverlap">allowSmallOverlap</code></td>
<td>
<p>logical; if TRUE, labels are allowed a small
overlap. The overlap allowed is 2% of the diagonal distance
of the plot area.</p>
</td></tr>
<tr><td><code id="panel.pointLabel_+3A_col">col</code>, <code id="panel.pointLabel_+3A_alpha">alpha</code>, <code id="panel.pointLabel_+3A_cex">cex</code>, <code id="panel.pointLabel_+3A_lineheight">lineheight</code>, <code id="panel.pointLabel_+3A_font">font</code>, <code id="panel.pointLabel_+3A_fontfamily">fontfamily</code>, <code id="panel.pointLabel_+3A_fontface">fontface</code>, <code id="panel.pointLabel_+3A_fill">fill</code></td>
<td>
<p>Graphical arguments. See gpar for details</p>
</td></tr>
<tr><td><code id="panel.pointLabel_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently not processed).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tom Short wrote <code><a href="car.html#topic+pointLabel">pointLabel</a></code> for <code>base</code>
graphics.  Oscar Perpiñán Lamigueiro modified this function for
<code>lattice</code> and <code>spplot</code>.</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spplot">spplot</a></code>

<code><a href="car.html#topic+pointLabel">pointLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 15
x &lt;- rnorm(n)*10
y &lt;- rnorm(n)*10
labels &lt;- as.character(round(x, 5))


myTheme &lt;- list(add.text=list(
                  cex=0.7,
                  col='midnightblue',
                  fontface=2,
                  fontfamily='mono'))
library(lattice)
xyplot(y~x,
       labels=labels,
       par.settings=myTheme, 
       panel=function(x, y, labels, ...){
         panel.xyplot(x, y, ...)
         panel.pointLabel(x, y, labels=labels, ...)
       })



data(meuse.grid)
coordinates(meuse.grid) = ~x+y
proj4string(meuse.grid) &lt;- CRS("+init=epsg:28992")
gridded(meuse.grid) = TRUE


pts &lt;- spsample(meuse.grid, n=15, type="random")

Rauthors &lt;- readLines(file.path(R.home("doc"), "AUTHORS"))[9:28]
someAuthors &lt;- Rauthors[seq_along(pts)]

sl1 &lt;- list('sp.points', pts, pch=19, cex=.8, col='midnightblue')
sl2 &lt;- list('sp.pointLabel', pts, label=someAuthors,
            cex=0.7, col='midnightblue',
            fontfamily='Palatino')
run &lt;- FALSE
if (require("RColorBrewer", quietly=TRUE)) run &lt;- TRUE
if (run) {
myCols &lt;- adjustcolor(colorRampPalette(brewer.pal(n=9, 'Reds'))(100), .85)
spplot(meuse.grid["dist"], col.regions=myCols, sp.layout=list(sl1, sl2))
}
</code></pre>

<hr>
<h2 id='pointLabel'> Label placement for points to avoid overlaps  </h2><span id='topic+pointLabel'></span>

<h3>Description</h3>

<p>Use optimization routines to find good locations for point labels
without overlaps. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointLabel(x, y = NULL, labels = seq(along = x), cex = 1,
           method = c("SANN", "GA"),
           allowSmallOverlap = FALSE,
           trace = FALSE,
           doPlot = TRUE,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointLabel_+3A_x">x</code>, <code id="pointLabel_+3A_y">y</code></td>
<td>
<p> as with <code>plot.default</code>, these provide the x and y coordinates for
the point labels.  Any reasonable way of defining the coordinates is
acceptable.  See the function <code>xy.coords</code> for details. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_labels">labels</code></td>
<td>
<p> as with <code>text</code>, a character vector or expression specifying the text to be
written.  An attempt is made to coerce other language objects
(names and calls) to expressions, and vectors and other
classed objects to character vectors by <code>as.character</code>. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_cex">cex</code></td>
<td>
<p> numeric character expansion factor as with <code>text</code>. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_method">method</code></td>
<td>
<p> the optimization method, either &ldquo;SANN&rdquo; for simulated
annealing (the default) or &ldquo;GA&rdquo; for a genetic algorithm. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_allowsmalloverlap">allowSmallOverlap</code></td>
<td>
<p> logical; if <code>TRUE</code>, labels are allowed
a small overlap. The overlap allowed is 2% of the diagonal
distance of the plot area.</p>
</td></tr>
<tr><td><code id="pointLabel_+3A_trace">trace</code></td>
<td>
<p> logical; if <code>TRUE</code>, status updates are given as the optimization algorithms
progress.</p>
</td></tr>
<tr><td><code id="pointLabel_+3A_doplot">doPlot</code></td>
<td>
<p> logical; if <code>TRUE</code>, the labels are plotted on the
existing graph with <code>text</code>.</p>
</td></tr>
<tr><td><code id="pointLabel_+3A_...">...</code></td>
<td>
<p> arguments passed along to <code>text</code> to specify
labeling parameters such as <code>col</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eight positions are candidates for label placement, either
horizontally, vertically, or diagonally offset from the points. The
default position for labels is the top right diagonal relative to the
point (considered the preferred label position). 
</p>
<p>With the default settings, simulating annealing solves faster than the
genetic algorithm. It is an open question as to which settles into a
global optimum the best (both algorithms have parameters that may be
tweaked).
</p>
<p>The label positioning problem is NP-hard (nondeterministic
polynomial-time hard). Placement becomes difficult and slows
considerably with large numbers of points. This function places all
labels, whether overlaps occur or not. Some placement algorithms
remove labels that overlap.
</p>
<p>Note that only <code>cex</code> is used to calculate string width and
height (using <code>strwidth</code> and <code>strheight</code>), so passing a
different font may corrupt the label dimensions. You could get around
this by adjusting the font parameters with <code>par</code> prior to running
this function.
</p>


<h3>Value</h3>

<p>An <code>xy</code> list giving the <code>x</code> and <code>y</code> positions of the
label as would be placed by <code>text(xy, labels)</code>.
</p>


<h3>Author(s)</h3>

<p> Tom Short, EPRI, <a href="mailto:tshort@epri.com">tshort@epri.com</a> </p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Automatic_label_placement">https://en.wikipedia.org/wiki/Automatic_label_placement</a>
</p>
<p><a href="https://i11www.iti.uni-karlsruhe.de/map-labeling/bibliography/">https://i11www.iti.uni-karlsruhe.de/map-labeling/bibliography/</a>
</p>
<p><a href="http://www.eecs.harvard.edu/~shieber/Projects/Carto/carto.html">http://www.eecs.harvard.edu/~shieber/Projects/Carto/carto.html</a>
</p>
<p><a href="http://www.szoraster.com/Cartography/PracticalExperience.htm">http://www.szoraster.com/Cartography/PracticalExperience.htm</a>
</p>
<p>The genetic algorithm code was adapted from the python code at 
</p>
<p><a href="https://meta.wikimedia.org/wiki/Map_generator">https://meta.wikimedia.org/wiki/Map_generator</a>.
</p>
<p>The simulated annealing code follows the algorithm and guidelines in:
</p>
<p>Jon Christensen, Joe Marks, and Stuart Shieber. Placing text labels on
maps and diagrams. In Paul Heckbert, editor, Graphics Gems IV, pages
497-504. Academic Press, Boston, MA, 1994.
<a href="http://www.eecs.harvard.edu/~shieber/Biblio/Papers/jc.label.pdf">http://www.eecs.harvard.edu/~shieber/Biblio/Papers/jc.label.pdf</a>
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+text">text</a></code>, <code><a href="plotrix.html#topic+thigmophobe.labels">thigmophobe.labels</a></code>
in package <span class="pkg">plotrix</span> </p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
x &lt;- rnorm(n)*10
y &lt;- rnorm(n)*10
plot(x, y, col = "red", pch = 20)
pointLabel(x, y, as.character(round(x,5)), offset = 0, cex = .7)

plot(x, y, col = "red", pch = 20)
pointLabel(x, y, expression(over(alpha, beta[123])), offset = 0, cex = .8)

</code></pre>

<hr>
<h2 id='ppp-class'>Virtual class &quot;ppp&quot; </h2><span id='topic+ppp-class'></span><span id='topic+owin-class'></span><span id='topic+im-class'></span><span id='topic+psp-class'></span>

<h3>Description</h3>

<p> Virtual S4 class definition for S3 classes in the spatstat package to allow S4-style coercion to these classes</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Author(s)</h3>

<p> Edzer J. Pebesma </p>

<hr>
<h2 id='readAsciiGrid'> read/write to/from (ESRI) asciigrid format </h2><span id='topic+readAsciiGrid'></span><span id='topic+writeAsciiGrid'></span>

<h3>Description</h3>

<p> read/write to/from ESRI asciigrid format; a fuzz factor has been added to <code>writeAsciiGrid</code> to force cell resolution to equality if the difference is less than the square root of machine precision</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
readAsciiGrid(fname, as.image = FALSE, plot.image = FALSE, 
 colname = basename(fname), proj4string = CRS(as.character(NA)), 
 dec=options()$OutDec)
writeAsciiGrid(x, fname, attr = 1, na.value = -9999, dec=options()$OutDec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readAsciiGrid_+3A_fname">fname</code></td>
<td>
<p> file name </p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_as.image">as.image</code></td>
<td>
<p>logical; if TRUE, a list is returned, ready to be
shown with the <code>image</code> command; if FALSE an object of
class <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a> is returned </p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_plot.image">plot.image</code></td>
<td>
<p>logical; if TRUE, an image of the map is plotted</p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_colname">colname</code></td>
<td>
<p>alternative name for data column if not file basename</p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_proj4string">proj4string</code></td>
<td>
<p>A CRS object setting the projection arguments of the Spatial Grid returned</p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_dec">dec</code></td>
<td>
<p>decimal point character.  This should be a character string containing just one single-byte character &mdash; see note below.</p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_x">x</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_attr">attr</code></td>
<td>
<p>attribute column; if missing, the first
column is taken; a name or a column number may be given</p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_na.value">na.value</code></td>
<td>
<p>numeric; value given to missing valued cells in the
resulting map</p>
</td></tr>
<tr><td><code id="readAsciiGrid_+3A_...">...</code></td>
<td>
<p> arguments passed to <a href="utils.html#topic+write.table">write.table</a>, which is used
to write the numeric data </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>readAsciiGrid</code> returns the grid map read; either as
an object of class <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a> or, if
as.image is TRUE, as list with components <code>x</code>, <code>y</code> and <code>z</code>.
</p>


<h3>Note</h3>

<p>In ArcGIS 8, it was not in general necessary to set the <code>dec</code> argument; it is not necessary in a mixed environment with ArcView 3.2 (R writes and ArcView reads &quot;.&quot;), but inter-operation with ArcGIS 9 requires care because the defaults used by ArcGIS seem to be misleading, and it may be necessary to override what appear to be platform defaults by setting the argument.</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, edzer.pebesma@uni-muenster.de</p>


<h3>See Also</h3>

 <p><code><a href="sp.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+image">image</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- readAsciiGrid(system.file("grids/test.ag", package="maptools")[1])
summary(x)
image(x)
xp &lt;- as(x, "SpatialPixelsDataFrame")
abline(h=332000, lwd=3)
xpS &lt;- xp[coordinates(xp)[,2] &lt; 332000,]
summary(xpS)
xS &lt;- as(xpS, "SpatialGridDataFrame")
summary(xS)
tmpfl &lt;- paste(tempdir(), "testS.ag", sep="/")
writeAsciiGrid(xS, tmpfl)
axS &lt;- readAsciiGrid(tmpfl)
opar &lt;- par(mfrow=c(1,2))
image(xS, main="before export")
image(axS, main="after import")
par(opar)
unlink(tmpfl)
</code></pre>

<hr>
<h2 id='readGPS'>GPSbabel read interface</h2><span id='topic+readGPS'></span>

<h3>Description</h3>

<p>The function reads a data frame from an attached GPS using the external program gpsbabel. The columns of the data frame need to be identified by hand because different GPS order NMEA data in different ways, and the columns should be converted to the correct classes by hand. Once the specifics of a particular GPS are identified, and ways of cleaning erroneous locations are found, the conversion of the output data frame into a usable one may be automated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readGPS(i = "garmin", f = "usb:", type="w", invisible=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readGPS_+3A_i">i</code></td>
<td>
<p>INTYPE: a supported file type, default &quot;garmin&quot;</p>
</td></tr>
<tr><td><code id="readGPS_+3A_f">f</code></td>
<td>
<p>INFILE: the appropriate device interface, default &quot;usb:&quot;, on Windows for serial interfaces commonly &quot;com4:&quot; or similar</p>
</td></tr>
<tr><td><code id="readGPS_+3A_type">type</code></td>
<td>
<p>&quot;w&quot; waypoints, or &quot;t&quot; track, or others provided in gpsbabel</p>
</td></tr>
<tr><td><code id="readGPS_+3A_invisible">invisible</code></td>
<td>
<p>Under Windows, do not open an extra window</p>
</td></tr>
<tr><td><code id="readGPS_+3A_...">...</code></td>
<td>
<p>arguments passed through to <code>read.table</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function just wraps: gpsbabel -i INTYPE -f INFILE -o tabsep -F - in system(), and reads the returned character vector of lines into a data frame. On some systems, INFILE may not be readable by ordinary users without extra configuration. The gpsbabel program must be present and on the user's PATH for the function to work. Typically, for a given GPS, the user will have to experiment first to find a set of data-cleaning tricks that work, but from then on they should be repeatable.
</p>


<h3>Value</h3>

<p>A data frame of waypoint values
</p>


<h3>Author(s)</h3>

<p>Patrick Giraudoux and Roger Bivand</p>


<h3>References</h3>

<p><a href="https://www.gpsbabel.org">https://www.gpsbabel.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#b1 &lt;- readGPS(f="usb:")
#str(b1)
#b2 &lt;- b1[1:172,]
#wp0 &lt;- b2[,c(2,3,4,8,9,19)]
#str(wp0)
#wp0$long &lt;- wp0$V9
#wp0$lat &lt;- as.numeric(as.character(wp0$V8))
#wp0$id &lt;- as.character(wp0$V2)
#wp0$alt &lt;- as.numeric(substring(as.character(wp0$V19), 1,
# (nchar(as.character(wp0$V19))-1)))
#wp0$time &lt;- as.POSIXct(strptime(paste(as.character(wp0$V3),
# as.character(wp0$V4)), format="%d-%b-%y %H:%M:%S"))
#str(wp0)
#wp1 &lt;- wp0[,-(1:6)]
#str(wp1)
#summary(wp1)

## End(Not run)
</code></pre>

<hr>
<h2 id='readShapeLines'>Read arc shape files into SpatialLinesDataFrame objects</h2><span id='topic+readShapeLines'></span><span id='topic+writeLinesShape'></span>

<h3>Description</h3>

<p>The use of this function is deprecated and it is not being maintained. Use <code>rgdal::readOGR()</code> or <code>sf::st_read()</code> instead - both of these read the coordinate reference system from the input file, while this deprecated function does not. For writing, use <code>rgdal::writeOGR()</code> or <code>sf::st_write()</code> instead.
</p>
<p>The <code>readShapeLines</code> function reads data from an arc/line shapefile into a <code>SpatialLinesDataFrame</code> object; the shapefile may be of type polygon, but for just plotting for example coastlines, a SpatialLines object is sufficient. The <code>writeLinesShape</code> function writes data from a <code>SpatialLinesDataFrame</code> object to a shapefile. Note DBF file restrictions in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readShapeLines(fn, proj4string=CRS(as.character(NA)), verbose=FALSE,
 repair=FALSE, delete_null_obj=FALSE)
writeLinesShape(x, fn, factor2char = TRUE, max_nchar=254)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readShapeLines_+3A_fn">fn</code></td>
<td>
<p>shapefile layer name, when writing omitting the extensions *.shp, *.shx and *.dbf, which are added in the function</p>
</td></tr>
<tr><td><code id="readShapeLines_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>CRS</code>; holding a valid proj4 string</p>
</td></tr>
<tr><td><code id="readShapeLines_+3A_verbose">verbose</code></td>
<td>
<p>default FALSE - report type of shapefile and number of shapes</p>
</td></tr>
<tr><td><code id="readShapeLines_+3A_repair">repair</code></td>
<td>
<p>default FALSE: some shapefiles provided by Geolytics Inc. have values of object sizes stored in the *.shx index file that are eight bytes too large, leading the function to try to read past the end of file. If repair=TRUE, an attempt is made to repair the internal values, permitting such files to be read.</p>
</td></tr>
<tr><td><code id="readShapeLines_+3A_delete_null_obj">delete_null_obj</code></td>
<td>
<p>if TRUE, null geometries will be removed together with their data.frame rows</p>
</td></tr>
<tr><td><code id="readShapeLines_+3A_x">x</code></td>
<td>
<p>a <code>SpatialLinesDataFrame</code> object</p>
</td></tr>
<tr><td><code id="readShapeLines_+3A_factor2char">factor2char</code></td>
<td>
<p>logical, default TRUE, convert factor columns to character</p>
</td></tr>
<tr><td><code id="readShapeLines_+3A_max_nchar">max_nchar</code></td>
<td>
<p>default 254, may be set to a higher limit and passed through to the DBF writer, please see Details in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shpID values of the shapefile will be used as <code>Lines</code> ID values; when writing shapefiles, the object data slot row.names are added to the DBF file as column SL_ID.</p>


<h3>Value</h3>

<p>a SpatialLinesDataFrame object
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>See Also</h3>

<p><code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- readShapeLines(system.file("shapes/fylk-val.shp", package="maptools")[1],
 proj4string=CRS("+proj=utm +zone=33 +datum=WGS84"))
plot(xx, col="blue")
summary(xx)
xxx &lt;- xx[xx$LENGTH &gt; 30000,]
plot(xxx, col="red", add=TRUE)
tmpfl &lt;- paste(tempdir(), "xxline", sep="/")
writeLinesShape(xxx, tmpfl)
getinfo.shape(paste(tmpfl, ".shp", sep=""))
axx &lt;- readShapeLines(tmpfl, proj4string=CRS("+proj=utm +zone=33 +datum=WGS84"))
plot(xxx, col="black", lwd=4)
plot(axx, col="yellow", lwd=1, add=TRUE)
unlink(paste(tmpfl, ".*", sep=""))
xx &lt;- readShapeLines(system.file("shapes/sids.shp", package="maptools")[1],
 proj4string=CRS("+proj=longlat +datum=NAD27"))
plot(xx, col="blue")
</code></pre>

<hr>
<h2 id='readShapePoints'>Read points shape files into SpatialPointsDataFrame objects</h2><span id='topic+readShapePoints'></span><span id='topic+writePointsShape'></span>

<h3>Description</h3>

<p>The use of this function is deprecated and it is not being maintained. Use <code>rgdal::readOGR()</code> or <code>sf::st_read()</code> instead - both of these read the coordinate reference system from the input file, while this deprecated function does not.For writing, use <code>rgdal::writeOGR()</code> or <code>sf::st_write()</code> instead.
</p>
<p>The <code>readShapePoints</code> reads data from a points shapefile into a <code>SpatialPointsDataFrame</code> object. The <code>writePointsShape</code> function writes data from a <code>SpatialPointsDataFrame</code> object to a shapefile. Both reading and writing can be carried out for 2D and 3D point coordinates. Note DBF file restrictions in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readShapePoints(fn, proj4string = CRS(as.character(NA)), verbose = FALSE,
 repair=FALSE)
writePointsShape(x, fn, factor2char = TRUE, max_nchar=254)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readShapePoints_+3A_fn">fn</code></td>
<td>
<p>shapefile layer name, when writing omitting the extensions *.shp, *.shx and *.dbf, which are added in the function</p>
</td></tr>
<tr><td><code id="readShapePoints_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>CRS</code>; holding a valid proj4 string</p>
</td></tr>
<tr><td><code id="readShapePoints_+3A_verbose">verbose</code></td>
<td>
<p>default FALSE - report type of shapefile and number of shapes</p>
</td></tr>
<tr><td><code id="readShapePoints_+3A_repair">repair</code></td>
<td>
<p>default FALSE: some shapefiles provided by Geolytics Inc. have values of object sizes stored in the *.shx index file that are eight bytes too large, leading the function to try to read past the end of file. If repair=TRUE, an attempt is made to repair the internal values, permitting such files to be read.</p>
</td></tr>
<tr><td><code id="readShapePoints_+3A_x">x</code></td>
<td>
<p>a <code>SpatialPointsDataFrame</code> object</p>
</td></tr>
<tr><td><code id="readShapePoints_+3A_factor2char">factor2char</code></td>
<td>
<p>logical, default TRUE, convert factor columns to character</p>
</td></tr>
<tr><td><code id="readShapePoints_+3A_max_nchar">max_nchar</code></td>
<td>
<p>default 254, may be set to a higher limit and passed through to the DBF writer, please see Details in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPointsDataFrame object
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>See Also</h3>

<p><code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(maptools)
xx &lt;- readShapePoints(system.file("shapes/baltim.shp", package="maptools")[1])
plot(xx)
summary(xx)
xxx &lt;- xx[xx$PRICE &lt; 40,]
tmpfl &lt;- paste(tempdir(), "xxpts", sep="/")
writePointsShape(xxx, tmpfl)
getinfo.shape(paste(tmpfl, ".shp", sep=""))
axx &lt;- readShapePoints(tmpfl)
plot(axx, col="red", add=TRUE)
unlink(paste(tmpfl, ".*", sep=""))
xx &lt;- readShapePoints(system.file("shapes/pointZ.shp", package="maptools")[1])
dimensions(xx)
plot(xx)
summary(xx)
</code></pre>

<hr>
<h2 id='readShapePoly'>Read polygon shape files into SpatialPolygonsDataFrame objects</h2><span id='topic+readShapePoly'></span><span id='topic+writePolyShape'></span>

<h3>Description</h3>

<p>The use of this function is deprecated and it is not being maintained. Use <code>rgdal::readOGR()</code> or <code>sf::st_read()</code> instead - both of these read the coordinate reference system from the input file, while this deprecated function does not.For writing, use <code>rgdal::writeOGR()</code> or <code>sf::st_write()</code> instead.
</p>
<p>The <code>readShapePoly</code> reads data from a polygon shapefile into a <code>SpatialPolygonsDataFrame</code> object. The <code>writePolyShape</code> function writes data from a <code>SpatialPolygonsDataFrame</code> object to a shapefile. Note DBF file restrictions in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readShapePoly(fn, IDvar=NULL, proj4string=CRS(as.character(NA)),
 verbose=FALSE, repair=FALSE, force_ring=FALSE, delete_null_obj=FALSE,
 retrieve_ABS_null=FALSE)
writePolyShape(x, fn, factor2char = TRUE, max_nchar=254)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readShapePoly_+3A_fn">fn</code></td>
<td>
<p>shapefile layer name, when writing omitting the extensions *.shp, *.shx and *.dbf, which are added in the function</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_idvar">IDvar</code></td>
<td>
<p>a character string: the name of a column in the shapefile DBF containing the ID values of the shapes - the values will be converted to a character vector</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>CRS</code>; holding a valid proj4 string</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_verbose">verbose</code></td>
<td>
<p>default FALSE - report type of shapefile and number of shapes</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_repair">repair</code></td>
<td>
<p>default FALSE: some shapefiles provided by Geolytics Inc. have values of object sizes stored in the *.shx index file that are eight bytes too large, leading the function to try to read past the end of file. If repair=TRUE, an attempt is made to repair the internal values, permitting such files to be read.</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_force_ring">force_ring</code></td>
<td>
<p>if TRUE, close unclosed input rings</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_delete_null_obj">delete_null_obj</code></td>
<td>
<p>if TRUE, null geometries will be removed together with their data.frame rows</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_retrieve_abs_null">retrieve_ABS_null</code></td>
<td>
<p>default FALSE, if TRUE and delete_null_obj also 
TRUE, the function will return a data frame containing the data from any 
null geometries inserted by ABS</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_x">x</code></td>
<td>
<p>a <code>SpatialPolygonsDataFrame</code> object</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_factor2char">factor2char</code></td>
<td>
<p>logical, default TRUE, convert factor columns to character</p>
</td></tr>
<tr><td><code id="readShapePoly_+3A_max_nchar">max_nchar</code></td>
<td>
<p>default 254, may be set to a higher limit and passed through to the DBF writer, please see Details in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no IDvar argument is given, the shpID values of the shapefile will be used as <code>Polygons</code> ID values; when writing shapefiles, the object data slot row.names are added to the DBF file as column SP_ID.</p>


<h3>Value</h3>

<p>a SpatialPolygonsDataFrame object
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>See Also</h3>

<p><code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(maptools)
xx &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
 IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
plot(xx, border="blue", axes=TRUE, las=1)
text(coordinates(xx), labels=row.names(xx), cex=0.6)
as(xx, "data.frame")[1:5, 1:6]
xxx &lt;- xx[xx$SID74 &lt; 2,]
plot(xxx, border="red", add=TRUE)
tmpfl &lt;- paste(tempdir(), "xxpoly", sep="/")
writePolyShape(xxx, tmpfl)
getinfo.shape(paste(tmpfl, ".shp", sep=""))
axx &lt;- readShapePoly(tmpfl, proj4string=CRS("+proj=longlat +ellps=clrk66"))
plot(xxx, border="black", lwd=4)
plot(axx, border="yellow", lwd=1, add=TRUE)
unlink(paste(tmpfl, ".*", sep=""))
</code></pre>

<hr>
<h2 id='readShapeSpatial'>Read shape files into Spatial*DataFrame objects</h2><span id='topic+readShapeSpatial'></span><span id='topic+writeSpatialShape'></span>

<h3>Description</h3>

<p>The use of this function is deprecated and it is not being maintained. Use <code>rgdal::readOGR()</code> or <code>sf::st_read()</code> instead - both of these read the coordinate reference system from the input file, while this deprecated function does not. For writing, use <code>rgdal::writeOGR()</code> or <code>sf::st_write()</code> instead.
</p>
<p>The <code>readShapeSpatial</code> reads data from a shapefile into a <code>Spatial*DataFrame</code> object. The <code>writeSpatialShape</code> function writes data from a <code>Spatial*DataFrame</code> object to a shapefile. Note DBF file restrictions in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readShapeSpatial(fn, proj4string=CRS(as.character(NA)), 
	verbose=FALSE, repair=FALSE, IDvar=NULL, force_ring=FALSE, 
	delete_null_obj=FALSE, retrieve_ABS_null=FALSE)
writeSpatialShape(x, fn, factor2char = TRUE, max_nchar=254)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readShapeSpatial_+3A_fn">fn</code></td>
<td>
<p>shapefile layer name, when writing omitting the extensions *.shp, *.shx and *.dbf, which are added in the function</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>CRS</code>; holding a valid proj4 string</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_verbose">verbose</code></td>
<td>
<p>default FALSE - report type of shapefile and number of shapes</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_repair">repair</code></td>
<td>
<p>default FALSE: some shapefiles provided by Geolytics Inc. have values of object sizes stored in the *.shx index file that are eight bytes too large, leading the function to try to read past the end of file. If repair=TRUE, an attempt is made to repair the internal values, permitting such files to be read.</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_idvar">IDvar</code></td>
<td>
<p>a character string: the name of a column in the shapefile DBF containing the ID values of the shapes - the values will be converted to a character vector (Polygons only)</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_force_ring">force_ring</code></td>
<td>
<p>if TRUE, close unclosed input rings (Polygons only)</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_delete_null_obj">delete_null_obj</code></td>
<td>
<p>if TRUE, null geometries inserted by ABS will be removed together with their data.frame rows (Polygons and Lines)</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_retrieve_abs_null">retrieve_ABS_null</code></td>
<td>
<p>default FALSE, if TRUE and delete_null_obj also 
TRUE, the function will return a data frame containing the data from any 
null geometries inserted by ABS (Polygons only)</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_x">x</code></td>
<td>
<p>a vector data <code>Spatial*DataFrame</code> object</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_factor2char">factor2char</code></td>
<td>
<p>logical, default TRUE, convert factor columns to character</p>
</td></tr>
<tr><td><code id="readShapeSpatial_+3A_max_nchar">max_nchar</code></td>
<td>
<p>default 254, may be set to a higher limit and passed through to the DBF writer, please see Details in <code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no IDvar argument is given, the shpID values of the shapefile will be used as <code>Polygons</code> ID values; when writing shapefiles, the object data slot row.names are added to the DBF file as column SP_ID.</p>


<h3>Value</h3>

<p>a Spatial*DataFrame object of a class corresponding to the input shapefile
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>See Also</h3>

<p><code><a href="foreign.html#topic+write.dbf">write.dbf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(maptools)
xx &lt;- readShapeSpatial(system.file("shapes/sids.shp", package="maptools")[1],
 IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
summary(xx)
xxx &lt;- xx[xx$SID74 &lt; 2,]
tmpfl &lt;- paste(tempdir(), "xxpoly", sep="/")
writeSpatialShape(xxx, tmpfl)
getinfo.shape(paste(tmpfl, ".shp", sep=""))
unlink(paste(tmpfl, ".*", sep=""))
xx &lt;- readShapeSpatial(system.file("shapes/fylk-val.shp",
 package="maptools")[1], proj4string=CRS("+proj=utm +zone=33 +datum=WGS84"))
summary(xx)
xxx &lt;- xx[xx$LENGTH &gt; 30000,]
plot(xxx, col="red", add=TRUE)
tmpfl &lt;- paste(tempdir(), "xxline", sep="/")
writeSpatialShape(xxx, tmpfl)
getinfo.shape(paste(tmpfl, ".shp", sep=""))
unlink(paste(tmpfl, ".*", sep=""))
xx &lt;- readShapeSpatial(system.file("shapes/baltim.shp", package="maptools")[1])
summary(xx)
xxx &lt;- xx[xx$PRICE &lt; 40,]
tmpfl &lt;- paste(tempdir(), "xxpts", sep="/")
writeSpatialShape(xxx, tmpfl)
getinfo.shape(paste(tmpfl, ".shp", sep=""))
unlink(paste(tmpfl, ".*", sep=""))
</code></pre>

<hr>
<h2 id='readSplus'>Read exported WinBUGS maps</h2><span id='topic+readSplus'></span>

<h3>Description</h3>

<p>The function permits an exported WinBUGS map to be read into an <span class="pkg">sp</span> package class <code>SpatialPolygons</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSplus(file, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSplus_+3A_file">file</code></td>
<td>
<p>name of file</p>
</td></tr>
<tr><td><code id="readSplus_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class '&quot;CRS&quot;'; holding a valid proj4 string</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>readSplus</code> returns a SpatialPolygons object
</p>


<h3>Note</h3>

<p>In the example, taken from the GeoBUGS manual, the smaller part of area1 has a counter-clockwise ring direction in the data, while other rings are clockwise. This implies that it is a hole, and does not get filled. Errant holes may be filled using <code><a href="maptools.html#topic+checkPolygonsHoles">checkPolygonsHoles</a></code>. The region labels are stored in the <code>ID</code> slots of the <code>Polygons</code> objects.</p>


<h3>Author(s)</h3>

<p>Virgilio Gomez Rubio &lt;Virgilio.Gomez@uclm.es&gt;</p>


<h3>References</h3>

<p><a href="http://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf">http://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf</a></p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+map2SpatialPolygons">map2SpatialPolygons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rgeosStatus()) {
geobugs &lt;- readSplus(system.file("share/Splus.map", package="maptools"))
plot(geobugs, axes=TRUE, col=1:3)
row.names(geobugs)
pls &lt;- slot(geobugs, "polygons")
sapply(pls, function(i) sapply(slot(i, "Polygons"), slot, "hole"))
pls1 &lt;- lapply(pls, checkPolygonsHoles)
sapply(pls1, function(i) sapply(slot(i, "Polygons"), slot, "hole"))
plot(SpatialPolygons(pls1), axes=TRUE, col=1:3)
}
</code></pre>

<hr>
<h2 id='Rgshhs'>Read GSHHS data into sp object</h2><span id='topic+Rgshhs'></span><span id='topic+getRgshhsMap'></span>

<h3>Description</h3>

<p>If the data are polygon data, the function will read GSHHS polygons into SpatialPolygons object for a chosen region, using binary shorelines from Global Self-consistant Hierarchical High-resolution (Shorelines) Geography, release 2.3.0 of February 1, 2014 (<a href="http://www.soest.hawaii.edu/pwessel/gshhg/gshhg-bin-2.3.0.zip">http://www.soest.hawaii.edu/pwessel/gshhg/gshhg-bin-2.3.0.zip</a>). 
</p>
<p>The <code>getRgshhsMap</code> function calls <code>Rgshhs</code> internally to simplify the interface by returning only a SpatialPolygons object rather than a more complex list, and by calling <code>Rgshhs</code> twice either side of longitude 0 degrees for values of &ldquo;xlim&rdquo; straddling 0, then merging the polygons retrieved.
</p>
<p>If the data are line data, the borders or river lines will be read into a SpatialLines object. The data are provided in integer form as millionths of decimal degrees. Reading of much earlier versions of the GSHHS binary files will fail with an error message. The netCDF GSHHS files distributed with GMT &gt;= 4.2 cannot be read as they are in a very different format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rgshhs(fn, xlim = NULL, ylim = NULL, level = 4, minarea = 0, shift = FALSE, 
verbose = TRUE, no.clip = FALSE, properly=FALSE, avoidGEOS=FALSE, 
checkPolygons=FALSE)
getRgshhsMap(fn = system.file("share/gshhs_c.b", package= "maptools"),
 xlim, ylim, level = 1, shift = TRUE, verbose = TRUE, no.clip = FALSE,
 properly=FALSE, avoidGEOS=FALSE, checkPolygons=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rgshhs_+3A_fn">fn</code></td>
<td>
<p>filename or full path to GSHHS 2.3.0 file to be read</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_xlim">xlim</code></td>
<td>
<p>longitude limits within 0-360 in most cases, negative longitudes are also found east of the Atlantic, but the Americas are recorded as positive values</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_ylim">ylim</code></td>
<td>
<p>latitude limits</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_level">level</code></td>
<td>
<p>maximum GSHHS level to include, defaults to 4 (everything), setting 1 will only retrieve land, no lakes</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_minarea">minarea</code></td>
<td>
<p>minimum area in square km to retrieve, default 0</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_shift">shift</code></td>
<td>
<p>default FALSE, can be used to shift longitudes &gt; 180 degrees to below zero, beware of artefacts involving unhandled polygon splitting at 180 degrees</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_verbose">verbose</code></td>
<td>
<p>default TRUE, print progress reports</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_no.clip">no.clip</code></td>
<td>
<p>default FALSE, if TRUE, do not clip output polygons to bounding box</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_properly">properly</code></td>
<td>
<p>default FALSE, if TRUE use <code><a href="rgeos.html#topic+gContainsProperly">gContainsProperly</a></code> rather than <code><a href="rgeos.html#topic+gContains">gContains</a></code>, here FALSE because clip rectangle touches clipped objects, so they are not properly contained</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_avoidgeos">avoidGEOS</code></td>
<td>
<p>default FALSE; if TRUE force use of <span class="pkg">gpclib</span> even when <span class="pkg">rgeos</span> is available</p>
</td></tr>
<tr><td><code id="Rgshhs_+3A_checkpolygons">checkPolygons</code></td>
<td>
<p>default FALSE, if TRUE, check using GEOS, which may re-order the member Polygon objects with respect to the returned polydata data frame rows</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package is distributed with the coarse version of the shoreline data, and much more detailed versions may be downloaded from the referenced websites. The data is of high quality, matching the accuracy of SRTM shorelines for the full dataset (but not for inland waterbodies). In general, users will construct study region SpatialPolygons objects, which can then be exported (for example as a shapefile), or used in other R packages (such as PBSmapping). The largest land polygons take considerable time to clip to the study region, certainly many minutes for an extract from the full resolution data file including Eurasia (with Africa) or the Americas. For this reason, do not give up if nothing seems to be happening after the (verbose) message: &quot;Rgshhs: clipping &lt;m&gt; of &lt;n&gt; polygons ...&quot; appears. Clipping the largest polygons in full resolution also needs a good deal of memory.
</p>


<h3>Value</h3>

<p>for polygon data, a list with the following components:
</p>
<table>
<tr><td><code>polydata</code></td>
<td>
<p>data from the headers of the selected GSHHS polygons</p>
</td></tr>
<tr><td><code>belongs</code></td>
<td>
<p>a matrix showing which polygon belongs to (is included in) which polygon, going from the highest level among the selected polygons down to 1 (land); levels are: 1 land, 2 lake, 3 island_in_lake, 4 pond_in_island_in_lake.</p>
</td></tr>
<tr><td><code>new_belongs</code></td>
<td>
<p>a ragged list of polygon inclusion used for making SP</p>
</td></tr>
<tr><td><code>SP</code></td>
<td>
<p>a SpatialPolygons object; this is the principal output object, and will become the only output object as the package matures</p>
</td></tr>
</table>
<p>the <code>getRgshhsMap</code> returns only a SpatialPolygons object;
for line data, a list with the following component:
</p>
<table>
<tr><td><code>SP</code></td>
<td>
<p>a SpatialLines object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A number of steps are taken in this implementation that are unexpected, print messages, and so require explanation. Following the extraction of polygons intersecting the required region, a check is made to see if Antarctica is present. If it is, a new southern border is imposed at the southern ylim value or -90 if no ylim value is given. When clipping polygons seeming to intersect the required region boundary, it can happen that no polygon is left within the region (for example when the boundaries are overlaid, but also because the min/max polygon values in the header may not agree with the polygon itself (one case observed for a lake west of Groningen). The function then reports a null polygon. Another problem occurs when closed polygons are cut up during the finding of intersections between polygons and the required region boundary. 
</p>
<p>By default, if the rgeos package is available, it is used for topology operations. If it is not available, the gpclib package may be used. Please also note that gpclib has a restricted licence.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>References</h3>

<p><a href="http://www.soest.hawaii.edu/pwessel/gshhg/">http://www.soest.hawaii.edu/pwessel/gshhg/</a>, <a href="http://www.soest.hawaii.edu/pwessel/gshhg/gshhg-bin-2.3.0.zip">http://www.soest.hawaii.edu/pwessel/gshhg/gshhg-bin-2.3.0.zip</a>; Wessel, P., and W. H. F. Smith, A Global Self-consistent, Hierarchical, High-resolution Shoreline Database, J. Geophys. Res., 101, 8741-8743, 1996.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rgeosStatus()) {
gshhs.c.b &lt;- system.file("share/gshhs_c.b", package="maptools")
WEx &lt;- c(-12, 3)
WEy &lt;- c(48, 59)
WE &lt;- getRgshhsMap(gshhs.c.b, xlim=WEx, ylim=WEy)
plot(WE, col="khaki", xlim=WEx, ylim=WEy, xaxs="i", yaxs="i", axes=TRUE)
NZx &lt;- c(160,180)
NZy &lt;- c(-50,-30)
NZ &lt;- Rgshhs(gshhs.c.b, xlim=NZx, ylim=NZy)
plot(NZ$SP, col="khaki", pbg="azure2", xlim=NZx, ylim=NZy, xaxs="i", yaxs="i", axes=TRUE)
GLx &lt;- c(265,285)
GLy &lt;- c(40,50)
GL &lt;- Rgshhs(gshhs.c.b, xlim=GLx, ylim=GLy)
plot(GL$SP, col="khaki", pbg="azure2", xlim=GLx, ylim=GLy, xaxs="i", yaxs="i", axes=TRUE)
BNLx &lt;- c(2,8)
BNLy &lt;- c(49,54)
wdb_lines &lt;- system.file("share/wdb_borders_c.b", package="maptools")
BNLp &lt;- Rgshhs(gshhs.c.b, xlim=BNLx, ylim=BNLy)
BNLl &lt;- Rgshhs(wdb_lines, xlim=BNLx, ylim=BNLy)
plot(BNLp$SP, col="khaki", pbg="azure2", xlim=BNLx, ylim=BNLy, xaxs="i", yaxs="i", axes=TRUE)
lines(BNLl$SP)
xlims &lt;- c(0,360)
ylims &lt;- c(-90,90)
world &lt;- Rgshhs(gshhs.c.b, xlim=xlims, ylim=ylims, level=1, checkPolygons=TRUE)
}
</code></pre>

<hr>
<h2 id='snapPointsToLines'>
Snap a set of points to a set of lines
</h2><span id='topic+snapPointsToLines'></span>

<h3>Description</h3>

<p>This function snaps a set of points to a set of lines based on the minimum 
distance of each point to any of the lines. This function does not work with 
geographic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snapPointsToLines(points, lines, maxDist=NA, withAttrs = TRUE, idField=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snapPointsToLines_+3A_points">points</code></td>
<td>

<p>An object of the class SpatialPoints or SpatialPointsDataFrame.
</p>
</td></tr>
<tr><td><code id="snapPointsToLines_+3A_lines">lines</code></td>
<td>

<p>An object of the class SpatialLines or SpatialLinesDataFrame.
</p>
</td></tr>
<tr><td><code id="snapPointsToLines_+3A_maxdist">maxDist</code></td>
<td>

<p>Numeric value for establishing a maximum distance to avoid snapping points that 
are farther apart; its default value is NA.
</p>
</td></tr>
<tr><td><code id="snapPointsToLines_+3A_withattrs">withAttrs</code></td>
<td>

<p>Boolean value for preserving (TRUE) or getting rid (FALSE) of the original point 
attributes. Default: TRUE. This parameter is optional. 
</p>
</td></tr>
<tr><td><code id="snapPointsToLines_+3A_idfield">idField</code></td>
<td>

<p>A string specifying the field which contains each line's id. This id will 
be transferred to the snapped points data set to distinguish the line which each
point was snapped to.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatialPointsDataFrame object as defined by the R package 'sp'. This object 
contains the snapped points, therefore all of them lie on the lines.
</p>


<h3>Author(s)</h3>

<p>German Carrillo and Ethan Plunkett
</p>


<h3>See Also</h3>

<p><code><a href="maptools.html#topic+nearestPointOnSegment">nearestPointOnSegment</a></code>, <code><a href="maptools.html#topic+nearestPointOnLine">nearestPointOnLine</a></code>, 
<code><a href="car.html#topic+sp">sp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From the sp vignette
l1 = cbind(c(1,2,3),c(3,2,2))
l1a = cbind(l1[,1]+.05,l1[,2]+.05)
l2 = cbind(c(1,2,3),c(1,1.5,1))
Sl1 = Line(l1)
Sl1a = Line(l1a)
Sl2 = Line(l2)
S1 = Lines(list(Sl1, Sl1a), ID="a")
S2 = Lines(list(Sl2), ID="b")
Sl = SpatialLines(list(S1,S2))
df = data.frame(z = c(1,2), row.names=sapply(slot(Sl, "lines"), function(x) slot(x, "ID")))
Sldf = SpatialLinesDataFrame(Sl, data = df)

xc = c(1.2,1.5,2.5)
yc = c(1.5,2.2,1.6)
Spoints = SpatialPoints(cbind(xc, yc))

if (rgeosStatus()) snapPointsToLines(Spoints, Sldf, maxDist=0.4)
</code></pre>

<hr>
<h2 id='sp2Mondrian'>write map data for Mondrian</h2><span id='topic+sp2Mondrian'></span>

<h3>Description</h3>

<p>The function outputs a SpatialPolygonsDataFrame object to be used by Mondrian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2Mondrian(SP, file, new_format=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp2Mondrian_+3A_sp">SP</code></td>
<td>
<p>a SpatialPolygonsDataFrame object</p>
</td></tr>
<tr><td><code id="sp2Mondrian_+3A_file">file</code></td>
<td>
<p>file where output is written</p>
</td></tr>
<tr><td><code id="sp2Mondrian_+3A_new_format">new_format</code></td>
<td>
<p>default TRUE, creates a text data file and a separate map file; the old format put both data sets in a single file - the map file is named by inserting &quot;MAP_&quot; into the file= argument after the rightmost directory separator (if any)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>At this release, the function writes out a text file with both data and polygon(s) identified as belonging to each row of data.
</p>


<h3>Author(s)</h3>

<p>Patrick Hausmann and Roger Bivand</p>


<h3>References</h3>

<p><a href="http://www.theusrus.de/Mondrian/">http://www.theusrus.de/Mondrian/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
td &lt;- tempdir()
xx &lt;- readShapePoly(system.file("shapes/columbus.shp", package="maptools")[1])
sp2Mondrian(xx, file=file.path(td, "columbus1.txt"))
xx &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1])
sp2Mondrian(xx, file=file.path(td, "sids1.txt"))

## End(Not run)
</code></pre>

<hr>
<h2 id='sp2tmap'>Convert SpatialPolygons object for Stata tmap command</h2><span id='topic+sp2tmap'></span>

<h3>Description</h3>

<p>The function converts a SpatialPolygons object for use with the Stata tmap command, by creating a data frame with the required columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2tmap(SP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp2tmap_+3A_sp">SP</code></td>
<td>
<p>a SpatialPolygons object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with three columns:
</p>
<table>
<tr><td><code>_ID</code></td>
<td>
<p>an integer vector of polygon identifiers in numeric order</p>
</td></tr>
<tr><td><code>_X</code></td>
<td>
<p>numeric x coordinate</p>
</td></tr>
<tr><td><code>_Y</code></td>
<td>
<p>numeric y coordinate</p>
</td></tr>
</table>
<p>and an <code>ID_n</code> attribute with the named polygon identifiers
</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>References</h3>

<p><a href="https://www.stata.com/search.cgi?query=tmap">https://www.stata.com/search.cgi?query=tmap</a></p>


<h3>See Also</h3>

<p><code><a href="foreign.html#topic+write.dta">write.dta</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xx &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
 IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
plot(xx, border="blue", axes=TRUE, las=1)
tmapdf &lt;- sp2tmap(as(xx, "SpatialPolygons"))
if (require(foreign)) {
td &lt;- tempdir()
write.dta(tmapdf, file=file.path(td, "NCmap.dta"), version=7)
NCdf &lt;- as(xx, "data.frame")
NCdf$ID_n &lt;- attr(tmapdf, "ID_names")
write.dta(NCdf, file=file.path(td, "NC.dta"), version=7)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='sp2WB'>Export SpatialPolygons object as S-Plus map for WinBUGS</h2><span id='topic+sp2WB'></span>

<h3>Description</h3>

<p>The function exports an sp SpatialPolygons object into a S-Plus map
format to be import by WinBUGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2WB(map, filename, Xscale = 1, Yscale = Xscale, plotorder = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp2WB_+3A_map">map</code></td>
<td>
<p>a SpatialPolygons object</p>
</td></tr>
<tr><td><code id="sp2WB_+3A_filename">filename</code></td>
<td>
<p>file where output is written</p>
</td></tr>
<tr><td><code id="sp2WB_+3A_xscale">Xscale</code>, <code id="sp2WB_+3A_yscale">Yscale</code></td>
<td>
<p>scales to be written in the output file</p>
</td></tr>
<tr><td><code id="sp2WB_+3A_plotorder">plotorder</code></td>
<td>
<p>default=FALSE, if TRUE, export polygons in plotting order</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Virgilio GÃ³mez Rubio, partly derived from earlier code by Thomas Jagger</p>


<h3>References</h3>

<p><a href="http://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf">http://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
 IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
plot(xx, border="blue", axes=TRUE, las=1)
tf &lt;- tempfile()
sp2WB(as(xx, "SpatialPolygons"), filename=tf)
xxx &lt;- readSplus(tf, proj4string=CRS("+proj=longlat +ellps=clrk66"))
all.equal(xxx, as(xx, "SpatialPolygons"), tolerance=.Machine$double.eps^(1/4),
 check.attributes=FALSE)
## Not run: 
x &lt;- readAsciiGrid(system.file("grids/test.ag", package="maptools")[1])
xp &lt;- as(x, "SpatialPixelsDataFrame")
pp &lt;- as(xp, "SpatialPolygons")
td &lt;- tempdir()
sp2WB(pp, filename=file.path(td, "test.map"))

## End(Not run)
</code></pre>

<hr>
<h2 id='SpatialLines2PolySet'>Convert sp line and polygon objects to PBSmapping PolySet objects</h2><span id='topic+SpatialLines2PolySet'></span><span id='topic+SpatialPolygons2PolySet'></span><span id='topic+PolySet2SpatialPolygons'></span><span id='topic+PolySet2SpatialLines'></span>

<h3>Description</h3>

<p>Functions <code>SpatialLines2PolySet</code> and <code>SpatialPolygons2PolySet</code> convert objects of sp classes to <code>PolySet</code> class objects as defined in the PBSmapping package, and <code>PolySet2SpatialLines</code> and <code>PolySet2SpatialPolygons</code> convert in the opposite direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialLines2PolySet(SL)
SpatialPolygons2PolySet(SpP)
PolySet2SpatialLines(PS)
PolySet2SpatialPolygons(PS, close_polys=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialLines2PolySet_+3A_sl">SL</code></td>
<td>
<p>a SpatialLines object as defined in the sp package</p>
</td></tr>
<tr><td><code id="SpatialLines2PolySet_+3A_spp">SpP</code></td>
<td>
<p>a SpatialPolygons object as defined in the sp package</p>
</td></tr>
<tr><td><code id="SpatialLines2PolySet_+3A_ps">PS</code></td>
<td>
<p>a PolySet object</p>
</td></tr>
<tr><td><code id="SpatialLines2PolySet_+3A_close_polys">close_polys</code></td>
<td>
<p>should polygons be closed if open</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PolySet objects as defined in the PBSmapping package
</p>


<h3>Author(s)</h3>

<p>Roger Bivand and Andrew Niccolai</p>


<h3>See Also</h3>

<p><code><a href="PBSmapping.html#topic+PolySet">PolySet</a></code>, <code><a href="maptools.html#topic+MapGen2SL">MapGen2SL</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(PBSmapping) &amp;&amp; require(maps)) {
nor_coast_lines &lt;- map("world", interior=FALSE, plot=FALSE, xlim=c(4,32),
 ylim=c(58,72))
nor_coast_lines &lt;- pruneMap(nor_coast_lines, xlim=c(4,32), ylim=c(58,72))
nor_coast_lines_sp &lt;- map2SpatialLines(nor_coast_lines,
 proj4string=CRS("+proj=longlat +datum=WGS84 +ellps=WGS84"))
nor_coast_lines_PS &lt;- SpatialLines2PolySet(nor_coast_lines_sp)
summary(nor_coast_lines_PS)
plotLines(nor_coast_lines_PS)
o3 &lt;- PolySet2SpatialLines(nor_coast_lines_PS)
plot(o3, axes=TRUE)
nor_coast_poly &lt;- map("world", "norway", fill=TRUE, col="transparent",
 plot=FALSE, ylim=c(58,72))
IDs &lt;- sapply(strsplit(nor_coast_poly$names, ":"), function(x) x[1])
nor_coast_poly_sp &lt;- map2SpatialPolygons(nor_coast_poly, IDs=IDs,
 proj4string=CRS("+proj=longlat +datum=WGS84 +ellps=WGS84"))
nor_coast_poly_PS &lt;- SpatialPolygons2PolySet(nor_coast_poly_sp)
summary(nor_coast_poly_PS)
plotPolys(nor_coast_poly_PS)
o1 &lt;- PolySet2SpatialPolygons(nor_coast_poly_PS)
plot(o1, axes=TRUE)
}
</code></pre>

<hr>
<h2 id='SpatialLinesMidPoints'>Line midpoints</h2><span id='topic+SpatialLinesMidPoints'></span>

<h3>Description</h3>

<p>The function onverts SpatialLinesDataFrame to SpatialPointsDataFrame with points at the midpoints of the line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialLinesMidPoints(sldf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialLinesMidPoints_+3A_sldf">sldf</code></td>
<td>
<p>A SpatialLines or SpatialLinesDataFrame object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function builds a SpatialPointsDataFrame from the midpoints of Line objects belonging to Lines objects in an object inheriting from a Spatial Lines object. The output data slot contains an index variable showing which Lines object the midpoints belong to.
</p>


<h3>Value</h3>

<p>A SpatialPointsDataFrame object created from the input object.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan, modified by Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- readShapeLines(system.file("shapes/fylk-val.shp", package="maptools")[1],
 proj4string=CRS("+proj=utm +zone=33 +datum=WGS84"))
plot(xx, col="blue")
spdf &lt;- SpatialLinesMidPoints(xx)
plot(spdf, col="orange", add=TRUE)
</code></pre>

<hr>
<h2 id='spCbind-methods'>cbind for spatial objects</h2><span id='topic+spCbind-methods'></span><span id='topic+spCbind+2CSpatialPointsDataFrame+2Cdata.frame-method'></span><span id='topic+spCbind+2CSpatialPointsDataFrame+2Cvector-method'></span><span id='topic+spCbind+2CSpatialLinesDataFrame+2Cdata.frame-method'></span><span id='topic+spCbind+2CSpatialLinesDataFrame+2Cvector-method'></span><span id='topic+spCbind+2CSpatialPolygonsDataFrame+2Cdata.frame-method'></span><span id='topic+spCbind+2CSpatialPolygonsDataFrame+2Cvector-method'></span><span id='topic+spCbind'></span>

<h3>Description</h3>

<p><code>spCbind</code> provides cbind-like methods for Spatial*DataFrame objects in addition to the <code>$</code>, <code>[&lt;-</code> and <code>[[&lt;-</code> methods already available.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;SpatialPointsDataFrame&quot;, x = &quot;data.frame&quot;</dt><dd><p>cbind a data frame to the data slot of a SpatialPointsDataFrame object</p>
</dd>
<dt>obj = &quot;SpatialPointsDataFrame&quot;, x = &quot;vector&quot;</dt><dd><p>cbind a vector to the data slot of a SpatialPointsDataFrame object</p>
</dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;, x = &quot;data.frame&quot;</dt><dd><p>cbind a data frame to the data slot of a SpatialLinesDataFrame object; the data frame argument must have row names set to the Lines ID values, and should be re-ordered first by matching against a shared key column</p>
</dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;, x = &quot;vector&quot;</dt><dd><p>cbind a vector to the data slot of a SpatialLinesDataFrame object</p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;, x = &quot;data.frame&quot;</dt><dd><p>cbind a data frame to the data slot of a SpatialPolygonsDataFrame object; the data frame argument must have row names set to the Polygons ID values, and should be re-ordered first by matching against a shared key column</p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;, x = &quot;vector&quot;</dt><dd><p>cbind a vector to the data slot of a SpatialPolygonsDataFrame object</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spChFIDs-methods">spChFIDs-methods</a></code>, <code><a href="maptools.html#topic+spRbind-methods">spRbind-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1], 
  IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
library(foreign)
xtra &lt;- read.dbf(system.file("share/nc_xtra.dbf", package="maptools")[1])
o &lt;- match(xx$CNTY_ID, xtra$CNTY_ID)
xtra1 &lt;- xtra[o,]
row.names(xtra1) &lt;- xx$FIPSNO
xx1 &lt;- spCbind(xx, xtra1)
names(xx1)
identical(xx1$CNTY_ID, xx1$CNTY_ID.1)
</code></pre>

<hr>
<h2 id='SplashDams'>Data for Splash Dams in western Oregon</h2><span id='topic+SplashDams'></span>

<h3>Description</h3>

<p>Data for Splash Dams in western Oregon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SplashDams)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'SpatialPointsDataFrame' [package &quot;sp&quot;] with 5 slots
..@ data       :'data.frame':	232 obs. of  6 variables:
.. ..$ streamName  : Factor w/ 104 levels &quot;Abiqua Creek&quot;,..: 12 12 60 60 60 49 49 9 9 18 ...
.. ..$ locationCode: Factor w/ 3 levels &quot;h&quot;,&quot;l&quot;,&quot;m&quot;: 1 1 1 1 1 1 1 1 1 1 ...
.. ..$ height      : int [1:232] 4 4 NA NA NA NA 10 NA NA NA ...
.. ..$ lastDate    : int [1:232] 1956 1956 1957 1936 1936 1929 1909 1919 1919 1919 ...
.. ..$ owner       : Factor w/ 106 levels &quot;A. Stefani&quot;,&quot;A.H. Blakesley&quot;,..: 42 42 42 84 84 24 24 25 25 25 ...
.. ..$ datesUsed   : Factor w/ 118 levels &quot;?-1870s-1899-?&quot;,..: 92 92 93 91 91 72 61 94 94 94 ...
..@ coords.nrs : num(0) 
..@ coords     : num [1:232, 1:3] -124 -124 -124 -124 -124 ...
.. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:3] &quot;coords.x1&quot; &quot;coords.x2&quot; &quot;coords.x3&quot;
..@ bbox       : num [1:3, 1:2] -124.2 42.9 0 -122.4 46.2 ...
.. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. ..$ : chr [1:3] &quot;coords.x1&quot; &quot;coords.x2&quot; &quot;coords.x3&quot;
.. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot;
..@ proj4string:Formal class 'CRS' [package &quot;sp&quot;] with 1 slots
.. .. ..@ projargs: chr &quot; +proj=longlat +ellps=WGS84&quot;
</p>


<h3>Source</h3>

<p>R. R. Miller (2010) Is the Past Present? Historical Splash-dam Mapping and Stream Disturbance Detection in the Oregon Coastal Province. MSc. thesis, Oregon State University; packaged by Jonathan Callahan</p>


<h3>References</h3>

<p><a href="https://www.fs.fed.us/pnw/lwm/aem/docs/burnett/miller_rebecca_r2010rev.pdf">https://www.fs.fed.us/pnw/lwm/aem/docs/burnett/miller_rebecca_r2010rev.pdf</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SplashDams)
plot(SplashDams, axes=TRUE)
</code></pre>

<hr>
<h2 id='spRbind-methods'>rbind for spatial objects</h2><span id='topic+spRbind-methods'></span><span id='topic+spRbind+2CSpatialPoints+2CSpatialPoints-method'></span><span id='topic+spRbind+2CSpatialPointsDataFrame+2CSpatialPointsDataFrame-method'></span><span id='topic+spRbind+2CSpatialLines+2CSpatialLines-method'></span><span id='topic+spRbind+2CSpatialLinesDataFrame+2CSpatialLinesDataFrame-method'></span><span id='topic+spRbind+2CSpatialPolygons+2CSpatialPolygons-method'></span><span id='topic+spRbind+2CSpatialPolygonsDataFrame+2CSpatialPolygonsDataFrame-method'></span><span id='topic+spRbind'></span>

<h3>Description</h3>

<p><code>spRbind</code> provides rbind-like methods for Spatial*DataFrame objects
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;SpatialPoints&quot;, x = &quot;SpatialPoints&quot;</dt><dd><p>rbind two SpatialPoints objects</p>
</dd>
<dt>obj = &quot;SpatialPointsDataFrame&quot;, x = &quot;SpatialPointsDataFrame&quot;</dt><dd><p>rbind two SpatialPointsDataFrame objects</p>
</dd>
<dt>obj = &quot;SpatialLines&quot;, x = &quot;SpatialLines&quot;</dt><dd><p>rbind two SpatialLines objects</p>
</dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;, x = &quot;SpatialLinesDataFrame&quot;</dt><dd><p>rbind two SpatialLinesDataFrame objects</p>
</dd>
<dt>obj = &quot;SpatialPolygons&quot;, x = &quot;SpatialPolygons&quot;</dt><dd><p>rbind two SpatialPolygons objects</p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;, x = &quot;SpatialPolygonsDataFrame&quot;</dt><dd><p>rbind two SpatialPolygonsDataFrame objects</p>
</dd>
</dl>


<h3>Note</h3>

<p>In addition to the <code>spRbind</code>-methods, there are also 
<code>rbind</code>-methods for Spatial* objects. The differences are:
</p>

<ol>
<li><p><code>spRbind</code>-methods can bind 2 objects, whereas <code>rbind</code>-methods 
can bind multiple object
</p>
</li>
<li><p>some <code>rbind</code> can accept objects with duplicated IDs, for all 
<code>spRbind</code>-methods these have to be modified explicitly, e.g. by 
calling <code><a href="sp.html#topic+spChFIDs-methods">spChFIDs-methods</a></code>
</p>
</li></ol>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spChFIDs-methods">spChFIDs-methods</a></code>, <code><a href="maptools.html#topic+spCbind-methods">spCbind-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1], 
  IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
summary(xx)
xx$FIPSNO
xx1 &lt;- xx[xx$CNTY_ID &lt; 1982,]
xx2 &lt;- xx[xx$CNTY_ID &gt;= 1982,]
xx3 &lt;- spRbind(xx2, xx1)
summary(xx3)
xx3$FIPSNO
</code></pre>

<hr>
<h2 id='state.vbm'> US State Visibility Based Map</h2><span id='topic+state.vbm'></span>

<h3>Description</h3>

<p>A SpatialPolygonsDataFrame object (for use with the maptools package) to plot a Visibility Based Map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(state.vbm)
</code></pre>


<h3>Details</h3>

<p>A SpatialPolygonsDataFrame object
(for use with the maptools package) to plot a map of the
US states where the sizes of the states have been adjusted to be more
equal.
</p>
<p>This map can be useful for plotting state data using colors patterns
without the larger states dominating and the smallest states being
lost.
</p>
<p>The original map is copyrighted by Mark Monmonier.  Official
publications based on this map should acknowledge him.
Comercial publications of maps based on this probably need permission
from him to use.
</p>


<h3>Author(s)</h3>

<p>Greg Snow <a href="mailto:greg.snow@imail.org">greg.snow@imail.org</a> (of this compilation)</p>


<h3>Source</h3>

<p>The data was converted from the maps library for S-PLUS.  S-PLUS uses
the map with permission from the author.  This version of the data
has not received permission from the author (no attempt made, not that
it was refused), most of my uses I feel fall under fair use and do not
violate copyright, but you will need to decide for yourself and your
applications.
</p>


<h3>References</h3>

<p><code>http://www.markmonmonier.com/index.htm</code>,
<a href="http://euclid.psych.yorku.ca/SCS/Gallery/bright-ideas.html">http://euclid.psych.yorku.ca/SCS/Gallery/bright-ideas.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(state.vbm)
  plot(state.vbm)

  tmp &lt;- state.x77[,'HS Grad']
  tmp2 &lt;- cut(tmp, seq(min(tmp),max(tmp), length.out=11),
    include.lowest=TRUE)
  plot(state.vbm,col=cm.colors(10)[tmp2])
</code></pre>

<hr>
<h2 id='sun-methods'>Methods for sun ephemerides calculations</h2><span id='topic+crepuscule'></span><span id='topic+sunriset'></span><span id='topic+solarnoon'></span><span id='topic+solarpos'></span><span id='topic+crepuscule-methods'></span><span id='topic+crepuscule+2CSpatialPoints+2CPOSIXct-method'></span><span id='topic+crepuscule+2Cmatrix+2CPOSIXct-method'></span><span id='topic+solarnoon-methods'></span><span id='topic+solarnoon+2CSpatialPoints+2CPOSIXct-method'></span><span id='topic+solarnoon+2Cmatrix+2CPOSIXct-method'></span><span id='topic+solarpos-methods'></span><span id='topic+solarpos+2CSpatialPoints+2CPOSIXct-method'></span><span id='topic+solarpos+2Cmatrix+2CPOSIXct-method'></span><span id='topic+sunriset-methods'></span><span id='topic+sunriset+2CSpatialPoints+2CPOSIXct-method'></span><span id='topic+sunriset+2Cmatrix+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>Functions for calculating sunrise, sunset, and times of
dawn and dusk, with flexibility for the various formal definitions.
They use algorithms provided by the National Oceanic &amp; Atmospheric
Administration (NOAA).</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'SpatialPoints,POSIXct'
crepuscule(crds, dateTime, solarDep, direction=c("dawn", "dusk"),
           POSIXct.out=FALSE)
## S4 method for signature 'matrix,POSIXct'
crepuscule(crds, dateTime,
           proj4string=CRS("+proj=longlat +datum=WGS84"), solarDep,
           direction=c("dawn", "dusk"), POSIXct.out=FALSE)
## S4 method for signature 'SpatialPoints,POSIXct'
sunriset(crds, dateTime, direction=c("sunrise", "sunset"),
         POSIXct.out=FALSE)
## S4 method for signature 'matrix,POSIXct'
sunriset(crds, dateTime,
         proj4string=CRS("+proj=longlat +datum=WGS84"),
         direction=c("sunrise", "sunset"), POSIXct.out=FALSE)
## S4 method for signature 'SpatialPoints,POSIXct'
solarnoon(crds, dateTime, POSIXct.out=FALSE)
## S4 method for signature 'matrix,POSIXct'
solarnoon(crds, dateTime,
          proj4string=CRS("+proj=longlat +datum=WGS84"),
          POSIXct.out=FALSE)
## S4 method for signature 'SpatialPoints,POSIXct'
solarpos(crds, dateTime, ...)
## S4 method for signature 'matrix,POSIXct'
solarpos(crds, dateTime,
         proj4string=CRS("+proj=longlat +datum=WGS84"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sun-methods_+3A_crds">crds</code></td>
<td>
<p>a <code>SpatialPoints</code> or <code>matrix</code> object, containing
x and y coordinates (in that order).</p>
</td></tr>
<tr><td><code id="sun-methods_+3A_datetime">dateTime</code></td>
<td>
<p>a POSIXct object with the date and time associated to
calculate ephemerides for points given in crds.</p>
</td></tr>
<tr><td><code id="sun-methods_+3A_solardep">solarDep</code></td>
<td>
<p>numeric vector with the angle of the sun below the
horizon in degrees.</p>
</td></tr>
<tr><td><code id="sun-methods_+3A_direction">direction</code></td>
<td>
<p>one of &quot;dawn&quot;, &quot;dusk&quot;, &quot;sunrise&quot;, or &quot;sunset&quot;,
indicating which ephemerides should be calculated.</p>
</td></tr>
<tr><td><code id="sun-methods_+3A_posixct.out">POSIXct.out</code></td>
<td>
<p>logical indicating whether POSIXct output should be
included.</p>
</td></tr>
<tr><td><code id="sun-methods_+3A_proj4string">proj4string</code></td>
<td>
<p>string with valid projection string describing the
projection of data in <code>crds</code>.</p>
</td></tr>
<tr><td><code id="sun-methods_+3A_...">...</code></td>
<td>
<p>other arguments passed through.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOAA used the reference below to develop their Sunrise/Sunset
</p>
<p><a href="https://gml.noaa.gov/grad/solcalc/sunrise.html">https://gml.noaa.gov/grad/solcalc/sunrise.html</a> and Solar
Position 
</p>
<p><a href="https://gml.noaa.gov/grad/solcalc/azel.html">https://gml.noaa.gov/grad/solcalc/azel.html</a>
Calculators.  The algorithms include corrections for atmospheric
refraction effects.
</p>
<p>Input can consist of one location and at least one POSIXct times, or one
POSIXct time and at least one location.  <var>solarDep</var> is recycled as
needed.
</p>
<p>Do not use the daylight savings time zone string for supplying
<var>dateTime</var>, as many OS will not be able to properly set it to
standard time when needed.
</p>


<h3>Value</h3>

<p><code>crepuscule</code>, <code>sunriset</code>, and <code>solarnoon</code> return a
numeric vector with the time of day at which the event occurs,
expressed as a fraction, if POSIXct.out is FALSE; otherwise they
return a data frame with both the fraction and the corresponding
POSIXct date and time.
</p>
<p><code>solarpos</code> returns a matrix with the solar azimuth (in degrees
from North), and elevation.
</p>


<h3>Warning</h3>

<p>Compared to NOAA's original Javascript code, the
sunrise and sunset estimates from this translation may differ by +/- 1
minute, based on tests using selected locations spanning the globe.
This translation does not include calculation of prior or next
sunrises/sunsets for locations above the Arctic Circle or below the
Antarctic Circle.</p>


<h3>Note</h3>

<p>NOAA notes that &ldquo;for latitudes greater than 72 degrees N
and S, calculations are accurate to within 10 minutes.  For
latitudes less than +/- 72 degrees accuracy is approximately one
minute.&rdquo;</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>, translated from
Greg Pelletier's <a href="mailto:gpel461@ecy.wa.gov">gpel461@ecy.wa.gov</a> VBA code (available from
<a href="https://ecology.wa.gov/Research-Data/Data-resources/Models-spreadsheets/Modeling-the-environment/Models-tools-for-TMDLs">https://ecology.wa.gov/Research-Data/Data-resources/Models-spreadsheets/Modeling-the-environment/Models-tools-for-TMDLs</a>), who in turn
translated it from original Javascript code by NOAA (see Details).
Roger Bivand <a href="mailto:roger.bivand@nhh.no">roger.bivand@nhh.no</a> adapted the code to work with
<span class="pkg">sp</span> classes.</p>


<h3>References</h3>

<p>Meeus, J.  (1991)  Astronomical Algorithms.  Willmann-Bell, Inc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Location of Helsinki, Finland, in decimal degrees,
## as listed in NOAA's website
hels &lt;- matrix(c(24.97, 60.17), nrow=1)
Hels &lt;- SpatialPoints(hels, proj4string=CRS("+proj=longlat +datum=WGS84"))
d041224 &lt;- as.POSIXct("2004-12-24", tz="EET")
## Astronomical dawn
crepuscule(hels, d041224, solarDep=18, direction="dawn", POSIXct.out=TRUE)
crepuscule(Hels, d041224, solarDep=18, direction="dawn", POSIXct.out=TRUE)
## Nautical dawn
crepuscule(hels, d041224, solarDep=12, direction="dawn", POSIXct.out=TRUE)
crepuscule(Hels, d041224, solarDep=12, direction="dawn", POSIXct.out=TRUE)
## Civil dawn
crepuscule(hels, d041224, solarDep=6, direction="dawn", POSIXct.out=TRUE)
crepuscule(Hels, d041224, solarDep=6, direction="dawn", POSIXct.out=TRUE)
solarnoon(hels, d041224, POSIXct.out=TRUE)
solarnoon(Hels, d041224, POSIXct.out=TRUE)
solarpos(hels, as.POSIXct(Sys.time(), tz="EET"))
solarpos(Hels, as.POSIXct(Sys.time(), tz="EET"))
sunriset(hels, d041224, direction="sunrise", POSIXct.out=TRUE)
sunriset(Hels, d041224, direction="sunrise", POSIXct.out=TRUE)
## Using a sequence of dates
Hels_seq &lt;- seq(from=d041224, length.out=365, by="days")
up &lt;- sunriset(Hels, Hels_seq, direction="sunrise", POSIXct.out=TRUE)
down &lt;- sunriset(Hels, Hels_seq, direction="sunset", POSIXct.out=TRUE)
day_length &lt;- down$time - up$time
plot(Hels_seq, day_length, type="l")

## Using a grid of spatial points for the same point in time
## Not run: 
grd &lt;- GridTopology(c(-179,-89), c(1,1), c(359,179))
SP &lt;- SpatialPoints(coordinates(grd),
                    proj4string=CRS("+proj=longlat +datum=WGS84"))
wint &lt;- as.POSIXct("2004-12-21", tz="GMT")
win &lt;- crepuscule(SP, wint, solarDep=6, direction="dawn")
SPDF &lt;- SpatialGridDataFrame(grd,
 proj4string=CRS("+proj=longlat +datum=WGS84"),
 data=data.frame(winter=win))
image(SPDF, axes=TRUE, col=cm.colors(40))

## End(Not run)
</code></pre>

<hr>
<h2 id='symbolsInPolys'>Place grids of points over polygons</h2><span id='topic+symbolsInPolys'></span>

<h3>Description</h3>

<p>Place grids of points over polygons with chosen density and/or symbols (suggested by Michael Wolf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolsInPolys(pl, dens, symb = "+", compatible = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolsInPolys_+3A_pl">pl</code></td>
<td>
<p>an object of class SpatialPolygons or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="symbolsInPolys_+3A_dens">dens</code></td>
<td>
<p>number of symbol plotting points per unit area; either a single numerical value for all polygons, or a numeric vector the same length as pl with values for each polygon</p>
</td></tr>
<tr><td><code id="symbolsInPolys_+3A_symb">symb</code></td>
<td>
<p>plotting symbol; either a single value for all polygons, or a vector the same length as pl with values for each polygon</p>
</td></tr>
<tr><td><code id="symbolsInPolys_+3A_compatible">compatible</code></td>
<td>
<p>what to return, if TRUE a a list of matrices of point coordinates, one matrix for each member of pl, with a <code>symb</code> attribute, if false a SpatialPointsDataFrame with a <code>symb</code> column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dots are placed in a grid pattern with the number of points per polygon being polygon area times density (number of dots not guaranteed to be the same as the count). When the polygon is made up of more than one part, the dots will be placed in proportion to the relative areas of the clockwise rings (anticlockwise are taken as holes). From maptools release 0.5-2, correction is made for holes in the placing of the dots, but depends on hole values being correctly set, which they often are not. 
</p>


<h3>Value</h3>

<p>The function returns a list of matrices of point coordinates, one matrix for each member of pl; each matrix has a <code>symb</code> attribute that can be used for setting the <code>pch</code> argument for plotting. If the count of points for the given density and polygon area is zero, the list element is NULL, and can be tested when plotting - see the examples.
</p>


<h3>Note</h3>

<p>Extension to plot pixmaps at the plotting points using addlogo() from the pixmap package is left as an exercise for the user.</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spsample">spsample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nc_SP &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
 proj4string=CRS("+proj=longlat +ellps=clrk66"))
## Not run: 
pls &lt;- slot(nc_SP, "polygons")
pls_new &lt;- lapply(pls, checkPolygonsHoles)
nc_SP &lt;- SpatialPolygonsDataFrame(SpatialPolygons(pls_new,
 proj4string=CRS(proj4string(nc_SP))), data=as(nc_SP, "data.frame"))

## End(Not run)
symbs &lt;- c("-", "+", "x")
np &lt;- sapply(slot(nc_SP, "polygons"), function(x) length(slot(x, "Polygons")))
try1 &lt;- symbolsInPolys(nc_SP, 100, symb=symbs[np])
plot(nc_SP, axes=TRUE)
plot(try1, add=TRUE, pch=as.character(try1$symb))
</code></pre>

<hr>
<h2 id='thinnedSpatialPoly'>Douglas-Peuker line generalization for Spatial Polygons</h2><span id='topic+thinnedSpatialPoly'></span>

<h3>Description</h3>

<p>The function applies the implementation of the Douglas-Peuker algorithm for line generalization or simplification (originally from shapefiles) to objects inheriting from Spatial Polygons. It does not preserve topology, so is suitable for visualisation, but not for the subsequent analysis of the polygon boundaries, as artefacts may be created, and boundaries of neighbouring entities may be generalized differently. If the rgeos package is available, <code>thinnedSpatialPolyGEOS</code> will be used with partial topology preservation instead of the R implementation here by passing arguments through.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinnedSpatialPoly(SP, tolerance, minarea=0, topologyPreserve = FALSE,
                 avoidGEOS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinnedSpatialPoly_+3A_sp">SP</code></td>
<td>
<p>an object inheriting from the SpatialPolygons class</p>
</td></tr>
<tr><td><code id="thinnedSpatialPoly_+3A_tolerance">tolerance</code></td>
<td>
<p>the tolerance value in the metric of the input object</p>
</td></tr>
<tr><td><code id="thinnedSpatialPoly_+3A_minarea">minarea</code></td>
<td>
<p>the smallest area of Polygon objects to be retained, ignored if <span class="pkg">rgeos</span> used</p>
</td></tr>
<tr><td><code id="thinnedSpatialPoly_+3A_topologypreserve">topologyPreserve</code></td>
<td>
<p>choose between two <span class="pkg">rgeos</span> options: logical determining if the algorithm should attempt to preserve the topology (nodes not complete edges) of the original geometry</p>
</td></tr>
<tr><td><code id="thinnedSpatialPoly_+3A_avoidgeos">avoidGEOS</code></td>
<td>
<p>use R DP code even if <span class="pkg">rgeos</span> is available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input object</p>


<h3>Note</h3>

<p>Warnings reporting: Non-finite label point detected and replaced, reflect the changes in the geometries of the polygons induced by line generalization.</p>


<h3>Author(s)</h3>

<p>Ben Stabler, Michael Friendly, Roger Bivand</p>


<h3>References</h3>

<p>Douglas, D. and Peucker, T. (1973). Algorithms for 
the reduction of the number of points required to 
represent a digitized line or its caricature. 
<em>The Canadian Cartographer</em> 10(2). 112-122.</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- readShapeSpatial(system.file("shapes/sids.shp", package="maptools")[1],
      IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
object.size(as(xx, "SpatialPolygons"))
xxx &lt;- thinnedSpatialPoly(xx, tolerance=0.05, minarea=0.001)
object.size(as(xxx, "SpatialPolygons"))
par(mfrow=c(2,1))
plot(xx)
plot(xxx)
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='unionSpatialPolygons'>Aggregate Polygons in a SpatialPolygons object</h2><span id='topic+unionSpatialPolygons'></span>

<h3>Description</h3>

<p>The function aggregates Polygons in a SpatialPolygons object, according to the IDs vector specifying which input Polygons belong to which output Polygons; internal boundaries are dissolved using the rgeos package <code>gUnaryUnion</code> function. If the rgeos package is not available, and if the gpclib package is available and the user confirms that its restrictive license conditions are met, its <code>union</code> function will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unionSpatialPolygons(SpP, IDs, threshold=NULL, avoidGEOS=FALSE, avoidUnaryUnion=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unionSpatialPolygons_+3A_spp">SpP</code></td>
<td>
<p>A SpatialPolygons object as defined in package sp</p>
</td></tr>
<tr><td><code id="unionSpatialPolygons_+3A_ids">IDs</code></td>
<td>
<p>A vector defining the output Polygons objects, equal in length to the length of the polygons slot of SpRs; it may be character, integer, or factor (try table(factor(IDs)) for a sanity check). It may contain NA values for input objects not included in the union</p>
</td></tr>
<tr><td><code id="unionSpatialPolygons_+3A_threshold">threshold</code></td>
<td>
<p>if not NULL, an area measure below which slivers will be discarded (some polygons have non-identical boundaries, for instance along rivers, generating slivers on union which are artefacts, not real sub-polygons)</p>
</td></tr>
<tr><td><code id="unionSpatialPolygons_+3A_avoidgeos">avoidGEOS</code></td>
<td>
<p>default FALSE; if TRUE force use of gpclib even when GEOS is available</p>
</td></tr>
<tr><td><code id="unionSpatialPolygons_+3A_avoidunaryunion">avoidUnaryUnion</code></td>
<td>
<p>avoid gUnaryUnion if it is available; not relevant before GEOS 3.3.0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an aggregated SpatialPolygons object named with the aggregated IDs values in their sorting order; see the ID values of the output object to view the order.
</p>


<h3>Warning</h3>

<p>When using GEOS Unary Union, it has been found that some polygons are not dissolved correctly when the absolute values of the coordinates are very small. No work-around is available at present.</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rgeosStatus()) {
nc1 &lt;- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
 proj4string=CRS("+proj=longlat +datum=NAD27"))
lps &lt;- coordinates(nc1)
ID &lt;- cut(lps[,1], quantile(lps[,1]), include.lowest=TRUE)
reg4 &lt;- unionSpatialPolygons(nc1, ID)
row.names(reg4)
}
</code></pre>

<hr>
<h2 id='wrld_simpl'>Simplified world country polygons</h2><span id='topic+wrld_simpl'></span>

<h3>Description</h3>

<p>The object loaded is a <code>SpatialPolygonsDataFrame</code> object containing a slightly modified version of Bjoern Sandvik's improved version of world_borders.zip - TM_WORLD_BORDERS_SIMPL-0.2.zip dataset from the Mapping Hacks geodata site. The country Polygons objects and the data slot data frame row numbers have been set to the ISO 3166 three letter codes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wrld_simpl)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'SpatialPolygonsDataFrame' [package &quot;sp&quot;] with 5 slots; the data 
clot contains a data.frame with 246 obs. of  11 variables:
</p>

<dl>
<dt>FIPS</dt><dd><p>factor of FIPS country codes</p>
</dd>
<dt>ISO2</dt><dd><p>factor of ISO 2 character country codes</p>
</dd>
<dt>ISO3</dt><dd><p>factor of ISO 3 character country codes</p>
</dd>
<dt>UN</dt><dd><p>integer vector of UN country codes</p>
</dd>
<dt>NAME</dt><dd><p>Factor of country names</p>
</dd>
<dt>AREA</dt><dd><p>integer vector of area values</p>
</dd>
<dt>POP2005</dt><dd><p>integer vector of population in 2005</p>
</dd>
<dt>REGION</dt><dd><p>integer vector of region values</p>
</dd>
<dt>SUBREGION</dt><dd><p>integer vector of subregion values</p>
</dd>
<dt>LON</dt><dd><p>numeric vector of longitude label points</p>
</dd>
<dt>LAT</dt><dd><p>numeric vector of latitude label points</p>
</dd>
</dl>

<p>The object is in geographical coordinates using the WGS84 datum.
</p>


<h3>Source</h3>

<p>Originally &ldquo;http://mappinghacks.com/data/TM_WORLD_BORDERS_SIMPL-0.2.zip&rdquo;, now available from <a href="https://github.com/nasa/World-Wind-Java/tree/master/WorldWind/testData/shapefiles">https://github.com/nasa/World-Wind-Java/tree/master/WorldWind/testData/shapefiles</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wrld_simpl)
plot(wrld_simpl)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
