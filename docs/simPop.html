<!DOCTYPE html><html lang="en"><head><title>Help for package simPop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simPop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simPop-package'><p>Simulation of Synthetic Populations for Survey Data</p>
Considering Auxiliary Information</a></li>
<li><a href='#addKnownMargins'><p>add known margins/totals</p></a></li>
<li><a href='#addWeights+26lt+3B-'><p>Methods for function <code>addWeights</code></p></a></li>
<li><a href='#calibPop'><p>Calibration of 0/1 weights by Simulated Annealing</p></a></li>
<li><a href='#calibSample'><p>Calibrate sample weights</p></a></li>
<li><a href='#calibVars'><p>Construct a matrix of binary variables for calibration</p></a></li>
<li><a href='#contingencyWt'><p>Weighted contingency coefficients</p></a></li>
<li><a href='#correctHeaps'><p>Correct  age heaping</p></a></li>
<li><a href='#correctSingleHeap'><p>correctSingleHeap</p></a></li>
<li><a href='#crossValidation'><p>Simulate variables of population data by cross validation</p></a></li>
<li><a href='#dataObj-class'><p>Class <code>"dataObj"</code></p></a></li>
<li><a href='#eusilc13puf'><p>Synthetic EU-SILC 2013 survey data</p></a></li>
<li><a href='#eusilcP'><p>Synthetic EU-SILC data</p></a></li>
<li><a href='#eusilcS'><p>Synthetic EU-SILC survey data</p></a></li>
<li><a href='#get_set-methods'><p>Extract and modify variables from population or sample data stored in an</p>
object of class <code>simPopObj-class</code>.</a></li>
<li><a href='#getBreaks'><p>Compute break points for categorizing (semi-)continuous variables</p></a></li>
<li><a href='#getCat'><p>Categorize (semi-)continuous variables</p></a></li>
<li><a href='#ghanaS'><p>Synthetic GLSS survey data</p></a></li>
<li><a href='#ipu'><p>iterative proportional updating</p></a></li>
<li><a href='#manageSimPopObj'><p>get and set variables from population or sample data stored in an object of</p>
class <code>simPopObj</code>.</a></li>
<li><a href='#quantileWt'><p>Weighted sample quantiles</p></a></li>
<li><a href='#sampHH'><p>Sample households from given microdata.</p></a></li>
<li><a href='#silcTools'><p>Utility functions for socio-economic data sets</p></a></li>
<li><a href='#silcTools2'><p>Utility functions for EU-SILC data</p></a></li>
<li><a href='#simCategorical'><p>Simulate categorical variables of population data</p></a></li>
<li><a href='#simComponents'><p>Simulate components of continuous variables of population data</p></a></li>
<li><a href='#simContinuous'><p>Simulate continuous variables of population data</p></a></li>
<li><a href='#simEUSILC'><p>Simulate EU-SILC population data</p></a></li>
<li><a href='#simInitSpatial'><p>Generation of smaller regions given an existing spatial variable and a</p>
table.</a></li>
<li><a href='#simple_dis'><p>Simple generation of new variables</p></a></li>
<li><a href='#simPopObj-class'><p>Class <code>"simPopObj"</code></p></a></li>
<li><a href='#simRelation'><p>Simulate categorical variables of population data</p></a></li>
<li><a href='#simStructure'><p>Simulate the household structure of population data</p></a></li>
<li><a href='#spBwplot'><p>Weighted box plots</p></a></li>
<li><a href='#spBwplotStats'><p>Weighted box plot statistics</p></a></li>
<li><a href='#spCdf'><p>(Weighted empirical) cumulative distribution function</p></a></li>
<li><a href='#spCdfplot'><p>Plot weighted cumulative distribution functions</p></a></li>
<li><a href='#specifyInput'><p>create an object of class 'dataObj' required for further processing</p></a></li>
<li><a href='#spMosaic'><p>Mosaic plots of expected and realized population sizes</p></a></li>
<li><a href='#sprague'><p>Sprague index (multipliers)</p></a></li>
<li><a href='#spTable'><p>Cross tabulations of expected and realized population sizes.</p></a></li>
<li><a href='#tableWt'><p>Weighted cross tabulation</p></a></li>
<li><a href='#totalsRG'><p>Population totals Region times Gender for Austria 2006</p></a></li>
<li><a href='#utility'><p>Utility measures</p></a></li>
<li><a href='#weighted_estimators'><p>Weighted mean, variance, covariance matrix and correlation matrix</p></a></li>
<li><a href='#whipple'><p>Whipple index (original and modified)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Complex Synthetic Data Information</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-05</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statistikat/simPop">https://github.com/statistikat/simPop</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0), lattice, vcd</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, MASS, Rcpp (&ge; 0.11.0), RcppArmadillo, e1071,
parallel, nnet, doParallel, foreach, colorspace, VIM, methods,
EnvStats, fitdistrplus, ranger, wrswoR, matrixStats, xgboost,
partykit</td>
</tr>
<tr>
<td>Suggests:</td>
<td>haven, microbenchmark, stringr, tinytest, sampling, covr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,RcppArmadillo</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools and methods to simulate populations for surveys based
    on auxiliary data. The tools include model-based methods, calibration and
    combinatorial optimization algorithms, see Templ, Kowarik and Meindl (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v079.i10">doi:10.18637/jss.v079.i10</a>&gt;) and
    Templ (2017) &lt;<a href="https://doi.org/10.1007%2F978-3-319-50272-4">doi:10.1007/978-3-319-50272-4</a>&gt;. The package was developed with support of
    the International Household Survey Network, DFID Trust Fund TF011722 and funds
    from the World bank.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Collate:</td>
<td>'0classes.R' 'addKnownMargins.R' 'addWeights.r' 'calibPop.R'
'calibSample.R' 'calibVars.R' 'contingencyWt.R' 'correctHeap.R'
'crossValidation.R' 'fitGPD.R' 'getBreaks.R' 'getCat.R' 'ipu.r'
'meanWt.R' 'printFunctions.R' 'quantileWt.R' 'sampHH.R'
'RcppExports.R' 'silcTools.R' 'silcTools2.R' 'simAnnealingDT.R'
'simCategorical.R' 'simComponents.R' 'simContinuous.R'
'simEUSILC.R' 'simGPD.R' 'simInitSpatial.R' 'simple_dis.R'
'simPop-package.R' 'simRelation.R' 'simStructure.R'
'spBwplot.R' 'spBwplotStats.R' 'spCdf.R' 'spCdfplot.R'
'spMosaic.R' 'spPredict.R' 'spSample.R' 'spTable.R'
'specifyInput.R' 'sprague.R' 'tableWt.R' 'utility.R' 'utils.R'
'whipple.R' 'dataSets.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-05 10:41:47 UTC; gussen</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Templ [aut, cre],
  Alexander Kowarik <a href="https://orcid.org/0000-0001-8598-4130"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bernhard Meindl [aut],
  Andreas Alfons [aut],
  Mathieu Ribatet [ctb],
  Johannes Gussenbauer [ctb],
  Siro Fritzmann [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Templ &lt;matthias.templ@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simPop-package'>Simulation of Synthetic Populations for Survey Data 
Considering Auxiliary Information</h2><span id='topic+simPop-package'></span><span id='topic+simPop'></span>

<h3>Description</h3>

<p>The production of synthetic datasets has been proposed as a 
statistical disclosure control solution to generate public use 
files out of protected data, and as a tool to 
create &ldquo;augmented datasets&rdquo; to serve as input for 
micro-simulation models. 
Synthetic data have become an important instrument 
for <em>ex-ante</em> assessments of policies' impact. 
The performance and acceptability of such a tool relies 
heavily on the quality of the synthetic populations, 
i.e., on the statistical similarity between the synthetic 
and the true population of interest.
</p>


<h3>Details</h3>

<p>Multiple approaches and tools have been developed to 
generate synthetic data. These approaches can be 
categorized into three main groups: 
synthetic reconstruction, combinatorial optimization, 
and model-based generation. 
</p>
<p>The package:
<span class="pkg">simPop</span> is a user-friendly R-package based on a modular object-oriented concept. 
It provides a highly optimized S4 class implementation 
of various methods, including calibration by iterative 
proportional fitting and simulated annealing, and 
modeling or data fusion by logistic regression. 
</p>
<p>The following applications further shows the methods and package:   
We firstly demonstrated the use of <span class="pkg">simPop</span> by creating 
a synthetic population of Austria based on the 
European Statistics of Income and Living Conditions (Alfons et al., 2011) 
including the evaluation of the quality of the generated population. 
In this contribution, the mathematical details of functions <code>simStructure</code>, <code>simCategorical</code>,
<code>simContinuous</code> and <code>simComponents</code> are given in detail.
The disclosure risk of this synthetic population has been evaluated in (Templ and Alfons, 2012) using large-scale simulation studies. 
</p>
<p>Employer-employee data were created in Templ and Filzmoser (2014) whereby 
the structure of companies and employees are considered.
</p>
<p>Finally, the R package <span class="pkg">simPop</span> is presented in full detail 
in Templ et al. (2017). In this paper - the main reference to this work - 
all functions and the S4 class 
structure of the package are described in detail. For beginners, this paper might be 
the starting point to learn about the methods and package.
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> simPop</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.0.0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 20017-08-07</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2) </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Bernhard Meindl, Matthias Templ, Andreas Alfons, Alexander Kowarik,
</p>
<p>Maintainer: Matthias Templ &lt;matthias.templ@gmail.com&gt;
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>
<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC. <em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. doi: 10.1007/s10260-011-0163-2
</p>
<p>M. Templ, P. Filzmoser (2014) Simulation and quality of a synthetic close-to-reality employer-employee population. 
Journal of Applied Statistics, <strong>41</strong> (5), 1053&ndash;1072. <a href="https://doi.org/10.1080/02664763.2013.859237">doi:10.1080/02664763.2013.859237</a> 
</p>
<p>M. Templ, A. Alfons (2012) Disclosure Risk of Synthetic Population Data 
with Application in the Case of EU-SILC. In J Domingo-Ferrer, E Magkos (eds.), 
<em>Privacy in Statistical Databases</em>, <strong>6344</strong> of Lecture Notes in Computer Science, 174&ndash;186. Springer Verlag, Heidelberg. <a href="https://doi.org/10.1007/978-3-642-15838-4_16">doi:10.1007/978-3-642-15838-4_16</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## we use synthetic eusilcS survey sample data 
## included in the package to simulate a population

## create the structure
data(eusilcS)

## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
## in the following, nr_cpus are selected automatically
simPop &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
simPop &lt;- simCategorical(simPop, additional=c("pl030", "pb220a"), method="multinom", nr_cpus=1)
simPop
class(simPop)
regModel = ~rb090+hsize+pl030+pb220a

## multinomial model with random draws
eusilcM &lt;- simContinuous(simPop, additional="netIncome",
              regModel = regModel,
              upper=200000, equidist=FALSE, nr_cpus=1)
class(eusilcM)


## this is already a basic synthetic population, but
## many other functions in the package might now 
## be used for fine-tuning, adding further variables, 
## evaluating the quality, adding finer geographical details, 
## using different methods, calibrating surveys or populations, etc. 
## -- see Templ et al. (2017) for more details.

</code></pre>

<hr>
<h2 id='addKnownMargins'>add known margins/totals</h2><span id='topic+addKnownMargins'></span>

<h3>Description</h3>

<p>add known margins/totals for a combination of variables for the population
to an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addKnownMargins(inp, margins)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addKnownMargins_+3A_inp">inp</code></td>
<td>
<p>a <code>simPopObj</code> containing population and household survey
data as well as optionally margins in standardized format.</p>
</td></tr>
<tr><td><code id="addKnownMargins_+3A_margins">margins</code></td>
<td>
<p>a <code>data.frame</code> containing for a combination of unique
variable levels for n-variables the number of known occurences in the
population. The numbers must be listed in the last column of data.frame
'margins' while the characteristics must be listed in the first 'n' columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a data.frame containing known marginals/totals for a some
variables that must exist in the population (stored in slot 'pop' of input
object 'inp') and updates slot 'table' of the input object. This slot
finally contains the known totals.
</p>
<p>households are drawn from the data and new ID's are generated for the new
households.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> with updated slot
'table'.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
data(eusilcP)
## Not run: 
## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
inp &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
inp &lt;- simCategorical(inp, additional=c("pl030", "pb220a"), method="multinom",nr_cpus=1)

margins &lt;- as.data.frame(
  xtabs(rep(1, nrow(eusilcP)) ~ eusilcP$region + eusilcP$gender + eusilcP$citizenship))
colnames(margins) &lt;- c("db040", "rb090", "pb220a", "freq")
inp &lt;- addKnownMargins(inp, margins)
str(inp)

## End(Not run)
</code></pre>

<hr>
<h2 id='addWeights+26lt+3B-'>Methods for function <code>addWeights</code></h2><span id='topic+addWeights+3C-'></span><span id='topic+addWeights'></span><span id='topic+addWeights+3C-+2CdataObj-method'></span><span id='topic+addWeights+3C-+2CsimPopObj-method'></span>

<h3>Description</h3>

<p>allows to modify sampling weights of an <code><a href="#topic+dataObj-class">dataObj</a></code> or
<code><a href="#topic+simPopObj-class">simPopObj</a></code>-object. As input the output of
<code><a href="#topic+calibSample">calibSample</a></code> must be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addWeights(object) &lt;- value

## S4 replacement method for signature 'dataObj'
addWeights(object) &lt;- value

## S4 replacement method for signature 'simPopObj'
addWeights(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addWeights+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+dataObj-class">dataObj</a></code> or <code><a href="#topic+simPopObj-class">simPopObj</a></code>.</p>
</td></tr>
<tr><td><code id="addWeights+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a numeric vector of suitable length</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
data(totalsRG)
## Not run: 
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
## approx. 20 seconds ...
addWeights(inp) &lt;- calibSample(inp, totalsRG)

## End(Not run)
</code></pre>

<hr>
<h2 id='calibPop'>Calibration of 0/1 weights by Simulated Annealing</h2><span id='topic+calibPop'></span>

<h3>Description</h3>

<p>A Simulated Annealing Algorithm for calibration of synthetic population data
available in a <code><a href="#topic+simPopObj-class">simPopObj</a></code>-object. The aims is to find,
given a population, a combination of different households which optimally
satisfy, in the sense of an acceptable error, a given table of specific
known marginals. The known marginals are also already available in slot
'table' of the input object 'inp'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibPop(
  inp,
  split = NULL,
  splitUpper = NULL,
  temp = 1,
  epsP.factor = 0.05,
  epsH.factor = 0.05,
  epsMinN = 0,
  maxiter = 200,
  temp.cooldown = 0.9,
  factor.cooldown = 0.85,
  min.temp = 10^-3,
  nr_cpus = NULL,
  sizefactor = 2,
  choose.temp = TRUE,
  choose.temp.factor = 0.2,
  scale.redraw = 0.5,
  observe.times = 50,
  observe.break = 0.05,
  n.forceCooldown = 100,
  verbose = FALSE,
  hhTables = NULL,
  persTables = NULL,
  redist.var = NULL,
  redist.var.factor = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibPop_+3A_inp">inp</code></td>
<td>
<p>an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> with slot
'table' being non-null! (see <code><a href="#topic+addKnownMargins">addKnownMargins</a></code>).</p>
</td></tr>
<tr><td><code id="calibPop_+3A_split">split</code></td>
<td>
<p>given strata in which the problem will be split. Has to
correspond to a column population data (slot 'pop' of input argument 'inp')
. For example <code>split = (c("region")</code>, problem will be split for
different regions. Parallel computing is performed automatically, if
possible.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_splitupper">splitUpper</code></td>
<td>
<p>optional column in the population for which decides the part
of the population from which to sample for each entry in <code>split</code>.
Has to correspond to a column population data (slot 'pop' of input argument 'inp').
For example <code>split = c("region"), splitUpper = c("Country")</code>
all units from the country are eligable for donor sample when problem is split
into regions. Is usefull if <code>simInitSpatial()</code> was used and the variable to split
the problem into results in very small groups (~couple of hundreds to thousands).</p>
</td></tr>
<tr><td><code id="calibPop_+3A_temp">temp</code></td>
<td>
<p>starting temperatur for simulated annealing algorithm</p>
</td></tr>
<tr><td><code id="calibPop_+3A_epsp.factor">epsP.factor</code></td>
<td>
<p>a factor (between 0 and 1) specifying the acceptance
error for contingency table on individual level. For example epsP.factor = 0.05 results in an acceptance error for the
objective function of <code>0.05*sum(People)</code>.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_epsh.factor">epsH.factor</code></td>
<td>
<p>a factor (between 0 and 1) specifying the acceptance
error for contingency table on household level. For example epsH.factor = 0.05 results in an acceptance error for the
objective function of <code>0.05*sum(Households)</code>.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_epsminn">epsMinN</code></td>
<td>
<p>integer specifying the minimum number of units from which the synthetic populatin can deviate from cells in contingency tables.
This overwrites <code>epsP.factor</code> and <code>epsH.factor</code>. Is especially usefull if cells in <code>hhTables</code> and <code>persTables</code> are very small, e.g. &lt;10.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum iterations during a temperature step.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_temp.cooldown">temp.cooldown</code></td>
<td>
<p>a factor (between 0 and 1) specifying the rate at which
temperature will be reduced in each step.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_factor.cooldown">factor.cooldown</code></td>
<td>
<p>a factor (between 0 and 1) specifying the rate at
which the number of permutations of housholds, in each iteration, will be
reduced in each step.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_min.temp">min.temp</code></td>
<td>
<p>minimal temperature at which the algorithm will stop.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_nr_cpus">nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_sizefactor">sizefactor</code></td>
<td>
<p>the factor for inflating the population before applying 0/1 weights</p>
</td></tr>
<tr><td><code id="calibPop_+3A_choose.temp">choose.temp</code></td>
<td>
<p>if TRUE <code>temp</code> will be rescaled according to <code>eps</code> and <code>choose.temp.factor</code>. <code>eps</code> is defined by the product between <code>epsP.factor</code> and <code>epsP.factor</code> with the sum over the target population margins supplied by <code><a href="#topic+addKnownMargins">addKnownMargins</a></code> or <code>hhTables</code> and <code>persTables</code>.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_choose.temp.factor">choose.temp.factor</code></td>
<td>
<p>number between (0,1) for rescaling <code>temp</code> for simulated annealing. <code>temp</code> redefined by<code>max(temp,eps*choose.temp.factor)</code>.
Can be usefull if simulated annealing is split into subgroups with considerably different population sizes. Only used if <code>choose.temp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_scale.redraw">scale.redraw</code></td>
<td>
<p>Number between (0,1) scaling the number of households that need to be drawn and discarded in each iteration step.
The number of individuals currently selected through simulated annealing is substracted from the sum over the target population margins added to <code>inp</code> via <code>addKnownMargins</code>.
This difference is divided by the median household size resulting in an estimated number of housholds that the current synthetic population differs from the population margins (~<code>redraw_gap</code>).
The next iteration will then adjust the number of housholds to be drawn or discarded (<code>redraw</code>) according to <code>max(ceiling(redraw-redraw_gap*scale.redraw),1)</code> or <code>max(ceiling(redraw+redraw_gap*scale.redraw),1)</code> respectively.
This keeps the number of individuals in the synthetic population relatively stable regarding the population margins. Otherwise the synthetic population might be considerably larger or smaller then the population margins, through selection of many large or small households.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_observe.times">observe.times</code></td>
<td>
<p>Number of times the new value of the objective function is saved. If <code>observe.times=0</code> values are not saved.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_observe.break">observe.break</code></td>
<td>
<p>When objective value has been saved <code>observe.times</code>-times the coefficient of variation is calculated over saved values; if the coefficient of variation falls below <code>observe.break</code>
simmulated annealing terminates. This repeats for each new set of <code>observe.times</code> new values of the objecive function. Can help save run time if objective value does not improve much. Disable this termination by either setting <code>observe.times=0</code> or <code>observe.break=0</code>.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_n.forcecooldown">n.forceCooldown</code></td>
<td>
<p>integer, if the solution does not move for <code>n.forceCooldown</code> iterations then a cooldown is automatically done.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_verbose">verbose</code></td>
<td>
<p>boolean variable; if TRUE some additional verbose output is
provided, however only if <code>split</code> is NULL. Otherwise the computation is
performed in parallel and no useful output can be provided.</p>
</td></tr>
<tr><td><code id="calibPop_+3A_hhtables">hhTables</code></td>
<td>
<p>information on population margins for households</p>
</td></tr>
<tr><td><code id="calibPop_+3A_perstables">persTables</code></td>
<td>
<p>information on population margins for persons</p>
</td></tr>
<tr><td><code id="calibPop_+3A_redist.var">redist.var</code></td>
<td>
<p>single column in the population which can be redistributed in each 'split'. Still experimental!</p>
</td></tr>
<tr><td><code id="calibPop_+3A_redist.var.factor">redist.var.factor</code></td>
<td>
<p>numeric in the interval (0,1]. Used in combinationo with 'redist.var', still experimental!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calibrates data using simulated annealing. The algorithm searches for a
(near) optimal combination of different households, by swaping housholds at
random in each iteration of each temperature level. During the algorithm as
well as for the output the optimal (or so far best) combination will be
indicated by a logical vector containg only 0s (not inculded) and 1s
(included in optimal selection). The objective function for simulated
annealing is defined by the sum of absolute differences between target
marginals and synthetic marginals (=marginals of synthetic dataset). The sum
of target marginals can at most be as large as the sum of target marginals.
For every factor-level in &ldquo;split&rdquo;, data must at least contain as many
entries of this kind as target marginals.
</p>
<p>Possible donors are automatically generated within the procedure.
</p>
<p>The number of cpus are selected automatically in the following manner. The
number of cpus is equal the number of strata. However, if the number of cpus
is less than the number of strata, the number of cpus - 1 is used by
default.  This should be the best strategy, but the user can also overwrite
this decision.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> with an
updated population listed in slot 'pop'.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl, Johannes Gussenbauer and Matthias Templ
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS) # load sample data
data(eusilcP) # population data
## Not run: 
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
simPop &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
simPop &lt;- simCategorical(simPop, additional=c("pl030", "pb220a"), method="multinom", nr_cpus=1)

# add margins
margins &lt;- as.data.frame(
  xtabs(rep(1, nrow(eusilcP)) ~ eusilcP$region + eusilcP$gender + eusilcP$citizenship))
colnames(margins) &lt;- c("db040", "rb090", "pb220a", "freq")
simPop &lt;- addKnownMargins(simPop, margins)
simPop_adj2 &lt;- calibPop(simPop, split="db040", 
  temp=1, epsP.factor=0.1,
 epsMinN=10, nr_cpus = 1)

## End(Not run)
# apply simulated annealing
## Not run: 
simPop_adj &lt;- calibPop(simPop, split="db040", temp=1,
epsP.factor=0.1,nr_cpus = 1)

## End(Not run)
## Not run: 
### use multiple different margins
# person margins
persTables &lt;- as.data.frame(
xtabs(rep(1, nrow(eusilcP)) ~ eusilcP$region + eusilcP$gender + eusilcP$citizenship))
colnames(persTables) &lt;- c("db040", "rb090", "pb220a", "Freq")

# household margins
filter_hid &lt;- !duplicated(eusilcP$hid)
eusilcP$hsize4 &lt;- pmin(4,as.numeric(eusilcP$hsize))
hhTables &lt;- as.data.frame(
  xtabs(rep(1, sum(filter_hid)) ~ eusilcP[filter_hid,]$region+eusilcP[filter_hid,]$hsize4))
colnames(hhTables) &lt;- c("db040", "hsize4", "Freq")
simPop@pop@data$hsize4 &lt;- pmin(4,as.numeric(simPop@pop@data$hsize))

simPop_adj_2 &lt;- calibPop(simPop, split="db040", 
                         temp=1, epsP.factor=0.1,
                         epsH.factor = 0.1,
                         persTables = persTables,
                         hhTables = hhTables,
                         nr_cpus = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='calibSample'>Calibrate sample weights</h2><span id='topic+calibSample'></span><span id='topic+calibSample+2Cdf_or_dataObj_or_simPopObj+2CdataFrame_or_Table-method'></span>

<h3>Description</h3>

<p>Calibrate sample weights according to known marginal population totals.
Based on initial sample weights, the so-called <em>g</em>-weights are computed
by generalized raking procedures.
</p>


<h3>Details</h3>

<p>The methods return a list containing both the <em>g</em>-weights (slot
<code>g_weights</code>) as well as the final weights (slot <code>final_weights</code>)
(initial sampling weights adjusted by the <em>g</em>-weights.
</p>


<h3>Methods</h3>

<p>The function provides methods with the following
signatures.  </p>
<dl>
<dt>list(&quot;signature(inp=\&quot;df_or_dataObj_or_simPopObj\&quot;,
totals=\&quot;dataFrame_or_Table\&quot;,...)&quot;)</dt><dd><p> Argument 'inp' must be an object of
class <code>data.frame</code>, <code><a href="#topic+dataObj-class">dataObj</a></code> or
<code><a href="#topic+simPopObj-class">simPopObj</a></code> and the totals must be specified in either
objects of class <code>table</code> or <code>data.frame</code>. If argument 'totals' is
a data.frame it must be provided in a way that in the first columns
n-columns the combinations of variables are listed. In the last column, the
frequency counts must be specified. Furthermore, variable names of all but
the last column must be available also from the sample data specified in
argument 'inp'. If argument 'total' is a table (e.g. created with function
<code><a href="#topic+tableWt">tableWt</a></code>, it must be made sure that the dimnames match the
variable names (and levels) of the specified input data set.  </p>
</dd> </dl>



<h3>Note</h3>

<p>This is a faster implementation of parts of
<code><a href="sampling.html#topic+calib">calib</a></code> from package <code>sampling</code>. Note that the
default calibration method is raking and that the truncated linear method is
not yet implemented.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Bernhard Meindl
</p>


<h3>References</h3>

<p>Deville, J.-C. and Saerndal, C.-E. (1992)
Calibration estimators in survey sampling. <em>Journal of the American
Statistical Association</em>, <b>87</b>(418), 376&ndash;382.  Deville, J.-C.,
Saerndal, C.-E. and Sautory, O. (1993) Generalized raking
procedures in survey sampling. <em>Journal of the American Statistical
Association</em>, <b>88</b>(423), 1013&ndash;1020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
eusilcS$agecut &lt;- cut(eusilcS$age, 7)
## Not run: 
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")

## for simplicity, we are using population data directly from the sample, but you get the idea
totals1 &lt;- tableWt(eusilcS[, c("agecut","rb090")], weights=eusilcS$rb050)
totals2 &lt;- tableWt(eusilcS[, c("rb090","agecut")], weights=eusilcS$rb050)
totals3 &lt;- tableWt(eusilcS[, c("rb090","agecut","db040")], weights=eusilcS$rb050)
totals4 &lt;- tableWt(eusilcS[, c("agecut","db040","rb090")], weights=eusilcS$rb050)

weights1 &lt;- calibSample(inp, totals1)
totals1.df &lt;- as.data.frame(totals1)
weights1.df &lt;- calibSample(inp, totals1.df)
identical(weights1, weights1.df)

# we can also use a data.frame and an optional weight vector as input
df &lt;- as.data.frame(inp@data)
w &lt;- inp@data[[inp@weight]]
weights1.x &lt;- calibSample(df, totals1.df, w=inp@data[[inp@weight]])
identical(weights1, weights1.x)

weights2 &lt;- calibSample(inp, totals2)
totals2.df &lt;- as.data.frame(totals2)
weights2.df &lt;- calibSample(inp, totals2.df)
identical(weights2, weights2.df)

## End(Not run)

## Not run: 
## approx 10 seconds computation time ...
weights3 &lt;- calibSample(inp, totals3)
totals3.df &lt;- as.data.frame(totals3)
weights3.df &lt;- calibSample(inp, totals3.df)
identical(weights3, weights3.df)

## approx 10 seconds computation time ...
weights4 &lt;- calibSample(inp, totals4)
totals4.df &lt;- as.data.frame(totals4)
weights4.df &lt;- calibSample(inp, totals4.df)
identical(weights4, weights4.df)

## End(Not run)
</code></pre>

<hr>
<h2 id='calibVars'>Construct a matrix of binary variables for calibration</h2><span id='topic+calibVars'></span>

<h3>Description</h3>

<p>Construct a matrix of binary variables for calibration of sample weights
according to known marginal population totals. The following methods
are implemented:
</p>

<ul>
<li> <p><code>calibVars.default(x)</code>
</p>
</li>
<li> <p><code>calibVars.matrix(x)</code>
</p>
</li>
<li> <p><code>calibVars.matrix(x)</code>
</p>
</li>
<li> <p><code>calibVars.data.frame(x)</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>calibVars(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibVars_+3A_x">x</code></td>
<td>
<p>a vector that can be interpreted as factor, or a matrix or
<code>data.frame</code> consisting of such variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of binary variables that indicate membership to the
corresponding factor levels.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl and Andreas Alfons
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. doi: 10.18637/jss.v079.i10
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibSample">calibSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
# default method
## Not run: 
aux &lt;- calibVars(eusilcS$rb090)
head(aux)
# data.frame method
aux &lt;- calibVars(eusilcS[, c("db040", "rb090")])
head(aux)

## End(Not run)
</code></pre>

<hr>
<h2 id='contingencyWt'>Weighted contingency coefficients</h2><span id='topic+contingencyWt'></span>

<h3>Description</h3>

<p>Compute (weighted) pairwise contingency coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contingencyWt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contingencyWt_+3A_x">x</code></td>
<td>
<p>for the default method, a vector that can be interpreted as factor.
For the matrix and <code>data.frame</code> methods, the columns should be
interpretable as factors.</p>
</td></tr>
<tr><td><code id="contingencyWt_+3A_...">...</code></td>
<td>
<p>for the generic function, arguments to be passed down to the
methods, otherwise ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+tableWt">tableWt</a></code> is used for the computation of the
corresponding pairwise contingency tables. The following methods are implemented:
</p>

<ul>
<li> <p><code>contingencyWt.default(x, y, weights = NULL, ...)</code>
</p>
</li>
<li> <p><code>contingencyWt.matrix(x, weights = NULL, ...)</code>
</p>
</li>
<li> <p><code>contingencyWt.data.frame(x, weights = NULL, ...)</code>
</p>
</li></ul>

<p>Additional parameters are:
</p>

<ul>
<li><p> y: a vector that can be interpreted as factor (for the default method)
</p>
</li>
<li><p> weights: an optional numeric vector containing sample weights
</p>
</li></ul>



<h3>Value</h3>

<p>For the default method, the (weighted) contingency coefficient of
<code>x</code> and <code>y</code>.
</p>
<p>For the matrix and <code>data.frame</code> method, a matrix of (weighted) pairwise
contingency coefficients for all combinations of columns.  Elements below
the diagonal are <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Stefan Kraft
</p>


<h3>References</h3>

<p>Kendall, M.G. and Stuart, A. (1967) <em>The Advanced Theory of
Statistics, Volume 2: Inference and Relationship</em>. Charles Griffin &amp; Co Ltd,
London, 2nd edition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tableWt">tableWt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)

## default method
contingencyWt(eusilcS$pl030, eusilcS$pb220a, weights = eusilcS$rb050)

## data.frame method
basic &lt;- c("age", "rb090", "hsize", "pl030", "pb220a")
contingencyWt(eusilcS[, basic], weights = eusilcS$rb050)
</code></pre>

<hr>
<h2 id='correctHeaps'>Correct  age heaping</h2><span id='topic+correctHeaps'></span>

<h3>Description</h3>

<p>Correct for age heaping using truncated (log-)normal distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctHeaps(x, heaps = "10year", method = "lnorm", start = 0, fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctHeaps_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="correctHeaps_+3A_heaps">heaps</code></td>
<td>

<ul>
<li> <p><code>5year</code>: heaps are assumed to be every 5 years (0,5,10,...)
</p>
</li>
<li> <p><code>10year</code>: heaps are assumed to be every 10 years (0,10,20,...)
</p>
</li></ul>
</td></tr>
<tr><td><code id="correctHeaps_+3A_method">method</code></td>
<td>
<p>a character specifying the algorithm used to correct the age
heaps. Allowed values are
</p>

<ul>
<li> <p><code>lnorm</code>: drawing from a truncated log-normal distribution. The
required parameters are estimated using original input data.
</p>
</li>
<li> <p><code>norm</code>: drawing from a truncated normal distribution. The
required parameters are estimated using original input data.
</p>
</li>
<li> <p><code>unif</code>: random sampling from a (truncated) uniform distribution
</p>
</li></ul>
</td></tr>
<tr><td><code id="correctHeaps_+3A_start">start</code></td>
<td>
<p>a numeric value for the starting of the 5 or 10 year sequences
(e.g. 0, 5 or 10)</p>
</td></tr>
<tr><td><code id="correctHeaps_+3A_fixed">fixed</code></td>
<td>
<p>numeric index vector with observation that should not be changed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Age heaping can cause substantial bias
in important measures and thus age heaping should be corrected. 
</p>
<p>For method &ldquo;lnorm&rdquo;, a truncated log-normal is fit to the whole age distribution. 
Then for each age heap (at 0, 5, 10, 15, ...) random numbers of a truncated 
log-normal (with lower and upper bound) is drawn in the 
interval +- 2 around the heap (rounding of degree 2) 
using the inverse transformation method. A ratio of randomly 
chosen observations on an age heap are replaced 
by these random draws. For the ratio the age distribution is chosen, whereas 
on an age heap (e.g. 5)
the arithmetic means of the two neighboring ages are calculated 
(average counts on age 4 and age 6 for age heap equals 5, for example).
The ratio on, e.g. age equals 5 is then given by the count on age 5 divided by this mean
This is done for any age heap at (0, 5, 10, 15, ...). 
</p>
<p>Method &ldquo;norm&rdquo; replace the draws from truncated log-normals to draws from 
truncated normals. It depends on the age distrubution (if right-skewed or not) if method
&ldquo;lnorm&rdquo; or &ldquo;norm&rdquo; should be used. Many distributions with heaping problems
are right-skewed.
</p>
<p>Method &ldquo;unif&rdquo; draws the mentioned ratio of observations on truncated uniform distributions
around the age heaps.
</p>
<p>Repeated calls of this function mimics multiple imputation, i.e. repeating this 
procedure m times provides m imputed datasets that properly reflect the 
uncertainty from imputation.
</p>


<h3>Value</h3>

<p>a numeric vector without age heaps
</p>


<h3>Author(s)</h3>

<p>Matthias Templ, Bernhard Meindl, Alexander Kowarik
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. doi: 10.18637/jss.v079.i10
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create some artificial data
age &lt;- rlnorm(10000, meanlog=2.466869, sdlog=1.652772)
age &lt;- round(age[age &lt; 93])
barplot(table(age))

## artificially introduce age heaping and correct it:
# heaps every 5 years
year5 &lt;- seq(0, max(age), 5)
age5 &lt;- sample(c(age, age[age %in% year5]))
cc5 &lt;- rep("darkgrey", length(unique(age)))
cc5[year5+1] &lt;- "yellow"
barplot(table(age5), col=cc5)
barplot(table(correctHeaps(age5, heaps="5year", method="lnorm")), col=cc5)

# heaps every 10 years
year10 &lt;- seq(0, max(age), 10)
age10 &lt;- sample(c(age, age[age %in% year10]))
cc10 &lt;- rep("darkgrey", length(unique(age)))
cc10[year10+1] &lt;- "yellow"
barplot(table(age10), col=cc10)
barplot(table(correctHeaps(age10, heaps="10year", method="lnorm")), col=cc10)

# the first 5 observations should be unchanged
barplot(table(correctHeaps(age10, heaps="10year", method="lnorm", fixed=1:5)), col=cc10)

</code></pre>

<hr>
<h2 id='correctSingleHeap'>correctSingleHeap</h2><span id='topic+correctSingleHeap'></span>

<h3>Description</h3>

<p>Correct a specific age heap in a vector containing age in years
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctSingleHeap(
  x,
  heap,
  before = 2,
  after = 2,
  method = "lnorm",
  fixed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctSingleHeap_+3A_x">x</code></td>
<td>
<p>numeric vector representing age in years (integers)</p>
</td></tr>
<tr><td><code id="correctSingleHeap_+3A_heap">heap</code></td>
<td>
<p>numeric or integer vector of length 1 specifying the year
for which a heap should be corrected</p>
</td></tr>
<tr><td><code id="correctSingleHeap_+3A_before">before</code></td>
<td>
<p>numeric or integer vector of length 1 specifying the number
of years before the heap that may be used to correct the heap. This input will
be rounded!</p>
</td></tr>
<tr><td><code id="correctSingleHeap_+3A_after">after</code></td>
<td>
<p>numeric or integer vector of length 1 specifying the number
of years after the heap that may be used to correct the heap. This input will
be rounded!
</p>

<ul>
<li> <p><code>5year</code>: heaps are assumed to be every 5 years (0,5,10,...)
</p>
</li>
<li> <p><code>10year</code>: heaps are assumed to be every 10 years (0,10,20,...)
</p>
</li></ul>
</td></tr>
<tr><td><code id="correctSingleHeap_+3A_method">method</code></td>
<td>
<p>a character specifying the algorithm used to correct the age
heaps. Allowed values are
</p>

<ul>
<li> <p><code>lnorm</code>: drawing from a truncated log-normal distribution. The
required parameters are estimated using original input data.
</p>
</li>
<li> <p><code>norm</code>: drawing from a truncated normal distribution. The
required parameters are estimated using original input data.
</p>
</li>
<li> <p><code>unif</code>: random sampling from a (truncated) uniform distribution
</p>
</li></ul>
</td></tr>
<tr><td><code id="correctSingleHeap_+3A_fixed">fixed</code></td>
<td>
<p>numeric index vector with observation that should not be changed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector without age heaps
</p>


<h3>Author(s)</h3>

<p>Matthias Templ, Bernhard Meindl, Alexander Kowarik
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create some artificial data
age &lt;- rlnorm(10000, meanlog=2.466869, sdlog=1.652772)
age &lt;- round(age[age &lt; 93])
barplot(table(age))

## artificially introduce an age heap for a specific year
## and correct it
age23 &lt;- c(age, rep(23, length=sum(age==23)))
cc23 &lt;- rep("darkgrey", length(unique(age)))
cc23[24] &lt;- "yellow"
barplot(table(age23), col=cc23)
barplot(table(correctSingleHeap(age23, heap=23, before=2, after=3, method="lnorm")), col=cc23)
barplot(table(correctSingleHeap(age23, heap=23, before=5, after=5, method="lnorm")), col=cc23)

# the first 5 observations should be unchanged
barplot(table(correctSingleHeap(age23, heap=23, before=5, after=5, method="lnorm",
  fixed=1:5)), col=cc23)
</code></pre>

<hr>
<h2 id='crossValidation'>Simulate variables of population data by cross validation</h2><span id='topic+crossValidation'></span>

<h3>Description</h3>

<p>Simulate variables of population data. The household structure
of the population data needs to be simulated beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossValidation(
  simPopObj,
  additionals,
  hyper_param_grid,
  fold = 3,
  method = c("xgboost"),
  type = c("categorical"),
  by = "strata",
  regModel = "available",
  nr_cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossValidation_+3A_simpopobj">simPopObj</code></td>
<td>
<p>a <code>simPopObj</code> containing population and household
survey data as well as optionally margins in standardized format.</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_additionals">additionals</code></td>
<td>
<p>a character vector specifying additional categorical
variables available in the sample object of <code>simPopObj</code> that should be
simulated for the population data.</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_hyper_param_grid">hyper_param_grid</code></td>
<td>
<p>a grid which can contain model specific parameters which will be passed onto the function call for the respective model.</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_fold">fold</code></td>
<td>
<p>the number of k in k-fold crossvalidation</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to be used for
simulating the additional categorical variables. Accepted value at the moment
only 
<code>"xgboost"</code>  for using xgboost (implementation in package xgboost)</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_type">type</code></td>
<td>
<p>currently only &quot;categorical&quot; is implemented</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_by">by</code></td>
<td>
<p>defining which variable to use as split up variable of the estimation. Defaults to the strata variable.</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_regmodel">regModel</code></td>
<td>
<p>allows to specify the variables or model that is used when
simulating additional categorical variables. The following choices are
available if different from NULL.  </p>
 <ul>
<li><p>'basic'only the basic
household variables (generated with <code><a href="#topic+simStructure">simStructure</a></code>) are used.
</p>
</li>
<li><p>'available'all available variables (that are common in the sample and
the synthetic population such as previously generated varaibles) excluding
id-variables, strata variables and household sizes are used for the
modelling. This parameter should be used with care because all factors are
automatically used as factors internally.  </p>
</li>
<li><p> formula-objectUsers may also
specify a specifiy formula (class 'formula') that will be used. Checks are
performed that all required variables are available.  </p>
</li></ul>
<p> If method
'distribution' is used, it is only possible to specify a vector of length
one containing one of the choices described above.  If parameter 'regModel'
is NULL, only basic household variables are used in any case.</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_nr_cpus">nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_verbose">verbose</code></td>
<td>
<p>set to TRUE if additional print output should be shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of cpus are selected automatically in the following manner. The
number of cpus is equal the number of strata. However, if the number of cpus
is less than the number of strata, the number of cpus - 1 is used by
default. This should be the best strategy, but the user can also overwrite
this decision.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing survey
data as well as the simulated population data including the categorical
variables specified by argument <code>additional</code>.
</p>


<h3>Note</h3>

<p>The basic household structure needs to be simulated beforehand with
the function <code><a href="#topic+simStructure">simStructure</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl, Andreas Alfons, Stefan Kraft, Alexander Kowarik, Matthias Templ, Siro Fritzmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simStructure">simStructure</a></code>, <code><a href="#topic+simRelation">simRelation</a></code>,
<code><a href="#topic+simContinuous">simContinuous</a></code>, <code><a href="#topic+simComponents">simComponents</a></code>, <code><a href="#topic+simCategorical">simCategorical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS) # load sample data
## Not run: 
## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
## in the following, nr_cpus are selected automatically
simPop &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
grid &lt;- expand.grid(nrounds = c(5, 10),
                    max_depth = 10,
                    eta = c(0.2, 0.3, 0.5),
                    eval_metric = "mlogloss",
                    stringsAsFactors = FALSE)

simPop &lt;- crossValidation(simPop, additionals=c("pl030", "pb220a"),
nr_cpus=1, hyper_param_grid = grid)
simPop

## End(Not run)
</code></pre>

<hr>
<h2 id='dataObj-class'>Class <code>"dataObj"</code></h2><span id='topic+dataObj-class'></span><span id='topic+show+2CdataObj-method'></span>

<h3>Description</h3>

<p>Objects of this class contain information on a population or survey.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("dataObj", ...)</code> but are usually automatically created when using
<code><a href="#topic+simStructure">simStructure</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl and Matthias Templ
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simPopObj-class">simPopObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("dataObj")

## show method, generate an object of class dataObj first
data(eusilcS)
inp &lt;- specifyInput(data=eusilcS, hhid="db030", weight="rb050", strata="db040")
## shows some basic information:
inp

</code></pre>

<hr>
<h2 id='eusilc13puf'>Synthetic EU-SILC 2013 survey data</h2><span id='topic+eusilc13puf'></span>

<h3>Description</h3>

<p>This data set is synthetically generated from real Austrian EU-SILC
(European Union Statistics on Income and Living Conditions) data 2013.
</p>


<h3>Format</h3>

<p>A data frame with 13513 observations on the following 62 variables.
</p>

<dl>
<dt>db030</dt><dd><p>integer; the household ID.</p>
</dd>
<dt>hsize</dt><dd><p>integer; the number of persons in the household.</p>
</dd>
<dt>db040</dt><dd><p>factor; the federal state in which the household is
located (levels <code>Burgenland</code>, <code>Carinthia</code>, <code>Lower Austria</code>,
<code>Salzburg</code>, <code>Styria</code>, <code>Tyrol</code>, <code>Upper Austria</code>,
<code>Vienna</code> and <code>Vorarlberg</code>).</p>
</dd>
<dt>age</dt><dd><p>integer; the
person's age.</p>
</dd>
<dt>rb090</dt><dd><p>factor; the person's gender (levels
<code>male</code> and <code>female</code>).</p>
</dd>
<dt>pid</dt><dd><p>personal ID</p>
</dd>
<dt>weight</dt><dd><p>sampling weights</p>
</dd>
<dt>pl031</dt><dd><p>factor; the person's
economic status (levels <code>1</code> = working full time, <code>2</code> = working
part time, <code>3</code> = unemployed, <code>4</code> = pupil, student, further
training or unpaid work experience or in compulsory military or community
service, <code>5</code> = in retirement or early retirement or has given up
business, <code>6</code> = permanently disabled or/and unfit to work or other
inactive person, <code>7</code> = fulfilling domestic tasks and care
responsibilities).</p>
</dd>
<dt>pb220a</dt><dd><p>factor; the person's citizenship
(levels <code>AT</code>, <code>EU</code> and <code>Other</code>).</p>
</dd>
<dt>pb190</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>pe040</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>pl111</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>pgrossIncomeCat</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>pgrossIncome</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hgrossIncomeCat</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hgrossIncome</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hgrossminusCat</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hgrossminus</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py010g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py021g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py050g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py080g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py090g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py100g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py110g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py120g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py130g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>py140g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy040g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy050g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy060g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy070g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy080g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy090g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy100g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy110g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy120g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy130g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy140g</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>rb250</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>p119000</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>p038003f</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>p118000i</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>aktivi</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>erwintensneu</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>rb050</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>pb040</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hb030</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>px030</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>rx030</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>pb030</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>rb030</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hx040</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>pb150</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>rx020</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>px020</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hx050</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>eqInc</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy010</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy020</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy022</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
<dt>hy023</dt><dd><p>for details, see Eurostat's code book</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set consists of 5977 households and is used as sample data in some
of the examples in package <code>simPop</code>.  Note that it is included
for illustrative purposes only.  The sample weights do not reflect the true
population sizes of Austria and its regions.
</p>
<p>62 variables of the original survey are
simulated for this example data set.  The variable names are rather cryptic
codes, but these are the standardized names used by the statistical
agencies.  Furthermore, the variables <code>hsize</code>, <code>age</code> and
<code>netIncome</code> are not included in the standardized format of EU-SILC
data, but have been derived from other variables for convenience.
</p>


<h3>Author(s)</h3>

<p>Matthias Templ
</p>


<h3>Source</h3>

<p>This is a synthetic data set based on Austrian EU-SILC data from
2013.  The original sample was provided by Statistics Austria.
</p>


<h3>References</h3>

<p>Eurostat (2013) Description of target variables: Cross-sectional
and longitudinal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilc13puf)
str(eusilc13puf)
</code></pre>

<hr>
<h2 id='eusilcP'>Synthetic EU-SILC data</h2><span id='topic+eusilcP'></span>

<h3>Description</h3>

<p>This data set is synthetically generated from real Austrian EU-SILC
(European Union Statistics on Income and Living Conditions) data.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> with 58 654 observations on the following 28
variables: </p>
 <dl>
<dt>hid</dt><dd><p>integer; the household ID.</p>
</dd>
<dt>region</dt><dd><p>factor; the federal state in which the household is
located (levels <code>Burgenland</code>, <code>Carinthia</code>, <code>Lower Austria</code>,
<code>Salzburg</code>, <code>Styria</code>, <code>Tyrol</code>, <code>Upper Austria</code>,
<code>Vienna</code> and <code>Vorarlberg</code>).</p>
</dd> <dt>hsize</dt><dd><p>integer; the
number of persons in the household.</p>
</dd> <dt>eqsize</dt><dd><p>numeric; the
equivalized household size according to the modified OECD scale.</p>
</dd>
<dt>eqIncome</dt><dd><p>numeric; a simplified version of the equivalized
household income.</p>
</dd> <dt>pid</dt><dd><p>integer; the personal ID.</p>
</dd>
<dt>id</dt><dd><p>the household ID combined with the personal ID.  The first five
digits represent the household ID, the last two digits the personal ID (both
with leading zeros).</p>
</dd> <dt>age</dt><dd><p>integer; the person's age.</p>
</dd>
<dt>gender</dt><dd><p>factor; the person's gender (levels <code>male</code> and
<code>female</code>).</p>
</dd> <dt>ecoStat</dt><dd><p>factor; the person's economic status
(levels <code>1</code> = working full time, <code>2</code> = working part time, <code>3</code>
= unemployed, <code>4</code> = pupil, student, further training or unpaid work
experience or in compulsory military or community service, <code>5</code> = in
retirement or early retirement or has given up business, <code>6</code> =
permanently disabled or/and unfit to work or other inactive person, <code>7</code>
= fulfilling domestic tasks and care responsibilities).</p>
</dd>
<dt>citizenship</dt><dd><p>factor; the person's citizenship (levels
<code>AT</code>, <code>EU</code> and <code>Other</code>).</p>
</dd> <dt>py010n</dt><dd><p>numeric;
employee cash or near cash income (net).</p>
</dd> <dt>py050n</dt><dd><p>numeric;
cash benefits or losses from self-employment (net).</p>
</dd>
<dt>py090n</dt><dd><p>numeric; unemployment benefits (net).</p>
</dd>
<dt>py100n</dt><dd><p>numeric; old-age benefits (net).</p>
</dd>
<dt>py110n</dt><dd><p>numeric; survivor's benefits (net).</p>
</dd>
<dt>py120n</dt><dd><p>numeric; sickness benefits (net).</p>
</dd>
<dt>py130n</dt><dd><p>numeric; disability benefits (net).</p>
</dd>
<dt>py140n</dt><dd><p>numeric; education-related allowances (net).</p>
</dd>
<dt>hy040n</dt><dd><p>numeric; income from rental of a property or land
(net).</p>
</dd> <dt>hy050n</dt><dd><p>numeric; family/children related allowances
(net).</p>
</dd> <dt>hy070n</dt><dd><p>numeric; housing allowances (net).</p>
</dd>
<dt>hy080n</dt><dd><p>numeric; regular inter-household cash transfer
received (net).</p>
</dd> <dt>hy090n</dt><dd><p>numeric; interest, dividends, profit
from capital investments in unincorporated business (net).</p>
</dd>
<dt>hy110n</dt><dd><p>numeric; income received by people aged under 16
(net).</p>
</dd> <dt>hy130n</dt><dd><p>numeric; regular inter-household cash transfer
paid (net).</p>
</dd> <dt>hy145n</dt><dd><p>numeric; repayments/receipts for tax
adjustment (net).</p>
</dd> <dt>main</dt><dd><p>logical; indicates the main income
holder (i.e., the person with the highest income) of each household.</p>
</dd> </dl>



<h3>Details</h3>

<p>The data set is used as population data in some of the examples in package
<code>simFrame</code>.  Note that it is included for illustrative purposes only.
It consists of 25 000 households, hence it does not represent the true
population sizes of Austria and its regions.
</p>
<p>Only a few of the large number of variables in the original survey are
included in this example data set.  Some variable names are different from
the standardized names used by the statistical agencies, as the latter are
rather cryptic codes.  Furthermore, the variables <code>hsize</code>,
<code>eqsize</code>, <code>eqIncome</code> and <code>age</code> are not included in the
standardized format of EU-SILC data, but have been derived from other
variables for convenience.  Moreover, some very sparse income components
were not included in the the generation of this synthetic data set. Thus the
equivalized household income is computed from the available income
components.
</p>


<h3>Source</h3>

<p>This is a synthetic data set based on Austrian EU-SILC data from
2006.  The original sample was provided by Statistics Austria.
</p>


<h3>References</h3>

<p>Eurostat (2004) Description of target variables: Cross-sectional
and longitudinal. <em>EU-SILC 065/04</em>, Eurostat.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcP)
summary(eusilcP)
</code></pre>

<hr>
<h2 id='eusilcS'>Synthetic EU-SILC survey data</h2><span id='topic+eusilcS'></span>

<h3>Description</h3>

<p>This data set is synthetically generated from real Austrian EU-SILC
(European Union Statistics on Income and Living Conditions) data.
</p>


<h3>Format</h3>

<p>A data frame with 11725 observations on the following 18 variables.
</p>
 <dl>
<dt>db030</dt><dd><p>integer; the household ID.</p>
</dd>
<dt>hsize</dt><dd><p>integer; the number of persons in the household.</p>
</dd>
<dt>db040</dt><dd><p>factor; the federal state in which the household is
located (levels <code>Burgenland</code>, <code>Carinthia</code>, <code>Lower Austria</code>,
<code>Salzburg</code>, <code>Styria</code>, <code>Tyrol</code>, <code>Upper Austria</code>,
<code>Vienna</code> and <code>Vorarlberg</code>).</p>
</dd> <dt>age</dt><dd><p>integer; the
person's age.</p>
</dd> <dt>rb090</dt><dd><p>factor; the person's gender (levels
<code>male</code> and <code>female</code>).</p>
</dd> <dt>pl030</dt><dd><p>factor; the person's
economic status (levels <code>1</code> = working full time, <code>2</code> = working
part time, <code>3</code> = unemployed, <code>4</code> = pupil, student, further
training or unpaid work experience or in compulsory military or community
service, <code>5</code> = in retirement or early retirement or has given up
business, <code>6</code> = permanently disabled or/and unfit to work or other
inactive person, <code>7</code> = fulfilling domestic tasks and care
responsibilities).</p>
</dd> <dt>pb220a</dt><dd><p>factor; the person's citizenship
(levels <code>AT</code>, <code>EU</code> and <code>Other</code>).</p>
</dd>
<dt>netIncome</dt><dd><p>numeric; the personal net income.</p>
</dd>
<dt>py010n</dt><dd><p>numeric; employee cash or near cash income (net).</p>
</dd>
<dt>py050n</dt><dd><p>numeric; cash benefits or losses from self-employment
(net).</p>
</dd> <dt>py090n</dt><dd><p>numeric; unemployment benefits (net).</p>
</dd>
<dt>py100n</dt><dd><p>numeric; old-age benefits (net).</p>
</dd>
<dt>py110n</dt><dd><p>numeric; survivor's benefits (net).</p>
</dd>
<dt>py120n</dt><dd><p>numeric; sickness benefits (net).</p>
</dd>
<dt>py130n</dt><dd><p>numeric; disability benefits (net).</p>
</dd>
<dt>py140n</dt><dd><p>numeric; education-related allowances (net).</p>
</dd>
<dt>db090</dt><dd><p>numeric; the household sample weights.</p>
</dd>
<dt>rb050</dt><dd><p>numeric; the personal sample weights.</p>
</dd> </dl>



<h3>Details</h3>

<p>The data set consists of 4641 households and is used as sample data in some
of the examples in package <code>simPopulation</code>.  Note that it is included
for illustrative purposes only.  The sample weights do not reflect the true
population sizes of Austria and its regions.  The resulting population data
is about 100 times smaller than the real population size to save computation
time.
</p>
<p>Only a few of the large number of variables in the original survey are
included in this example data set.  The variable names are rather cryptic
codes, but these are the standardized names used by the statistical
agencies.  Furthermore, the variables <code>hsize</code>, <code>age</code> and
<code>netIncome</code> are not included in the standardized format of EU-SILC
data, but have been derived from other variables for convenience.
</p>


<h3>Source</h3>

<p>This is a synthetic data set based on Austrian EU-SILC data from
2006.  The original sample was provided by Statistics Austria.
</p>


<h3>References</h3>

<p>Eurostat (2004) Description of target variables: Cross-sectional
and longitudinal. <em>EU-SILC 065/04</em>, Eurostat.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
summary(eusilcS)
</code></pre>

<hr>
<h2 id='get_set-methods'>Extract and modify variables from population or sample data stored in an
object of class <code><a href="#topic+simPopObj-class">simPopObj-class</a></code>.</h2><span id='topic+get_set-methods'></span><span id='topic+pop'></span><span id='topic+pop+3C-'></span><span id='topic+pop+2CsimPopObj-method'></span><span id='topic+pop+3C-+2CsimPopObj-method'></span><span id='topic+samp'></span><span id='topic+samp+3C-'></span><span id='topic+samp+2CsimPopObj-method'></span><span id='topic+samp+3C-+2CsimPopObj-method'></span><span id='topic+popData'></span><span id='topic+popData+2CsimPopObj-method'></span><span id='topic+sampleData+2CsimPopObj-method'></span><span id='topic+popObj'></span><span id='topic+popObj+3C-'></span><span id='topic+popObj+3C-+2CsimPopObj+2CdataObj-method'></span><span id='topic+popObj+2CsimPopObj-method'></span><span id='topic+sampleData'></span><span id='topic+sampleObj'></span><span id='topic+sampleObj+3C-'></span><span id='topic+sampleObj+2CsimPopObj-method'></span><span id='topic+sampleObj+3C-+2CsimPopObj+2CdataObj-method'></span><span id='topic+tableObj'></span><span id='topic+tableObj+2CsimPopObj-method'></span>

<h3>Description</h3>

<p>Using <code><a href="#topic+samp">samp</a></code> <code><a href="#topic+samp+3C-">samp&lt;-</a></code> it is possible to extract or
rather modify variables of the sample data within slot <code>data</code> in slot
<code>sample</code> of the <code><a href="#topic+simPopObj-class">simPopObj-class</a></code>-object. Using
<code><a href="#topic+pop">pop</a></code> <code><a href="#topic+pop+3C-">pop&lt;-</a></code> it is possible to extract or rather
modify variables of the synthetic population within in slot <code>data</code> in
slot <code>sample</code> of the <code><a href="#topic+simPopObj-class">simPopObj-class</a></code>-object.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_set-methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj-class</a></code></p>
</td></tr>
<tr><td><code id="get_set-methods_+3A_var">var</code></td>
<td>
<p>variable name or index for the variable in slot 'samp' of object
with the slot name to be accessed. If <code>NULL</code>, the entire dataset
(sample or population) is returned.</p>
</td></tr>
<tr><td><code id="get_set-methods_+3A_value">value</code></td>
<td>
<p>Content replacing whatever the variable in slot <code>var</code> in
<code>obj</code> currently holds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+simPopObj-class">simPopObj-class</a></code> with the
appropriate replacement.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simPopObj-class">simPopObj-class</a></code>,<code><a href="#topic+pop">pop</a></code>,
<code><a href="#topic+pop+3C-">pop&lt;-</a></code>, <code><a href="#topic+samp+3C-">samp&lt;-</a></code>, <code><a href="#topic+manageSimPopObj">manageSimPopObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)

inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040",
weight="db090")
simPopObj &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))

## get/set variables in sample-object of simPopObj
head(samp(simPopObj, var="age"))
samp(simPopObj, var="newVar") &lt;- 1
head(samp(simPopObj, var="newVar"))
## deleting is also possible
samp(simPopObj, var="newvar") &lt;- NULL
head(samp(simPopObj, var="newvar"))
## extract multiple variables
head(samp(simPopObj, var=c("db030","db040")))

## get/set variables in pop-object of simPopObj
head(pop(simPopObj, var="age"))
pop(simPopObj, var="newVar") &lt;- 1
head(pop(simPopObj, var="newVar"))
## deleting is also possible
pop(simPopObj, var="newvar") &lt;- NULL
head(pop(simPopObj, var="newvar"))
## extract multiple variables
head(pop(simPopObj, var=c("db030","db040")))


</code></pre>

<hr>
<h2 id='getBreaks'>Compute break points for categorizing (semi-)continuous variables</h2><span id='topic+getBreaks'></span>

<h3>Description</h3>

<p>Compute break points for categorizing continuous or semi-continuous
variables using (weighted) quantiles.  This is a utility function that is
useful for writing custom wrapper functions such as <code><a href="#topic+simEUSILC">simEUSILC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBreaks(
  x,
  weights = NULL,
  zeros = TRUE,
  lower = NULL,
  upper = NULL,
  equidist = TRUE,
  probs = NULL,
  strata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBreaks_+3A_x">x</code></td>
<td>
<p>a numeric vector to be categorized.</p>
</td></tr>
<tr><td><code id="getBreaks_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector containing sample weights.</p>
</td></tr>
<tr><td><code id="getBreaks_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether <code>x</code> is semi-continuous, i.e.,
contains a considerable amount of zeros. See &ldquo;Details&rdquo; on how this
affects the behavior of the function.</p>
</td></tr>
<tr><td><code id="getBreaks_+3A_lower">lower</code>, <code id="getBreaks_+3A_upper">upper</code></td>
<td>
<p>optional numeric values specifying lower and upper bounds
other than minimum and maximum of <code>x</code>, respectively.</p>
</td></tr>
<tr><td><code id="getBreaks_+3A_equidist">equidist</code></td>
<td>
<p>a logical indicating whether the (positive) break points
should be equidistant or whether there should be refinements in the lower
and upper tail (see &ldquo;Details&rdquo;).</p>
</td></tr>
<tr><td><code id="getBreaks_+3A_probs">probs</code></td>
<td>
<p>a numeric vector of probabilities with values in <code class="reqn">[0, 1]</code>
giving quantiles to be used as (positive) break points.  If supplied, this
is preferred over <code>equidist</code>.</p>
</td></tr>
<tr><td><code id="getBreaks_+3A_strata">strata</code></td>
<td>
<p>an optional vector specifying a strata variable (e.g household ids).
if specified, the mean of <code>x</code> (and also of <code>weights</code> if specified) is
computed within each strata before calculating the breaks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>equidist</code> is <code>TRUE</code>, the behavior is as follows.  If
<code>zeros</code> is <code>TRUE</code> as well, the 0%, 10%, ..., 90% quantiles
of the negative values and the 10%, 20%, ..., 100% of the positive
values are computed.  These quantiles are then used as break points together
with 0.  If <code>zeros</code> is not <code>TRUE</code>, on the other hand, the 0%,
10%, ..., 100% quantiles of all values are used.
</p>
<p>If <code>equidist</code> is not <code>TRUE</code>, the behavior is as follows.  If
<code>zeros</code> is not <code>TRUE</code>, the 1%, 5%, 10%, 20%, 40%, 60%, 80%,
90%, 95% and 99% quantiles of all values are used for the inner part of
the data (instead of the equidistant 10%, ..., 90% quantiles).  If
<code>zeros</code> is <code>TRUE</code>, these quantiles are only used for the positive
values while the quantiles of the negative values remain equidistant.
</p>
<p>Note that duplicated values among the quantiles are discarded and that the
minimum and maximum are replaced with <code>lower</code> and <code>upper</code>,
respectively, if these are specified.
</p>
<p>The (weighted) quantiles are computed with the function
<code><a href="#topic+quantileWt">quantileWt</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of break points.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Bernhard Meindl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCat">getCat</a></code>, <code><a href="#topic+quantileWt">quantileWt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)

# semi-continuous variable, positive break points equidistant
getBreaks(eusilcS$netIncome, weights=eusilcS$rb050)

# semi-continuous variable, positive break points not equidistant
getBreaks(eusilcS$netIncome, weights=eusilcS$rb050,
    equidist = FALSE)

</code></pre>

<hr>
<h2 id='getCat'>Categorize (semi-)continuous variables</h2><span id='topic+getCat'></span>

<h3>Description</h3>

<p>Categorize continuous or semi-continuous variables.  This is a utility
function that is useful for writing custom wrapper functions such as
<code><a href="#topic+simEUSILC">simEUSILC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCat(x, breaks, zeros = TRUE, right = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCat_+3A_x">x</code></td>
<td>
<p>a numeric vector to be categorized.</p>
</td></tr>
<tr><td><code id="getCat_+3A_breaks">breaks</code></td>
<td>
<p>a numeric vector of two or more break points.</p>
</td></tr>
<tr><td><code id="getCat_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether <code>x</code> is semi-continuous, i.e.,
contains a considerable amount of zeros.  See &ldquo;Details&rdquo; on how this
affects the behavior of the function.</p>
</td></tr>
<tr><td><code id="getCat_+3A_right">right</code></td>
<td>
<p>logical; if <code>zeros</code> is not <code>TRUE</code>, this indicates
whether the intervals should be closed on the right (and open on the left)
or vice versa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>zeros</code> is <code>TRUE</code>, 0 is added to the break points and treated
as its own factor level.  Consequently, intervals for negative values are
left-closed and right-open, whereas intervals for positive values are
left-open and right-closed.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code> containing the categories.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getBreaks">getBreaks</a></code>, <code><a href="base.html#topic+cut">cut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)

## semi-continuous variable
breaks &lt;- getBreaks(eusilcS$netIncome, 
    weights=eusilcS$rb050, equidist = FALSE)
netIncomeCat &lt;- getCat(eusilcS$netIncome, breaks)
summary(netIncomeCat)

</code></pre>

<hr>
<h2 id='ghanaS'>Synthetic GLSS survey data</h2><span id='topic+ghanaS'></span>

<h3>Description</h3>

<p>This data set is synthetically generated from real GLSS (Ghana Living
Standards Survey) data.
</p>


<h3>Format</h3>

<p>A data frame with 36970 observations on the following 14 variables.
</p>
 <dl>
<dt>hhid</dt><dd><p>integer; the household ID.</p>
</dd>
<dt>hsize</dt><dd><p>integer; the number of persons in the household.</p>
</dd>
<dt>region</dt><dd><p>factor; the region in which the household is located
(levels <code>western</code>, <code>central</code>, <code>greater accra</code>, <code>volta</code>,
<code>eastern</code>, <code>ashanti</code>, <code>brong ahafo</code>, <code>northern</code>,
<code>upper east</code> and <code>upper west</code>).</p>
</dd> <dt>clust</dt><dd><p>factor; the
enumeration area.</p>
</dd> <dt>age</dt><dd><p>integer; the person's age.</p>
</dd>
<dt>sex</dt><dd><p>factor; the person's sex (levels <code>male</code> and
<code>female</code>).</p>
</dd> <dt>relate</dt><dd><p>factor; the relationship with the
household head (levels <code>head</code>, <code>spouse</code>, <code>child</code>,
<code>grandchild</code>, <code>parent/parentlaw</code>, <code>son/daughterlaw</code>,
<code>other relative</code>, <code>adopted child</code>, <code>househelp</code> and
<code>non_relative</code>).</p>
</dd> <dt>nation</dt><dd><p>factor; the person's
nationality (levels <code>ghanaian birth</code>, <code>ghanaian naturalise</code>,
<code>burkinabe</code>, <code>malian</code>, <code>nigerian</code>, <code>ivorian</code>,
<code>togolese</code>, <code>liberian</code>, <code>other ecowas</code>, <code>other africa</code>
and <code>other</code>).</p>
</dd> <dt>ethnic</dt><dd><p>factor; the person's ethnicity
(levels <code>akan</code>, <code>all other tribes</code>, <code>ewe</code>, <code>ga-dangbe</code>,
<code>grusi</code>, <code>guan</code>, <code>gurma</code>, <code>mande</code> and
<code>mole-dagbani</code>).</p>
</dd> <dt>religion</dt><dd><p>factor; the person's religion
(levels <code>catholic</code>, <code>anglican</code>, <code>presbyterian</code>,
<code>methodist</code>, <code>pentecostal</code>, <code>spiritualist</code>, <code>other
christian</code>, <code>moslem</code>, <code>traditional</code>, <code>no religion</code> and
<code>other</code>).</p>
</dd> <dt>highest_degree</dt><dd><p>factor; the person's highest
degree of education (levels <code>none</code>, <code>mlsc</code>, <code>bece</code>,
<code>voc/comm</code>, <code>teacher trng a</code>, <code>teacher trng b</code>, <code>gce 'o'
level</code>, <code>ssce</code>, <code>gce 'a' level</code>, <code>tech/prof cert</code>,
<code>tech/prof dip</code>, <code>hnd</code>, <code>bachelor</code>, <code>masters</code>,
<code>doctorate</code> and <code>other</code>).</p>
</dd> <dt>occupation</dt><dd><p>factor; the
person's occupation (levels <code>armed forces and other security
personnel</code>, <code>clerks</code>, <code>craft and related trades workers</code>,
<code>elementary occupations</code>, <code>legislators, senior officials and
managers</code>, <code>none</code>, <code>plant and machine operators and assemblers</code>,
<code>professionals</code>, <code>service workers and shop and market sales
workers</code>, <code>skilled agricultural and fishery workers</code>, and
<code>technicians and associate professionals</code>).</p>
</dd>
<dt>income</dt><dd><p>numeric; the person's annual income.</p>
</dd>
<dt>weight</dt><dd><p>numeric; the sample weights.</p>
</dd> </dl>



<h3>Details</h3>

<p>The data set consists of 8700 households and is used as sample data in some
of the examples in package <code>simPopulation</code>.  Note that it is included
for illustrative purposes only.  The sample weights do not reflect the true
population sizes of Ghana and its regions.  The resulting population data is
about 100 times smaller than the real population size to save computation
time.
</p>
<p>Only some of the variables in the original survey are included in this
example data set.  Furthermore, categories are aggregated for certain
variables due to the large number of possible outcomes in the original
survey data.
</p>


<h3>Source</h3>

<p>This is a synthetic data set based on GLSS data from 2006.  The
original sample was provided by Ghana Statistical Service.
</p>


<h3>References</h3>

<p>Ghana Statistical Service (2008) Ghana Living Standards Survey:
Report of the fifth round.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ghanaS)
summary(ghanaS)
</code></pre>

<hr>
<h2 id='ipu'>iterative proportional updating</h2><span id='topic+ipu'></span>

<h3>Description</h3>

<p>adjust sampling weights to given totals based on household-level and/or
individual level constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipu(inp, con, hid = NULL, eps = 1e-07, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ipu_+3A_inp">inp</code></td>
<td>
<p>a <code>data.frame</code> or <code>data.table</code> containing household ids
(optionally), counts for household and/or personal level attributes that
should be fitted.</p>
</td></tr>
<tr><td><code id="ipu_+3A_con">con</code></td>
<td>
<p>named list with each list element holding a constraint total with
list-names relating to column-names in <code>inp</code>.</p>
</td></tr>
<tr><td><code id="ipu_+3A_hid">hid</code></td>
<td>
<p>character vector specifying the variable containing household-ids
within <code>inp</code> or NULL if such a variable does not exist.</p>
</td></tr>
<tr><td><code id="ipu_+3A_eps">eps</code></td>
<td>
<p>number specifiying convergence limit</p>
</td></tr>
<tr><td><code id="ipu_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, ipu will print some progress information.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Meindl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
# basic example
inp &lt;- as.data.frame(matrix(0, nrow=8, ncol=6))
colnames(inp) &lt;- c("hhid","hh1","hh2","p1","p2","p3")
inp$hhid &lt;- 1:8
inp$hh1[1:3] &lt;- 1
inp$hh2[4:8] &lt;- 1
inp$p1 &lt;- c(1,1,2,1,0,1,2,1)
inp$p2 &lt;- c(1,0,1,0,2,1,1,1)
inp$p3 &lt;- c(1,1,0,2,1,0,2,0)
con &lt;- list(hh1=35, hh2=65, p1=91, p2=65, p3=104)
res &lt;- ipu(inp=inp, hid="hhid", con=con, verbose=FALSE)

# more sophisticated
# load sample and population data
data(eusilcS)
data(eusilcP)

# variable generation and preparation
eusilcS$hsize &lt;- factor(eusilcS$hsize)

# make sure, factor levels in sample and population match
eusilcP$region &lt;- factor(eusilcP$region, levels = levels(eusilcS$db040))
eusilcP$gender &lt;- factor(eusilcP$gender, levels = levels(eusilcS$rb090))
eusilcP$hsize  &lt;- factor(eusilcP$hsize , levels = levels(eusilcS$hsize))

# generate input matrix
# we want to adjust to variable "db040" (region) as household variables and
# variable "rb090" (gender) as individual information

library(data.table)
samp &lt;- data.table(eusilcS)
pop &lt;-  data.table(eusilcP)
setkeyv(samp, "db030")
hh &lt;- samp[!duplicated(samp$db030),]
hhpop &lt;- pop[!duplicated(pop$hid),]

# reg contains for each region the number of households
reg &lt;- data.table(model.matrix(~db040 +0, data=hh))
# hsize contains for each household size the number of households
hsize &lt;- data.table(model.matrix(~factor(hsize) +0, data=hh))

# aggregate persons-level characteristics per household
# gender contains for each household the number of males and females
gender &lt;- data.table(model.matrix(~db030+rb090 +0, data=samp))
setkeyv(gender, "db030")
gender &lt;- gender[, lapply(.SD, sum), by = key(gender)]

# bind together and use it as input
inp &lt;- cbind(reg, hsize, gender)

# the totals we want to calibrate to
con &lt;- c(
  as.list(xtabs(rep(1, nrow(hhpop)) ~ hhpop$region)),
  as.list(xtabs(rep(1, nrow(hhpop)) ~ hhpop$hsize)),
  as.list(xtabs(rep(1, nrow(eusilcP)) ~ eusilcP$gender))
)
# we need to have the same names as in 'inp'
names(con) &lt;- setdiff(names(inp), "db030")

# run ipu und check results
res &lt;- ipu(inp=inp, hid="db030", con=con, verbose=TRUE)

is &lt;- sapply(2:(ncol(res)-1), function(x) {
  sum(res[,x]*res$weights)
})
data.frame(required=unlist(con), is=is)

</code></pre>

<hr>
<h2 id='manageSimPopObj'>get and set variables from population or sample data stored in an object of
class <code><a href="#topic+simPopObj-class">simPopObj</a></code>.</h2><span id='topic+manageSimPopObj'></span>

<h3>Description</h3>

<p>This functions allows to get or set variables in slots <code>pop</code> and
<code>sample</code> of <code><a href="#topic+simPopObj-class">simPopObj</a></code>-objects. This is a utility
function that is useful for writing custom wrapper functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manageSimPopObj(x, var, sample = FALSE, set = FALSE, values = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manageSimPopObj_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code>.</p>
</td></tr>
<tr><td><code id="manageSimPopObj_+3A_var">var</code></td>
<td>
<p>character vector of length 1; variable name that should be set or
extracted.</p>
</td></tr>
<tr><td><code id="manageSimPopObj_+3A_sample">sample</code></td>
<td>
<p>a logical indicating whether <code>var</code> should be
extracted/set from slot 'sample' (TRUE) or slot 'pop' (FALSE).</p>
</td></tr>
<tr><td><code id="manageSimPopObj_+3A_set">set</code></td>
<td>
<p>logical; if TRUE, argument 'values' is set to either the sample
or population data stored in 'x', depending on argument 'sample'. If FALSE,
the desired variable given by 'var' is returned from either the sample or
the pop slot of 'x'.</p>
</td></tr>
<tr><td><code id="manageSimPopObj_+3A_values">values</code></td>
<td>
<p>vector; if 'set' is TRUE, then this vector is used to update
the variable of sample or population data depending of choice of argument
'sample'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> (if 'set' is TRUE)
or a vector (if 'set' is FALSE).
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl and Matthias Templ
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040",
  weight="db090")
simPopObj &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))

(manageSimPopObj(simPopObj, var="age", sample=FALSE, set=FALSE))
(manageSimPopObj(simPopObj, var="age", sample=TRUE, set=FALSE))
</code></pre>

<hr>
<h2 id='quantileWt'>Weighted sample quantiles</h2><span id='topic+quantileWt'></span>

<h3>Description</h3>

<p>Compute quantiles taking into account sample weights. The following methods
are implemented:
</p>

<ul>
<li> <p><code>quantileWt.default(x, weights=NULL, probs=seq(0, 1, 0.25), na.rm=TRUE, ...)</code>
</p>
</li>
<li> <p><code>quantileWt.dataObj(x, vars, probs=seq(0, 1, 0.25), na.rm=TRUE, ...)</code>
</p>
</li></ul>

<p>Additional parameters are:
</p>

<ul>
<li><p> weights an optional numeric vector containing sample weights.
</p>
</li>
<li><p> vars a character vector of length 1 specifying a variable name that
is available in the data-slot of <code>x</code> and which is used for the
calculation.
</p>
</li>
<li><p> probs a numeric vector of probabilities with values in <code class="reqn">[0, 1]</code>.
</p>
</li>
<li><p> na.rm a logical indicating whether any <code>NA</code> or <code>NaN</code> values
should be removed from <code>x</code> before the quantiles are computed.  Note
that the default is <code>TRUE</code>, contrary to the function
<code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>quantileWt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantileWt_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="quantileWt_+3A_...">...</code></td>
<td>
<p>for the generic function <code>quantileWt</code> additional arguments
to be passed to methods.  Additional arguments not included in the
definition of the methods are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If weights are not specified then <code>quantile(x, probs, na.rm=na.rm,
names=FALSE, type=1)</code> is used for the computation.
</p>
<p>Note probabilities outside <code class="reqn">[0, 1]</code> cause an error.
</p>


<h3>Value</h3>

<p>A vector of the (weighted) sample quantiles.
</p>


<h3>Author(s)</h3>

<p>Stefan Kraft and Bernhard Meindl
</p>
<p>A basic version of this function was provided by Cedric Beguin and Beat
Hulliger.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)
(quantileWt(eusilcS$netIncome, weights=eusilcS$rb050))

# dataObj-method
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
(quantileWt(inp, vars="netIncome"))

</code></pre>

<hr>
<h2 id='sampHH'>Sample households from given microdata.</h2><span id='topic+sampHH'></span>

<h3>Description</h3>

<p>The function samples households from microdata containing personal and
household information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampHH(pop, sizefactor = 1, hid = "hid", strata = "region", hsize = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampHH_+3A_pop">pop</code></td>
<td>
<p>data frame containing households and persons</p>
</td></tr>
<tr><td><code id="sampHH_+3A_sizefactor">sizefactor</code></td>
<td>
<p>factor of how many times the initial population should be
resampled</p>
</td></tr>
<tr><td><code id="sampHH_+3A_hid">hid</code></td>
<td>
<p>string specifying the name of the household-id variable in the
data.</p>
</td></tr>
<tr><td><code id="sampHH_+3A_strata">strata</code></td>
<td>
<p>can be used to sample within strata.</p>
</td></tr>
<tr><td><code id="sampHH_+3A_hsize">hsize</code></td>
<td>
<p>string specifying the name of the household size variable in
the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>households are drawn from the data and new ID's are generated for the new
households.
</p>


<h3>Value</h3>

<p>the data frame of new households.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl, Matthias Templ and Johannes Gussenbauer
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. doi: 10.18637/jss.v079.i10
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcP)
pop &lt;- eusilcP
colnames(pop)[3] &lt;- "hhsize"

system.time(x1 &lt;- sampHH(pop, strata="region", hsize="hhsize"))
dim(x1)
## Not run: 
## approx. 10 second computation time ...
system.time(x1 &lt;- sampHH(pop, sizefactor=4, strata="region", hsize="hhsize"))
dim(x1)
system.time(x2 &lt;- sampHH(pop, strata=NULL, hsize="hhsize"))

pop &lt;- pop[,-which(colnames(pop)=="hhsize")]
system.time(y1 &lt;- sampHH(pop, strata="region", hsize=NULL))
system.time(y2 &lt;- sampHH(pop, strata=NULL, hsize=NULL))

## End(Not run)
</code></pre>

<hr>
<h2 id='silcTools'>Utility functions for socio-economic data sets</h2><span id='topic+silcTools'></span><span id='topic+getAge'></span><span id='topic+getGender'></span><span id='topic+getEcoStat'></span><span id='topic+getCitizenship'></span><span id='topic+getHsize'></span><span id='topic+restructureHHid'></span><span id='topic+factorNA'></span>

<h3>Description</h3>

<p>Various utility functions mainly used for simulating EU-SILC data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAge(birth, year, data = NULL)

getGender(gender, labels = c("male", "female"), data = NULL)

getEcoStat(ecoStat, data, levels)

getCitizenship(citizenship, data, owncountry, EU, other)

getHsize(data, hhid)

restructureHHid(data, hhid)

factorNA(x, always = FALSE, newval = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silcTools_+3A_birth">birth</code></td>
<td>
<p>year of birth</p>
</td></tr>
<tr><td><code id="silcTools_+3A_year">year</code></td>
<td>
<p>current year</p>
</td></tr>
<tr><td><code id="silcTools_+3A_data">data</code></td>
<td>
<p>data.frame (for some functions optional)</p>
</td></tr>
<tr><td><code id="silcTools_+3A_gender">gender</code></td>
<td>
<p>variable including information on gender</p>
</td></tr>
<tr><td><code id="silcTools_+3A_labels">labels</code></td>
<td>
<p>labels of a factor variable</p>
</td></tr>
<tr><td><code id="silcTools_+3A_ecostat">ecoStat</code></td>
<td>
<p>variable holding information on the economic status</p>
</td></tr>
<tr><td><code id="silcTools_+3A_hhid">hhid</code></td>
<td>
<p>name or index of variable holding the information on household ID</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons, Matthias Templ
</p>


<h3>Examples</h3>

<pre><code class='language-R'>birth &lt;- sample(1950:2000, 20)
getAge(birth, 2013)
data(eusilcS)
head(getGender("rb090", labels = c("ma","fe"), data=eusilcS))
lev &lt;- c("Employee working full-time", "Employee working part-time",
         "Self-employed working full-time", "Self-employed working part-time",
         "Unemployed", "Pupil, student, further training, unpaid work experience",
         "In retirement", "Permanently disabled", "In compulsory military community or service",
         "Fulfilling domestic tasks", "Other inactive person")
g &lt;- getEcoStat("pl030", eusilcS, lev)
table(g)
data(eusilcS)
## destroy info on pb220a to show afterwards the usage of the function
owncountry &lt;- "AT"
EU &lt;- c("DE","BE","BG","CY","CZ","DK","EE","EL","ES","FI","FR","GR","HU","IE",
        "IT","LT","LU","LV","MT","NL","PL","PT","RO","SI","SE","SK","UK")
other &lt;- c("CAN","CH","CSA","HR","IS","ME","MK","NAF","NME","NO",
           "OAF","OAS","OCE","OEU","OT","OTH","TR","USA","WAF")
eusilcS$fakepb220a &lt;-  factor(sample(c(owncountry, EU, other), nrow(eusilcS), replace = TRUE))
table(eusilcS$fakepb220a)
eusilcS$fakepb220a &lt;- getCitizenship(citizenship = "fakepb220a",
                                  data=eusilcS, owncountry=owncountry,
                                  EU=EU, other=other)
table(eusilcS$fakepb220a)
data(eusilcS)
hsize &lt;- getHsize(data=eusilcS)
table(hsize)
hhid &lt;- c(6,6,3,3,3,2,1,1,8,9,9,9,9,7,7)
hhid
df &lt;- data.frame("hhid"=hhid)
restructureHHid(df, "hhid")
hhid &lt;- factor(c(6,6,3,3,3,2,1,1,NA,9,9,9,9,7,7))
hhid
factorNA(hhid)
</code></pre>

<hr>
<h2 id='silcTools2'>Utility functions for EU-SILC data</h2><span id='topic+silcTools2'></span><span id='topic+mergeSILC'></span><span id='topic+checkCol'></span><span id='topic+chooseSILCvars'></span><span id='topic+modifySILC'></span><span id='topic+loadSILC'></span>

<h3>Description</h3>

<p>Various utility functions mainly used for simulating EU-SILC data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSILC(
  file = NULL,
  filed = NULL,
  filer = NULL,
  filep = NULL,
  fileh = NULL,
  year = 2013,
  country = "Austria"
)

mergeSILC(filed, filer, fileh, filep)

checkCol(x, y)

chooseSILCvars(
  x,
  vars = c("db030", "db040", "rb030", "rb080", "rb090", "pl031", "pb220a", "py010g",
    "py021g", "py050g", "py080g", "py090g", "py100g", "py110g", "py120g", "py130g",
    "py140g", "hy040g", "hy050g", "hy060g", "hy070g", "hy080g", "hy090g", "hy100g",
    "hy110g", "hy120g", "hy130g", "hy140g", "db090", "rb050", "pb190", "pe040", "pl051",
    "pl111", "rb010"),
  country = NULL
)

modifySILC(x, country = "Austria")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silcTools2_+3A_file">file</code></td>
<td>
<p>data set in R binary format, csv or sav (SPSS) of merged EU-SILC data.</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_filed">filed</code></td>
<td>
<p>data set including the household register information</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_filer">filer</code></td>
<td>
<p>data set including the personal register information</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_filep">filep</code></td>
<td>
<p>data set including the personal information</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_fileh">fileh</code></td>
<td>
<p>data set including the household information</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_year">year</code></td>
<td>
<p>year of origin</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_country">country</code></td>
<td>
<p>country</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_x">x</code></td>
<td>
<p>public-use file (for checkCol function) or orginal data</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_y">y</code></td>
<td>
<p>scientific-use file (for checkCol function)</p>
</td></tr>
<tr><td><code id="silcTools2_+3A_vars">vars</code></td>
<td>
<p>variables to be selected for function chooseSILCvars</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collection of functions to import, select and modify data EU-SILC data.
Either file (merged data) or single files have to be provided for loadSILC().
</p>


<h3>Author(s)</h3>

<p>Matthias Templ
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- loadSILC("new_workfile.RData")
filed &lt;- "zielvar_d_eurostat2013.sav"
filer &lt;- "zielvar_r_eurostat2013.sav"
filep &lt;- "zielvar_p_eurostat2013.sav"
fileh &lt;- "zielvar_h_eurostat2013.sav"
suf4 &lt;- loadSILC(filed = filed,
                 filer = filer,
                 filep = filep,
                 fileh = fileh)

## End(Not run)
## Not run: 
filed &lt;- "zielvar_d_eurostat2013.sav"
filer &lt;- "zielvar_r_eurostat2013.sav"
filep &lt;- "zielvar_p_eurostat2013.sav"
fileh &lt;- "zielvar_h_eurostat2013.sav"
suf4 &lt;- loadSILC(filed = filed,
                 filer = filer,
                 filep = filep,
                 fileh = fileh)
suf &lt;- mergeSILC(d = suf4[["d"]],
                 r = suf4[["r"]],
                 h = suf4[["h"]],
                 p = suf4[["p"]])

## End(Not run)
data(eusilc13puf)
## instead of scientific-use file or
## original data we took the 2006 synthetic data
data(eusilcS)
## check which columns of y are in x
checkCol(eusilc13puf, eusilcS)
## Not run: 
## on original silc data to extract needed variables for SGA project on SILC
x &lt;- loadSILC("new_workfile.RData")
chooseSILCvars(x)

## End(Not run)
## Not run: 
## wrapper to prepare SILC data
## on original silc data
x &lt;- loadSILC("new_workfile.RData")
x &lt;- chooseSILCvars(x)
modifySILC(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='simCategorical'>Simulate categorical variables of population data</h2><span id='topic+simCategorical'></span>

<h3>Description</h3>

<p>Simulate categorical variables of population data. The household structure
of the population data needs to be simulated beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simCategorical(
  simPopObj,
  additional,
  method = c("multinom", "distribution", "ctree", "cforest", "ranger", "xgboost"),
  limit = NULL,
  censor = NULL,
  maxit = 500,
  MaxNWts = 1500,
  eps = NULL,
  nr_cpus = NULL,
  regModel = NULL,
  seed = 1,
  verbose = FALSE,
  by = "strata",
  model_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simCategorical_+3A_simpopobj">simPopObj</code></td>
<td>
<p>a <code>simPopObj</code> containing population and household
survey data as well as optionally margins in standardized format.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_additional">additional</code></td>
<td>
<p>a character vector specifying additional categorical
variables available in the sample object of <code>simPopObj</code> that should be
simulated for the population data.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to be used for
simulating the additional categorical variables. Accepted values are
<code>"multinom"</code> (estimation of the conditional probabilities using
multinomial log-linear models and random draws from the resulting
distributions) or <code>"distribution"</code> (random draws from the observed
conditional distributions of their multivariate realizations).
<code>"ctree"</code>  for using Classification trees
<code>"cforest"</code>  for using random forest (implementation in package party)
<code>"ranger"</code>  for using random forest (implementation in package ranger)
<code>"xgboost"</code>  for using xgboost (implementation in package xgboost)</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_limit">limit</code></td>
<td>
<p>if <code>method</code> is <code>"multinom"</code>, this can be used to
account for structural zeros. If only one additional variable is requested,
a named list of lists should be supplied. The names of the list components
specify the predictor variables for which to limit the possible outcomes of
the response. For each predictor, a list containing the possible outcomes of
the response for each category of the predictor can be supplied. The
probabilities of other outcomes conditional on combinations that contain the
specified categories of the supplied predictors are set to 0. If more than
one additional variable is requested, such a list of lists can be supplied
for each variable as a component of yet another list, with the component
names specifying the respective variables.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_censor">censor</code></td>
<td>
<p>if <code>method</code> is <code>"multinom"</code>, this can be used to
account for structural zeros. If only one additional variable is requested,
a named list of lists or <code>data.frame</code>s should be supplied. The names of
the list components specify the categories that should be censored. For each
of these categories, a list or <code>data.frame</code> containing levels of the
predictor variables can be supplied. The probability of the specified
categories is set to 0 for the respective predictor levels. If more than one
additional variable is requested, such a list of lists or <code>data.frame</code>s
can be supplied for each variable as a component of yet another list, with
the component names specifying the respective variables.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_maxit">maxit</code>, <code id="simCategorical_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>control parameters to be passed to
<code><a href="nnet.html#topic+multinom">multinom</a></code> and <code><a href="nnet.html#topic+nnet">nnet</a></code>. See the help file
for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value, or <code>NULL</code> (the default). In
the former case and if <code>method</code> is <code>"multinom"</code>, estimated
probabilities smaller than this are assumed to result from structural zeros
and are set to exactly 0.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_nr_cpus">nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_regmodel">regModel</code></td>
<td>
<p>allows to specify the variables or model that is used when
simulating additional categorical variables. The following choices are
available if different from NULL.  </p>
 <ul>
<li><p>'basic'only the basic
household variables (generated with <code><a href="#topic+simStructure">simStructure</a></code>) are used.
</p>
</li>
<li><p>'available'all available variables (that are common in the sample and
the synthetic population such as previously generated varaibles) excluding
id-variables, strata variables and household sizes are used for the
modelling. This parameter should be used with care because all factors are
automatically used as factors internally.  </p>
</li>
<li><p> formula-objectUsers may also
specify a specifiy formula (class 'formula') that will be used. Checks are
performed that all required variables are available.  </p>
</li></ul>
<p> If method
'distribution' is used, it is only possible to specify a vector of length
one containing one of the choices described above.  If parameter 'regModel'
is NULL, only basic household variables are used in any case.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_seed">seed</code></td>
<td>
<p>optional; an integer value to be used as the seed of the random
number generator, or an integer vector containing the state of the random
number generator to be restored.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_verbose">verbose</code></td>
<td>
<p>set to TRUE if additional print output should be shown.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_by">by</code></td>
<td>
<p>defining which variable to use as split up variable of the estimation. Defaults to the strata variable.</p>
</td></tr>
<tr><td><code id="simCategorical_+3A_model_params">model_params</code></td>
<td>
<p>NULL or a named list which can contain model specific parameters which will be passed onto the function call for the respective model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of cpus are selected automatically in the following manner. The
number of cpus is equal the number of strata. However, if the number of cpus
is less than the number of strata, the number of cpus - 1 is used by
default. This should be the best strategy, but the user can also overwrite
this decision.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing survey
data as well as the simulated population data including the categorical
variables specified by argument <code>additional</code>.
</p>


<h3>Note</h3>

<p>The basic household structure needs to be simulated beforehand with
the function <code><a href="#topic+simStructure">simStructure</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl, Andreas Alfons, Stefan Kraft, Alexander Kowarik, Matthias Templ, Siro Fritzmann
</p>


<h3>References</h3>

<p>B. Meindl, M. Templ, A. Kowarik, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>
<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC.
<em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. <a href="https://doi.org/10.1080/02664763.2013.859237">doi:10.1080/02664763.2013.859237</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simStructure">simStructure</a></code>, <code><a href="#topic+simRelation">simRelation</a></code>,
<code><a href="#topic+simContinuous">simContinuous</a></code>, <code><a href="#topic+simComponents">simComponents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS) # load sample data
## Not run: 
## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
## in the following, nr_cpus are selected automatically
simPop &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
simPop &lt;- simCategorical(simPop, additional=c("pl030", "pb220a"), method="multinom", nr_cpus=1)
simPop

## End(Not run)
</code></pre>

<hr>
<h2 id='simComponents'>Simulate components of continuous variables of population data</h2><span id='topic+simComponents'></span>

<h3>Description</h3>

<p>Simulate components of continuous variables of population data by resampling
fractions from survey data. The continuous variable to be split and any
categorical conditioning variables need to be simulated beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simComponents(
  simPopObj,
  total = "netIncome",
  components = c("py010n", "py050n", "py090n", "py100n", "py110n", "py120n", "py130n",
    "py140n"),
  conditional = c(getCatName(total), "pl030"),
  replaceEmpty = c("sequential", "min"),
  seed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simComponents_+3A_simpopobj">simPopObj</code></td>
<td>
<p>a <code><a href="#topic+simPopObj-class">simPopObj</a></code>-object.</p>
</td></tr>
<tr><td><code id="simComponents_+3A_total">total</code></td>
<td>
<p>a character string specifying the continuous variable of dataP
that should be split into components. Currently, only one variable can be
split at a time.</p>
</td></tr>
<tr><td><code id="simComponents_+3A_components">components</code></td>
<td>
<p>a character vector specifying the components in
<code>dataS</code> that should be simulated for the population data.</p>
</td></tr>
<tr><td><code id="simComponents_+3A_conditional">conditional</code></td>
<td>
<p>an optional character vector specifying categorical
conditioning variables for resampling. The fractions occurring in
<code>dataS</code> are then drawn from the respective subsets defined by these
variables.</p>
</td></tr>
<tr><td><code id="simComponents_+3A_replaceempty">replaceEmpty</code></td>
<td>
<p>a character string; if <code>conditional</code> specifies at
least two conditioning variables, this determines how replacement cells for
empty subsets in the sample are obtained. If <code>"sequential"</code>, the
conditioning variables are browsed sequentially such that replacement cells
have the same value in one conditioning variable and minimum Manhattan
distance in the other conditioning variables. If no such cells exist,
replacement cells with minimum overall Manhattan distance are selected. The
latter is always done if this is <code>"min"</code> or only one conditioning
variable is used.</p>
</td></tr>
<tr><td><code id="simComponents_+3A_seed">seed</code></td>
<td>
<p>optional; an integer value to be used as the seed of the random
number generator, or an integer vector containing the state of the random
number generator to be restored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing survey
data as well as the simulated population data including the components of
the continuous variable specified by <code>total</code> and <code>components</code>.
</p>


<h3>Note</h3>

<p>The basic household structure, any categorical conditioning variables
and the continuous variable to be split need to be simulated beforehand with
the functions <code><a href="#topic+simStructure">simStructure</a></code>, <code><a href="#topic+simCategorical">simCategorical</a></code> and
<code><a href="#topic+simContinuous">simContinuous</a></code>.
</p>


<h3>Author(s)</h3>

<p>Stefan Kraft and Andreas Alfons and Bernhard Meindl
</p>


<h3>References</h3>

<p>B. Meindl, M. Templ, A. Kowarik, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>
<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC. 
<em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. <a href="https://doi.org/10.1080/02664763.2013.859237">doi:10.1080/02664763.2013.859237</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simStructure">simStructure</a></code>, <code><a href="#topic+simCategorical">simCategorical</a></code>,
<code><a href="#topic+simContinuous">simContinuous</a></code>, <code><a href="#topic+simEUSILC">simEUSILC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
## Not run: 
## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize",
  strata="db040", weight="db090")
simPopObj &lt;- simStructure(data=inp, method="direct",
  basicHHvars=c("age", "rb090", "hsize", "pl030", "pb220a"))
simPopObj &lt;- simContinuous(simPopObj, additional = "netIncome",
  regModel = ~rb090+hsize+pl030+pb220a+hsize,
  method="multinom", upper=200000, equidist=FALSE, nr_cpus=1)

# categorize net income for use as conditioning variable
sIncome &lt;- manageSimPopObj(simPopObj, var="netIncome", sample=TRUE, set=FALSE)
sWeight &lt;- manageSimPopObj(simPopObj, var="rb050", sample=TRUE, set=FALSE)
pIncome &lt;- manageSimPopObj(simPopObj, var="netIncome", sample=FALSE, set=FALSE)

breaks &lt;- getBreaks(x=unlist(sIncome), w=unlist(sWeight), upper=Inf, equidist=FALSE)
simPopObj &lt;- manageSimPopObj(simPopObj, var="netIncomeCat", sample=TRUE,
  set=TRUE, values=getCat(x=unlist(sIncome), breaks))
simPopObj &lt;- manageSimPopObj(simPopObj, var="netIncomeCat", sample=FALSE,
  set=TRUE, values=getCat(x=unlist(pIncome), breaks))

# simulate net income components
simPopObj &lt;- simComponents(simPopObj=simPopObj, total="netIncome",
  components=c("py010n","py050n","py090n","py100n","py110n","py120n","py130n","py140n"),
  conditional = c("netIncomeCat", "pl030"), replaceEmpty = "sequential", seed=1 )

class(simPopObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='simContinuous'>Simulate continuous variables of population data</h2><span id='topic+simContinuous'></span>

<h3>Description</h3>

<p>Simulate continuous variables of population data using multinomial
log-linear models combined with random draws from the resulting categories
or (two-step) regression models combined with random error terms. The
household structure of the population data and any other categorical
predictors need to be simulated beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simContinuous(
  simPopObj,
  additional = "netIncome",
  method = c("multinom", "lm", "poisson", "xgboost"),
  zeros = TRUE,
  breaks = NULL,
  lower = NULL,
  upper = NULL,
  equidist = TRUE,
  probs = NULL,
  gpd = TRUE,
  threshold = NULL,
  est = "moments",
  limit = NULL,
  censor = NULL,
  log = TRUE,
  const = NULL,
  alpha = 0.01,
  residuals = TRUE,
  keep = TRUE,
  maxit = 500,
  MaxNWts = 1500,
  tol = .Machine$double.eps^0.5,
  nr_cpus = NULL,
  eps = NULL,
  regModel = "basic",
  byHousehold = NULL,
  imputeMissings = FALSE,
  seed,
  verbose = FALSE,
  by = "strata",
  model_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simContinuous_+3A_simpopobj">simPopObj</code></td>
<td>
<p>a <code><a href="#topic+simPopObj-class">simPopObj</a></code> holding household survey
data, population data and optionally some margins.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_additional">additional</code></td>
<td>
<p>a character string specifying the additional continuous
variable of <code>dataS</code> that should be simulated for the population data.
Currently, only one additional variable can be simulated at a time.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to be used for
simulating the continuous variable. Accepted values are <code>"multinom"</code>,
for using multinomial log-linear models combined with random draws from the
resulting categories, <code>"lm"</code>, for using (two-step) regression
models combined with random error terms, <code>"poisson"</code> for using Poisson regression for count variables, and <code>"xgboost"</code> for using XGBoost.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether the variable specified by
<code>additional</code> is semi-continuous, i.e., contains a considerable amount
of zeros. If <code>TRUE</code> and <code>method</code> is <code>"multinom"</code>, a separate
factor level for zeros in the response is used. If <code>TRUE</code> and
<code>method</code> is <code>"lm"</code>, a two-step model is applied. The first step
thereby uses a log-linear or multinomial log-linear model (see
&ldquo;Details&rdquo;).</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_breaks">breaks</code></td>
<td>
<p>an optional numeric vector; if multinomial models are
computed, this can be used to supply two or more break points for
categorizing the variable specified by <code>additional</code>. If <code>NULL</code>,
break points are computed using weighted quantiles.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_lower">lower</code>, <code id="simContinuous_+3A_upper">upper</code></td>
<td>
<p>optional numeric values; if multinomial models are
computed and <code>breaks</code> is <code>NULL</code>, these can be used to specify
lower and upper bounds other than minimum and maximum, respectively. Note
that if <code>method</code> is <code>"multinom"</code> and <code>gpd</code> is <code>TRUE</code>
(see below), <code>upper</code> defaults to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_equidist">equidist</code></td>
<td>
<p>logical; if <code>method</code> is <code>"multinom"</code> and
<code>breaks</code> is <code>NULL</code>, this indicates whether the (positive) default
break points should be equidistant or whether there should be refinements in
the lower and upper tail (see <code><a href="#topic+getBreaks">getBreaks</a></code>).</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_probs">probs</code></td>
<td>
<p>numeric vector with values in <code class="reqn">[0, 1]</code>; if <code>method</code> is
<code>"multinom"</code> and <code>breaks</code> is <code>NULL</code>, this gives probabilities
for quantiles to be used as (positive) break points. If supplied, this is
preferred over <code>equidist</code>.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_gpd">gpd</code></td>
<td>
<p>logical; if <code>method</code> is <code>"multinom"</code>, this indicates
whether the upper tail of the variable specified by <code>additional</code> should
be simulated by random draws from a (truncated) generalized Pareto
distribution rather than a uniform distribution.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value; if <code>method</code> is <code>"multinom"</code>,
values for categories above <code>threshold</code> are drawn from a (truncated)
generalized Pareto distribution.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_est">est</code></td>
<td>
<p>a character string; if <code>method</code> is <code>"multinom"</code>, the
estimator to be used to fit the generalized Pareto distribution.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_limit">limit</code></td>
<td>
<p>an optional named list of lists; if multinomial models are
computed, this can be used to account for structural zeros. The names of the
list components specify the predictor variables for which to limit the
possible outcomes of the response. For each predictor, a list containing the
possible outcomes of the response for each category of the predictor can be
supplied. The probabilities of other outcomes conditional on combinations
that contain the specified categories of the supplied predictors are set to
0. Currently, this is only implemented for more than two categories in the
response.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_censor">censor</code></td>
<td>
<p>an optional named list of lists or <code>data.frame</code>s; if
multinomial models are computed, this can be used to account for structural
zeros. The names of the list components specify the categories that should
be censored. For each of these categories, a list or <code>data.frame</code>
containing levels of the predictor variables can be supplied. The
probability of the specified categories is set to 0 for the respective
predictor levels. Currently, this is only implemented for more than two
categories in the response.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_log">log</code></td>
<td>
<p>logical; if <code>method</code> is <code>"lm"</code>, this indicates whether
the linear model should be fitted to the logarithms of the variable
specified by <code>additional</code>. The predicted values are then
back-transformed with the exponential function. See &ldquo;Details&rdquo; for
more information.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_const">const</code></td>
<td>
<p>numeric; if <code>method</code> is <code>"lm"</code> and <code>log</code> is
<code>TRUE</code>, this gives a constant to be added before log transformation.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_alpha">alpha</code></td>
<td>
<p>numeric; if <code>method</code> is <code>"lm"</code>, this gives trimming
parameters for the sample data. Trimming is thereby done with respect to the
variable specified by <code>additional</code>. If a numeric vector of length two
is supplied, the first element gives the trimming proportion for the lower
part and the second element the trimming proportion for the upper part. If a
single numeric is supplied, it is used for both. With <code>NULL</code>, trimming
is suppressed.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_residuals">residuals</code></td>
<td>
<p>logical; if <code>method</code> is <code>"lm"</code>, this indicates
whether the random error terms should be obtained by draws from the
residuals. If <code>FALSE</code>, they are drawn from a normal distribution
(median and MAD of the residuals are used as parameters).</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_keep">keep</code></td>
<td>
<p>logical; if multinomial models are computed, this indicates
whether the simulated categories should be stored as a variable in the
resulting population data. If <code>TRUE</code>, the corresponding column name is
given by <code>additional</code> with postfix <code>"Cat"</code>.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_maxit">maxit</code>, <code id="simContinuous_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>control parameters to be passed to
<code><a href="nnet.html#topic+multinom">multinom</a></code> and <code><a href="nnet.html#topic+nnet">nnet</a></code>. See the help file
for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_tol">tol</code></td>
<td>
<p>if <code>method</code> is <code>"lm"</code> and <code>zeros</code> is <code>TRUE</code>,
a small positive numeric value or <code>NULL</code>. When fitting a log-linear
model within a stratum, factor levels may not exist in the sample but are
likely to exist in the population. However, the coefficient for such factor
levels will be 0. Therefore, coefficients smaller than <code>tol</code> in
absolute value are replaced by coefficients from an auxiliary model that is
fit to the whole sample. If <code>NULL</code>, no auxiliary log-linear model is
computed and no coefficients are replaced.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_nr_cpus">nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value, or <code>NULL</code> (the default). In
the former case and if (multinomial) log-linear models are computed,
estimated probabilities smaller than this are assumed to result from
structural zeros and are set to exactly 0.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_regmodel">regModel</code></td>
<td>
<p>allows to specify the model that should be for the
simulation of the additional continuous variable. The following choices are
possible: </p>
 <ul>
<li><p>'basic'only the basic household-variables
(generated with <code><a href="#topic+simStructure">simStructure</a></code>) are used.  </p>
</li>
<li><p>'available'all
available variables (that are common in the sample and the syntetic
population (e.g. previously generated variables) are used for the modeling.
Should be used with care because all variables are automatically used as
factors!  </p>
</li>
<li><p> formula-object: Users may also specify a specific formula
(class 'formula') that will be used. Checks are performed that all required
variables are available.</p>
</li></ul>
</td></tr>
<tr><td><code id="simContinuous_+3A_byhousehold">byHousehold</code></td>
<td>
<p>if NULL, simulated values are used as is. If either <code>'sum'</code>,
<code>'mean'</code> or <code>'random'</code> is specified, the values are aggregated and each member
of the household gets the same value (mean, sum or a random value) assigned.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_imputemissings">imputeMissings</code></td>
<td>
<p>if TRUE, missing values in variables that are used for
the underlying model are imputed using hock-deck.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_seed">seed</code></td>
<td>
<p>optional; an integer value to be used as the seed of the random
number generator, or an integer vector containing the state of the random
number generator to be restored.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_verbose">verbose</code></td>
<td>
<p>(logical) if <code>TRUE</code>, additional output is written to the promt</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_by">by</code></td>
<td>
<p>defining which variable to use as split up variable of the estimation. Defaults to the strata variable.</p>
</td></tr>
<tr><td><code id="simContinuous_+3A_model_params">model_params</code></td>
<td>
<p>adding optional parameter to the model, at the moment only implemented for xgboost hyperparameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> is <code>"lm"</code>, the behavior for two-step models is
described in the following.
</p>
<p>If <code>zeros</code> is <code>TRUE</code> and <code>log</code> is not <code>TRUE</code> or the
variable specified by <code>additional</code> does not contain negative values, a
log-linear model is used to predict whether an observation is zero or not.
Then a linear model is used to predict the non-zero values.
</p>
<p>If <code>zeros</code> is <code>TRUE</code>, <code>log</code> is <code>TRUE</code> and <code>const</code>
is specified, again a log-linear model is used to predict whether an
observation is zero or not. In the linear model to predict the non-zero
values, <code>const</code> is added to the variable specified by <code>additional</code>
before the logarithms are taken.
</p>
<p>If <code>zeros</code> is <code>TRUE</code>, <code>log</code> is <code>TRUE</code>, <code>const</code> is
<code>NULL</code> and there are negative values, a multinomial log-linear model is
used to predict negative, zero and positive observations. Categories for the
negative values are thereby defined by <code>breaks</code>. In the second step, a
linear model is used to predict the positive values and negative values are
drawn from uniform distributions in the respective classes.
</p>
<p>If <code>zeros</code> is <code>FALSE</code>, <code>log</code> is <code>TRUE</code> and <code>const</code>
is <code>NULL</code>, a two-step model is used if there are non-positive values in
the variable specified by <code>additional</code>. Whether a log-linear or a
multinomial log-linear model is used depends on the number of categories to
be used for the non-positive values, as defined by <code>breaks</code>. Again,
positive values are then predicted with a linear model and non-positive
values are drawn from uniform distributions.
</p>
<p>The number of cpus are selected automatically in the following manner. The
number of cpus is equal the number of strata. However, if the number of cpus
is less than the number of strata, the number of cpus - 1 is used by
default. This should be the best strategy, but the user can also overwrite
this decision.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing survey
data as well as the simulated population data including the continuous
variable specified by <code>additional</code> and possibly simulated categories
for the desired continous variable.
</p>


<h3>Note</h3>

<p>The basic household structure and any other categorical predictors
need to be simulated beforehand with the functions
<code><a href="#topic+simStructure">simStructure</a></code> and <code><a href="#topic+simCategorical">simCategorical</a></code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl, Andreas Alfons, Alexander Kowarik (based on code by Stefan Kraft), Siro Fritzmann
</p>


<h3>References</h3>

<p>B. Meindl, M. Templ, A. Kowarik, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>
<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC. 
<em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. <a href="https://doi.org/10.1080/02664763.2013.859237">doi:10.1080/02664763.2013.859237</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simStructure">simStructure</a></code>, <code><a href="#topic+simCategorical">simCategorical</a></code>,
<code><a href="#topic+simComponents">simComponents</a></code>, <code><a href="#topic+simEUSILC">simEUSILC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)
## Not run: 
## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
simPop &lt;- simStructure(data=inp, method="direct",
  basicHHvars=c("age", "rb090", "hsize", "pl030", "pb220a"))

regModel = ~rb090+hsize+pl030+pb220a

# multinomial model with random draws
eusilcM &lt;- simContinuous(simPop, additional="netIncome",
              regModel = regModel,
              upper=200000, equidist=FALSE, nr_cpus=1)
class(eusilcM)

# two-step regression
eusilcT &lt;- simContinuous(simPop, additional="netIncome",
              regModel = "basic",
              method = "lm", nr_cpus=1)
class(eusilcT)

## End(Not run)

</code></pre>

<hr>
<h2 id='simEUSILC'>Simulate EU-SILC population data</h2><span id='topic+simEUSILC'></span>

<h3>Description</h3>

<p>Simulate population data for the European Statistics on Income and Living
Conditions (EU-SILC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simEUSILC(
  dataS,
  hid = "db030",
  wh = "db090",
  wp = "rb050",
  hsize = NULL,
  strata = "db040",
  pid = NULL,
  age = "age",
  gender = "rb090",
  categorizeAge = TRUE,
  breaksAge = NULL,
  categorical = c("pl030", "pb220a"),
  income = "netIncome",
  method = c("multinom", "twostep"),
  breaks = NULL,
  lower = NULL,
  upper = NULL,
  equidist = TRUE,
  probs = NULL,
  gpd = TRUE,
  threshold = NULL,
  est = "moments",
  const = NULL,
  alpha = 0.01,
  residuals = TRUE,
  components = c("py010n", "py050n", "py090n", "py100n", "py110n", "py120n", "py130n",
    "py140n"),
  conditional = c(getCatName(income), "pl030"),
  keep = TRUE,
  maxit = 500,
  MaxNWts = 1500,
  tol = .Machine$double.eps^0.5,
  nr_cpus = NULL,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simEUSILC_+3A_datas">dataS</code></td>
<td>
<p>a <code>data.frame</code> containing EU-SILC survey data.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_hid">hid</code></td>
<td>
<p>a character string specifying the column of <code>dataS</code> that
contains the household ID.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_wh">wh</code></td>
<td>
<p>a character string specifying the column of <code>dataS</code> that
contains the household sample weights.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_wp">wp</code></td>
<td>
<p>a character string specifying the column of <code>dataS</code> that
contains the personal sample weights.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_hsize">hsize</code></td>
<td>
<p>an optional character string specifying a column of
<code>dataS</code> that contains the household size. If <code>NULL</code>, the household
sizes are computed.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_strata">strata</code></td>
<td>
<p>a character string specifying the column of <code>dataS</code> that
define strata. Note that this is currently a required argument and only one
stratification variable is supported.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_pid">pid</code></td>
<td>
<p>an optional character string specifying a column of <code>dataS</code>
that contains the personal ID.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_age">age</code></td>
<td>
<p>a character string specifying the column of <code>dataS</code> that
contains the age of the persons (to be used for setting up the household
structure).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_gender">gender</code></td>
<td>
<p>a character string specifying the column of <code>dataS</code> that
contains the gender of the persons (to be used for setting up the household
structure).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_categorizeage">categorizeAge</code></td>
<td>
<p>a logical indicating whether age categories should be
used for simulating additional categorical and continuous variables to
decrease computation time.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_breaksage">breaksAge</code></td>
<td>
<p>numeric; if <code>categorizeAge</code> is <code>TRUE</code>, an
optional vector of two or more break points for constructing age categories,
otherwise ignored.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_categorical">categorical</code></td>
<td>
<p>a character vector specifying additional categorical
variables of <code>dataS</code> that should be simulated for the population data.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_income">income</code></td>
<td>
<p>a character string specifying the variable of <code>dataS</code>
that contains the personal income (to be simulated for the population data).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to be used for
simulating personal income. Accepted values are <code>"multinom"</code> (for using
multinomial log-linear models combined with random draws from the resulting
ategories) and <code>"twostep"</code> (for using two-step regression models
combined with random error terms).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_breaks">breaks</code></td>
<td>
<p>if <code>method</code> is <code>"multinom"</code>, an optional numeric
vector of two or more break points for categorizing the personal income. If
missing, break points are computed using weighted quantiles.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_lower">lower</code>, <code id="simEUSILC_+3A_upper">upper</code></td>
<td>
<p>numeric values; if <code>method</code> is <code>"multinom"</code> and
<code>breaks</code> is <code>NULL</code>, these can be used to specify lower and upper
bounds other than minimum and maximum, respectively. Note that if <code>gpd</code>
is <code>TRUE</code> (see below), <code>upper</code> defaults to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_equidist">equidist</code></td>
<td>
<p>logical; if <code>method</code> is <code>"multinom"</code> and
<code>breaks</code> is <code>NULL</code>, this indicates whether the (positive) default
break points should be equidistant or whether there should be refinements in
the lower and upper tail (see <code><a href="#topic+getBreaks">getBreaks</a></code>).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_probs">probs</code></td>
<td>
<p>numeric vector with values in <code class="reqn">[0, 1]</code>; if <code>method</code> is
<code>"multinom"</code> and <code>breaks</code> is <code>NULL</code>, this gives probabilities
for quantiles to be used as (positive) break points. If supplied, this is
preferred over <code>equidist</code>.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_gpd">gpd</code></td>
<td>
<p>logical; if <code>method</code> is <code>"multinom"</code>, this indicates
whether the upper tail of the personal income should be simulated by random
draws from a (truncated) generalized Pareto distribution rather than a
uniform distribution.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value; if <code>method</code> is <code>"multinom"</code>,
values for categories above <code>threshold</code> are drawn from a (truncated)
generalized Pareto distribution.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_est">est</code></td>
<td>
<p>a character string; if <code>method</code> is <code>"multinom"</code>, the
estimator to be used to fit the generalized Pareto distribution.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_const">const</code></td>
<td>
<p>numeric; if <code>method</code> is <code>"twostep"</code>, this gives a
constant to be added before log transformation.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_alpha">alpha</code></td>
<td>
<p>numeric; if <code>method</code> is <code>"twostep"</code>, this gives
trimming parameters for the sample data. Trimming is thereby done with
respect to the variable specified by <code>additional</code>. If a numeric vector
of length two is supplied, the first element gives the trimming proportion
for the lower part and the second element the trimming proportion for the
upper part. If a single numeric is supplied, it is used for both. With
<code>NULL</code>, trimming is suppressed.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_residuals">residuals</code></td>
<td>
<p>logical; if <code>method</code> is <code>"twostep"</code>, this
indicates whether the random error terms should be obtained by draws from
the residuals. If <code>FALSE</code>, they are drawn from a normal distribution
(median and MAD of the residuals are used as parameters).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_components">components</code></td>
<td>
<p>a character vector specifying the income components in
<code>dataS</code> (to be simulated for the population data).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_conditional">conditional</code></td>
<td>
<p>an optional character vector specifying categorical
contitioning variables for resampling of the income components. The
fractions occurring in <code>dataS</code> are then drawn from the respective
subsets defined by these variables.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_keep">keep</code></td>
<td>
<p>a logical indicating whether variables computed internally in
the procedure (such as the original IDs of the corresponding households in
the underlying sample, age categories or income categories) should be stored
in the resulting population data.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_maxit">maxit</code>, <code id="simEUSILC_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>control parameters to be passed to
<code><a href="nnet.html#topic+multinom">multinom</a></code> and <code><a href="nnet.html#topic+nnet">nnet</a></code>. See the help file
for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_tol">tol</code></td>
<td>
<p>if <code>method</code> is <code>"twostep"</code>, a small positive numeric
value or <code>NULL</code> (see <code><a href="#topic+simContinuous">simContinuous</a></code>).</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_nr_cpus">nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td></tr>
<tr><td><code id="simEUSILC_+3A_seed">seed</code></td>
<td>
<p>optional; an integer value to be used as the seed of the random
number generator, or an integer vector containing the state of the random
number generator to be restored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing the
simulated EU-SILC population data as well as the underlying sample.
</p>


<h3>Note</h3>

<p>This is a wrapper calling <code><a href="#topic+simStructure">simStructure</a></code>,
<code><a href="#topic+simCategorical">simCategorical</a></code>, <code><a href="#topic+simContinuous">simContinuous</a></code> and
<code><a href="#topic+simComponents">simComponents</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Stefan Kraft and Bernhard Meindl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simStructure">simStructure</a></code>, <code><a href="#topic+simCategorical">simCategorical</a></code>,
<code><a href="#topic+simContinuous">simContinuous</a></code>, <code><a href="#topic+simComponents">simComponents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS) # load sample data

## Not run: 
## long computation time
# multinomial model with random draws
eusilcM &lt;- simEUSILC(eusilcS, upper = 200000, equidist = FALSE
, nr_cpus = 1)
summary(eusilcM)

# two-step regression
eusilcT &lt;- simEUSILC(eusilcS, method = "twostep", nr_cpus = 1)
summary(eusilcT)

## End(Not run)

</code></pre>

<hr>
<h2 id='simInitSpatial'>Generation of smaller regions given an existing spatial variable and a
table.</h2><span id='topic+simInitSpatial'></span>

<h3>Description</h3>

<p>This function allows to manipulate an object of class
<code><a href="#topic+simPopObj-class">simPopObj</a></code> in a way that a new variable containing
smaller regions within an already existing broader region is generated. The
distribution of the smaller region within the broader region is respected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simInitSpatial(
  simPopObj,
  additional,
  region,
  tspatialP = NULL,
  tspatialHH = NULL,
  eps = 0.05,
  maxIter = 100,
  nr_cpus = NULL,
  seed = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simInitSpatial_+3A_simpopobj">simPopObj</code></td>
<td>
<p>an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code>.</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_additional">additional</code></td>
<td>
<p>a character vector of length one holding the variable name
of the variable containing smaller geographical units. This variable name
must be available as a column in input argument <code>tspatial</code>.</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_region">region</code></td>
<td>
<p>a character vector of length one holding the variable name of
the broader region. This variable must be available in the input
<code>tspatial</code> as well as in the sample and population slots of input
<code>simPopObj</code>.</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_tspatialp">tspatialP</code></td>
<td>
<p>a  data.frame (or data.table) containing three columns. The broader region
(with the variable name being the same as in input <code>region</code>, the
smaller geographical units (with the variable name being the same as in
input <code>additional</code>) and a third column containing a numeric vector
holding counts of persons. This argument or tspatialHH has to be provided.</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_tspatialhh">tspatialHH</code></td>
<td>
<p>a  data.frame (or data.table) containing three columns. The broader region
(with the variable name being the same as in input <code>region</code>, the
smaller geographical units (with the variable name being the same as in
input <code>additional</code>) and a third column containing a numeric vector
holding counts of households. This argument or tspatialP has to be provided.</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_eps">eps</code></td>
<td>
<p>relative deviation of person counts if person and household counts are provided</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iteration for adjustment
if person and household counts are provided</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_nr_cpus">nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_seed">seed</code></td>
<td>
<p>optional; an integer value to be used as the seed of the random
number generator, or an integer vector containing the state of the random
number generator to be restored.</p>
</td></tr>
<tr><td><code id="simInitSpatial_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE if some information should be shown during the process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distributional information must be contained in an input table that
holds combinations of characteristics of the broader region and the smaller
regions as well as population counts (which may be available from a census).
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> with an additional
variable in the synthetic population slot.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl and Alexander Kowarik
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data(eusilcS)
data(eusilcP)
library(data.table)

# no districts are available in the population, so we have to generate those
# we randomly assign districts within "region" in the eusilc population data
# each hh has the same district
simulate_districts &lt;- function(inp) {
  hhid &lt;- "hid"
  region &lt;- "region"

  a &lt;- inp[!duplicated(inp[,hhid]),c(hhid, region)]
  spl &lt;- split(a, a[,region])
  regions &lt;- unique(inp[,region])

  tmpres &lt;- lapply(1:length(spl), function(x) {
    codes &lt;- paste(x, 1:sample(3:9,1), sep="")
    spl[[x]]$district &lt;- sample(codes, nrow(spl[[x]]), replace=TRUE)
    spl[[x]]
  })
  tmpres &lt;- do.call("rbind", tmpres)
  tmpres &lt;- tmpres[,-c(2)]
  out &lt;- merge(inp, tmpres, by.x=c(hhid), by.y=hhid, all.x=TRUE)
  invisible(out)
}

eusilcP &lt;- data.table(simulate_districts(eusilcP))
# we generate the input table using the broad region (variable 'region')
# and the districts, we have generated before.
#Generate table with household counts by district
tabHH &lt;- eusilcP[!duplicated(hid),.(Freq=.N),by=.(db040=region,district)]
setkey(tabHH,db040,district)
#Generate table with person counts by district
tabP &lt;- eusilcP[,.(Freq=.N),by=.(db040=region,district)]
setkey(tabP,db040,district)

# we generate a synthetic population
setnames(eusilcP,"region","db040")
setnames(eusilcP,"hid","db030")
inp &lt;- specifyInput(data=eusilcP, hhid="db030", hhsize="hsize", strata="db040",population=TRUE)
## Not run: 
# use only HH counts
simPopObj &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "gender"))
simPopObj1 &lt;- simInitSpatial(simPopObj, additional="district", region="db040", tspatialHH=tabHH,
tspatialP=NULL, nr_cpus=1)

# use only P counts
simPopObj &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "gender"))
simPopObj2 &lt;- simInitSpatial(simPopObj, additional="district", region="db040", tspatialHH=NULL,
tspatialP=tabP, nr_cpus = 1)

# use P and HH counts
simPopObj &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "gender"))
simPopObj3 &lt;- simInitSpatial(simPopObj, additional="district", region="db040", tspatialHH=tabHH,
tspatialP=tabP, nr_cpus = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='simple_dis'>Simple generation of new variables</h2><span id='topic+simple_dis'></span><span id='topic+univariate.dis'></span><span id='topic+conditional.dis'></span>

<h3>Description</h3>

<p>Fast simulation of new variables based on univariate distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univariate.dis(puf, data, additional, weights, value = "data", fNA = NA)

conditional.dis(
  puf,
  data,
  additional,
  conditional,
  weights,
  value = "data",
  fNA = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simple_dis_+3A_puf">puf</code></td>
<td>
<p>data for which one additional column specified by function argument &lsquo;additional&rsquo; is simulated</p>
</td></tr>
<tr><td><code id="simple_dis_+3A_data">data</code></td>
<td>
<p>donor data</p>
</td></tr>
<tr><td><code id="simple_dis_+3A_additional">additional</code></td>
<td>
<p>name of variable to be simulated</p>
</td></tr>
<tr><td><code id="simple_dis_+3A_weights">weights</code></td>
<td>
<p>sampling weights from data</p>
</td></tr>
<tr><td><code id="simple_dis_+3A_value">value</code></td>
<td>
<p>if &ldquo;data&rdquo; then the puf including the additional variable is returned, otherwise only
the simulated vector.</p>
</td></tr>
<tr><td><code id="simple_dis_+3A_fna">fNA</code></td>
<td>
<p>only used with missing values if another code as NA should be used</p>
</td></tr>
<tr><td><code id="simple_dis_+3A_conditional">conditional</code></td>
<td>
<p>conditioning variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function uni.distribution: random draws from the weighted univariate distribution of
the original data
</p>
<p>Function conditional.dis: random draws from the weighted conditional distribution
(conditioned on a factor variable)
</p>
<p>This are simple functions to produce structural variables, variables that
should have the same categories as given ones. For more advanced methods see simCategorical()
</p>


<h3>Author(s)</h3>

<p>Lydia Spies, Matthias Templ
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simCategorical">simCategorical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## we don't have original data, so let's use eusilc
data(eusilc13puf)
data(eusilcS)
v1 &lt;- univariate.dis(eusilcS, eusilc13puf, additional = "db040",
weights = "rb050", value = "vector")
table(v1)
table(eusilc13puf$db040)
## we don't have original data, so let's use eusilc
##data(eusilc13puf)
##data(eusilcS)
##v1 &lt;- conditional.dis(eusilcS, eusilc13puf, additional = "pb190",
##  conditional = "db040", weights = "rb050")
##table(v1) / sum(table(v1))
##table(eusilc13puf$pb190) / sum(table(eusilc13puf$pb190))
</code></pre>

<hr>
<h2 id='simPopObj-class'>Class <code>"simPopObj"</code></h2><span id='topic+simPopObj-class'></span><span id='topic+show+2CsimPopObj-method'></span>

<h3>Description</h3>

<p>An object that is used throughout the package containing information on the
sample (in slot <code>sample</code>), the population (slot <code>pop</code>) and
optionally some margins in form of a table (slot <code>table</code>).
</p>


<h3>Objects from the Class</h3>

<p>Objects are automatically created in
function <code><a href="#topic+simStructure">simStructure</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl and Matthias Templ
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataObj-class">dataObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("simPopObj")

## show method: generate an object of class simPop first
data(eusilcS)
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
eusilcP &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
class(eusilcP)
## shows some basic information:
eusilcP

</code></pre>

<hr>
<h2 id='simRelation'>Simulate categorical variables of population data</h2><span id='topic+simRelation'></span>

<h3>Description</h3>

<p>Simulate categorical variables of population data taking relationships
between household members into account. The household structure of the
population data needs to be simulated beforehand using
<code><a href="#topic+simStructure">simStructure()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRelation(
  simPopObj,
  relation = "relate",
  head = "head",
  direct = NULL,
  additional,
  limit = NULL,
  censor = NULL,
  maxit = 500,
  MaxNWts = 2000,
  eps = NULL,
  nr_cpus = NULL,
  seed = 1,
  regModel = NULL,
  verbose = FALSE,
  method = c("multinom", "ctree", "cforest", "ranger"),
  by = "strata"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simRelation_+3A_simpopobj">simPopObj</code></td>
<td>
<p>a <code>simPopObj</code> containing population and household
survey data as well as optionally margins in standardized format.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_relation">relation</code></td>
<td>
<p>a character string specifying the columns of <code>dataS</code>
and <code>dataP</code>, respectively, that define the relationships between the
household members.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_head">head</code></td>
<td>
<p>a character string specifying the category of the variable given
by <code>relation</code> that identifies the household head.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_direct">direct</code></td>
<td>
<p>a character string specifying categories of the variable given
by <code>relation</code>. Simulated individuals with those categories directly
inherit the values of the additional variables from the household head. The
default is <code>NULL</code> such that no individuals directly inherit value from
the household head.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_additional">additional</code></td>
<td>
<p>a character vector specifying additional categorical
variables of <code>dataS</code> that should be simulated for the population data.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_limit">limit</code></td>
<td>
<p>this can be used to account for structural zeros. If only one
additional variable is requested, a named list of lists should be supplied.
The names of the list components specify the predictor variables for which
to limit the possible outcomes of the response. For each predictor, a list
containing the possible outcomes of the response for each category of the
predictor can be supplied. The probabilities of other outcomes conditional
on combinations that contain the specified categories of the supplied
predictors are set to 0. If more than one additional variable is requested,
such a list of lists can be supplied for each variable as a component of yet
another list, with the component names specifying the respective variables.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_censor">censor</code></td>
<td>
<p>this can be used to account for structural zeros. If only one
additional variable is requested, a named list of lists or
<code>data.frame</code>s should be supplied. The names of the list components
specify the categories that should be censored. For each of these
categories, a list or <code>data.frame</code> containing levels of the predictor
variables can be supplied. The probability of the specified categories is
set to 0 for the respective predictor levels. If more than one additional
variable is requested, such a list of lists or <code>data.frame</code>s can be
supplied for each variable as a component of yet another list, with the
component names specifying the respective variables.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_maxit">maxit</code>, <code id="simRelation_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>control parameters to be passed to
<code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code> and <code><a href="nnet.html#topic+nnet">nnet::nnet()</a></code>. See the help file
for <code><a href="nnet.html#topic+nnet">nnet::nnet()</a></code>.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value, or <code>NULL</code> (the default). In
the former case, estimated probabilities smaller than this are assumed to
result from structural zeros and are set to exactly 0.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_nr_cpus">nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_seed">seed</code></td>
<td>
<p>optional; an integer value to be used as the seed of the random
number generator, or an integer vector containing the state of the random
number generator to be restored.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_regmodel">regModel</code></td>
<td>
<p>allows to specify the variables or model that is used when
simulating additional categorical variables. The following choices are
available if different from <code>NULL</code>.
</p>

<ul>
<li><p> &quot;basic&quot;: only the basic household variables (generated with <code><a href="#topic+simStructure">simStructure()</a></code>
are used.
</p>
</li>
<li><p> &quot;available&quot;: all available variables (that are common in the sample and
the synthetic population such as previously generated variables) excluding
id-variables, strata variables and household sizes are used for the
modeling. This parameter should be used with care because all factors are
automatically used as factors internally.
</p>
</li>
<li><p> formula-object: users may also specify a formula (class 'formula') that
will be used. Checks are performed that all required variables are available.
If parameter <code>regModel</code> is <code>NULL</code>, only basic household variables are used
in any case.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simRelation_+3A_verbose">verbose</code></td>
<td>
<p>set to <code>TRUE</code> if additional print output should be shown.</p>
</td></tr>
<tr><td><code id="simRelation_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to be used for
simulating the additional categorical variables. Accepted values are
</p>

<ul>
<li><p> &quot;multinom&quot;: estimation of the conditional probabilities using
multinomial log-linear models and random draws from the resulting
distributions
</p>
</li>
<li><p> &quot;ctree&quot;: for using Classification trees
</p>
</li>
<li><p> &quot;cforest&quot;: for using random forest (implementation in package party)
</p>
</li>
<li><p> &quot;ranger&quot;: for using random forest (implementation in package ranger)
</p>
</li></ul>
</td></tr>
<tr><td><code id="simRelation_+3A_by">by</code></td>
<td>
<p>defining which variable to use as split up variable of the estimation. Defaults
to the strata variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of a new variable are simulated in three steps, where the second
step is optional. First, the values of the household heads are simulated
with multinomial log-linear models. Second, individuals directly related to
the corresponding household head (as specified by the argument
<code>direct</code>) inherit the value of the latter. Third, the values of the
remaining individuals are simulated with multinomial log-linear models in
which the value of the respective household head is used as an additional
predictor.
</p>
<p>The number of cpus are selected automatically in the following manner. The
number of cpus is equal the number of strata. However, if the number of cpus
is less than the number of strata, the number of cpus - 1 is used by
default.  This should be the best strategy, but the user can also overwrite
this decision.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+simPopObj-class">simPopObj</a> containing survey
data as well as the simulated population data including the categorical
variables specified by <code>additional</code>.
</p>


<h3>Note</h3>

<p>The basic household structure needs to be simulated beforehand with
the function <code><a href="#topic+simStructure">simStructure()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Bernhard Meindl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simStructure">simStructure()</a></code>, <code><a href="#topic+simCategorical">simCategorical()</a></code>,
<code><a href="#topic+simContinuous">simContinuous()</a></code>, <code><a href="#topic+simComponents">simComponents()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ghanaS) # load sample data
samp &lt;- specifyInput(
  data = ghanaS,
  hhid = "hhid",
  strata = "region",
  weight = "weight"
)
ghanaP &lt;- simStructure(
  data = samp,
  method = "direct",
  basicHHvars = c("age", "sex", "relate")
)
class(ghanaP)

## Not run: 
## long computation time ...
ghanaP &lt;- simRelation(
  simPopObj = ghanaP,
  relation = "relate",
  head = "head",
  additional = c("nation", "ethnic", "religion"), nr_cpus = 1
)
str(ghanaP)

## End(Not run)
</code></pre>

<hr>
<h2 id='simStructure'>Simulate the household structure of population data</h2><span id='topic+simStructure'></span>

<h3>Description</h3>

<p>Simulate basic categorical variables that define the household structure
(typically variables such as household ID, age and gender) of population
data by resampling from survey data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simStructure(
  dataS,
  method = c("direct", "multinom", "distribution"),
  basicHHvars,
  seed = 1,
  MaxNWts = 1e+07
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simStructure_+3A_datas">dataS</code></td>
<td>
<p>an object of class <code>dataObj</code> containing household survey
data that is usually generated with <code><a href="#topic+specifyInput">specifyInput</a></code>.</p>
</td></tr>
<tr><td><code id="simStructure_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to be used for
simulating the household sizes.  Accepted values are <code>"direct"</code>
(estimation of the population totals for each combination of stratum and
household size using the Horvitz-Thompson estimator), <code>"multinom"</code>
(estimation of the conditional probabilities within the strata using a
multinomial log-linear model and random draws from the resulting
distributions), or <code>"distribution"</code> (random draws from the observed
conditional distributions within the strata).</p>
</td></tr>
<tr><td><code id="simStructure_+3A_basichhvars">basicHHvars</code></td>
<td>
<p>a character vector specifying important variables for the
household structure that need to be available in <code>dataS</code>. Typically
variables such as age or sex may be used.</p>
</td></tr>
<tr><td><code id="simStructure_+3A_seed">seed</code></td>
<td>
<p>optional; an integer value to be used as the seed of the random
number generator, or an integer vector containing the state of the random
number generator to be restored.</p>
</td></tr>
<tr><td><code id="simStructure_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>optional; an integer value for the multinom method for controlling 
the maximum number of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>simPopObj</code> containing the simulated
population household structure as well as the underlying sample that was
provided as input.
</p>


<h3>Note</h3>

<p>The function <code><a href="base.html#topic+sample">sample</a></code> is used, which gives results
incompatible with those from &lt; 2.2.0 and produces a warning the first time
this happens in a session.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl and Andreas Alfons
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simCategorical">simCategorical</a></code>, <code><a href="#topic+simContinuous">simContinuous</a></code>,
<code><a href="#topic+simComponents">simComponents</a></code>, <code><a href="#topic+simEUSILC">simEUSILC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)
## Not run: 
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
eusilcP &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
class(eusilcP)
eusilcP

## End(Not run)

</code></pre>

<hr>
<h2 id='spBwplot'>Weighted box plots</h2><span id='topic+spBwplot'></span><span id='topic+panelSpBwplot'></span><span id='topic+getBwplotStats'></span><span id='topic+prepBwplotStats.data.frame'></span><span id='topic+prepBwplotStats.default'></span><span id='topic+prepBwplotStats'></span>

<h3>Description</h3>

<p>Produce box-and-whisker plots of continuous or semi-continuous variables,
possibly broken down according to conditioning variables and taking into
account sample weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spBwplot(
  inp,
  x,
  cond = NULL,
  horizontal = TRUE,
  coef = 1.5,
  zeros = TRUE,
  minRatio = NULL,
  do.out = FALSE,
  ...
)

panelSpBwplot(x, y, coef = 1.5, zeros = TRUE, ratio, outliers, subscripts, ...)

getBwplotStats(x, weights = NULL, cond = NULL, data, ..., name = "")

prepBwplotStats(x, w, ..., name = "")

## S3 method for class 'data.frame'
prepBwplotStats(x, w, ..., name = "")

## Default S3 method:
prepBwplotStats(x, w, ..., name = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spBwplot_+3A_inp">inp</code></td>
<td>
<p>an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing
survey sample and synthetic population data.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_x">x</code></td>
<td>
<p>a character vector specifying the columns of data available in the
sample and the population (specified in input object 'inp') to be plotted.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_cond">cond</code></td>
<td>
<p>an optional character vector (of length 1, if used) specifying
the conditioning variable.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_horizontal">horizontal</code></td>
<td>
<p>a logical indicating whether the boxes should be
horizontal or vertical.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_coef">coef</code></td>
<td>
<p>a numeric value that determines the extension of the whiskers.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether the variables specified by
<code>x</code> are semi-continuous, i.e., contain a considerable amount of zeros.
If <code>TRUE</code>, the box widths correspond to the proportion of non-zero data
points and the (weighted) box plot statistics are computed for these
non-zero data points only.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_minratio">minRatio</code></td>
<td>
<p>a numeric value in <code class="reqn">(0,1]</code>; if <code>zeros</code> is
<code>TRUE</code>, the boxes may become unreadable for a large proportion of
zeros. In such a case, this can be used to specify a minimum ratio for the
box widths. Variable box widths for semi-continuous variables can be
suppressed by setting this value to 1.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_do.out">do.out</code></td>
<td>
<p>a logical indicating whether data points that lie beyond the
extremes of the whiskers should be plotted. Note that this is <code>FALSE</code>
by default.</p>
</td></tr>
<tr><td><code id="spBwplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to
<code><a href="lattice.html#topic+xyplot">bwplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are ignored for producing box plots and weights are directly
extracted from the input object <code>inp</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>, as returned by
<code><a href="lattice.html#topic+xyplot">bwplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Bernhard Meindl
</p>


<h3>References</h3>

<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC. 
<em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. <a href="https://doi.org/10.1007/s10260-011-0163-2">doi:10.1007/s10260-011-0163-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spBwplotStats">spBwplotStats</a></code>, <code><a href="lattice.html#topic+xyplot">bwplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## these take some time and are not run automatically
## copy &amp; paste to the R command line

set.seed(1234)  # for reproducibility
data(eusilcS)   # load sample data

## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize",
  strata="db040", weight="db090")
simPop &lt;- simStructure(data=inp, method="direct",
  basicHHvars=c("age", "rb090", "hsize", "pl030", "pb220a"))

# multinomial model with random draws
eusilcM &lt;- simContinuous(simPop, additional="netIncome",
  regModel  = ~rb090+hsize+pl030+pb220a+hsize,
  upper=200000, equidist=FALSE, nr_cpus=1)

# plot results
spBwplot(eusilcM, x="netIncome", cond=NULL)
spBwplot(eusilcM, x="netIncome", cond="rb090", layout=c(1,2))


</code></pre>

<hr>
<h2 id='spBwplotStats'>Weighted box plot statistics</h2><span id='topic+spBwplotStats'></span>

<h3>Description</h3>

<p>Compute the statistics necessary for producing box-and-whisker plots of
continuous or semi-continuous variables, taking into account sample weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spBwplotStats(x, weights = NULL, coef = 1.5, zeros = TRUE, do.out = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spBwplotStats_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="spBwplotStats_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector containing sample weights.</p>
</td></tr>
<tr><td><code id="spBwplotStats_+3A_coef">coef</code></td>
<td>
<p>a numeric value that determines the extension of the whiskers.</p>
</td></tr>
<tr><td><code id="spBwplotStats_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether the variable specified by
<code>additional</code> is semi-continuous, i.e., contains a considerable amount
of zeros.  If <code>TRUE</code>, the (weighted) box plot statistics are computed
for the non-zero data points only and the number of zeros is returned, too.</p>
</td></tr>
<tr><td><code id="spBwplotStats_+3A_do.out">do.out</code></td>
<td>
<p>a logical indicating whether data points that lie beyond the
extremes of the whiskers should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+quantileWt">quantileWt</a></code> is used for the computation of
(weighted) quantiles.  The median is computed together with the first and
the third quartile, which form the box.  If <code>range</code> is positive, the
whiskers extend to the most extreme data points that have a distance to the
box of no more than <code>coef</code> times the interquartile range.  For
<code>coef = 0</code>, the whiskers mark the minimum and the maximum of the
sample, whereas a negative value causes an error.
</p>


<h3>Value</h3>

<p>A list of class <code>"spBwplotStats"</code> with the following
components: </p>
<table role = "presentation">
<tr><td><code>stats</code></td>
<td>
<p>A vector of length 5 containing the (weighted)
statistics for the construction of a box plot.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>if <code>weights</code>
is <code>NULL</code>, the number of non-missing and, if <code>zeros</code> is
<code>TRUE</code>, non-zero data points.  Otherwise the sum of the weights of the
corresponding points.</p>
</td></tr> <tr><td><code>nzero</code></td>
<td>
<p>if <code>zeros</code> is <code>TRUE</code> and
<code>weights</code> is <code>NULL</code>, the number of zeros.  If <code>zeros</code> is
<code>TRUE</code> and <code>weights</code> is not <code>NULL</code>, the sum of the weights of
the zeros.  If <code>zeros</code> is not <code>TRUE</code>, this is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>if <code>do.out</code>, the values of any data points that lie beyond
the extremes of the whiskers.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Kraft and Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spBwplot">spBwplot</a></code>, for producing (weighted) box plots of
continuous or semi-continuous variables.
</p>
<p><code><a href="#topic+quantileWt">quantileWt</a></code> for the computation of (weighted) sample quantiles.
</p>
<p><code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code> for the unweighted statistics for box
plots (not considering semi-continuous variables).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)

## semi-continuous variable
spBwplotStats(eusilcS$netIncome, 
    weights=eusilcS$rb050, do.out = FALSE)

</code></pre>

<hr>
<h2 id='spCdf'>(Weighted empirical) cumulative distribution function</h2><span id='topic+spCdf'></span>

<h3>Description</h3>

<p>Compute a (weighted empirical) cumulative distribution function for survey
or population data.  For survey data, sample weights are taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spCdf(x, weights = NULL, approx = FALSE, n = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spCdf_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="spCdf_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector containing sample weights.</p>
</td></tr>
<tr><td><code id="spCdf_+3A_approx">approx</code></td>
<td>
<p>a logical indicating whether an approximation of the
cumulative distribution function should be computed.</p>
</td></tr>
<tr><td><code id="spCdf_+3A_n">n</code></td>
<td>
<p>a single integer value; if <code>approx</code> is <code>TRUE</code>, this
specifies the number of points at which the approximation takes place (see
<code><a href="stats.html#topic+approxfun">approx</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sample weights are taken into account by adjusting the step height.  To be
precise, the weighted step height for an observation is defined as its
weight divided by the sum of all weights<code class="reqn">\ ( w_{i} / \sum_{j = 1}^{n}
w_{j} ).</code>
</p>
<p>If requested, the approximation is performed using the function
<code><a href="stats.html#topic+approxfun">approx</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"spCdf"</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>a numeric vector containing the <code class="reqn">x</code>-coordinates.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>a
numeric vector containing the <code class="reqn">y</code>-coordinates.</p>
</td></tr> <tr><td><code>approx</code></td>
<td>
<p>a logical
indicating whether the coordinates represent an approximation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Stefan Kraft
</p>


<h3>References</h3>

<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC. 
<em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. <a href="https://doi.org/10.1007/s10260-011-0163-2">doi:10.1007/s10260-011-0163-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spCdfplot">spCdfplot</a></code>, <code><a href="stats.html#topic+ecdf">ecdf</a></code>,
<code><a href="stats.html#topic+approxfun">approx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)
cdfS &lt;- spCdf(eusilcS$netIncome, weights = eusilcS$rb050)
plot(cdfS, type="s")

</code></pre>

<hr>
<h2 id='spCdfplot'>Plot weighted cumulative distribution functions</h2><span id='topic+spCdfplot'></span><span id='topic+spCdfplot.default'></span><span id='topic+prepanelSpCdfplot'></span><span id='topic+panelSpCdfplot'></span><span id='topic+getCdf'></span><span id='topic+prepCdf'></span><span id='topic+prepCdf.data.frame'></span><span id='topic+prepCdf.default'></span>

<h3>Description</h3>

<p>Plot cumulative distribution functions, possibly broken down according to
conditioning variables and taking into account sample weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spCdfplot(
  inp,
  x,
  cond = NULL,
  approx = c(FALSE, TRUE),
  n = 10000,
  bounds = TRUE,
  ...
)

panelSpCdfplot(x, y, approx, bounds = TRUE, ...)

prepanelSpCdfplot(x, y, ...)

getCdf(x, weights = NULL, cond = NULL, data, ..., name = "")

prepCdf(x, w, ..., name = "")

## S3 method for class 'data.frame'
prepCdf(x, w, ..., name = "")

## Default S3 method:
prepCdf(x, w, ..., name = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spCdfplot_+3A_inp">inp</code></td>
<td>
<p>an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing
survey sample and synthetic population data.</p>
</td></tr>
<tr><td><code id="spCdfplot_+3A_x">x</code></td>
<td>
<p>a character vector specifying the columns of data available in the
sample and the population (specified in input object 'inp') to be plotted.</p>
</td></tr>
<tr><td><code id="spCdfplot_+3A_cond">cond</code></td>
<td>
<p>an optional character vector (of length 1, if used) specifying
the conditioning variable.</p>
</td></tr>
<tr><td><code id="spCdfplot_+3A_approx">approx</code></td>
<td>
<p>logicals indicating whether approximations of the cumulative
distribution functions should be computed.  The default is to use
<code>FALSE</code> for the survey data and <code>TRUE</code> for the population data.</p>
</td></tr>
<tr><td><code id="spCdfplot_+3A_n">n</code></td>
<td>
<p>integers specifying the number of points at which the
approximations take place (see <code><a href="stats.html#topic+approxfun">approx</a></code>).  It
is used wherever <code>approx</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spCdfplot_+3A_bounds">bounds</code></td>
<td>
<p>a logical indicating whether vertical lines should be drawn at
0 and 1 (the bounds for cumulative distribution functions).</p>
</td></tr>
<tr><td><code id="spCdfplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights are directly extracted from the input object <code>inp</code> and are
taken into account by adjusting the step height.  To be precise, the
weighted step height for an observation is defined as its weight divided by
the sum of all weights<code class="reqn">\ ( w_{i} / \sum_{j = 1}^{n} w_{j} ).</code>
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>, as returned by
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC. <em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. doi: 10.1007/s10260-011-0163-2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spCdf">spCdf</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## these take some time and are not run automatically
## copy &amp; paste to the R command line

set.seed(1234)  # for reproducibility
data(eusilcS)   # load sample data
## Not run: 
## approx. 20 seconds computation time
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize",
  strata="db040", weight="db090")
simPop &lt;- simStructure(data=inp, method="direct",
  basicHHvars=c("age", "rb090", "hsize", "pl030", "pb220a"))

# multinomial model with random draws
eusilcM &lt;- simContinuous(simPop, additional="netIncome",
  regModel = ~rb090+hsize+pl030+pb220a,
  upper=200000, equidist=FALSE, nr_cpus=1)
class(eusilcM)

# plot results
spCdfplot(eusilcM, "netIncome", cond=NULL)
spCdfplot(eusilcM, "netIncome", cond="rb090", layout=c(1,2))

## End(Not run)
</code></pre>

<hr>
<h2 id='specifyInput'>create an object of class 'dataObj' required for further processing</h2><span id='topic+specifyInput'></span>

<h3>Description</h3>

<p>create an standardized input object of class 'dataObj' containing
information on weights, household ids, household sizes, person ids and
optionally strata. Outputs of this function are typically used in
<code><a href="#topic+simStructure">simStructure</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specifyInput(
  data,
  hhid,
  hhsize = NULL,
  pid = NULL,
  weight = NULL,
  strata = NULL,
  population = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specifyInput_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>data.table</code> featuring sample data.</p>
</td></tr>
<tr><td><code id="specifyInput_+3A_hhid">hhid</code></td>
<td>
<p>character vector of length 1 specifying variable containing
household ids within slot <code>data</code>.</p>
</td></tr>
<tr><td><code id="specifyInput_+3A_hhsize">hhsize</code></td>
<td>
<p>character vector of length 1 specifying variable containing
household sizes within slot <code>data</code>. If NULL, household sizes are
automatically calculated.</p>
</td></tr>
<tr><td><code id="specifyInput_+3A_pid">pid</code></td>
<td>
<p>character vector of length 1 specifying variable containing
person ids within slot <code>data</code>. If NULL, person ids are automatically
calculated.</p>
</td></tr>
<tr><td><code id="specifyInput_+3A_weight">weight</code></td>
<td>
<p>character vector of length 1 specifying variable holding
sampling weights within slot <code>data</code>.</p>
</td></tr>
<tr><td><code id="specifyInput_+3A_strata">strata</code></td>
<td>
<p>character vector of length 1 specifing variable name within
slot <code>data</code> of variable holding information on strata, e.g. regions or
NULL if such variable does not exist.</p>
</td></tr>
<tr><td><code id="specifyInput_+3A_population">population</code></td>
<td>
<p>TRUE/FALSE vector of length 1 specifing if the data object is a sample or a population
NULL if such variable does not exist.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Meindl
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
inp &lt;- specifyInput(data=eusilcS, hhid="db030", weight="rb050", strata="db040")
class(inp)
inp
</code></pre>

<hr>
<h2 id='spMosaic'>Mosaic plots of expected and realized population sizes</h2><span id='topic+spMosaic'></span>

<h3>Description</h3>

<p>Create mosaic plots of expected (i.e., estimated) and realized (i.e.,
simulated) population sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMosaic(x, method = c("split", "color"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spMosaic_+3A_x">x</code></td>
<td>
<p>An object of class <code>"spTable"</code> created using function
<code><a href="#topic+spTable">spTable</a></code>.</p>
</td></tr>
<tr><td><code id="spMosaic_+3A_method">method</code></td>
<td>
<p>A character string specifying the plot method. Possible values
are <code>"split"</code> to plot the expected population sizes on the left hand
side and the realized population sizes on the right hand side, and
<code>"color"</code></p>
</td></tr>
<tr><td><code id="spMosaic_+3A_...">...</code></td>
<td>
<p>if <code>method</code> is <code>"split"</code>, further arguments to be
passed to <code><a href="vcd.html#topic+cotabplot">cotabplot</a></code>.  If <code>method</code> is <code>"color"</code>,
further arguments to be passed to <code><a href="vcd.html#topic+strucplot">strucplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> is <code>"split"</code>, the two tables of expected and realized
population sizes are combined into a single table, with an additional
conditioning variable indicating expected and realized values. A conditional
plot of this table is then produced using <code><a href="vcd.html#topic+cotabplot">cotabplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Bernhard Meindl
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1&ndash;38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>
<p>A. Alfons, M. Templ (2011) Simulation of close-to-reality population data for household surveys with application to EU-SILC. 
<em>Statistical Methods &amp; Applications</em>, <strong>20</strong> (3), 383&ndash;407. <a href="https://doi.org/10.1080/02664763.2013.859237">doi:10.1080/02664763.2013.859237</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spTable">spTable</a></code>, <code><a href="vcd.html#topic+cotabplot">cotabplot</a></code>,
<code><a href="vcd.html#topic+strucplot">strucplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)  # for reproducibility
## Not run: 
data(eusilcS)   # load sample data
samp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize",
  strata="db040", weight="db090")
eusilcP &lt;- simStructure(data=samp, method="direct", basicHHvars=c("age","rb090"))
abb &lt;- c("B","LA","Vi","C","St","UA","Sa","T","Vo")
tab &lt;- spTable(eusilcP, select=c("rb090", "db040", "hsize"))

# expected and realized population sizes
spMosaic(tab, method = "split",
  labeling=labeling_border(abbreviate=c(db040=TRUE)))

# realized population sizes colored according to relative
# differences with expected population sizes
spMosaic(tab, method = "color",
  labeling=labeling_border(abbreviate=c(db040=TRUE)))

## End(Not run)

</code></pre>

<hr>
<h2 id='sprague'>Sprague index (multipliers)</h2><span id='topic+sprague'></span>

<h3>Description</h3>

<p>Using the Sprague multipliers, the age counts are estimated for each year
having 5-years interval data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprague(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sprague_+3A_x">x</code></td>
<td>
<p>numeric vector of age counts in five-year intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is population counts of age classes 0-4, 5-9, 10-14, ... , 77-74,
75-79, 80+.
</p>


<h3>Value</h3>

<p>Population counts for age 0, 1, 2, 3, 4, ..., 78, 79, 80+.
</p>


<h3>Author(s)</h3>

<p>Matthias Templ
</p>


<h3>References</h3>

<p>G. Calot and J.-P. Sardon.  Methodology for the calculation of
Eurostat's demographic indicators.  Detailed report by the European
Demographic Observatory
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whipple">whipple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example from the world bank
x &lt;- data.frame(age=as.factor(c(
  "0-4",
  "5-9","10-14","15-19", "20-24",
  "25-29","30-34","35-39","40-44","45-49",
  "50-54","55-59","60-64","65-69","77-74","75-79","80+"
    )),
  pop=c(1971990, 2095820,2157190, 2094110,2116580,   2003840, 1785690,
        1502990, 1214170, 796934,  627551,  530305, 488014,
        364498, 259029,158047,  125941)
)

s  &lt;- sprague(x[,2])
s
  
all.equal(sum(s), sum(x[,2]))

</code></pre>

<hr>
<h2 id='spTable'>Cross tabulations of expected and realized population sizes.</h2><span id='topic+spTable'></span>

<h3>Description</h3>

<p>Compute contingency tables of expected (i.e., estimated) and realized (i.e.,
simulated) population sizes. The expected values are obtained with the
Horvitz-Thompson estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spTable(inp, select)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spTable_+3A_inp">inp</code></td>
<td>
<p>an object of class <code><a href="#topic+simPopObj-class">simPopObj</a></code> containing
household survey and simulated population data.</p>
</td></tr>
<tr><td><code id="spTable_+3A_select">select</code></td>
<td>
<p>character; vector defining the columns in slots 'pop' and
'sample' of argument 'input' that should be used for tabulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contingency tables are computed with <code><a href="#topic+tableWt">tableWt</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"spTable"</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>expected</code></td>
<td>
<p>the contingency table estimated from the survey data.</p>
</td></tr>
<tr><td><code>realized</code></td>
<td>
<p>the contingency table computed from the simulated population
data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Sampling weights are automatically used from the input object 'inp'!
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Bernhard Meindl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spMosaic">spMosaic</a></code>, <code><a href="#topic+tableWt">tableWt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)  # for reproducibility
data(eusilcS)   # load sample data
## Not run: 
samp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize",
  strata="db040", weight="db090")
eusilcP &lt;- simStructure(data=samp, method="direct", basicHHvars=c("age", "rb090"))
res &lt;- spTable(eusilcP, select = c("age", "rb090"))
class(res)
res

## End(Not run)
</code></pre>

<hr>
<h2 id='tableWt'>Weighted cross tabulation</h2><span id='topic+tableWt'></span>

<h3>Description</h3>

<p>Compute contingency tables taking into account sample weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableWt(x, weights = NULL, useNA = c("no", "ifany", "always"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tableWt_+3A_x">x</code></td>
<td>
<p>a vector that can be interpreted as a factor, or a matrix or
<code>data.frame</code> whose columns can be interpreted as factors.</p>
</td></tr>
<tr><td><code id="tableWt_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector containing sample weights.</p>
</td></tr>
<tr><td><code id="tableWt_+3A_usena">useNA</code></td>
<td>
<p>a logical indicating whether to include extra <code>NA</code> levels
in the table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each combination of the variables in <code>x</code>, the weighted number of
occurence is computed as the sum of the corresponding sample weights.  If
weights are not specified, the function <code><a href="base.html#topic+table">table</a></code> is applied.
</p>


<h3>Value</h3>

<p>The (weighted) contingency table as an object of class <code>table</code>,
an array of integer values.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Stefan Kraft
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>, <code><a href="#topic+contingencyWt">contingencyWt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eusilcS)
tableWt(eusilcS[, c("hsize", "db040")], weights = eusilcS$rb050)
tableWt(eusilcS[, c("rb090", "pb220a")], weights = eusilcS$rb050, 
    useNA = "ifany")

</code></pre>

<hr>
<h2 id='totalsRG'>Population totals Region times Gender for Austria 2006</h2><span id='topic+totalsRG'></span><span id='topic+totalsRGtab'></span>

<h3>Description</h3>

<p>Population characteristics Region times Gender from Austria.
</p>
<p>Using <code><a href="#topic+samp">samp</a></code> <code><a href="#topic+samp+3C-">samp&lt;-</a></code> it is possible to extract or
rather modify variables of the sample data within slot <code>data</code> in slot
<code>sample</code> of the <code><a href="#topic+simPopObj-class">simPopObj-class</a></code>-object. Using
<code><a href="#topic+pop">pop</a></code> <code><a href="#topic+pop+3C-">pop&lt;-</a></code> it is possible to extract or rather
modify variables of the synthetic population within in slot <code>data</code> in
slot <code>sample</code> of the <code><a href="#topic+simPopObj-class">simPopObj-class</a></code>-object.
</p>


<h3>Format</h3>

<p>totalsRG: A data frame with 18 observations on the following 3
variables.  </p>
 <dl>
<dt>list(&quot;rb090&quot;)</dt><dd><p>gender; a factor with levels
<code>female</code> <code>male</code></p>
</dd> <dt>list(&quot;db040&quot;)</dt><dd><p>region; a factor with levels
<code>Burgenland</code> <code>Carinthia</code> <code>Lower Austria,</code> <code>Salzburg</code>
<code>Styria</code> <code>Tyrol</code> <code>Upper Austria</code> <code>Vienna</code>
<code>Vorarlberg</code></p>
</dd> <dt>list(&quot;Freq&quot;)</dt><dd><p>totals; a numeric vector</p>
</dd> </dl>

<p>totalsRGtab: a two-dimensional table holding the same information
</p>
<p>totalsRG: A data frame with 18 observations on the following 3
variables.  </p>
 <dl>
<dt>list(&quot;rb090&quot;)</dt><dd><p>gender; a factor with levels
<code>female</code> <code>male</code></p>
</dd> <dt>list(&quot;db040&quot;)</dt><dd><p>region; a factor with levels
<code>Burgenland</code> <code>Carinthia</code> <code>Lower Austria,</code> <code>Salzburg</code>
<code>Styria</code> <code>Tyrol</code> <code>Upper Austria</code> <code>Vienna</code>
<code>Vorarlberg</code></p>
</dd> <dt>list(&quot;Freq&quot;)</dt><dd><p>totals; a numeric vector</p>
</dd> </dl>

<p>totalsRGtab: a two-dimensional table holding the same information
</p>


<h3>Details</h3>

<p>Population totals Region times Gender for Austria 2006
</p>
<p>Population characteristics Region times Gender from Austria.
</p>


<h3>Source</h3>

<p>StatCube - statistical data base,
<a href="http://www.statistik.at">http://www.statistik.at</a>
</p>
<p>StatCube - statistical data base,
<a href="http://www.statistik.at/">http://www.statistik.at/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(totalsRG)
totalsRG
data(totalsRGtab)
totalsRGtab
data(totalsRG)
totalsRG
data(totalsRGtab)
totalsRGtab
</code></pre>

<hr>
<h2 id='utility'>Utility measures</h2><span id='topic+utility'></span><span id='topic+utilityModal'></span><span id='topic+utilityIndicator'></span>

<h3>Description</h3>

<p>Various utility measues that basically compares two data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility(
  x,
  y,
  type = c("all", "compareColumns", "compareRows", "compareRowsHH", "compareNA"),
  hhid = NULL
)

utilityModal(x, y, varx, vary = NULL)

utilityIndicator(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utility_+3A_x">x</code></td>
<td>
<p>a data.frame, typically the original data set. For <code>utilityIndicator</code> this should be a vector of length 1.</p>
</td></tr>
<tr><td><code id="utility_+3A_y">y</code></td>
<td>
<p>a data.frame, typically the corresponding synthetic data set. For <code>utilityIndicator</code> this should be a vector of length 1.</p>
</td></tr>
<tr><td><code id="utility_+3A_type">type</code></td>
<td>
<p>which measure
</p>

<dl>
<dt>compareColumns</dt><dd><p>compares the intersection of variables</p>
</dd>
<dt>compareRows</dt><dd><p>compares the number of rows</p>
</dd>
<dt>compareRowsHH</dt><dd><p>compares the number of housholds</p>
</dd>
<dt>compareNA</dt><dd><p>compares the number of missings</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="utility_+3A_hhid">hhid</code></td>
<td>
<p>index or name of variable containing the houshold ID</p>
</td></tr>
<tr><td><code id="utility_+3A_varx">varx</code></td>
<td>
<p>name or index of a variable in data.frame x</p>
</td></tr>
<tr><td><code id="utility_+3A_vary">vary</code></td>
<td>
<p>NULL or name or index of a variable in data.frame y corresponding to variable varx in data.frame x. 
If NULL, the names of the selected variable should be the same in both x and y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the measure(s) of interest
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>utility()</code>: comparisons of two data sets
</p>
</li>
<li> <p><code>utilityModal()</code>: comparison of number of categories
</p>
</li>
<li> <p><code>utilityIndicator()</code>: difference between two values
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matthias Templ, Maxime Bergeaut
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
data(eusilcP)
## for fast caluclations, took a subsample

eusilcP &lt;- eusilcP[1:15000, ]
utility(eusilcS, eusilcP)


data(eusilcS)
data(eusilcP)
utilityModal(eusilcS, eusilcP, "age")
utilityModal(eusilcS, eusilcP, "pl030", "ecoStat")

data(eusilcS)
data(eusilcP)
m1 &lt;- meanWt(eusilcS$age, eusilcS$rb050) 
m2 &lt;- mean(eusilcP$age)
utilityIndicator(m1, m2)
</code></pre>

<hr>
<h2 id='weighted_estimators'>Weighted mean, variance, covariance matrix and correlation matrix</h2><span id='topic+weighted_estimators'></span><span id='topic+meanWt'></span><span id='topic+varWt'></span><span id='topic+covWt'></span><span id='topic+corWt'></span>

<h3>Description</h3>

<p>Compute mean, variance, covariance matrix and correlation matrix, taking
into account sample weights.
</p>

<ul>
<li> <p><code>meanWt</code>: a simple wrapper that calls <code>mean(x, na.rm=na.rm)</code> if
<code>weights</code> is missing and <code>weighted.mean(x, w=weights,
na.rm=na.rm)</code> otherwise. Implemented methods for this generic are:
</p>

<ul>
<li> <p><code>meanWt.default(x, weights, na.rm=TRUE, ...)</code>
</p>
</li>
<li> <p><code>meanWt.dataObj(x, vars, na.rm=TRUE, ...)</code>
</p>
</li></ul>

</li>
<li> <p><code>varWt</code>: calls <code>var(x, na.rm=na.rm)</code> if <code>weights</code> is missing.
Implemented methods for this generic are:
</p>

<ul>
<li> <p><code>varWt.default(x, weights, na.rm=TRUE, ...)</code>
</p>
</li>
<li> <p><code>varWt.dataObj(x, vars, na.rm=TRUE, ...)</code>
</p>
</li></ul>

</li>
<li> <p><code>covWt</code> and <code>covWt</code>: always remove missing values pairwise and call
<code>cov</code> and <code>cor</code>, respectively, if <code>weights</code> is missing.
Implemented methods for these generics are:
</p>

<ul>
<li> <p><code>covWt.default(x, y, weights, ...)</code>
</p>
</li>
<li> <p><code>covWt.matrix(x, weights, ...)</code>
</p>
</li>
<li> <p><code>covWt.data.frame(x, weights, ...) </code>
</p>
</li>
<li> <p><code>covWt.dataObj(x, vars, ...)</code>
</p>
</li>
<li> <p><code>corWt.default(x, y, weights, ...)</code>
</p>
</li>
<li> <p><code>corWt.matrix(x, weights, ...)</code>
</p>
</li>
<li> <p><code>corWt.data.frame(x, weights, ...)</code>
</p>
</li>
<li> <p><code>corWt.dataObj(x, vars, ...)</code>
</p>
</li></ul>

</li></ul>

<p>The additional parameters are now described:
</p>

<ul>
<li><p> y: a numeric vector.  If missing, this defaults to <code>x</code>.
</p>
</li>
<li><p> vars: a character vector of variable names that should be used for the
calculation.
</p>
</li>
<li><p> na.rm: a logical indicating whether any <code>NA</code> or <code>NaN</code> values
should be removed from <code>x</code> before computation.  Note that the default
is <code>TRUE</code>.
</p>
</li>
<li><p> weights: an optional numeric vector containing sample weights.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>meanWt(x, ...)

varWt(x, ...)

covWt(x, ...)

corWt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_estimators_+3A_x">x</code></td>
<td>
<p>for <code>meanWt</code> and <code>varWt</code>, a numeric vector or an object
of class <code><a href="#topic+dataObj-class">dataObj</a></code>. For <code>covWt</code> and <code>corWt</code>, a
numeric vector, matrix, <code>data.frame</code> or <code><a href="#topic+dataObj-class">dataObj</a></code>.
In case of a <code><a href="#topic+dataObj-class">dataObj</a></code>, weights are automatically used
from the S4-object itself.</p>
</td></tr>
<tr><td><code id="weighted_estimators_+3A_...">...</code></td>
<td>
<p>for the generic functions <code>covWt</code> and <code>corWt</code>,
additional arguments to be passed to methods.  Additional arguments not
included in the definition of the methods are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>meanWt</code>, the (weighted) mean.
</p>
<p>For <code>varWt</code>, the (weighted) variance.
</p>
<p>For <code>covWt</code>, the (weighted) covariance matrix or, for the default
method, the (weighted) covariance.
</p>
<p>For <code>corWt</code>, the (weighted) correlation matrix or, for the default
method, the (weighted) correlation coefficient.
</p>


<h3>Note</h3>

<p><code>meanWt</code>, <code>varWt</code>, <code>covWt</code> and <code>corWt</code> all make use of
slot <code>weights</code> of the input object if the <code>dataObj</code>-method is
used.
</p>


<h3>Author(s)</h3>

<p>Stefan Kraft and Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>,
<code><a href="stats.html#topic+cor">var</a></code>, <code><a href="stats.html#topic+cor">cov</a></code>,
<code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eusilcS)
meanWt(eusilcS$netIncome, weights=eusilcS$rb050)
sqrt(varWt(eusilcS$netIncome, weights=eusilcS$rb050))

# dataObj-methods
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
meanWt(inp, vars="netIncome")
sqrt(varWt(inp, vars="netIncome"))
corWt(inp, vars=c("age", "netIncome"))
covWt(inp, vars=c("age", "netIncome"))
</code></pre>

<hr>
<h2 id='whipple'>Whipple index (original and modified)</h2><span id='topic+whipple'></span>

<h3>Description</h3>

<p>The function calculates the original and modified Whipple index to evaluate
age heaping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whipple(x, method = "standard", weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whipple_+3A_x">x</code></td>
<td>
<p>numeric vector holding the age of persons</p>
</td></tr>
<tr><td><code id="whipple_+3A_method">method</code></td>
<td>
<p>&ldquo;standard&rdquo; or &ldquo;modified&rdquo; Whipple index.</p>
</td></tr>
<tr><td><code id="whipple_+3A_weight">weight</code></td>
<td>
<p>numeric vector holding the weights of each person</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original Whipple's index is obtained by summing the number of persons in
the age range between 23 and 62, and calculating the ratio of reported ages
ending in 0 or 5 to one-fifth of the total sample. A linear decrease in the
number of persons of each age within the age range is assumed. Therefore,
low ages (0-22 years) and high ages (63 years and above) are excluded from
analysis since this assumption is not plausible.
</p>
<p>When the digits 0 and 5 are not reported in the data, the original Whipple
index varies between 0 and 100, 100 if no preference for 0 or 5 is within
the data. When only the digits 0 and 5 are reported in the data it reaches a
to a maximum of 500.
</p>
<p>For the modified Whipple index, age heaping is calculated for all ten digits
(0-9). For each digit, the degree of preference or avoidance can be
determined for certain ranges of ages, and the modified Whipple index then
is given by the absolute sum of these (indices - 1). The index is scaled between
0 and 1, therefore it is 1 if all age values end with the same digit and 0 it is
distributed perfectly equally.
</p>


<h3>Value</h3>

<p>The original or modified Whipple index.
</p>


<h3>Author(s)</h3>

<p>Matthias Templ, Alexander Kowarik
</p>


<h3>References</h3>

<p>Henry S. Shryock and Jacob S. Siegel, Methods and Materials of
Demography (New York: Academic Press, 1976)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sprague">sprague</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Equally distributed
age &lt;- sample(1:100, 5000, replace=TRUE)
whipple(age)
whipple(age,method="modified")

# Only 5 and 10
age5 &lt;- sample(seq(0,100,by=5), 5000, replace=TRUE)
whipple(age5)
whipple(age5,method="modified")

#Only 10
age10 &lt;- sample(seq(0,100,by=10), 5000, replace=TRUE)
whipple(age10)
whipple(age10,method="modified")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
