<!DOCTYPE html><html lang="en"><head><title>Help for package ptycho</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ptycho}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ptycho-package'><p>Bayesian Variable Selection with Hierarchical Priors</p></a></li>
<li><a href='#checkConvergence'><p>Compute Differences Between MCMC Chains</p></a></li>
<li><a href='#createData'><p>Simulate Data</p></a></li>
<li><a href='#createGroupsSim'><p>Create Groups of Covariates</p></a></li>
<li><a href='#createOrthogonalX'><p>Create Design Matrix With Orthogonal Columns</p></a></li>
<li><a href='#Data'><p>Sample Data</p></a></li>
<li><a href='#PosteriorStatistics'><p>Extract Posterior Statistics</p></a></li>
<li><a href='#print.ptycho'><p>Print ptycho Object</p></a></li>
<li><a href='#ptycho'><p>Sample From Posterior Distributions</p></a></li>
<li><a href='#WhichCols'><p>Identify Columns Containing Indicator Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Variable Selection with Hierarchical Priors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-4</td>
</tr>
<tr>
<td>Author:</td>
<td>Laurel Stell and Chiara Sabatti</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laurel Stell &lt;lstell@stanford.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td>web.stanford.edu/~lstell/ptycho/</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Bayesian variable selection for linear regression models using hierarchical
  priors. There is a prior that combines information across responses and one
  that combines information across covariates, as well as a standard spike and
  slab prior for comparison. An MCMC samples from the marginal posterior
  distribution for the 0-1 variables indicating if each covariate belongs to the
  model for each response.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, plyr, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreach, doRNG</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-11-12 17:53:40 UTC; lstell</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-11-12 19:09:21</td>
</tr>
</table>
<hr>
<h2 id='ptycho-package'>Bayesian Variable Selection with Hierarchical Priors</h2><span id='topic+ptycho-package'></span>

<h3>Description</h3>

<p>Bayesian variable selection for linear regression models using hierarchical
priors. There is a prior that combines information across responses and one
that combines information across covariates, as well as a standard spike and
slab prior for comparison. An MCMC samples from the marginal posterior
distribution for the 0-1 variables indicating if each covariate belongs to the
model for each response.
</p>


<h3>Details</h3>

<p>This package provides functions to carry out Bayesian model selection combining
different layers of information: across multiple traits or across multiple
variants in the same gene.  The priors are described by Stell and Sabatti
(2015).  To sample the posterior distribution for specified genotype and
phenotype matrices, use <code><a href="#topic+ptycho">ptycho</a></code>.
</p>
<p>This package also provides functions to generate simulated data as in Stell and
Sabatti (2015); see <code><a href="#topic+createData">createData</a></code> and
<a href="web.stanford.edu/~lstell/ptycho/">web.stanford.edu/~lstell/ptycho/</a>.  Those datasets are not included in this
package because they have images about 20 MB or larger.  Instead small data
objects are included for examples; see <a href="#topic+Data">Data</a>.
</p>
<p>Functions for post-processing <code>ptycho</code> objects are described at
<code><a href="#topic+checkConvergence">checkConvergence</a></code> and <a href="#topic+PosteriorStatistics">PosteriorStatistics</a>.
</p>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Stell, L. and Sabatti, C. (2015) Genetic variant selection: learning across
traits and sites, arXiv:1504.00946.
</p>

<hr>
<h2 id='checkConvergence'>Compute Differences Between MCMC Chains</h2><span id='topic+checkConvergence'></span>

<h3>Description</h3>

<p>Compute the differences between the chains in a <code><a href="#topic+ptycho">ptycho</a></code> object
of the means of <code class="reqn">\tau</code> and the indicator variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkConvergence(obj, doLastIterOnly=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkConvergence_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+ptycho">ptycho</a></code> object</p>
</td></tr>
<tr><td><code id="checkConvergence_+3A_dolastiteronly">doLastIterOnly</code></td>
<td>
<p>Logical specifying whether to compute differences only
for the last MCMC iteration in the input object or for all iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">\tau</code> and each indicator variable in the input <code><a href="#topic+ptycho">ptycho</a></code>
object, compute the difference between the maximum and the minimum mean for
each chain.  If <code>doLastIterOnly</code> is <code>TRUE</code>, then the differences are
only computed for the last iteration in each chain; otherwise, the differences
are computed at each iteration in the input object.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt><code>iter</code></dt><dd><p>MCMC iteration number</p>
</dd>
<dt><code>type</code></dt><dd><p>Factor specifying the type of the variable; one of
&ldquo;tau&rdquo;, &ldquo;var&rdquo; for variant indicator variable, or &ldquo;grp&rdquo;
for second-level indicator variable</p>
</dd>
<dt><code>index</code></dt><dd><p>Number specifying the pertinent column in the design
matrix (for <code>type</code> equal to &ldquo;var&rdquo; or for <code>type</code> equal to
&ldquo;grp&rdquo; when <em>Across Traits</em> prior was used) or the variant
group index (for <code>type</code> equal to &ldquo;grp&rdquo; when <em>Across
Sites</em> prior was used);
equal to 1 for <code>type</code> equal to &ldquo;tau&rdquo;</p>
</dd>
<dt><code>y</code></dt><dd><p>Factor specifying the name of the response; empty for
<code>type</code> equal to &ldquo;tau&rdquo; or for <code>type</code> equal to &ldquo;grp&rdquo;
when <em>Across Traits</em> prior was used</p>
</dd>
<dt><code>range</code></dt><dd><p>Difference between maximum and minimum across chains</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptycho">ptycho</a></code>; also <code><a href="#topic+ptychoOut">ptychoOut</a></code> for example below
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ptychoOut)
cvg &lt;- checkConvergence(ptychoOut, doLastIterOnly=FALSE)
reshape2::dcast(cvg, ... ~ iter, value.var="range")
</code></pre>

<hr>
<h2 id='createData'>Simulate Data</h2><span id='topic+createData'></span><span id='topic+createDataBayesModel'></span><span id='topic+createPubData'></span>

<h3>Description</h3>

<p>Create a data object suitable for <code><a href="#topic+ptycho.all">ptycho.all</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createData(X, y, omega = NULL, beta = NULL)
createDataBayesModel(mode = c("exchange","pleiotropy","gene"), n, p, q,
                     nreps, tau.min, tau.max, G)
createPubData(mode = c("tinysim","ptychoIn",
                       "exchange","pleiotropy","gene",
                       "actualGeno","actualPheno","corTest",
                       "fixedOmega","uniformEffects"),
              X=NULL, y=NULL, var.detail=NULL, variants=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createData_+3A_x">X</code></td>
<td>
<p>Design matrix or alist specifying how to generate such a matrix.  If
a list, the first entry is a function name and the second is a list of
arguments to the function.  In <code>createPubData</code>, <code>X</code> is ignored
unless <code>mode</code> is &ldquo;actualGeno&rdquo;, &ldquo;actualPheno&rdquo;, or
<code>corTest</code>.</p>
</td></tr>
<tr><td><code id="createData_+3A_y">y</code></td>
<td>

<p>Numeric vector or matrix or list with the following components:
</p>

<dl>
<dt><code>nreps</code></dt><dd><p>Number of replicates to simulate</p>
</dd>
<dt><code>q</code></dt><dd><p>Number of responses to generate for each replicate</p>
</dd>
<dt><code>sd</code></dt><dd><p>Standard deviation of the simulated noise</p>
</dd>
</dl>

<p>In <code>createPubData</code>, <code>y</code> is ignored unless <code>mode</code> is
&ldquo;actualPheno&rdquo;.</p>
</td></tr>
<tr><td><code id="createData_+3A_omega">omega</code></td>
<td>
<p>Numeric vector or matrix or list specifying how to generate a
list with the component <code>omega</code>; see Details for its meaning.  If this
is a list, the first entry is a function name and the second is a list of
arguments to the function, which will be prepended by the number of rows in
output <code>X</code> and the number of columns in output <code>y</code>.  Only used if
<code>y</code> is a list.</p>
</td></tr>
<tr><td><code id="createData_+3A_beta">beta</code></td>
<td>
<p>List specifying how to generate a matrix of effect sizes.  The
first entry of the list is a function name and the second is a list of
arguments to the function, which will be prepended by a matrix specifying
the variables selected and <code>y$sd</code>.  Only used if <code>y</code> is a list.</p>
</td></tr>
<tr><td><code id="createData_+3A_n">n</code></td>
<td>
<p>Number of observations to simulate</p>
</td></tr>
<tr><td><code id="createData_+3A_p">p</code></td>
<td>
<p>Number of covariates to simulate</p>
</td></tr>
<tr><td><code id="createData_+3A_q">q</code></td>
<td>
<p>Number of responses to simulate for each replicate</p>
</td></tr>
<tr><td><code id="createData_+3A_nreps">nreps</code></td>
<td>
<p>Number of replicates to simulate</p>
</td></tr>
<tr><td><code id="createData_+3A_mode">mode</code></td>
<td>
<p>String specifying type of dataset to create:
</p>

<dl>
<dt><code>tinysim</code></dt><dd><p>Simulated data included with this package;
equivalent to mode <code>pleiotropy</code> except that the dataset is tiny,
with <code>n=100</code>, <code>p=10</code>, <code>q=5</code>, and <code>nreps=10</code></p>
</dd>
<dt><code>ptychoIn</code></dt><dd><p>Simulated data included with this package;
equivalent to mode <code>gene</code> except that the dataset is tiny,
with <code>n=3000</code>, <code>p=10</code>, <code>q=1</code>, and <code>nreps=1</code></p>
</dd>
<dt><code>exchange</code></dt><dd><p>Create orthogonal <code>X</code> and exchangeable
variants; <code>n=5000</code>, <code>p=50</code>, <code>q=5</code>, and <code>nreps=100</code></p>
</dd>
<dt><code>pleiotropy</code></dt><dd><p>Create orthogonal <code>X</code>, and several variants
have nonzero effects on multiple responses; <code>n=5000</code>, <code>p=50</code>,
<code>q=5</code>, and <code>nreps=100</code></p>
</dd>
<dt><code>gene</code></dt><dd><p>Create orthogonal <code>X</code>, and each group of variants
typically has either several or no variants that effect a response;
<code>n=5000</code>, <code>p=50</code>, <code>q=5</code>, and <code>nreps=100</code></p>
</dd>
<dt><code>actualGeno</code></dt><dd><p>Simulate responses for input <code>X</code></p>
</dd>
<dt><code>corTest</code></dt><dd><p>Simulate <code>q=2</code> responses for input <code>X</code>.
There will be 10 replicates with the first variant in argument
<code>variants</code> causal for both responses, 10 with the second variant
causal, and 20 with variant <code>i</code> causal for response <code>i</code>.  No
other variant will be causal.</p>
</dd>
<dt><code>actualPheno</code></dt><dd><p>Put input <code>X</code> and <code>y</code> into data
object</p>
</dd>
<dt><code>fixedOmega</code></dt><dd><p>Create orthogonal <code>X</code>, and each variant has
a certain probability of a nonzero effect size</p>
</dd>
<dt><code>uniformEffects</code></dt><dd><p>Same as mode <code>fixedOmega</code> except that
effect sizes are uniformly rather than normally distributed</p>
</dd>
</dl>

<p>For <code>createDataBayesModel</code>, <code>mode</code> must be one of
&ldquo;exchange&rdquo;, &ldquo;pleiotropy&rdquo;, or &ldquo;gene&rdquo;.</p>
</td></tr>
<tr><td><code id="createData_+3A_tau.min">tau.min</code>, <code id="createData_+3A_tau.max">tau.max</code></td>
<td>
<p>Endpoints of uniform distribution from which to draw
<code>tau</code></p>
</td></tr>
<tr><td><code id="createData_+3A_g">G</code></td>
<td>
<p>Number of groups of covariates; unused if <code>mode</code> is not
&ldquo;gene&rdquo;</p>
</td></tr>
<tr><td><code id="createData_+3A_var.detail">var.detail</code></td>
<td>
<p>Data frame with row names same as column names of <code>X</code>;
must have columns &ldquo;MAF&rdquo; and &ldquo;GENE&rdquo;.  Ignored unless
<code>mode</code> is &ldquo;actualGeno&rdquo;.</p>
</td></tr>
<tr><td><code id="createData_+3A_variants">variants</code></td>
<td>
<p>Character vector containing names of two columns of <code>X</code>;
ignored unless <code>mode</code> is &ldquo;corTest&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We describe <code>createData</code> and then describe its wrappers
<code>createDataBayesModel</code> and <code>createPubData</code>.
</p>
<p>Although <code>createData</code> can form the data object required by
<code>ptycho.all</code> when <code>X</code> and <code>y</code> are input, it primarily exists to
simplify simulating data from <code class="reqn">Y=X\beta+\epsilon</code>, where
<code class="reqn">\epsilon</code> is normal with mean zero and specified standard deviation and
<code class="reqn">\beta</code> is sparse with entries simulated as specified.
</p>
<p>The function generates a specified number of replicates, all of which use the
same design matrix <code class="reqn">X</code>.  If this matrix is not input, then its argument
must specify a function call to generate it.  In either case, suppose <code class="reqn">X</code>
has <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.
</p>
<p>If the input <code>y</code> is numeric, then it will be used for the lone replicate.
If it is a matrix, it must have <code class="reqn">n</code> rows; let <code class="reqn">q</code> be its number of
columns.  If input <code>y</code> is a numeric vector, it must have <code class="reqn">n</code> entries
and will be cast as a matrix with <code class="reqn">q=1</code> column.  Otherwise, input <code>y</code>
is a list specifying, along with the arguments <code>omega</code> and <code>beta</code>,
how to simulate the response(s).  Because it is useful in analysis of the
estimation of the marginal posterior distribution, the returned object always
contains, regardless of how <code>X</code> and <code>y</code> are specified, a matrix
<code>eta2</code> with <code class="reqn">(j,k)</code> entry equal to
<code class="reqn">\mathbf{x}_j^T \mathbf{y}_k / (n \mathbf{y}_k^T \mathbf{y}_k)</code>
</p>
<p>If <code>y</code> is to be simulated, the first step is to choose the probability
that each covariate is associated with each reponse as specified by the input
argument <code>omega</code>.  If this argument is a matrix, it must have size
<code class="reqn">p</code>-by-<code class="reqn">q</code>.  If it is not a matrix but is numeric, it will be passed
to <code><a href="base.html#topic+matrix">matrix</a></code> to create a matrix of the correct size.  Otherwise,
the matrix for each replicate will be generated by calling the function whose
name is given by <code>omega[[1]]</code> with argument list
<code>(p, q, omega[[2]])</code>.  This function must return a list with component
<code>omega</code> set to a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix; the list may also contain
additional components.  The package contains several functions whose names
start with &ldquo;createOmega&rdquo; that might guide users in writing their own
functions.
</p>
<p>The next step is to draw a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix <code>indic.var</code> whose
<code class="reqn">(j,k)</code> entry is equal to one with probability <code>omega[j,k]</code> and zero
otherwise.  This matrix will be drawn until all column sums are positive.
</p>
<p>For each entry in <code>indic.var</code> that is equal to one, the effect size must
be drawn.  This is done by calling the function whose name is given by
<code>beta[[1]]</code> with argument list <code>(indic.var, y$sd, beta[[2]])</code>.  This
function must return a list with component <code>beta</code> set to a
<code class="reqn">p</code>-by-<code class="reqn">q</code> matrix; the list may also contain additional components.
If <code>indic.var[j,k]</code> is zero, then <code>beta[j,k]</code> should be zero.  The
package contains functions whose names start with &ldquo;createBeta&rdquo; that
might guide users in writing their own functions.
</p>
<p>Finally, an <code class="reqn">n</code>-by-<code class="reqn">q</code> matrix of noise is drawn from
<code class="reqn">N(0,\sigma^2)</code>, where <code class="reqn">\sigma</code> is the input <code>noise.sd</code>, and
added to <code class="reqn">X\beta</code> to obtain <code>y</code>.  The column names of each
response matrix generated will be <code>y1</code>, <code>y2</code>, and so forth.
</p>
<p>The function <code>createPubData</code> generates the data sets used in Stell and
Sabatti (2015).  For <code>mode</code> equal to &ldquo;exchange&rdquo;,
&ldquo;pleiotropy&rdquo;, or &ldquo;geno&rdquo;, it calls <code>createData</code> via
<code>createDataBayesModel</code>; otherwise, it calls <code>createData</code> directly.
These functions also serve as additional examples of the use of
<code>createData</code>.  For reproducibility, <code>createPubData</code> first sets the
random seed to 1234, except that it is set to 4 when <code>mode</code> equals
&ldquo;ptychoIn&rdquo; and it does not set it when <code>mode</code> equals
&ldquo;corTest&rdquo;.
</p>
<p>In <code>createDataBayesModel</code>, if <code>mode</code> is &ldquo;exchange&rdquo;, then
one <code class="reqn">\omega \sim \mbox{Beta}(12,48)</code> is drawn
independently for each trait.  If <code>mode</code> is &ldquo;pleiotropy&rdquo;, then one
probability of association for a trait is drawn from Beta(16,55) for each data
set, that probability is used to draw <code>indic.grp</code> for each variant, and
then the probability of nonzero <code>indic.var[j,k]</code> is drawn from
Beta(48,12) for each nonzero <code>indic.grp[j]</code>.  Finally, if <code>mode</code> is
&ldquo;gene&rdquo;, the process is analogous to pleiotropy except that each trait
is simulated independently.
</p>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>Design matrix</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Number of columns in each response</p>
</td></tr>
<tr><td><code>noise.sd</code></td>
<td>
<p>Standard deviation of the simulated noise; <code>NULL</code> if
input <code>y</code> is numeric</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>Input <code>omega</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Input <code>beta</code></p>
</td></tr>
<tr><td><code>replicates</code></td>
<td>
<p>List of length <code>y$nreps</code> (length 1 if <code>y</code> is
numeric), each entry of which is a list with the following components:
</p>

<dl>
<dt><code>omega</code></dt><dd><p>Matrix containing probabilities of association between
covariates and responses; row names are <code>colnames(X)</code> and column
names are <code>colnames(y)</code>; <code>NULL</code> if input <code>y</code> is numeric</p>
</dd>
<dt><code>indic.var</code></dt><dd><p>Matrix containing ones for associations and zeros
otherwise; row and column names are same as for <code>omega</code>;
<code>NULL</code> if input <code>y</code> is numeric</p>
</dd>
<dt><code>beta</code></dt><dd><p>Matrix of effect sizes; row and column names are same
as for <code>omega</code>; <code>NULL</code> if input <code>y</code> is numeric</p>
</dd>
<dt><code>y</code></dt><dd><p>Response matrix</p>
</dd>
<dt><code>eta2</code></dt><dd><p>Matrix with row names equal to <code>colnames(X)</code> and
column names equal to <code>colnames(y)</code></p>
</dd>
</dl>

<p>For <code>createDataBayesModel</code> with <code>mode</code> that uses a second level of
indicator variables, each entry in the <code>replicate</code> list also has
components <code>omega.grp</code> and <code>indic.grp</code> containing the intermediate
steps of drawing the second-level indicator variable before drawing
<code>omega</code>.  If the argument <code>beta</code> to <code>createData</code> is
&ldquo;createBetaNormal&rdquo; (which it is when called by
<code>createDataBayesModel</code>), then each replicate will also have a component
<code>tau</code> giving the value drawn by a call to
<code>runif(1, tau.min, tau.max)</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Stell, L. and Sabatti, C. (2015) Genetic variant selection: learning across
traits and sites, arXiv:1504.00946.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createOrthogonalX">createOrthogonalX</a></code>, <code><a href="#topic+createGroupsSim">createGroupsSim</a></code>;
also <a href="#topic+Data">Data</a> describes <code>tinysim</code> in example below as well as another
object output by <code>createData</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### EXAMPLE 1
data(tinysim)
# Data generated with mode equal to pleiotropy, so indic.grp exists and
# has an entry for each column in X.
colnames(tinysim$X)
tinysim$replicates[[5]]$indic.grp
# X4, X6, and X9 are associated with some responses.
tinysim$replicates[[5]]$indic.var

### EXAMPLE 2
# Generate miniature data set with information shared across covariates.
set.seed(1234)
tiny1 &lt;- createDataBayesModel(mode="gene", n=100, p=10, q=5, nreps=10,
                              tau.min=0.045, tau.max=0.063, G=2)
# A covariate can only have indic.var=1 if the group it belongs to has
# indic.grp=1.  For example,indic.grp[1,4]=0 implies
# indic.var[groups$group2var[1],4]=0.
tiny1$replicates[[1]]$indic.grp
tiny1$omega[[2]]$groups$group2var[1]
tiny1$replicates[[1]]$indic.var

### EXAMPLE 3
# Alternatively, call createData directly
groups &lt;- createGroupsSim(G=2, p=10)
omegaargs &lt;- list(indic.grp.shape1=16, indic.grp.shape2=55,
                  shape1=48, shape2=12, groups=groups)
betaargs &lt;- list(tau.min=0.045, tau.max=0.063)
set.seed(1234)
tiny2 &lt;- createData(X=list("createOrthogonalX", list(n=100, p=10)),
                    y=list(nreps=10, q=5, sd=1),
                    omega=list("createOmegaCrossVars", omegaargs),
                    beta=list("createBetaNormal", betaargs))
identical(tiny1, tiny2)
### SEE THE CODE FOR createPubData FOR MORE EXAMPLES.
</code></pre>

<hr>
<h2 id='createGroupsSim'>Create Groups of Covariates</h2><span id='topic+createGroupsSim'></span>

<h3>Description</h3>

<p>Create an object specifying groups of covariates as needed for some of the
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGroupsSim(G, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createGroupsSim_+3A_g">G</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code id="createGroupsSim_+3A_p">p</code></td>
<td>
<p>Number of covariates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>G</code> divides <code>p</code>, then each group will have <code>p/G</code> consecutive
covariates.  If <code>G</code> does not divide <code>p</code>, then the last group will
have fewer covariates.
</p>


<h3>Value</h3>

<p>List containing the following components:
</p>

<dl>
<dt><code>var2group</code></dt><dd><p>Integer vector of length <code>p</code>, with entry
<code class="reqn">j</code> being the index of the group containing covariate <code class="reqn">j</code></p>
</dd>
<dt><code>group2var</code></dt><dd><p>List of length <code>G</code>, each entry of which is an
integer vector containing the indices of the covariates belonging to that
group</p>
</dd>
<dt><code>sizes</code></dt><dd><p>Vector of length <code>G</code> containing the number of
covariates in each group</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createData">createData</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>grp &lt;- createGroupsSim(G=3, p=15)
# Which covariates are in group 2?  Two ways to find out:
which(grp$var2group == 2)
grp$group2var[[2]]
</code></pre>

<hr>
<h2 id='createOrthogonalX'>Create Design Matrix With Orthogonal Columns</h2><span id='topic+createOrthogonalX'></span>

<h3>Description</h3>

<p>Create a design matrix whose columns are orthogonal to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createOrthogonalX(n, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createOrthogonalX_+3A_n">n</code></td>
<td>
<p>Number of rows in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="createOrthogonalX_+3A_p">p</code></td>
<td>
<p>Number of columns in <code class="reqn">X</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>First create
<code class="reqn">\hat{X} = (I_p\,\,\,I_p\,\,\,\cdots\,\,\,I_p)^T,</code>
where <code class="reqn">I_p</code>, the identity matrix of size <code class="reqn">p</code>, is repeated
<code>ceiling(n/p)</code> times.  If <code>p</code> does not divide <code>n</code>, remove
rows at the bottom so that <code class="reqn">\hat{X}</code> has <code>n</code> rows.  Divide by the
root mean square of the columns of <code class="reqn">\hat{X}</code>.
</p>


<h3>Value</h3>

<p>Matrix with <code>n</code> rows, <code>p</code> columns, and column names <code>X1</code>,
<code>X2</code>, and so forth.
</p>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createData">createData</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50; p &lt;- 5
X &lt;- createOrthogonalX(n, p)
XtX &lt;- t(X) %*% X
D &lt;- diag(n-1, nrow=p)
# XtX and D are not quite equal due to roundoff error
range(XtX - D)
</code></pre>

<hr>
<h2 id='Data'>Sample Data</h2><span id='topic+Data'></span><span id='topic+tinysim'></span><span id='topic+ptychoIn'></span><span id='topic+ptychoOut'></span>

<h3>Description</h3>

<p>Data objects used in examples in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tinysim)
data(ptychoIn)
data(ptychoOut)
</code></pre>


<h3>Format</h3>

<p>The object <code>tinysim</code> is an object returned by
<code><a href="#topic+createDataBayesModel">createDataBayesModel</a></code> with <code>mode</code> equal to
&ldquo;pleiotropy&rdquo;.
</p>
<p>The object <code>ptychoIn</code> is an object returned by
<code><a href="#topic+createDataBayesModel">createDataBayesModel</a></code> with <code>mode</code> equal to
&ldquo;gene&rdquo;.
</p>
<p>The object <code>ptychoOut</code> is an object returned by
<code><a href="#topic+ptycho">ptycho</a></code> applied to the data in <code>ptychoIn</code> using the
<em>Across Sites</em> prior.
</p>


<h3>Details</h3>

<p>These data objects are constructed to illustrate certain features in the
examples while still being small enough not to be burdensome.
</p>
<p>The object <code>tinysim</code> contains simulated data.  Its design matrix is
100-by-10. It has 10 replicates, each with a 100-by-5 response matrix.  It
is generated by <code><a href="#topic+createPubData">createPubData</a></code>.
</p>
<p>The object <code>ptychoIn</code> also contains simulated data generated by
<code><a href="#topic+createPubData">createPubData</a></code>.  Its design matrix is 3000-by-10 because, for its
effect sizes, <code>n</code> must be about that large to distinguish signal from
noise as explained in the supplemental text to Stell and Sabatti (2015).  To
keep the object small, it has only 1 replicate, which has only one response.
</p>
<p>The object <code>ptychoOut</code> is generated by
</p>
<pre>
    G &lt;- 2; p &lt;- ncol(ptychoIn$X)
    groups &lt;- createGroupsSim(G, p)
    state &lt;- list(list(indic.grp=rep(FALSE,G),
                       indic.var=matrix(FALSE,nrow=p,ncol=1), tau=1),
                  list(indic.grp=rep(TRUE,G),
                       indic.var=matrix(TRUE,nrow=p,ncol=1), tau=1))
    ptychoOut &lt;- ptycho(X=ptychoIn$X, y=ptychoIn$replicates[[1]]$y,
                        groups=groups, initStates=state,
                        only.means=10000*seq_len(5), random.seed=12345)
  </pre>


<h3>Source</h3>

<p>Stell, L. and Sabatti, C. (2015) Genetic variant selection: learning across
traits and sites, arXiv:1504.00946.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createPubData">createPubData</a></code>, <code><a href="#topic+ptycho">ptycho</a></code></p>

<hr>
<h2 id='PosteriorStatistics'>Extract Posterior Statistics</h2><span id='topic+PosteriorStatistics'></span><span id='topic+meanTau'></span><span id='topic+varTau'></span><span id='topic+meanIndicators'></span><span id='topic+meanVarIndicators'></span><span id='topic+meanGrpIndicators'></span>

<h3>Description</h3>

<p>Extract posterior statistics from a <code><a href="#topic+ptycho">ptycho</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanTau(obj)
varTau(obj)
meanIndicators(obj)
meanVarIndicators(obj)
meanGrpIndicators(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PosteriorStatistics_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+ptycho">ptycho</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+ptycho">ptycho</a></code> object contains means for many different variables.  If
multiple chains were run, it has separate means for each, and it may have
running means from different points within each chain.  The functions
described here simplify extracting from the input object certain statistics of
the posterior distribution sampled by <code><a href="#topic+ptycho">ptycho</a></code>.
</p>
<p>The function <code>meanTau</code> identifies the last iteration saved in the input
<code><a href="#topic+ptycho">ptycho</a></code> object and computes the mean of <code class="reqn">\tau</code> at that
iteration across all chains.  The function <code>varTau</code> is analogous,
computing var<code class="reqn">(\tau)</code>.
</p>
<p>Similarly, <code>meanIndicators</code> returns the mean across all chains of each
indicator variable.  The functions <code>meanVarIndicators</code> and
<code>meanGrpIndicators</code> compute the means only of the indicators of variants
or only of second-level indicator variables, respectively.
</p>


<h3>Value</h3>

<p>Both <code>meanTau</code> and <code>varTau</code> return a scalar.
</p>
<p>The other functions, which extract means of indicator variables, return
vectors with names copied from the column names of the input <code>obj</code>.
</p>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptycho">ptycho</a></code>, <a href="#topic+WhichCols">WhichCols</a>; also <a href="#topic+Data">Data</a> describes
<code>ptychoIn</code> and <code>ptychoOut</code> in example below
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ptychoIn)
data(ptychoOut)
# Compare averages of sampled group indicator variables to truth.
cbind(ptychoIn$replicates[[1]]$indic.grp,
      meanGrpIndicators(ptychoOut))
# Compare averages of sampled covariate indicator variables to truth.
cbind(ptychoIn$replicates[[1]]$indic.var,
      meanVarIndicators(ptychoOut))
# Compare average of sampled values of tau to truth.
ptychoIn$replicates[[1]]$tau
meanTau(ptychoOut)
# Variance of sampled values of tau is reasonable because sampled model
# is usually NOT empty.
varTau(ptychoOut)
</code></pre>

<hr>
<h2 id='print.ptycho'>Print ptycho Object</h2><span id='topic+print.ptycho'></span>

<h3>Description</h3>

<p>Print the sample means in a <code>ptycho</code> object; do not print the
attributes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptycho'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ptycho_+3A_x">x</code></td>
<td>
<p>Object of class <code>ptycho</code></p>
</td></tr>
<tr><td><code id="print.ptycho_+3A_...">...</code></td>
<td>
<p>Additional print arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptycho">ptycho</a></code></p>

<hr>
<h2 id='ptycho'>Sample From Posterior Distributions</h2><span id='topic+ptycho'></span><span id='topic+ptycho.all'></span>

<h3>Description</h3>

<p>Generate MCMC samples from posterior distribution.  Two interfaces are
provided: <code>ptycho</code> generates samples for one design matrix and response
matrix while <code>ptycho.all</code> runs in batch an object generated by
<code><a href="#topic+createData">createData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptycho(X, y, initStates, groups = NULL,
       tau.min = 0.01, tau.max = 10, tau.sd = (tau.max - tau.min)/4,
       doGPrior = TRUE, doDetPrior = FALSE, prob.varadd = 0.5,
       isOmegaFixed = FALSE, omega = NULL, omega.grp = NULL,
       probs.grp = NULL, rho.alpha = 10, rho.lambda = rho.alpha,
       only.means = FALSE, nburn = 0, nthin = 1, nSavePerChain,
       parallel.chains=FALSE, random.seed=NULL)
ptycho.all(data, across=c("none","traits","sites"), doGrpIndicator,
           dir.out, nreplicates=NULL, parallel.replicates=FALSE,
           doSetSeed=TRUE, ncolumns=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptycho_+3A_x">X</code></td>
<td>
<p><code class="reqn">n</code>-by-<code class="reqn">p</code> design matrix</p>
</td></tr>
<tr><td><code id="ptycho_+3A_y">y</code></td>
<td>
<p><code class="reqn">n</code>-by-<code class="reqn">q</code> matrix containing response(s)</p>
</td></tr>
<tr><td><code id="ptycho_+3A_initstates">initStates</code></td>
<td>
<p>List containing initial states for chains.  Each state is a
list with components:
</p>

<dl>
<dt><code>indic.var</code></dt><dd><p><code class="reqn">p</code>-by-<code class="reqn">q</code> logical matrix.  If <code class="reqn">(j,k)</code>
entry is <code>TRUE</code>, then covariate <code class="reqn">j</code> is initially in the model
for response <code class="reqn">k</code>.</p>
</dd>
<dt><code>tau</code></dt><dd><p>Scalar</p>
</dd>
<dt><code>indic.grp</code></dt><dd><p>Logical vector of length equal to the number of
groups; analogous to <code>indic.var</code>; <code>NULL</code> to use priors that do
not incorporate a second-level indicator variable
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ptycho_+3A_groups">groups</code></td>
<td>
<p>To combine information across variants, list containing
</p>

<dl>
<dt><code>var2group</code></dt><dd><p>Integer vector of length <code class="reqn">p</code>, with entry
<code class="reqn">j</code> being the index of the group containing covariate <code class="reqn">j</code></p>
</dd>
<dt><code>group2var</code></dt><dd><p>List of length <code class="reqn">G</code>, each entry of which is an
integer vector containing the indices of the covariates belonging to
that group</p>
</dd>
<dt><code>sizes</code></dt><dd><p>Vector of length <code class="reqn">G</code> containing the number of
covariates in each group</p>
</dd>
</dl>

<p>Otherwise, <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="ptycho_+3A_tau.min">tau.min</code>, <code id="ptycho_+3A_tau.max">tau.max</code></td>
<td>
<p>Endpoints of uniform prior distribution on <code>tau</code></p>
</td></tr>
<tr><td><code id="ptycho_+3A_tau.sd">tau.sd</code></td>
<td>
<p>Standard deviation of the Metropolis-Hastings proposal
distribution for <code>tau</code></p>
</td></tr>
<tr><td><code id="ptycho_+3A_dogprior">doGPrior</code></td>
<td>
<p>Logical indicating whether to use the g-prior for effect
sizes</p>
</td></tr>
<tr><td><code id="ptycho_+3A_dodetprior">doDetPrior</code></td>
<td>
<p>Unsupported; use default value</p>
</td></tr>
<tr><td><code id="ptycho_+3A_prob.varadd">prob.varadd</code></td>
<td>
<p>If <code>initStates[[1]]]$indic.grp</code> is <code>NULL</code>, the
probability that the Metropolis-Hastings proposal changes one entry of
<code>indic.var</code> from <code>FALSE</code> to <code>TRUE</code>.  Otherwise, the
probability of this event given that the proposal does not change
<code>indic.grp</code>.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_isomegafixed">isOmegaFixed</code></td>
<td>
<p>Logical indicating whether <code>omega</code> is known</p>
</td></tr>
<tr><td><code id="ptycho_+3A_omega">omega</code></td>
<td>
<p>If <code>isOmegaFixed</code> is <code>TRUE</code>, a <code class="reqn">p</code>-by-<code class="reqn">q</code>
matrix containing the known probabilities.  Otherwise, a matrix containing
the parameters for the Beta prior distribution on <code>omega</code>.  Such a
matrix has columns &ldquo;A&rdquo; and &ldquo;B&rdquo;; the number of rows should be:
</p>

<ul>
<li><p> 1 if <code class="reqn">q=1</code> and <code>initStates[[1]]$indic.grp</code> is <code>NULL</code>,
</p>
</li>
<li> <p><code>length(groups$group2var)</code> if that is nonzero, or
</p>
</li>
<li> <p><code class="reqn">p</code> otherwise.
</p>
</li></ul>

<p>If <code>omega</code> is <code>NULL</code> and <code>isOmegaFixed</code> is <code>FALSE</code>,
defaults to uniform priors.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_omega.grp">omega.grp</code></td>
<td>
<p>If <code>isOmegaFixed</code> is <code>TRUE</code>, the known probability
that entries in <code>indic.grp</code> are <code>TRUE</code>.  Otherwise, a vector with
names &ldquo;A&rdquo; and &ldquo;B&rdquo; containing the parameters for the Beta prior
distribution on <code>omega.grp</code>.  If <code>NULL</code>, defaults to uniform
priors.  Unused if <code>initStates[[1]]$indic.grp</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_probs.grp">probs.grp</code></td>
<td>
<p>Vector containing the probabilities that the
Metropolis-Hastings proposal will add, leave unchanged, or remove,
respectively, a group.  If <code>NULL</code>, defaults to <code>c(0.25,0.5,0.25)</code>.
Unused if <code>initStates[[1]]$indic.grp</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_rho.alpha">rho.alpha</code>, <code id="ptycho_+3A_rho.lambda">rho.lambda</code></td>
<td>
<p>Parameters for the Gamma prior distribution on
<code class="reqn">\rho</code>, which is the precision of the noise.  Here, the
Gamma<code class="reqn">(\alpha,\lambda)</code> distribution has density function proportional
to <code class="reqn">x^\alpha e^{-\lambda x}</code>.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_only.means">only.means</code></td>
<td>
<p>If logical, specifies whether to return samples or the
running means of the samples.  Can also be a vector containing the
iterations (after the burn-in interval) at which to save the means.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_nburn">nburn</code></td>
<td>
<p>Number of MCMC samples to make before starting to save samples or
to compute means</p>
</td></tr>
<tr><td><code id="ptycho_+3A_nthin">nthin</code></td>
<td>
<p>Interval between saved samples; default value 1 saves all
samples.  Unused if <code>only.means</code> is <code>TRUE</code> or a vector.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_nsaveperchain">nSavePerChain</code></td>
<td>
<p>If <code>only.means</code> is <code>FALSE</code>, number of MCMC
samples to return from each chain, which means a total of
<code>nthin * nSavePerChain + nburn</code> samples are drawn per chain.  If
<code>only.means</code> is <code>TRUE</code>, then <code>nSavePerChain + nburn</code> samples
are drawn, and only the averages of the last <code>nSavePerChain</code> samples
are returned.  Unused if <code>only.means</code> is not a logical.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_parallel.chains">parallel.chains</code></td>
<td>
<p>Logical indicating whether to run chains in parallel;
see Details.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_random.seed">random.seed</code></td>
<td>
<p>Random seed to pass to chain iterator; if <code>NULL</code>, the
random seed is not set.  See Details.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_data">data</code></td>
<td>
<p>Data in format output by <code><a href="#topic+createData">createData</a></code></p>
</td></tr>
<tr><td><code id="ptycho_+3A_across">across</code></td>
<td>
<p>Whether to combine information across traits, sites, or
neither</p>
</td></tr>
<tr><td><code id="ptycho_+3A_dogrpindicator">doGrpIndicator</code></td>
<td>
<p>Whether to use priors that incorporate <code>indic.grp</code></p>
</td></tr>
<tr><td><code id="ptycho_+3A_dir.out">dir.out</code></td>
<td>
<p>Directory to which to <code><a href="base.html#topic+save">save</a></code> samples or means</p>
</td></tr>
<tr><td><code id="ptycho_+3A_nreplicates">nreplicates</code></td>
<td>
<p>Vector of replicates to run; if <code>NULL</code>, all will be run</p>
</td></tr>
<tr><td><code id="ptycho_+3A_parallel.replicates">parallel.replicates</code></td>
<td>
<p>Logical indicating whether to run replicates in
parallel; see Details.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_dosetseed">doSetSeed</code></td>
<td>
<p>If <code>TRUE</code>, call <code>set.seed(n.repl)</code> before running
samples.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_ncolumns">ncolumns</code></td>
<td>
<p>Scalar. If <code>across</code> is &ldquo;none&rdquo; or
&ldquo;sites&rdquo;, each of the first <code>ncolumns</code> of <code>repl$y</code> will
be used in turn, running all columns by default.  Ignored if <code>across</code>
is &ldquo;sites&rdquo;.</p>
</td></tr>
<tr><td><code id="ptycho_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>ptycho</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions run MCMC sampling from the posterior of the linear regression
models using hierarchical priors described in Stell and Sabatti (2015).  The
function <code>ptycho.all</code> is a wrapper of <code>ptycho</code> to simplify running
the simulation experiments over many replicates.  These functions determine
which priors to use as follows:
</p>

<ul>
<li><p> Standard spike and slab priors that do not combine information
(basic)<br />
For <code>ptycho.all</code>, argument <code>across</code> is &ldquo;none&rdquo; and
<code>doGrpIndicator</code> is <code>FALSE</code>.<br />
For <code>ptycho</code>, argument <code>y</code> has one column, <code>groups</code> is
<code>NULL</code>, and <code>indic.grp</code> is <code>NULL</code> or missing in each entry of
<code>initStates</code>.
</p>
</li>
<li><p> Combine information across traits (<em>Across Traits</em>)<br />
For <code>ptycho.all</code>, argument <code>across</code> is &ldquo;traits&rdquo; and
<code>doGrpIndicator</code> is <code>TRUE</code>.<br />
For <code>ptycho</code>, argument <code>y</code> has <code class="reqn">p &gt; 1</code> columns, <code>groups</code>
is <code>NULL</code>, and <code>indic.grp</code> is a logical vector of length <code class="reqn">p</code>
in each entry of <code>initStates</code>.
</p>
</li>
<li><p> Combine information across variants (<em>Across Sites</em>)<br />
For <code>ptycho.all</code>, argument <code>across</code> is &ldquo;sites&rdquo; and
<code>doGrpIndicator</code> is <code>TRUE</code>.<br />
For <code>ptycho</code>, argument <code>y</code> has one column, <code>groups</code> specifies
how to combine information, and <code>indic.grp</code> in each entry of
<code>initStates</code> is a logical vector of the same length as
<code>groups$group2var</code>.
</p>
</li>
<li><p> Combine information across traits <em>incorrectly</em>
(<em>Unadjusted</em>)<br />
For <code>ptycho.all</code>, argument <code>across</code> is &ldquo;traits&rdquo; and
<code>doGrpIndicator</code> is <code>FALSE</code>.<br />
For <code>ptycho</code>, argument <code>y</code> has <code class="reqn">p &gt; 1</code> columns, <code>groups</code>
is <code>NULL</code>, and <code>indic.grp</code> is <code>NULL</code> in each entry of
<code>initStates</code>.<br />
This prior does not properly correct for multiple hypothesis testing and is
only included because it is needed to reproduce results in Stell and Sabatti
(2015).
</p>
</li></ul>

<p>Combining information across both phenotypes and variants is planned for a
future release.  These functions perform some checks for compatibility of
<code>X</code>, <code>y</code>, <code>groups</code>, and <code>initStates</code>; but invalid input
could lead to unpredictable behavior.  Singular <code class="reqn">X</code> can result in an error;
even strongly correlated covariates can cause difficulties as described by Stell
and Sabatti (2015).
</p>
<p>The simplest way to run the simulations in Stell and Sabatti (2015) is, for
example,
</p>
<pre>
  data &lt;- createPubData("pleiotropy")
  ptycho.all(data=data, across="traits", doGrpIndicator=TRUE,
             dir.out="/path/to/output/dir/",
             only.means=50000*(1:10), nburn=10000)
  ptycho.all(data=data, across="sites", doGrpIndicator=TRUE,
             dir.out="/path/to/another/dir/",
             groups=createGroupsSim(G=10, ncol(data$X)),
             only.means=50000*(1:10), nburn=10000)
</pre>
<p>With these calls, the replicates run sequentially and so do the chains of the
MCMC sampler; the results will be reproducible because the random seed is set
for each replicate.
</p>
<p>Parallelization is implemented via the <span class="pkg">foreach</span> package.  The user must not
only have it installed but also an appropriate parallel backend, which must be
registered.  To run chains in parallel using the <span class="pkg">doMC</span>, for example,
</p>
<pre>
  data(ptychoIn)
  G &lt;- 2; p &lt;- ncol(ptychoIn$X)
  groups &lt;- createGroupsSim(G, p)
  state &lt;- list(list(indic.grp=rep(FALSE,G),
                     indic.var=matrix(FALSE,nrow=p,ncol=1), tau=1),
                list(indic.grp=rep(TRUE,G),
                     indic.var=matrix(TRUE,nrow=p,ncol=1), tau=1))
  require(doMC)
  registerDoMC(length(state))
  ptychoOut &lt;- ptycho(X=ptychoIn$X, y=ptychoIn$replicates[[1]]$y,
                      groups=groups, initStates=state,
                      only.means=100*seq_len(5), parallel.chains=TRUE)
</pre>
<p>The results would not be reproducible, however, even if one set the random seed
before calling <code>ptycho</code>.  For reproducible results, pass the random seed
in the call to <code>ptycho</code>, which requires that the <span class="pkg">doRNG</span> package is
also installed.  Running the chains in parallel when calling <code>ptycho.all</code>
also requires the option <code>parallel.chains=TRUE</code>, which uses <span class="pkg">doRNG</span>
unless <code>doSetSeed=FALSE</code>.  By default, one of the chains starts with all
variants in the model, so that chain takes much longer to run than do the other
chains.  Consequently, when running multiple replicates via <code>ptycho.all</code>,
much greater time savings can be achieved by running the replicates in parallel
with, for example,
</p>
<pre>
  data &lt;- createPubData("pleiotropy")
  require(doMC)
  registerDoMC(8)
  ptycho.all(data=data, across="traits", doGrpIndicator=TRUE,
             dir.out="/path/to/output/dir/",
             only.means=50000*(1:10), nburn=10000)
</pre>
<p>In this case, the default behavior of reproducible results does <em>not</em>
require <span class="pkg">doRNG</span> because the seed is set after each parallel worker is
created.
</p>
<p>We conclude this description with a discussion of the running time of the MCMC
sampler.  Our actual data has 5335 subjects, 764 variants and three traits.  An
<code>mcmc.list</code> containing 50,000 samples for each of four chains can take
about 5~GB.  Running chains in parallel, it takes less than an hour (on a Linux
computer with 2.6 GHz processors) to perform 510,000 samples per chain.  The run
time depends primarily on the number of entries that are <code>TRUE</code> in the
sampled <code>indic.var</code> matrices; increasing this will increase run times.  A
chain that initially has all entries of <code>indic.var</code> set to <code>TRUE</code> will
take longer than one where the model is initially empty.  Priors that inflate
the posterior expectation of <code>indic.var[j,k]</code> (such as combining
information across responses without using <code>indic.grp</code>) will also take
longer.
</p>


<h3>Value</h3>

<p>The results of <code>ptycho.all</code> are written to files by <code><a href="base.html#topic+save">save</a></code>.
For priors that use only one response, the output for replicate <code class="reqn">r</code> and
column <code class="reqn">c</code> will be written to &lsquo;<span class="file">rpl&lt;r&gt;col&lt;c&gt;.Rdata</span>&rsquo; in the directory
specified by <code>dir.out</code>.  For priors that use multiple responses,
<code>ptycho</code> is called only once for each replicate, and the file name will
be &lsquo;<span class="file">rpl&lt;r&gt;col1.Rdata</span>&rsquo;.  The object in each such file has the name
<code>smpl</code> and is the value of a call to <code>ptycho</code>.  The format of these
objects depends upon the argument <code>only.means</code>.  In all cases, however,
it has attribute <code>params</code> set to a list containing most of the arguments
in the call to <code>ptycho</code>.
</p>
<p>If <code>only.means</code> is <code>FALSE</code>, then <code>ptycho</code> returns an
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> whose length is the same as the length of
<code>initStates</code>.  Each entry in this list is an <code><a href="coda.html#topic+mcmc">mcmc</a></code> object
with <code>nSavePerChain</code> rows and a column for each entry of <code>indic.var</code>
and <code>indic.grp</code> plus a column for <code>tau</code>.
</p>
<p>Otherwise, <code>ptycho</code> returns an object of class <code>ptycho</code>, which is
actually a matrix.  The matrix has a column for each sampled indicator
variable, for <code>tau</code> and its square (so that its variance can be
computed), and for the chain and iteration numbers.  If <code>only.means</code> is
<code>TRUE</code>, then each row contains the means of the samples in one chain and
there will be <code>length(initStates) * nSavePerChain</code> rows.
If
<code>only.means</code> is a vector, then there will be
<code>length(initStates) * length(only.means)</code> rows.
</p>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Stell, L. and Sabatti, C. (2015) Genetic variant selection: learning across
traits and sites, arXiv:1504.00946.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createData">createData</a></code> for simulating input data.
</p>
<p><code><a href="#topic+checkConvergence">checkConvergence</a></code> and <a href="#topic+PosteriorStatistics">PosteriorStatistics</a> for analyzing
output of <code>ptycho</code>.
</p>
<p><a href="#topic+Data">Data</a> describes <code>tinysim</code> in example below as well as an object
created with <code>ptycho</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tinysim)
# Use replicate 4.
X &lt;- tinysim$X; p &lt;- ncol(X); nr &lt;- 4
# COMBINE INFORMATION ACROSS RESPONSES
Y &lt;- tinysim$replicates[[nr]]$y; q &lt;- ncol(Y)
# Run 2 chains.
state &lt;- list(list(indic.grp=rep(FALSE,p),
                   indic.var=matrix(FALSE,nrow=p,ncol=q), tau=1),
              list(indic.grp=rep(TRUE,p),
                   indic.var=matrix(TRUE,nrow=p,ncol=q), tau=1))
# In each chain, discard first 10 burn-in samples, then generate
# 100 samples and save running means after every 20 samples.
smpl.ph &lt;- ptycho(X=X, y=Y, initStates=state, only.means=20*(1:5),
                  nburn=10)
# COMBINE INFORMATION ACROSS VARIANTS
# Use two groups of variants.
G &lt;- 2; groups &lt;- createGroupsSim(G, p)
# Run 2 chains.
state &lt;- list(list(indic.grp=rep(FALSE,G),
                   indic.var=matrix(FALSE,nrow=p,ncol=1), tau=1),
              list(indic.grp=rep(TRUE,G),
                   indic.var=matrix(TRUE,nrow=p,ncol=1), tau=1))
# Use response 3.
y &lt;- tinysim$replicates[[nr]]$y[,3,drop=FALSE]
smpl.var &lt;- ptycho(X=X, y=y, groups=groups, initStates=state,
                   only.means=c(20*(1:5)), nburn=10, nthin=1)
</code></pre>

<hr>
<h2 id='WhichCols'>Identify Columns Containing Indicator Variables</h2><span id='topic+WhichCols'></span><span id='topic+indicVarCols'></span><span id='topic+indicGrpCols'></span>

<h3>Description</h3>

<p>Determine which columns contain <code>indic.var</code> or <code>indic.grp</code> in an
object returned by <code><a href="#topic+ptycho">ptycho</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indicVarCols(obj)
indicGrpCols(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WhichCols_+3A_obj">obj</code></td>
<td>
<p>Object output by <code><a href="#topic+ptycho">ptycho</a></code> or any numeric object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input object is a numeric vector, returns the indices of its entries
that have names starting with &ldquo;indic.var&rdquo; or &ldquo;indic.grp&rdquo;,
respectively.
</p>
<p>Otherwise, it returns the indices of <code>colnames(obj)</code> that start with
&ldquo;indic.var&rdquo; or &ldquo;indic.grp&rdquo;, respectively.
</p>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br />
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptycho">ptycho</a></code>; also <code><a href="#topic+ptychoOut">ptychoOut</a></code> and
<a href="#topic+PosteriorStatistics">PosteriorStatistics</a> for example below
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ptychoOut)
colnames(ptychoOut)[indicVarCols(ptychoOut)]
# Can also apply these functions to output of meanIndicators ...
mi &lt;- meanIndicators(ptychoOut)
mi[indicGrpCols(mi)]
# ... instead of using meanGrpIndicators or meanVarIndicators
meanGrpIndicators(ptychoOut)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
