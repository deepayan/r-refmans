<!DOCTYPE html><html lang="en-US"><head><title>Help for package ICAOD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICAOD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayes'><p>Bayesian D-Optimal Designs</p></a></li>
<li><a href='#bayes.update'><p>Updating an Object of Class <code>minimax</code></p></a></li>
<li><a href='#bayescomp'><p>Bayesian Compound DP-Optimal Designs</p></a></li>
<li><a href='#beff'><p>Calculates Relative Efficiency for Bayesian Optimal Designs</p></a></li>
<li><a href='#crt.bayes.control'><p>Returns Control Parameters for Approximating Bayesian Criteria</p></a></li>
<li><a href='#crt.minimax.control'><p>Returns Control Parameters for Optimizing Minimax Criteria Over The Parameter Space</p></a></li>
<li><a href='#FIM_2par_exp_censor1'><p>Fisher Information Matrix for a 2-Parameter Cox Proportional-Hazards Model for Type One Censored Data</p></a></li>
<li><a href='#FIM_2par_exp_censor2'><p>Fisher Information Matrix for a 2-Parameter Cox Proportional-Hazards Model for Random Censored Data</p></a></li>
<li><a href='#FIM_3par_exp_censor1'><p>Fisher Information Matrix for a 3-Parameter Cox Proportional-Hazards Model for Type One Censored Data</p></a></li>
<li><a href='#FIM_3par_exp_censor2'><p>Fisher Information Matrix for a 3-Parameter Cox Proportional-Hazards Model for Random Censored Data</p></a></li>
<li><a href='#FIM_exp_2par'><p>Fisher Information Matrix for the 2-Parameter Exponential Model</p></a></li>
<li><a href='#FIM_kinetics_alcohol'><p>Fisher Information Matrix for the Alcohol-Kinetics Model</p></a></li>
<li><a href='#FIM_logistic'><p>Fisher Information Matrix for the 2-Parameter Logistic (2PL) Model</p></a></li>
<li><a href='#FIM_logistic_2pred'><p>Fisher Information Matrix for the Logistic Model with Two Predictors</p></a></li>
<li><a href='#FIM_logistic_4par'><p>Fisher Information Matrix for the 4-Parameter Logistic Model</p></a></li>
<li><a href='#FIM_loglin'><p>Fisher Information Matrix for the Mixed Inhibition Model</p></a></li>
<li><a href='#FIM_mixed_inhibition'><p>Fisher Information Matrix for the Mixed Inhibition Model.</p></a></li>
<li><a href='#FIM_power_logistic'><p>Fisher Information Matrix for the Power Logistic Model</p></a></li>
<li><a href='#FIM_sig_emax'><p>Fisher Information Matrix for the Sigmoid Emax Model</p></a></li>
<li><a href='#ICA.control'><p>Returns ICA Control Optimization Parameters</p></a></li>
<li><a href='#ICAOD'><p>ICAOD: Finding Optimal Designs for Nonlinear Models Using Imperialist Competitive Algorithm</p></a></li>
<li><a href='#leff'><p>Calculates Relative Efficiency for Locally Optimal Designs</p></a></li>
<li><a href='#locally'><p>Locally D-Optimal Designs</p></a></li>
<li><a href='#locallycomp'><p>Locally DP-Optimal Designs</p></a></li>
<li><a href='#meff'><p>Calculates Relative Efficiency for Minimax Optimal Designs</p></a></li>
<li><a href='#minimax'><p>Minimax and Standardized Maximin D-Optimal Designs</p></a></li>
<li><a href='#multiple'><p>Locally Multiple Objective Optimal Designs for the 4-Parameter Hill Model</p></a></li>
<li><a href='#normal'><p>Assumes A Multivariate Normal Prior Distribution for The Model Parameters</p></a></li>
<li><a href='#plot.minimax'><p>Plotting <code>minimax</code> Objects</p></a></li>
<li><a href='#print.minimax'><p>Printing <code>minimax</code> Objects</p></a></li>
<li><a href='#print.sensminimax'><p>Printing <code>sensminimax</code> Objects</p></a></li>
<li><a href='#robust'><p>Robust D-Optimal Designs</p></a></li>
<li><a href='#sens.bayes.control'><p>Returns Control Parameters for Approximating The Integrals In The Bayesian Sensitivity Functions</p></a></li>
<li><a href='#sens.control'><p>Returns Control Parameters To Find Maximum of The Sensitivity (Derivative) Function Over The Design Space</p></a></li>
<li><a href='#sens.minimax.control'><p>Returns Control Parameters for Verifying General Equivalence Theorem For Minimax Optimal Designs</p></a></li>
<li><a href='#sensbayes'><p>Verifying Optimality of Bayesian D-optimal Designs</p></a></li>
<li><a href='#sensbayescomp'><p>Verifying Optimality of Bayesian Compound DP-optimal Designs</p></a></li>
<li><a href='#senslocally'><p>Verifying Optimality of The Locally D-optimal Designs</p></a></li>
<li><a href='#senslocallycomp'><p>Verifying Optimality of The Locally DP-optimal Designs</p></a></li>
<li><a href='#sensminimax'><p>Verifying Optimality of The Minimax and Standardized maximin D-optimal Designs</p></a></li>
<li><a href='#sensmultiple'><p>Verifying Optimality of The Multiple Objective Designs for The 4-Parameter Hill Model</p></a></li>
<li><a href='#sensrobust'><p>Verifying Optimality of The Robust Designs</p></a></li>
<li><a href='#skewnormal'><p>Assumes A Multivariate Skewed Normal Prior Distribution for The Model Parameters</p></a></li>
<li><a href='#student'><p>Multivariate Student's t Prior Distribution for Model Parameters</p></a></li>
<li><a href='#uniform'><p>Assume A Multivariate Uniform Prior Distribution for The Model Parameters</p></a></li>
<li><a href='#update.minimax'><p>Updating an Object of Class <code>minimax</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Optimal Designs for Nonlinear Statistical Models by Imperialist
Competitive Algorithm (ICA)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Finds optimal designs for nonlinear models using a metaheuristic algorithm called Imperialist Competitive Algorithm (ICA). See, for details, Masoudi et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2016.06.014">doi:10.1016/j.csda.2016.06.014</a>&gt; and Masoudi et al. (2019) &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1601097">doi:10.1080/10618600.2019.1601097</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen,</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, nloptr, stats, utils, graphics, grDevices, cubature, sn,
mnormt, methods, mvQuad</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, lattice, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Ehsan Masoudi [aut, cre],
  Heinz Holling [aut],
  Weng Kee Wong [aut],
  Seongho Kim [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ehsan Masoudi &lt;esn_mud@yahoo.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-11 17:55:50 UTC; ehsan</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-11 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayes'>Bayesian D-Optimal Designs</h2><span id='topic+bayes'></span>

<h3>Description</h3>

<p>Finds (pseudo) Bayesian D-optimal designs for linear and nonlinear models.
It should be used when the user assumes a (truncated) prior distribution for the unknown model parameters.
If you have a discrete prior, please use the function <code><a href="#topic+robust">robust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  prior,
  lx,
  ux,
  iter,
  k,
  fimfunc = NULL,
  ICA.control = list(),
  sens.control = list(),
  crt.bayes.control = list(),
  sens.bayes.control = list(),
  initial = NULL,
  npar = NULL,
  plot_3d = c("lattice", "rgl"),
  x = NULL,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="bayes_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="bayes_+3A_prior">prior</code></td>
<td>
<p>An object of class <code>cprior</code>. User can also use one of the functions
<code><a href="#topic+uniform">uniform</a></code>, <code><a href="#topic+normal">normal</a></code>,
<code><a href="#topic+skewnormal">skewnormal</a></code> or <code><a href="#topic+student">student</a></code>  to create the  prior. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="bayes_+3A_k">k</code></td>
<td>
<p>Number of design points. Must be at least equal to the number of model parameters to avoid singularity of the FIM.</p>
</td></tr>
<tr><td><code id="bayes_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_ica.control">ICA.control</code></td>
<td>
<p>ICA control parameters. For details, see <code><a href="#topic+ICA.control">ICA.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_crt.bayes.control">crt.bayes.control</code></td>
<td>
<p>A list. Control parameters to approximate the integral in  the Bayesian criterion at a given design over the parameter space.
For details, see <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_sens.bayes.control">sens.bayes.control</code></td>
<td>
<p>A list. Control parameters to verify the general equivalence theorem. For details, see <code><a href="#topic+sens.bayes.control">sens.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_initial">initial</code></td>
<td>
<p>A matrix of the  initial design points and weights that will be inserted into the initial solutions (countries) of the algorithm.
Every row is a design, i.e.  a concatenation of <code>x</code> and <code>w</code>. Will be coerced to a <code>matrix</code> if necessary.  See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not specified correctly, the sensitivity (derivative) plot may be shifted below the y-axis.
When <code>NULL</code> (default), it will be set to <code>length(parvars)</code> or
<code>prior$npar</code> when <code>missing(formula)</code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to <code>"lattice"</code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_x">x</code></td>
<td>
<p>A vector of candidate design (support) points.
When is not set to <code>NULL</code> (default),
the algorithm only finds the optimal weights for the candidate points in  <code>x</code>.
Should be set when the user has a finite number of candidate design points  and the purpose
is to find the optimal weight for each of them (when zero, they will be excluded from the design).
For design points with more than one dimension, see 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\Xi</code> be the space of all  approximate designs with
<code class="reqn">k</code> design points (support points) at <code class="reqn">x_1, x_2, ...,  x_k</code> from  design space <code class="reqn">\chi</code> with
corresponding weights  <code class="reqn">w_1, . . . ,w_k</code>.
Let <code class="reqn">M(\xi, \theta)</code> be the Fisher information
matrix (FIM) of a <code class="reqn">k-</code>point design <code class="reqn">\xi</code>
and  <code class="reqn">\pi(\theta)</code> is a user-given  prior distribution for the vector of unknown parameters <code class="reqn">\theta</code>.
A  Bayesian D-optimal design <code class="reqn">\xi^*</code> minimizes over <code class="reqn">\Xi</code>
</p>
<p style="text-align: center;"><code class="reqn">\int_{\theta \in \Theta} -\log|M(\xi, \theta)| \pi(\theta) d\theta.</code>
</p>

<p>An object of class <code>cprior</code>  is a  list with the following components:
</p>

<ul>
<li><p><code>fn</code>: Prior distribution as an R <code>function</code> with argument <code>param</code> that is the vector of the unknown parameters. See below.
</p>
</li>
<li><p><code>npar</code>: Number of unknown parameters and is equal to the length of <code>param</code>.
</p>
</li>
<li><p><code>lower</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li>
<li><p><code>upper</code>: Argument <code>upper</code>. It has the same length as <code>param</code>.
</p>
</li></ul>

<p>A <code>cprior</code> object  will be passed to the argument <code>prior</code> of the function <code><a href="#topic+bayes">bayes</a></code>.
The argument <code>param</code> in <code>fn</code> has the same order as the argument <code>parvars</code> when the model is specified by a <code>formula</code>.
Otherwise, it is the same as the argument <code>param</code> in the function <code>fimfunc</code>.<br />
The user can use the implemented  priors that are <code><a href="#topic+uniform">uniform</a></code>, <code><a href="#topic+normal">normal</a></code>,
<code><a href="#topic+skewnormal">skewnormal</a></code> and <code><a href="#topic+student">student</a></code> to create a <code>cprior</code> object.
</p>
<p>To verify the equivalence theorem of the output design,
use <code><a href="base.html#topic+plot">plot</a></code> function or change the value of the <code>checkfreq</code> in the argument <code><a href="#topic+ICA.control">ICA.control</a></code>.
</p>
<p>To increase the speed of the algorithm, change the value of the tuning parameters <code>tol</code> and <code>maxEval</code> via
the argument  <code>crt.bayes.control</code> when <code>crt.bayes.control$method = "cubature"</code>.
Similarly, this applies  when <code>crt.bayes.control$method = "quadrature"</code>.
In general, if the CPU time matters, the user should find an appropriate speed-accuracy trade-off  for her/his own problem.
See 'Examples' for more details.
</p>
<p>If some of the parameters are known and fixed, they should be set
to their values via the argument <code>paravars</code> when the model is given by <code>formula</code>. In this case,
the user must provide the number of parameters via the argument <code>npar</code> for verifying the general equivalence theorem.
See 'Examples', Section 'Weibull',  'Richards' and 'Exponential' model.
</p>
<p><code>crtfunc</code> is a function that is used
to specify a new criterion.
Its arguments are:
</p>

<ul>
<li><p> design points <code>x</code> (as a <code>vector</code>).
</p>
</li>
<li><p> design weights <code>w</code> (as a <code>vector</code>).
</p>
</li>
<li><p> model parameters as follows.
</p>

<ul>
<li><p> If <code>formula</code> is specified:
they should be the same parameter specified by <code>parvars</code>.
Note that <code>crtfunc</code> must be vectorized with respect to the parameters.
The parameters enter the body of <code>crtfunc</code> as a <code>vector</code> with dynamic length.
</p>
</li>
<li><p> If FIM is specified via the argument <code>fimfunc</code>:
<code>param</code> that is a matrix where its row is a
vector of parameters values.
</p>
</li></ul>

</li>
<li> <p><code>fimfunc</code> is a <code>function</code> that takes the other arguments of <code>crtfunc</code>
and returns the computed Fisher information matrices for each parameter vector.
The output is a list of matrices.
</p>
</li></ul>

<p>The <code>crtfunc</code> function must return a vector of  criterion values associated with the vector of parameter values.
The <code>sensfunc</code> is the optional sensitivity function for the criterion
<code>crtfunc</code>. It has one more argument than  <code>crtfunc</code>,
which is  <code>xi_x</code>. It denotes the design point of the degenerate design
and  must be a vector with the same length as the number of  predictors.
For more details, see 'Examples'.
</p>


<h3>Value</h3>

<p>an object of class <code>minimax</code> that is a list including three sub-lists:
</p>

<dl>
<dt><code>arg</code></dt><dd><p>A list of design and algorithm parameters.</p>
</dd>
<dt><code>evol</code></dt><dd><p>A list of length equal to the number of iterations that stores the information about the best design (design with the minimum criterion value) of each iteration as follows:
<code>evol[[iter]]</code> contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>iter</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> Iteration number.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>x</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design points. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>w</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design weights. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>min_cost</code>               </td><td style="text-align: left;">      </td><td style="text-align: left;"> Value of the criterion for the best imperialist (design).  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>mean_cost</code>              </td><td style="text-align: left;">      </td><td style="text-align: left;"> Mean of the criterion values of all the imperialists. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sens</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> An object of class <code>'sensminimax'</code>. See below.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>empires</code></dt><dd><p>A list of all the empires of the last iteration.</p>
</dd>
<dt><code>alg</code></dt><dd><p>A list with following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>nfeval</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of function evaluations. It does not count the function evaluations from checking the general equivalence theorem. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nlocal</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful local searches. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nrevol</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful revolutions. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nimprove</code>         </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful movements toward the imperialists in the assimilation step. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>convergence</code>      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Stopped by <code>'maxiter'</code> or <code>'equivalence'</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>method</code></dt><dd><p>A type of optimal designs used.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design points and weights at the final iteration.</p>
</dd>
<dt><code>out</code></dt><dd><p>A data frame of design points, weights, value of the criterion for the best imperialist (min_cost), and Mean of the criterion values of all the imperialistsat each iteration (mean_cost).</p>
</dd>
</dl>

<p>The list <code>sens</code>  contains information about the design verification by the general equivalence theorem.
See <code>sensbayes</code> for more Details.
It is only given every <code>ICA.control$checkfreq</code> iterations
and also the last iteration if   <code>ICA.control$checkfreq &gt;= 0</code>. Otherwise, <code>NULL</code>.
</p>


<h3>References</h3>

<p>Atashpaz-Gargari, E, &amp; Lucas, C (2007). Imperialist competitive algorithm: an algorithm for optimization inspired by imperialistic competition. In 2007 IEEE congress on evolutionary computation (pp. 4661-4667). IEEE.<br />
Masoudi E, Holling H, Duarte BP, Wong Wk (2019). Metaheuristic Adaptive Cubature Based Algorithm to Find Bayesian Optimal Designs for Nonlinear Models. Journal of Computational and Graphical Statistics. &lt;doi:10.1080/10618600.2019.1601097&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensbayes">sensbayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################
# Two parameter logistic model: uniform prior
#############################################
# set the unfirom prior
uni &lt;- uniform(lower =  c(-3, .1), upper = c(3, 2))
# set the logistic model with formula
res1 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))),
              predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3,
              k =  5, iter = 1, prior = uni,
              ICA.control = list(rseed = 1366))

## Not run: 
  res1 &lt;- update(res1, 500)
  plot(res1)

## End(Not run)
# You can also use your  Fisher information matrix (FIM) if you think it is faster!
## Not run: 
  bayes(fimfunc = FIM_logistic, lx = -3, ux = 3, k =  5, iter = 500,
        prior = uni, ICA.control = list(rseed = 1366))

## End(Not run)

# with fixed x
## Not run: 
  res1.1 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))),
                  predvars = "x", parvars = c("a", "b"),
                  family = binomial(), lx = -3, ux = 3,
                  k =  5, iter = 100, prior = uni,
                  x = c( -3, -1.5, 0,  1.5, 3),
                  ICA.control = list(rseed = 1366))
  plot(res1.1)
  # not optimal

## End(Not run)

# with quadrature formula
## Not run: 
  res1.2 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))),
                  predvars = "x", parvars = c("a", "b"),
                  family = binomial(), lx = -3, ux = 3,
                  k =  5, iter = 1, prior = uni,
                  crt.bayes.control = list(method = "quadrature"),
                  ICA.control = list(rseed = 1366))
  res1.2 &lt;- update(res1.2, 500)
  plot(res1.2) # not optimal
  # compare it with res1 that was found by automatic integration
  plot(res1)

  # we increase the number of quadrature nodes
  res1.3 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))),
                  predvars = "x", parvars = c("a", "b"),
                  family = binomial(), lx = -3, ux = 3,
                  k =  5, iter = 1, prior = uni,
                  crt.bayes.control = list(method = "quadrature",
                                           quadrature = list(level = 9)),
                  ICA.control = list(rseed = 1366))
  res1.3 &lt;- update(res1.3, 500)
  plot(res1.3)
  # by automatic integration (method = "cubature"),
  #  we did not need to worry about the number of nodes.

## End(Not run)
###############################################
# Two parameter logistic model: normal prior #1
###############################################
# defining the normal prior #1
norm1 &lt;- normal(mu =  c(0, 1),
                sigma = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                lower =  c(-3, .1), upper = c(3, 2))
## Not run: 
  # initializing
  res2 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
                family = binomial(), lx = -3, ux = 3, k =  4, iter = 1, prior = norm1,
                ICA.control = list(rseed = 1366))
  res2 &lt;- update(res2, 500)
  plot(res2)

## End(Not run)

###############################################
# Two parameter logistic model: normal prior #2
###############################################
# defining the normal prior #1
norm2 &lt;- normal(mu =  c(0, 1),
                sigma = matrix(c(1, 0, 0, .5), nrow = 2),
                lower =  c(-3, .1), upper = c(3, 2))
## Not run: 
  # initializing
  res3 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
                family = binomial(), lx = -3, ux = 3, k =  4, iter = 1, prior = norm2,
                ICA.control = list(rseed = 1366))

  res3 &lt;- update(res3, 700)
  plot(res3,
       sens.bayes.control = list(cubature = list(maxEval = 3000, tol = 1e-4)),
       sens.control = list(optslist = list(maxeval = 3000)))

## End(Not run)


######################################################
# Two parameter logistic model: skewed normal prior #1
######################################################
skew1 &lt;- skewnormal(xi = c(0, 1),
                    Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                    alpha = c(1, 0), lower =  c(-3, .1), upper = c(3, 2))
## Not run: 
  res4 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
                family = binomial(), lx = -3, ux = 3, k =  4, iter = 700, prior = skew1,
                ICA.control = list(rseed = 1366, ncount = 60))
  plot(res4,
       sens.bayes.control = list(cubature = list(maxEval = 3000, tol = 1e-4)),
       sens.control = list(optslist = list(maxeval = 3000)))

## End(Not run)


######################################################
# Two parameter logistic model: skewed normal prior #2
######################################################
skew2 &lt;- skewnormal(xi = c(0, 1),
                    Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                    alpha = c(-1, 0), lower =  c(-3, .1), upper = c(3, 2))
## Not run: 
  res5 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
                family = binomial(), lx = -3, ux = 3, k =  4, iter = 700, prior = skew2,
                ICA.control = list(rseed = 1366, ncount = 60))
  plot(res5,
       sens.bayes.control = list(cubature = list(maxEval = 3000, tol = 1e-4)),
       sens.control = list(optslist = list(maxeval = 3000)))

## End(Not run)

###############################################
# Two parameter logistic model: t student prior
###############################################
# set the prior
stud &lt;- student(mean =  c(0, 1), S   = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                df = 3, lower =  c(-3, .1), upper = c(3, 2))
## Not run: 
  res6 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
                family = binomial(), lx = -3, ux = 3, k =  5, iter = 500, prior = stud,
                ICA.control = list(ncount = 50, rseed = 1366))
  plot(res6)

## End(Not run)
# not bad, but to find a very accurate designs we increase
# the ncount to 200 and repeat the optimization
## Not run: 
  res6 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a))),
                predvars = "x", parvars = c("a", "b"),
                family = binomial(), lx = -3, ux = 3, k =  5, iter = 1000, prior = stud,
                ICA.control = list(ncount = 200,  rseed = 1366))
  plot(res6)

## End(Not run)


##############################################
# 4-parameter sigmoid Emax model: unform prior
##############################################
lb &lt;- c(4, 11, 100, 5)
ub &lt;- c(8, 15, 130, 9)
## Not run: 
  res7 &lt;- bayes(formula = ~ theta1 + (theta2 - theta1)*(x^theta4)/(x^theta4 + theta3^theta4),
                predvars = c("x"), parvars = c("theta1", "theta2", "theta3", "theta4"),
                lx = .001, ux = 500, k = 5, iter = 200, prior = uniform(lb, ub),
                ICA.control = list(rseed = 1366, ncount = 60))
  plot(res7,
       sens.bayes.control = list(cubature = list(maxEval = 500, tol = 1e-3)),
       sens.control = list(optslist = list(maxeval = 500)))

## End(Not run)

#######################################################################
# 2-parameter Cox Proportional-Hazards Model for type one cenosred data
#######################################################################
# The Fisher information matrix is available here with name FIM_2par_exp_censor1
# However, we should reparameterize the function to match the standard of the argument 'fimfunc'
myfim &lt;- function(x, w, param)
  FIM_2par_exp_censor1(x = x, w = w, param = param, tcensor = 30)
## Not run: 
  res8 &lt;- bayes(fimfunc = myfim, lx = 0, ux = 1, k = 4,
                iter = 1, prior = uniform(c(-11, -11), c(11, 11)),
                ICA.control = list(rseed = 1366))

  res8 &lt;- update(res8, 200)
  plot(res8,
       sens.bayes.control = list(cubature = list(maxEval = 500, tol = 1e-3)),
       sens.control = list(optslist = list(maxeval = 500)))

## End(Not run)


#######################################################################
# 2-parameter Cox Proportional-Hazards Model for random cenosred data
#######################################################################
# The Fisher information matrix is available here with name FIM_2par_exp_censor2
# However, we should reparameterize the function to match the standard of the argument 'fimfunc'
myfim &lt;- function(x, w, param)
  FIM_2par_exp_censor2(x = x, w = w, param = param, tcensor = 30)
## Not run: 
  res9 &lt;- bayes(fimfunc = myfim, lx = 0, ux = 1, k = 2,
                iter = 200, prior = uniform(c(-11, -11), c(11, 11)),
                ICA.control = list(rseed = 1366))
  plot(res9,
       sens.bayes.control = list(cubature = list(maxEval = 100, tol = 1e-3)),
       sens.control = list(optslist = list(maxeval = 100)))

## End(Not run)

#################################
# Weibull model: Uniform prior
################################
# see Dette, H., &amp; Pepelyshev, A. (2008).
# Efficient experimental designs for sigmoidal growth models.
# Journal of statistical planning and inference, 138(1), 2-17.

## See how we fixed a some parameters in Bayesian designs
## Not run: 
  res10 &lt;- bayes(formula = ~a - b * exp(-lambda * t ^h),
                 predvars = c("t"),
                 parvars = c("a=1", "b=1", "lambda", "h=1"),
                 lx = .00001, ux = 20,
                 prior = uniform(.5, 2.5), k = 5, iter = 400,
                 ICA.control = list(rseed = 1366))
  plot(res10)

## End(Not run)

#################################
# Weibull model: Normal prior
################################
norm3 &lt;- normal(mu = 1, sigma = .1, lower = .5, upper = 2.5)
res11 &lt;- bayes(formula = ~a - b * exp(-lambda * t ^h),
               predvars = c("t"),
               parvars = c("a=1", "b=1", "lambda", "h=1"),
               lx = .00001, ux = 20, prior = norm3, k = 4, iter = 1,
               ICA.control = list(rseed = 1366))

## Not run: 
  res11 &lt;- update(res11, 400)
  plot(res11)

## End(Not run)

#################################
# Richards model: Normal prior
#################################
norm4 &lt;- normal(mu = c(1, 1), sigma = matrix(c(.2, 0.1, 0.1, .4), 2, 2),
                lower = c(.4, .4), upper = c(1.6, 1.6))
## Not run: 
  res12 &lt;- bayes(formula = ~a/(1 + b * exp(-lambda*t))^h,
                 predvars = c("t"),
                 parvars = c("a=1", "b", "lambda", "h=1"),
                 lx = .00001, ux = 10,
                 prior = norm4,
                 k = 5, iter = 400,
                 ICA.control = list(rseed = 1366))
  plot(res12,
       sens.bayes.control = list(cubature = list(maxEval = 1000, tol = 1e-3)),
       sens.control = list(optslist = list(maxeval = 1000)))
  ## or we can use the quadrature formula to plot the derivative function
  plot(res12,
       sens.bayes.control = list(method = "quadrature"),
       sens.control = list(optslist = list(maxeval = 1000)))


## End(Not run)

#################################
# Exponential model: Uniform prior
#################################
## Not run: 
res13 &lt;- bayes(formula = ~a + exp(-b*x), predvars = "x",
               parvars = c("a = 1", "b"),
               lx = 0.0001, ux = 1,
               prior = uniform(lower = 1, upper = 20),
               iter = 300, k = 3,
               ICA.control= list(rseed = 100))
  plot(res13)

## End(Not run)

#################################
# Power logistic model
#################################
# See, Duarte, B. P., &amp; Wong, W. K. (2014).
# A Semidefinite Programming based approach for finding
# Bayesian optimal designs for nonlinear models
uni1 &lt;- uniform(lower = c(-.3, 6, .5), upper = c(.3, 8, 1))
## Not run: 
  res14 &lt;- bayes(formula = ~1/(1 + exp(-b *(x - a)))^s, predvars = "x",
                 parvars = c("a", "b", "s"),
                 lx = -1, ux = 1, prior = uni1, k = 5, iter = 1)
  res14 &lt;- update(res14, 300)
  plot(res14)

## End(Not run)

############################################################################
# A two-variable generalized linear model with a gamma distributed response
############################################################################
lb &lt;- c(.5, 0, 0, 0, 0, 0)
ub &lt;- c(2, 1, 1, 1, 1, 1)
myformula1 &lt;- ~beta0+beta1*x1+beta2*x2+beta3*x1^2+beta4*x2^2+beta5*x1*x2
## Not run: 
  res15 &lt;- bayes(formula = myformula1,
                 predvars = c("x1", "x2"), parvars = paste("beta", 0:5, sep = ""),
                 family = Gamma(),
                 lx = rep(0, 2), ux = rep(1, 2),
                 prior = uniform(lower = lb, upper = ub),
                 k = 7,iter = 1, ICA.control = list(rseed = 1366))
  res14 &lt;- update(res14, 500)
  plot(res14,
       sens.bayes.control = list(cubature = list(maxEval = 5000, tol = 1e-4)),
       sens.control = list(optslist = list(maxeval = 3000)))

## End(Not run)

#################################
# Three parameter logistic model
#################################
## Not run: 
sigma1 &lt;- matrix(-0.1, nrow = 3, ncol = 3)
diag(sigma1) &lt;- c(.5, .4, .1)
norm5 &lt;- normal(mu =  c(0, 1, .2), sigma = sigma1,
                lower =  c(-3, .1, 0), upper = c(3, 2, .7))
  res16 &lt;- bayes(formula = ~ c + (1-c)/(1 + exp(-b *(x - a))), predvars = "x",
                 parvars = c("a", "b", "c"),
                 family = binomial(), lx = -3, ux = 3,
                 k =  4, iter = 500, prior = norm5,
                 ICA.control = list(rseed = 1366, ncount = 50),
                 crt.bayes.control = list(cubature = list(maxEval = 2500, tol = 1e-4)))
  plot(res16,
       sens.bayes.control = list(cubature = list(maxEval = 3000, tol = 1e-4)),
       sens.control = list(optslist = list(maxeval = 3000)))
  # took 925 second on my system

## End(Not run)


</code></pre>

<hr>
<h2 id='bayes.update'>Updating an Object of Class <code>minimax</code></h2><span id='topic+bayes.update'></span>

<h3>Description</h3>

<p>Runs the ICA optimization algorithm on an object of class <code>minimax</code> for more number of iterations  and updates the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes.update(object, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes.update_+3A_object">object</code></td>
<td>
<p>An object of class <code>minimax</code>.</p>
</td></tr>
<tr><td><code id="bayes.update_+3A_iter">iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="bayes.update_+3A_...">...</code></td>
<td>
<p>An argument of no further use.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bayes">bayes</a></code>
</p>

<hr>
<h2 id='bayescomp'>Bayesian Compound DP-Optimal Designs</h2><span id='topic+bayescomp'></span>

<h3>Description</h3>

<p>Finds compound Bayesian DP-optimal designs that meet the dual goal of parameter estimation and
increasing the probability of a particular outcome in a binary response  model.
A compound Bayesian DP-optimal design maximizes  the product of the Bayesian efficiencies of a design <code class="reqn">\xi</code> with respect to D- and average P-optimality, weighted by a pre-defined mixing constant
<code class="reqn">0 \leq \alpha \leq 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayescomp(
  formula,
  predvars,
  parvars,
  family = binomial(),
  prior,
  alpha,
  prob,
  lx,
  ux,
  iter,
  k,
  fimfunc = NULL,
  ICA.control = list(),
  sens.control = list(),
  crt.bayes.control = list(),
  sens.bayes.control = list(),
  initial = NULL,
  npar = NULL,
  plot_3d = c("lattice", "rgl")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayescomp_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_prior">prior</code></td>
<td>
<p>An object of class <code>cprior</code>. User can also use one of the functions
<code><a href="#topic+uniform">uniform</a></code>, <code><a href="#topic+normal">normal</a></code>,
<code><a href="#topic+skewnormal">skewnormal</a></code> or <code><a href="#topic+student">student</a></code>  to create the  prior. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_alpha">alpha</code></td>
<td>
<p>A value between 0 and 1.
Compound or combined DP-criterion  is the product of the efficiencies of a design  with respect to D- and average P- optimality, weighted by <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_prob">prob</code></td>
<td>
<p>Either <code>formula</code> or a <code>function</code>. When function, its argument are <code>x</code> and <code>param</code>, and they are the same as the arguments in <code>fimfunc</code>.
<code>prob</code> as a function takes the design points and vector of parameters and returns the probability of success at each design points.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_k">k</code></td>
<td>
<p>Number of design points. Must be at least equal to the number of model parameters to avoid singularity of the FIM.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_ica.control">ICA.control</code></td>
<td>
<p>ICA control parameters. For details, see <code><a href="#topic+ICA.control">ICA.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_crt.bayes.control">crt.bayes.control</code></td>
<td>
<p>A list. Control parameters to approximate the integral in  the Bayesian criterion at a given design over the parameter space.
For details, see <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_sens.bayes.control">sens.bayes.control</code></td>
<td>
<p>A list. Control parameters to verify the general equivalence theorem. For details, see <code><a href="#topic+sens.bayes.control">sens.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_initial">initial</code></td>
<td>
<p>A matrix of the  initial design points and weights that will be inserted into the initial solutions (countries) of the algorithm.
Every row is a design, i.e.  a concatenation of <code>x</code> and <code>w</code>. Will be coerced to a <code>matrix</code> if necessary.  See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not specified correctly, the sensitivity (derivative) plot may be shifted below the y-axis.
When <code>NULL</code> (default), it will be set to <code>length(parvars)</code> or
<code>prior$npar</code> when <code>missing(formula)</code>.</p>
</td></tr>
<tr><td><code id="bayescomp_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to <code>"lattice"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\Xi</code> be the space of all  approximate designs with
<code class="reqn">k</code> design points (support points) at <code class="reqn">x_1, x_2, ...,  x_k</code>
from  design space <code class="reqn">\chi</code> with
corresponding weights  <code class="reqn">w_1,... ,w_k</code>.
Let <code class="reqn">M(\xi, \theta)</code> be the Fisher information
matrix (FIM) of a <code class="reqn">k-</code>point design <code class="reqn">\xi</code>,
<code class="reqn">\pi(\theta)</code> is a user-given  prior distribution for the vector of unknown parameters <code class="reqn">\theta</code> and
<code class="reqn">p(x_i, \theta)</code> is the ith probability of success
given by <code class="reqn">x_i</code> in a binary response model.
A  compound Bayesian DP-optimal design maximizes over <code class="reqn">\Xi</code>
</p>
<p style="text-align: center;"><code class="reqn">\int_{\theta \in \Theta} \frac{\alpha}{q}\log|M(\xi, \theta)| + (1- \alpha)
\log \left( \sum_{i=1}^k w_ip(x_i, \theta) \right) \pi(\theta) d\theta.</code>
</p>

<p>To verify the equivalence theorem of the output design,
use <code><a href="base.html#topic+plot">plot</a></code> function or change the value of the <code>checkfreq</code> in the argument <code><a href="#topic+ICA.control">ICA.control</a></code>.
</p>
<p>To increase the speed of the algorithm, change the value of the tuning parameters <code>tol</code> and <code>maxEval</code> via
the argument  <code>crt.bayes.control</code> when its <code>method</code> component  is equal to  <code>"cubature"</code>.
In general, if the CPU time matters, the user should find an appropriate speed-accuracy trade-off  for her/his own problem.
See 'Examples' for more details.
</p>


<h3>Value</h3>

<p>an object of class <code>minimax</code> that is a list including three sub-lists:
</p>

<dl>
<dt><code>arg</code></dt><dd><p>A list of design and algorithm parameters.</p>
</dd>
<dt><code>evol</code></dt><dd><p>A list of length equal to the number of iterations that stores the information about the best design (design with the minimum criterion value) of each iteration as follows:
<code>evol[[iter]]</code> contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>iter</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> Iteration number.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>x</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design points. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>w</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design weights. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>min_cost</code>               </td><td style="text-align: left;">      </td><td style="text-align: left;"> Value of the criterion for the best imperialist (design).  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>mean_cost</code>              </td><td style="text-align: left;">      </td><td style="text-align: left;"> Mean of the criterion values of all the imperialists. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sens</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> An object of class <code>'sensminimax'</code>. See below.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>empires</code></dt><dd><p>A list of all the empires of the last iteration.</p>
</dd>
<dt><code>alg</code></dt><dd><p>A list with following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>nfeval</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of function evaluations. It does not count the function evaluations from checking the general equivalence theorem. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nlocal</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful local searches. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nrevol</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful revolutions. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nimprove</code>         </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful movements toward the imperialists in the assimilation step. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>convergence</code>      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Stopped by <code>'maxiter'</code> or <code>'equivalence'</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>method</code></dt><dd><p>A type of optimal designs used.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design points and weights at the final iteration.</p>
</dd>
<dt><code>out</code></dt><dd><p>A data frame of design points, weights, value of the criterion for the best imperialist (min_cost), and Mean of the criterion values of all the imperialistsat each iteration (mean_cost).</p>
</dd>
</dl>

<p>The list <code>sens</code>  contains information about the design verification by the general equivalence theorem.
See <code>sensbayes</code> for more Details.
It is only given every <code>ICA.control$checkfreq</code> iterations
and also the last iteration if   <code>ICA.control$checkfreq &gt;= 0</code>. Otherwise, <code>NULL</code>.
</p>


<h3>References</h3>

<p>McGree, J. M., Eccleston, J. A., and Duffull, S. B. (2008). Compound optimal design criteria for nonlinear models. Journal of Biopharmaceutical Statistics, 18(4), 646-661.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensbayescomp">sensbayescomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################################################
# DP-optimal design for a logitic model with two predictors: with formula
##########################################################################
p &lt;- c(1, -2, 1, -1)
myprior &lt;- uniform(p -1.5, p + 1.5)
myformula1 &lt;- ~exp(b0+b1*x1+b2*x2+b3*x1*x2)/(1+exp(b0+b1*x1+b2*x2+b3*x1*x2))
res1 &lt;- bayescomp(formula = myformula1,
                  predvars = c("x1", "x2"),
                  parvars = c("b0", "b1", "b2", "b3"),
                  family = binomial(),
                  lx = c(-1, -1), ux = c(1, 1),
                  prior = myprior, iter = 1, k = 7,
                  prob = ~1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2)),
                  alpha = .5, ICA.control = list(rseed = 1366),
                  crt.bayes.control = list(cubature = list(tol = 1e-4, maxEval = 1000)))


## Not run: 
  res1 &lt;- update(res1, 1000)
  plot(res1, sens.bayes.control = list(cubature = list(tol = 1e-3, maxEval = 1000)))
  # or use quadrature method
  plot(res1, sens.bayes.control= list(method = "quadrature"))

## End(Not run)

##########################################################################
# DP-optimal design for a logitic model with two predictors: with fimfunc
##########################################################################
# The function of the Fisher information matrix for this model is 'FIM_logistic_2pred'
# We should reparameterize it to match the standard of the argument 'fimfunc'
## Not run: 
myfim &lt;- function(x, w, param){
  npoint &lt;- length(x)/2
  x1 &lt;- x[1:npoint]
  x2 &lt;- x[(npoint+1):(npoint*2)]
  FIM_logistic_2pred(x1 = x1,x2 = x2, w = w, param = param)
}

## The following function is equivalent to the function created
# by the formula: ~1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2))
# It returns probability of success given x and param
# x = c(x1, x2) and param = c()

myprob &lt;- function(x, param){
  npoint &lt;- length(x)/2
  x1 &lt;- x[1:npoint]
  x2 &lt;- x[(npoint+1):(npoint*2)]
  b0 &lt;- param[1]
  b1 &lt;- param[2]
  b2 &lt;- param[3]
  b3 &lt;- param[4]
  out &lt;- 1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2))
  return(out)
}

res2 &lt;- bayescomp(fimfunc = myfim,
                  lx = c(-1, -1), ux = c(1, 1),
                  prior = myprior, iter = 1000, k = 7,
                  prob = myprob, alpha = .5,
                  ICA.control = list(rseed = 1366))
  plot(res2, sens.bayes.control = list(cubature = list(maxEval = 1000, tol = 1e-4)))
  # quadrature with 6 nodes (default)
  plot(res2, sens.bayes.control= list(method = "quadrature"))

## End(Not run)


</code></pre>

<hr>
<h2 id='beff'>Calculates Relative Efficiency for Bayesian Optimal Designs</h2><span id='topic+beff'></span>

<h3>Description</h3>

<p>Given a prior distribution for the parameters, this function calculates the Bayesian D-and PA- efficiency of a design <code class="reqn">\xi_1</code> with respect to a design <code class="reqn">\xi_2</code>.
Usually, <code class="reqn">\xi_2</code> is an optimal design.
This function is especially useful for investigating the robustness of Bayesian optimal designs under different prior distributions (See 'Examples').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beff(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  prior,
  fimfunc = NULL,
  x2,
  w2,
  x1,
  w1,
  crt.bayes.control = list(),
  npar = NULL,
  type = c("D", "PA"),
  prob = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beff_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="beff_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="beff_+3A_prior">prior</code></td>
<td>
<p>An object of class <code>cprior</code>. User can also use one of the functions
<code><a href="#topic+uniform">uniform</a></code>, <code><a href="#topic+normal">normal</a></code>,
<code><a href="#topic+skewnormal">skewnormal</a></code> or <code><a href="#topic+student">student</a></code>  to create the  prior. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_x2">x2</code></td>
<td>
<p>Vector of design (support) points of the optimal design (<code class="reqn">\xi_2</code>). Similar to <code>x1</code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_w2">w2</code></td>
<td>
<p>Vector of corresponding design weights for <code>x2</code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_x1">x1</code></td>
<td>
<p>Vector of design (support) points of <code class="reqn">\xi_1</code>. See 'Details' of <code><a href="#topic+leff">leff</a></code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_w1">w1</code></td>
<td>
<p>Vector of corresponding design weights for <code>x1</code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_crt.bayes.control">crt.bayes.control</code></td>
<td>
<p>A list. Control parameters to approximate the integral in  the Bayesian criterion at a given design over the parameter space.
For details, see <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis. When <code>NULL</code>, it will be set here to <code>length(inipars)</code>.</p>
</td></tr>
<tr><td><code id="beff_+3A_type">type</code></td>
<td>
<p>A character. <code>"D"</code> denotes the D-efficiency and <code>"PA"</code> denotes the average P-efficiency.</p>
</td></tr>
<tr><td><code id="beff_+3A_prob">prob</code></td>
<td>
<p>Either <code>formula</code> or a <code>function</code>. When function, its argument are <code>x</code> and <code>param</code>, and they are the same as the arguments in <code>fimfunc</code>.
<code>prob</code> as a function takes the design points and vector of parameters and returns the probability of success at each design points.
See 'Examples'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Masoudi et al. (2018) for formula details (the paper is under review and will be updated as soon as accepted).
</p>
<p>The argument  <code>x1</code> is the vector of design points.
For design points with more than one dimension (the models with more than one predictors),
it is a concatenation of the design points, but <strong>dimension-wise</strong>.
For example, let the model has three predictors   <code class="reqn">(I, S, Z)</code>.
Then,  a two-point optimal design has the following points:
<code class="reqn">\{\mbox{point1} = (I_1, S_1, Z_1), \mbox{point2} = (I_2, S_2, Z_2)\}</code>.
Then, the argument <code>x</code> is equal to
<code>x = c(I1, I2, S1, S2, Z1, Z2)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################
#  2PL model
############################
formula4.1 &lt;- ~ 1/(1 + exp(-b *(x - a)))
predvars4.1 &lt;- "x"
parvars4.1 &lt;- c("a", "b")

# des4.1 is a list of Bayesian optimal designs with corresponding priors.


des4.1 &lt;- vector("list", 6)
des4.1[[1]]$x &lt;- c(-3, -1.20829, 0, 1.20814, 3)
des4.1[[1]]$w &lt;- c(.24701, .18305, .13988, .18309, .24702)
des4.1[[1]]$prior &lt;- uniform(lower =  c(-3, .1), upper = c(3, 2))

des4.1[[2]]$x &lt;- c(-2.41692, -1.16676, .04386, 1.18506, 2.40631)
des4.1[[2]]$w &lt;- c(.26304, .18231, .14205, .16846, .24414)
des4.1[[2]]$prior &lt;- student(mean =  c(0, 1), S   = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                             df = 3, lower =  c(-3, .1), upper = c(3, 2))

des4.1[[3]]$x &lt;- c(-2.25540, -.76318, .54628, 2.16045)
des4.1[[3]]$w &lt;- c(.31762, .18225, .18159, .31853)
des4.1[[3]]$prior &lt;- normal(mu =  c(0, 1),
                            sigma = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                            lower =  c(-3, .1), upper = c(3, 2))

des4.1[[4]]$x &lt;- c(-2.23013, -.66995, .67182, 2.23055)
des4.1[[4]]$w &lt;- c(.31420, .18595, .18581, .31404)
des4.1[[4]]$prior &lt;- normal(mu =  c(0, 1),
                            sigma = matrix(c(1, 0, 0, .5), nrow = 2),
                            lower =  c(-3, .1), upper = c(3, 2))

des4.1[[5]]$x &lt;- c(-1.51175, .12043, 1.05272, 2.59691)
des4.1[[5]]$w &lt;- c(.37679, .14078, .12676, .35567)
des4.1[[5]]$prior &lt;- skewnormal(xi = c(0, 1),
                                Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                                alpha = c(1, 0), lower =  c(-3, .1), upper = c(3, 2))


des4.1[[6]]$x &lt;- c(-2.50914, -1.16780, -.36904, 1.29227)
des4.1[[6]]$w &lt;- c(.35767, .11032, .15621, .37580)
des4.1[[6]]$prior &lt;- skewnormal(xi = c(0, 1),
                                Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                                alpha = c(-1, 0), lower =  c(-3, .1), upper = c(3, 2))

## now we want to find the relative efficiency of
## all Bayesian optimal designs assuming different priors (6 * 6)
eff4.1 &lt;- matrix(NA, 6, 6)
colnames(eff4.1) &lt;- c("uni", "t", "norm1", "norm2", "skew1", "skew2")
rownames(eff4.1) &lt;- colnames(eff4.1)
## Not run: 
for (i in 1:6)
  for(j in 1:6)
    eff4.1[i, j] &lt;- beff(formula = formula4.1,
                         predvars = predvars4.1,
                         parvars = parvars4.1,
                         family = binomial(),
                         prior = des4.1[[i]]$prior,
                         x2 = des4.1[[i]]$x,
                         w2 = des4.1[[i]]$w,
                         x1 = des4.1[[j]]$x,
                         w1 = des4.1[[j]]$w)
# For example the first row represents Bayesian D-efficiencies of different
# Bayesian optimal design found assuming different priors with respect to
# the Bayesian D-optimal design found under uniform prior distribution.
  eff4.1

## End(Not run)

#############################
# Relative efficiency for the DP-Compund criterion
############################
p &lt;- c(1, -2, 1, -1)
prior4.4 &lt;- uniform(p -1.5, p + 1.5)
formula4.4 &lt;- ~exp(b0+b1*x1+b2*x2+b3*x1*x2)/(1+exp(b0+b1*x1+b2*x2+b3*x1*x2))
prob4.4 &lt;- ~1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2))
predvars4.4 &lt;-  c("x1", "x2")
parvars4.4 &lt;- c("b0", "b1", "b2", "b3")
lb &lt;- c(-1, -1)
ub &lt;- c(1, 1)



## des4.4 is a list of DP-optimal designs found using different values for alpha
des4.4 &lt;- vector("list", 5)
des4.4[[1]]$x &lt;- c(-1, 1)
des4.4[[1]]$w &lt;- c(1)
des4.4[[1]]$alpha &lt;- 0


des4.4[[2]]$x &lt;- c(1, -.62534, .11405, -1, 1, .28175, -1, -1, 1, -1, -1, 1, 1, .09359)
des4.4[[2]]$w &lt;- c(.08503, .43128, .01169, .14546, .05945, .08996, .17713)
des4.4[[2]]$alpha &lt;- .25


des4.4[[3]]$x &lt;- c(-1, .30193, 1, 1, .07411, -1, -.31952, -.08251, 1, -1, 1, -1, -1, 1)
des4.4[[3]]$w &lt;- c(.09162, .10288, .15615, .13123, .01993, .22366, .27454)
des4.4[[3]]$alpha &lt;- .5

des4.4[[4]]$x &lt;- c(1, -1, .28274, 1, -1, -.19674, .03288, 1, -1, 1, -1, -.16751, 1, -1)
des4.4[[4]]$w &lt;- c(.19040, .24015, .10011, .20527, .0388, .20075, .02452)
des4.4[[4]]$alpha &lt;- .75

des4.4[[5]]$x &lt;- c(1, -1, .26606, -.13370, 1, -.00887, -1, 1, -.2052, 1, 1, -1, -1, -1)
des4.4[[5]]$w &lt;- c(.23020, .01612, .09546, .16197, .23675, .02701, .2325)
des4.4[[5]]$alpha &lt;- 1

# D-efficiency of the DP-optimal designs:
# des4.4[[5]]$x and  des4.4[[5]]$w is the D-optimal design

beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     x2 = des4.4[[5]]$x,
     w2 = des4.4[[5]]$w,
     x1 = des4.4[[2]]$x,
     w1 = des4.4[[2]]$w)

beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     x2 = des4.4[[5]]$x,
     w2 = des4.4[[5]]$w,
     x1 = des4.4[[3]]$x,
     w1 = des4.4[[3]]$w)

beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     x2 = des4.4[[5]]$x,
     w2 = des4.4[[5]]$w,
     x1 = des4.4[[4]]$x,
     w1 = des4.4[[4]]$w)

# must be one!
beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     prob = prob4.4,
     type = "PA",
     x2 = des4.4[[5]]$x,
     w2 = des4.4[[5]]$w,
     x1 = des4.4[[5]]$x,
     w1 = des4.4[[5]]$w)

## P-efficiency
# reported in Table 4 as eff_P
# des4.4[[1]]$x and  des4.4[[1]]$w is the P-optimal design
beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     prob = prob4.4,
     type = "PA",
     x2 = des4.4[[1]]$x,
     w2 = des4.4[[1]]$w,
     x1 = des4.4[[2]]$x,
     w1 = des4.4[[2]]$w)

beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     prob = prob4.4,
     type = "PA",
     x2 = des4.4[[1]]$x,
     w2 = des4.4[[1]]$w,
     x1 = des4.4[[3]]$x,
     w1 = des4.4[[3]]$w)

beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     prob = prob4.4,
     type = "PA",
     x2 = des4.4[[1]]$x,
     w2 = des4.4[[1]]$w,
     x1 = des4.4[[4]]$x,
     w1 = des4.4[[4]]$w)

beff(formula = formula4.4,
     predvars = predvars4.4,
     parvars = parvars4.4,
     family = binomial(),
     prior = prior4.4,
     prob = prob4.4,
     type = "PA",
     x2 = des4.4[[1]]$x,
     w2 = des4.4[[1]]$w,
     x1 = des4.4[[5]]$x,
     w1 = des4.4[[5]]$w)





</code></pre>

<hr>
<h2 id='crt.bayes.control'>Returns Control Parameters for Approximating Bayesian Criteria</h2><span id='topic+crt.bayes.control'></span>

<h3>Description</h3>

<p>This function returns two lists each corresponds
to an implemented integration method for approximating the integrals
in Bayesian criteria.
The first list is named <code>cubature</code> and contains the <code><a href="cubature.html#topic+hcubature">hcubature</a></code>
control parameters to  approximate the integrals with an adaptive multivariate integration method over hypercubes.
The second list is named <code>quadrature</code> and contains the <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code>
tuning parameters to approximate the integrals with the quadrature methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crt.bayes.control(
  method = c("cubature", "quadrature"),
  cubature = list(tol = 1e-05, maxEval = 50000, absError = 0),
  quadrature = list(type = c("GLe", "GHe"), level = 6, ndConstruction = "product",
    level.trans = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crt.bayes.control_+3A_method">method</code></td>
<td>
<p>A character denotes which method to be used to approximate the integrals in Bayesian criteria.
<code>"cubature"</code> corresponds to the adaptive multivariate integration method using the <code><a href="cubature.html#topic+hcubature">hcubature</a></code> algorithm (default).
<code>"quadrature"</code> corresponds the traditional quadrature formulas and calls the function <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code>.</p>
</td></tr>
<tr><td><code id="crt.bayes.control_+3A_cubature">cubature</code></td>
<td>
<p>A list that will be passed to the arguments of the function <code><a href="cubature.html#topic+hcubature">hcubature</a></code> for the adaptive multivariate integration.
It is required and used when <code>crt.bayes.control$method = "cubature"</code> in the parent function, e.g.  <code><a href="#topic+bayes">bayes</a></code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="crt.bayes.control_+3A_quadrature">quadrature</code></td>
<td>
<p>A list that will be passed to the arguments of the function <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code> for the quadrature-based integration.
It is required and used when <code>crt.bayes.control$method = "quadrature"</code> in the parent function, e.g.  <code><a href="#topic+bayes">bayes</a></code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cubature</code> is a list that its components will be passed to the function <code><a href="cubature.html#topic+hcubature">hcubature</a></code> and they are:
</p>

<dl>
<dt><code>tol</code></dt><dd><p>The maximum tolerance. Defaults to <code>1e-5</code>.</p>
</dd>
<dt><code>maxEval</code></dt><dd><p>The maximum number of function evaluations needed. Note that the actual number of function evaluations performed is only approximately guaranteed not to exceed this number. Defaults to <code>5000</code>.</p>
</dd>
<dt><code>absError</code></dt><dd><p>The maximum absolute error tolerated. Defaults to <code>0</code>.</p>
</dd>
</dl>

<p>One can specify a maximum number of function evaluations.
Otherwise, the integration stops when the estimated error is less than
the absolute error requested, or when the estimated error is less than
<code>tol</code> times the absolute value of the integral,  or when the maximum number of iterations
is reached, whichever is earlier.
<code>cubature</code> is activated when <code>crt.bayes.control$method = "cubature"</code> in
any of the parent functions (for example, <code><a href="#topic+bayes">bayes</a></code>).
</p>
<p><code>quadrature</code> is a list that its components will be passed to
the function <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code> and they are:
</p>

<dl>
<dt><code>type</code></dt><dd><p>Quadrature rule (see Details of <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code>) Defaults to <code>"GLe"</code>.</p>
</dd>
<dt><code>level</code></dt><dd><p>Accuracy level (typically number of grid points for the underlying 1D quadrature rule). Defaults to <code>6</code>.</p>
</dd>
<dt><code>ndConstruction</code></dt><dd><p>Character vector which denotes the construction rule
for multidimensional grids. <code>"product"</code> for product rule,
returns a full grid (default).
<code>"sparse"</code> for combination technique,
leads to a regular sparse grid.</p>
</dd>
<dt><code>level.trans</code></dt><dd><p>Logical variable denotes either to take the levels as number of grid points (FALSE = default) or to transform in that manner that number of grid points = 2^(levels-1) (TRUE). See, code<a href="mvQuad.html#topic+createNIGrid">createNIGrid</a>, for details.</p>
</dd>
</dl>

<p><code>quadrature</code> is activated when <code>crt.bayes.control$method = "quadrature"</code> in
any of the parent functions (for example, <code><a href="#topic+bayes">bayes</a></code>).
</p>


<h3>Value</h3>

<p>A list  of two lists each contains the  control parameters for <code><a href="cubature.html#topic+hcubature">hcubature</a></code> and <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crt.bayes.control()
crt.bayes.control(cubature = list(tol = 1e-4))
crt.bayes.control(quadrature = list(level = 4))
</code></pre>

<hr>
<h2 id='crt.minimax.control'>Returns Control Parameters for Optimizing Minimax Criteria Over The Parameter Space</h2><span id='topic+crt.minimax.control'></span>

<h3>Description</h3>

<p>The function <code>crt.minimax.control</code> returns a list of <code><a href="nloptr.html#topic+nloptr">nloptr</a></code> control parameters for optimizing the minimax criterion over the parameter space.<br />
The key tuning parameter for our application is <strong><code>maxeval</code>.</strong>
Its value should be increased when either the dimension or the size of the parameter space becomes larger
to avoid pre-mature convergence in the inner optimization problem over the parameter space.
If the CPU time matters, the user should find an appropriate speed-accuracy trade-off  for her/his own design problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crt.minimax.control(
  x0 = NULL,
  optslist = list(stopval = -Inf, algorithm = "NLOPT_GN_DIRECT_L", xtol_rel = 1e-06,
    ftol_rel = 0, maxeval = 1000),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crt.minimax.control_+3A_x0">x0</code></td>
<td>
<p>Vector of the starting values for the optimization problem (must be from the parameter space).</p>
</td></tr>
<tr><td><code id="crt.minimax.control_+3A_optslist">optslist</code></td>
<td>
<p>A list. It will be passed to the argument <code>opts</code> of the function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="crt.minimax.control_+3A_...">...</code></td>
<td>
<p>Further arguments will be passed to <code><a href="nloptr.html#topic+nl.opts">nl.opts</a></code> from package <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>optslist</code> will be passed to the argument <code>opts</code> of the function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>:
</p>

<dl>
<dt><code>stopval</code></dt><dd><p>Stop minimization when an objective value &lt;= <code>stopval</code> is found. Setting <code>stopval</code> to <code>-Inf</code> disables this stopping criterion (default).</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Defaults to <code>NLOPT_GN_DIRECT_L</code>. DIRECT-L is a deterministic-search algorithm based on systematic division of the search domain into smaller and smaller hyperrectangles.</p>
</dd>
<dt><code>xtol_rel</code></dt><dd><p>Stop when an optimization step (or an estimate of the optimum) changes every parameter by less than <code>xtol_rel</code> multiplied by the absolute value of the parameter. Criterion is disabled if <code>xtol_rel</code> is non-positive. Defaults to <code>1e-5</code>.</p>
</dd>
<dt><code>ftol_rel</code></dt><dd><p>Stop when an optimization step (or an estimate of the optimum) changes the objective function value by less than <code>ftol_rel</code> multiplied by the absolute value of the function value. Criterion is disabled if <code>ftol_rel</code> is non-positive. Defaults to <code>1e-8</code>.</p>
</dd>
<dt><code>maxeval</code></dt><dd><p>Stop when the number of function evaluations exceeds <code>maxeval</code>. Criterion is disabled if <code>maxeval</code> is non-positive. Defaults to <code>1000</code>. See below.</p>
</dd>
</dl>

<p>A detailed explanation of all the options is shown by <code>nloptr.print.options()</code> in package <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.
</p>


<h3>Value</h3>

<p>A list of control parameters for the function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crt.minimax.control(optslist = list(maxeval = 2000))
</code></pre>

<hr>
<h2 id='FIM_2par_exp_censor1'>Fisher Information Matrix for a 2-Parameter Cox Proportional-Hazards Model for Type One Censored Data</h2><span id='topic+FIM_2par_exp_censor1'></span>

<h3>Description</h3>

<p>It provides the cpp function for the FIM introduced in  Eq. (3.1) of Schmidt and Schwabe (2015) for type one censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_2par_exp_censor1(x, w, param, tcensor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_2par_exp_censor1_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_2par_exp_censor1_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_2par_exp_censor1_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code class="reqn">c(\beta_0, \beta_1)</code>.</p>
</td></tr>
<tr><td><code id="FIM_2par_exp_censor1_+3A_tcensor">tcensor</code></td>
<td>
<p>The experiment is terminated at the fixed time point <code>tcensor</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>References</h3>

<p>Schmidt, D., &amp; Schwabe, R. (2015). On optimal designs for censored data. Metrika, 78(3), 237-257.
</p>

<hr>
<h2 id='FIM_2par_exp_censor2'>Fisher Information Matrix for a 2-Parameter Cox Proportional-Hazards Model for Random Censored Data</h2><span id='topic+FIM_2par_exp_censor2'></span>

<h3>Description</h3>

<p>It provides the cpp function for the FIM introduced in  Eq. (3.1) of Schmidt and Schwabe (2015) for random censored data (type two censored data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_2par_exp_censor2(x, w, param, tcensor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_2par_exp_censor2_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_2par_exp_censor2_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_2par_exp_censor2_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code class="reqn">c(\beta_0, \beta_1)</code>.</p>
</td></tr>
<tr><td><code id="FIM_2par_exp_censor2_+3A_tcensor">tcensor</code></td>
<td>
<p>The experiment is terminated at the fixed time point <code>tcensor</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>References</h3>

<p>Schmidt, D., &amp; Schwabe, R. (2015). On optimal designs for censored data. Metrika, 78(3), 237-257.
</p>

<hr>
<h2 id='FIM_3par_exp_censor1'>Fisher Information Matrix for a 3-Parameter Cox Proportional-Hazards Model for Type One Censored Data</h2><span id='topic+FIM_3par_exp_censor1'></span>

<h3>Description</h3>

<p>It provides the cpp function for the FIM introduced in Page 247 of Schmidt and Schwabe (2015) for type one censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_3par_exp_censor1(x, w, param, tcensor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_3par_exp_censor1_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_3par_exp_censor1_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_3par_exp_censor1_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code class="reqn">c(\beta_0, \beta_1, \beta_2)</code>.</p>
</td></tr>
<tr><td><code id="FIM_3par_exp_censor1_+3A_tcensor">tcensor</code></td>
<td>
<p>The experiment is terminated at the fixed time point <code>tcensor</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>References</h3>

<p>Schmidt, D., &amp; Schwabe, R. (2015). On optimal designs for censored data. Metrika, 78(3), 237-257.
</p>

<hr>
<h2 id='FIM_3par_exp_censor2'>Fisher Information Matrix for a 3-Parameter Cox Proportional-Hazards Model for Random Censored Data</h2><span id='topic+FIM_3par_exp_censor2'></span>

<h3>Description</h3>

<p>It provides the cpp function for the FIM introduced in Page 247 of Schmidt and Schwabe (2015) for random censored data (type two censored data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_3par_exp_censor2(x, w, param, tcensor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_3par_exp_censor2_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_3par_exp_censor2_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_3par_exp_censor2_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code class="reqn">(\beta_0, \beta_1, \beta_2)</code>.</p>
</td></tr>
<tr><td><code id="FIM_3par_exp_censor2_+3A_tcensor">tcensor</code></td>
<td>
<p>The experiment is terminated at the fixed time point <code>tcensor</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>References</h3>

<p>Schmidt, D., &amp; Schwabe, R. (2015). On optimal designs for censored data. Metrika, 78(3), 237-257.
</p>

<hr>
<h2 id='FIM_exp_2par'>Fisher Information Matrix for the 2-Parameter Exponential Model</h2><span id='topic+FIM_exp_2par'></span>

<h3>Description</h3>

<p>It provides the cpp function for FIM for the model  <code>~a + exp(-b*x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_exp_2par(x, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_exp_2par_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_exp_2par_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_exp_2par_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(a, b)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FIM does not depend on the value of <code>a</code>.
</p>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>References</h3>

<p>Dette, H., &amp; Neugebauer, H. M. (1997). Bayesian D-optimal designs for exponential regression models. Journal of Statistical Planning and Inference, 60(2), 331-349.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FIM_exp_2par(x = c(1, 2), w = c(.5, .5), param = c(3, 4))
</code></pre>

<hr>
<h2 id='FIM_kinetics_alcohol'>Fisher Information Matrix for the Alcohol-Kinetics Model</h2><span id='topic+FIM_kinetics_alcohol'></span>

<h3>Description</h3>

<p>It provides the cpp function for FIM for the model <code>~(b3 * x1)/(1 + b1 * x1 + b2 * x2)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_kinetics_alcohol(x1, x2, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_kinetics_alcohol_+3A_x1">x1</code></td>
<td>
<p>Vector of design points (first dimension).</p>
</td></tr>
<tr><td><code id="FIM_kinetics_alcohol_+3A_x2">x2</code></td>
<td>
<p>Vector of design points (second dimension).</p>
</td></tr>
<tr><td><code id="FIM_kinetics_alcohol_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_kinetics_alcohol_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(b1, b2, b3)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>

<hr>
<h2 id='FIM_logistic'>Fisher Information Matrix for the 2-Parameter Logistic (2PL) Model</h2><span id='topic+FIM_logistic'></span>

<h3>Description</h3>

<p>It provides the cpp function for FIM for the model  <code>~1/(1 + exp(-b *(x - a)))</code>.
In item response theory (IRT),
<code class="reqn">a</code> is the item difficulty parameter, <code class="reqn">b</code> is the item discrimination parameter and <code class="reqn">x</code> is the person ability parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_logistic(x, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_logistic_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_logistic_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_logistic_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(a, b)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be shown that minimax and standardized D-optimal designs for the 2PL model is symmetric around point
<code class="reqn">a_M = (a^L + a^U)/2</code> where <code class="reqn">a^L</code> and <code class="reqn">a^U</code> are the
lower bound and upper bound for parameter <code class="reqn">a</code>, respectively. In <code><a href="#topic+ICA.control">ICA.control</a></code>,
arguments <code>sym</code> and <code>sym_point</code> can be used to specify <code class="reqn">a_M</code> and find accurate symmetric optimal designs.
</p>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FIM_logistic(x = c(1, 2), w = c(.5, .5), param = c(2, 1))
</code></pre>

<hr>
<h2 id='FIM_logistic_2pred'>Fisher Information Matrix for the Logistic Model with Two Predictors</h2><span id='topic+FIM_logistic_2pred'></span>

<h3>Description</h3>

<p>It provides the cpp function for FIM for the following model:<br />
<code>~exp(b0+ b1 * x1 + b2 * x2 + b3 * x1 * x2)/(1 + exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_logistic_2pred(x1, x2, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_logistic_2pred_+3A_x1">x1</code></td>
<td>
<p>Vector of design points (for first predictor).</p>
</td></tr>
<tr><td><code id="FIM_logistic_2pred_+3A_x2">x2</code></td>
<td>
<p>Vector of design points (for second predictor).</p>
</td></tr>
<tr><td><code id="FIM_logistic_2pred_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_logistic_2pred_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(b0, b1, b2, b3)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>

<hr>
<h2 id='FIM_logistic_4par'>Fisher Information Matrix for the 4-Parameter Logistic Model</h2><span id='topic+FIM_logistic_4par'></span>

<h3>Description</h3>

<p>It provides the cpp function for the FIM for the model
<code>~theta1/(1+exp(theta2*x+theta3))+theta4</code>.
This model is another re-parameterization of the 4-parameter Hill model.
For more details, see Eq. (1) and (2) in Hyun and  Wong (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_logistic_4par(x, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_logistic_4par_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_logistic_4par_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_logistic_4par_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(theta1, theta2, theta3, theta4)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fisher information matrix does not depend on <code>theta4</code>.<br />
</p>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>References</h3>

<p>Hyun, S. W., &amp; Wong, W. K. (2015). Multiple-Objective Optimal Designs for Studying the Dose Response Function and Interesting Dose Levels. The international journal of biostatistics, 11(2), 253-271.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiple">multiple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FIM_logistic_4par(x = c(-6.9, -4.6, -3.9, 6.7 ),
                  w = c(0.489, 0.40, 0.061, 0.050),
                  param = c(1.563, 1.790, 8.442, 0.137))
</code></pre>

<hr>
<h2 id='FIM_loglin'>Fisher Information Matrix for the Mixed Inhibition Model</h2><span id='topic+FIM_loglin'></span>

<h3>Description</h3>

<p>It provides the cpp function for the FIM for the model <code>~theta0 + theta1* log(x + theta2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_loglin(x, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_loglin_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_loglin_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_loglin_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(theta0, theta1, theta2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FIM of this model does not depend on the parameter <code>theta0</code>.
</p>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>References</h3>

<p>Dette, H., Kiss, C., Bevanda, M., &amp; Bretz, F. (2010). Optimal designs for the EMAX, log-linear and exponential models. Biometrika, 97(2), 513-518.
</p>

<hr>
<h2 id='FIM_mixed_inhibition'>Fisher Information Matrix for the Mixed Inhibition Model.</h2><span id='topic+FIM_mixed_inhibition'></span>

<h3>Description</h3>

<p>It provides the cpp function for FIM for the model <code>~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_mixed_inhibition(S, I, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_mixed_inhibition_+3A_s">S</code></td>
<td>
<p>Vector of <code>S</code> component of design points. <code>S</code> is the substrate concentration.</p>
</td></tr>
<tr><td><code id="FIM_mixed_inhibition_+3A_i">I</code></td>
<td>
<p>Vector of <code>I</code> component of design points. <code>I</code> is the inhibitor concentration.</p>
</td></tr>
<tr><td><code id="FIM_mixed_inhibition_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>S</code> and <code>I</code>, besides  <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_mixed_inhibition_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(V, Km, Kic, Kiu)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal design does not depend on parameter <code class="reqn">V</code>.
</p>


<h3>Value</h3>

<p>Fisher information matrix of design.
</p>


<h3>References</h3>

<p>Bogacka, B., Patan, M., Johnson, P. J., Youdim, K., &amp; Atkinson, A. C. (2011). Optimum design of experiments for enzyme inhibition kinetic models. Journal of biopharmaceutical statistics, 21(3), 555-572.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FIM_mixed_inhibition(S = c(30, 3.86, 30, 4.60),
                     I = c(0, 0, 5.11, 4.16), w = rep(.25, 4),
                     param = c(1.5, 5.2, 3.4, 5.6))
</code></pre>

<hr>
<h2 id='FIM_power_logistic'>Fisher Information Matrix for the Power Logistic Model</h2><span id='topic+FIM_power_logistic'></span>

<h3>Description</h3>

<p>It provides the cpp function for FIM for the model  <code>~1/(1 + exp(-b *(x - a)))^s</code>, but when <code>s</code> is fixed (a two by two matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_power_logistic(x, w, param, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_power_logistic_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_power_logistic_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_power_logistic_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(a, b)</code>.</p>
</td></tr>
<tr><td><code id="FIM_power_logistic_+3A_s">s</code></td>
<td>
<p>parameter <code>s</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>


<h3>Note</h3>

<p>This matrix is a two by two matrix and not equal to the Fisher information matrix for the power logistic model
when the derivative is taken with respect to all the three parameters.
This matrix is only given to be used in some illustrative examples.
</p>

<hr>
<h2 id='FIM_sig_emax'>Fisher Information Matrix for the Sigmoid Emax Model</h2><span id='topic+FIM_sig_emax'></span>

<h3>Description</h3>

<p>It provides the cpp function for FIM for the model <code>~b1+(b2-b1)*(x^b4)/(x^b4+b3^b4)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIM_sig_emax(x, w, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIM_sig_emax_+3A_x">x</code></td>
<td>
<p>Vector of design points.</p>
</td></tr>
<tr><td><code id="FIM_sig_emax_+3A_w">w</code></td>
<td>
<p>Vector of design weight. Its length must be equal to the length of <code>x</code> and <code>sum(w) = 1</code>.</p>
</td></tr>
<tr><td><code id="FIM_sig_emax_+3A_param">param</code></td>
<td>
<p>Vector of values for the model parameters <code>c(b1, b2, b3, b4)</code>.
The mean of response variable is .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher information matrix.
</p>

<hr>
<h2 id='ICA.control'>Returns ICA Control Optimization Parameters</h2><span id='topic+ICA.control'></span>

<h3>Description</h3>

<p>The function <code>ICA.control</code> returns a list of ICA control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICA.control(
  ncount = 40,
  nimp = ncount/10,
  assim_coeff = 4,
  revol_rate = 0.3,
  damp = 0.99,
  uniting_threshold = 0.02,
  equal_weight = FALSE,
  sym = FALSE,
  sym_point = NULL,
  stop_rule = c("maxiter", "equivalence"),
  stoptol = 0.99,
  checkfreq = 0,
  plot_cost = TRUE,
  plot_sens = TRUE,
  plot_3d = c("lattice", "rgl"),
  trace = TRUE,
  rseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICA.control_+3A_ncount">ncount</code></td>
<td>
<p>Number of countries. Defaults to <code>40</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_nimp">nimp</code></td>
<td>
<p>Number of imperialists. Defaults to 10 percent of <code>ncount</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_assim_coeff">assim_coeff</code></td>
<td>
<p>Assimilation coefficient. Defaults to <code>4</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_revol_rate">revol_rate</code></td>
<td>
<p>Revolution rate. Defaults to <code>0.3</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_damp">damp</code></td>
<td>
<p>Damp ratio for revolution rate.  <code>revol_rate</code> is decreased in every iteration by a factor of <code>damp</code> (<code>revol_rate * damp</code>). Defaults to <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_uniting_threshold">uniting_threshold</code></td>
<td>
<p>If the distance between two imperialists is less than the product of the uniting threshold by the largest distance in the search space, ICA unites the empires. Defaults to <code>0.02</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_equal_weight">equal_weight</code></td>
<td>
<p>Should the weights of design points assumed to be equal? Defaults to <code>FALSE</code>. If <code>TRUE</code>, it reduces the dimension of the search space and produces a design that gives equal weight to all of its support points.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_sym">sym</code></td>
<td>
<p>Should the design points be symmetric around <code>sym_point</code>? Defaults to <code>FALSE</code>. When <code>TRUE</code>, <code>sym_point</code> must be given.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_sym_point">sym_point</code></td>
<td>
<p>If <code>sym = TRUE</code>, the design points will be symmetric around <code>sym_point</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_stop_rule">stop_rule</code></td>
<td>
<p>Either  <code>'maxiter'</code> or <code>'equivalence'</code>.
Denotes the type of stopping rule.  See 'Details'. Defaults to <code>'maxiter'</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_stoptol">stoptol</code></td>
<td>
<p>If <code>stop_rule = 'equivalence'</code>, algorithm stops when  ELB is larger than  <code>stoptol</code>. Defaults to <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_checkfreq">checkfreq</code></td>
<td>
<p>The algorithm verifies the  general equivalence theorem in
every <code>checkfreq</code> iterations.
When <code>checkfreq = 0</code>, no verification will be done. When <code>checkfreq = Inf</code>, only the output design will be verified.
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_plot_cost">plot_cost</code></td>
<td>
<p>Plot the iterations (evolution) of algorithm? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function at every <code>checkfreq</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Character. Which package should be used to plot the sensitivity plot for models with two explanatory variables?</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_trace">trace</code></td>
<td>
<p>Print the information in every iteration? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ICA.control_+3A_rseed">rseed</code></td>
<td>
<p>Random seed. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>stop_rule = 'maxiter'</code>, the algorithm iterates until maximum number of iterations.<br />
If <code>stope_rule = 'equivalence'</code>, the algorithm stops when either ELB  is greater than <code>stoptol</code> or it reaches <code>maxiter</code>.
In this case, you must specify the check frequency by <code>checkfreq</code>.
Note that checking equivalence theorem is a very time consuming process,
especially for Bayesian and minimax design problems.
We advise using this option only for locally, multiple objective and robust optimal designs.
</p>
<p>What to follows shows  how <code>sym_point</code> and <code>sym</code> may be useful? <br />
Assume the 2PL model of the form <code class="reqn"> P(Y=1) = \frac{1}{1+exp(-b(x - a))}</code> and
let the parameters <code class="reqn">a</code> and <code class="reqn">b</code>
belong to
<code class="reqn">[a_L, a_U]</code> and <code class="reqn">[b_L, b_U]</code>, respectively.
It can be shown that the optimal design for this model
is symmetric around <code class="reqn">a_M = \frac{a_L + a_U}{2}</code>.
For this model, to find accurate symmetric designs, one can set <code>sym = TRUE</code> and
provide the value of the <code class="reqn">a_M</code> via <code>sym_point</code>.
In this case, the output design will be symmetric around the point <code>sym_point</code>.
The length of  <code>sym_point</code> must be equal to the number of model predictors, here, is equal to <code>1</code>.
</p>


<h3>Value</h3>

<p>A list of ICA control parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ICA.control(ncount = 100)
</code></pre>

<hr>
<h2 id='ICAOD'>ICAOD: Finding Optimal Designs for Nonlinear Models Using Imperialist Competitive Algorithm</h2><span id='topic+ICAOD'></span>

<h3>Description</h3>

<p>Different functions are available to find optimal designs for linear and nonlinear models using the imperialist competitive algorithm (ICA).
Because the optimality criteria for linear and nonlinear models depend on the unknown parameters,
one should choose on of the following method to deal with the parameter-dependency based on the available information for the unknown parameters:
</p>

<ul>
<li><p><code><a href="#topic+locally">locally</a></code>: finds locally optimal designs. A vector of initial estimates or guess is available for the vector of model parameters from a pilot or similar study.
</p>
</li>
<li><p><code><a href="#topic+bayes">bayes</a></code>: finds Bayesian optimal designs. A continuous prior is available for the vector of unknown model parameters.
</p>
</li>
<li><p><code><a href="#topic+robust">robust</a></code>: finds robust or optimum-in-average designs. It is similar to <code><a href="#topic+bayes">bayes</a></code>, but uses a discrete prior.
</p>
</li>
<li><p><code><a href="#topic+minimax">minimax</a></code>: finds minimax and standardized maximin optimal designs. Each of the unknown  parameters belongs to a user-specified interval. The purpose is to find a design that protects the user against the worst scenario over the parameter space.
Standardized designs should be used when locally optimal design of the model of interest has an analytical solution.
</p>
</li></ul>

<p>Some functions are also available to find optimal designs for special applications:
</p>

<ul>
<li><p><code><a href="#topic+multiple">multiple</a></code>: finds locally multiple objective optimal designs for the 4-parameter Hill model with application in dose-response stuides. It uses the same strategy as  <code>locally</code> to deal with the unknown model parameters.
</p>
</li>
<li><p><code><a href="#topic+bayescomp">bayescomp</a></code>: finds a design that  meets the dual goal of the parameter estimation and
increasing the probability of a particular outcome in a binary response  model.  It uses the same strategy as the function <code>bayes</code> to deal with the unknown mode parameters and applicable in medicine studies.
</p>
</li></ul>



<h3>Details</h3>

<p>The functions <code><a href="#topic+locally">locally</a></code> and <code><a href="#topic+robust">robust</a></code> are very easy to be applied and
they are usually fast. The speed of the functions <code><a href="#topic+bayes">bayes</a></code> and <code><a href="#topic+minimax">minimax</a></code>
considerably depends on the value of the tuning parameters.
</p>
<p>The following functions may also be used  to verify the optimality of an output design for each of the above criterion:
</p>

<ul>
<li><p><code><a href="#topic+senslocally">senslocally</a></code>
</p>
</li>
<li><p><code><a href="#topic+sensrobust">sensrobust</a></code>
</p>
</li>
<li><p><code><a href="#topic+sensbayes">sensbayes</a></code>
</p>
</li>
<li><p><code><a href="#topic+sensminimax">sensminimax</a></code>
</p>
</li>
<li><p><code><a href="#topic+sensmultiple">sensmultiple</a></code>
</p>
</li>
<li><p><code><a href="#topic+sensbayescomp">sensbayescomp</a></code>
</p>
</li></ul>

<p>For more details see Masoudi et al. (2017, 2019).
</p>


<h3>References</h3>

<p>Masoudi E, Holling H, Wong WK (2017). Application of Imperialist Competitive Algorithm to Find Minimax and Standardized Maximin Optimal Designs. Computational Statistics and Data Analysis, 113, 330-345. &lt;doi:10.1016/j.csda.2016.06.014&gt; <br />
Masoudi E, Holling H, Duarte BP, Wong Wk (2019). Metaheuristic Adaptive Cubature Based Algorithm to Find Bayesian Optimal Designs for Nonlinear Models. Journal of Computational and Graphical Statistics. &lt;doi:10.1080/10618600.2019.1601097&gt;
</p>

<hr>
<h2 id='leff'>Calculates Relative Efficiency for Locally Optimal Designs</h2><span id='topic+leff'></span>

<h3>Description</h3>

<p>Given a vector of initial estimates for the parameters, this function calculates the D-and PA- efficiency of a design <code class="reqn">\xi_1</code> with respect to a design <code class="reqn">\xi_2</code>.
Usually, <code class="reqn">\xi_2</code> is an  optimal design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leff(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  inipars,
  type = c("D", "PA"),
  fimfunc = NULL,
  x2,
  w2,
  x1,
  w1,
  npar = length(inipars),
  prob = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leff_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="leff_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="leff_+3A_inipars">inipars</code></td>
<td>
<p>Vector. Initial values for the unknown parameters. It will be passed to the information matrix and also probability function.</p>
</td></tr>
<tr><td><code id="leff_+3A_type">type</code></td>
<td>
<p>A character. <code>"D"</code> denotes the D-efficiency and <code>"PA"</code> denotes the average P-efficiency.</p>
</td></tr>
<tr><td><code id="leff_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_x2">x2</code></td>
<td>
<p>Vector of design (support) points of the optimal design (<code class="reqn">\xi_2</code>). Similar to <code>x1</code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_w2">w2</code></td>
<td>
<p>Vector of corresponding design weights for <code>x2</code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_x1">x1</code></td>
<td>
<p>Vector of design (support) points of <code class="reqn">\xi_1</code>. See 'Details' of <code><a href="#topic+leff">leff</a></code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_w1">w1</code></td>
<td>
<p>Vector of corresponding design weights for <code>x1</code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis. When <code>NULL</code>, it will be set here to <code>length(inipars)</code>.</p>
</td></tr>
<tr><td><code id="leff_+3A_prob">prob</code></td>
<td>
<p>Either <code>formula</code> or a <code>function</code>. When function, its argument are <code>x</code> and <code>param</code>, and they are the same as the arguments in <code>fimfunc</code>.
<code>prob</code> as a function takes the design points and vector of parameters and returns the probability of success at each design points.
See 'Examples'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a known <code class="reqn">\theta_0</code>, relative D-efficiency is
</p>
<p style="text-align: center;"><code class="reqn">exp(\frac{log|M(\xi_1, \theta_0)| - log|M(\xi_2, \theta_0)|}{npar})</code>
</p>

<p>The relative P-efficiency is
</p>
<p style="text-align: center;"><code class="reqn">\exp(\log(\sum_{i=1}^k w_{1i}p(x_{1i}, \theta_0) - \log(\sum_{i=1}^k w_{2i}p(x{2_i}, \theta_0))</code>
</p>

<p>where <code class="reqn">x_2</code> and <code class="reqn">w_2</code> are usually the support points and the corresponding weights of the optimal design, respectively.
</p>
<p>The argument  <code>x1</code> is the vector of design points.
For design points with more than one dimension (the models with more than one predictors),
it is a concatenation of the design points, but <strong>dimension-wise</strong>.
For example, let the model has three predictors   <code class="reqn">(I, S, Z)</code>.
Then,  a two-point optimal design has the following points:
<code class="reqn">\{\mbox{point1} = (I_1, S_1, Z_1), \mbox{point2} = (I_2, S_2, Z_2)\}</code>.
Then, the argument <code>x1</code> is equal to
<code>x = c(I1, I2, S1, S2, Z1, Z2)</code>.
</p>


<h3>Value</h3>

<p>A value between 0 and 1.
</p>


<h3>References</h3>

<p>McGree, J. M., Eccleston, J. A., and Duffull, S. B. (2008). Compound optimal design criteria for nonlinear models. Journal of Biopharmaceutical Statistics, 18(4), 646-661.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1, -2, 1, -1)
prior4.4 &lt;- uniform(p -1.5, p + 1.5)
formula4.4 &lt;- ~exp(b0+b1*x1+b2*x2+b3*x1*x2)/(1+exp(b0+b1*x1+b2*x2+b3*x1*x2))
prob4.4 &lt;- ~1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2))
predvars4.4 &lt;-  c("x1", "x2")
parvars4.4 &lt;- c("b0", "b1", "b2", "b3")


# Locally D-optimal design is as follows:
## weight and point of D-optimal design
# Point1     Point2     Point3     Point4
# /1.00000 \ /-1.00000\ /0.06801 \ /1.00000 \
# \-1.00000/ \-1.00000/ \1.00000 / \1.00000 /
#   Weight1    Weight2    Weight3    Weight4
# 0.250      0.250      0.250      0.250

xopt_D &lt;- c(1, -1, .0680, 1, -1, -1, 1, 1)
wopt_D &lt;- rep(.25, 4)

# Let see if we use only three of the design points, what is the relative efficiency.
leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x1 = c(1, -1, .0680,  -1, -1, 1), w1 = c(.33, .33, .33),
     inipars = p,
     x2 = xopt_D, w2 = wopt_D)
# Wow, it heavily drops!


# Locally P-optimal design has only one support point and is -1 and 1
xopt_P &lt;- c(-1, 1)
wopt_P &lt;- 1

# What is the relative P-efficiency of the D-optimal design with respect to P-optimal design?
leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x1 = xopt_D, w1 = wopt_D,
     inipars = p,
     type = "PA",
     prob = prob4.4,
     x2 = xopt_P, w2 = wopt_P)
# .535


</code></pre>

<hr>
<h2 id='locally'>Locally D-Optimal Designs</h2><span id='topic+locally'></span>

<h3>Description</h3>

<p>Finds locally D-optimal designs for linear and nonlinear models.
It should be used when a vector of initial estimates is available for the unknown model parameters.
Locally optimal designs may not be efficient when the initial estimates are  far away from the true values of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locally(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  lx,
  ux,
  iter,
  k,
  inipars,
  fimfunc = NULL,
  ICA.control = list(),
  sens.control = list(),
  initial = NULL,
  npar = length(inipars),
  plot_3d = c("lattice", "rgl"),
  x = NULL,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locally_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="locally_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="locally_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="locally_+3A_k">k</code></td>
<td>
<p>Number of design points. Must be at least equal to the number of model parameters to avoid singularity of the FIM.</p>
</td></tr>
<tr><td><code id="locally_+3A_inipars">inipars</code></td>
<td>
<p>A vector of initial estimates for the unknown parameters.
It must match <code>parvars</code> or the argument <code>param</code> of the function <code>fimfunc</code>, when provided.</p>
</td></tr>
<tr><td><code id="locally_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_ica.control">ICA.control</code></td>
<td>
<p>ICA control parameters. For details, see <code><a href="#topic+ICA.control">ICA.control</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_initial">initial</code></td>
<td>
<p>A matrix of the  initial design points and weights that will be inserted into the initial solutions (countries) of the algorithm.
Every row is a design, i.e.  a concatenation of <code>x</code> and <code>w</code>. Will be coerced to a <code>matrix</code> if necessary.  See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis.
When <code>NULL</code>, it is set to <code>length(inipars)</code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to <code>"lattice"</code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_x">x</code></td>
<td>
<p>A vector of candidate design (support) points.
When is not set to <code>NULL</code> (default),
the algorithm only finds the optimal weights for the candidate points in  <code>x</code>.
Should be set when the user has a finite number of candidate design points  and the purpose
is to find the optimal weight for each of them (when zero, they will be excluded from the design).
For design points with more than one dimension, see 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="locally_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">M(\xi, \theta_0)</code> be the Fisher information
matrix (FIM) of a <code class="reqn">k-</code>point design <code class="reqn">\xi</code> and
<code class="reqn">\theta_0</code>  be the vector of the initial  estimates for the unknown parameters.
A locally D-optimal design <code class="reqn">\xi^*</code> minimizes over <code class="reqn">\Xi</code>
</p>
<p style="text-align: center;"><code class="reqn">-\log|M(\xi, \theta_0)|.</code>
</p>

<p>One can adjust the tuning parameters in <code><a href="#topic+ICA.control">ICA.control</a></code> to set a stopping rule
based on the general equivalence theorem. See &quot;Examples&quot; below.
</p>


<h3>Value</h3>

<p>an object of class <code>minimax</code> that is a list including three sub-lists:
</p>

<dl>
<dt><code>arg</code></dt><dd><p>A list of design and algorithm parameters.</p>
</dd>
<dt><code>evol</code></dt><dd><p>A list of length equal to the number of iterations that stores
the information about the best design (design with least criterion value)
of each iteration. <code>evol[[iter]]</code> contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>iter</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> Iteration number.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>x</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design points. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>w</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design weights. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>min_cost</code>               </td><td style="text-align: left;">      </td><td style="text-align: left;"> Value of the criterion for the best imperialist (design).  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>mean_cost</code>              </td><td style="text-align: left;">      </td><td style="text-align: left;"> Mean of the criterion values of all the imperialists. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sens</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> An object of class <code>'sensminimax'</code>. See below. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>param</code>                  </td><td style="text-align: left;">      </td><td style="text-align: left;"> Vector of parameters.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>empires</code></dt><dd><p>A list of all the  empires of the last iteration.</p>
</dd>
<dt><code>alg</code></dt><dd><p>A list with following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>nfeval</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of function evaluations.  It does not count the function evaluations from checking the general equivalence theorem.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nlocal</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful local searches. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nrevol</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful revolutions. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nimprove</code>         </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful movements toward the imperialists in the assimilation step. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>convergence</code>      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Stopped by <code>'maxiter'</code> or <code>'equivalence'</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>method</code></dt><dd><p>A type of optimal designs used.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design points and weights at the final iteration.</p>
</dd>
<dt><code>out</code></dt><dd><p>A data frame of design points, weights, value of the criterion for the best imperialist (min_cost), and Mean of the criterion values of all the imperialistsat each iteration (mean_cost).</p>
</dd>
</dl>

<p>The list <code>sens</code> contains information about the design verification by the general equivalence theorem. See <code>sensminimax</code> for more details.
It is given  every <code>ICA.control$checkfreq</code> iterations
and also the last iteration if   <code>ICA.control$checkfreq &gt;= 0</code>. Otherwise, <code>NULL</code>.
</p>
<p><code>param</code> is a vector of parameters that is the global minimum of
the minimax criterion or the global maximum of the standardized maximin criterion over the parameter space, given  the current <code>x</code>, <code>w</code>.
</p>


<h3>References</h3>

<p>Masoudi E, Holling H, Wong W.K. (2017). Application of Imperialist Competitive Algorithm to Find Minimax and Standardized Maximin Optimal Designs. Computational Statistics and Data Analysis, 113, 330-345. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+senslocally">senslocally</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################
# Exponential growth model
################################
# See how we set stopping rule by adjusting 'stop_rule', 'checkfreq' and 'stoptol'
# It calls the 'senslocally' function every checkfreq = 50 iterations to
# calculate the ELB. if ELB is greater than stoptol = .95, then the algoithm stops.

# initializing by one iteration
res1 &lt;- locally(formula = ~a + exp(-b*x), predvars = "x", parvars = c("a", "b"),
                lx = 0, ux = 1, inipars = c(1, 10),
                iter = 1, k = 2,
                ICA.control= ICA.control(rseed = 100,
                                         stop_rule = "equivalence",
                                         checkfreq = 20, stoptol = .95))
## Not run: 
  # update the algorithm
  res1 &lt;- update(res1, 150)
  #stops at iteration 21 because ELB is greater than .95

## End(Not run)

### fixed x, lx and ux are only required for equivalence theorem
## Not run: 
  res1.1 &lt;- locally(formula = ~a + exp(-b*x), predvars = "x", parvars = c("a", "b"),
                    lx = 0, ux = 1, inipars = c(1, 10),
                    iter = 100,
                    x = c(.25, .5, .75),
                    ICA.control= ICA.control(rseed = 100))
  plot(res1.1)
  # we can not have an optimal design using this x

## End(Not run)

################################
## two parameter logistic model
################################
res2 &lt;- locally(formula = ~1/(1 + exp(-b *(x - a))),
                predvars = "x", parvars = c("a", "b"),
                family = binomial(), lx = -3, ux = 3,
                inipars = c(1, 3), iter = 1, k = 2,
                ICA.control= list(rseed = 100, stop_rule = "equivalence",
                                  checkfreq = 50, stoptol = .95))
## Not run: 
  res2 &lt;- update(res2, 100)
  # stops at iteration 51

## End(Not run)




################################
# A model with two predictors
################################
# mixed inhibition model
## Not run: 
  res3 &lt;- locally(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
                  predvars = c("S", "I"),
                  parvars = c("V", "Km", "Kic", "Kiu"),
                  family = gaussian(),
                  lx = c(0, 0), ux = c(30, 60),
                  k = 4,
                  iter = 300,
                  inipars = c(1.5, 5.2, 3.4, 5.6),
                  ICA.control= list(rseed = 100, stop_rule = "equivalence",
                                    checkfreq = 50, stoptol = .95))
  # stops at iteration 100

## End(Not run)


## Not run: 
  # fixed x
  res3.1 &lt;- locally(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
                    predvars = c("S", "I"),
                    parvars = c("V", "Km", "Kic", "Kiu"),
                    family = gaussian(),
                    lx = c(0, 0), ux = c(30, 60),
                    iter = 100,
                    x = c(20, 4, 20, 4, 10,  0, 0, 30, 3, 2),
                    inipars = c(1.5, 5.2, 3.4, 5.6),
                    ICA.control= list(rseed = 100))

## End(Not run)


###################################
# user-defined optimality criterion
##################################
# When the model is defined by the formula interface
# A-optimal design for the 2PL model.
# the criterion function must have argument x, w fimfunc and the parameters defined in 'parvars'.
# use 'fimfunc' as a function of the design points x,  design weights w and
#  the 'parvars' parameters whenever needed.
Aopt &lt;-function(x, w, a, b, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, a = a, b = b))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a  = a, b = b)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}

res4 &lt;- locally(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
                parvars = c("a", "b"), family = "binomial",
                lx = -3, ux = 3, inipars = c(1, 1.25),
                iter = 1, k = 2,
                crtfunc = Aopt,
                sensfunc = Aopt_sens,
                ICA.control = list(checkfreq = Inf))
## Not run: 
  res4 &lt;- update(res4, 50)

## End(Not run)

# When the FIM of the model is defined directly via the argument 'fimfunc'
# the criterion function must have argument x, w fimfunc and param.
# use 'fimfunc' as a function of the design points x,  design weights w
# and param whenever needed.
Aopt2 &lt;-function(x, w, param, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, param = param))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens2 &lt;- function(xi_x, x, w, param, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, param = param)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, param = param)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}

res4.1 &lt;- locally(fimfunc = FIM_logistic,
                  lx = -3, ux = 3, inipars = c(1, 1.25),
                  iter = 1, k = 2,
                  crtfunc = Aopt2,
                  sensfunc = Aopt_sens2,
                  ICA.control = list(checkfreq = Inf))
## Not run: 
  res4.1 &lt;- update(res4.1, 50)
  plot(res4.1)

## End(Not run)


# locally c-optimal design
# example from Chaloner and Larntz (1989) Figure 3
c_opt &lt;-function(x, w, a, b, fimfunc){
  gam &lt;- log(.95/(1-.95))
  M &lt;- fimfunc(x = x, w = w, a = a, b = b)
  c &lt;- matrix(c(1, -gam * b^(-2)), nrow = 1)
  B &lt;- t(c) %*% c
  sum(diag(B %*% solve(M)))
}

c_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  gam &lt;- log(.95/(1-.95))
  M &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(M)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a = a, b = b)
  c &lt;- matrix(c(1, -gam * b^(-2)), nrow = 1)
  B &lt;- t(c) %*% c
  sum(diag(B %*% M_inv %*% M_x %*%  M_inv)) - sum(diag(B %*% M_inv))
}


res4.2 &lt;- locally(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
                  parvars = c("a", "b"), family = "binomial",
                  lx = -1, ux = 1, inipars = c(0, 7),
                  iter = 1, k = 2,
                  crtfunc = c_opt, sensfunc = c_sens,
                  ICA.control = list(rseed = 1, checkfreq = Inf))
## Not run: 
res4.2 &lt;- update(res4.2, 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='locallycomp'>Locally DP-Optimal Designs</h2><span id='topic+locallycomp'></span>

<h3>Description</h3>

<p>Finds compound locally DP-optimal designs that meet the dual goal of parameter estimation and
increasing the probability of a particular outcome in a binary response model.
A compound locally DP-optimal design maximizes  the product of the efficiencies of a design <code class="reqn">\xi</code> with respect to D- and average P-optimality, weighted by a pre-defined mixing constant
<code class="reqn">0 \leq \alpha \leq 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locallycomp(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  lx,
  ux,
  alpha,
  prob,
  iter,
  k,
  inipars,
  fimfunc = NULL,
  ICA.control = list(),
  sens.control = list(),
  initial = NULL,
  npar = length(inipars),
  plot_3d = c("lattice", "rgl")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locallycomp_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_alpha">alpha</code></td>
<td>
<p>A value between 0 and 1.
Compound or combined DP-criterion  is the product of the efficiencies of a design  with respect to D- and average P- optimality, weighted by <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_prob">prob</code></td>
<td>
<p>Either <code>formula</code> or a <code>function</code>. When function, its argument are <code>x</code> and <code>param</code>, and they are the same as the arguments in <code>fimfunc</code>.
<code>prob</code> as a function takes the design points and vector of parameters and returns the probability of success at each design points.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_k">k</code></td>
<td>
<p>Number of design points. When <code>alpha = 0</code>, then <code>k</code> can be less than the number of parameters.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_inipars">inipars</code></td>
<td>
<p>Vector. Initial values for the unknown parameters. It will be passed to the information matrix and also probability function.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_ica.control">ICA.control</code></td>
<td>
<p>ICA control parameters. For details, see <code><a href="#topic+ICA.control">ICA.control</a></code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_initial">initial</code></td>
<td>
<p>A matrix of the  initial design points and weights that will be inserted into the initial solutions (countries) of the algorithm.
Every row is a design, i.e.  a concatenation of <code>x</code> and <code>w</code>. Will be coerced to a <code>matrix</code> if necessary.  See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis. When <code>NULL</code>, it will be set here to <code>length(inipars)</code>.</p>
</td></tr>
<tr><td><code id="locallycomp_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to <code>"lattice"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\Xi</code> be the space of all  approximate designs with
<code class="reqn">k</code> design points (support points) at <code class="reqn">x_1, x_2, ...,  x_k</code>
from  design space <code class="reqn">\chi</code> with
corresponding weights  <code class="reqn">w_1,... ,w_k</code>.
Let <code class="reqn">M(\xi, \theta)</code> be the Fisher information
matrix (FIM) of a <code class="reqn">k-</code>point design <code class="reqn">\xi</code>,
<code class="reqn">\theta_0</code> is a user-given vector of initial estimates for the  unknown parameters <code class="reqn">\theta</code> and
<code class="reqn">p(x_i, \theta)</code> is the ith probability of success
given by <code class="reqn">x_i</code> in a binary response model.
A compound locally DP-optimal design   maximizes over <code class="reqn">\Xi</code>
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\alpha}{q}\log|M(\xi, \theta_0)| + (1- \alpha)
\log \left( \sum_{i=1}^k w_ip(x_i, \theta_0) \right).</code>
</p>

<p>Use <code><a href="base.html#topic+plot">plot</a></code> function to verify the general equivalence theorem for the output design or change <code>checkfreq</code> in <code><a href="#topic+ICA.control">ICA.control</a></code>.
</p>
<p>One can adjust the tuning parameters in <code><a href="#topic+ICA.control">ICA.control</a></code> to set a stopping rule
based on the general equivalence theorem. See &quot;Examples&quot; in <code><a href="#topic+locally">locally</a></code>.
</p>


<h3>Value</h3>

<p>an object of class <code>minimax</code> that is a list including three sub-lists:
</p>

<dl>
<dt><code>arg</code></dt><dd><p>A list of design and algorithm parameters.</p>
</dd>
<dt><code>evol</code></dt><dd><p>A list of length equal to the number of iterations that stores
the information about the best design (design with least criterion value)
of each iteration. <code>evol[[iter]]</code> contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>iter</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> Iteration number.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>x</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design points. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>w</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design weights. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>min_cost</code>               </td><td style="text-align: left;">      </td><td style="text-align: left;"> Value of the criterion for the best imperialist (design).  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>mean_cost</code>              </td><td style="text-align: left;">      </td><td style="text-align: left;"> Mean of the criterion values of all the imperialists. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sens</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> An object of class <code>'sensminimax'</code>. See below. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>param</code>                  </td><td style="text-align: left;">      </td><td style="text-align: left;"> Vector of parameters.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>empires</code></dt><dd><p>A list of all the  empires of the last iteration.</p>
</dd>
<dt><code>alg</code></dt><dd><p>A list with following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>nfeval</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of function evaluations.  It does not count the function evaluations from checking the general equivalence theorem.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nlocal</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful local searches. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nrevol</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful revolutions. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nimprove</code>         </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful movements toward the imperialists in the assimilation step. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>convergence</code>      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Stopped by <code>'maxiter'</code> or <code>'equivalence'</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>method</code></dt><dd><p>A type of optimal designs used.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design points and weights at the final iteration.</p>
</dd>
<dt><code>out</code></dt><dd><p>A data frame of design points, weights, value of the criterion for the best imperialist (min_cost), and Mean of the criterion values of all the imperialistsat each iteration (mean_cost).</p>
</dd>
</dl>

<p>The list <code>sens</code> contains information about the design verification by the general equivalence theorem. See <code>sensminimax</code> for more details.
It is given  every <code>ICA.control$checkfreq</code> iterations
and also the last iteration if   <code>ICA.control$checkfreq &gt;= 0</code>. Otherwise, <code>NULL</code>.
</p>
<p><code>param</code> is a vector of parameters that is the global minimum of
the minimax criterion or the global maximum of the standardized maximin criterion over the parameter space, given  the current <code>x</code>, <code>w</code>.
</p>


<h3>References</h3>

<p>McGree, J. M., Eccleston, J. A., and Duffull, S. B. (2008). Compound optimal design criteria for nonlinear models. Journal of Biopharmaceutical Statistics, 18(4), 646-661.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Here we produce the results of Table 2 in in McGree and Eccleston (2008)
# For D- and P-efficiency see, ?leff and ?peff

p &lt;- c(1, -2, 1, -1)
prior4.4 &lt;- uniform(p -1.5, p + 1.5)
formula4.4 &lt;- ~exp(b0+b1*x1+b2*x2+b3*x1*x2)/(1+exp(b0+b1*x1+b2*x2+b3*x1*x2))
prob4.4 &lt;- ~1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2))
predvars4.4 &lt;-  c("x1", "x2")
parvars4.4 &lt;- c("b0", "b1", "b2", "b3")
lb &lt;- c(-1, -1)
ub &lt;- c(1, 1)


# set checkfreq = Inf to ask for equivalence theorem at final step.
res.0 &lt;- locallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                     family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                     alpha = 0, k = 1, inipars = p, iter = 10,
                     ICA.control = ICA.control(checkfreq = Inf))

## Not run: 
res.25 &lt;- locallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                      family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                      alpha = .25, k = 4, inipars = p, iter = 350,
                      ICA.control = ICA.control(checkfreq = Inf))

res.5 &lt;- locallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                     family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                     alpha = .5, k = 4, inipars = p, iter = 350,
                     ICA.control = ICA.control(checkfreq = Inf))
res.75 &lt;- locallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                      family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                      alpha = .75, k = 4, inipars = p, iter = 350,
                      ICA.control = ICA.control(checkfreq = Inf))

res.1 &lt;- locallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                     family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                     alpha = 1, k = 4, inipars = p, iter = 350,
                     ICA.control = ICA.control(checkfreq = Inf))

#### computing the D-efficiency
# locally D-optimal design is locally DP-optimal design when alpha = 1.

leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x1 = res.0$evol[[10]]$x, w1 = res.0$evol[[10]]$w,
     inipars = p,
     x2 = res.1$evol[[350]]$x, w2 = res.1$evol[[350]]$w)

leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x1 = res.25$evol[[350]]$x, w1 = res.25$evol[[350]]$w,
     inipars = p,
     x2 = res.1$evol[[350]]$x, w2 = res.1$evol[[350]]$w)

leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x1 = res.5$evol[[350]]$x, w1 = res.5$evol[[350]]$w,
     inipars = p,
     x2 = res.1$evol[[350]]$x, w2 = res.1$evol[[350]]$w)


leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x1 = res.75$evol[[350]]$x, w1 = res.75$evol[[350]]$w,
     inipars = p,
     x2 = res.1$evol[[350]]$x, w2 = res.1$evol[[350]]$w)



#### computing the P-efficiency
# locally p-optimal design is locally DP-optimal design when alpha = 0.

leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x2 = res.0$evol[[10]]$x, w2 = res.0$evol[[10]]$w,
     prob = prob4.4,
     type = "PA",
     inipars = p,
     x1 = res.25$evol[[350]]$x, w1 = res.25$evol[[350]]$w)

leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x2 = res.0$evol[[10]]$x, w2 = res.0$evol[[10]]$w,
     prob = prob4.4,
     inipars = p,
     type = "PA",
     x1 = res.5$evol[[350]]$x, w1 = res.5$evol[[350]]$w)

leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x2 = res.0$evol[[10]]$x, w2 = res.0$evol[[10]]$w,
     prob = prob4.4,
     inipars = p,
     type = "PA",
     x1 = res.75$evol[[350]]$x, w1 = res.75$evol[[350]]$w)


leff(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4, family = binomial(),
     x2 = res.0$evol[[10]]$x, w2 = res.1$evol[[10]]$w,
     prob = prob4.4,
     type = "PA",
     inipars = p,
     x1 = res.1$evol[[350]]$x, w1 = res.1$evol[[350]]$w)



## End(Not run)
</code></pre>

<hr>
<h2 id='meff'>Calculates Relative Efficiency for Minimax Optimal Designs</h2><span id='topic+meff'></span>

<h3>Description</h3>

<p>Given a parameter space for the unknown parameters, this function calculates the D-efficiency of a design <code class="reqn">\xi_1</code> with respect to a design <code class="reqn">\xi_2</code>.
Usually, <code class="reqn">\xi_2</code> is an  optimal design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meff(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  lp,
  up,
  fimfunc = NULL,
  x2,
  w2,
  x1,
  w1,
  standardized = FALSE,
  localdes = NULL,
  crt.minimax.control = list(),
  npar = length(lp)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meff_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="meff_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="meff_+3A_lp">lp</code></td>
<td>
<p>Vector of lower bounds for the model parameters. Should be in the same order as <code>parvars</code> or <code>param</code> in the argument <code>fimfunc</code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_up">up</code></td>
<td>
<p>Vector of upper bounds for the model parameters. Should be in the same order as <code>parvars</code> or <code>param</code> in the argument <code>fimfunc</code>.
When a parameter is known (has a fixed value), its associated lower and upper bound values  in <code>lp</code> and <code>up</code>  must be set equal.</p>
</td></tr>
<tr><td><code id="meff_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_x2">x2</code></td>
<td>
<p>Vector of design (support) points of the optimal design (<code class="reqn">\xi_2</code>). Similar to <code>x</code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_w2">w2</code></td>
<td>
<p>Vector of corresponding design weights for <code>x2</code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_x1">x1</code></td>
<td>
<p>Vector of design (support) points of <code class="reqn">\xi_1</code>. See 'Details' of <code><a href="#topic+leff">leff</a></code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_w1">w1</code></td>
<td>
<p>Vector of corresponding design weights for <code>x</code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_standardized">standardized</code></td>
<td>
<p>Maximin standardized design? When <code>standardized = TRUE</code>, the argument <code>localdes</code> must be given.
Defaults to <code>FALSE</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_localdes">localdes</code></td>
<td>
<p>A function that takes the parameter values  as inputs and returns the design points and weights of the locally optimal design.
Required when <code>standardized = "TRUE"</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_crt.minimax.control">crt.minimax.control</code></td>
<td>
<p>Control parameters to optimize the minimax or standardized maximin criterion at a given design over a <strong>continuous</strong> parameter space (when <code>n.grid = 0</code>).
For details, see the function <code><a href="#topic+crt.minimax.control">crt.minimax.control</a></code>.</p>
</td></tr>
<tr><td><code id="meff_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not specified truly, the sensitivity (derivative) plot may be shifted below the y-axis. When <code>NULL</code> (default), it is set to <code>length(lp)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Masoudi et al. (2017) for formula details.
</p>
<p>The argument  <code>x1</code> is the vector of design points.
For design points with more than one dimension (the models with more than one predictors),
it is a concatenation of the design points, but <strong>dimension-wise</strong>.
For example, let the model has three predictors   <code class="reqn">(I, S, Z)</code>.
Then,  a two-point optimal design has the following points:
<code class="reqn">\{\mbox{point1} = (I_1, S_1, Z_1), \mbox{point2} = (I_2, S_2, Z_2)\}</code>.
Then, the argument <code>x</code> is equal to
<code>x = c(I1, I2, S1, S2, Z1, Z2)</code>.
</p>


<h3>Value</h3>

<p>A value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Relative D-efficiency with respect to the minimax criterion
meff(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
     parvars = c("a", "b"), family = "binomial",
     lp = c(-3, .5), up = c(3, 2),
     x2 = c(-3, -1.608782, 0, 1.608782, 3),
     w2 = c(0.22291601, 0.26438449, 0.02539899, 0.26438449, 0.22291601),
     x1 = c(-1, 1), w1 = c(.5, .5))



# A function to calculate the locally D-optimal design for the 2PL model
Dopt_2pl &lt;- function(a, b){
  x &lt;- c(a + (1/b) * 1.5434046, a - (1/b) * 1.5434046)
  return(list(x = x, w = c(.5, .5)))
}
# Relative D-efficiency with respect to the standardized maximin criterion
meff (formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
      parvars = c("a", "b"), family = "binomial",
      lp = c(-3, .5), up = c(3, 2),
      x2 = c(-3, -1.611255, 0, 1.611255, 3),
      w2 = c(0.22167034, 0.26592974, 0.02479984, 0.26592974, 0.22167034),
      x1 = c(0, -1), w1 = c(.5, .5),
      standardized = TRUE,
      localdes = Dopt_2pl)


</code></pre>

<hr>
<h2 id='minimax'>Minimax and Standardized Maximin D-Optimal Designs</h2><span id='topic+minimax'></span>

<h3>Description</h3>

<p>Finds minimax and standardized maximin D-optimal designs for linear and nonlinear models.
It should be used when the user assumes the unknown parameters belong to a parameter region
<code class="reqn">\Theta</code>, which is called &ldquo;region of uncertainty&rdquo;,  and the
purpose is to protect the experiment from the worst case scenario
over <code class="reqn">\Theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimax(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  lx,
  ux,
  lp,
  up,
  iter,
  k,
  n.grid = 0,
  fimfunc = NULL,
  ICA.control = list(),
  sens.control = list(),
  sens.minimax.control = list(),
  crt.minimax.control = list(),
  standardized = FALSE,
  initial = NULL,
  localdes = NULL,
  npar = length(lp),
  plot_3d = c("lattice", "rgl"),
  x = NULL,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minimax_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="minimax_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="minimax_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_lp">lp</code></td>
<td>
<p>Vector of lower bounds for the model parameters. Should be in the same order as <code>parvars</code> or <code>param</code> in the argument <code>fimfunc</code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_up">up</code></td>
<td>
<p>Vector of upper bounds for the model parameters. Should be in the same order as <code>parvars</code> or <code>param</code> in the argument <code>fimfunc</code>.
When a parameter is known (has a fixed value), its associated lower and upper bound values  in <code>lp</code> and <code>up</code>  must be set equal.</p>
</td></tr>
<tr><td><code id="minimax_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="minimax_+3A_k">k</code></td>
<td>
<p>Number of design points. Must be at least equal to the number of model parameters to avoid singularity of the FIM.</p>
</td></tr>
<tr><td><code id="minimax_+3A_n.grid">n.grid</code></td>
<td>
<p>Only required when the parameter space is
going to be discretized.
The total number of grid points from the parameter space is <code>n.grid^p</code>.
When <code>n.grid &gt; 0</code>, optimal design protects the experimenter against the worst case scenario only over the grid points, and not over the continuous parameter space.
The resulting designs may not be globally optimal.
In some literature, this type of designs has been used as a compromise to
the minimax type designs to avoid continuous optimization problem over
the parameter space and simplify the minimax design problems.
Especially when the design criterion is convex with respect to the
given parameter space at every given design from the design space,
the obtained design may also be globally optimal (because the maximum of a convex function is attained on the bounds, and here, are included in the grid points).
See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_ica.control">ICA.control</code></td>
<td>
<p>ICA control parameters. For details, see <code><a href="#topic+ICA.control">ICA.control</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_sens.minimax.control">sens.minimax.control</code></td>
<td>
<p>Control parameters to construct the answering set required for verify the general equivalence theorem and calculating the ELB. For details, see the function <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_crt.minimax.control">crt.minimax.control</code></td>
<td>
<p>Control parameters to optimize the minimax or standardized maximin criterion at a given design over a <strong>continuous</strong> parameter space (when <code>n.grid = 0</code>).
For details, see the function <code><a href="#topic+crt.minimax.control">crt.minimax.control</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_standardized">standardized</code></td>
<td>
<p>Maximin standardized design? When <code>standardized = TRUE</code>, the argument <code>localdes</code> must be given.
Defaults to <code>FALSE</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_initial">initial</code></td>
<td>
<p>A matrix of the  initial design points and weights that will be inserted into the initial solutions (countries) of the algorithm.
Every row is a design, i.e.  a concatenation of <code>x</code> and <code>w</code>. Will be coerced to a <code>matrix</code> if necessary.  See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_localdes">localdes</code></td>
<td>
<p>A function that takes the parameter values  as inputs and returns the design points and weights of the locally optimal design.
Required when <code>standardized = "TRUE"</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not specified truly, the sensitivity (derivative) plot may be shifted below the y-axis. When <code>NULL</code> (default), it is set to <code>length(lp)</code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to <code>"lattice"</code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_x">x</code></td>
<td>
<p>A vector of candidate design (support) points.
When is not set to <code>NULL</code> (default),
the algorithm only finds the optimal weights for the candidate points in  <code>x</code>.
Should be set when the user has a finite number of candidate design points  and the purpose
is to find the optimal weight for each of them (when zero, they will be excluded from the design).
For design points with more than one dimension, see 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="minimax_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\Xi</code> be the space of all  approximate designs with
<code class="reqn">k</code> design points (support points) at <code class="reqn">x_1, x_2, ...,  x_k</code>
from  the design space <code class="reqn">\chi</code> with
corresponding weights  <code class="reqn">w_1, . . . ,w_k</code>.
Let <code class="reqn">M(\xi, \theta)</code> be the Fisher information
matrix (FIM) of a <code class="reqn">k-</code>point design <code class="reqn">\xi</code> and <code class="reqn">\theta</code> be the vector of
unknown parameters.
A  minimax D-optimal design <code class="reqn">\xi^*</code> minimizes over <code class="reqn">\Xi</code>
</p>
<p style="text-align: center;"><code class="reqn">\max_{\theta \in \Theta} -\log|M(\xi, \theta)|.</code>
</p>

<p>A standardized maximin D-optimal design <code class="reqn">\xi^*</code> maximizes over <code class="reqn">\Xi</code>
</p>
<p style="text-align: center;"><code class="reqn">\inf_{\theta \in \Theta} \left[\left(\frac{|M(\xi, \theta)|}{|M(\xi_{\theta}, \theta)|}\right)^\frac{1}{p}\right],</code>
</p>

<p>where <code class="reqn">p</code> is the number of model parameters and <code class="reqn">\xi_\theta</code> is the locally D-optimal design with respect to <code class="reqn">\theta</code>.<br />
</p>
<p>A minimax criterion (cost function or objective function) is evaluated at each design (decision variables) by maximizing the criterion over the parameter space.
We call the optimization problem over the parameter space as <em>inner optimization problem</em>.
Two different strategies may be
applied to solve the inner problem at a given design (design points and weights):
</p>

<ol>
<li> <p><strong>Continuous inner problem</strong>: we optimize the criterion
over a continuous parameter space using the function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.
In this case, the tuning parameters can be regulated
via the argument <code><a href="#topic+crt.minimax.control">crt.minimax.control</a></code>, when the most influential one
is <strong><code>maxeval</code></strong>.
</p>
</li>
<li>  <p><strong>Discrete inner problem</strong>: we map the parameter space to
the grid points and optimize the criterion over a discrete parameter space.
In this case, the number of grid points can be regulated via <code>n.grid</code>.
This strategy is quite efficient (ans fast) when  the maxima most likely attain the vertices of the continuous parameter space at any given design.
The output design here protects the experiment from the worst scenario
over the grid points.
</p>
</li></ol>

<p>The <code>formula</code> is used to automatically create the Fisher information matrix (FIM)
for a linear or nonlinear model provided that the distribution of the
response variable belongs to the natural exponential family.
Function <code>minimax</code> also provides an
option to assign a user-defined FIM directly via the argument  <code>fimfunc</code>.
In this case, the
argument <code>fimfunc</code> takes a <code>function</code> that has three arguments as follows:
</p>

<ol>
<li> <p><code>x</code> a vector of design points. For design points with more than one dimension,
it is a concatenation of the design points, but dimension-wise.
For example, let the model has three predictors   <code class="reqn">(I, S, Z)</code>.
Then,  a two-point design is of the format
<code class="reqn">\{\mbox{point1} = (I_1, S_1, Z_1), \mbox{point2} = (I_2, S_2, Z_2)\}</code>.
and the argument <code>x</code> is equivalent to
<code>x = c(I1, I2, S1, S2, Z1, Z2)</code>.
</p>
</li>
<li> <p><code>w</code> a vector that includes the design weights associated with <code>x</code>.
</p>
</li>
<li> <p><code>param</code> a vector of parameter values associated with <code>lp</code> and <code>up</code>.
</p>
</li></ol>

<p>The output must be the Fisher information matrix with number of rows equal to <code>length(param)</code>. See 'Examples'.
</p>
<p>Minimax optimal designs can have very different criterion values depending on the nominal set of parameter values.
Accordingly, it is desirable to standardize the criterion and control for the potentially widely varying magnitude of the criterion (Dette, 1997).
Evaluating a standardized maximin criterion requires knowing locally optimal designs.
We strongly advise setting <code>standardized = 'TRUE'</code> only when analytical solutions for the locally D-optimal designs is available.
In this case, for any initial estimate of the unknown parameters,
an analytical solution  for the locally optimal design, i.e, the support points <code>x</code>
and the corresponding weights <code>w</code>, must be provided via the argument <code>localdes</code>.
Therefore, depending on how the model is specified, <code>localdes</code> is a <code>function</code> with the following arguments (input).
</p>

<ul>
<li><p> If <code>formula</code> is given (<code>!missing(formula)</code>):
</p>

<ul>
<li><p> The parameter names given by <code>parvars</code> in the same order.
</p>
</li></ul>

</li>
<li><p> If FIM is given via the argument <code>fimfunc</code> (<code>missing(formula)</code>):
</p>

<ul>
<li> <p><code>param</code>: A vector of the parameters equal to the argument <code>param</code> in <code>fimfunc</code>.
</p>
</li></ul>

</li></ul>

<p>This function must return a list with the components <code>x</code> and <code>w</code> (they match the same arguments in the function <code>fimfunc</code>).
See 'Examples'.<br />
</p>
<p>The standardized D-criterion is equal to the  D-efficiency and it must be between 0 and 1.
However, in practice, when running the algorithm,  it may be the case that
the criterion takes a value larger than one.
This may happen  because the user-function that is  given via <code>localdes</code> does not
return the true (accurate) locally optimal designs for some
requested initial estimates of the parameters  from <code class="reqn">\Theta</code>.
In this case, the function <code>minimax</code>
throw an error where the error message helps the user
to debug her/his function.
</p>
<p>Each row of <code>initial</code> is one design, i.e. a concatenation of values for design (support) points  and the associated design weights.
Let <code>x0</code> and <code>w0</code> be the vector of initial values with exactly the same length and order as <code>x</code> and <code>w</code> (the arguments of <code>fimfunc</code>).
As an example, the first row  of the matrix <code>initial</code> is equal to <code>initial[1, ] = c(x0, w0)</code>.
For models with more than one predictors, <code>x0</code> is a concatenation of the initial values for design points, but <strong>dimension-wise</strong>.
See the details of the argument <code>fimfunc</code>, above.
</p>
<p>To verify the optimality of the output design by the general equivalence theorem,
the user can either <code>plot</code> the results or set  <code>checkfreq</code> in <code><a href="#topic+ICA.control">ICA.control</a></code>
to <code>Inf</code>. In either way, the function <code><a href="#topic+sensminimax">sensminimax</a></code> is called for verification.
Note that  the function <code><a href="#topic+sensminimax">sensminimax</a></code> always verifies the optimality of a design assuming a continues parameter space.
See 'Examples'.
</p>
<p><code>crtfunc</code> is a function that is used
to specify a new criterion.
Its arguments are:
</p>

<ul>
<li><p> design points <code>x</code> (as a <code>vector</code>).
</p>
</li>
<li><p> design weights <code>w</code> (as a <code>vector</code>).
</p>
</li>
<li><p> model parameters as follows.
</p>

<ul>
<li><p> If <code>formula</code> is specified:
they should be the same parameter specified by <code>parvars</code>.
</p>
</li>
<li><p> If FIM is specified via the argument <code>fimfunc</code>:
<code>param</code> that is a vector of the parameters in <code>fimfunc</code>.
</p>
</li></ul>

</li>
<li> <p><code>fimfunc</code> is a <code>function</code> that takes the other arguments of <code>crtfunc</code>
and returns the computed Fisher information matrix as a <code>matrix</code>.
</p>
</li></ul>

<p>The <code>crtfunc</code> function must return the criterion value.
<code>crtfunc</code>. It has one more argument than  <code>crtfunc</code>,
which is  <code>xi_x</code>. It denotes the design point of the degenerate design
and  must be a vector with the same length as the number of  predictors.
For more details, see 'Examples'.
</p>


<h3>Value</h3>

<p>an object of class <code>minimax</code> that is a list including three sub-lists:
</p>

<dl>
<dt><code>arg</code></dt><dd><p>A list of design and algorithm parameters.</p>
</dd>
<dt><code>evol</code></dt><dd><p>A list of length equal to the number of iterations that stores
the information about the best design (design with least criterion value)
of each iteration. <code>evol[[iter]]</code> contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>iter</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> Iteration number.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>x</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design points. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>w</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design weights. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>min_cost</code>               </td><td style="text-align: left;">      </td><td style="text-align: left;"> Value of the criterion for the best imperialist (design).  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>mean_cost</code>              </td><td style="text-align: left;">      </td><td style="text-align: left;"> Mean of the criterion values of all the imperialists. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sens</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> An object of class <code>'sensminimax'</code>. See below. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>param</code>                  </td><td style="text-align: left;">      </td><td style="text-align: left;"> Vector of parameters.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>empires</code></dt><dd><p>A list of all the  empires of the last iteration.</p>
</dd>
<dt><code>alg</code></dt><dd><p>A list with following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>nfeval</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of function evaluations.  It does not count the function evaluations from checking the general equivalence theorem.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nlocal</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful local searches. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nrevol</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful revolutions. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nimprove</code>         </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful movements toward the imperialists in the assimilation step. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>convergence</code>      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Stopped by <code>'maxiter'</code> or <code>'equivalence'</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>method</code></dt><dd><p>A type of optimal designs used.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design points and weights at the final iteration.</p>
</dd>
<dt><code>out</code></dt><dd><p>A data frame of design points, weights, value of the criterion for the best imperialist (min_cost), and Mean of the criterion values of all the imperialistsat each iteration (mean_cost).</p>
</dd>
</dl>

<p>The list <code>sens</code> contains information about the design verification by the general equivalence theorem. See <code>sensminimax</code> for more details.
It is given  every <code>ICA.control$checkfreq</code> iterations
and also the last iteration if   <code>ICA.control$checkfreq &gt;= 0</code>. Otherwise, <code>NULL</code>.
</p>
<p><code>param</code> is a vector of parameters that is the global minimum of
the minimax criterion or the global maximum of the standardized maximin criterion over the parameter space, given  the current <code>x</code>, <code>w</code>.
</p>


<h3>Note</h3>

<p>For larger parameter space or model with more number of unknown parameters,
it is always important to increase the value of  <code>ncount</code> in <code>ICA.control</code>
and <code>optslist$maxeval</code> in <code>crt.minimax.control</code> to produce very accurate designs.
</p>
<p>Although standardized criteria have been preferred theoretically,
in practice, they should be applied only
when  an analytical solution for
the locally D-optimal designs is available for the model
of interest.
Otherwise, we encounter a three-level nested-optimization algorithm, which is very slow.
</p>


<h3>References</h3>

<p>Atashpaz-Gargari, E, &amp; Lucas, C (2007). Imperialist competitive algorithm: an algorithm for optimization inspired by imperialistic competition. In 2007 IEEE congress on evolutionary computation (pp. 4661-4667). IEEE.<br />
Dette, H. (1997). Designing experiments with respect to 'standardized' optimality criteria. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 59(1), 97-110. <br />
Masoudi E, Holling H, Wong WK (2017). Application of Imperialist Competitive Algorithm to Find Minimax and Standardized Maximin Optimal Designs. Computational Statistics and Data Analysis, 113, 330-345. &lt;doi:10.1016/j.csda.2016.06.014&gt;<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensminimax">sensminimax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################
# Two-parameter exponential growth model
########################################
res1 &lt;- minimax (formula = ~a + exp(-b*x), predvars = "x", parvars = c("a", "b"),
                 lx = 0, ux = 1, lp = c(1, 1), up = c(1, 10),
                 iter = 1, k = 4,
                 ICA.control= ICA.control(rseed = 100),
                 crt.minimax.control = list(optslist = list(maxeval = 100)))
# The optimal design has 3 points, but we set k = 4 for illustration purpose to
#   show how the algorithm modifies the design by adjusting the weights
# The value of maxeval is changed to reduce the CPU time
## Not run: 
  res1 &lt;- update(res1, 150)
  # iterating the algorithm up to 150 more iterations

## End(Not run)

res1 # print method
plot(res1) # Veryfying the general equivalence theorem

## Not run: 
  ## fixed x
  res1.1 &lt;- minimax (formula = ~a + exp(-b*x), predvars = "x", parvars = c("a", "b"),
                     lx = 0, ux = 1, lp = c(1, 1), up = c(1, 10),
                     x = c(0, .5, 1),
                     iter = 150, k = 3, ICA.control= ICA.control(rseed = 100))
  # not optimal

## End(Not run)

########################################
# Two-parameter logistic model.
########################################
# A little playing with the tuning parameters
# The value of maxeval is reduced to 200 to increase the speed
cont1 &lt;- crt.minimax.control(optslist = list(maxeval = 200))
cont2 &lt;- ICA.control(rseed = 100, checkfreq = Inf, ncount = 60)

## Not run: 
  res2 &lt;- minimax (formula = ~1/(1 + exp(-b *(x - a))), predvars = "x",
                   parvars = c("a", "b"),
                   family = binomial(), lx = -3, ux = 3,
                   lp = c(0, 1), up = c(1, 2.5), iter = 200, k = 3,
                   ICA.control= cont2, crt.minimax.control = cont1)
  print(res2)
  plot(res2)

## End(Not run)

############################################
# An example of a model with two predictors
############################################
# Mixed inhibition model
lower &lt;- c(1, 4, 2, 4)
upper &lt;- c(1, 5, 3, 5)
cont &lt;- crt.minimax.control(optslist = list(maxeval = 100)) # to be faster
## Not run: 
  res3 &lt;- minimax(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
                  predvars = c("S", "I"),
                  parvars = c("V", "Km", "Kic", "Kiu"),
                  lx = c(0, 0), ux = c(30, 60), k = 4,
                  iter = 100, lp = lower, up = upper,
                  ICA.control= list(rseed = 100),
                  crt.minimax.control = cont)

  res3 &lt;- update(res3, 100)
  print(res3)
  plot(res3) # sensitivity plot
  res3$arg$time

## End(Not run)

# Now consider grid points instead of assuming continuous parameter space
# set n.grid to 5
## Not run: 
  res4 &lt;- minimax(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
                  predvars = c("S", "I"),
                  parvars = c("V", "Km", "Kic", "Kiu"),
                  lx = c(0, 0), ux = c(30, 60),
                  k = 4, iter = 130, n.grid = 5, lp = lower, up = upper,
                  ICA.control= list(rseed = 100, checkfreq = Inf),
                  crt.minimax.control = cont)
  print(res4)
  plot(res4) # sensitivity plot

## End(Not run)

############################################
# Standardized maximin D-optimal designs
############################################
# Assume the purpose is finding STANDARDIZED designs
# We know from literature that the locally D-optimal design (LDOD)
# for this model has an analytical solution.
# The follwoing function takes the parameter as input and returns
# the design points and weights of LDOD.
# x and w are exactly similar to the arguments of 'fimfunc'.
# x is a vector and returns the design points 'dimension-wise'.
# see explanation of the arguments of 'fimfunc' in 'Details'.

LDOD &lt;- function(V, Km, Kic, Kiu){
  #first dimention is for S and the second one is for I.
  S_min &lt;- 0
  S_max &lt;- 30
  I_min &lt;- 0
  I_max &lt;- 60
  s2 &lt;- max(S_min, S_max*Km*Kiu*(Kic+I_min)/
              (S_max*Kic*I_min+S_max*Kic*Kiu+2*Km*Kiu*I_min+2*Km*Kiu*Kic))
  i3 &lt;- min((2*S_max*Kic*I_min + S_max*Kic*Kiu+2*Km*Kiu*I_min+Km*Kiu*Kic)/
              (Km*Kiu+S_max*Kic), I_max)
  i4 &lt;- min(I_min + (sqrt((Kic+I_min)*(Km*Kic*Kiu+Km*Kiu*I_min+
                                         S_max*Kic*Kiu+S_max*Kic*I_min)/
                            (Km*Kiu+S_max*Kic))), I_max )
  s4 &lt;- max(-Km*Kiu*(Kic+2*I_min-i4)/(Kic*(Kiu+2*I_min-i4)), S_min)
  x &lt;- c(S_max, s2, S_max, s4, I_min, I_min, i3, i4)
  return(list(x = x, w =rep(1/4, 4)))

}
formalArgs(LDOD)
## Not run: 
  minimax(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
          predvars = c("S", "I"),
          parvars = c("V", "Km", "Kic", "Kiu"),
          lx = c(0, 0), ux = c(30, 60),
          k = 4, iter = 300,
          lp = lower, up = upper,
          ICA.control= list(rseed = 100, checkfreq = Inf),
          crt.minimax.control = cont,
          standardized = TRUE,
          localdes = LDOD)

## End(Not run)


################################################################
# Not necessary!
# The rest of the examples here are only for professional uses.
################################################################
# Imagine you have written your own FIM, say in Rcpp that is faster than
# the FIM created by the formula interface above.

###########################################
# An example of a model with two predictors
###########################################
# For example, th cpp FIM function for the mixed inhibition model is named:
formalArgs(FIM_mixed_inhibition)

# We should reparamterize the arguments to match the standard of the
# argument 'fimfunc' (see 'Details').
myfim &lt;- function(x, w, param){
  npoint &lt;- length(x)/2
  S &lt;- x[1:npoint]
  I &lt;- x[(npoint+1):(npoint*2)]
  out &lt;- FIM_mixed_inhibition(S = S, I = I, w = w, param = param)
  return(out)
}
formalArgs(myfim)

# Finds minimax optimal design, exactly as before, but NOT using the
# formula interface.
## Not run: 
  res5 &lt;- minimax(fimfunc = myfim,
                  lx = c(0, 0), ux = c(30, 60), k = 4,
                  iter = 100, lp = lower, up = upper,
                  ICA.control= list(rseed = 100),
                  crt.minimax.control = cont)
  print(res5)
  plot(res5) # sensitivity plot

## End(Not run)
#########################################
# Standardized maximin D-optimal designs
#########################################
# To match the argument 'localdes' when no formula inteface is used,
# we should reparameterize LDOD.
# The input must be 'param' same as the argument of 'fimfunc'
LDOD2 &lt;- function(param)
  LDOD(V = param[1], Km = param[2], Kic = param[3], Kiu = param[4])

# compare these two:
formalArgs(LDOD)
formalArgs(LDOD2)
## Not run: 
  res6 &lt;- minimax(fimfunc = myfim,
                  lx = c(0, 0), ux = c(30, 60), k = 4,
                  iter = 300, lp = lower, up = upper,
                  ICA.control= list(rseed = 100, checkfreq = Inf),
                  crt.minimax.control = cont,
                  standardized = TRUE,
                  localdes = LDOD2)
  res6
  plot(res6)

## End(Not run)

###################################
# user-defined optimality criterion
##################################
# When the model is defined by the formula interface
# A-optimal design for the 2PL model.
# the criterion function must have argument x, w fimfunc and the parameters defined in 'parvars'.
# use 'fimfunc' as a function of the design points x,  design weights w and
#  the 'parvars' parameters whenever needed.
Aopt &lt;-function(x, w, a, b, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, a = a, b = b))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a  = a, b = b)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}
## Not run: 
res7 &lt;- minimax(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
                parvars = c("a", "b"), family = "binomial",
                lx = -2, ux = 2,
                lp = c(-2, 1), up = c(2, 1.5),
                iter = 400, k = 3,
                crtfunc = Aopt,
                sensfunc = Aopt_sens,
                crt.minimax.control = list(optslist = list(maxeval = 200)),
                ICA.control = list(rseed = 1))
  plot(res7)

## End(Not run)
# with grid points
res7.1 &lt;- minimax(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
                  parvars = c("a", "b"), family = "binomial",
                  lx = -2, ux = 2,
                  lp = c(-2, 1), up = c(2, 1.5),
                  iter = 1, k = 3,
                  crtfunc = Aopt,
                  sensfunc = Aopt_sens,
                  n.grid = 9,
                  ICA.control = list(rseed = 1))
## Not run: 
  res7.1 &lt;- update(res7.1, 400)
  plot(res7.1)

## End(Not run)

# When the FIM of the model is defined directly via the argument 'fimfunc'
# the criterion function must have argument x, w fimfunc and param.
# use 'fimfunc' as a function of the design points x,  design weights w and
#  the 'parvars' parameters whenever needed.
Aopt2 &lt;-function(x, w, param, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, param = param))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens2 &lt;- function(xi_x, x, w, param, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, param = param)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, param = param)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}
## Not run: 
res7.2 &lt;- minimax(fimfunc = FIM_logistic,
                  lx = -2, ux = 2,
                  lp = c(-2, 1), up = c(2, 1.5),
                  iter = 1, k = 3,
                  crtfunc = Aopt2,
                  sensfunc = Aopt_sens2,
                  crt.minimax.control = list(optslist = list(maxeval = 200)),
                  ICA.control = list(rseed = 1))
  res7.2 &lt;- update(res7.2, 200)
  plot(res7.2)

## End(Not run)
# with grid points
res7.3 &lt;- minimax(fimfunc = FIM_logistic,
                  lx = -2, ux = 2,
                  lp = c(-2, 1), up = c(2, 1.5),
                  iter = 1, k = 3,
                  crtfunc = Aopt2,
                  sensfunc = Aopt_sens2,
                  n.grid = 9,
                  ICA.control = list(rseed = 1))
## Not run: 
  res7.3 &lt;- update(res7.2, 200)
  plot(res7.3)

## End(Not run)


# robust c-optimal design
# example from Chaloner and Larntz (1989), Figure 3, but robust design
c_opt &lt;-function(x, w, a, b, fimfunc){
  gam &lt;- log(.95/(1-.95))
  M &lt;- fimfunc(x = x, w = w, a = a, b = b)
  c &lt;- matrix(c(1, -gam * b^(-2)), nrow = 1)
  B &lt;- t(c) %*% c
  sum(diag(B %*% solve(M)))
}

c_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  gam &lt;- log(.95/(1-.95))
  M &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(M)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a = a, b = b)
  c &lt;- matrix(c(1, -gam * b^(-2)), nrow = 1)
  B &lt;- t(c) %*% c
  sum(diag(B %*% M_inv %*% M_x %*%  M_inv)) - sum(diag(B %*% M_inv))
}

## Not run: 
res8 &lt;- minimax(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
                parvars = c("a", "b"), family = "binomial",
                lx = -1, ux = 1,
                lp = c(-.3, 6), up = c(.3, 8),
                iter = 500, k = 3,
                crtfunc = c_opt, sensfunc = c_sens,
                ICA.control = list(rseed = 1, ncount = 100),
                n.grid = 12)
  plot(res8)

## End(Not run)



</code></pre>

<hr>
<h2 id='multiple'>Locally Multiple Objective Optimal Designs for the 4-Parameter Hill Model</h2><span id='topic+multiple'></span>

<h3>Description</h3>

<p>The 4-parameter Hill model is of the form
</p>
<p style="text-align: center;"><code class="reqn">f(D) = c + \frac{(d-c)(\frac{D}{a})^b}{1+(\frac{D}{a})^b} + \epsilon,</code>
</p>

<p>where <code class="reqn">\epsilon \sim N(0, \sigma^2)</code>,
<code class="reqn">D</code> is the dose level and the predictor,
<code class="reqn">a</code> is the ED50,
<code class="reqn">d</code> is the upper limit of response,
<code class="reqn">c</code> is the lower limit of response and
<code class="reqn">b</code> denotes the Hill constant that
control the flexibility in the slope of the response curve.<br />
Sometimes, the Hill model is re-parameterized and written as
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\theta_1}{1 + exp(\theta_2 x + \theta_3)} + \theta_4,</code>
</p>

<p>where <code class="reqn">\theta_1 = d - c</code>, <code class="reqn">\theta_2 = - b</code>,
<code class="reqn">\theta_3 = b\log(a)</code>, <code class="reqn">\theta_4 = c</code>, <code class="reqn">\theta_1 &gt; 0</code>,
<code class="reqn">\theta_2 \neq 0</code>, and <code class="reqn">-\infty &lt; ED50 &lt; \infty</code>,
where <code class="reqn">x = log(D) \in [-M, M]</code>
for some sufficiently large value of <code class="reqn">M</code>.
The new form is sometimes called  4-parameter logistic model.<br />
The function <code>multiple</code> finds locally multiple-objective optimal designs for estimating the model parameters, the ED50, and the MED, simultaneously.
For more details, see Hyun and  Wong (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple(
  minDose,
  maxDose,
  iter,
  k,
  inipars,
  Hill_par = TRUE,
  delta,
  lambda,
  fimfunc = NULL,
  ICA.control = list(),
  sens.control = list(),
  initial = NULL,
  tol = sqrt(.Machine$double.xmin),
  x = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiple_+3A_mindose">minDose</code></td>
<td>
<p>Minimum dose <code class="reqn">D</code>. For the 4-parameter logistic model, i.e. when <code>Hill_par = FALSE</code>, it is the minimum of <code class="reqn">log(D)</code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_maxdose">maxDose</code></td>
<td>
<p>Maximum dose <code class="reqn">D</code>. For the 4-parameter logistic model, i.e. when <code>Hill_par = FALSE</code>, it is the maximum of <code class="reqn">log(D)</code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="multiple_+3A_k">k</code></td>
<td>
<p>Number of design points. Must be at least equal to the number of model parameters to avoid singularity of the FIM.</p>
</td></tr>
<tr><td><code id="multiple_+3A_inipars">inipars</code></td>
<td>
<p>A vector of initial estimates for the vector of parameters  <code class="reqn">(a, b, c, d)</code>.
For the 4-parameter logistic model, i.e. when <code>Hill_par = FALSE</code>,
it is  a vector of initial estimates for <code class="reqn">(\theta_1, \theta_2,\theta_3, \theta_4)</code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_hill_par">Hill_par</code></td>
<td>
<p>Hill model parameterization? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_delta">delta</code></td>
<td>
<p>Predetermined meaningful value of the minimum effective dose MED.
When <code class="reqn">\delta &lt; 0 </code>, then <code class="reqn">\theta_2 &gt; 0</code> or when <code class="reqn">\delta &gt; 0</code>, then <code class="reqn">\theta_2 &lt; 0</code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_lambda">lambda</code></td>
<td>
<p>A vector of relative importance of each of the three criteria,
i.e. <code class="reqn">\lambda = (\lambda_1, \lambda_2, \lambda_3)</code>.
Here <code class="reqn">0 &lt; \lambda_i &lt; 1</code> and  s <code class="reqn">\sum \lambda_i = 1</code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_ica.control">ICA.control</code></td>
<td>
<p>ICA control parameters. For details, see <code><a href="#topic+ICA.control">ICA.control</a></code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_initial">initial</code></td>
<td>
<p>A matrix of the  initial design points and weights that will be inserted into the initial solutions (countries) of the algorithm.
Every row is a design, i.e.  a concatenation of <code>x</code> and <code>w</code>. Will be coerced to a <code>matrix</code> if necessary.  See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_tol">tol</code></td>
<td>
<p>Tolerance for finding the general inverse of the Fisher information matrix. Defaults to <code>.Machine$double.xmin</code>.</p>
</td></tr>
<tr><td><code id="multiple_+3A_x">x</code></td>
<td>
<p>A vector of candidate design (support) points.
When is not set to <code>NULL</code> (default),
the algorithm only finds the optimal weights for the candidate points in  <code>x</code>.
Should be set when the user has a finite number of candidate design points  and the purpose
is to find the optimal weight for each of them (when zero, they will be excluded from the design).
For design points with more than one dimension, see 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code class="reqn">\lambda_1 &gt; 0</code>, then the number of support points <code>k</code>
must at least be four to avoid singularity of the Fisher information matrix.
</p>
<p>One can adjust the tuning parameters in <code><a href="#topic+ICA.control">ICA.control</a></code> to set a stopping rule
based on the general equivalence theorem. See 'Examples' below.
</p>


<h3>Value</h3>

<p>an object of class <code>minimax</code> that is a list including three sub-lists:
</p>

<dl>
<dt><code>arg</code></dt><dd><p>A list of design and algorithm parameters.</p>
</dd>
<dt><code>evol</code></dt><dd><p>A list of length equal to the number of iterations that stores
the information about the best design (design with least criterion value)
of each iteration. <code>evol[[iter]]</code> contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>iter</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> Iteration number.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>x</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design points. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>w</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design weights. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>min_cost</code>               </td><td style="text-align: left;">      </td><td style="text-align: left;"> Value of the criterion for the best imperialist (design).  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>mean_cost</code>              </td><td style="text-align: left;">      </td><td style="text-align: left;"> Mean of the criterion values of all the imperialists. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sens</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> An object of class <code>'sensminimax'</code>. See below. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>param</code>                  </td><td style="text-align: left;">      </td><td style="text-align: left;"> Vector of parameters.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>empires</code></dt><dd><p>A list of all the  empires of the last iteration.</p>
</dd>
<dt><code>alg</code></dt><dd><p>A list with following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>nfeval</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of function evaluations.  It does not count the function evaluations from checking the general equivalence theorem.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nlocal</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful local searches. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nrevol</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful revolutions. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nimprove</code>         </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful movements toward the imperialists in the assimilation step. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>convergence</code>      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Stopped by <code>'maxiter'</code> or <code>'equivalence'</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>method</code></dt><dd><p>A type of optimal designs used.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design points and weights at the final iteration.</p>
</dd>
<dt><code>out</code></dt><dd><p>A data frame of design points, weights, value of the criterion for the best imperialist (min_cost), and Mean of the criterion values of all the imperialistsat each iteration (mean_cost).</p>
</dd>
</dl>

<p>The list <code>sens</code> contains information about the design verification by the general equivalence theorem. See <code>sensminimax</code> for more details.
It is given  every <code>ICA.control$checkfreq</code> iterations
and also the last iteration if   <code>ICA.control$checkfreq &gt;= 0</code>. Otherwise, <code>NULL</code>.
</p>
<p><code>param</code> is a vector of parameters that is the global minimum of
the minimax criterion or the global maximum of the standardized maximin criterion over the parameter space, given  the current <code>x</code>, <code>w</code>.
</p>


<h3>Note</h3>

<p>This function is NOT appropriate for  finding  c-optimal designs for estimating 'MED' or 'ED50' (single objective optimal designs)
and  the results may not be stable.
The reason is that for the c-optimal criterion
the generalized inverse of the Fisher information matrix
is not stable and depends
on the tolerance value (<code>tol</code>).
</p>


<h3>References</h3>

<p>Hyun, S. W., and Wong, W. K. (2015). Multiple-Objective Optimal Designs for Studying the Dose Response Function and Interesting Dose Levels. The international journal of biostatistics, 11(2), 253-271.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensmultiple">sensmultiple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All the examples are available in Hyun and Wong (2015)

#################################
#  4-parameter logistic model
# Example 1, Table 3
#################################
lam &lt;- c(0.05, 0.05, .90)
# Initial estimates are derived from Table 1
# See how the stopping rules are set via 'stop_rul', checkfreq' and 'stoptol'
Theta1 &lt;- c(1.563, 1.790, 8.442, 0.137)
res1 &lt;- multiple(minDose = log(.001), maxDose = log(1000),
                 inipars = Theta1, k = 4, lambda = lam, delta = -1,
                 Hill_par = FALSE,
                 iter = 1,
                 ICA.control = list(rseed = 1366, ncount = 100,
                                    stop_rule = "equivalence",
                                    checkfreq = 100, stoptol = .95))
## Not run: 
res1 &lt;- update(res1, 1000)
# stops at iteration 101

## End(Not run)

#################################
#  4-parameter Hill model
#################################
## initial estimates for the parameters of Hill model:
a &lt;- 0.008949  # ED50
b &lt;- -1.79 # Hill constant
c &lt;- 0.137 # lower limit
d &lt;- 1.7 # upper limit
# D belongs to c(.001, 1000) ## dose in mg
## the vector of Hill parameters are now c(a, b, c, d)
## Not run: 
res2 &lt;- multiple(minDose = .001, maxDose = 1000,
                 inipars =  c(a, b, c, d),
                 Hill_par = TRUE, k = 4, lambda = lam,
                 delta = -1, iter = 1000,
                 ICA.control = list(rseed = 1366, ncount = 100,
                                    stop_rule = "equivalence",
                                    checkfreq = 100, stoptol = .95))
# stops at iteration 100

## End(Not run)



# use x argument to provide fix number of  dose levels.
# In this case, the optimization is only over weights
## Not run: 
res3 &lt;- multiple(minDose = log(.001), maxDose = log(1000),
                 inipars = Theta1, k = 4, lambda = lam, delta = -1,
                 iter = 300,
                 Hill_par = FALSE,
                 x = c(-6.90, -4.66, -3.93, 3.61),
                 ICA.control = list(rseed = 1366))
res3$evol[[300]]$w
# if the user provide the desugn points via x, there is no guarantee
#   that the resulted design is optimal. It only provides the optimal weights given
#   the x points of the design.
plot(res3)

## End(Not run)

</code></pre>

<hr>
<h2 id='normal'>Assumes A Multivariate Normal Prior Distribution for The Model Parameters</h2><span id='topic+normal'></span>

<h3>Description</h3>

<p>Creates a multivariate normal prior distribution for the unknown parameters as an object of class <code>cprior</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal(mu, sigma, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal_+3A_mu">mu</code></td>
<td>
<p>A vector representing the mean values.</p>
</td></tr>
<tr><td><code id="normal_+3A_sigma">sigma</code></td>
<td>
<p>A symmetric positive-definite matrix representing the variance-covariance matrix of the distribution.</p>
</td></tr>
<tr><td><code id="normal_+3A_lower">lower</code></td>
<td>
<p>A vector of lower bounds  for the model parameters.</p>
</td></tr>
<tr><td><code id="normal_+3A_upper">upper</code></td>
<td>
<p>A vector of upper bounds  for the model parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cprior</code> that is a  list with the following components:
</p>

<ul>
<li><p><code>fn</code>: prior distribution as an R <code>function</code> with argument <code>param</code> that is the vector of the unknown parameters. See below.
</p>
</li>
<li><p><code>npar</code>: Number of unknown parameters and is equal to the length of <code>param</code>.
</p>
</li>
<li><p><code>lower</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li>
<li><p><code>upper</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li></ul>

<p>The list will be passed to the argument <code>prior</code> of the function <code><a href="#topic+bayes">bayes</a></code>.
The order of the argument <code>param</code> in <code>fn</code> has the same order as the argument <code>parvars</code> when the model is specified by a formula.
Otherwise, it is equal to the argument <code>param</code> in the function <code>fimfunc</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes">bayes</a></code> <code><a href="#topic+sensbayes">sensbayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal(mu =  c(0, 1), sigma = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
  lower =  c(-3, .1), upper = c(3, 2))
</code></pre>

<hr>
<h2 id='plot.minimax'>Plotting <code>minimax</code> Objects</h2><span id='topic+plot.minimax'></span>

<h3>Description</h3>

<p>This function plots the evolution of the ICA algorithm (iteration vs the best (minimum) criterion value at each iteration) and also verifies the optimality of the last obtained design
using  the general equivalence theorem. It plots the sensitivity function and calculates the ELB for the  best design generated at iteration number  <code>iter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'minimax'
plot(
  x,
  iter = NULL,
  sensitivity = TRUE,
  calculate_criterion = FALSE,
  sens.minimax.control = list(),
  crt.minimax.control = list(),
  sens.bayes.control = list(),
  crt.bayes.control = list(),
  sens.control = list(),
  silent = TRUE,
  plot_3d = c("lattice", "rgl"),
  evolution = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.minimax_+3A_x">x</code></td>
<td>
<p>An object of class <code>minimax</code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_iter">iter</code></td>
<td>
<p>Iteration number. if <code>NULL</code> (default), it will be set to the last iteration.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_sensitivity">sensitivity</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the general equivalence theorem is used to check the optimality if the best design in iteration number <code>iter</code> and the sensitivity function will be plotted.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Logical. Re-calculate the criterion value (maybe with a set of new tuning parameters to be sure of the globality of the maximum over the parameter space given the design)? It only assumes a continuous parameter space for the minimax and standardized maximin designs.  Defaults to <code>FALSE</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_sens.minimax.control">sens.minimax.control</code></td>
<td>
<p>Control parameters to verify general equivalence theorem. For details, see <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
If <code>NULL</code> (default), it will be set to the  tuning parameters used to create object <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_crt.minimax.control">crt.minimax.control</code></td>
<td>
<p>Control parameters to optimize the minimax or standardized maximin criterion at a given design over a <strong>continuous</strong> parameter space.
For details, see <code><a href="#topic+crt.minimax.control">crt.minimax.control</a></code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_sens.bayes.control">sens.bayes.control</code></td>
<td>
<p>Control parameters to verify general equivalence theorem for the Bayesian optimal designs. For details, see <code><a href="#topic+sens.bayes.control">sens.bayes.control</a></code>. If <code>NULL</code> (default), it will be set to the  tuning parameters used to create object <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_crt.bayes.control">crt.bayes.control</code></td>
<td>
<p>Control parameters to optimize the integration in the Bayesian criterion at a given design over a <strong>continuous</strong> parameter space. For details, see <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>. If <code>NULL</code> (default), it will be set to the  tuning parameters used to create object <code>x</code>.
If <code>NULL</code> (default), it will be set to the  tuning parameters used to create object <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see the function <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity function for two-dimensional design space. Defaults to <code>plot_3d = "lattice"</code>.
Only applicable when <code>sensitivity = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_evolution">evolution</code></td>
<td>
<p>Plot Evolution? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.minimax_+3A_...">...</code></td>
<td>
<p>Argument with no further use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to verifying the general equivalence theorem,
this function makes it possible to re-calculated the criterion value
for the output designs using a new set of tuning parameters, especially,
a large value for <code>maxeval</code> in the function <code><a href="#topic+crt.minimax.control">crt.minimax.control</a></code>.
This is useful for  minimax and standardized maximin optimal designs to assess
the robustness of the
criterion value with respect to different values of <code>maxeval</code>.
To put it simple, for these designs, the user can re-calculate the
criterion value (finds the global maximum over the parameter space given an output design in a minimax problem)
with larger values for  <code>maxeval</code> in <code><a href="#topic+crt.minimax.control">crt.minimax.control</a></code>
to be sure that the function <code>nloptr</code> finds global optima of the inner
optimization problem over the parameter space using the default value
(or the user-given value) of <code>maxeval</code>.
If increasing the value of <code>maxeval</code> returns different criterion values,
then the results can not be trusted and the algorithm should be repeated with a higher value for <code>maxeval</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minimax">minimax</a></code>, <code><a href="#topic+locally">locally</a></code>, <code><a href="#topic+robust">robust</a></code>
</p>

<hr>
<h2 id='print.minimax'>Printing <code>minimax</code> Objects</h2><span id='topic+print.minimax'></span>

<h3>Description</h3>

<p>Print method for an object of class <code>minimax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'minimax'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.minimax_+3A_x">x</code></td>
<td>
<p>An object of class <code>minimax</code>.</p>
</td></tr>
<tr><td><code id="print.minimax_+3A_...">...</code></td>
<td>
<p>Argument with no further use.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+minimax">minimax</a></code>, <code><a href="#topic+locally">locally</a></code>, <code><a href="#topic+robust">robust</a></code>, <code><a href="#topic+bayes">bayes</a></code>
</p>

<hr>
<h2 id='print.sensminimax'>Printing <code>sensminimax</code> Objects</h2><span id='topic+print.sensminimax'></span>

<h3>Description</h3>

<p>Print method for an object of class <code>sensminimax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sensminimax'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sensminimax_+3A_x">x</code></td>
<td>
<p>An object of class <code>sensminimax</code>.</p>
</td></tr>
<tr><td><code id="print.sensminimax_+3A_...">...</code></td>
<td>
<p>Argument with no further use.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sensminimax">sensminimax</a></code>, <code><a href="#topic+senslocally">senslocally</a></code>, <code><a href="#topic+sensrobust">sensrobust</a></code>
</p>

<hr>
<h2 id='robust'>Robust D-Optimal Designs</h2><span id='topic+robust'></span>

<h3>Description</h3>

<p>Finds Robust designs or optimal  in-average designs for linear and nonlinear models.
It is useful when a set of different vectors of initial estimates
along with a discrete probability measure
are available for the unknown model parameters.
It is a discrete version of <code><a href="#topic+bayes">bayes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  lx,
  ux,
  iter,
  k,
  prob,
  parset,
  fimfunc = NULL,
  ICA.control = list(),
  sens.control = list(),
  initial = NULL,
  npar = dim(parset)[2],
  plot_3d = c("lattice", "rgl"),
  x = NULL,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="robust_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="robust_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="robust_+3A_k">k</code></td>
<td>
<p>Number of design points. Must be at least equal to the number of model parameters to avoid singularity of the FIM.</p>
</td></tr>
<tr><td><code id="robust_+3A_prob">prob</code></td>
<td>
<p>A vector of the probability measure <code class="reqn">\pi</code> associated with each row of <code>parset</code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_parset">parset</code></td>
<td>
<p>A matrix that provides the vector of initial estimates for the model parameters, i.e. support of <code class="reqn">\pi</code>.
Every row is one vector  (<code>nrow(parset) == length(prob)</code>). See 'Details'.</p>
</td></tr>
<tr><td><code id="robust_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_ica.control">ICA.control</code></td>
<td>
<p>ICA control parameters. For details, see <code><a href="#topic+ICA.control">ICA.control</a></code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_initial">initial</code></td>
<td>
<p>A matrix of the  initial design points and weights that will be inserted into the initial solutions (countries) of the algorithm.
Every row is a design, i.e.  a concatenation of <code>x</code> and <code>w</code>. Will be coerced to a <code>matrix</code> if necessary.  See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis.
When <code>NULL</code>, it is set to <code>dim(parset)[2]</code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for models with two predictors.
Either <code>"rgl"</code> or <code>"lattice"</code> (default).</p>
</td></tr>
<tr><td><code id="robust_+3A_x">x</code></td>
<td>
<p>Vector of the design (support) points. See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code> for models with more than one predictors.</p>
</td></tr>
<tr><td><code id="robust_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\Theta</code> be a set of initial estimates for the unknown parameters.
A robust criterion is evaluated at the elements of <code class="reqn">\Theta</code> weighted by a probability measure
<code class="reqn">\pi</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">B(\xi, \pi) = \int_{\Theta}|M(\xi, \theta)|\pi(\theta) d\theta.</code>
</p>

<p>A robust design <code class="reqn">\xi^*</code>   maximizes <code class="reqn">B(\xi, \pi)</code> over the space of all designs.
</p>
<p>When the model is given via <code>formula</code>,
columns of <code>parset</code> must match the parameters introduced
in <code>parvars</code>.
Otherwise, when the model is introduced via <code>fimfunc</code>,
columns of <code>parset</code> must match the argument <code>param</code> in <code>fimfunc</code>.
</p>
<p>To verify the optimality of the output design by the general equivalence theorem,
the user can either <code>plot</code> the results or set  <code>checkfreq</code> in <code><a href="#topic+ICA.control">ICA.control</a></code>
to <code>Inf</code>. In either way, the function <code><a href="#topic+sensrobust">sensrobust</a></code> is called for verification.
One can also adjust the tuning parameters in <code><a href="#topic+ICA.control">ICA.control</a></code> to set a stopping rule
based on the general equivalence theorem. See 'Examples' below.
</p>


<h3>Value</h3>

<p>an object of class <code>minimax</code> that is a list including three sub-lists:
</p>

<dl>
<dt><code>arg</code></dt><dd><p>A list of design and algorithm parameters.</p>
</dd>
<dt><code>evol</code></dt><dd><p>A list of length equal to the number of iterations that stores
the information about the best design (design with least criterion value)
of each iteration. <code>evol[[iter]]</code> contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>iter</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> Iteration number.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>x</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design points. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>w</code>                      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Design weights. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>min_cost</code>               </td><td style="text-align: left;">      </td><td style="text-align: left;"> Value of the criterion for the best imperialist (design).  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>mean_cost</code>              </td><td style="text-align: left;">      </td><td style="text-align: left;"> Mean of the criterion values of all the imperialists. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sens</code>                   </td><td style="text-align: left;">      </td><td style="text-align: left;"> An object of class <code>'sensminimax'</code>. See below. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>param</code>                  </td><td style="text-align: left;">      </td><td style="text-align: left;"> Vector of parameters.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>empires</code></dt><dd><p>A list of all the  empires of the last iteration.</p>
</dd>
<dt><code>alg</code></dt><dd><p>A list with following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>nfeval</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of function evaluations.  It does not count the function evaluations from checking the general equivalence theorem.</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nlocal</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful local searches. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nrevol</code>           </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful revolutions. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>nimprove</code>         </td><td style="text-align: left;">      </td><td style="text-align: left;"> Number of successful movements toward the imperialists in the assimilation step. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>convergence</code>      </td><td style="text-align: left;">      </td><td style="text-align: left;"> Stopped by <code>'maxiter'</code> or <code>'equivalence'</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</dd>
<dt><code>method</code></dt><dd><p>A type of optimal designs used.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design points and weights at the final iteration.</p>
</dd>
<dt><code>out</code></dt><dd><p>A data frame of design points, weights, value of the criterion for the best imperialist (min_cost), and Mean of the criterion values of all the imperialistsat each iteration (mean_cost).</p>
</dd>
</dl>

<p>The list <code>sens</code> contains information about the design verification by the general equivalence theorem. See <code>sensminimax</code> for more details.
It is given  every <code>ICA.control$checkfreq</code> iterations
and also the last iteration if   <code>ICA.control$checkfreq &gt;= 0</code>. Otherwise, <code>NULL</code>.
</p>
<p><code>param</code> is a vector of parameters that is the global minimum of
the minimax criterion or the global maximum of the standardized maximin criterion over the parameter space, given  the current <code>x</code>, <code>w</code>.
</p>


<h3>Note</h3>

<p>When a continuous prior distribution for the unknown model parameters is available,  use <code><a href="#topic+bayes">bayes</a></code>.
When only one initial estimates of the unknown model parameters is available (<code class="reqn">\Theta</code> has only one element),  use  <code><a href="#topic+locally">locally</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes">bayes</a></code> <code><a href="#topic+sensrobust">sensrobust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Finding a robust design for the two-parameter logistic model
# See how we set a stopping rule.
# The ELB is computed every checkfreq = 30 iterations
# The optimization stops when the ELB is larger than stoptol = .95
res1 &lt;- robust(formula = ~1/(1 + exp(-b *(x - a))),
               predvars = c("x"), parvars = c("a", "b"),
               family = binomial(),
               lx = -5, ux = 5, prob = rep(1/4, 4),
               parset = matrix(c(0.5, 1.5, 0.5, 1.5, 4.0, 4.0, 5.0, 5.0), 4, 2),
               iter = 1, k =3,
               ICA.control = list(stop_rule = "equivalence",
                                  stoptol = .95, checkfreq = 30))

## Not run: 
  res1 &lt;- update(res1, 100)
  # stops at iteration 51

## End(Not run)


## Not run: 
  res1.1 &lt;- robust(formula = ~1/(1 + exp(-b *(x - a))),
                   predvars = c("x"), parvars = c("a", "b"),
                   family = binomial(),
                   lx = -5, ux = 5, prob = rep(1/4, 4),
                   parset = matrix(c(0.5, 1.5, 0.5, 1.5, 4.0, 4.0, 5.0, 5.0), 4, 2),
                   x = c(-3, 0, 3),
                   iter = 150, k =3)
  plot(res1.1)
  # not optimal

## End(Not run)


###################################
# user-defined optimality criterion
##################################
# When the model is defined by the formula interface
# A-optimal design for the 2PL model.
# the criterion function must have argument x, w fimfunc and the parameters defined in 'parvars'.
# use 'fimfunc' as a function of the design points x,  design weights w and
#  the 'parvars' parameters whenever needed.
Aopt &lt;-function(x, w, a, b, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, a = a, b = b))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a  = a, b = b)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}

res2 &lt;- robust(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
               parvars = c("a", "b"), family = "binomial",
               lx = -3, ux = 3,
               iter = 1, k = 4,
               crtfunc = Aopt,
               sensfunc = Aopt_sens,
               prob = c(.25, .5, .25),
               parset = matrix(c(-2, 0, 2, 1.25, 1.25, 1.25), 3, 2),
               ICA.control = list(checkfreq = 50, stoptol = .999,
                                  stop_rule = "equivalence",
                                  rseed = 1))
## Not run: 
  res2 &lt;- update(res2, 500)

## End(Not run)





# robust c-optimal design
# example from Chaloner and Larntz (1989), Figure 3, but robust design
c_opt &lt;-function(x, w, a, b, fimfunc){
  gam &lt;- log(.95/(1-.95))
  M &lt;- fimfunc(x = x, w = w, a = a, b = b)
  c &lt;- matrix(c(1, -gam * b^(-2)), nrow = 1)
  B &lt;- t(c) %*% c
  sum(diag(B %*% solve(M)))
}

c_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  gam &lt;- log(.95/(1-.95))
  M &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(M)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a = a, b = b)
  c &lt;- matrix(c(1, -gam * b^(-2)), nrow = 1)
  B &lt;- t(c) %*% c
  sum(diag(B %*% M_inv %*% M_x %*%  M_inv)) - sum(diag(B %*% M_inv))
}


res3 &lt;- robust(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
               parvars = c("a", "b"), family = "binomial",
               lx = -1, ux = 1,
               parset = matrix(c(0, 7, .2, 6.5), 2, 2, byrow = TRUE),
               prob = c(.5, .5),
               iter = 1, k = 3,
               crtfunc = c_opt, sensfunc = c_sens,
               ICA.control = list(rseed = 1, checkfreq = Inf))

## Not run: 
  res3 &lt;- update(res3, 300)

## End(Not run)

</code></pre>

<hr>
<h2 id='sens.bayes.control'>Returns Control Parameters for Approximating The Integrals In The Bayesian Sensitivity Functions</h2><span id='topic+sens.bayes.control'></span>

<h3>Description</h3>

<p>This function returns two lists each corresponds
to an implemented integration method for approximating the integrals
in the sensitivity (derivative) functions for the Bayesian optimality criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sens.bayes.control(
  method = c("cubature", "quadrature"),
  cubature = list(tol = 1e-05, maxEval = 50000, absError = 0),
  quadrature = list(type = c("GLe", "GHe"), level = 6, ndConstruction = "product",
    level.trans = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sens.bayes.control_+3A_method">method</code></td>
<td>
<p>A character denotes which method to be used to approximate the integrals in Bayesian criteria.
<code>"cubature"</code> corresponds to the adaptive multivariate integration method using the <code><a href="cubature.html#topic+hcubature">hcubature</a></code> algorithm (default).
<code>"quadrature"</code> corresponds the traditional quadrature formulas and calls the function <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code>.
The tuning parameters are adjusted by <code>crt.bayes.control</code>. Default is set to <code>"cubature"</code>.</p>
</td></tr>
<tr><td><code id="sens.bayes.control_+3A_cubature">cubature</code></td>
<td>
<p>A list that will be passed to the arguments of the <code><a href="cubature.html#topic+hcubature">hcubature</a></code> function. See 'Details' of <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="sens.bayes.control_+3A_quadrature">quadrature</code></td>
<td>
<p>A list that will be passed to the arguments of the <code><a href="mvQuad.html#topic+createNIGrid">createNIGrid</a></code> function. See 'Details' of <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of  control parameters for approximating the integrals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sens.bayes.control()
sens.bayes.control(cubature = list(maxEval = 50000))
sens.bayes.control(quadrature =  list(level = 4))
</code></pre>

<hr>
<h2 id='sens.control'>Returns Control Parameters To Find Maximum of The Sensitivity (Derivative) Function Over The Design Space</h2><span id='topic+sens.control'></span>

<h3>Description</h3>

<p>It returns  some arguments of the <code><a href="nloptr.html#topic+nloptr">nloptr</a></code> function including the list of control parameters.
This function is used to find the maximum of the sensitivity (derivative) function over the design space in order to
calculate the efficiency lower bound (ELB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sens.control(
  x0 = NULL,
  optslist = list(stopval = -Inf, algorithm = "NLOPT_GN_DIRECT_L", xtol_rel = 1e-08,
    ftol_rel = 1e-08, maxeval = 1000),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sens.control_+3A_x0">x0</code></td>
<td>
<p>Vector of starting values for maximizing the sensitivity (derivative) function over the design space <code class="reqn">x</code>.
It will be passed to the optimization function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.</p>
</td></tr>
<tr><td><code id="sens.control_+3A_optslist">optslist</code></td>
<td>
<p>A list. It will be passed to the argument <code>opts</code>  of the function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code> to find the maximum of the sensitivity function over the design space. See 'Details'.</p>
</td></tr>
<tr><td><code id="sens.control_+3A_...">...</code></td>
<td>
<p>Further arguments will be passed to <code><a href="nloptr.html#topic+nl.opts">nl.opts</a></code> from package <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ELB is a measure of  proximity of a design to the optimal design without knowing the latter.
Given a design, let <code class="reqn">\epsilon</code> be the global maximum
of the sensitivity (derivative) function with respect the vector of the model predictors <code class="reqn">x</code> over the design space.
ELB is given by </p>
<p style="text-align: center;"><code class="reqn">ELB = p/(p + \epsilon),</code>
</p>

<p>where <code class="reqn">p</code> is the number of model parameters. Obviously,
calculating ELB requires finding <code class="reqn">\epsilon</code> and therefore,
a maximization problem to be solved. The function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>
is used here to solve this maximization problem. The arguments <code>x0</code> and <code>optslist</code>
will be passed to this function as follows:
</p>
<p>Argument <code>x0</code> provides the user initial values for this maximization problem
and will be passed to the argument with the same name
in the function  <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.
</p>
<p>Argument <code>optslist</code> will be passed to the argument <code>opts</code> of the function <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.
<code>optslist</code> is a <code>list</code> and the most important components are listed as follows:
</p>

<dl>
<dt><code>stopval</code></dt><dd><p>Stop minimization when an objective value &lt;= <code>stopval</code> is found. Setting <code>stopval</code> to <code>-Inf</code> disables this stopping criterion (default).</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Defaults to <code>NLOPT_GN_DIRECT_L</code>. DIRECT-L is a deterministic-search algorithm based on systematic division of the search domain into smaller and smaller hyperrectangles.</p>
</dd>
<dt><code>xtol_rel</code></dt><dd><p>Stop when an optimization step (or an estimate of the optimum) changes every parameter by less than <code>xtol_rel</code> multiplied by the absolute value of the parameter. Criterion is disabled if <code>xtol_rel</code> is non-positive.</p>
</dd>
<dt><code>ftol_rel</code></dt><dd><p>Stop when an optimization step (or an estimate of the optimum) changes the objective function value by less than <code>ftol_rel</code> multiplied by the absolute value of the function value. Criterion is disabled if <code>ftol_rel</code> is non-positive. </p>
</dd>
<dt><code>maxeval</code></dt><dd><p>Stop when the number of function evaluations exceeds <code>maxeval</code>. Criterion is disabled if <code>maxeval</code> is non-positive.</p>
</dd>
</dl>

<p>For more details, see <code>?nloptr::nloptr.print.options</code>.
</p>


<h3>Note</h3>

<p>ELB must be <code>0 &lt;=ELB &lt;= 1</code>.
When the computed ELB is larger than one (equivalently <code class="reqn">\epsilon</code> is negative), it may be a signal that the obtained <code class="reqn">\epsilon</code> is not the global maximum.
To overcome this issue, please increase
the value of the parameter <code>maxeval</code> to allow the
optimization algorithm to find the global maximum
of the sensitivity (derivative) function over the design space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sens.control()
sens.control(optslist = list(maxeval = 1000))
</code></pre>

<hr>
<h2 id='sens.minimax.control'>Returns Control Parameters for Verifying General Equivalence Theorem For Minimax Optimal Designs</h2><span id='topic+sens.minimax.control'></span>

<h3>Description</h3>

<p>This function returns a list of control parameters that are used to find
the &ldquo;answering set&rdquo; for minimax and
standardized maximin designs.
The answering set is required to  obtain the sensitivity (derivative) function in order to verify the optimality of
a given design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sens.minimax.control(n_seg = 6, merge_tol = 0.005)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sens.minimax.control_+3A_n_seg">n_seg</code></td>
<td>
<p>For a given design, the number of starting points in the local search to find all the local maxima of the minimax criterion over the parameter space is equal to <code>(n_seg + 1)^p</code>. Defaults to <code>6</code>.
Please increase its value when the parameter space is large. It is also applicable for standardized maximin designs. See 'Details' of <a href="#topic+sens.minimax.control">sens.minimax.control</a>.</p>
</td></tr>
<tr><td><code id="sens.minimax.control_+3A_merge_tol">merge_tol</code></td>
<td>
<p>Merging tolerance. It is used  to  specify the elements of the answering set
by choosing only the local maxima (found by the local search) that are nearer to
the global maximum.  See 'Details' of <a href="#topic+sens.minimax.control">sens.minimax.control</a>. Defaults to <code>0.005</code>.
We advise to not change its default value because it has been successfully tested on many optimal design problems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a design, an &ldquo;answering set&rdquo; is a subset of all the local optima
of the optimality criterion over the parameter space.
Answering set is used to obtain the sensitivity function
of a minimax or standardized maximin criterion.
Therefore, an invalid  answering set may result in a false
sensitivity plot and ELB.
Unfortunately, there is no theoretical rule on how to choose the number of elements of
the answering set; and they  have to be found by trial and error.
Given a design, the answering set for a minimax criterion is obtained as follows:
</p>

<ul>
<li><p>Step 1: Find all the local maxima of the optimality criterion (minimax)  over the parameter space.
For this purpose,  the parameter space is divided into <code>(n_seg + 1)^p</code> segments,
where p is the number of unknown model parameters.
Then, each boundary point of the resulted segments (intervals) is assigned to the argument
<code>par</code> of the function <code>optim</code> in order to start a local search
using the <code>"L-BFGS-B"</code> method.
</p>
</li>
<li><p>Step 2: Pick the ones nearest to the global minimum subject to a merging tolerance
<code>merge_tol</code> (default <code>0.005</code>).
</p>
</li></ul>

<p>Obviously, the answering set is a subset of all the local maxima over the parameter space (or local minima in case of standardized maximin criteria)
Therefore, it is very important to be able to find all the local maxima to create the true answering set with no missing elements.
Otherwise, even when the design is optimal, the sensitivity (derivative) plot may not reveal its optimality.
</p>
<p>Note that the minimax criterion (or standardized maximin criterion)
is a multimodel function especially near the optimal design and
this makes the job of finding all the locall maxima (minima) over the
parameter space very complicated.
</p>


<h3>Value</h3>

<p>A list of control parameters for verifying the general equivalence
theorem for minimax and standardized maximin optimal designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sens.minimax.control()
sens.minimax.control(n_seg = 4)
</code></pre>

<hr>
<h2 id='sensbayes'>Verifying Optimality of Bayesian D-optimal Designs</h2><span id='topic+sensbayes'></span>

<h3>Description</h3>

<p>Plots the sensitivity (derivative) function  and calculates the efficiency lower bound (ELB) for a  given  Bayesian design.
Let <code class="reqn">\boldsymbol{x}</code> belongs to <code class="reqn">\chi</code> that denotes the design space.
Based on the general equivalence theorem,  a design <code class="reqn">\xi^*</code> is optimal if and only if the value of the sensitivity (derivative) function
is non-positive for all <code class="reqn">\boldsymbol{x}</code> in <code class="reqn">\chi</code> and zero when
<code class="reqn">\boldsymbol{x}</code> belongs to the support of <code class="reqn">\xi^*</code> (be equal to the one of the design points).
</p>
<p>For an approximate (continuous) design, when the design space is one or two-dimensional, the user can visually verify the optimality of the design by observing the
sensitivity plot. Furthermore, the proximity of the design to the optimal design
can be measured by the  ELB without knowing the latter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensbayes(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  x,
  w,
  lx,
  ux,
  fimfunc = NULL,
  prior = list(),
  sens.control = list(),
  sens.bayes.control = list(),
  crt.bayes.control = list(),
  plot_3d = c("lattice", "rgl"),
  plot_sens = TRUE,
  npar = NULL,
  calculate_criterion = TRUE,
  silent = FALSE,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sensbayes_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_x">x</code></td>
<td>
<p>A vector of candidate design (support) points.
When is not set to <code>NULL</code> (default),
the algorithm only finds the optimal weights for the candidate points in  <code>x</code>.
Should be set when the user has a finite number of candidate design points  and the purpose
is to find the optimal weight for each of them (when zero, they will be excluded from the design).
For design points with more than one dimension, see 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_w">w</code></td>
<td>
<p>Vector of the corresponding design weights for <code>x</code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_prior">prior</code></td>
<td>
<p>An object of class <code>cprior</code>. User can also use one of the functions
<code><a href="#topic+uniform">uniform</a></code>, <code><a href="#topic+normal">normal</a></code>,
<code><a href="#topic+skewnormal">skewnormal</a></code> or <code><a href="#topic+student">student</a></code>  to create the  prior. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_sens.bayes.control">sens.bayes.control</code></td>
<td>
<p>A list. Control parameters to verify the general equivalence theorem. For details, see <code><a href="#topic+sens.bayes.control">sens.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_crt.bayes.control">crt.bayes.control</code></td>
<td>
<p>A list. Control parameters to approximate the integral in  the Bayesian criterion at a given design over the parameter space.
For details, see <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to <code>"lattice"</code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not specified correctly, the sensitivity (derivative) plot may be shifted below the y-axis.
When <code>NULL</code> (default), it will be set to <code>length(parvars)</code> or
<code>prior$npar</code> when <code>missing(formula)</code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Calculate the optimality criterion? See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayes_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\Xi</code> be the space of all  approximate designs with
<code class="reqn">k</code> design points (support points) at <code class="reqn">x_1, x_2, ...,  x_k</code> from  design space <code class="reqn">\chi</code> with
corresponding weights  <code class="reqn">w_1, . . . ,w_k</code>.
Let <code class="reqn">M(\xi, \theta)</code> be the Fisher information
matrix (FIM) of a <code class="reqn">k-</code>point design <code class="reqn">\xi</code>
and  <code class="reqn">\pi(\theta)</code> is a user-given  prior distribution for the vector of unknown parameters <code class="reqn">\theta</code>.
A design <code class="reqn">\xi^*</code> is Bayesian D-optimal among all designs on <code class="reqn">\chi</code> if and only if  the following inequality holds for all <code class="reqn">\boldsymbol{x} \in \chi</code>
</p>
<p style="text-align: center;"><code class="reqn">c(\boldsymbol{x}, \xi^*) =  \int_{\theta \in Theta}tr M^{-1}(\xi^*, \theta)I(\boldsymbol{x}, \theta)-p \pi(\theta) d\theta\leq 0,</code>
</p>

<p>with equality at all support points of <code class="reqn">\xi^*</code>.
Here, <code class="reqn">p</code> is the number of model parameters.
<code class="reqn">c(\boldsymbol{x},\xi^*)</code> is
called <strong>sensitivity</strong> or <strong>derivative</strong> function.
</p>
<p>Depending on the complexity of the problem at hand, sometimes, the CPU time can be considerably reduced
by choosing a set of  less conservative values for the tuning parameters <code>tol</code> and <code>maxEval</code> in
the function <code><a href="#topic+sens.bayes.control">sens.bayes.control</a></code> when <code>sens.bayes.control$method = "cubature"</code>.
Similarly, this applies  when <code>sens.bayes.control$method = "quadrature"</code>.
In general, if the CPU time matters, the user should find an appropriate speed-accuracy trade-off  for her/his own problem.
See 'Examples' for more details.
</p>


<h3>Note</h3>

<p>The default values of the tuning parameters in <code>sens.bayes.control</code> are set in a way that
having accurate plots for the sensitivity (derivative) function
and calculating the ELB to a high precision  to be the primary goals,
although the process may take too long. The user should choose a set of less conservative values
via the argument <code>sens.bayes.control</code> when the CPU-time is too long or matters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################################
# Checking the Bayesian D-optimality of a design for the 2Pl model
##################################################################
skew2 &lt;- skewnormal(xi = c(0, 1), Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                    alpha = c(-1, 0), lower =  c(-3, .1), upper = c(3, 2))
## Not run: 
  sensbayes(formula = ~1/(1 + exp(-b *(x - a))),
            predvars = "x", parvars = c("a", "b"),
            family = binomial(),
            x= c(-2.50914, -1.16780, -0.36904, 1.29227),
            w =c(0.35767, 0.11032, 0.15621, 0.37580),
            lx = -3, ux = 3,
            prior = skew2)
  # took 29 seconds on my system!

## End(Not run)

# It took very long.
# We re-adjust the tuning parameters in sens.bayes.control to be faster
# See how we drastically reduce the maxEval and increase the tolerance
## Not run: 
  sensbayes(formula = ~1/(1 + exp(-b *(x - a))),
            predvars = "x", parvars = c("a", "b"),
            family = binomial(),
            x= c(-2.50914, -1.16780, -0.36904, 1.29227),
            w =c(0.35767, 0.11032, 0.15621, 0.37580),
            lx = -3, ux = 3,prior = skew2,
            sens.bayes.control = list(cubature = list(tol = 1e-4, maxEval = 300)))
  # took 5 Seconds on my system!

## End(Not run)



# Compare it with the following:
sensbayes(formula = ~1/(1 + exp(-b *(x - a))),
          predvars = "x", parvars = c("a", "b"),
          family = binomial(),
          x= c(-2.50914, -1.16780, -0.36904, 1.29227),
          w =c(0.35767, 0.11032, 0.15621, 0.37580),
          lx = -3, ux = 3,prior = skew2,
          sens.bayes.control = list(cubature = list(tol = 1e-4, maxEval = 200)))
# Look at the plot!
# took 3 seconds on my system


########################################################################################
# Checking the Bayesian D-optimality of a design for the 4-parameter sigmoid emax model
########################################################################################
lb &lt;- c(4, 11, 100, 5)
ub &lt;- c(9, 17, 140, 10)
## Not run: 
  sensbayes(formula = ~ theta1 + (theta2 - theta1)*(x^theta4)/(x^theta4 + theta3^theta4),
            predvars = c("x"), parvars = c("theta1", "theta2", "theta3", "theta4"),
            x = c(0.78990, 95.66297, 118.42964,147.55809, 500),
            w = c(0.23426, 0.17071, 0.17684, 0.1827, 0.23549),
            lx = .001, ux = 500,  prior = uniform(lb, ub))
  # took 200 seconds on my system

## End(Not run)

# Re-adjust the tuning parameters to have it faster
## Not run: 
  sensbayes(formula = ~ theta1 + (theta2 - theta1)*(x^theta4)/(x^theta4 + theta3^theta4),
            predvars = c("x"), parvars = c("theta1", "theta2", "theta3", "theta4"),
            x = c(0.78990, 95.66297, 118.42964,147.55809, 500),
            w = c(0.23426, 0.17071, 0.17684, 0.1827, 0.23549),
            lx = .001, ux = 500,  prior = uniform(lb, ub),
            sens.bayes.control = list(cubature = list(tol = 1e-3, maxEval = 300)))
  # took 4 seconds on my system. See how much it makes difference

## End(Not run)

## Not run: 
  # Now we try it with quadrature. Default is 6 nodes
  sensbayes(formula = ~ theta1 + (theta2 - theta1)*(x^theta4)/(x^theta4 + theta3^theta4),
            predvars = c("x"), parvars = c("theta1", "theta2", "theta3", "theta4"),
            x = c(0.78990, 95.66297, 118.42964,147.55809, 500),
            w = c(0.23426, 0.17071, 0.17684, 0.1827, 0.23549),
            sens.bayes.control = list(method = "quadrature"),
            lx = .001, ux = 500,  prior = uniform(lb, ub))
  # 166.519 s

  # use less number of nodes  to see if we can reduce the CPU time
  sensbayes(formula = ~ theta1 + (theta2 - theta1)*(x^theta4)/(x^theta4 + theta3^theta4),
            predvars = c("x"), parvars = c("theta1", "theta2", "theta3", "theta4"),
            x = c(0.78990, 95.66297, 118.42964,147.55809, 500),
            w = c(0.23426, 0.17071, 0.17684, 0.1827, 0.23549),
            sens.bayes.control = list(method = "quadrature",
                                      quadrature = list(level = 3)),
            lx = .001, ux = 500,  prior = uniform(lb, ub))
  # we don't have an accurate plot

  # use less number of levels: use 4 nodes
  sensbayes(formula = ~ theta1 + (theta2 - theta1)*(x^theta4)/(x^theta4 + theta3^theta4),
            predvars = c("x"), parvars = c("theta1", "theta2", "theta3", "theta4"),
            x = c(0.78990, 95.66297, 118.42964,147.55809, 500),
            w = c(0.23426, 0.17071, 0.17684, 0.1827, 0.23549),
            sens.bayes.control = list(method = "quadrature",
                                      quadrature = list(level = 4)),
            lx = .001, ux = 500,  prior = uniform(lb, ub))


## End(Not run)
</code></pre>

<hr>
<h2 id='sensbayescomp'>Verifying Optimality of Bayesian Compound DP-optimal Designs</h2><span id='topic+sensbayescomp'></span>

<h3>Description</h3>

<p>This function plot the sensitivity (derivative) function given an approximate (continuous) design and calculate the efficiency lower bound (ELB) for Bayesian DP-optimal designs.
Let <code class="reqn">\boldsymbol{x}</code> belongs to <code class="reqn">\chi</code> that denotes the design space.
Based on the general equivalence theorem, generally, a design <code class="reqn">\xi^*</code> is optimal if and only if the value of its sensitivity (derivative) function
be non-positive for all <code class="reqn">\boldsymbol{x}</code> in <code class="reqn">\chi</code> and it only reaches zero
when <code class="reqn">\boldsymbol{x}</code> belong to the support of <code class="reqn">\xi^*</code> (be equal to one of the design point).
Therefore, the user can look at the sensitivity plot and the ELB and decide whether the
design is optimal or close enough to the true optimal design (ELB tells us that without knowing the latter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensbayescomp(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  x,
  w,
  lx,
  ux,
  fimfunc = NULL,
  prior = list(),
  prob,
  alpha,
  sens.control = list(),
  sens.bayes.control = list(),
  crt.bayes.control = list(),
  plot_3d = c("lattice", "rgl"),
  plot_sens = TRUE,
  npar = NULL,
  calculate_criterion = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sensbayescomp_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_x">x</code></td>
<td>
<p>A vector of candidate design (support) points.
When is not set to <code>NULL</code> (default),
the algorithm only finds the optimal weights for the candidate points in  <code>x</code>.
Should be set when the user has a finite number of candidate design points  and the purpose
is to find the optimal weight for each of them (when zero, they will be excluded from the design).
For design points with more than one dimension, see 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_w">w</code></td>
<td>
<p>Vector of the corresponding design weights for <code>x</code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_prior">prior</code></td>
<td>
<p>An object of class <code>cprior</code>. User can also use one of the functions
<code><a href="#topic+uniform">uniform</a></code>, <code><a href="#topic+normal">normal</a></code>,
<code><a href="#topic+skewnormal">skewnormal</a></code> or <code><a href="#topic+student">student</a></code>  to create the  prior. See 'Details' of <code><a href="#topic+bayes">bayes</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_prob">prob</code></td>
<td>
<p>Either <code>formula</code> or a <code>function</code>. When function, its argument are <code>x</code> and <code>param</code>, and they are the same as the arguments in <code>fimfunc</code>.
<code>prob</code> as a function takes the design points and vector of parameters and returns the probability of success at each design points.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_alpha">alpha</code></td>
<td>
<p>A value between 0 and 1.
Compound or combined DP-criterion  is the product of the efficiencies of a design  with respect to D- and average P- optimality, weighted by <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_sens.bayes.control">sens.bayes.control</code></td>
<td>
<p>A list. Control parameters to verify the general equivalence theorem. For details, see <code><a href="#topic+sens.bayes.control">sens.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_crt.bayes.control">crt.bayes.control</code></td>
<td>
<p>A list. Control parameters to approximate the integral in  the Bayesian criterion at a given design over the parameter space.
For details, see <code><a href="#topic+crt.bayes.control">crt.bayes.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to <code>"lattice"</code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not specified correctly, the sensitivity (derivative) plot may be shifted below the y-axis.
When <code>NULL</code> (default), it will be set to <code>length(parvars)</code> or
<code>prior$npar</code> when <code>missing(formula)</code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Calculate the optimality criterion? See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensbayescomp_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the complexity of the problem at hand, sometimes, the CPU time can be considerably reduced
by choosing a set of  less conservative values for the tuning parameters <code>tol</code> and <code>maxEval</code> in
the function <code><a href="#topic+sens.bayes.control">sens.bayes.control</a></code> when its  <code>method</code> component is equal to <code>"cubature"</code>.
Similarly, this applies  when <code>sens.bayes.control$method = "quadrature"</code>.
In general, if the CPU time matters, the user should find an appropriate speed-accuracy trade-off  for her/his own problem.
See 'Examples' for more details.
</p>


<h3>Note</h3>

<p>The default values of the tuning parameters in <code>sens.bayes.control</code> are set in a way that
having accurate plots for the sensitivity (derivative) function
and calculating the ELB to a high precision  to be the primary goals,
although the process may take too long. The user should choose a set of less conservative values
via the argument <code>sens.bayes.control</code> when the CPU-time is too long or matters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayescomp">bayescomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
# Verifing the DP-optimality of a design
# The logistic model with two predictors
##########################################

# The design points and corresponding weights are as follows:
# Point1     Point2     Point3     Point4     Point5     Point6     Point7
# 0.07410  -0.31953   -1.00000     1.00000  -1.00000     1.00000    0.30193
# -1.00000  1.00000   -1.00000     1.00000   -0.08251   -1.00000    1.00000
# Weight1   Weight2    Weight3    Weight4    Weight5    Weight6    Weight7
# 0.020      0.275      0.224      0.131      0.092      0.156      0.103

# It should be given to the function as two seperate vectors:
x1 &lt;- c(0.07409639, -0.3195265, -1, 1, -1, 1, 0.3019317, -1, 1, -1, 1, -0.08251169, -1, 1)
w1 &lt;- c(0.01992863, 0.2745394, 0.2236575, 0.1312331, 0.09161503, 0.1561454, 0.1028811)


p &lt;- c(1, -2, 1, -1)

## Not run: 
sensbayescomp(formula = ~exp(b0+b1*x1+b2*x2+b3*x1*x2)/(1+exp(b0+b1*x1+b2*x2+b3*x1*x2)),
              predvars = c("x1", "x2"),
              parvars = c("b0", "b1", "b2", "b3"),
              family = binomial(),
              x = x1, w = w1,
              lx = c(-1, -1), ux = c(1, 1),
              prior = uniform(p -1.5, p + 1.5),
              prob = ~1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2)),
              alpha = .5, plot_3d = "rgl",
              sens.bayes.control = list(cubature = list(tol = 1e-3, maxEval = 1000)))

## End(Not run)





</code></pre>

<hr>
<h2 id='senslocally'>Verifying Optimality of The Locally D-optimal Designs</h2><span id='topic+senslocally'></span>

<h3>Description</h3>

<p>It plots the sensitivity (derivative) function of the
locally D-optimal criterion
at a given approximate (continuous) design and also
calculates its efficiency lower bound (ELB) with respect
to the optimality criterion.
For an approximate (continuous) design, when the design space is one or two-dimensional,
the user can visually verify the optimality of the design by observing the
sensitivity plot. Furthermore, the proximity of the design to the optimal design
can be measured by the  ELB without knowing the latter.
See, for more details, Masoudi et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>senslocally(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  x,
  w,
  lx,
  ux,
  inipars,
  fimfunc = NULL,
  sens.control = list(),
  calculate_criterion = TRUE,
  plot_3d = c("lattice", "rgl"),
  plot_sens = TRUE,
  npar = length(inipars),
  silent = FALSE,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="senslocally_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_x">x</code></td>
<td>
<p>Vector of the design (support) points. See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code> for models with more than one predictors.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_w">w</code></td>
<td>
<p>Vector of the corresponding design weights for <code>x</code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_inipars">inipars</code></td>
<td>
<p>A vector of initial estimates for the unknown parameters.
It must match <code>parvars</code> or the argument <code>param</code> of the function <code>fimfunc</code>, when provided.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Calculate the optimality criterion? See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for models with two predictors.
Either <code>"rgl"</code> or <code>"lattice"</code> (default).</p>
</td></tr>
<tr><td><code id="senslocally_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis.
When <code>NULL</code>, it is set to <code>length(inipars)</code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="senslocally_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\theta_0</code> denotes the vector of initial estimates for the unknown parameters.
A design <code class="reqn">\xi^*</code> is locally D-optimal among all designs on <code class="reqn">\chi</code> if and only if
the following inequality holds for all <code class="reqn">\boldsymbol{x} \in \chi</code>
</p>
<p style="text-align: center;"><code class="reqn">c(\boldsymbol{x}, \xi^*, \theta_0) =  tr M^{-1}(\xi^*, \theta_0)I(\boldsymbol{x}, \theta_0)-p \leq 0,</code>
</p>

<p>with equality at all support points of <code class="reqn">\xi^*</code>.
Here, <code class="reqn">p</code> is the number of model parameters.
<code class="reqn">c(\boldsymbol{x},\xi^*, \theta_0)</code> is called <strong>sensitivity</strong> or <strong>derivative</strong> function.
</p>
<p>ELB is a measure of  proximity of a design to the optimal design without knowing the latter.
Given a design, let <code class="reqn">\epsilon</code> be the global maximum
of the sensitivity (derivative) function over <code class="reqn">x \in \chi</code>.
ELB is given by </p>
<p style="text-align: center;"><code class="reqn">ELB = p/(p + \epsilon),</code>
</p>

<p>where <code class="reqn">p</code> is the number of model parameters. Obviously,
calculating ELB requires finding <code class="reqn">\epsilon</code> and
another optimization problem to be solved.
The tuning parameters of this optimization can be regulated via the argument  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
See, for more details, Masoudi et al. (2017).
</p>


<h3>Value</h3>

<p>an object of class <code>sensminimax</code> that is a list with the following elements:
</p>

<dl>
<dt><code>type</code></dt><dd><p>Argument <code>type</code> that is required for print methods.</p>
</dd>
<dt><code>optima</code></dt><dd><p>A <code>matrix</code> that stores all the local optima over the parameter space.
The cost  (criterion) values are stored in a column named <code>Criterion_Value</code>.
The last column (<code>Answering_Set</code>)
shows if the optimum belongs to the answering set (1) or not (0). See 'Details' of <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>mu</code></dt><dd><p>Probability measure on the answering set.
Corresponds to the rows of <code>optima</code> for which the associated row in column <code>Answering_Set</code> is equal to 1.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>max_deriv</code></dt><dd><p>Global maximum of the sensitivity (derivative) function (<code class="reqn">\epsilon</code> in 'Details').</p>
</dd>
<dt><code>ELB</code></dt><dd><p>D-efficiency lower bound. Can not be larger than 1. If negative, see 'Note' in <code><a href="#topic+sensminimax">sensminimax</a></code> or  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.</p>
</dd>
<dt><code>merge_tol</code></dt><dd><p>Merging tolerance to create the answering set from the set of all local optima. See 'Details' in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>crtval</code></dt><dd><p>Criterion value. Compare it with the column <code>Crtiterion_Value</code> in <code>optima</code> for minimax and standardized maximin designs.</p>
</dd>
<dt><code>time</code></dt><dd><p>Used CPU time (rough approximation).</p>
</dd>
</dl>



<h3>Note</h3>

<p>Theoretically, ELB can not be larger than 1. But if so, it may have one of the following reasons:
</p>

<ul>
<li> <p><code>max_deriv</code> is not a GLOBAL maximum.  Please increase  the value of the parameter <code>maxeval</code> in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code> to find the global maximum.
</p>
</li>
<li><p> The sensitivity function is shifted below the y-axis because
the number of model parameters has not been specified correctly (less value given).
Please specify the correct number of model parameters via the argument <code>npar</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Masoudi E, Holling H, Wong W.K. (2017). Application of Imperialist Competitive Algorithm to Find Minimax and Standardized Maximin Optimal Designs. Computational Statistics and Data Analysis, 113, 330-345. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################
# Exponential growth model
############################
# Verifying optimailty of a locally D-optimal design
senslocally(formula = ~a + exp(-b*x),
            predvars = "x", parvars = c("a", "b"),
            x = c(.1, 1), w = c(.5, .5),
            lx = 0, ux = 1, inipars = c(1, 10))


##############################
# A model with two predictors
##############################
x0 &lt;- c(30, 3.861406, 30, 4.600633, 0, 0, 5.111376, 4.168798)
w0 &lt;- rep(.25, 4)
senslocally(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
            predvars = c("S", "I"),
            parvars = c("V", "Km", "Kic", "Kiu"),
            x = x0, w = w0,
            lx = c(0, 0), ux = c(30, 60),
            inipars = c(1.5, 5.2, 3.4, 5.6))
## Not run: 
  # using package rgl for 3d plot:
  res&lt;- senslocally(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
                    predvars = c("S", "I"),
                    parvars = c("V", "Km", "Kic", "Kiu"),
                    x = x0, w = w0,
                    lx = c(0, 0), ux = c(30, 60),
                    inipars = c(1.5, 5.2, 3.4, 5.6),
                    plot_3d = "rgl")


## End(Not run)

###################################
# user-defined optimality criterion
##################################
# When the model is defined by the formula interface
# Checking the A-optimality  for the 2PL model.
# the criterion function must have argument x, w fimfunc and the parameters defined in 'parvars'.
# use 'fimfunc' as a function of the design points x,  design weights w and
#  the 'parvars' parameters whenever needed.
Aopt &lt;-function(x, w, a, b, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, a = a, b = b))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a  = a, b = b)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}

senslocally(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
            parvars = c("a", "b"), family = "binomial",
            inipars = c(0, 1.5),
            crtfunc = Aopt,
            lx = -2, ux = 2,
            sensfunc = Aopt_sens,
            x = c(-1,  1), w = c(.5, .5))
# not optimal
</code></pre>

<hr>
<h2 id='senslocallycomp'>Verifying Optimality of The Locally DP-optimal Designs</h2><span id='topic+senslocallycomp'></span>

<h3>Description</h3>

<p>This function plot the sensitivity (derivative) function given an approximate (continuous) design and calculate the efficiency lower bound (ELB) for locally DP-optimal designs.
Let <code class="reqn">\boldsymbol{x}</code> belongs to <code class="reqn">\chi</code> that denotes the design space.
Based on the general equivalence theorem, generally, a design <code class="reqn">\xi^*</code> is optimal if and only if the value of its sensitivity (derivative) function
be non-positive for all <code class="reqn">\boldsymbol{x}</code> in <code class="reqn">\chi</code> and it only reaches zero
when <code class="reqn">\boldsymbol{x}</code> belong to the support of <code class="reqn">\xi^*</code> (be equal to one of the design point).
Therefore, the user can look at the sensitivity plot and the ELB to decide whether the
design is optimal or close enough to the true optimal design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>senslocallycomp(
  formula,
  predvars,
  parvars,
  alpha,
  prob,
  family = gaussian(),
  x,
  w,
  lx,
  ux,
  inipars,
  fimfunc = NULL,
  sens.control = list(),
  calculate_criterion = TRUE,
  plot_3d = c("lattice", "rgl"),
  plot_sens = TRUE,
  npar = length(inipars),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="senslocallycomp_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_alpha">alpha</code></td>
<td>
<p>A value between 0 and 1.
Compound or combined DP-criterion  is the product of the efficiencies of a design  with respect to D- and average P- optimality, weighted by <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_prob">prob</code></td>
<td>
<p>Either <code>formula</code> or a <code>function</code>. When function, its argument are <code>x</code> and <code>param</code>, and they are the same as the arguments in <code>fimfunc</code>.
<code>prob</code> as a function takes the design points and vector of parameters and returns the probability of success at each design points.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_x">x</code></td>
<td>
<p>Vector of the design (support) points. See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code> for models with more than one predictors.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_w">w</code></td>
<td>
<p>Vector of the corresponding design weights for <code>x</code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_inipars">inipars</code></td>
<td>
<p>Vector of initial estimates for the unknown parameters.
It must match <code>parvars</code> or argument <code>param</code> of the function provided in <code>fimfunc</code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Calculate the optimality criterion? See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for models with two predictors.
Either <code>"rgl"</code> or <code>"lattice"</code> (default).</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis.
When <code>NULL</code>, it is set  to <code>length(inipars)</code>.</p>
</td></tr>
<tr><td><code id="senslocallycomp_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>sensminimax</code> that is a list with the following elements:
</p>

<dl>
<dt><code>type</code></dt><dd><p>Argument <code>type</code> that is required for print methods.</p>
</dd>
<dt><code>optima</code></dt><dd><p>A <code>matrix</code> that stores all the local optima over the parameter space.
The cost  (criterion) values are stored in a column named <code>Criterion_Value</code>.
The last column (<code>Answering_Set</code>)
shows if the optimum belongs to the answering set (1) or not (0). See 'Details' of <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>mu</code></dt><dd><p>Probability measure on the answering set.
Corresponds to the rows of <code>optima</code> for which the associated row in column <code>Answering_Set</code> is equal to 1.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>max_deriv</code></dt><dd><p>Global maximum of the sensitivity (derivative) function (<code class="reqn">\epsilon</code> in 'Details').</p>
</dd>
<dt><code>ELB</code></dt><dd><p>D-efficiency lower bound. Can not be larger than 1. If negative, see 'Note' in <code><a href="#topic+sensminimax">sensminimax</a></code> or  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.</p>
</dd>
<dt><code>merge_tol</code></dt><dd><p>Merging tolerance to create the answering set from the set of all local optima. See 'Details' in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>crtval</code></dt><dd><p>Criterion value. Compare it with the column <code>Crtiterion_Value</code> in <code>optima</code> for minimax and standardized maximin designs.</p>
</dd>
<dt><code>time</code></dt><dd><p>Used CPU time (rough approximation).</p>
</dd>
</dl>



<h3>References</h3>

<p>McGree, J. M., Eccleston, J. A., and Duffull, S. B. (2008). Compound optimal design criteria for nonlinear models. Journal of Biopharmaceutical Statistics, 18(4), 646-661.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- c(1, -2, 1, -1)
prior4.4 &lt;- uniform(p -1.5, p + 1.5)
formula4.4 &lt;- ~exp(b0+b1*x1+b2*x2+b3*x1*x2)/(1+exp(b0+b1*x1+b2*x2+b3*x1*x2))
prob4.4 &lt;- ~1-1/(1+exp(b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2))
predvars4.4 &lt;-  c("x1", "x2")
parvars4.4 &lt;- c("b0", "b1", "b2", "b3")
lb &lt;- c(-1, -1)
ub &lt;- c(1, 1)

## That is the optimal design when alpha = .25, see ?locallycomp on how to find it
xopt &lt;- c(-1, -0.389, 1, 0.802, -1, 1, -1, 1)
wopt &lt;- c(0.198, 0.618, 0.084, 0.1)

# We want to verfiy the optimality of the optimal design by the general equivalence theorem.

senslocallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                alpha = .25, inipars = p, x = xopt, w = wopt)

## Not run: 
# is this design also optimal when alpha = .3

senslocallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                alpha = .3, inipars = p, x = xopt, w = wopt)

# when alpha = .3
senslocallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                alpha = .5, inipars = p, x = xopt, w = wopt)
# when alpha = .8
senslocallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                alpha = .8, inipars = p, x = xopt, w = wopt)


# when alpha = .9
senslocallycomp(formula = formula4.4, predvars = predvars4.4, parvars = parvars4.4,
                family = binomial(), prob = prob4.4, lx = lb, ux = ub,
                alpha = .9, inipars = p, x = xopt, w = wopt)

## As can be seen, the design looses efficiency as alpha increases.

## End(Not run)
</code></pre>

<hr>
<h2 id='sensminimax'>Verifying Optimality of The Minimax and Standardized maximin D-optimal Designs</h2><span id='topic+sensminimax'></span>

<h3>Description</h3>

<p>It plots the sensitivity (derivative) function of the minimax or
standardized maximin D-optimal criterion
at a given approximate (continuous) design and also
calculates its efficiency lower bound (ELB) with respect
to the optimality criterion.
For an approximate (continuous) design, when the design space is one or two-dimensional,
the user can visually verify the optimality of the design by observing the
sensitivity plot. Furthermore, the proximity of the design to the optimal design
can be measured by the  ELB without knowing the latter.
See, for more details, Masoudi et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensminimax(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  x,
  w,
  lx,
  ux,
  lp,
  up,
  fimfunc = NULL,
  standardized = FALSE,
  localdes = NULL,
  sens.control = list(),
  sens.minimax.control = list(),
  calculate_criterion = TRUE,
  crt.minimax.control = list(),
  plot_3d = c("lattice", "rgl"),
  plot_sens = TRUE,
  npar = length(lp),
  silent = FALSE,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sensminimax_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_x">x</code></td>
<td>
<p>Vector of the design (support) points. See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code> for models with more than one predictors.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_w">w</code></td>
<td>
<p>Vector of the corresponding design weights for <code>x</code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_lp">lp</code></td>
<td>
<p>Vector of lower bounds for the model parameters. Should be in the same order as <code>parvars</code> or <code>param</code> in the argument <code>fimfunc</code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_up">up</code></td>
<td>
<p>Vector of upper bounds for the model parameters. Should be in the same order as <code>parvars</code> or <code>param</code> in the argument <code>fimfunc</code>.
When a parameter is known (has a fixed value), its associated lower and upper bound values  in <code>lp</code> and <code>up</code>  must be set equal.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_standardized">standardized</code></td>
<td>
<p>Maximin standardized design? When <code>standardized = TRUE</code>, the argument <code>localdes</code> must be given.
Defaults to <code>FALSE</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_localdes">localdes</code></td>
<td>
<p>A function that takes the parameter values  as inputs and returns the design points and weights of the locally optimal design.
Required when <code>standardized = "TRUE"</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_sens.minimax.control">sens.minimax.control</code></td>
<td>
<p>Control parameters to construct the answering set required for verify the general equivalence theorem and calculating the ELB. For details, see the function <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Calculate the optimality criterion? See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_crt.minimax.control">crt.minimax.control</code></td>
<td>
<p>Control parameters to calculate the value of the  minimax or standardized maximin optimality criterion  over the  continuous parameter space.
Only applicable when <code>calculate_criterion = TRUE</code>.
For more details, see <code><a href="#topic+crt.minimax.control">crt.minimax.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for models with two predictors.
Either <code>"rgl"</code> or <code>"lattice"</code> (default).</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not specified truly, the sensitivity (derivative) plot may be shifted below the y-axis. When <code>NULL</code> (default), it is set to <code>length(lp)</code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensminimax_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let the unknown parameters belong to <code class="reqn">\Theta</code>.
A design <code class="reqn">\xi^*</code> is minimax D-optimal among all designs on <code class="reqn">\chi</code> if and only if there exists a probability measure <code class="reqn">\mu^*</code> on
</p>
<p style="text-align: center;"><code class="reqn">A(\xi^*) = \left\{\nu \in \Theta \mid -log|M(\xi^*, \nu)| = \max_{\theta \in \Theta} -log|M(\xi^*, \theta)| \right\},</code>
</p>

<p>such that the following inequality holds for all <code class="reqn">\boldsymbol{x} \in \chi</code>
</p>
<p style="text-align: center;"><code class="reqn">c(\boldsymbol{x}, \mu^*, \xi^*) = \int_{A(\xi^*)} tr M^{-1}(\xi^*, \nu)I(\boldsymbol{x}, \nu)\mu^* d(\nu)-p \leq 0,</code>
</p>

<p>with equality at all support points of <code class="reqn">\xi^*</code>.
Here, <code class="reqn">p</code> is the number of model parameters. <code class="reqn">c(\boldsymbol{x}, \mu^*, \xi^*)</code> is called <strong>sensitivity</strong> or <strong>derivative</strong> function.
The set <code class="reqn">A(\xi^*)</code> is sometimes called <b>answering set</b> of
<code class="reqn">\xi^*</code> and the measure <code class="reqn">\mu^*</code> is a sub-gradient of the
non-differentiable criterion evaluated at <code class="reqn">M(\xi^*,\nu)</code>.<br />
For the standardized maximin D-optimal designs, the answering set <code class="reqn">N(\xi^*)</code> is
</p>
<p style="text-align: center;"><code class="reqn">N(\xi^*) = \left\{\boldsymbol{\nu} \in \Theta \mid \mbox{eff}_D(\xi^*, \boldsymbol{\nu}) = \min_{\boldsymbol{\theta} \in \Theta} \mbox{eff}_D(\xi^*, \boldsymbol{\theta}) \right\}.
     </code>
</p>
<p> where
<code class="reqn">\mbox{eff}_D(\xi, \boldsymbol{\theta}) =  (\frac{|M(\xi, \boldsymbol{\theta})|}{|M(\xi_{\boldsymbol{\theta}}, \boldsymbol{\theta})|})^\frac{1}{p}</code> and <code class="reqn">\xi_\theta</code> is the locally D-optimal design with respect to <code class="reqn">\theta</code>.
See 'Details' of <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code> on how we find the answering set.
</p>
<p>The argument  <code>x</code> is the vector of design points.
For design points with more than one dimension (the models with more than one predictors),
it is a concatenation of the design points, but <strong>dimension-wise</strong>.
For example, let the model has three predictors   <code class="reqn">(I, S, Z)</code>.
Then,  a two-point optimal design has the following points:
<code class="reqn">\{\mbox{point1} = (I_1, S_1, Z_1), \mbox{point2} = (I_2, S_2, Z_2)\}</code>.
Then, the argument <code>x</code> is equal to
<code>x = c(I1, I2, S1, S2, Z1, Z2)</code>.
</p>
<p>ELB is a measure of  proximity of a design to the optimal design without knowing the latter.
Given a design, let <code class="reqn">\epsilon</code> be the global maximum
of the sensitivity (derivative) function with respect <code class="reqn">x</code> where <code class="reqn">x \in \chi</code>.
ELB is given by </p>
<p style="text-align: center;"><code class="reqn">ELB = p/(p + \epsilon),</code>
</p>

<p>where <code class="reqn">p</code> is the number of model parameters. Obviously,
calculating ELB requires finding <code class="reqn">\epsilon</code> and
another optimization problem to be solved.
The tuning parameters of this optimization can be regulated via the argument <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
See, for more details, Masoudi et al. (2017).
</p>
<p>The criterion value for the minimax D-optimal design is (global maximum over <code class="reqn">\Theta</code>)
</p>
<p style="text-align: center;"><code class="reqn">\max_{\theta \in \Theta} -\log|M(\xi, \theta)|;</code>
</p>

<p>for the standardized maximin D-optimal design is (global minimum over <code class="reqn">\Theta</code>)
</p>
<p style="text-align: center;"><code class="reqn">\inf_{\theta \in \Theta} \left[\left(\frac{|M(\xi, \theta)|}{|M(\xi_{\theta}, \theta)|}\right)^\frac{1}{p}\right].</code>
</p>

<p>This function confirms the optimality assuming only a continuous parameter space <code class="reqn">\Theta</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>sensminimax</code> that is a list with the following elements:
</p>

<dl>
<dt><code>type</code></dt><dd><p>Argument <code>type</code> that is required for print methods.</p>
</dd>
<dt><code>optima</code></dt><dd><p>A <code>matrix</code> that stores all the local optima over the parameter space.
The cost  (criterion) values are stored in a column named <code>Criterion_Value</code>.
The last column (<code>Answering_Set</code>)
shows if the optimum belongs to the answering set (1) or not (0). See 'Details' of <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>mu</code></dt><dd><p>Probability measure on the answering set.
Corresponds to the rows of <code>optima</code> for which the associated row in column <code>Answering_Set</code> is equal to 1.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>max_deriv</code></dt><dd><p>Global maximum of the sensitivity (derivative) function (<code class="reqn">\epsilon</code> in 'Details').</p>
</dd>
<dt><code>ELB</code></dt><dd><p>D-efficiency lower bound. Can not be larger than 1. If negative, see 'Note' in <code><a href="#topic+sensminimax">sensminimax</a></code> or  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.</p>
</dd>
<dt><code>merge_tol</code></dt><dd><p>Merging tolerance to create the answering set from the set of all local optima. See 'Details' in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>crtval</code></dt><dd><p>Criterion value. Compare it with the column <code>Crtiterion_Value</code> in <code>optima</code> for minimax and standardized maximin designs.</p>
</dd>
<dt><code>time</code></dt><dd><p>Used CPU time (rough approximation).</p>
</dd>
</dl>



<h3>Note</h3>

<p>Theoretically, ELB can not be larger than 1. But if so, it may have one of the following reasons:
</p>

<ul>
<li> <p><code>max_deriv</code> is not a GLOBAL maximum.  Please increase  the value of the parameter <code>maxeval</code> in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code> to find the global maximum.
</p>
</li>
<li><p> The sensitivity function is shifted below the y-axis because
the number of model parameters has not been specified correctly (less value given).
Please specify the correct number of model parameters via argument <code>npar</code>.
</p>
</li></ul>

<p>Please increase the value of the parameter
<code>n_seg</code> in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>
for  models with larger number of parameters or large parameter space to find the true
answering set for minimax and standardized maximin designs. See <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code> for more details.
</p>


<h3>References</h3>

<p>Masoudi E, Holling H, Wong W.K. (2017). Application of Imperialist Competitive Algorithm to Find Minimax and Standardized Maximin Optimal Designs. Computational Statistics and Data Analysis, 113, 330-345. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################
# Power logistic model
##########################
# verifying the minimax D-optimality of a design with points x0 and weights w0
x0 &lt;- c(-4.5515, 0.2130, 2.8075)
w0 &lt;- c(0.4100, 0.3723, 0.2177)
# Power logistic model when s = .2
sensminimax(formula =  ~ (1/(1 + exp(-b * (x-a))))^.2,
            predvars = "x",
            parvars = c("a", "b"),
            family = binomial(),
            x = x0, w = w0,
            lx = -5, ux = 5,
            lp = c(0, 1), up = c(3, 1.5))

##############################
# A model with two predictors
##############################
# Verifying the minimax D-optimality of a design for a model with two predictors
# The model is the mixed inhibition model.
# X0 is the vector of four design points that are:
# (3.4614, 0) (4.2801, 3.1426) (30, 0) (30, 4.0373)
x0 &lt;- c(3.4614, 4.2801, 30, 30, 0, 3.1426, 0, 4.0373)
w0 &lt;- rep(1/4, 4)
sensminimax(formula =  ~ V*S/(Km * (1 + I/Kic)+ S * (1 + I/Kiu)),
            predvars = c("S", "I"),
            parvars = c("V", "Km", "Kic", "Kiu"),
            family = "gaussian",
            x = x0, w = w0,
            lx = c(0, 0), ux = c(30, 60),
            lp = c(1, 4, 2, 4), up = c(1, 5, 3, 5))

##########################################
# Standardized maximin D-optimal designs
##########################################
# Verifying the standardized maximin D-optimality of a design for
# the loglinear model
# First we should define the function for 'localdes' argument
# The function LDOD takes the parameters and returns the points and
# weights of the locally D-optimal design
LDOD &lt;- function(theta0, theta1, theta2){
  ## param is the vector of theta = (theta0, theta1, theta2)
  lx &lt;- 0 # lower bound of the design space
  ux &lt;- 150 # upper bound of the design space
  param &lt;- c()
  param[1] &lt;- theta0
  param[2] &lt;- theta1
  param[3] &lt;- theta2
  xstar &lt;- (ux+param[3]) * (lx + param[3]) *
    (log(ux + param[3]) - log(lx + param[3]))/(ux - lx) - param[3]
  return(list(x = c(lx, xstar, ux) , w = rep(1/3, 3)))
}
x0 &lt;- c(0, 4.2494, 17.0324, 149.9090)
w0 &lt;- c(0.3204, 0.1207, 0.2293, 0.3296)
## Not run: 
  sensminimax(formula = ~theta0 + theta1* log(x + theta2),
              predvars = c("x"),
              parvars = c("theta0", "theta1", "theta2"),
              x = x0, w = w0,
              lx = 0, ux = 150,
              lp = c(2, 2, 1), up = c(2, 2, 15),
              localdes = LDOD,
              standardized = TRUE,
              sens.minimax.control = list(n_seg = 10))

## End(Not run)
################################################################
# Not necessary!
# The rest of the examples here are only for professional uses.
################################################################
# Imagine you have written your own FIM, say in Rcpp that is faster than
# the FIM created by the formula interface here.

##########################
# Power logistic model
##########################
# For example, th cpp FIM function for the power logistic model is named:
FIM_power_logistic
args(FIM_power_logistic)
# The arguments do not match the standard of the argument 'fimfunc'
# in 'sensminimax'
# So we reparameterize it:
myfim1 &lt;- function(x, w, param)
  FIM_power_logistic(x = x, w = w, param =param, s = .2)

args(myfim1)
## Not run: 
  # Verify minimax D-optimality of a design
  sensminimax(fimfunc = myfim1,
              x = c(-4.5515, 0.2130, 2.8075),
              w = c(0.4100, 0.3723, 0.2177),
              lx = -5, ux = 5,
              lp = c(0, 1), up = c(3, 1.5))

## End(Not run)
##############################
# A model with two predictors
##############################
# An example of a  model with two-predictors: mixed inhibition model
# Fisher information matrix:
FIM_mixed_inhibition
args(FIM_mixed_inhibition)

# We should first reparameterize the FIM to match the standard of the
# argument 'fimfunc'
myfim2 &lt;- function(x, w, param){
  npoint &lt;- length(x)/2
  S &lt;- x[1:npoint]
  I &lt;- x[(npoint+1):(npoint*2)]
  out &lt;- FIM_mixed_inhibition(S = S, I = I, w = w, param = param)
  return(out)
}
args(myfim2)
## Not run: 
  # Verifyng minimax D-optimality of a design
  sensminimax(fimfunc = myfim2,
              x = c(3.4614, 4.2801, 30, 30, 0, 3.1426, 0, 4.0373),
              w = rep(1/4, 4),
              lx = c(0, 0), ux = c(30, 60),
              lp = c(1, 4, 2, 4), up = c(1, 5, 3, 5))

## End(Not run)

#########################################
# Standardized maximin D-optimal designs
#########################################
# An example of a user-written FIM function:
help(FIM_loglin)
# An example of verfying standardaized maximin D-optimality for a design
# Look how we re-define the function LDOD above
LDOD2 &lt;- function(param){
  ## param is the vector of theta = (theta0, theta1, theta2)
  lx &lt;- 0 # lower bound of the design space
  ux &lt;- 150 # upper bound of the design space
  xstar &lt;- (ux + param[3]) * (lx + param[3]) *
    (log(ux + param[3]) - log(lx + param[3]))/(ux - lx) - param[3]
  return(list(x = c(lx, xstar, ux) , w = rep(1/3, 3)))
}

args(LDOD2)

sensminimax(fimfunc = FIM_loglin,
            x = x0,
            w = w0,
            lx = 0, ux = 150,
            lp = c(2, 2, 1), up = c(2, 2, 15),
            localdes = LDOD2,
            standardized = TRUE)



###################################
# user-defined optimality criterion
##################################
# When the model is defined by the formula interface
# Checking the A-optimality  for the 2PL model.
# the criterion function must have argument x, w fimfunc and the parameters defined in 'parvars'.
# use 'fimfunc' as a function of the design points x,  design weights w and
#  the 'parvars' parameters whenever needed.
Aopt &lt;-function(x, w, a, b, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, a = a, b = b))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a  = a, b = b)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}

sensminimax(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
            parvars = c("a", "b"), family = "binomial",
            lp = c(-2, 1), up = c(2, 1.5),
            crtfunc = Aopt,
            lx = -2, ux = 2,
            sensfunc = Aopt_sens,
            x = c(-2, .0033, 2), w = c(.274, .452, .274))

</code></pre>

<hr>
<h2 id='sensmultiple'>Verifying Optimality of The Multiple Objective Designs for The 4-Parameter Hill Model</h2><span id='topic+sensmultiple'></span>

<h3>Description</h3>

<p>This function uses general equivalence theorem to verify
the optimality of a multiple objective optimal design found for
the 4-Parameter Hill model and  the 4-parameter logistic model.
For more details, See Hyun and Wong (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensmultiple(
  dose,
  w,
  minDose,
  maxDose,
  inipars,
  lambda,
  delta,
  Hill_par = TRUE,
  sens.control = list(),
  calculate_criterion = TRUE,
  plot_sens = TRUE,
  tol = sqrt(.Machine$double.xmin),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sensmultiple_+3A_dose">dose</code></td>
<td>
<p>A vector of design points. It is  either dose values or logarithm of dose values when <code>Hill_par = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_w">w</code></td>
<td>
<p>A vector of design weights.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_mindose">minDose</code></td>
<td>
<p>Minimum dose <code class="reqn">D</code>. For the 4-parameter logistic model, i.e. when <code>Hill_par = FALSE</code>, it is the minimum of <code class="reqn">log(D)</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_maxdose">maxDose</code></td>
<td>
<p>Maximum dose <code class="reqn">D</code>. For the 4-parameter logistic model, i.e. when <code>Hill_par = FALSE</code>, it is the maximum of <code class="reqn">log(D)</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_inipars">inipars</code></td>
<td>
<p>A vector of initial estimates for the vector of parameters  <code class="reqn">(a, b, c, d)</code>.
For the 4-parameter logistic model, i.e. when <code>Hill_par = FALSE</code>,
it is  a vector of initial estimates for <code class="reqn">(\theta_1, \theta_2,\theta_3, \theta_4)</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_lambda">lambda</code></td>
<td>
<p>A vector of relative importance of each of the three criteria,
i.e. <code class="reqn">\lambda = (\lambda_1, \lambda_2, \lambda_3)</code>.
Here <code class="reqn">0 &lt; \lambda_i &lt; 1</code> and  s <code class="reqn">\sum \lambda_i = 1</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_delta">delta</code></td>
<td>
<p>Predetermined meaningful value of the minimum effective dose MED.
When <code class="reqn">\delta &lt; 0 </code>, then <code class="reqn">\theta_2 &gt; 0</code> or when <code class="reqn">\delta &gt; 0</code>, then <code class="reqn">\theta_2 &lt; 0</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_hill_par">Hill_par</code></td>
<td>
<p>Hill model parameterization? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Calculate the criterion? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_tol">tol</code></td>
<td>
<p>Tolerance for finding the general inverse of the Fisher information matrix. Defaults to <code>.Machine$double.xmin</code>.</p>
</td></tr>
<tr><td><code id="sensmultiple_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ELB is a measure of  proximity of a design to the optimal design without knowing the latter.
Given a design, let <code class="reqn">\epsilon</code> be the global maximum
of the sensitivity (derivative) function over <code class="reqn">x \in \chi</code>.
ELB is given by </p>
<p style="text-align: center;"><code class="reqn">ELB = p/(p + \epsilon),</code>
</p>

<p>where <code class="reqn">p</code> is the number of model parameters. Obviously,
calculating ELB requires finding <code class="reqn">\epsilon</code> and
another optimization problem to be solved.
The tuning parameters of this optimization can be regulated via the argument  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
See, for more details, Masoudi et al. (2017).
</p>


<h3>Value</h3>

<p>an object of class <code>sensminimax</code> that is a list with the following elements:
</p>

<dl>
<dt><code>type</code></dt><dd><p>Argument <code>type</code> that is required for print methods.</p>
</dd>
<dt><code>optima</code></dt><dd><p>A <code>matrix</code> that stores all the local optima over the parameter space.
The cost  (criterion) values are stored in a column named <code>Criterion_Value</code>.
The last column (<code>Answering_Set</code>)
shows if the optimum belongs to the answering set (1) or not (0). See 'Details' of <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>mu</code></dt><dd><p>Probability measure on the answering set.
Corresponds to the rows of <code>optima</code> for which the associated row in column <code>Answering_Set</code> is equal to 1.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>max_deriv</code></dt><dd><p>Global maximum of the sensitivity (derivative) function (<code class="reqn">\epsilon</code> in 'Details').</p>
</dd>
<dt><code>ELB</code></dt><dd><p>D-efficiency lower bound. Can not be larger than 1. If negative, see 'Note' in <code><a href="#topic+sensminimax">sensminimax</a></code> or  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.</p>
</dd>
<dt><code>merge_tol</code></dt><dd><p>Merging tolerance to create the answering set from the set of all local optima. See 'Details' in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>crtval</code></dt><dd><p>Criterion value. Compare it with the column <code>Crtiterion_Value</code> in <code>optima</code> for minimax and standardized maximin designs.</p>
</dd>
<dt><code>time</code></dt><dd><p>Used CPU time (rough approximation).</p>
</dd>
</dl>



<h3>Note</h3>

<p>DO NOT use this function to verify  c-optimal designs for estimating 'MED' or 'ED50' (verifying single objective optimal designs) because the results may be unstable.
The reason is that for the c-optimal criterion the generalized inverse of the Fisher information matrix is not stable and depends
on the tolerance value (<code>tol</code>).
</p>
<p>Theoretically, ELB can not be larger than 1. But if so, it may have one of the following reasons:
</p>

<ul>
<li> <p><code>max_deriv</code> is not a GLOBAL maximum.  Please increase  the value of the parameter <code>maxeval</code> in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code> to find the global maximum.
</p>
</li>
<li><p> The sensitivity function is shifted below the y-axis because
the number of model parameters has not been specified correctly (less value given).
Please specify the correct number of model parameters via argument <code>npar</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Hyun, S. W., and Wong, W. K. (2015). Multiple-Objective Optimal Designs for Studying the Dose Response Function and Interesting Dose Levels. The international journal of biostatistics, 11(2), 253-271.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiple">multiple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################################
# Verifying optimality of a design for the 4-parameter Hill model
#################################################################

## initial estiamtes for the parameters of the Hill model
a &lt;- 0.008949  # ED50
b &lt;- -1.79 # Hill constant
c &lt;- 0.137 # lower limit
d &lt;- 1.7 # upper limit
# D belongs to c(.001, 1000) ## dose in mg
## Hill parameters are c(a, b, c, d)
# dose, minDose and maxDose vector in mg scale

sensmultiple (dose = c(0.001, 0.009426562, 0.01973041, 999.9974),
              w =   c(0.4806477, 0.40815, 0.06114173, 0.05006055),
              minDose = .001, maxDose = 1000,
              Hill_par = TRUE,
              inipars = c(a, b, c, d),
              lambda = c(0.05, 0.05, .90),
              delta = -1)






</code></pre>

<hr>
<h2 id='sensrobust'>Verifying Optimality of The Robust Designs</h2><span id='topic+sensrobust'></span>

<h3>Description</h3>

<p>It plots the sensitivity (derivative) function of the
robust criterion
at a given approximate (continuous) design and also
calculates its efficiency lower bound (ELB) with respect
to the optimality criterion.
For an approximate (continuous) design, when the design space is one or two-dimensional,
the user can visually verify the optimality of the design by observing the
sensitivity plot. Furthermore, the proximity of the design to the optimal design
can be measured by the  ELB without knowing the latter.
See, for more details, Masoudi et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensrobust(
  formula,
  predvars,
  parvars,
  family = gaussian(),
  x,
  w,
  lx,
  ux,
  prob,
  parset,
  fimfunc = NULL,
  sens.control = list(),
  calculate_criterion = TRUE,
  plot_3d = c("lattice", "rgl"),
  plot_sens = TRUE,
  npar = dim(parset)[2],
  silent = FALSE,
  crtfunc = NULL,
  sensfunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sensrobust_+3A_formula">formula</code></td>
<td>
<p>A linear or nonlinear model <code><a href="stats.html#topic+formula">formula</a></code>.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a <code><a href="stats.html#topic+formula">formula</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_predvars">predvars</code></td>
<td>
<p>A vector of characters. Denotes the predictors in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_parvars">parvars</code></td>
<td>
<p>A vector of characters. Denotes the unknown parameters in the <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and the link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
Every family function has a link argument allowing to specify the link function to be applied on the response variable.
If not specified, default links are used. For details see <code><a href="stats.html#topic+family">family</a></code>.
By default, a linear gaussian model <code>gaussian()</code> is applied.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_x">x</code></td>
<td>
<p>Vector of the design (support) points. See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code> for models with more than one predictors.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_w">w</code></td>
<td>
<p>Vector of the corresponding design weights for <code>x</code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_lx">lx</code></td>
<td>
<p>Vector of lower bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_ux">ux</code></td>
<td>
<p>Vector of upper bounds for the predictors. Should be in the same order as <code>predvars</code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_prob">prob</code></td>
<td>
<p>A vector of the probability measure <code class="reqn">\pi</code> associated with each row of <code>parset</code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_parset">parset</code></td>
<td>
<p>A matrix that provides the vector of initial estimates for the model parameters, i.e. support of <code class="reqn">\pi</code>.
Every row is one vector  (<code>nrow(parset) == length(prob)</code>). See 'Details'.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_fimfunc">fimfunc</code></td>
<td>
<p>A function. Returns the FIM as a <code>matrix</code>. Required when <code>formula</code> is missing. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_sens.control">sens.control</code></td>
<td>
<p>Control Parameters for Calculating the ELB. For details, see <code><a href="#topic+sens.control">sens.control</a></code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_calculate_criterion">calculate_criterion</code></td>
<td>
<p>Calculate the optimality criterion? See 'Details' of <code><a href="#topic+sensminimax">sensminimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_plot_3d">plot_3d</code></td>
<td>
<p>Which package should be used to plot the sensitivity (derivative) function for models with two predictors.
Either <code>"rgl"</code> or <code>"lattice"</code> (default).</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_plot_sens">plot_sens</code></td>
<td>
<p>Plot the sensitivity (derivative) function? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_npar">npar</code></td>
<td>
<p>Number of model parameters.  Used when <code>fimfunc</code> is given instead of <code>formula</code> to specify the number of model parameters.
If not given, the sensitivity plot may be shifted below the y-axis.
When <code>NULL</code>, it is set to <code>dim(parset)[2]</code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_silent">silent</code></td>
<td>
<p>Do not print anything? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_crtfunc">crtfunc</code></td>
<td>
<p>(Optional) a function that specifies an arbitrary criterion. It must have especial arguments and output. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
<tr><td><code id="sensrobust_+3A_sensfunc">sensfunc</code></td>
<td>
<p>(Optional) a function that specifies the sensitivity function for <code>crtfunc</code>. See 'Details' of <code><a href="#topic+minimax">minimax</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\Theta</code>  be the set initial estimates for the model parameters and <code class="reqn">\pi</code> be a probability measure having support in  <code class="reqn">\Theta</code>.
A design <code class="reqn">\xi^*</code> is robust with respect to  <code class="reqn">\pi</code>
if the following inequality holds for all <code class="reqn">\boldsymbol{x} \in \chi</code>:
</p>
<p style="text-align: center;"><code class="reqn">c(\boldsymbol{x}, \pi, \xi^*) = \int_{\pi} tr M^{-1}(\xi^*, \theta)I(\boldsymbol{x}, \theta)\pi(\theta) d(\theta)-p \leq 0,</code>
</p>

<p>with equality at all support points of <code class="reqn">\xi^*</code>.
Here, <code class="reqn">p</code> is the number of model parameters.
</p>
<p>ELB is a measure of  proximity of a design to the optimal design without knowing the latter.
Given a design, let <code class="reqn">\epsilon</code> be the global maximum
of the sensitivity (derivative) function over <code class="reqn">x \in \chi</code>.
ELB is given by </p>
<p style="text-align: center;"><code class="reqn">ELB = p/(p + \epsilon),</code>
</p>

<p>where <code class="reqn">p</code> is the number of model parameters. Obviously,
calculating ELB requires finding <code class="reqn">\epsilon</code> and
another optimization problem to be solved.
The tuning parameters of this optimization can be regulated via the argument  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
</p>


<h3>Value</h3>

<p>an object of class <code>sensminimax</code> that is a list with the following elements:
</p>

<dl>
<dt><code>type</code></dt><dd><p>Argument <code>type</code> that is required for print methods.</p>
</dd>
<dt><code>optima</code></dt><dd><p>A <code>matrix</code> that stores all the local optima over the parameter space.
The cost  (criterion) values are stored in a column named <code>Criterion_Value</code>.
The last column (<code>Answering_Set</code>)
shows if the optimum belongs to the answering set (1) or not (0). See 'Details' of <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>mu</code></dt><dd><p>Probability measure on the answering set.
Corresponds to the rows of <code>optima</code> for which the associated row in column <code>Answering_Set</code> is equal to 1.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>max_deriv</code></dt><dd><p>Global maximum of the sensitivity (derivative) function (<code class="reqn">\epsilon</code> in 'Details').</p>
</dd>
<dt><code>ELB</code></dt><dd><p>D-efficiency lower bound. Can not be larger than 1. If negative, see 'Note' in <code><a href="#topic+sensminimax">sensminimax</a></code> or  <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.</p>
</dd>
<dt><code>merge_tol</code></dt><dd><p>Merging tolerance to create the answering set from the set of all local optima. See 'Details' in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code>.
Only applicable for minimax or standardized maximin designs.</p>
</dd>
<dt><code>crtval</code></dt><dd><p>Criterion value. Compare it with the column <code>Crtiterion_Value</code> in <code>optima</code> for minimax and standardized maximin designs.</p>
</dd>
<dt><code>time</code></dt><dd><p>Used CPU time (rough approximation).</p>
</dd>
</dl>



<h3>Note</h3>

<p>Theoretically, ELB can not be larger than 1. But if so, it may have one of the following reasons:
</p>

<ul>
<li> <p><code>max_deriv</code> is not a GLOBAL maximum.  Please increase  the value of the parameter <code>maxeval</code> in <code><a href="#topic+sens.minimax.control">sens.minimax.control</a></code> to find the global maximum.
</p>
</li>
<li><p> The sensitivity function is shifted below the y-axis because
the number of model parameters has not been specified correctly (less value given).
Please specify the correct number of model parameters via the argument <code>npar</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bayes">bayes</a></code> <code><a href="#topic+sensbayes">sensbayes</a></code> <code><a href="#topic+robust">robust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Verifying a robust design for the two-parameter logistic model
sensrobust(formula = ~1/(1 + exp(-b *(x - a))),
           predvars = c("x"),
           parvars = c("a", "b"),
           family = binomial(),
           prob = rep(1/4, 4),
           parset = matrix(c(0.5, 1.5, 0.5, 1.5, 4.0, 4.0, 5.0, 5.0), 4, 2),
           x = c(0.260, 1, 1.739), w = c(0.275, 0.449, 0.275),
           lx = -5, ux = 5)


###################################
# user-defined optimality criterion
##################################
# When the model is defined by the formula interface
# Checking the A-optimality  for the 2PL model.
# the criterion function must have argument x, w fimfunc and the parameters defined in 'parvars'.
# use 'fimfunc' as a function of the design points x,  design weights w and
#  the 'parvars' parameters whenever needed.
Aopt &lt;-function(x, w, a, b, fimfunc){
  sum(diag(solve(fimfunc(x = x, w = w, a = a, b = b))))
}
## the sensitivtiy function
# xi_x is a design that put all its mass on x in the definition of the sensitivity function
# x is a vector of design points
Aopt_sens &lt;- function(xi_x, x, w, a, b, fimfunc){
  fim &lt;- fimfunc(x = x, w = w, a = a, b = b)
  M_inv &lt;- solve(fim)
  M_x &lt;- fimfunc(x = xi_x, w = 1, a  = a, b = b)
  sum(diag(M_inv %*% M_x %*%  M_inv)) - sum(diag(M_inv))
}

sensrobust(formula = ~1/(1 + exp(-b * (x-a))), predvars = "x",
           parvars = c("a", "b"), family = "binomial",
           crtfunc = Aopt,
           sensfunc = Aopt_sens,
           lx = -3, ux = 3,
           prob = c(.25, .5, .25),
           parset = matrix(c(-2, 0, 2, 1.25, 1.25, 1.25), 3, 2),
           x = c(-2.469, 0, 2.469), w = c(.317, .365, .317))
# not optimal. the optimal design has four points. see the last example in ?robust
</code></pre>

<hr>
<h2 id='skewnormal'>Assumes A Multivariate Skewed Normal Prior Distribution for The Model Parameters</h2><span id='topic+skewnormal'></span>

<h3>Description</h3>

<p>Creates a multivariate skewed normal prior distribution for the unknown parameters as an object of class <code>cprior</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewnormal(xi, Omega, alpha, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewnormal_+3A_xi">xi</code></td>
<td>
<p>A numeric vector of length <code>d=length(alpha)</code> representing the location parameter of the distribution. For more details, see 'Background' in  <code><a href="sn.html#topic+dmsn">dmsn</a></code>.</p>
</td></tr>
<tr><td><code id="skewnormal_+3A_omega">Omega</code></td>
<td>
<p>A symmetric positive-definite matrix of dimension <code>(d,d)</code>. For more details, see 'Background' in <code><a href="sn.html#topic+dmsn">dmsn</a></code>.</p>
</td></tr>
<tr><td><code id="skewnormal_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector which regulates the slant of the density. For more details, see 'Background' in <code><a href="sn.html#topic+dmsn">dmsn</a></code>.</p>
</td></tr>
<tr><td><code id="skewnormal_+3A_lower">lower</code></td>
<td>
<p>A vector of lower bounds  for the model parameters.</p>
</td></tr>
<tr><td><code id="skewnormal_+3A_upper">upper</code></td>
<td>
<p>A vector of upper bounds  for the model parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cprior</code> that is a  list with the following components:
</p>

<ul>
<li><p><code>fn</code>: prior distribution as an R <code>function</code> with argument <code>param</code> that is the vector of the unknown parameters. See below.
</p>
</li>
<li><p><code>npar</code>: Number of unknown parameters and is equal to the length of <code>param</code>.
</p>
</li>
<li><p><code>lower</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li>
<li><p><code>upper</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li></ul>

<p>The list will be passed to the argument <code>prior</code> of the function <code><a href="#topic+bayes">bayes</a></code>.
The order of the argument <code>param</code> in <code>fn</code> has the same order as the argument <code>parvars</code> when the model is specified by a formula.
Otherwise, it is equal to the argument <code>param</code> in the function <code>fimfunc</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes">bayes</a></code> <code><a href="#topic+sensbayes">sensbayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skewnormal(xi = c(0, 1),
 Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
  alpha = c(1, 0), lower =  c(-3, .1), upper = c(3, 2))
</code></pre>

<hr>
<h2 id='student'>Multivariate Student's t Prior Distribution for Model Parameters</h2><span id='topic+student'></span>

<h3>Description</h3>

<p>Creates the prior distribution for the parameters as an object of class <code>cprior</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>student(mean, S, df, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="student_+3A_mean">mean</code></td>
<td>
<p>A vector of length <code>d=ncol(S)</code>, representing the location parameter (equal to the mean vector when <code>df&gt;1</code>). For more details, see 'Arguments' in  <code><a href="mnormt.html#topic+dmt">dmt</a></code>.</p>
</td></tr>
<tr><td><code id="student_+3A_s">S</code></td>
<td>
<p>A symmetric positive-definite matrix representing the scale matrix of the distribution, such that <code>S*df/(df-2)</code> is the variance-covariance matrix when <code>df&gt;2</code>. For more details, see 'Arguments' in <code><a href="mnormt.html#topic+dmt">dmt</a></code>.</p>
</td></tr>
<tr><td><code id="student_+3A_df">df</code></td>
<td>
<p>Degrees of freedom; it must be a positive integer. For more details, see 'Arguments' in <code><a href="mnormt.html#topic+dmt">dmt</a></code>.</p>
</td></tr>
<tr><td><code id="student_+3A_lower">lower</code></td>
<td>
<p>A vector of lower bounds  for the model parameters.</p>
</td></tr>
<tr><td><code id="student_+3A_upper">upper</code></td>
<td>
<p>A vector of upper bounds  for the model parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cprior</code> that is a  list with the following components:
</p>

<ul>
<li><p><code>fn</code>: prior distribution as an R <code>function</code> with argument <code>param</code> that is the vector of the unknown parameters. See below.
</p>
</li>
<li><p><code>npar</code>: Number of unknown parameters and is equal to the length of <code>param</code>.
</p>
</li>
<li><p><code>lower</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li>
<li><p><code>upper</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li></ul>

<p>The list will be passed to the argument <code>prior</code> of the function <code><a href="#topic+bayes">bayes</a></code>.
The order of the argument <code>param</code> in <code>fn</code> has the same order as the argument <code>parvars</code> when the model is specified by a formula.
Otherwise, it is equal to the argument <code>param</code> in the function <code>fimfunc</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes">bayes</a></code> <code><a href="#topic+sensbayes">sensbayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skewnormal(xi = c(0, 1),
 Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
  alpha = c(1, 0), lower =  c(-3, .1), upper = c(3, 2))
</code></pre>

<hr>
<h2 id='uniform'>Assume A Multivariate Uniform Prior Distribution for The Model Parameters</h2><span id='topic+uniform'></span>

<h3>Description</h3>

<p>Creates independent uniform prior distributions for the unknown model parameters as an object of class <code>cprior</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform(lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniform_+3A_lower">lower</code></td>
<td>
<p>A vector of lower bounds  for the model parameters.</p>
</td></tr>
<tr><td><code id="uniform_+3A_upper">upper</code></td>
<td>
<p>A vector of upper bounds  for the model parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cprior</code> that is a  list with the following components:
</p>

<ul>
<li><p><code>fn</code>: prior distribution as an R <code>function</code> with argument <code>param</code> that is the vector of the unknown parameters. See below.
</p>
</li>
<li><p><code>npar</code>: Number of unknown parameters and is equal to the length of <code>param</code>.
</p>
</li>
<li><p><code>lower</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li>
<li><p><code>upper</code>: Argument <code>lower</code>. It has the same length as <code>param</code>.
</p>
</li></ul>

<p>The list will be passed to the argument <code>prior</code> of the function <code><a href="#topic+bayes">bayes</a></code>.
The order of the argument <code>param</code> in <code>fn</code> has the same order as the argument <code>parvars</code> when the model is specified by a formula.
Otherwise, it is equal to the argument <code>param</code> in the function <code>fimfunc</code>.
</p>


<h3>Note</h3>

<p>The order of the argument <code>param</code> in <code>fn</code> has the same order as the argument <code>parvars</code> when the model is specified by a formula.
Otherwise, it is the same as the argument <code>param</code> in the function <code>fimfunc</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes">bayes</a></code> <code><a href="#topic+sensbayes">sensbayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uniform(lower =  c(-3, .1), upper = c(3, 2))
</code></pre>

<hr>
<h2 id='update.minimax'>Updating an Object of Class <code>minimax</code></h2><span id='topic+update.minimax'></span>

<h3>Description</h3>

<p>Runs the ICA optimization algorithm on an object of class <code>minimax</code> for more number of iterations  and updates the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'minimax'
update(object, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.minimax_+3A_object">object</code></td>
<td>
<p>An object of class <code>minimax</code>.</p>
</td></tr>
<tr><td><code id="update.minimax_+3A_iter">iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="update.minimax_+3A_...">...</code></td>
<td>
<p>An argument of no further use.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+minimax">minimax</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
