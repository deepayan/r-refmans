<!DOCTYPE html><html lang="en"><head><title>Help for package sets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#canonicalize+20set+20and+20mapping'><p>Canonicalize set and mapping</p></a></li>
<li><a href='#closure'><p>Closure and reduction</p></a></li>
<li><a href='#cset'><p>Customizable sets</p></a></li>
<li><a href='#fuzzy'><p>Fuzzy logic</p></a></li>
<li><a href='#fuzzydocs'><p>Documents on Fuzzy Theory</p></a></li>
<li><a href='#fuzzyfuns'><p>Fuzzy membership functions</p></a></li>
<li><a href='#fuzzyinference'><p>Fuzzy inference</p></a></li>
<li><a href='#gset'><p>Generalized sets</p></a></li>
<li><a href='#interval'><p>Intervals</p></a></li>
<li><a href='#labels'><p>Labels from objects</p></a></li>
<li><a href='#options'><p>Options for the &lsquo;sets&rsquo; package</p></a></li>
<li><a href='#outer'><p>Outer Product of Sets (Tuples)</p></a></li>
<li><a href='#plot'><p>Plot functions for generalized sets</p></a></li>
<li><a href='#set'><p>Sets</p></a></li>
<li><a href='#sets-internal'><p>Internal</p></a></li>
<li><a href='#similarity'><p>Similarity and Dissimilarity Functions</p></a></li>
<li><a href='#tuple'><p>Tuples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Sets, Generalized Sets, Customizable Sets and Intervals</td>
</tr>
<tr>
<td>Description:</td>
<td>Data structures and basic operations for ordinary sets,
             generalizations such as fuzzy sets, multisets, and
             fuzzy multisets, customizable sets, and intervals.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.7.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>proxy</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics,grDevices,stats,utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 17:39:41 UTC; meyer</td>
</tr>
<tr>
<td>Author:</td>
<td>David Meyer <a href="https://orcid.org/0000-0002-5196-3048"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Christian Buchta [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Meyer &lt;David.Meyer@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 09:22:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='canonicalize+20set+20and+20mapping'>Canonicalize set and mapping</h2><span id='topic+canonicalize_set_and_mapping'></span>

<h3>Description</h3>

<p>Helper function that canonicalizes set elements, and
possibly reorders a given mapping accordingly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>canonicalize_set_and_mapping(x, mapping = NULL, margin = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="canonicalize+2B20set+2B20and+2B20mapping_+3A_x">x</code></td>
<td>
<p>An object to be transformed into a set.</p>
</td></tr>
<tr><td><code id="canonicalize+2B20set+2B20and+2B20mapping_+3A_mapping">mapping</code></td>
<td>
<p>A list, array or data frame representing a mapping of the set.</p>
</td></tr>
<tr><td><code id="canonicalize+2B20set+2B20and+2B20mapping_+3A_margin">margin</code></td>
<td>
<p>Margins to be reordered (ignored if <code>mapping</code> is a
list). If <code>NULL</code>, all margins with the same length of <code>x</code>
will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This helper function can be used when a set is to be created from some
object <code>x</code>, and another object contains some meta-information
on the set elements in the same order than the elements
of <code>x</code>. The set creation can cause the input elements to be
permuted. By the use of this function, the meta information can be kept in
sync with the result of iterating over the associated set.
</p>


<h3>Value</h3>

<p>A list with three named components:
</p>
<table role = "presentation">
<tr><td><code>set</code></td>
<td>
<p>The set created from <code>x</code>.</p>
</td></tr>
<tr><td><code>mapping</code></td>
<td>
<p><code>mapping</code>, possibly reordered to match the order
of <code>set</code>.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>The order used for rearranging the mapping.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- list(c, "a", 3)
M1 &lt;- list("a","b","c")
M2 &lt;- matrix(1:9, ncol = 3)
canonicalize_set_and_mapping(L, M1)
canonicalize_set_and_mapping(L, M2)
canonicalize_set_and_mapping(L, M2, 1)
</code></pre>

<hr>
<h2 id='closure'>Closure and reduction</h2><span id='topic+closure'></span><span id='topic+closure.set'></span><span id='topic+binary_closure'></span><span id='topic+reduction'></span><span id='topic+reduction.set'></span><span id='topic+binary_reduction'></span>

<h3>Description</h3>

<p>Closure and reduction of (g)sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'set'
closure(x, operation = c("union", "intersection"), ...)
binary_closure(x, operation = c("union", "intersection"))
## S3 method for class 'set'
reduction(x, operation = c("union", "intersection"), ...)
binary_reduction(x, operation = c("union", "intersection"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closure_+3A_x">x</code></td>
<td>
<p>For <code>binary_closure</code> and <code>binary_reduction</code>: a
binary matrix.  A set of (g)sets otherwise.</p>
</td></tr>
<tr><td><code id="closure_+3A_operation">operation</code></td>
<td>
<p>The set operation under which the closure or
reduction shall be computed.</p>
</td></tr>
<tr><td><code id="closure_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The closure of a set <code class="reqn">S</code> under some operation <code class="reqn">OP</code>
contains all elements
of <code class="reqn">S</code>, and the results of <code class="reqn">OP</code> applied to all element pairs
of  <code class="reqn">S</code>.
</p>
<p>The reduction of a set <code class="reqn">S</code> under some operation <code class="reqn">OP</code>
is the minimal subset
of <code class="reqn">S</code> having the same closure than <code class="reqn">S</code> under <code class="reqn">OP</code>.
</p>
<p>Note that the closure and reduction methods for sets
are currently only implemented for sets of <em>(g)sets</em> (families)
and will give an error for other cases.
</p>
<p><code>binary_closure</code> and <code>binary_reduction</code>
interface efficient C code for computing
closures and reductions of binary patterns.
They are used by the
high-level methods if <code>x</code> contains only objects of class <code>sets</code>.
</p>


<h3>Value</h3>

<p>An object of same type than <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>The C code for binary closures is provided by Christian Buchta.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code>, <code><a href="#topic+gset">gset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ordinary set
s &lt;- set(set(1),set(2),set(3))
(cl &lt;- closure(s))
(re &lt;- reduction(cl))
stopifnot(s == re)

(cl &lt;- closure(s, "intersection"))
(re &lt;- reduction(cl, "intersection"))
stopifnot(s == re)

## multi set
s &lt;- set(gset(1,1),gset(2,2),gset(3,3))
(cl &lt;- closure(s))
(re &lt;- reduction(cl))
stopifnot(s == re)

## fuzzy set
s &lt;- set(gset(1,1/3),gset(2,2/3),gset(3,3/3))
(cl &lt;- closure(s))
(re &lt;- reduction(cl))
stopifnot(s == re)

## fuzzy multiset
s &lt;- set(gset(1,list(set(1,0.8))), gset(2, list(gset(1,3))), gset(3,0.3))
(cl &lt;- closure(s))
(re &lt;- reduction(cl))
stopifnot(s == re)
</code></pre>

<hr>
<h2 id='cset'>Customizable sets</h2><span id='topic+cset'></span><span id='topic+as.cset'></span><span id='topic+is.cset'></span><span id='topic+cset_is_empty'></span><span id='topic+cset_is_subset'></span><span id='topic+cset_is_proper_subset'></span><span id='topic+cset_is_equal'></span><span id='topic+cset_contains_element'></span><span id='topic+cset_core'></span><span id='topic+cset_peak'></span><span id='topic+cset_universe'></span><span id='topic+cset_bound'></span><span id='topic+cset_height'></span><span id='topic+cset_union'></span><span id='topic+cset_sum'></span><span id='topic+cset_difference'></span><span id='topic+cset_product'></span><span id='topic+cset_mean'></span><span id='topic+cset_intersection'></span><span id='topic+cset_symdiff'></span><span id='topic+cset_complement'></span><span id='topic+cset_power'></span><span id='topic+cset_cartesian'></span><span id='topic+cset_combn'></span><span id='topic+cset_cardinality'></span><span id='topic+cset_charfun'></span><span id='topic+cset_memberships'></span><span id='topic+cset_transform_memberships'></span><span id='topic+cset_concentrate'></span><span id='topic+cset_dilate'></span><span id='topic+cset_normalize'></span><span id='topic+cset_defuzzify'></span><span id='topic+cset_support'></span><span id='topic+cset_is_crisp'></span><span id='topic+cset_is_fuzzy_set'></span><span id='topic+cset_is_multiset'></span><span id='topic+cset_is_set_or_fuzzy_set'></span><span id='topic+cset_is_set_or_multiset'></span><span id='topic+cset_is_fuzzy_multiset'></span><span id='topic+cset_is_set'></span><span id='topic+cset_has_missings'></span><span id='topic+length.cset'></span><span id='topic+lengths.cset'></span><span id='topic+matchfun'></span><span id='topic+mean.cset'></span><span id='topic+median.cset'></span><span id='topic+cut.cset'></span><span id='topic+cset_orderfun'></span><span id='topic+cset_matchfun'></span><span id='topic+cset_orderfun+3C-'></span><span id='topic+cset_matchfun+3C-'></span>

<h3>Description</h3>

<p>Creation and manipulation of customizable sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cset(gset,
     orderfun = sets_options("orderfun"),
     matchfun = sets_options("matchfun"))
cset_support(x)
cset_core(x, na.rm = FALSE)
cset_peak(x, na.rm = FALSE)
cset_height(x, na.rm = FALSE)
cset_memberships(x, filter = NULL)
cset_universe(x)
cset_bound(x)

cset_transform_memberships(x, FUN, ...)
cset_concentrate(x)
cset_dilate(x)
cset_normalize(x, height = 1)
cset_defuzzify(x,
               method = c("meanofmax", "smallestofmax",
                          "largestofmax", "centroid"))

matchfun(FUN)

cset_orderfun(x)
cset_matchfun(x)
cset_orderfun(x) &lt;- value
cset_matchfun(x) &lt;- value

as.cset(x)
is.cset(x)

cset_is_empty(x, na.rm = FALSE)
cset_is_subset(x, y, na.rm = FALSE)
cset_is_proper_subset(x, y, na.rm = FALSE)
cset_is_equal(x, y, na.rm = FALSE)
cset_contains_element(x, e)

cset_is_set(x, na.rm = FALSE)
cset_is_multiset(x, na.rm = FALSE)
cset_is_fuzzy_set(x, na.rm = FALSE)
cset_is_set_or_multiset(x, na.rm = FALSE)
cset_is_set_or_fuzzy_set(x, na.rm = FALSE)
cset_is_fuzzy_multiset(x)
cset_is_crisp(x, na.rm = FALSE)
cset_has_missings(x)

cset_cardinality(x, type = c("absolute", "relative"), na.rm = FALSE)
cset_union(...)
cset_mean(x, y, type = c("arithmetic", "geometric", "harmonic"))
cset_product(...)
cset_difference(...)
cset_intersection(...)
cset_symdiff(...)
cset_complement(x, y)
cset_power(x)
cset_cartesian(...)
cset_combn(x, m)

## S3 method for class 'cset'
cut(x, level = 1, type = c("alpha", "nu"), strict = FALSE, ...)
## S3 method for class 'cset'
mean(x, ..., na.rm = FALSE)
## S3 method for class 'cset'
## median(x, na.rm = FALSE, ...)     [R &gt;= 3.4.0]
## median(x, na.rm)                  [R &lt; 3.4.0]
## S3 method for class 'cset'
length(x)
## S3 method for class 'cset'
lengths(x, use.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cset_+3A_x">x</code></td>
<td>
<p>For <code>as.cset()</code> and <code>is.cset()</code>:
an <span class="rlang"><b>R</b></span> object. A (c)set object otherwise.</p>
</td></tr>
<tr><td><code id="cset_+3A_y">y</code></td>
<td>
<p>A (c)set object.</p>
</td></tr>
<tr><td><code id="cset_+3A_gset">gset</code></td>
<td>
<p>A generalized set (or some other <span class="rlang"><b>R</b></span> object coercible to it).</p>
</td></tr>
<tr><td><code id="cset_+3A_matchfun">matchfun</code></td>
<td>
<p>A function for matching similar elements, comparable 
to <code><a href="base.html#topic+match">match</a></code>, taking two arguments: <code>x</code> (vector of
elements to be matched) and <code>table</code> (vector of elements to be
matched against). The return value is an integer vector of the
matching positions (or <code>NA</code> if there is no match).
Note that the default behavior is to test for <em>identity</em>.</p>
</td></tr>
<tr><td><code id="cset_+3A_fun">FUN</code></td>
<td>
<p>A predicate testing for equality of two objects.</p>
</td></tr>
<tr><td><code id="cset_+3A_orderfun">orderfun</code></td>
<td>
<p>A function taking a list and returning an integer vector,
specifying the order in which an iterator processes the set
elements. Alternatively, the index vector can be specified directly.</p>
</td></tr>
<tr><td><code id="cset_+3A_value">value</code></td>
<td>
<p>A new match function (order function).</p>
</td></tr>
<tr><td><code id="cset_+3A_type">type</code></td>
<td>
<p>For <code>gset_cardinality()</code>:
cardinality type (either <code>"absolute"</code> or
<code>"relative"</code>). For <code>gset_mean()</code>: mean type
(<code>"arithmetic"</code>, <code>"geometric"</code>, or <code>"harmonic"</code>).
For <code>"cut"</code>: either <code>"alpha"</code> or <code>"nu"</code>.</p>
</td></tr>
<tr><td><code id="cset_+3A_strict">strict</code></td>
<td>
<p>Logical indicating whether the cut level must be 
exceeded strictly (&ldquo;greater than&rdquo;) or not (&ldquo;greater
than or equal&rdquo;).</p>
</td></tr>
<tr><td><code id="cset_+3A_height">height</code></td>
<td>
<p>Double from the unit interval for scaling memberships.</p>
</td></tr>
<tr><td><code id="cset_+3A_e">e</code></td>
<td>
<p>An object of class <code>element</code>.</p>
</td></tr>
<tr><td><code id="cset_+3A_filter">filter</code></td>
<td>
<p>Optional vector of elements to be filtered.</p>
</td></tr>
<tr><td><code id="cset_+3A_m">m</code></td>
<td>
<p>Number of elements to choose.</p>
</td></tr>
<tr><td><code id="cset_+3A_method">method</code></td>
<td>
<p>Currently, only <code>"Jaccard"</code> is implemented.</p>
</td></tr>
<tr><td><code id="cset_+3A_level">level</code></td>
<td>
<p>The minimum membership level.</p>
</td></tr>
<tr><td><code id="cset_+3A_use.names">use.names</code></td>
<td>
<p>logical; should the names of <code>x</code> be used in the result?</p>
</td></tr>
<tr><td><code id="cset_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be
removed.</p>
</td></tr>
<tr><td><code id="cset_+3A_...">...</code></td>
<td>
<p>For <code>cset_<var>foo</var>()</code>: (c)set objects. For
the mean and sort methods: additional parameters internally passed to
<code><a href="base.html#topic+mean">mean</a></code> and <code><a href="base.html#topic+order">order</a></code>, respectively. For
<code>gset_transform_memberships</code>: further arguments passed to
<code>FUN</code>. For <code>cut</code>: currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Customizable sets extend generalized sets in two ways: First, users
can control the way elements are matched, i.e., define equivalence
classes of elements. Second, an order function (or permutation index)
can be specified for each set for changing the order in which
iterators such as <code>as.list</code> process the elements. The latter in
particular influences the labeling and print methods for
customizable sets.
</p>
<p>The match function needs to be vectorized in a similar way than
<code><a href="base.html#topic+match">match</a></code>. <code>matchfun</code> can be used to create such a
function from a &ldquo;simple&rdquo; predicate testing for equality
(such as, e.g., <code><a href="base.html#topic+identical">identical</a></code>). Make sure, however, to
create the same function only once.
</p>
<p>Note that operations on customizable sets require the same match
function for all sets involved. The order function can differ, but
will then be stripped from the result.
</p>
<p><code>sets_options</code> can be used to
conveniently switch the default match and/or
order function if a number of <code>cset</code> objects need to be created.
</p>


<h3>References</h3>

<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1&ndash;27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code> for (&ldquo;ordinary&rdquo;) sets, 
<code><a href="#topic+gset">gset</a></code> for generalized sets, 
<code><a href="#topic+cset_outer">cset_outer</a></code>, and
<code><a href="#topic+tuple">tuple</a></code> for tuples (&ldquo;vectors&rdquo;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default behavior of sets: matching of elements is very strict
## Note that on most systems, 3.3 - 2.2 != 1.1
x &lt;- set("1", 1L, 1, 3.3 - 2.2, 1.1)
print(x)

y &lt;- set(1, 1.1, 2L, "2")
print(y)
1L %e% y

set_union(x, y)
set_intersection(x, y)
set_complement(x, y)

## Now use the more sloppy match()-function. 
## Note that 1 == "1" == 1L ...
X &lt;- cset(x, matchfun = match)
print(X)
Y &lt;- cset(y, matchfun = match)
print(Y)
1L %e% Y

cset_union(X, Y)
cset_intersection(X, Y)
cset_complement(X, Y)

## Same using all.equal().
## This is a non-vectorized predicate, so use matchfun
## to generate a vectorized version:
FUN &lt;- matchfun(function(x, y) isTRUE(all.equal(x, y)))
X &lt;- cset(x, matchfun = FUN)
print(X)
Y &lt;- cset(y, matchfun = FUN)
print(Y)
1L %e% Y

cset_union(X, Y)
cset_intersection(X, Y)
cset_complement(X, Y)

### change default functions via set_option
sets_options("matchfun", match)
cset(x)
cset(y)

cset(1:3) &lt;= cset(c(1,2,3))

### restore package defaults
sets_options("matchfun", NULL)

### customized order function
FUN &lt;- function(x) order(as.character(x), decreasing = TRUE)
Z &lt;- cset(letters[1:5], orderfun = FUN)
print(Z)
as.character(Z)

## converter for ordered factors keeps order
o &lt;- ordered(c("a", "b", "a"), levels = c("b", "a"))
as.set(o)
as.cset(o)

## converter for other data types keep order if the elements are unique:
as.cset(c("A", "quick", "brown", "fox"))
as.cset(c("A", "quick", "brown", "fox", "quick"))
</code></pre>

<hr>
<h2 id='fuzzy'>Fuzzy logic</h2><span id='topic+.N.'></span><span id='topic+.T.'></span><span id='topic+.S.'></span><span id='topic+.I.'></span><span id='topic+fuzzy_logic'></span>

<h3>Description</h3>

<p>Fuzzy Logic</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_logic(new, ...)
.N.(x)
.T.(x, y)
.S.(x, y)
.I.(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzy_+3A_x">x</code>, <code id="fuzzy_+3A_y">y</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
<tr><td><code id="fuzzy_+3A_new">new</code></td>
<td>
<p>A character string specifying one of the available fuzzy
logic &ldquo;families&rdquo; (see details).</p>
</td></tr>
<tr><td><code id="fuzzy_+3A_...">...</code></td>
<td>
<p>optional parameters for the selected family.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call to <code>fuzzy_logic()</code> without arguments returns the currently
set fuzzy logic, i.e., a named list with four
components <code>N</code>, <code>T</code>, <code>S</code>, and <code>I</code> containing the
corresponding functions for negation, conjunction
(&ldquo;t-norm&rdquo;), disjunction (&ldquo;t-conorm&rdquo;), and residual
implication (which may not be available).
</p>
<p>The package provides several fuzzy logic <em>families</em>.
A concrete fuzzy logic is selected 
by calling <code>fuzzy_logic</code> with a character
string specifying the family name, and optional parameters.  Let us
refer to <code class="reqn">N(x) = 1 - x</code> as the <em>standard</em> negation, and,
for a t-norm <code class="reqn">T</code>, let <code class="reqn">S(x, y) = 1 - T(1 - x, 1 - y)</code> be the
<em>dual</em> (or complementary) t-conorm.  Available specifications and
corresponding families are as follows, with the standard negation used
unless stated otherwise.
</p>

<dl>
<dt><code>"Zadeh"</code></dt><dd><p>Zadeh's logic with <code class="reqn">T = \min</code> and
<code class="reqn">S = \max</code>.  Note that the minimum t-norm, also known as the
Gödel t-norm, is the pointwise largest t-norm, and that the
maximum t-conorm is the smallest t-conorm.</p>
</dd>
<dt><code>"drastic"</code></dt><dd><p>the drastic logic with t-norm
<code class="reqn">T(x, y) = y</code> if <code class="reqn">x = 1</code>, <code class="reqn">x</code> if <code class="reqn">y = 1</code>, and 0
otherwise, and complementary t-conorm <code class="reqn">S(x, y) = y</code> if
<code class="reqn">x = 0</code>, <code class="reqn">x</code> if <code class="reqn">y = 0</code>, and 1 otherwise.  Note that
the drastic t-norm and t-conorm are the smallest t-norm and
largest t-conorm, respectively.</p>
</dd>
<dt><code>"product"</code></dt><dd><p>the family with the product t-norm
<code class="reqn">T(x, y) = xy</code> and dual t-conorm <code class="reqn">S(x, y) = x + y - xy</code>.</p>
</dd> 
<dt><code>"Lukasiewicz"</code></dt><dd><p>the Lukasiewicz logic with t-norm
<code class="reqn">T(x, y) = \max(0, x + y - 1)</code> and dual t-conorm
<code class="reqn">S(x, y) = \min(x + y, 1)</code>.</p>
</dd>
<dt><code>"Fodor"</code></dt><dd><p>the family with Fodor's <em>nilpotent
minimum</em> t-norm given by <code class="reqn">T(x, y) = \min(x, y)</code> if
<code class="reqn">x + y &gt; 1</code>, and 0 otherwise, and the dual t-conorm given by
<code class="reqn">S(x, y) = \max(x, y)</code> if <code class="reqn">x + y &lt; 1</code>, and 1 otherwise.</p>
</dd>
<dt><code>"Frank"</code></dt><dd><p>the family of Frank t-norms <code class="reqn">T_p</code>,
<code class="reqn">p \ge 0</code>, which gives the Zadeh, product and Lukasiewicz
t-norms for <code class="reqn">p = 0</code>, 1, and <code class="reqn">\infty</code>, respectively,
and otherwise is given by 
<code class="reqn">T(x, y) = \log_p (1 + (p^x - 1) (p^y - 1) / (p - 1))</code>.</p>
</dd>
<dt><code>"Hamacher"</code></dt><dd><p>the three-parameter family of Hamacher,
with negation <code class="reqn">N_\gamma(x) = (1 - x) / (1 + \gamma x)</code>,
t-norm
<code class="reqn">T_\alpha(x, y) = xy / (\alpha + (1 - \alpha)(x + y - xy))</code>,
and t-conorm
<code class="reqn">S_\beta(x, y) = (x + y + (\beta - 1) xy) / (1 + \beta xy)</code>,
where <code class="reqn">\alpha \ge 0</code> and <code class="reqn">\beta, \gamma \ge -1</code>.  This
gives a deMorgan triple (for which <code class="reqn">N(S(x, y)) = T(N(x), N(y))</code>
iff <code class="reqn">\alpha = (1 + \beta) / (1 + \gamma)</code>.  The parameters can
be specified as <code>alpha</code>, <code>beta</code> and <code>gamma</code>,
respectively.  If <code class="reqn">\alpha</code> is not given, it is taken as
<code class="reqn">\alpha = (1 + \beta) / (1 + \gamma)</code>. 
The default values for <code class="reqn">\beta</code> and <code class="reqn">\gamma</code> are 0, so that
by default, the product family is obtained.</p>
</dd>
</dl>

<p>The following parametric families are obtained by combining the
corresponding families of t-norms with the standard negation.
</p>

<dl>
<dt><code>"Schweizer-Sklar"</code></dt><dd><p>the Schweizer-Sklar family
<code class="reqn">T_p</code>, <code class="reqn">-\infty \le p \le \infty</code>, which
gives the Zadeh (minimum), product and drastic t-norms for
<code class="reqn">p = -\infty</code>, <code class="reqn">0</code>, and <code class="reqn">\infty</code>,
respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \max(0, (x^p + y^p - 1)^{1/p})</code>.</p>
</dd>
<dt><code>"Yager"</code></dt><dd><p>the Yager family <code class="reqn">T_p</code>, <code class="reqn">p \ge 0</code>,
which gives the drastic and minimum t-norms for <code class="reqn">p = 0</code>
and <code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \max(0, 1 - ((1-x)^p + (1-y)^p)^{1/p})</code>.</p>
</dd>
<dt><code>"Dombi"</code></dt><dd><p>the Dombi family <code class="reqn">T_p</code>, <code class="reqn">p \ge 0</code>,
which gives the drastic and minimum t-norms for <code class="reqn">p = 0</code>
and <code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = 0</code> if <code class="reqn">x = 0</code> or <code class="reqn">y = 0</code>, and
<code class="reqn">T_p(x, y) = 1 / (1 + ((1/x - 1)^p + (1/y - 1)^p)^{1/p})</code> if
both <code class="reqn">x &gt; 0</code> and <code class="reqn">y &gt; 0</code>.</p>
</dd>
<dt><code>"Aczel-Alsina"</code></dt><dd><p>the family of t-norms <code class="reqn">T_p</code>,
<code class="reqn">p \ge 0</code>, introduced by Aczél and Alsina, which gives the
drastic and minimum t-norms for <code class="reqn">p = 0</code> and
<code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \exp(-(|\log(x)|^p + |\log(y)|^p)^{1/p})</code>.</p>
</dd>
<dt><code>"Sugeno-Weber"</code></dt><dd><p>the family of t-norms <code class="reqn">T_p</code>,
<code class="reqn">-1 \le p \le \infty</code>, introduced by Weber
with dual t-conorms introduced by Sugeno, which gives the
drastic and product t-norms for <code class="reqn">p = -1</code> and
<code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \max(0, (x + y - 1 + pxy) / (1 + p))</code>.</p>
</dd>
<dt><code>"Dubois-Prade"</code></dt><dd><p>the family of t-norms <code class="reqn">T_p</code>,
<code class="reqn">0 \le p \le 1</code>, introduced by Dubois and Prade, which gives
the minimum and product t-norms for <code class="reqn">p = 0</code> and <code class="reqn">1</code>,
respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = xy / \max(x, y, p)</code>.</p>
</dd>
<dt><code>"Yu"</code></dt><dd><p>the family of t-norms <code class="reqn">T_p</code>, <code class="reqn">p \ge -1</code>,
introduced by Yu, which gives the product and drastic t-norms for
<code class="reqn">p = -1</code> and <code class="reqn">\infty</code>, respectively, and otherwise is
given by <code class="reqn">T(x, y) = \max(0, (1 + p) (x + y - 1) - p x y)</code>.</p>
</dd>
</dl>

<p>By default, the Zadeh logic is used.
</p>
<p><code>.N.</code>, <code>.T.</code>, <code>.S.</code>, and <code>.I.</code> are dynamic
functions, i.e., wrappers that call the corresponding function of the
current fuzzy logic.  Thus, the behavior of code using these
functions will change according to the chosen logic.
</p>


<h3>References</h3>

<p>C. Alsina, M. J. Frank and B. Schweizer (2006),
<em>Associative Functions: Triangular Norms and Copulas</em>.
World Scientific. ISBN 981-256-671-6.
</p>
<p>J. Dombi (1982),
A general class of fuzzy operators, the De Morgan class of fuzzy
operators and fuzziness measures induced by fuzzy operators,
<em>Fuzzy Sets and Systems</em> <b>8</b>, 149&ndash;163.
</p>
<p>J. Fodor and M. Roubens (1994),
<em>Fuzzy Preference Modelling and Multicriteria Decision Support</em>.
Kluwer Academic Publishers, Dordrecht.
</p>
<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1&ndash;27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>
<p>B. Schweizer and A. Sklar (1983),
<em>Probabilistic Metric Spaces</em>.
North-Holland, New York.  ISBN 0-444-00666-4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.7, 0.8)
y &lt;- c(0.2, 0.3)

## Use default family ("Zadeh")
.N.(x)
.T.(x, y)
.S.(x, y)
.I.(x, y)

## Switch family and try again
fuzzy_logic("Fodor")
.N.(x)
.T.(x, y)
.S.(x, y)
.I.(x, y)
</code></pre>

<hr>
<h2 id='fuzzydocs'>Documents on Fuzzy Theory</h2><span id='topic+fuzzy_docs'></span>

<h3>Description</h3>

<p>Occurence of three terms (neural networks, fuzzy, and image)
in 30 documents retrieved
from a Japanese article data base on fuzzy theory and systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fuzzy_docs")
</code></pre>


<h3>Format</h3>

<p><code>fuzzy_docs</code> is a list of 30 fuzzy multisets, representing the
occurrence of the terms &ldquo;neural networks&rdquo;, &ldquo;fuzzy&rdquo;, and
&ldquo;image&rdquo; in each document. Each term appears with up to
three membership values representing weights,
depending on whether the term occurred
in the abstract (0.2), the keywords section (0.6), and/or the title
(1). The first 12 documents concern neural networks, the remaining 18
image processing. In the reference, various clustering methods have
been employed to recover the two groups in the data set.
</p>


<h3>Source</h3>

<p>K. Mizutani, R. Inokuchi, and S. Miyamoto (2008),
Algorithms of Nonlinear Document Clustering Based on Fuzzy Multiset
Model,
<em>International Journal of Intelligent Systems</em>,
<b>23</b>, 176&ndash;198.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fuzzy_docs)

## compute distance matrix using Jaccard dissimilarity
d &lt;- as.dist(set_outer(fuzzy_docs, gset_dissimilarity))

## apply hierarchical clustering (Ward method)
cl &lt;- hclust(d, "ward")

## retrieve two clusters
cutree(cl, 2)

## -&gt; clearly, the clusters are formed by docs 1--12 and 13--30,
## respectively.

</code></pre>

<hr>
<h2 id='fuzzyfuns'>Fuzzy membership functions</h2><span id='topic+charfun_generator'></span><span id='topic+is.charfun_generator'></span><span id='topic+fuzzy_tuple'></span><span id='topic+fuzzy_normal'></span><span id='topic+fuzzy_two_normals'></span><span id='topic+fuzzy_bell'></span><span id='topic+fuzzy_cone'></span><span id='topic+fuzzy_sigmoid'></span><span id='topic+fuzzy_trapezoid'></span><span id='topic+fuzzy_triangular'></span><span id='topic+fuzzy_pi3'></span><span id='topic+fuzzy_pi4'></span><span id='topic+fuzzy_normal_gset'></span><span id='topic+fuzzy_two_normals_gset'></span><span id='topic+fuzzy_bell_gset'></span><span id='topic+fuzzy_sigmoid_gset'></span><span id='topic+fuzzy_trapezoid_gset'></span><span id='topic+fuzzy_triangular_gset'></span><span id='topic+fuzzy_cone_gset'></span><span id='topic+fuzzy_pi3_gset'></span><span id='topic+fuzzy_pi4_gset'></span>

<h3>Description</h3>

<p>Fuzzy membership and set creator functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>charfun_generator(FUN, height = 1)
fuzzy_tuple(FUN = fuzzy_normal, n = 5, ...,
                 universe = NULL, names = NULL)
is.charfun_generator(x)

fuzzy_normal(mean = NULL, sd = 1, log = FALSE, height = 1, chop = 0)
fuzzy_two_normals(mean = NULL, sd = c(1,1), log = c(FALSE, FALSE),
                  height = 1, chop = 0)
fuzzy_bell(center = NULL, cross = NULL, slope = 4, height = 1, chop = 0)
fuzzy_sigmoid(cross = NULL, slope = 0.5, height = 1, chop = 0)
fuzzy_trapezoid(corners = NULL, height = c(1,1),
                return_base_corners = TRUE)
fuzzy_triangular(corners = NULL, height = 1,
                 return_base_corners = TRUE)
fuzzy_cone(center = NULL, radius = 2, height = 1,
           return_base_corners = TRUE)
fuzzy_pi3(mid = NULL, min = NULL, max = NULL, height = 1,
          return_base_corners = TRUE)
fuzzy_pi4(knots, height = 1, return_base_corners = TRUE)

fuzzy_normal_gset(mean = NULL, sd = 1, log = FALSE, height = 1,
                  chop = 0, universe = NULL)
fuzzy_two_normals_gset(mean = NULL, sd = c(1,1), log = c(FALSE, FALSE),
                      height = 1, chop = 0, universe = NULL)
fuzzy_bell_gset(center = NULL, cross = NULL, slope = 4, height = 1,
                chop = 0, universe = NULL)
fuzzy_sigmoid_gset(cross = NULL, slope = 0.5, height = 1,
                   chop = 0, universe = NULL)
fuzzy_trapezoid_gset(corners = NULL, height = c(1,1), universe = NULL,
                     return_base_corners = TRUE)
fuzzy_triangular_gset(corners = NULL, height = 1, universe = NULL,
                      return_base_corners = TRUE)
fuzzy_cone_gset(center = NULL, radius = 2, height = 1, universe = NULL,
                return_base_corners = TRUE)
fuzzy_pi3_gset(mid = NULL, min = NULL, max = NULL, height = 1,
              universe = NULL, return_base_corners = TRUE)
fuzzy_pi4_gset(knots, height = 1,
               universe = NULL, return_base_corners = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzyfuns_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_n">n</code></td>
<td>
<p>Positive integer indicating the number of sets to be created,
or integer vector of location parameters used to create the sets.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_fun">FUN</code></td>
<td>
<p>Function to be used for creating a membership function.
Needs to be vectorized, i.e., is expected to take a vector of set
elements and to return a vector of numeric values.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_height">height</code></td>
<td>
<p>Numeric value in the unit interval specifying the height
of the set resulting from applying the membership function to the
universe, i.e., the maximum value to which the values will be scaled to.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_chop">chop</code></td>
<td>
<p>Threshold value below which the membership function is
truncated, i.e., has a value of 0.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_center">center</code>, <code id="fuzzyfuns_+3A_mean">mean</code></td>
<td>
<p>Numeric mean value(s) used for
the resulting membership function.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_sd">sd</code></td>
<td>
<p>Numeric scale factor(s) (standard deviation(s)) used for the
resulting membership function.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_radius">radius</code></td>
<td>
<p>Double added/subtracted from <code>center</code> to get the
base line corners of the cone.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_log">log</code></td>
<td>
<p>Logical (vector), indicating whether normal or log-normal
distributions should be used.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_cross">cross</code></td>
<td>
<p>Double indicating the cross-over point for the sigmoidal
distribution.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_slope">slope</code></td>
<td>
<p>Double indicating the slope at the cross-over point.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_corners">corners</code></td>
<td>
<p>Double values (vector of length four)
indicating the abscissas of the four corners of the resulting
trapezoid.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_min">min</code>, <code id="fuzzyfuns_+3A_mid">mid</code>, <code id="fuzzyfuns_+3A_max">max</code></td>
<td>
<p>Doubles indicating the abscissas of the three
spline knots <code class="reqn">(\code{min}, 0)</code>, <code class="reqn">(\code{mid},
      \code{height})</code> and <code class="reqn">(\code{max}, 0)</code>
the curve passes through.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_knots">knots</code></td>
<td>
<p>Vector of doubles of length four indicating the abscissas
of the spline knots the curve passes through.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_return_base_corners">return_base_corners</code></td>
<td>
<p>Logical indicating whether membership grades
for the base line corner elements should be returned as small values
(<code>.Machine$double.eps</code>) instead of 0.
Otherwise, if a set is created from the memberships,
the corner elements would be removed from the set.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_universe">universe</code></td>
<td>
<p>Universal set used for computing the memberships
grades.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_names">names</code></td>
<td>
<p>optional character vector of component labels for the return value.</p>
</td></tr>
<tr><td><code id="fuzzyfuns_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to create sets with certain membership
patterns. 
</p>
<p>The core functions are function <em>generators</em>, taking parameters
and returning a corresponding fuzzy function (i.e., with values in the
unit interval).  All of them are normalized, i.e., scaled to have a
maximum value of <code>height</code> (default: 1):
</p>

<dl>
<dt><code>fuzzy_normal</code></dt><dd><p>is simply based on <code><a href="stats.html#topic+dnorm">dnorm</a></code>.</p>
</dd>
<dt><code>fuzzy_two_normals</code></dt><dd><p>returns a function composed of the left and
right parts of two normal distributions (each normalized),
with possibly different means and standard
deviations.</p>
</dd>
<dt><code>fuzzy_bell</code></dt><dd><p>returns a function defined as:
<code class="reqn">\frac{1}{\left(1 + |\frac{x - c}{w}| \right) ^ {2s}}</code>  with center <code class="reqn">c</code>,
crossover points <code class="reqn">c \pm w</code>, and slope at the crossover
points of <code class="reqn">\frac{s}{2w}</code>.</p>
</dd>
<dt><code>fuzzy_sigmoid</code></dt><dd><p>yields a function whose values are
computed as <code class="reqn">\frac{1}{1 + e ^ {s (c - x)}}</code>  with slope <code class="reqn">s</code> at crossover point <code class="reqn">c</code>.</p>
</dd>
<dt><code>fuzzy_trapezoid</code></dt><dd><p>creates a function with
trapezoidal shape, defined by four <code>corners</code> elements and two
<code>height</code> values for the second and third corner (the heights of
the first and fourth corner being fixed at 0).</p>
</dd>
<dt><code>fuzzy_triangular</code></dt><dd><p>similar to the above with only three
corners.</p>
</dd>
<dt><code>fuzzy_cone</code></dt><dd><p>is a special case of <code>fuzzy_triangular</code>,
defining an isosceles triangle with corners (element, membership degree):
<code class="reqn">(\code{center} - \code{radius}, 0)</code>,
<code class="reqn">(\code{center}, \code{height})</code>, and
<code class="reqn">(\code{center} + \code{radius}, 0)</code>.</p>
</dd>
<dt><code>fuzzi_pi3</code></dt><dd><p>constructs a spline based on two quadratic
functions, passing through the knot points <code class="reqn">(\code{min}, 0)</code>,
<code class="reqn">(\code{mid}, \code{height})</code> and <code class="reqn">(\code{max}, 0)</code>.</p>
</dd>
<dt><code>fuzzi_pi4</code></dt><dd><p>constructs a spline based on an S-shaped and
a Z-shaped curve forming a <code class="reqn">\pi</code>-shaped one, passing through
the four knots <code class="reqn">(\code{knots[1]}, 0)</code>, <code class="reqn">(\code{knots[2]},
	\code{height})</code>, <code class="reqn">(\code{knots[3]}, \code{height})</code>, and <code class="reqn">(\code{knots[4]}, 0)</code>.
</p>
</dd>
</dl>

<p><code>charfun_generator</code> takes a vectorized function as argument,
returning a function normalized by <code>height</code>.
</p>
<p>The <code>fuzzy_<var>foo</var>_gset</code> functions directly generate
generalized sets from <code>fuzzy_<var>foo</var></code>, using the values defined by
<code>universe</code>, <code>sets_options("universe")</code>, or <code>seq(0, 20, by
    = 0.1)</code> (in that order, whichever is not <code>NULL</code>).
</p>
<p><code>fuzzy_tuple</code> generates a sequence of <code>n</code>
sets based on any of the generating functions (except
<code>fuzzy_trapezoid</code> and <code>fuzzy_triangular</code>).  The chosen
generating function <code>FUN</code> is called with <code>n</code> different
values chosen along the <code>universe</code> passed to the
first argument, thus varying the position or the resulting graph.
</p>


<h3>Value</h3>

<p>For <code>charfun_generator</code>, a <em>generating function</em>
taking an argument list of parameters, and returning a membership
function, mapping elements to membership values (from of the unit
interval).
</p>
<p>For <code>fuzzy_tuple</code>, a tuple of <code>n</code> fuzzy sets.
</p>
<p>For <code>is.charfun_generator</code>, a logical.
</p>
<p>For <code>fuzzy_<var>foo</var>_gset</code>, a fuzzy set.
</p>
<p>For the other functions, a membership function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code>, <code><a href="#topic+gset">gset</a></code>, and <code><a href="#topic+tuple">tuple</a></code> for the
set types, and <code><a href="#topic+plot.gset">plot.gset</a></code> for the available plot functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## creating a fuzzy normal function
N &lt;- fuzzy_normal(mean = 0, sd = 1)
N(-3:3)

## create a fuzzy set with it
gset(charfun = N, universe = -3:3)

## same using wrapper
fuzzy_normal_gset(universe = -3:3)

## creating a user-defined fuzzy function
fuzzy_poisson &lt;- charfun_generator(dpois)
gset(charfun = fuzzy_poisson(10), universe = seq(0, 20, 2))

## creating a series of fuzzy normal sets
fuzzy_tuple(fuzzy_normal, 5)

## creating a series of fuzzy cones with specific locations
fuzzy_tuple(fuzzy_cone, c(2,3,7))
</code></pre>

<hr>
<h2 id='fuzzyinference'>Fuzzy inference</h2><span id='topic+fuzzy_rule'></span><span id='topic+fuzzy_variable'></span><span id='topic+fuzzy_partition'></span><span id='topic+fuzzy_system'></span><span id='topic+fuzzy_inference'></span><span id='topic++25is+25'></span>

<h3>Description</h3>

<p>Basic infrastructure for building and using fuzzy inference
systems.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_inference(system, values, implication = c("minimum", "product"))
fuzzy_rule(antecedent, consequent)
fuzzy_system(variables, rules)
fuzzy_partition(varnames, FUN = fuzzy_normal, universe = NULL, ...)
fuzzy_variable(...)
x %is% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzyinference_+3A_...">...</code></td>
<td>
<p>For <code>fuzzy_variable</code>: named list of fuzzy sets (or
membership functions from which the fuzzy sets will be created using the
default universe). For <code>fuzy_partition</code>: further arguments passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_antecedent">antecedent</code>, <code id="fuzzyinference_+3A_consequent">consequent</code></td>
<td>
<p>parts of an inference rule (see
details).</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_variables">variables</code></td>
<td>
<p>Set or tuple of fuzzy variables (note that
tuples must be used if two variables have the same definition).</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_rules">rules</code></td>
<td>
<p>Set of rules.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_system">system</code></td>
<td>
<p>A fuzzy system.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_values">values</code></td>
<td>
<p>Named list of input values to the system. The names must
match the labels of the variable set.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_implication">implication</code></td>
<td>
<p>A vectorized function taking two arguments, or a
character string indicating the parallel minimum or the product
function.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_varnames">varnames</code></td>
<td>
<p>Either a character vector of fuzzy category labels, to
be used with the default locations, or
a named numeric vector of locations.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_fun">FUN</code></td>
<td>
<p>Function generator for membership functions to be used for
the fuzzy partition.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_universe">universe</code></td>
<td>
<p>Universal set used for computing the memberships
grades.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_x">x</code></td>
<td>
<p>The name of a fuzzy variable.</p>
</td></tr>
<tr><td><code id="fuzzyinference_+3A_y">y</code></td>
<td>
<p>The name of a category, belonging to a fuzzy variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to create simple fuzzy inference machines
based on fuzzy (&ldquo;linguistic&rdquo;) variables and fuzzy rules. This
involves five steps:
</p>

<ol>
<li><p> Fuzzification of the input variables.
</p>
</li>
<li><p> Application of fuzzy operators (AND, OR, NOT) in the
antecedents of some given rules.
</p>
</li>
<li><p> Implication from the antecedent to the consequent.
</p>
</li>
<li><p> Aggregation of the consequents across the rules.
</p>
</li>
<li><p> Defuzzification of the resulting fuzzy set.
</p>
</li></ol>

<p>Implication is based on either the minimum or the product.
The evaluation of the logical expressions in the antecedents, as
well as the aggregation of the evaluation result for each single rule,
depends on the fuzzy logic currently set.
</p>


<h3>Value</h3>

<p>For <code>fuzzy_inference</code>: a generalized set. For
<code>fuzzy_rule</code> and <code>fuzzy_system</code>: an object of class
<code>fuzzy_rule</code> and <code>fuzzy_system</code>, respectively.
For <code>fuzzy_variable</code> and <code>fuzzy_partition</code>: an object of
class <code>fuzzy_variable</code>, inheriting from <code>tuple</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code> and <code><a href="#topic+gset">gset</a></code> for the
set types, <code><a href="#topic+fuzzy_tuple">fuzzy_tuple</a></code> for available fuzzy functions,
and <code><a href="#topic+fuzzy_logic">fuzzy_logic</a></code> on the behavior of the implemented fuzzy
operators. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set universe
sets_options("universe", seq(from = 0, to = 25, by = 0.1))

## set up fuzzy variables
variables &lt;-
set(service =
    fuzzy_partition(varnames =
                    c(poor = 0, good = 5, excellent = 10),
                    sd = 1.5),
    food =
    fuzzy_variable(rancid =
                   fuzzy_trapezoid(corners = c(-2, 0, 2, 4)),
                   delicious =
                   fuzzy_trapezoid(corners = c(7, 9, 11, 13))),
    tip =
    fuzzy_partition(varnames =
                    c(cheap = 5, average = 12.5, generous = 20),
                    FUN = fuzzy_cone, radius = 5)
    )

## set up rules
rules &lt;-
set(
    fuzzy_rule(service %is% poor || food %is% rancid,
               tip %is% cheap),
    fuzzy_rule(service %is% good,
               tip %is% average),
    fuzzy_rule(service %is% excellent || food %is% delicious,
               tip %is% generous)
    )

## combine to a system
system &lt;- fuzzy_system(variables, rules)
print(system)
plot(system) ## plots variables

## do inference
fi &lt;- fuzzy_inference(system, list(service = 3, food = 8))

## plot resulting fuzzy set
plot(fi)

## defuzzify
gset_defuzzify(fi, "centroid")

## reset universe
sets_options("universe", NULL)
</code></pre>

<hr>
<h2 id='gset'>Generalized sets</h2><span id='topic+gset'></span><span id='topic+as.gset'></span><span id='topic+is.gset'></span><span id='topic+gset_is_empty'></span><span id='topic+gset_is_subset'></span><span id='topic+gset_is_proper_subset'></span><span id='topic+gset_is_equal'></span><span id='topic+gset_contains_element'></span><span id='topic+gset_union'></span><span id='topic+gset_sum'></span><span id='topic+gset_product'></span><span id='topic+gset_mean'></span><span id='topic+gset_difference'></span><span id='topic+gset_intersection'></span><span id='topic+gset_symdiff'></span><span id='topic+gset_complement'></span><span id='topic+gset_power'></span><span id='topic+gset_cartesian'></span><span id='topic+gset_combn'></span><span id='topic+gset_core'></span><span id='topic+gset_peak'></span><span id='topic+gset_height'></span><span id='topic+gset_transform_memberships'></span><span id='topic+gset_concentrate'></span><span id='topic+gset_dilate'></span><span id='topic+gset_normalize'></span><span id='topic+gset_defuzzify'></span><span id='topic++25D+25'></span><span id='topic++25e+25'></span><span id='topic+e'></span><span id='topic+is_element'></span><span id='topic+gset_bound'></span><span id='topic+gset_cardinality'></span><span id='topic+gset_charfun'></span><span id='topic+gset_memberships'></span><span id='topic+gset_support'></span><span id='topic+gset_universe'></span><span id='topic+gset_has_missings'></span><span id='topic+gset_is_crisp'></span><span id='topic+gset_is_fuzzy_set'></span><span id='topic+gset_is_multiset'></span><span id='topic+gset_is_set_or_fuzzy_set'></span><span id='topic+gset_is_set_or_multiset'></span><span id='topic+gset_is_fuzzy_multiset'></span><span id='topic+gset_is_set'></span><span id='topic+length.gset'></span><span id='topic+lengths.gset'></span><span id='topic+mean.gset'></span><span id='topic+median.gset'></span><span id='topic+cut.gset'></span>

<h3>Description</h3>

<p>Creation and manipulation of generalized sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gset(support, memberships, charfun, elements, universe, bound,
     assume_numeric_memberships)
as.gset(x)
is.gset(x)
gset_support(x)
gset_core(x, na.rm = FALSE)
gset_peak(x, na.rm = FALSE)
gset_height(x, na.rm = FALSE)
gset_universe(x)
gset_bound(x)

gset_memberships(x, filter = NULL)
gset_transform_memberships(x, FUN, ...)
gset_concentrate(x)
gset_dilate(x)
gset_normalize(x, height = 1)
gset_defuzzify(x,
               method = c("meanofmax", "smallestofmax",
                          "largestofmax", "centroid"))

gset_is_empty(x, na.rm = FALSE)
gset_is_subset(x, y, na.rm = FALSE)
gset_is_proper_subset(x, y, na.rm = FALSE)
gset_is_equal(x, y, na.rm = FALSE)
gset_contains_element(x, e)

gset_is_set(x, na.rm = FALSE)
gset_is_multiset(x, na.rm = FALSE)
gset_is_fuzzy_set(x, na.rm = FALSE)
gset_is_set_or_multiset(x, na.rm = FALSE)
gset_is_set_or_fuzzy_set(x, na.rm = FALSE)
gset_is_fuzzy_multiset(x)
gset_is_crisp(x, na.rm = FALSE)
gset_has_missings(x)

gset_cardinality(x, type = c("absolute", "relative"), na.rm = FALSE)
gset_union(...)
gset_sum(...)
gset_difference(...)
gset_product(...)
gset_mean(x, y, type = c("arithmetic", "geometric", "harmonic"))
gset_intersection(...)
gset_symdiff(...)
gset_complement(x, y)
gset_power(x)
gset_cartesian(...)
gset_combn(x, m)

e(x, memberships = 1L)
is_element(e)

## S3 method for class 'gset'
cut(x, level = 1, type = c("alpha", "nu"), strict = FALSE, ...)
## S3 method for class 'gset'
mean(x, ..., na.rm = FALSE)
## S3 method for class 'gset'
## median(x, na.rm = FALSE, ...)     [R &gt;= 3.4.0]
## median(x, na.rm)                  [R &lt; 3.4.0]
## S3 method for class 'gset'
length(x)
## S3 method for class 'gset'
lengths(x, use.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gset_+3A_x">x</code></td>
<td>
<p>For <code>e()</code>, <code>as.gset()</code> and <code>is.gset()</code>:
an <span class="rlang"><b>R</b></span> object. A (g)set object otherwise. <code>gset_memberships()</code>
also accepts tuple objects.</p>
</td></tr>
<tr><td><code id="gset_+3A_y">y</code></td>
<td>
<p>A (g)set object.</p>
</td></tr>
<tr><td><code id="gset_+3A_e">e</code></td>
<td>
<p>An object of class <code>element</code>.</p>
</td></tr>
<tr><td><code id="gset_+3A_filter">filter</code></td>
<td>
<p>Optional vector of elements to be filtered.</p>
</td></tr>
<tr><td><code id="gset_+3A_m">m</code></td>
<td>
<p>Number of elements to choose.</p>
</td></tr>
<tr><td><code id="gset_+3A_support">support</code></td>
<td>
<p>A set of elements giving the support of the gset
(elements with non-zero memberships). Must be a subset of the
universe, if specified.</p>
</td></tr>
<tr><td><code id="gset_+3A_memberships">memberships</code></td>
<td>
<p>For an (&ldquo;ordinary&rdquo;) set: 1L (or simply missing).
For a fuzzy set: a value between 0 and 1.  For a multiset: a
positive integer.  For a fuzzy multiset: a list of
multisets with elements from the unit interval (or a list of vectors
interpreted as such).
Otherwise, the argument will be transformed using <code>as.gset</code>.</p>
</td></tr> 
<tr><td><code id="gset_+3A_elements">elements</code></td>
<td>
<p>A set (or list) of <code>e</code> objects which are
object/memberships-pairs.</p>
</td></tr>
<tr><td><code id="gset_+3A_charfun">charfun</code></td>
<td>
<p>A function taking an object and returning the
membership.</p>
</td></tr>
<tr><td><code id="gset_+3A_bound">bound</code></td>
<td>
<p>Integer used to compute the absolute complement for
(fuzzy) multisets. If <code>NULL</code>,
defaults to the value of <code>sets_options("bound")</code>.
If the latter is also <code>NULL</code>, the maximum multiplicity
will be used in computations.</p>
</td></tr>
<tr><td><code id="gset_+3A_assume_numeric_memberships">assume_numeric_memberships</code></td>
<td>
<p>When applying <code>carfun()</code> to
the universe, should numeric memberships (i.e. fuzzy sets or
multisets) be assumed (default)? If <code>FALSE</code>, fuzzy multisets
will be created.</p>
</td></tr>
<tr><td><code id="gset_+3A_fun">FUN</code></td>
<td>
<p>A function, to be applied to a membership vector.</p>
</td></tr>
<tr><td><code id="gset_+3A_type">type</code></td>
<td>
<p>For <code>gset_cardinality()</code>:
cardinality type (either <code>"absolute"</code> or
<code>"relative"</code>). For <code>gset_mean()</code>: mean type
(<code>"arithmetic"</code>, <code>"geometric"</code>, or <code>"harmonic"</code>).
For <code>"cut"</code>: either <code>"alpha"</code> or <code>"nu"</code>.</p>
</td></tr>
<tr><td><code id="gset_+3A_strict">strict</code></td>
<td>
<p>Logical indicating whether the cut level must be 
exceeded strictly (&ldquo;greater than&rdquo;) or not (&ldquo;greater
than or equal&rdquo;).</p>
</td></tr>
<tr><td><code id="gset_+3A_height">height</code></td>
<td>
<p>Double from the unit interval for scaling memberships.</p>
</td></tr>
<tr><td><code id="gset_+3A_universe">universe</code></td>
<td>
<p>An optional set of elements. If <code>NULL</code>,
defaults to the value of <code>sets_options("universe")</code>.
If the latter is also <code>NULL</code>, the support
will be used in computations.</p>
</td></tr>
<tr><td><code id="gset_+3A_method">method</code></td>
<td>
<p><code>"centroid"</code> computes the arithmetic
mean of the set elements, using the membership values as
weights. <code>"smallestofmax"</code> / <code>"meanofmax"</code> /
<code>"largestofmax"</code> returns the minimum/mean/maximum of all
set elements with maximal membership degree.</p>
</td></tr>
<tr><td><code id="gset_+3A_level">level</code></td>
<td>
<p>The minimum membership level.</p>
</td></tr>
<tr><td><code id="gset_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be
removed.</p>
</td></tr>
<tr><td><code id="gset_+3A_use.names">use.names</code></td>
<td>
<p>logical; should the names of <code>x</code> be used in the result?</p>
</td></tr>
<tr><td><code id="gset_+3A_...">...</code></td>
<td>
<p>For <code>gset_<var>foo</var>()</code>: (g)set objects.  For
the mean and sort methods: additional parameters internally passed to
<code><a href="base.html#topic+mean">mean</a></code> and <code><a href="base.html#topic+order">order</a></code>, respectively. For
<code>gset_transform_memberships</code>: further arguments passed to
<code>FUN</code>. For <code>cut</code>: currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions represent basic infrastructure for handling
<em>generalized</em> sets of general (<span class="rlang"><b>R</b></span>) objects.
</p>
<p>A generalized set (or gset) is set of pairs <code class="reqn">(e, f)</code>, where
<code class="reqn">e</code> is some set element and <code class="reqn">f</code> is the characteristic (or
membership) function. For (&ldquo;ordinary&rdquo;) sets
<code class="reqn">f</code> maps to <code class="reqn">\{0, 1\}</code>,
for fuzzy sets into the unit interval, for multisets into the natural
numbers, and for fuzzy multisets <code class="reqn">f</code> maps to the set of multisets
over the unit interval.
</p>
<p>The <code>gset_is_<var>foo</var>()</code> predicates
are vectorized. In addition
to the methods defined, one can use the following operators:
<code>|</code> for the union, <code>&amp;</code> for the
intersection, <code>+</code> for the sum, <code>-</code> for
the difference,  <code>%D%</code> for the symmetric difference,
<code>*</code> and <code>^<var>n</var></code> for the
(<code class="reqn">n</code>-fold) cartesian product, <code>2^</code> for the power set,
<code>%e%</code> for the element-of predicate,
<code>&lt;</code> and <code>&lt;=</code> for
the (proper) subset predicate, <code>&gt;</code> and <code>&gt;=</code> for
the (proper) superset predicate, and <code>==</code> and <code>!=</code> for
(in)equality.
The <code>Summary</code> methods do also work if
defined for the set elements. 
The <code><a href="base.html#topic+mean">mean</a></code> and <code><a href="stats.html#topic+median">median</a></code>
methods try to convert the object to a numeric vector before calling
the default methods. <code>set_combn</code> returns the gset of all
subsets of specified length. 
</p>
<p><code>gset_support</code>, <code>gset_core</code>, and <code>gset_peak</code>
return the set of elements with memberships greater than zero, equal
to one, and equal to the maximum membership, respectively.
<code>gset_memberships</code> returns the membership
vector(s) of a given (tuple of) gset(s), optionally
restricted to the elements specified by <code>filter</code>.
<code>gset_height</code> returns only
the largest membership degree.
<code>gset_cardinality</code> computes either the absolute or the
relative cardinality, i.e. the memberships sum, or the absolute
cardinality divided by the number of elements, respectively.
The <code>length</code> method for gsets gives the (absolute) cardinality.
The <code>lengths</code> method coerces the set to a list
before applying the <code>length</code> method on its elements.
<code>gset_transform_memberships</code> applies function <code>FOO</code> to 
the membership vector of the supplied gset and returns the transformed
gset. The transformed memberships are guaranteed to be in the unit
interval.
<code>gset_concentrate</code> and <code>gset_dilate</code> are convenience
functions, using the square and the square root,
respectively. <code>gset_normalize</code> divides the memberships by their
maximum and scales with <code>height</code>.
<code>gset_product</code> (<code>gset_mean</code>) of some gsets
compute the gset with the corresponding memberships multiplied (averaged).
</p>
<p>The <code>cut</code> method provides both <code class="reqn">\alpha</code>- and <code class="reqn">\nu</code>-cuts.
<code class="reqn">\alpha</code>-cuts &ldquo;filter&rdquo; all elements with memberships
greater than (or equal to) <code>level</code>&mdash;the result, thus, is a crisp
(multi)set. <code class="reqn">\nu</code>-cuts select those elements with a
<em>multiplicity</em> exceeding <code>level</code>
(only sensible for (fuzzy) multisets). 
</p>
<p>Because set elements are unordered, it is not allowed to use
<em>positional</em> indexing. However, it is possible to
do indexing using element labels or
simply the elements themselves (useful, e.g., for subassignment).
In addition, it is possible to iterate over
<em>all</em> elements using <code>for</code> and <code>lapply</code>/<code>sapply</code>.
</p>
<p><code>gset_contains_element</code> is vectorized in <code>e</code>, that is, if <code>e</code>
is an atomic vector or list, the is-element operation is performed
element-wise, and a logical vector returned. Note that, however,
objects of class <code>tuple</code> are taken as atomic objects to
correctly handle sets of tuples.
</p>


<h3>References</h3>

<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1&ndash;27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code> for &ldquo;ordinary&rdquo; sets, 
<code><a href="#topic+gset_outer">gset_outer</a></code>, and
<code><a href="#topic+tuple">tuple</a></code> for tuples (&ldquo;vectors&rdquo;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## multisets
(A &lt;- gset(letters[1:5], memberships = c(3, 2, 1, 1, 1)))
(B &lt;- gset(c("a", "c", "e", "f"), memberships = c(2, 2, 1, 2)))
rep(B, 2)
gset_memberships(tuple(A, B), c("a","c"))

gset_union(A, B)
gset_intersection(A, B)
gset_complement(A, B)

gset_is_multiset(A)
gset_sum(A, B)
gset_difference(A, B)

## fuzzy sets
(A &lt;- gset(letters[1:5], memberships = c(1, 0.3, 0.8, 0.6, 0.2)))
(B &lt;- gset(c("a", "c", "e", "f"), memberships = c(0.7, 1, 0.4, 0.9)))
cut(B, 0.5)
A * B
A &lt;- gset(3L, memberships = 0.5, universe = 1:5)
!A

## fuzzy multisets
(A &lt;- gset(c("a", "b", "d"),
         memberships = list(c(0.3, 1, 0.5), c(0.9, 0.1),
                            gset(c(0.4, 0.7), c(1, 2)))))
(B &lt;- gset(c("a", "c", "d", "e"),
         memberships = list(c(0.6, 0.7), c(1, 0.3), c(0.4, 0.5), 0.9)))
gset_union(A, B)
gset_intersection(A, B)
gset_complement(A, B)

## other operations
mean(gset(1:3, c(0.1,0.5,0.9)))
median(gset(1:3, c(0.1,0.5,0.9)))

## vectorization
list(gset(1, 0.5), gset(2, 2L), gset()) &lt;= gset(1, 2L)
</code></pre>

<hr>
<h2 id='interval'>Intervals</h2><span id='topic+as.character.interval'></span><span id='topic+as.double.interval'></span><span id='topic+as.interval'></span><span id='topic+as.interval.default'></span><span id='topic+as.interval.interval'></span><span id='topic+as.interval.list'></span><span id='topic+as.interval.NULL'></span><span id='topic+as.interval.numeric'></span><span id='topic+as.interval.set'></span><span id='topic+as.interval.tuple'></span><span id='topic+as.list.interval'></span><span id='topic+integers'></span><span id='topic+integers2reals'></span><span id='topic+interval'></span><span id='topic+interval_complement'></span><span id='topic+interval_contains_element'></span><span id='topic+interval_difference'></span><span id='topic+interval_division'></span><span id='topic+interval_domain'></span><span id='topic+interval_intersection'></span><span id='topic+interval_is_bounded'></span><span id='topic+interval_is_closed'></span><span id='topic+interval_is_countable'></span><span id='topic+interval_is_degenerate'></span><span id='topic+interval_is_empty'></span><span id='topic+interval_is_equal'></span><span id='topic+interval_is_less_than_or_equal'></span><span id='topic+interval_is_greater_than_or_equal'></span><span id='topic+interval_is_less_than'></span><span id='topic+interval_is_greater_than'></span><span id='topic+interval_is_finite'></span><span id='topic+interval_is_half_bounded'></span><span id='topic+interval_is_left_bounded'></span><span id='topic+interval_is_left_closed'></span><span id='topic+interval_is_left_open'></span><span id='topic+interval_is_left_unbounded'></span><span id='topic+interval_is_proper'></span><span id='topic+interval_is_proper_subinterval'></span><span id='topic+interval_is_right_bounded'></span><span id='topic+interval_is_right_closed'></span><span id='topic+interval_is_right_open'></span><span id='topic+interval_is_right_unbounded'></span><span id='topic+interval_is_subinterval'></span><span id='topic+interval_is_unbounded'></span><span id='topic+interval_is_uncountable'></span><span id='topic+interval_measure'></span><span id='topic+interval_power'></span><span id='topic+interval_product'></span><span id='topic+interval_sum'></span><span id='topic+interval_symdiff'></span><span id='topic+interval_union'></span><span id='topic+is.interval'></span><span id='topic+max.interval'></span><span id='topic+mean.interval'></span><span id='topic+min.interval'></span><span id='topic+naturals'></span><span id='topic+naturals0'></span><span id='topic+range.interval'></span><span id='topic+reals'></span><span id='topic+reals2integers'></span><span id='topic+prod.interval'></span><span id='topic+sum.interval'></span><span id='topic++25..+25'></span><span id='topic++25+3C+25'></span><span id='topic++25+3E+25'></span><span id='topic++25+3C+3D+25'></span><span id='topic++25+3E+3D+25'></span>

<h3>Description</h3>

<p>Interval class for countable and uncountable numeric sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval(l=NULL, r=l,
         bounds=c("[]", "[)", "(]", "()", "[[", "]]", "][",
                  "open", "closed", "left-open", "right-open",
                  "left-closed", "right-closed"),
         domain=NULL)

reals(l=NULL, r=NULL,
      bounds=c("[]", "[)", "(]", "()", "[[", "]]", "][",
               "open", "closed", "left-open", "right-open",
               "left-closed", "right-closed"))
integers(l=NULL, r=NULL)
naturals(l=NULL, r=NULL)
naturals0(l=NULL, r=NULL)
l %..% r

interval_domain(x)

as.interval(x)
integers2reals(x, min=-Inf, max=Inf)
reals2integers(x)

interval_complement(x, y=NULL)
interval_intersection(...)
interval_symdiff(...)
interval_union(...)

interval_difference(...)
interval_division(...)
interval_product(...)
interval_sum(...)

is.interval(x)
interval_contains_element(x, y)
interval_is_bounded(x)
interval_is_closed(x)
interval_is_countable(...)
interval_is_degenerate(x)
interval_is_empty(x)
interval_is_equal(x, y)
interval_is_less_than_or_equal(x, y)
interval_is_less_than(x, y)
interval_is_greater_than_or_equal(x, y)
interval_is_greater_than(x, y)
interval_is_finite(x)
interval_is_half_bounded(x)
interval_is_left_bounded(x)
interval_is_left_closed(x)
interval_is_left_open(...)
interval_is_left_unbounded(x)
interval_measure(x)
interval_is_proper(...)
interval_is_proper_subinterval(x, y)
interval_is_right_bounded(x)
interval_is_right_closed(x)
interval_is_right_open(...)
interval_is_right_unbounded(x)
interval_is_subinterval(x, y)
interval_is_unbounded(x)
interval_is_uncountable(x)
interval_power(x, n)
x %&lt;% y
x %&gt;% y
x %&lt;=% y
x %&gt;=% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interval_+3A_x">x</code></td>
<td>
<p>For <code>as.interval()</code> and <code>is.interval()</code>: an <span class="rlang"><b>R</b></span>
object. For all other functions: an interval object (or any other <span class="rlang"><b>R</b></span> object
coercible to one).</p>
</td></tr>
<tr><td><code id="interval_+3A_y">y</code></td>
<td>
<p>An interval object (or any other <span class="rlang"><b>R</b></span> object coercible to
one).</p>
</td></tr>
<tr><td><code id="interval_+3A_min">min</code>, <code id="interval_+3A_max">max</code></td>
<td>
<p>Integers defining the range to be coerced.</p>
</td></tr>
<tr><td><code id="interval_+3A_l">l</code>, <code id="interval_+3A_r">r</code></td>
<td>
<p>Numeric values defining the bounds of the interval. For
integer domains, these will be rounded.</p>
</td></tr>
<tr><td><code id="interval_+3A_bounds">bounds</code></td>
<td>
<p>Character string specifying whether the interval is
open, closed, or left/right-open/closed. Symbolic shortcuts such as
<code>"()"</code> or <code>"]["</code> for an open interval, etc., are also accepted.</p>
</td></tr>
<tr><td><code id="interval_+3A_domain">domain</code></td>
<td>
<p>Character string specifying the domain of the interval:
<code>"R"</code>, <code>"Z"</code>, <code>"N"</code>, and <code>"N0"</code> for the reals,
integers, positive integers and non-negative integers,
respectively. If unspecified, the domain will be guessed from the
mode of the numeric values specifying the bounds.</p>
</td></tr>
<tr><td><code id="interval_+3A_n">n</code></td>
<td>
<p>Integer exponent.</p>
</td></tr>
<tr><td><code id="interval_+3A_...">...</code></td>
<td>
<p>Interval objects (or other <span class="rlang"><b>R</b></span> objects coercible to
interval objects).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An interval object represents a multi-interval, i.e., a union of
disjoint, possibly unbounded (i.e., infinite)
ranges of numbers&mdash;either the extended reals, or sequences of
integers. The usual set operations (union, complement, intersection)
and predicates (equality, (proper) inclusion) are implemented. If
(numeric) sets and interval objects are mixed, the result will be an
interval object. Some basic interval arithmetic operations
(addition, subtraction, multiplication, division, power) as well
mathematical functions (<code>log</code>, <code>log2</code>, <code>log10</code>, <code>exp</code>,
<code>abs</code>, <code>sqrt</code>, <code>trunc</code>, <code>round</code>, <code>floor</code>,
<code>ceiling</code>, <code>signif</code>, and the trigonometric functions)
are defined. Note that the rounding functions will discretize the
interval. 
</p>
<p>Coercion methods for the <code>as.numeric</code>, <code>as.list</code>, and
<code>as.set</code> generics are implemented. <code>reals2integers()</code>
discretizes a real multi-interval. <code>integers2reals()</code> returns a
multi-interval of corresponding (degenerate) real intervals.
</p>
<p>The summary functions <code>min</code>, <code>max</code>, <code>range</code>,
<code>sum</code>, <code>mean</code> and <code>prod</code> are implemented and work
on the interval bounds.
</p>
<p><code>sets_options()</code> allows to change the style of open bounds
according to the ISO 31-11 standard using reversed brackets instead of
round parentheses (see examples).
</p>


<h3>Value</h3>

<p>For the predicates: a logical value. For all other functions:
an interval object.</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code> and <code><a href="#topic+gset">gset</a></code> for <em>finite</em> (generalized) sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### * general interval constructor

interval(1,5)
interval(1,5, "[)")
interval(1,5, "()")

## ambiguous notation -&gt; use alternative style
sets_options("openbounds", "][")
interval(1,5, "()")
sets_options("openbounds", "()")

interval(1,5, domain = "Z")
interval(1L, 5L)

## degenerate interval
interval(3)

## empty interval
interval()

#### * reals
reals()
reals(1,5)
reals(1,5,"()")
reals(1) ## half-unbounded

## (auto-)complement
!reals(1,5)
interval_complement(reals(1,5), reals(2, Inf))

## combine/c(reals(2,4), reals(3,5))
reals(2,4) | reals(3,5)

## intersection
reals(2,4) &amp; reals(3,5)

## overlapping intervals
reals(2,4) &amp; reals(3,5)
reals(2,4) &amp; reals(4,5,"(]")

## non-overlapping
reals(2,4) &amp; reals(7,8)
reals(2,4) | reals(7,8)
reals(2,4,"[)") | reals(4,5,"(]")

## degenerated cases
reals(2,4) | interval()
c(reals(2,4), set())

reals(2,4) | interval(6)
c(reals(2,4), set(6), 9)

## predicates
interval_is_empty(interval())
interval_is_degenerate(interval(4))
interval_is_bounded(reals(1,2))
interval_is_bounded(reals(1,Inf)) ## !! FALSE, because extended reals
interval_is_half_bounded(reals(1,Inf))
interval_is_left_bounded(reals(1,Inf))
interval_is_right_unbounded(reals(1,Inf))
interval_is_left_closed(reals(1,Inf))
interval_is_right_closed(reals(1,Inf)) ## !! TRUE

reals(1,2) &lt;= reals(1,5)
reals(1,2) &lt; reals(1,2)
reals(1,2) &lt;= reals(1,2,"[)")
reals(1,2,"[)") &lt; reals(1,2)

#### * integers
integers()
naturals()
naturals0()

3 %..% 5
integers(3, 5)
integers(3, 5) | integers(6,9)
integers(3, 5) | integers(7,9)

interval_complement(naturals(), integers())

naturals() &lt;= naturals0()
naturals0() &lt;= integers()

## mix reals and integers
c(reals(2,5), integers(7,9))
interval_complement(reals(2,5), integers())
interval_complement(integers(2,5), reals())

try(interval_complement(integers(), reals()), silent = TRUE)
## infeasible --&gt; error

integers() &lt;= reals()
reals() &lt;= integers()

### interval arithmetic
x &lt;- interval(2,4)
y &lt;- interval(3,6)
x + y
x - y
x * y
x / y

## summary functions
min(x, y)
max(y)
range(y)
mean(y)
</code></pre>

<hr>
<h2 id='labels'>Labels from objects</h2><span id='topic+LABELS'></span><span id='topic+LABEL'></span><span id='topic+LABEL.character'></span>

<h3>Description</h3>

<p>Creates &ldquo;nice&rdquo; labels from objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LABELS(x, max_width = NULL, dots = "...", unique = FALSE,
       limit = NULL, ...)
LABEL(x, limit = NULL, ...)
## S3 method for class 'character'
LABEL(x, limit = NULL, quote = sets_options("quote"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labels_+3A_x">x</code></td>
<td>
<p>For <code>LABELS</code>, a vector of <span class="rlang"><b>R</b></span> objects (if the object is
not a vector, it is converted using <code>as.list</code>).
For <code>LABEL</code>, an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="labels_+3A_max_width">max_width</code></td>
<td>
<p>Integer vector (recycled as needed) specifying the
maximum label width for each component of <code>x</code>.
If <code>NULL</code>, there is no limit, otherwise, the label will be
truncated to <code>max_width</code>.</p>
</td></tr>
<tr><td><code id="labels_+3A_dots">dots</code></td>
<td>
<p>A character string appended to a truncated label.
If <code>NULL</code>, nothing is appended.</p>
</td></tr>
<tr><td><code id="labels_+3A_unique">unique</code></td>
<td>
<p>Logical indicating whether
<code><a href="base.html#topic+make.unique">make.unique</a></code> should be called on the final
result.</p>
</td></tr>
<tr><td><code id="labels_+3A_limit">limit</code></td>
<td>
<p>Maximum length of vectors or sets to be represented as
is. Longer elements will be replaced by a label.</p>
</td></tr>
<tr><td><code id="labels_+3A_quote">quote</code></td>
<td>
<p>Should character strings be quoted, or not?
(default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="labels_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the <code>LABEL</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of labels generated from the supplied object(s).
<code>LABELS</code> first checks whether the object has names and uses these
if any; otherwise, <code>LABEL</code> is called for each element to generate
a &ldquo;short&rdquo; representation.
</p>
<p><code>LABEL</code> is generic to allow user extensions.
The current methods return the result of <code><a href="base.html#topic+format">format</a></code> if the
argument is of length 1 (for objects of classes <code><a href="#topic+set">set</a></code> and
<code><a href="#topic+tuple">tuple</a></code>: by default of length 5), and create a simple class
information otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LABELS(list(1, "test", X = "1", 1:5))
LABELS(set(X = as.tuple(1:20), "test", list(list(list(1,2)))))
LABELS(set(pair(1,2), set("a", 2), as.tuple(1:10)))
LABELS(set(pair(1,2), set("a", 2), as.tuple(1:10)), limit = 11)
</code></pre>

<hr>
<h2 id='options'>Options for the &lsquo;sets&rsquo; package</h2><span id='topic+sets_options'></span>

<h3>Description</h3>

<p>Function for getting and setting options for the
<span class="pkg">sets</span> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sets_options(option, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="options_+3A_option">option</code></td>
<td>
<p>character string indicating the option to get
or set (see details). If missing, all options are returned as a list.</p>
</td></tr>
<tr><td><code id="options_+3A_value">value</code></td>
<td>
<p>Value to be set. If omitted, the current value is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the following options are available:
</p>

<dl>
<dt><code>"quote"</code>:</dt><dd><p>logical specifying whether labels for
character elements are quoted or not (default: <code>TRUE</code>).</p>
</dd>
<dt><code>"hash"</code>:</dt><dd><p>logical specifying whether set elements
are hashed or not (default: <code>TRUE</code>).</p>
</dd>
<dt><code>"matchfun"</code>:</dt><dd><p>the default matching function for
<code><a href="#topic+cset">cset</a></code> (default: <code>NULL</code>).</p>
</dd>
<dt><code>"orderfun"</code>:</dt><dd><p>the default ordering function for
<code><a href="#topic+cset">cset</a></code> (default: <code>NULL</code>).</p>
</dd>
<dt><code>"universe"</code>:</dt><dd><p>the default universe for
generalized sets (default: <code>NULL</code>).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+cset">cset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sets_options()
sets_options("quote", TRUE)
print(set("a"))
sets_options("quote", FALSE)
print(set("a"))
</code></pre>

<hr>
<h2 id='outer'>Outer Product of Sets (Tuples)</h2><span id='topic+set_outer'></span><span id='topic+gset_outer'></span><span id='topic+cset_outer'></span><span id='topic+tuple_outer'></span>

<h3>Description</h3>

<p>Outer &ldquo;product&rdquo; of (g)sets (tuples).</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
gset_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
cset_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
tuple_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outer_+3A_x">X</code>, <code id="outer_+3A_y">Y</code></td>
<td>
<p>Set (tuple) objects or vectors. If <code>Y</code> is omitted, <code>X</code>
will be used instead. In this case, <code>FUN</code> can also be specified
as <code>Y</code> for convenience.</p>
</td></tr>
<tr><td><code id="outer_+3A_fun">FUN</code></td>
<td>
<p>A function or function name (character string).</p>
</td></tr>
<tr><td><code id="outer_+3A_simplify">SIMPLIFY</code></td>
<td>
<p>Logical. If <code>TRUE</code> and all return values of
<code>FUN</code> are atomic and of length 1, the result will be an atomic
matrix; otherwise, a recursive one (a list with <code>dim</code>
attribute).</p>
</td></tr>
<tr><td><code id="outer_+3A_quote">quote</code></td>
<td>
<p>logical indicating whether the character strings used for
the row and column names of the returned matrix should
be quoted.</p>
</td></tr>
<tr><td><code id="outer_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies <code>FUN</code> to all pairs of elements specified in
<code>X</code> and <code>Y</code>.  Basically intended as a replacement for
<code><a href="base.html#topic+outer">outer</a></code> for sets (tuples), it will also accept any vector for
<code>X</code> and <code>Y</code>.  The return value will be a matrix of dimension
<code>length(X)</code> times <code>length(Y)</code>, atomic or recursive
depending on the complexity of <code>FUN</code>'s return type and the
<code>SIMPLIFY</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code>, <code><a href="#topic+tuple">tuple</a></code>, <code><a href="base.html#topic+outer">outer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_outer(set(1,2), set(1,2,3), "/")
X &lt;- set_outer(set(1,2), set(1,2,3), pair)
X[[1,1]]
Y &lt;- set_outer(set(1,2), set(1,2,3), set)
Y[[1,1]]
set_outer(2 ^ set(1,2,3), set_is_subset)

tuple_outer(pair(1,2), triple(1,2,3))
tuple_outer(1:5, 1:4, "^")
</code></pre>

<hr>
<h2 id='plot'>Plot functions for generalized sets</h2><span id='topic+plot.gset'></span><span id='topic+plot.set'></span><span id='topic+plot.cset'></span><span id='topic+plot.tuple'></span><span id='topic+plot.charfun_generator'></span><span id='topic+lines.gset'></span><span id='topic+lines.set'></span><span id='topic+lines.cset'></span><span id='topic+lines.tuple'></span><span id='topic+lines.charfun_generator'></span>

<h3>Description</h3>

<p>Plot and lines functions for (tuples of) generalized sets and
function generators of characteristic functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gset'
plot(x, type = NULL, ylim = NULL,
         xlab = "Universe", ylab = "Membership Grade", ...)
## S3 method for class 'cset'
plot(x, ...)
## S3 method for class 'set'
plot(x, ...)
## S3 method for class 'tuple'
plot(x, type = "l", ylim = NULL,
         xlab = "Universe", ylab = "Membership Grade", col = 1,
         continuous = TRUE, ...)
## S3 method for class 'charfun_generator'
plot(x, universe = NULL, ...)

## S3 method for class 'gset'
lines(x, type = "l", col = 1, continuous = TRUE,
         universe = NULL, ...)
## S3 method for class 'cset'
lines(x, ...)
## S3 method for class 'set'
lines(x, ...)
## S3 method for class 'tuple'
lines(x, col = 1, universe = NULL, ...)
## S3 method for class 'charfun_generator'
lines(x, universe = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>For a method for class <var>foo</var>, an object of class
<var>foo</var>.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>Same as the <code>type</code> argument of
<code><a href="graphics.html#topic+plot">plot</a></code>.  For <code>plot.gset</code>
and <code>plot.cset</code>, <code>"barplot"</code> can also be used.</p>
</td></tr>
<tr><td><code id="plot_+3A_universe">universe</code></td>
<td>
<p>Universal set used for setting up the plot region. By
default, this is deduced from the object(s) to be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>Character or integer vector specifying the color of the
object(s) to be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_continuous">continuous</code></td>
<td>
<p>Logical indicating whether zero membership degrees
&ldquo;inside&rdquo; the graph should be ignored.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code>, <code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>Character labels for the axes.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>Double vector of length 2 defining the range of the y axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the default plot methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The main argument (invisibly).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code>, <code><a href="#topic+gset">gset</a></code>, and <code><a href="#topic+tuple">tuple</a></code> for the
set types, and <code><a href="#topic+fuzzy_normal">fuzzy_normal</a></code> for available characteristic
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## basic plots
plot(gset(1:3, 1:3/3))
plot(gset(1:3, 1:3/3, universe = 0:4))
plot(gset(c("a", "b"), list(1:2/2, 0.3)))

## characteristic functions
plot(fuzzy_normal)
plot(tuple(fuzzy_normal, fuzzy_bell), col = 1:2)
plot(fuzzy_pi3_gset(min = 2, max = 15))

## superposing plots using lines()
x &lt;- fuzzy_normal_gset()
y &lt;- fuzzy_trapezoid_gset(corners = c(5, 10, 15, 17), height = c(0.7, 1))
plot(tuple(x, y))
lines(x | y, col = 2)
lines(x &amp; y, col = 3)

## another example using gset_mean
x &lt;- fuzzy_two_normals_gset(sd = c(2, 1))
y &lt;- fuzzy_trapezoid_gset(corners = c(5, 9, 11, 15))
plot(tuple(x, y))
lines(tuple(gset_mean(x, y),
            gset_mean(x, y, "geometric"),
            gset_mean(x, y, "harmonic")),
      col = 2:4)

## creating a sequence of sets
plot(fuzzy_tuple(fuzzy_cone, 10), col = gray.colors(10))
</code></pre>

<hr>
<h2 id='set'>Sets</h2><span id='topic+set'></span><span id='topic+as.set'></span><span id='topic+make_set_with_order'></span><span id='topic+is.set'></span><span id='topic+set_is_empty'></span><span id='topic+set_is_subset'></span><span id='topic+set_is_proper_subset'></span><span id='topic+set_is_equal'></span><span id='topic+set_contains_element'></span><span id='topic+set_union'></span><span id='topic+set_intersection'></span><span id='topic+set_symdiff'></span><span id='topic+set_complement'></span><span id='topic+set_cardinality'></span><span id='topic+length.set'></span><span id='topic+lengths.set'></span><span id='topic+set_power'></span><span id='topic+set_cartesian'></span><span id='topic+set_combn'></span>

<h3>Description</h3>

<p>Creation and manipulation of sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>set(...)
as.set(x)
make_set_with_order(x)
is.set(x)

set_is_empty(x)
set_is_subset(x, y)
set_is_proper_subset(x, y)
set_is_equal(x, y)
set_contains_element(x, e)

set_union(...)
set_intersection(...)
set_symdiff(...)
set_complement(x, y)
set_cardinality(x)
## S3 method for class 'set'
length(x)
## S3 method for class 'set'
lengths(x, use.names = TRUE)
set_power(x)
set_cartesian(...)
set_combn(x, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_+3A_x">x</code></td>
<td>
<p>For <code>as.set()</code> and <code>is.set()</code>:
an <span class="rlang"><b>R</b></span> object. A set object otherwise.</p>
</td></tr>
<tr><td><code id="set_+3A_y">y</code></td>
<td>
<p>A set object.</p>
</td></tr>
<tr><td><code id="set_+3A_e">e</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="set_+3A_m">m</code></td>
<td>
<p>Number of elements to choose.</p>
</td></tr>
<tr><td><code id="set_+3A_use.names">use.names</code></td>
<td>
<p>logical; should the names of <code>x</code> be used in the result?</p>
</td></tr>
<tr><td><code id="set_+3A_...">...</code></td>
<td>
<p>For <code>set()</code>: <span class="rlang"><b>R</b></span> objects, and set objects otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions represent basic infrastructure for handling sets
of general (<span class="rlang"><b>R</b></span>) objects. The <code>set_is_<var>foo</var>()</code> predicates
are vectorized. In addition
to the methods defined, one can use the following operators:
<code>|</code> for the union,
<code>-</code> for the difference (or complement), <code>&amp;</code> for the
intersection, <code>%D%</code> for the symmetric difference,
<code>*</code> and <code>^<var>n</var></code> for the
(<code class="reqn">n</code>-fold) cartesian product, <code>2^</code> for the power set,
<code>%e%</code> for the element-of predicate,
<code>&lt;</code> and <code>&lt;=</code> for
the (proper) subset predicate, <code>&gt;</code> and <code>&gt;=</code> for
the (proper) superset predicate, and <code>==</code> and <code>!=</code> for
(in)equality. The <code>length</code> method for sets gives the
cardinality. The <code>lengths</code> method coerces the set to a list
before applying the <code>length</code> method on its elements.
<code>set_combn</code> returns the set of all
subsets of specified length. The <code>Summary</code> methods do also work if
defined for the set elements. The <code><a href="base.html#topic+mean">mean</a></code> and
<code><a href="stats.html#topic+median">median</a></code>
methods try to convert the object to a numeric vector before calling
the default methods.
</p>
<p>Because set elements are unordered, it is not allowed to use
<em>positional</em> indexing. However, it is possible to
do indexing using element labels or
simply the elements themselves (useful, e.g., for subassignment).
In addition, it is possible to iterate over
<em>all</em> elements using <code>for</code> and <code>lapply</code>/<code>sapply</code>.
</p>
<p>Note that converting objects to sets may change the internal order
of the elements, so that iterating over the original data
might give different results than iterating over the corresponding
set. The permutation can be obtained using the generic function
<code>make_set_with_order</code>, returning both the set and the ordering.
<code>as.set</code> simply calls
<code>make_set_with_order</code> internally and strips the order
information, so user-defined
methods for coercion have to be provided for the latter and not for
<code>as.set</code>.
</p>
<p>Note that <code>set_union</code>, <code>set_intersection</code>, and
<code>set_symdiff</code> accept any number of arguments. The <code class="reqn">n</code>-ary
symmetric difference of sets contains
just elements which are in an odd number of the sets.
</p>
<p><code>set_contains_element</code> is vectorized in <code>e</code>, that is, if <code>e</code>
is an atomic vector or list, the is-element operation is performed
element-wise, and a logical vector returned. Note that, however,
objects of class <code>tuple</code> are taken as atomic objects to
correctly handle sets of tuples.
</p>


<h3>Value</h3>

<p>For the predicate functions, a vector of logicals.
For <code>make_set_with_order</code>,
a list with two components <code>"set"</code> and <code>"order"</code>. For
<code>set_cardinality</code> and the length method, an integer value.
For the <code>lengths</code> method, an integer vector. For all
others, a set.
</p>


<h3>References</h3>

<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1&ndash;27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_outer">set_outer</a></code>,
<code><a href="#topic+gset">gset</a></code> for generalized sets,
and <code><a href="#topic+tuple">tuple</a></code> for tuples (&ldquo;vectors&rdquo;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## constructor
s &lt;- set(1L, 2L, 3L)
s

## named elements
snamed &lt;- set(one = 1, 2, three = 3)
snamed

## indexing by label
snamed[["one"]]

## subassignment
snamed[c(2,3)] &lt;- c("a","b")
snamed

## a more complex set
set(c, "test", list(1, 2, 3))

## converter
s2 &lt;- as.set(2:5)
s2

## converter with order
make_set_with_order(5:1)

## set of sets
set(set(), set(1))

## cartesian product
s * s2
s * s
s ^ 2 # same as above
s ^ 3

## power set
2 ^ s

## tuples
s3 &lt;- set(tuple(1,2,3), tuple(2,3,4))
s3

## Predicates:

## element
1:2 %e% s
tuple(1,2,3) %e% s3

## subset
s &lt;= s2
s2 &gt;= s # same

## proper subset
s &lt; s

## complement, union, intersection, symmetric difference:
s - set(1L)
s + set("a") # or use: s | set("a")
s &amp; s
s %D% s2
set(1,2,3) - set(1,2)
set_intersection(set(1,2,3), set(2,3,4), set(3,4,5))
set_union(set(1,2,3), set(2,3,4), set(3,4,5))
set_symdiff(set(1,2,3), set(2,3,4), set(3,4,5))

## subsets:
set_combn(as.set(1:3),2)

## iterators:
sapply(s, sqrt)
for (i in s) print(i)

## Summary methods
sum(s)
range(s)

## mean / median
mean(s)
median(s)

## cardinality
s &lt;- set(1, list(1, 2))
length(s)
lengths(s)

## vectorization
list(set(1), set(2), set()) == set(1)
</code></pre>

<hr>
<h2 id='sets-internal'>Internal</h2><span id='topic+.cartesian_product'></span><span id='topic+.exact_match'></span><span id='topic+.get_memberships'></span><span id='topic+.make_gset_from_support_and_memberships'></span><span id='topic+.make_set_of_tuples_from_list_of_lists'></span><span id='topic+.ntuple'></span><span id='topic+.set_subset'></span><span id='topic+fuzzy_logic_predicates'></span>

<h3>Description</h3>

<p>Internal functions not intended for public use.</p>

<hr>
<h2 id='similarity'>Similarity and Dissimilarity Functions</h2><span id='topic+set_similarity'></span><span id='topic+gset_similarity'></span><span id='topic+cset_similarity'></span><span id='topic+set_dissimilarity'></span><span id='topic+gset_dissimilarity'></span><span id='topic+cset_dissimilarity'></span>

<h3>Description</h3>

<p>Similarities and dissimilarities for (generalized) sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_similarity(x, y, method = "Jaccard")
gset_similarity(x, y, method = "Jaccard")
cset_similarity(x, y, method = "Jaccard")

set_dissimilarity(x, y,
                  method = c("Jaccard", "Manhattan", "Euclidean",
                             "L1", "L2"))
gset_dissimilarity(x, y,
                   method = c("Jaccard", "Manhattan", "Euclidean",
                              "L1", "L2"))
cset_dissimilarity(x, y,
                   method = c("Jaccard", "Manhattan", "Euclidean",
                              "L1", "L2"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="similarity_+3A_x">x</code>, <code id="similarity_+3A_y">y</code></td>
<td>
<p>Two (generalized/customizable) sets.</p>
</td></tr>
<tr><td><code id="similarity_+3A_method">method</code></td>
<td>
<p>Character string specifying the proximity method (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two generalized sets <code class="reqn">X</code> and <code class="reqn">Y</code>, the
<code>Jaccard</code> similarity is <code class="reqn">|X \cap Y| / |X \cup Y|</code> where <code class="reqn">|\cdot|</code> denotes the cardinality for
generalized sets (sum of memberships). The <code>Jaccard</code> 
dissimilarity is 1 minus the similarity.
</p>
<p>The <code>L1</code> (or <code>Manhattan</code>) and <code>L2</code> (or
<code>Euclidean</code>) 
dissimilarities are defined as
follows. For two fuzzy multisets <code class="reqn">A</code> and <code class="reqn">B</code> on a
given universe <code class="reqn">X</code> with elements <code class="reqn">x</code>, let
<code class="reqn">M_A(x)</code> and <code class="reqn">M_B(x)</code> be functions returning the memberships of an
element <code class="reqn">x</code> in sets <code class="reqn">A</code> and <code class="reqn">B</code>, respectively. The
memberships are returned in <em>standard form</em>,
i.e. as an infinite vector of decreasing membership
values, e.g. <code class="reqn">(1, 0.3, 0, 0, \dots)</code>.
Let <code class="reqn">M_A(x)_i</code> and <code class="reqn">M_B(x)_i</code> denote the <code class="reqn">i</code>th components of these
membership vectors. Then the L1 distance is defined as:
</p>
<p style="text-align: center;"><code class="reqn">d_1(A, B) = \sum_{x \in X}\sum_{i=1}{\infty}|M_A(x)_i -
  M_B(x)_i|</code>
</p>
<p> and the L2
distance as: </p>
<p style="text-align: center;"><code class="reqn">d_2(A, B) = \sqrt{\sum_{x \in
  X}\sum_{i=1}{\infty}|M_A(x)_i - M_B(x)_i|^2}</code>
</p>



<h3>Value</h3>

<p>A numeric value (similarity or dissimilarity, as specified).
</p>


<h3>Source</h3>

<p>T. Matthe, R. De Caluwe, G. de Tre, A. Hallez, J. Verstraete, M. Leman,
O. Cornelis, D. Moelants, and J. Gansemans (2006),
Similarity Between Multi-valued Thesaurus
Attributes: Theory and Application in Multimedia Systems,
<em>Flexible Query Answering Systems</em>,
Lecture Notes in Computer Science, Springer, 331&ndash;342.
</p>
<p>K. Mizutani, R. Inokuchi, and S. Miyamoto (2008),
Algorithms of Nonlinear Document Clustering Based on Fuzzy Multiset
Model,
<em>International Journal of Intelligent Systems</em>,
<b>23</b>, 176&ndash;198.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- set("a", "b", "c")
B &lt;- set("c", "d", "e")
set_similarity(A, B)
set_dissimilarity(A, B)

A &lt;- gset(c("a", "b", "c"), c(0.3, 0.7, 0.9))
B &lt;- gset(c("c", "d", "e"), c(0.2, 0.4, 0.5))
gset_similarity(A, B, "Jaccard")
gset_dissimilarity(A, B, "Jaccard")
gset_dissimilarity(A, B, "L1")
gset_dissimilarity(A, B, "L2")

A &lt;- gset(c("a", "b", "c"), list(c(0.3, 0.7), 0.1, 0.9))
B &lt;- gset(c("c", "d", "e"), list(0.2, c(0.4, 0.5), 0.8))
gset_similarity(A, B, "Jaccard")
gset_dissimilarity(A, B, "Jaccard")
gset_dissimilarity(A, B, "L1")
gset_dissimilarity(A, B, "L2")
</code></pre>

<hr>
<h2 id='tuple'>Tuples</h2><span id='topic+tuple'></span><span id='topic+singleton'></span><span id='topic+pair'></span><span id='topic+triple'></span><span id='topic+as.tuple'></span><span id='topic+is.tuple'></span><span id='topic+tuple_is_ntuple'></span><span id='topic+tuple_is_singleton'></span><span id='topic+tuple_is_pair'></span><span id='topic+tuple_is_triple'></span>

<h3>Description</h3>

<p>Creation and manipulation of tuples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuple(...)
as.tuple(x)
is.tuple(x)
singleton(...)
pair(...)
triple(...)
tuple_is_singleton(x)
tuple_is_pair(x)
tuple_is_triple(x)
tuple_is_ntuple(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tuple_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="tuple_+3A_n">n</code></td>
<td>
<p>A non-negative integer.</p>
</td></tr>
<tr><td><code id="tuple_+3A_...">...</code></td>
<td>
<p>Possibly named <span class="rlang"><b>R</b></span> objects (for <code>singleton</code>,
<code>pair</code>, and
<code>triple</code> exactly one, two, and three, respectively.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions represent basic infrastructure for handling tuples of
general (<span class="rlang"><b>R</b></span>) objects.  Class <code>tuple</code> is used in particular to
correctly handle cartesian products of sets.  Although tuple objects
should behave like &ldquo;ordinary&rdquo; vectors, some operations might
yield unexpected results since tuple objects are in fact list objects
internally. The <code>Summary</code> methods do work if
defined for the set elements. The <code><a href="base.html#topic+mean">mean</a></code> and
<code><a href="stats.html#topic+median">median</a></code>
methods try to convert the object to a numeric vector before calling
the default methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set">set</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Constructor.
tuple(1,2,3, TRUE)
triple(1,2,3)
pair(Name = "David", Height = 185)
tuple_is_triple(triple(1,2,3))
tuple_is_ntuple(tuple(1,2,3,4), 4)

## Converter.
as.tuple(1:3)

## Operations.
c(tuple("a","b"), 1)
tuple(1,2,3) * tuple(2,3,4)
rep(tuple(1,2,3), 2)
min(tuple(1,2,3))
sum(tuple(1,2,3))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
