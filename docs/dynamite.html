<!DOCTYPE html><html><head><title>Help for package dynamite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dynamite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dynamite-package'><p>The <code>dynamite</code> package.</p></a></li>
<li><a href='#as_draws_df.dynamitefit'><p>Convert <code>dynamite</code> Output to <code>draws_df</code> Format</p></a></li>
<li><a href='#as.data.frame.dynamitefit'><p>Extract Samples From a <code>dynamitefit</code> Object as a Data Frame</p></a></li>
<li><a href='#as.data.table.dynamitefit'><p>Extract Samples From a <code>dynamitefit</code> Object as a Data Table</p></a></li>
<li><a href='#categorical_example'><p>Simulated Categorical Multivariate Panel Data</p></a></li>
<li><a href='#categorical_example_fit'><p>Model Fit for the Simulated Categorical Multivariate Panel Data</p></a></li>
<li><a href='#coef.dynamitefit'><p>Extract Regression Coefficients of a Dynamite Model</p></a></li>
<li><a href='#confint.dynamitefit'><p>Credible Intervals for Dynamite Model Parameters</p></a></li>
<li><a href='#dynamite'><p>Estimate a Bayesian Dynamic Multivariate Panel Model</p></a></li>
<li><a href='#dynamiteformula'><p>Model formula for <span class="pkg">dynamite</span></p></a></li>
<li><a href='#fitted.dynamitefit'><p>Extract Fitted Values of a Dynamite Model</p></a></li>
<li><a href='#gaussian_example'><p>Simulated Data of Gaussian Responses</p></a></li>
<li><a href='#gaussian_example_fit'><p>Model Fit for the Simulated Data of Gaussian Responses</p></a></li>
<li><a href='#gaussian_simulation_fit'><p>Model Fit for the time-varying example in the <code>dynamite_simulation</code> Vignette</p></a></li>
<li><a href='#get_code'><p>Extract the Stan Code of the Dynamite Model</p></a></li>
<li><a href='#get_data'><p>Extract the Model Data of the Dynamite Model</p></a></li>
<li><a href='#get_parameter_dims'><p>Get Parameter Dimensions of the Dynamite Model</p></a></li>
<li><a href='#get_parameter_names'><p>Get Parameter Names of the Dynamite Model</p></a></li>
<li><a href='#get_parameter_types'><p>Get Parameter Types of the Dynamite Model</p></a></li>
<li><a href='#get_priors'><p>Get Prior Definitions of a Dynamite Model</p></a></li>
<li><a href='#lags'><p>Add Lagged Responses as Predictors to Each Channel of a Dynamite Model</p></a></li>
<li><a href='#lfactor'><p>Define a Common Latent Factor for the Dynamite Model.</p></a></li>
<li><a href='#lfo'><p>Approximate Leave-Future-Out (LFO) Cross-validation</p></a></li>
<li><a href='#loo.dynamitefit'><p>Approximate Leave-One-Out (LOO) Cross-validation</p></a></li>
<li><a href='#mcmc_diagnostics'><p>Diagnostic Values of a Dynamite Model</p></a></li>
<li><a href='#multichannel_example'><p>Simulated Multivariate Panel Data</p></a></li>
<li><a href='#multichannel_example_fit'><p>Model Fit for the Simulated Multivariate Panel Data</p></a></li>
<li><a href='#ndraws.dynamitefit'><p>Return the Number of Posterior Draws of a <code>dynamitefit</code> Object</p></a></li>
<li><a href='#nobs.dynamitefit'><p>Extract the Number of Observations Used to Fit a Dynamite Model</p></a></li>
<li><a href='#plot_betas'><p>Plot Time-invariant Regression Coefficients of a Dynamite Model</p></a></li>
<li><a href='#plot_deltas'><p>Plot Time-varying Regression Coefficients of a Dynamite Model</p></a></li>
<li><a href='#plot_lambdas'><p>Plot Factor Loadings of a Dynamite Model</p></a></li>
<li><a href='#plot_nus'><p>Plot Random effects of a Dynamite Model</p></a></li>
<li><a href='#plot_psis'><p>Plot Latent Factors of a Dynamite Model</p></a></li>
<li><a href='#plot.dynamitefit'><p>Traceplots and Density Plots for a <code>dynamitefit</code> Object</p></a></li>
<li><a href='#plot.lfo'><p>Diagnostic Plot for Pareto k Values from LFO</p></a></li>
<li><a href='#predict.dynamitefit'><p>Predict Method for a Dynamite Model</p></a></li>
<li><a href='#print.lfo'><p>Print the results from the LFO</p></a></li>
<li><a href='#random_spec'><p>Additional Specifications for the Group-level Random Effects of the DMPM</p></a></li>
<li><a href='#splines'><p>Define the B-splines Used for the Time-varying Coefficients of the Model.</p></a></li>
<li><a href='#update.dynamitefit'><p>Update a Dynamite Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Modeling and Causal Inference for Multivariate
Longitudinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Easy-to-use and efficient interface for 
  Bayesian inference of complex panel (time series) data using dynamic 
  multivariate panel models by Helske and Tikka (2022) 
  &lt;<a href="https://doi.org/10.31235%2Fosf.io%2Fmdwu5">doi:10.31235/osf.io/mdwu5</a>&gt;. The package supports joint modeling of multiple 
  measurements per individual, time-varying and time-invariant effects, and a 
  wide range of discrete and continuous distributions. Estimation of these 
  dynamic multivariate panel models is carried out via 'Stan'. For an 
  in-depth tutorial of the package, see (Tikka and Helske, 2023) 
  &lt;<a href="https://doi.org/10.48550/arXiv.2302.01607">doi:10.48550/arXiv.2302.01607</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/dynamite/">https://docs.ropensci.org/dynamite/</a>,
<a href="https://github.com/ropensci/dynamite/">https://github.com/ropensci/dynamite/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/dynamite/issues/">https://github.com/ropensci/dynamite/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, cli, data.table, glue, ggplot2, loo, methods,
patchwork, posterior, rlang, rstan, stats, tibble (&ge; 2.0.0),
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, cmdstanr, covr, dplyr, knitr, mockthat, rmarkdown,
testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 09:58:03 UTC; santikka</td>
</tr>
<tr>
<td>Author:</td>
<td>Santtu Tikka <a href="https://orcid.org/0000-0003-4039-4342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jouni Helske <a href="https://orcid.org/0000-0001-7130-793X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nicholas Clark [rev],
  Lucy Dâ€™Agostino McGowan [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Santtu Tikka &lt;santtuth@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dynamite-package'>The <code>dynamite</code> package.</h2><span id='topic+dynamite-package'></span>

<h3>Description</h3>

<p>Easy-to-use and efficient interface for Bayesian inference of
complex panel data consisting of multiple individuals with multiple
measurements over time. Supports several observational distributions,
time-varying effects and realistic counterfactual predictions which take into
account the dynamic structure of the model.
</p>


<h3>See Also</h3>


<ul>
<li><p> The package vignette.
</p>
</li>
<li> <p><code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> for information on defining models.
</p>
</li>
<li> <p><code><a href="#topic+dynamite">dynamite()</a></code> for information on fitting models.
</p>
</li>
<li> <p><a href="https://github.com/ropensci/dynamite/issues/">https://github.com/ropensci/dynamite/issues/</a> to submit a bug report
or a feature request.
</p>
</li></ul>



<h3>Authors</h3>


<table>
<tr>
 <td style="text-align: left;">
   Santtu Tikka (author) </td><td style="text-align: left;"> <a href="mailto:santtuth@gmail.com">santtuth@gmail.com</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Jouni Helske (author) </td><td style="text-align: left;"> <a href="mailto:jouni.helske@iki.fi">jouni.helske@iki.fi</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='as_draws_df.dynamitefit'>Convert <code>dynamite</code> Output to <code>draws_df</code> Format</h2><span id='topic+as_draws_df.dynamitefit'></span><span id='topic+as_draws_df'></span><span id='topic+as_draws.dynamitefit'></span><span id='topic+as_draws'></span>

<h3>Description</h3>

<p>Converts the output from a <code><a href="#topic+dynamite">dynamite()</a></code> call to a
<code>draws_df</code> format of the <span class="pkg">posterior</span> package, enabling the use
of diagnostics and plotting methods of <span class="pkg">posterior</span> and <span class="pkg">bayesplot</span>
packages. Note that this function returns variables in a wide format,
whereas <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code> uses the long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
as_draws_df(x, parameters = NULL, responses = NULL, types = NULL, ...)

## S3 method for class 'dynamitefit'
as_draws(x, parameters = NULL, responses = NULL, types = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_draws_df.dynamitefit_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="as_draws_df.dynamitefit_+3A_parameters">parameters</code></td>
<td>
<p>[<code>character()</code>]<br /> Parameter(s) for which the samples
should be extracted. Possible options can be found with function
<code>get_parameter_names()</code>. Default is all parameters of specific type for all
responses.</p>
</td></tr>
<tr><td><code id="as_draws_df.dynamitefit_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the samples
should be extracted. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this entire vector.
Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="as_draws_df.dynamitefit_+3A_types">types</code></td>
<td>
<p>[<code>character()</code>]<br /> Type(s) of the parameters for which the
samples should be extracted. See details of possible values. Default is
all values listed in details except spline coefficients <code>omega</code>,
<code>omega_alpha</code>, and <code>omega_psi</code>. See also <code><a href="#topic+get_parameter_types">get_parameter_types()</a></code>.
Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="as_draws_df.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can use the arguments <code>parameters</code>, <code>responses</code> and <code>types</code> to extract
only a subset of the model parameters (i.e., only certain types of
parameters related to a certain response variable).
</p>
<p>See potential values for the types argument in
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit()</a></code> and
<code><a href="#topic+get_parameter_names">get_parameter_names()</a></code> for potential values for <code>parameters</code>
argument.
</p>


<h3>Value</h3>

<p>A <code>draws_df</code> object.
</p>
<p>A <code>draws_df</code> object.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
as_draws(gaussian_example_fit, types = c("sigma", "beta"))

# Compute MCMC diagnostics using the posterior package
posterior::summarise_draws(as_draws(gaussian_example_fit))

</code></pre>

<hr>
<h2 id='as.data.frame.dynamitefit'>Extract Samples From a <code>dynamitefit</code> Object as a Data Frame</h2><span id='topic+as.data.frame.dynamitefit'></span>

<h3>Description</h3>

<p>Provides a <code>data.frame</code> representation of the posterior samples of the model
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  parameters = NULL,
  responses = NULL,
  types = NULL,
  summary = FALSE,
  probs = c(0.05, 0.95),
  include_fixed = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.dynamitefit_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_row.names">row.names</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_optional">optional</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_parameters">parameters</code></td>
<td>
<p>[<code>character()</code>]<br /> Parameter(s) for which the samples
should be extracted. Possible options can be found with function
<code>get_parameter_names()</code>. Default is all parameters of specific type for all
responses.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the samples
should be extracted. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this entire vector.
Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_types">types</code></td>
<td>
<p>[<code>character()</code>]<br /> Type(s) of the parameters for which the
samples should be extracted. See details of possible values. Default is
all values listed in details except spline coefficients <code>omega</code>,
<code>omega_alpha</code>, and <code>omega_psi</code>. See also <code><a href="#topic+get_parameter_types">get_parameter_types()</a></code>.
Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_summary">summary</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code>, returns posterior
mean, standard deviation, and posterior quantiles (as defined by the
<code>probs</code> argument) for all parameters. If <code>FALSE</code> (default), returns the
posterior samples instead.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_probs">probs</code></td>
<td>
<p>[<code>numeric()</code>]<br /> Quantiles of interest. Default is
<code>c(0.05, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_include_fixed">include_fixed</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default), time-varying
parameters for <code>1:fixed</code> time points are included in the output as <code>NA</code>
values. If <code>FALSE</code>, fixed time points are omitted completely
from the output.</p>
</td></tr>
<tr><td><code id="as.data.frame.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>responses</code> and <code>types</code> can be used to extract only a subset
of the model parameters (i.e., only certain types of parameters related to a
certain response variable).
</p>
<p>Potential values for the <code>types</code> argument are:
</p>

<ul>
<li> <p><code>alpha</code><br /> Intercept terms (time-invariant or time-varying).
</p>
</li>
<li> <p><code>beta</code><br /> Time-invariant regression coefficients.
</p>
</li>
<li> <p><code>delta</code><br /> Time-varying regression coefficients.
</p>
</li>
<li> <p><code>nu</code><br /> Group-level random effects.
</p>
</li>
<li> <p><code>lambda</code><br /> Factor loadings.
</p>
</li>
<li> <p><code>psi</code><br /> Latent factors.
</p>
</li>
<li> <p><code>tau</code><br /> Standard deviations of the spline coefficients of <code>delta</code>.
</p>
</li>
<li> <p><code>tau_alpha</code><br /> Standard deviations of the spline coefficients of
time-varying <code>alpha</code>.
</p>
</li>
<li> <p><code>sigma_nu</code><br /> Standard deviations of the random effects <code>nu</code>.
</p>
</li>
<li> <p><code>corr_nu</code><br /> Pairwise within-group correlations of random effects <code>nu</code>.
Samples of the full correlation matrix can be extracted manually as
<code>rstan::extract(fit$stanfit, pars = "corr_matrix_nu")</code> if necessary.
</p>
</li>
<li> <p><code>sigma_lambda</code><br /> Standard deviations of the latent factor loadings
<code>lambda</code>.
</p>
</li>
<li> <p><code>tau_psi</code><br /> Standard deviations of the the spline coefficients of <code>psi</code>.
</p>
</li>
<li> <p><code>corr_psi</code><br /> Pairwise correlations of the latent factors.
Samples of the full correlation matrix can be extracted manually as
<code>rstan::extract(fit$stanfit, pars = "corr_matrix_psi")</code> if necessary.
</p>
</li>
<li> <p><code>sigma</code><br /> Standard deviations of gaussian responses.
</p>
</li>
<li> <p><code>corr</code><br /> Pairwise correlations of multivariate gaussian responses.
</p>
</li>
<li> <p><code>phi</code><br /> Describes various distributional parameters, such as:
</p>

<ul>
<li><p> Dispersion parameter of the Negative Binomial distribution.
</p>
</li>
<li><p> Shape parameter of the Gamma distribution.
</p>
</li>
<li><p> Precision parameter of the Beta distribution.
</p>
</li>
<li><p> Degrees of freedom of the Student t-distribution.
</p>
</li></ul>

</li>
<li> <p><code>omega</code><br /> Spline coefficients of the regression coefficients <code>delta</code>.
</p>
</li>
<li> <p><code>omega_alpha</code><br /> Spline coefficients of time-varying <code>alpha</code>.
</p>
</li>
<li> <p><code>omega_psi</code><br /> Spline coefficients of the latent factors <code>psi</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> containing either samples or summary statistics of the
model parameters in a long format. For a wide format, see
<code><a href="#topic+as_draws">as_draws()</a></code>.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
as.data.frame(
  gaussian_example_fit,
  responses = "y",
  types = "beta"
)

# Basic summaries can be obtained automatically with summary = TRUE
as.data.frame(
  gaussian_example_fit,
  responses = "y",
  types = "beta",
  summary = TRUE
)

# Time-varying coefficients "delta"
as.data.frame(
  gaussian_example_fit,
  responses = "y",
  types = "delta",
  summary = TRUE
)

# Obtain summaries for a specific parameters
as.data.frame(
  gaussian_example_fit,
  parameters = c("tau_y_x", "sigma_y"),
  summary = TRUE
)

</code></pre>

<hr>
<h2 id='as.data.table.dynamitefit'>Extract Samples From a <code>dynamitefit</code> Object as a Data Table</h2><span id='topic+as.data.table.dynamitefit'></span><span id='topic+as.data.table'></span>

<h3>Description</h3>

<p>Provides a <code>data.table</code> representation of the posterior samples of the model
parameters. See <code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
as.data.table(
  x,
  keep.rownames = FALSE,
  row.names = NULL,
  optional = FALSE,
  parameters = NULL,
  responses = NULL,
  types = NULL,
  summary = FALSE,
  probs = c(0.05, 0.95),
  include_fixed = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.dynamitefit_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> Not used.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_row.names">row.names</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_optional">optional</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_parameters">parameters</code></td>
<td>
<p>[<code>character()</code>]<br /> Parameter(s) for which the samples
should be extracted. Possible options can be found with function
<code>get_parameter_names()</code>. Default is all parameters of specific type for all
responses.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the samples
should be extracted. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this entire vector.
Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_types">types</code></td>
<td>
<p>[<code>character()</code>]<br /> Type(s) of the parameters for which the
samples should be extracted. See details of possible values. Default is
all values listed in details except spline coefficients <code>omega</code>,
<code>omega_alpha</code>, and <code>omega_psi</code>. See also <code><a href="#topic+get_parameter_types">get_parameter_types()</a></code>.
Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_summary">summary</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code>, returns posterior
mean, standard deviation, and posterior quantiles (as defined by the
<code>probs</code> argument) for all parameters. If <code>FALSE</code> (default), returns the
posterior samples instead.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_probs">probs</code></td>
<td>
<p>[<code>numeric()</code>]<br /> Quantiles of interest. Default is
<code>c(0.05, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_include_fixed">include_fixed</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default), time-varying
parameters for <code>1:fixed</code> time points are included in the output as <code>NA</code>
values. If <code>FALSE</code>, fixed time points are omitted completely
from the output.</p>
</td></tr>
<tr><td><code id="as.data.table.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing either samples or summary statistics of
the model parameters.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
as.data.table(
  gaussian_example_fit,
  responses = "y",
  types = "beta",
  summary = FALSE
)

</code></pre>

<hr>
<h2 id='categorical_example'>Simulated Categorical Multivariate Panel Data</h2><span id='topic+categorical_example'></span>

<h3>Description</h3>

<p>A simulated data containing multiple individuals with two categorical
response variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorical_example
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 5 variables:
</p>

<dl>
<dt>id</dt><dd><p>Variable defining individuals (1 to 100).</p>
</dd>
<dt>time</dt><dd><p>Variable defining the time point of the measurement (1 to 20).</p>
</dd>
<dt>x</dt><dd><p>Categorical variable with three levels, A, B, and C.</p>
</dd>
<dt>y</dt><dd><p>Categorical variable with three levels, a, b, and c.</p>
</dd>
<dt>z</dt><dd><p>A continuous covariate.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was generated according to a script in
<a href="https://github.com/ropensci/dynamite/blob/main/data-raw/categorical_example.R">https://github.com/ropensci/dynamite/blob/main/data-raw/categorical_example.R</a>
</p>


<h3>See Also</h3>

<p>Example models
<code><a href="#topic+categorical_example_fit">categorical_example_fit</a></code>,
<code><a href="#topic+gaussian_example_fit">gaussian_example_fit</a></code>,
<code><a href="#topic+gaussian_example">gaussian_example</a></code>,
<code><a href="#topic+gaussian_simulation_fit">gaussian_simulation_fit</a></code>,
<code><a href="#topic+multichannel_example_fit">multichannel_example_fit</a></code>,
<code><a href="#topic+multichannel_example">multichannel_example</a></code>
</p>

<hr>
<h2 id='categorical_example_fit'>Model Fit for the Simulated Categorical Multivariate Panel Data</h2><span id='topic+categorical_example_fit'></span>

<h3>Description</h3>

<p>A <code>dynamitefit</code> object obtained by running <code>dynamite</code> on the
<code>categorical_example</code> dataset as
</p>
<pre>
set.seed(1)
library(dynamite)
f &lt;- obs(x ~ z + lag(x) + lag(y), family = "categorical") +
  obs(y ~ z + lag(x) + lag(y), family = "categorical")
categorical_example_fit &lt;- dynamite(
  f,
  data = categorical_example,
  time = "time",
  group = "id",
  chains = 1,
  refresh = 0,
  thin = 5,
  save_warmup = FALSE
)
</pre>
<p>Note the small number of samples due to size restrictions on CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorical_example_fit
</code></pre>


<h3>Format</h3>

<p>A <code>dynamitefit</code> object.
</p>


<h3>Source</h3>

<p>Script in
<a href="https://github.com/ropensci/dynamite/blob/main/data-raw/categorical_example_fit.R">https://github.com/ropensci/dynamite/blob/main/data-raw/categorical_example_fit.R</a>
</p>


<h3>See Also</h3>

<p>Example models
<code><a href="#topic+categorical_example">categorical_example</a></code>,
<code><a href="#topic+gaussian_example_fit">gaussian_example_fit</a></code>,
<code><a href="#topic+gaussian_example">gaussian_example</a></code>,
<code><a href="#topic+gaussian_simulation_fit">gaussian_simulation_fit</a></code>,
<code><a href="#topic+multichannel_example_fit">multichannel_example_fit</a></code>,
<code><a href="#topic+multichannel_example">multichannel_example</a></code>
</p>

<hr>
<h2 id='coef.dynamitefit'>Extract Regression Coefficients of a Dynamite Model</h2><span id='topic+coef.dynamitefit'></span>

<h3>Description</h3>

<p>Extracts either time-varying or time-invariant parameters of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
coef(
  object,
  parameters = NULL,
  type = c("beta", "delta", "nu", "lambda", "psi"),
  responses = NULL,
  summary = TRUE,
  probs = c(0.05, 0.95),
  include_alpha = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.dynamitefit_+3A_object">object</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="coef.dynamitefit_+3A_parameters">parameters</code></td>
<td>
<p>[<code>character()</code>]<br /> Parameter(s) for which the samples
should be extracted. Possible options can be found with function
<code>get_parameter_names()</code>. Default is all parameters of specific type for all
responses.</p>
</td></tr>
<tr><td><code id="coef.dynamitefit_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br /> Either <code>beta</code> (the default) for
time-invariant coefficients, <code>delta</code> for time-varying coefficients,
<code>nu</code> for random effects, <code>lambda</code> for factor loadings, or <code>psi</code> for
latent factor. Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="coef.dynamitefit_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the samples
should be extracted. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this entire vector.
Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="coef.dynamitefit_+3A_summary">summary</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code>, returns posterior
mean, standard deviation, and posterior quantiles (as defined by the
<code>probs</code> argument) for all parameters. If <code>FALSE</code> (default), returns the
posterior samples instead.</p>
</td></tr>
<tr><td><code id="coef.dynamitefit_+3A_probs">probs</code></td>
<td>
<p>[<code>numeric()</code>]<br /> Quantiles of interest. Default is
<code>c(0.05, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="coef.dynamitefit_+3A_include_alpha">include_alpha</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default), extracts also
time-invariant intercept term alpha if time-invariant parameters beta are
extracted, and time-varying alpha if time-varying delta are extracted.
Ignored if the argument <code>parameters</code> is supplied.
@param summary [<code>logical(1)</code>]<br /> If <code>TRUE</code> (default), returns posterior
mean, standard deviation, and posterior quantiles (as defined by the
<code>probs</code> argument) for all parameters. If <code>FALSE</code>, returns the
posterior samples instead.</p>
</td></tr>
<tr><td><code id="coef.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> containing either samples or summary statistics of the
model parameters in a long format.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
betas &lt;- coef(gaussian_example_fit, type = "beta")
deltas &lt;- coef(gaussian_example_fit, type = "delta")

</code></pre>

<hr>
<h2 id='confint.dynamitefit'>Credible Intervals for Dynamite Model Parameters</h2><span id='topic+confint.dynamitefit'></span>

<h3>Description</h3>

<p>Extracts credible intervals from <code>dynamitefit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.dynamitefit_+3A_object">object</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="confint.dynamitefit_+3A_parm">parm</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="confint.dynamitefit_+3A_level">level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Credible interval width.</p>
</td></tr>
<tr><td><code id="confint.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rows of the resulting <code>matrix</code> will be named using the following
logic: <code style="white-space: pre;">&#8288;{parameter}_{time}_{category}_{group}&#8288;</code> where <code>parameter</code> is the
name of the parameter, <code>time</code> is the time index of the parameter,
<code>category</code> specifies the level of the response the parameter
is related to if the response is categorical, and <code>group</code> determines which
group of observations the parameter is related to in the case of random
effects and loadings. Non-applicable fields in the this syntax are set
to <code>NA</code>.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
confint(gaussian_example_fit, level = 0.9)

</code></pre>

<hr>
<h2 id='dynamite'>Estimate a Bayesian Dynamic Multivariate Panel Model</h2><span id='topic+dynamite'></span><span id='topic+formula.dynamitefit'></span><span id='topic+print.dynamitefit'></span><span id='topic+summary.dynamitefit'></span>

<h3>Description</h3>

<p>Fit a Bayesian dynamic multivariate panel model (DMPM) using Stan for
Bayesian inference. The <span class="pkg">dynamite</span> package supports a wide range of
distributions and allows the user to flexibly customize the priors for the
model parameters. The dynamite model is specified using standard <span class="rlang"><b>R</b></span> formula
syntax via <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code>. For more information and examples,
see 'Details' and the package vignettes.
</p>
<p>The <code>formula</code> method returns the model definition as a quoted expression.
</p>
<p>Information on the estimated dynamite model can be obtained via
<code>print</code> including the following: The model formula, the data, the smallest
effective sample sizes, largest Rhat and summary statistics of the
time- and group-invariant model parameters.
</p>
<p>The <code>summary</code> method provides statistics of the posterior samples of the
model; this is an alias of <code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit()</a></code> with
<code>summary = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamite(
  dformula,
  data,
  time,
  group = NULL,
  priors = NULL,
  backend = "rstan",
  verbose = TRUE,
  verbose_stan = FALSE,
  stanc_options = list("O0"),
  threads_per_chain = 1L,
  grainsize = NULL,
  custom_stan_model = NULL,
  debug = NULL,
  ...
)

## S3 method for class 'dynamitefit'
formula(x, ...)

## S3 method for class 'dynamitefit'
print(x, full_diagnostics = FALSE, ...)

## S3 method for class 'dynamitefit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamite_+3A_dformula">dformula</code></td>
<td>
<p>[<code>dynamiteformula</code>]<br /> The model formula.
See <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> and 'Details'.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_data">data</code></td>
<td>
<p>[<code>data.frame</code>, <code>tibble::tibble</code>, or <code>data.table::data.table</code>]<br />
The data that contains the variables in the model in long format.
Supported column types are <code>integer</code>, <code>logical</code>, <code>double</code>, and
<code>factor</code>. Columns of type <code>character</code> will be converted to factors.
Unused factor levels will be dropped. The <code>data</code> can contain missing
values which will simply be ignored in the estimation in a case-wise
fashion (per time-point and per channel). Input <code>data</code> is converted to
channel specific matrix representations via <code><a href="stats.html#topic+model.matrix">stats::model.matrix.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_time">time</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
time index of observations. If this variable is a factor, the integer
representation of its levels are used internally for defining the time
indexing.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_group">group</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
unique groups or <code>NULL</code> corresponding to a scenario without any groups.
If <code>group</code> is <code>NULL</code>, a new column <code>.group</code> is created with constant
value <code>1L</code> is created indicating that all observations belong to the same
group. In case of name conflicts with <code>data</code>, see the <code>group_var</code> element
of the return object to get the column name of the new variable.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_priors">priors</code></td>
<td>
<p>[<code>data.frame</code>]<br /> An optional data frame with prior
definitions. See <code><a href="#topic+get_priors">get_priors()</a></code> and 'Details'.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_backend">backend</code></td>
<td>
<p>[<code>character(1)</code>]<br /> Defines the backend interface to Stan,
should be  either <code>"rstan"</code> (the default) or <code>"cmdstanr"</code>. Note that
<code>cmdstanr</code> needs to be installed separately as it is not on CRAN. It also
needs the actual <code>CmdStan</code> software. See https://mc-stan.org/cmdstanr/ for
details.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> All warnings and messages are suppressed
if set to <code>FALSE</code>. Defaults to <code>TRUE</code>. Setting this to <code>FALSE</code> will also
disable checks for perfect collinearity in the model matrix.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_verbose_stan">verbose_stan</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> This is the <code>verbose</code> argument for
<code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_stanc_options">stanc_options</code></td>
<td>
<p>[<code>list()</code>]<br /> This is the <code>stanc_options</code> argument
passed to the compile method of a <code>CmdStanModel</code> object via
<code><a href="cmdstanr.html#topic+cmdstan_model">cmdstanr::cmdstan_model()</a></code> when <code>backend = "cmdstanr"</code>.
Defaults to <code>list("O0")</code>. To enable level one compiler optimizations,
use <code>list("O1")</code>.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_threads_per_chain">threads_per_chain</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> A Positive integer defining the
number of parallel threads to use within each chain. Default is <code>1</code>. See
<code><a href="rstan.html#topic+rstan_options">rstan::rstan_options()</a></code> and <code><a href="cmdstanr.html#topic+model-method-sample">cmdstanr::sample()</a></code> for details.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_grainsize">grainsize</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> A positive integer defining the
suggested size of the partial sums when using within-chain parallelization.
Default is number of time points divided by <code>threads_per_chain</code>.
Setting this to <code>1</code> leads the workload division entirely to the internal
scheduler. The performance of the within-chain parallelization can be
sensitive to the choice of <code>grainsize</code>, see Stan manual on reduce-sum for
details.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_custom_stan_model">custom_stan_model</code></td>
<td>
<p>[<code>character(1)</code>]<br /> An optional character string
that either contains a customized stan model code or a path to a <code>.stan</code>
file that contains the code. Using this will override the generated model
code. For expert users only.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_debug">debug</code></td>
<td>
<p>[<code>list()</code>]<br /> A named list of form <code>name = TRUE</code> indicating
additional objects in the environment of the <code>dynamite</code> function which are
added to the return object. Additionally, values <code>no_compile = TRUE</code> and
<code>no_sampling = TRUE</code> can be used to skip the compilation of the Stan code
and sampling steps respectively. This can be useful for debugging when
combined with <code>model_code = TRUE</code>, which adds the Stan model code to the
return object.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_...">...</code></td>
<td>
<p>For <code>dynamite()</code>, additional arguments to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> or
<code><a href="cmdstanr.html#topic+model-method-sample">cmdstanr::sample()</a></code>, such as <code>chains</code> and <code>cores</code> (<code>chains</code> and
<code>parallel_chains</code> in <code>cmdstanr</code>). For <code>summary()</code>, additional arguments to
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit()</a></code>. For <code>print()</code>, further arguments
to the print method for tibbles (see <a href="tibble.html#topic+formatting">tibble::formatting</a>). Not used for
<code>formula()</code>.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_full_diagnostics">full_diagnostics</code></td>
<td>
<p>By default, the effective sample size (ESS) and Rhat
are computed only for the time- and group-invariant parameters
(<code>full_diagnostics = FALSE</code>). Setting this to <code>TRUE</code> computes ESS and Rhat
values for all model parameters, which can take some time for complex models.</p>
</td></tr>
<tr><td><code id="dynamite_+3A_object">object</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best-case scalability of <code>dynamite</code> in terms of data size should be
approximately linear in terms of number of time points and and number of
groups, but as wall-clock time of the MCMC algorithms provided by Stan can
depend on the discrepancy of the data and the model (and the subsequent
shape of the posterior), this can vary greatly.
</p>


<h3>Value</h3>

<p><code>dynamite</code> returns a <code>dynamitefit</code> object which is a list containing
the following components:
</p>

<ul>
<li> <p><code>stanfit</code><br /> A <code>stanfit</code> object, see <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> for details.
</p>
</li>
<li> <p><code>dformulas</code><br /> A list of <code>dynamiteformula</code> objects for internal use.
</p>
</li>
<li> <p><code>data</code><br /> A processed version of the input <code>data</code>.
</p>
</li>
<li> <p><code>data_name</code><br /> Name of the input data object.
</p>
</li>
<li> <p><code>stan</code><br /> A <code>list</code> containing various elements related to Stan model
construction and sampling.
</p>
</li>
<li> <p><code>group_var</code><br /> Name of the variable defining the groups.
</p>
</li>
<li> <p><code>time_var</code><br /> Name of the variable defining the time index.
</p>
</li>
<li> <p><code>priors</code><br /> Data frame containing the used priors.
</p>
</li>
<li> <p><code>backend</code><br /> Either <code>"rstan"</code> or <code>"cmdstanr"</code> indicating which
package was used in sampling.
</p>
</li>
<li> <p><code>call</code><br /> Original function call as an object of class <code>call</code>.
</p>
</li></ul>

<p><code>formula</code> returns a quoted expression.
</p>
<p><code>print</code> returns <code>x</code> invisibly.
</p>
<p><code>summary</code> returns a <code>data.frame</code>.
</p>


<h3>References</h3>

<p>Santtu Tikka and Jouni Helske (2023). <code>dynamite</code>: An <span class="rlang"><b>R</b></span> Package for Dynamic
Multivariate Panel Models. arXiv preprint,
<a href="https://arxiv.org/abs/2302.01607">https://arxiv.org/abs/2302.01607</a>.
</p>
<p>Jouni Helske and Santtu Tikka (2022). Estimating Causal Effects
from Panel Data with Dynamic Multivariate Panel Models. SocArxiv preprint,
<a href="https://osf.io/preprints/socarxiv/mdwu5/">https://osf.io/preprints/socarxiv/mdwu5/</a>.
</p>


<h3>See Also</h3>

<p>Model fitting
<code><a href="#topic+get_priors">get_priors</a>()</code>,
<code><a href="#topic+update.dynamitefit">update.dynamitefit</a>()</code>
</p>
<p>Model formula construction
<code><a href="#topic+dynamiteformula">dynamiteformula</a>()</code>,
<code><a href="#topic+lags">lags</a>()</code>,
<code><a href="#topic+lfactor">lfactor</a>()</code>,
<code><a href="#topic+random_spec">random_spec</a>()</code>,
<code><a href="#topic+splines">splines</a>()</code>
</p>
<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN

# Please update your rstan and StanHeaders installation before running
# on Windows
if (!identical(.Platform$OS.type, "windows")) {
  fit &lt;- dynamite(
    dformula = obs(y ~ -1 + varying(~x), family = "gaussian") +
      lags(type = "varying") +
      splines(df = 20),
    gaussian_example,
    "time",
    "id",
    chains = 1,
    refresh = 0
  )
}


data.table::setDTthreads(1) # For CRAN
formula(gaussian_example_fit)

data.table::setDTthreads(1) # For CRAN
print(gaussian_example_fit)

data.table::setDTthreads(1) # For CRAN
summary(gaussian_example_fit,
  types = "beta",
  probs = c(0.05, 0.1, 0.9, 0.95)
)

</code></pre>

<hr>
<h2 id='dynamiteformula'>Model formula for <span class="pkg">dynamite</span></h2><span id='topic+dynamiteformula'></span><span id='topic+obs'></span><span id='topic+aux'></span><span id='topic++2B.dynamiteformula'></span><span id='topic+print.dynamiteformula'></span>

<h3>Description</h3>

<p>Defines a new observational or a new auxiliary channel for the model using
standard <span class="rlang"><b>R</b></span> formula syntax. Formulas of individual response variables can be
joined together via <code>+</code>. See 'Details' and the package vignette for more
information. The function <code>obs</code> is a shorthand alias for <code>dynamiteformula</code>,
and <code>aux</code> is a shorthand alias for
<code>dynamiteformula(formula, family = "deterministic")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamiteformula(formula, family)

obs(formula, family)

aux(formula)

## S3 method for class 'dynamiteformula'
e1 + e2

## S3 method for class 'dynamiteformula'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamiteformula_+3A_formula">formula</code></td>
<td>
<p>[<code>formula</code>]<br /> An <span class="rlang"><b>R</b></span> formula describing the model.</p>
</td></tr>
<tr><td><code id="dynamiteformula_+3A_family">family</code></td>
<td>
<p>[<code>character(1)</code>]<br /> The family name. See 'Details' for the
supported families.</p>
</td></tr>
<tr><td><code id="dynamiteformula_+3A_e1">e1</code></td>
<td>
<p>[<code>dynamiteformula</code>]<br /> A model formula specification.</p>
</td></tr>
<tr><td><code id="dynamiteformula_+3A_e2">e2</code></td>
<td>
<p>[<code>dynamiteformula</code>]<br /> A model formula specification.</p>
</td></tr>
<tr><td><code id="dynamiteformula_+3A_x">x</code></td>
<td>
<p>[<code>dynamiteformula</code>]<br /> The model formula.</p>
</td></tr>
<tr><td><code id="dynamiteformula_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the <span class="pkg">dynamite</span> package supports the following
distributions for the observations:
</p>

<ul>
<li><p> Categorical: <code>categorical</code> (with a softmax link using the first category
as reference). See the documentation of the <code>categorical_logit_glm</code> in the
Stan function reference manual (https://mc-stan.org/users/documentation/).
</p>
</li>
<li><p> Multinomial: <code>multinomial</code> (softmax link, first category is reference).
</p>
</li>
<li><p> Gaussian: <code>gaussian</code> (identity link, parameterized using mean and standard
deviation).
</p>
</li>
<li><p> Multivariate Gaussian: <code>mvgaussian</code> (identity link, parameterized using
mean vector, standard deviation vector and the Cholesky decomposition of
the correlation matrix).
</p>
</li>
<li><p> Poisson: <code>poisson</code> (log-link, with an optional known offset variable).
</p>
</li>
<li><p> Negative-binomial: <code>negbin</code> (log-link, using mean and dispersion
parameterization, with an optional known offset variable). See the
documentation on <code>NegBinomial2</code> in the Stan function reference manual.
</p>
</li>
<li><p> Bernoulli: <code>bernoulli</code> (logit-link).
</p>
</li>
<li><p> Binomial: <code>binomial</code> (logit-link).
</p>
</li>
<li><p> Exponential: <code>exponential</code> (log-link).
</p>
</li>
<li><p> Gamma: <code>gamma</code> (log-link, using mean and shape parameterization).
</p>
</li>
<li><p> Beta: <code>beta</code> (logit-link, using mean and precision parameterization).
</p>
</li>
<li><p> Student t: <code>student</code> (identity link, parametrized using degrees of
freedon, location and scale)
</p>
</li></ul>

<p>The models in the <span class="pkg">dynamite</span> package are defined by combining the
channel-specific formulas defined via <span class="rlang"><b>R</b></span> formula syntax.
Each channel is defined via the <code>obs</code> function, and the channels are
combined with <code>+</code>. For example a formula
<code>obs(y ~ lag(x), family = "gaussian") + obs(x ~ z, family = "poisson")</code>
defines a model with two channels;
first we declare that <code>y</code> is a gaussian variable depending on a previous
value of <code>x</code> (<code>lag(x)</code>), and then we add a second channel declaring <code>x</code> as
Poisson distributed depending on some exogenous variable <code>z</code>
(for which we do not define any distribution).
</p>
<p>Number of trials for binomial channels should be defined via a <code>trials</code>
model component, e.g., <code>obs(y ~ x + trials(n), family = "binomial")</code>,
where <code>n</code> is a data variable defining the number of trials. For multinomial
channels, the number of trials is automatically defined to be the sum
of the observations over the categories, but can also be defined using
the <code>trials</code> component, for example for prediction.
</p>
<p>Multivariate channels are defined by providing a single formula for all
components or by providing component-specific formulas separated by a <code>|</code>.
The response variables that correspond to the components should be joined by
<code>c()</code>. For instance, the following would define <code>c(y1, y2)</code> as multivariate
gaussian with <code>x</code> as a predictor for the mean of the first component and
<code>x</code> and <code>z</code> as predictors for the mean of the second component:
<code>obs(c(y1, y2) ~ x | x + z, family = "mvgaussian")</code>. A multinomial channel
should only have a single formula.
</p>
<p>In addition to declaring response variables via <code>obs</code>, we can also use
the function <code>aux</code> to define auxiliary channels which are deterministic
functions of other variables. The values of auxiliary variables are computed
dynamically during prediction, making the use of lagged values and other
transformations possible. The function <code>aux</code> also does not use the
<code>family</code> argument, which is automatically set to <code>deterministic</code> and is a
special channel type of <code>obs</code>. Note that lagged values of deterministic
<code>aux</code> channels do not imply fixed time points. Instead they must be given
starting values using a special function <code>init</code> that directly initializes
the lags to specified values, or by <code>past</code> which computes the initial values
based on an R expression. Both <code>init</code> and <code>past</code> should appear on the
right hand side of the model formula, separated from the primary defining
expression via <code>|</code>.
</p>
<p>The formula within <code>obs</code> can also contain an additional special
function <code>varying</code>, which defines the time-varying part of the model
equation, in which case we could write for example
<code>obs(x ~ z + varying(~ -1 + w), family = "poisson")</code>, which defines a model
equation with a constant intercept and time-invariant effect of <code>z</code>, and a
time-varying effect of <code>w</code>. We also remove the duplicate intercept with <code>-1</code>
in order to avoid identifiability issues in the model estimation
(we could also define a time varying intercept, in which case we would write
<code style="white-space: pre;">&#8288;obs(x ~ -1 + z + varying(~ w), family = "poisson)&#8288;</code>). The part of the formula
not wrapped with <code>varying</code> is assumed to correspond to the fixed part of the
model, so <code>obs(x ~ z + varying(~ -1 + w), family = "poisson")</code> is actually
identical to
<code>obs(x ~ -1 + fixed(~ z) + varying(~ -1 + w), family = "poisson")</code> and
<code>obs(x ~ fixed(~ z) + varying(~ -1 + w), family = "poisson")</code>.
</p>
<p>When defining varying effects, we also need to define how the these
time-varying regression coefficient behave. For this, a <code>splines</code> component
should be added to the model, e.g.,
<code style="white-space: pre;">&#8288;obs(x ~ varying(~ -1 + w), family = "poisson) + splines(df = 10)&#8288;</code> defines a
cubic B-spline with 10 degrees of freedom for the time-varying coefficient
corresponding to the <code>w</code>. If the model contains multiple time-varying
coefficients, same spline basis is used for all coefficients, with unique
spline coefficients and their standard deviation.
</p>
<p>If the desired model contains lagged predictors of each response in each
channel, these can be quickly added to the model as either time-invariant
or time-varying predictors via <code><a href="#topic+lags">lags()</a></code> instead of writing them manually
for each channel.
</p>
<p>It is also possible to define group-specific (random) effects term
using the special syntax <code>random()</code> similarly as <code>varying()</code>. For example,
<code>random(~1)</code> leads to a model where in addition to the common intercept,
each individual/group has their own intercept with zero-mean normal prior and
unknown standard deviation analogously with the typical mixed models. An
additional model component <code><a href="#topic+random_spec">random_spec()</a></code> can be used to define
whether the random effects are allowed to correlate within and across
channels and whether to use centered or noncentered parameterization for
the random effects.
</p>


<h3>Value</h3>

<p>A <code>dynamiteformula</code> object.
</p>


<h3>See Also</h3>

<p>Model formula construction
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+lags">lags</a>()</code>,
<code><a href="#topic+lfactor">lfactor</a>()</code>,
<code><a href="#topic+random_spec">random_spec</a>()</code>,
<code><a href="#topic+splines">splines</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
# A single gaussian response channel with a time-varying effect of 'x',
# and a time-varying effect of the lag of 'y' using B-splines with
# 20 degrees of freedom for the coefficients of the time-varying terms.
obs(y ~ -1 + varying(~x), family = "gaussian") +
  lags(type = "varying") +
  splines(df = 20)

# A two-channel categorical model with time-invariant predictors
# here, lag terms are specified manually
obs(x ~ z + lag(x) + lag(y), family = "categorical") +
  obs(y ~ z + lag(x) + lag(y), family = "categorical")

# The same categorical model as above, but with the lag terms
# added using 'lags'
obs(x ~ z, family = "categorical") +
  obs(y ~ z, family = "categorical") +
  lags(type = "fixed")

# A multichannel model with a gaussian, Poisson and a Bernoulli response and
# an auxiliary channel for the logarithm of 'p' plus one
obs(g ~ lag(g) + lag(logp), family = "gaussian") +
  obs(p ~ lag(g) + lag(logp) + lag(b), family = "poisson") +
  obs(b ~ lag(b) * lag(logp) + lag(b) * lag(g), family = "bernoulli") +
  aux(numeric(logp) ~ log(p + 1))

data.table::setDTthreads(1) # For CRAN
obs(y ~ x, family = "gaussian") + obs(z ~ w, family = "exponential")

data.table::setDTthreads(1) # For CRAN
x &lt;- obs(y ~ x + random(~ 1 + lag(d)), family = "gaussian") +
  obs(z ~ varying(~w), family = "exponential") +
  aux(numeric(d) ~ log(y) | init(c(0, 1))) +
  lags(k = 2) +
  splines(df = 5) +
  random_spec(correlated = FALSE)
print(x)

</code></pre>

<hr>
<h2 id='fitted.dynamitefit'>Extract Fitted Values of a Dynamite Model</h2><span id='topic+fitted.dynamitefit'></span>

<h3>Description</h3>

<p>Fitted values for a <code>dynamitefit</code> object, i.e.,
<code class="reqn">E(y_t | newdata, \theta)</code> where <code class="reqn">\theta</code> contains all the
model parameters. See also
<code><a href="#topic+predict.dynamitefit">predict.dynamitefit()</a></code> for multi-step predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
fitted(object, newdata = NULL, n_draws = NULL, expand = TRUE, df = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.dynamitefit_+3A_object">object</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="fitted.dynamitefit_+3A_newdata">newdata</code></td>
<td>
<p>[<code>data.frame</code>]<br /> Data used in predictions.
If <code>NULL</code> (default), the data used in model estimation is used for
predictions as well.
There should be no new time points that were not present in the data that
were used to fit the model, and no new group levels can be included.</p>
</td></tr>
<tr><td><code id="fitted.dynamitefit_+3A_n_draws">n_draws</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> Number of posterior samples to use,
default is <code>NULL</code> which uses all samples.</p>
</td></tr>
<tr><td><code id="fitted.dynamitefit_+3A_expand">expand</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (the default), the output
is a single <code>data.frame</code> containing the original <code>newdata</code> and the
predicted values. Otherwise, a <code>list</code> is returned with two components,
<code>simulated</code> and <code>observed</code>, where the first contains only the
predicted values, and the second contains the original <code>newdata</code>.
Setting <code>expand</code> to <code>FALSE</code> can help conserve memory because <code>newdata</code>
is not replicated <code>n_draws</code> times in the output.
This argument is ignored if <code>funs</code> are provided.</p>
</td></tr>
<tr><td><code id="fitted.dynamitefit_+3A_df">df</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default) the output
consists of <code>data.frame</code> objects, and <code>data.table</code> objects otherwise.</p>
</td></tr>
<tr><td><code id="fitted.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the fitted values.
</p>


<h3>See Also</h3>

<p>Obtaining predictions
<code><a href="#topic+predict.dynamitefit">predict.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
fitted(gaussian_example_fit, n_draws = 2L)

set.seed(1)
# Please update your rstan and StanHeaders installation before running
# on Windows
if (!identical(.Platform$OS.type, "windows")) {
  fit &lt;- dynamite(
    dformula = obs(LakeHuron ~ 1, "gaussian") + lags(),
    data = data.frame(LakeHuron, time = seq_len(length(LakeHuron)), id = 1),
    time = "time",
    group = "id",
    chains = 1,
    refresh = 0
  )

  if (requireNamespace("dplyr") &amp;&amp;
    requireNamespace("tidyr") &amp;&amp;
    base::getRversion() &gt;= "4.1.0") {

    # One-step ahead samples (fitted values) from the posterior
    # (first time point is fixed due to lag in the model):
    fitted(fit) |&gt;
      dplyr::filter(time &gt; 2) |&gt;
      ggplot2::ggplot(ggplot2::aes(time, LakeHuron_fitted, group = .draw)) +
      ggplot2::geom_line(alpha = 0.5) +
      # observed values
      ggplot2::geom_line(ggplot2::aes(y = LakeHuron), colour = "tomato") +
      ggplot2::theme_bw()

    # Posterior predictive distribution given the first time point:
    predict(fit, type = "mean") |&gt;
      dplyr::filter(time &gt; 2) |&gt;
      ggplot2::ggplot(ggplot2::aes(time, LakeHuron_mean, group = .draw)) +
      ggplot2::geom_line(alpha = 0.5) +
      # observed values
      ggplot2::geom_line(ggplot2::aes(y = LakeHuron), colour = "tomato") +
      ggplot2::theme_bw()
  }
 }


</code></pre>

<hr>
<h2 id='gaussian_example'>Simulated Data of Gaussian Responses</h2><span id='topic+gaussian_example'></span>

<h3>Description</h3>

<p>Simulated data containing gaussian response variables with two covariates.
The dataset was generated from a model with time-varying effects of
covariate x and the lagged value of the response variable, time-varying
intercept, and time-invariant effect of covariate z. The time-varying
coefficients vary according to a spline with 20 degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_example
</code></pre>


<h3>Format</h3>

<p>A data frame with 3000 rows and 5 variables:
</p>

<dl>
<dt>y</dt><dd><p>The response variable.</p>
</dd>
<dt>x</dt><dd><p>A continuous covariate.</p>
</dd>
<dt>z</dt><dd><p>A binary covariate.</p>
</dd>
<dt>id</dt><dd><p>Variable defining individuals (1 to 50).</p>
</dd>
<dt>time</dt><dd><p>Variable defining the time point of the measurement (1 to 30).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was generated according to a script in
<a href="https://github.com/ropensci/dynamite/blob/main/data-raw/gaussian_example.R">https://github.com/ropensci/dynamite/blob/main/data-raw/gaussian_example.R</a>
</p>


<h3>See Also</h3>

<p>Example models
<code><a href="#topic+categorical_example_fit">categorical_example_fit</a></code>,
<code><a href="#topic+categorical_example">categorical_example</a></code>,
<code><a href="#topic+gaussian_example_fit">gaussian_example_fit</a></code>,
<code><a href="#topic+gaussian_simulation_fit">gaussian_simulation_fit</a></code>,
<code><a href="#topic+multichannel_example_fit">multichannel_example_fit</a></code>,
<code><a href="#topic+multichannel_example">multichannel_example</a></code>
</p>

<hr>
<h2 id='gaussian_example_fit'>Model Fit for the Simulated Data of Gaussian Responses</h2><span id='topic+gaussian_example_fit'></span>

<h3>Description</h3>

<p>A <code>dynamitefit</code> object obtained by running <code>dynamite</code> on the
<code>gaussian_example</code> dataset as
</p>
<pre>
set.seed(1)
library(dynamite)
gaussian_example_fit &lt;- dynamite(
  obs(y ~ -1 + z + varying(~ x + lag(y)) + random(~1), family = "gaussian") +
    random_spec() + splines(df = 20),
  data = gaussian_example,
  time = "time",
  group = "id",
  iter = 2000,
  warmup = 1000,
  thin = 10,
  chains = 2,
  cores = 2,
  refresh = 0,
  save_warmup = FALSE,
  pars = c("omega_alpha_1_y", "omega_raw_alpha_y", "nu_raw", "nu", "L",
    "sigma_nu", "a_y"),
  include = FALSE
)
</pre>
<p>Note the very small number of samples due to size restrictions on CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_example_fit
</code></pre>


<h3>Format</h3>

<p>A <code>dynamitefit</code> object.
</p>


<h3>Source</h3>

<p>The data was generated according to a script in
<a href="https://github.com/ropensci/dynamite/blob/main/data-raw/gaussian_example_fit.R">https://github.com/ropensci/dynamite/blob/main/data-raw/gaussian_example_fit.R</a>
</p>


<h3>See Also</h3>

<p>Example models
<code><a href="#topic+categorical_example_fit">categorical_example_fit</a></code>,
<code><a href="#topic+categorical_example">categorical_example</a></code>,
<code><a href="#topic+gaussian_example">gaussian_example</a></code>,
<code><a href="#topic+gaussian_simulation_fit">gaussian_simulation_fit</a></code>,
<code><a href="#topic+multichannel_example_fit">multichannel_example_fit</a></code>,
<code><a href="#topic+multichannel_example">multichannel_example</a></code>
</p>

<hr>
<h2 id='gaussian_simulation_fit'>Model Fit for the time-varying example in the <code>dynamite_simulation</code> Vignette</h2><span id='topic+gaussian_simulation_fit'></span>

<h3>Description</h3>

<p>A <code>dynamitefit</code> object obtained by running <code>dynamite</code> with the
<code>"Fixed_param"</code> algorithm on the specified <code>inits</code> in the example.
</p>
<pre>
set.seed(1)
library(dynamite)
gaussian_simulation_fit &lt;- dynamite(
  dformula = f,
  data = d,
  time = "time",
  group = "id",
  chains = 1,
  iter = 1,
  algorithm = "Fixed_param",
  init = list(init),
)
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_simulation_fit
</code></pre>


<h3>Format</h3>

<p>A <code>dynamitefit</code> object.
</p>


<h3>Source</h3>

<p>The data was generated according to a script in
<a href="https://github.com/ropensci/dynamite/blob/main/data-raw/gaussian_simulation_fit.R">https://github.com/ropensci/dynamite/blob/main/data-raw/gaussian_simulation_fit.R</a>
</p>


<h3>See Also</h3>

<p>Example models
<code><a href="#topic+categorical_example_fit">categorical_example_fit</a></code>,
<code><a href="#topic+categorical_example">categorical_example</a></code>,
<code><a href="#topic+gaussian_example_fit">gaussian_example_fit</a></code>,
<code><a href="#topic+gaussian_example">gaussian_example</a></code>,
<code><a href="#topic+multichannel_example_fit">multichannel_example_fit</a></code>,
<code><a href="#topic+multichannel_example">multichannel_example</a></code>
</p>

<hr>
<h2 id='get_code'>Extract the Stan Code of the Dynamite Model</h2><span id='topic+get_code'></span><span id='topic+get_code.dynamiteformula'></span><span id='topic+get_code.dynamitefit'></span>

<h3>Description</h3>

<p>Returns the Stan code of the model. Mostly useful for debugging or for
building a customized version of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_code(x, ...)

## S3 method for class 'dynamiteformula'
get_code(x, data, time, group = NULL, blocks = NULL, ...)

## S3 method for class 'dynamitefit'
get_code(x, blocks = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_code_+3A_x">x</code></td>
<td>
<p>[<code>dynamiteformula</code> or <code>dynamitefit</code>]<br /> The model formula or an
existing <code>dynamitefit</code> object. See <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> and <code><a href="#topic+dynamite">dynamite()</a></code>.</p>
</td></tr>
<tr><td><code id="get_code_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="get_code_+3A_data">data</code></td>
<td>
<p>[<code>data.frame</code>, <code>tibble::tibble</code>, or <code>data.table::data.table</code>]<br />
The data that contains the variables in the model in long format.
Supported column types are <code>integer</code>, <code>logical</code>, <code>double</code>, and
<code>factor</code>. Columns of type <code>character</code> will be converted to factors.
Unused factor levels will be dropped. The <code>data</code> can contain missing
values which will simply be ignored in the estimation in a case-wise
fashion (per time-point and per channel). Input <code>data</code> is converted to
channel specific matrix representations via <code><a href="stats.html#topic+model.matrix">stats::model.matrix.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_code_+3A_time">time</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
time index of observations. If this variable is a factor, the integer
representation of its levels are used internally for defining the time
indexing.</p>
</td></tr>
<tr><td><code id="get_code_+3A_group">group</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
unique groups or <code>NULL</code> corresponding to a scenario without any groups.
If <code>group</code> is <code>NULL</code>, a new column <code>.group</code> is created with constant
value <code>1L</code> is created indicating that all observations belong to the same
group. In case of name conflicts with <code>data</code>, see the <code>group_var</code> element
of the return object to get the column name of the new variable.</p>
</td></tr>
<tr><td><code id="get_code_+3A_blocks">blocks</code></td>
<td>
<p>[<code>character()</code>]<br /> Stan block names to extract. If <code>NULL</code>,
extracts the full model code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Stan model blocks as a <code>character</code> string.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
d &lt;- data.frame(y = rnorm(10), x = 1:10, time = 1:10, id = 1)
cat(get_code(obs(y ~ x, family = "gaussian"),
  data = d, time = "time", group = "id"
))
# same as
cat(dynamite(obs(y ~ x, family = "gaussian"),
  data = d, time = "time", group = "id",
  debug = list(model_code = TRUE, no_compile = TRUE)
)$model_code)

</code></pre>

<hr>
<h2 id='get_data'>Extract the Model Data of the Dynamite Model</h2><span id='topic+get_data'></span><span id='topic+get_data.dynamiteformula'></span><span id='topic+get_data.dynamitefit'></span>

<h3>Description</h3>

<p>Returns the input data to the Stan model. Mostly useful for debugging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(x, ...)

## S3 method for class 'dynamiteformula'
get_data(x, data, time, group = NULL, ...)

## S3 method for class 'dynamitefit'
get_data(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_x">x</code></td>
<td>
<p>[<code>dynamiteformula</code> or <code>dynamitefit</code>]<br /> The model formula or an
existing <code>dynamitefit</code> object. See <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> and <code><a href="#topic+dynamite">dynamite()</a></code>.</p>
</td></tr>
<tr><td><code id="get_data_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="get_data_+3A_data">data</code></td>
<td>
<p>[<code>data.frame</code>, <code>tibble::tibble</code>, or <code>data.table::data.table</code>]<br />
The data that contains the variables in the model in long format.
Supported column types are <code>integer</code>, <code>logical</code>, <code>double</code>, and
<code>factor</code>. Columns of type <code>character</code> will be converted to factors.
Unused factor levels will be dropped. The <code>data</code> can contain missing
values which will simply be ignored in the estimation in a case-wise
fashion (per time-point and per channel). Input <code>data</code> is converted to
channel specific matrix representations via <code><a href="stats.html#topic+model.matrix">stats::model.matrix.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_data_+3A_time">time</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
time index of observations. If this variable is a factor, the integer
representation of its levels are used internally for defining the time
indexing.</p>
</td></tr>
<tr><td><code id="get_data_+3A_group">group</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
unique groups or <code>NULL</code> corresponding to a scenario without any groups.
If <code>group</code> is <code>NULL</code>, a new column <code>.group</code> is created with constant
value <code>1L</code> is created indicating that all observations belong to the same
group. In case of name conflicts with <code>data</code>, see the <code>group_var</code> element
of the return object to get the column name of the new variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the input data to Stan.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
d &lt;- data.frame(y = rnorm(10), x = 1:10, time = 1:10, id = 1)
str(get_data(obs(y ~ x, family = "gaussian"),
  data = d, time = "time", group = "id"
))

</code></pre>

<hr>
<h2 id='get_parameter_dims'>Get Parameter Dimensions of the Dynamite Model</h2><span id='topic+get_parameter_dims'></span><span id='topic+get_parameter_dims.dynamiteformula'></span><span id='topic+get_parameter_dims.dynamitefit'></span>

<h3>Description</h3>

<p>Extracts the names and dimensions of all parameters used in the
<code>dynamite</code> model. See also <code><a href="#topic+get_parameter_types">get_parameter_types()</a></code> and
<code><a href="#topic+get_parameter_names">get_parameter_names()</a></code>. The returned dimensions match those of
the <code>stanfit</code> element of the <code>dynamitefit</code> object. When applied to
<code>dynamiteformula</code> objects, the model is compiled and sampled for 1 iteration
to get the parameter dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_dims(x, ...)

## S3 method for class 'dynamiteformula'
get_parameter_dims(x, data, time, group = NULL, ...)

## S3 method for class 'dynamitefit'
get_parameter_dims(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameter_dims_+3A_x">x</code></td>
<td>
<p>[<code>dynamiteformula</code> or <code>dynamitefit</code>]<br /> The model formula or an
existing <code>dynamitefit</code> object. See <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> and <code><a href="#topic+dynamite">dynamite()</a></code>.</p>
</td></tr>
<tr><td><code id="get_parameter_dims_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="get_parameter_dims_+3A_data">data</code></td>
<td>
<p>[<code>data.frame</code>, <code>tibble::tibble</code>, or <code>data.table::data.table</code>]<br />
The data that contains the variables in the model in long format.
Supported column types are <code>integer</code>, <code>logical</code>, <code>double</code>, and
<code>factor</code>. Columns of type <code>character</code> will be converted to factors.
Unused factor levels will be dropped. The <code>data</code> can contain missing
values which will simply be ignored in the estimation in a case-wise
fashion (per time-point and per channel). Input <code>data</code> is converted to
channel specific matrix representations via <code><a href="stats.html#topic+model.matrix">stats::model.matrix.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_parameter_dims_+3A_time">time</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
time index of observations. If this variable is a factor, the integer
representation of its levels are used internally for defining the time
indexing.</p>
</td></tr>
<tr><td><code id="get_parameter_dims_+3A_group">group</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
unique groups or <code>NULL</code> corresponding to a scenario without any groups.
If <code>group</code> is <code>NULL</code>, a new column <code>.group</code> is created with constant
value <code>1L</code> is created indicating that all observations belong to the same
group. In case of name conflicts with <code>data</code>, see the <code>group_var</code> element
of the return object to get the column name of the new variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with all parameter dimensions of the input model.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
get_parameter_dims(multichannel_example_fit)

</code></pre>

<hr>
<h2 id='get_parameter_names'>Get Parameter Names of the Dynamite Model</h2><span id='topic+get_parameter_names'></span><span id='topic+get_parameter_names.dynamitefit'></span>

<h3>Description</h3>

<p>Extracts all parameter names of used in the <code>dynamitefit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_names(x, types = NULL, ...)

## S3 method for class 'dynamitefit'
get_parameter_names(x, types = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameter_names_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="get_parameter_names_+3A_types">types</code></td>
<td>
<p>[<code>character()</code>]<br /> Extract only names of parameter of a
certain type. See <code><a href="#topic+get_parameter_types">get_parameter_types()</a></code>.</p>
</td></tr>
<tr><td><code id="get_parameter_names_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The naming of parameters generally follows style where the name starts with
the parameter type (e.g. beta for time-invariant regression coefficient),
followed by underscore and the name of the response variable, and in case of
time-invariant, time-varying or random effect, the name of the predictor. An
exception to this is spline coefficients omega, which also contain the
number denoting the knot number.
</p>


<h3>Value</h3>

<p>A <code>character</code> vector with parameter names of the input model.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
get_parameter_names(multichannel_example_fit)

</code></pre>

<hr>
<h2 id='get_parameter_types'>Get Parameter Types of the Dynamite Model</h2><span id='topic+get_parameter_types'></span><span id='topic+get_parameter_types.dynamitefit'></span>

<h3>Description</h3>

<p>Extracts all parameter types of used in the <code>dynamitefit</code> object. See
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit()</a></code> for explanations of different types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_types(x, ...)

## S3 method for class 'dynamitefit'
get_parameter_types(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameter_types_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="get_parameter_types_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector with all parameter types of the input model.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
get_parameter_types(multichannel_example_fit)

</code></pre>

<hr>
<h2 id='get_priors'>Get Prior Definitions of a Dynamite Model</h2><span id='topic+get_priors'></span><span id='topic+get_priors.dynamiteformula'></span><span id='topic+get_priors.dynamitefit'></span>

<h3>Description</h3>

<p>Extracts the priors used in the dynamite model as a data frame. You
can then alter the priors by changing the contents of the <code>prior</code> column and
supplying this data frame to <code>dynamite</code> function using the argument
<code>priors</code>. See vignettes for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_priors(x, ...)

## S3 method for class 'dynamiteformula'
get_priors(x, data, time, group = NULL, ...)

## S3 method for class 'dynamitefit'
get_priors(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_priors_+3A_x">x</code></td>
<td>
<p>[<code>dynamiteformula</code> or <code>dynamitefit</code>]<br /> The model formula or an
existing <code>dynamitefit</code> object. See <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> and <code><a href="#topic+dynamite">dynamite()</a></code>.</p>
</td></tr>
<tr><td><code id="get_priors_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="get_priors_+3A_data">data</code></td>
<td>
<p>[<code>data.frame</code>, <code>tibble::tibble</code>, or <code>data.table::data.table</code>]<br />
The data that contains the variables in the model in long format.
Supported column types are <code>integer</code>, <code>logical</code>, <code>double</code>, and
<code>factor</code>. Columns of type <code>character</code> will be converted to factors.
Unused factor levels will be dropped. The <code>data</code> can contain missing
values which will simply be ignored in the estimation in a case-wise
fashion (per time-point and per channel). Input <code>data</code> is converted to
channel specific matrix representations via <code><a href="stats.html#topic+model.matrix">stats::model.matrix.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_priors_+3A_time">time</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
time index of observations. If this variable is a factor, the integer
representation of its levels are used internally for defining the time
indexing.</p>
</td></tr>
<tr><td><code id="get_priors_+3A_group">group</code></td>
<td>
<p>[<code>character(1)</code>]<br /> A column name of <code>data</code> that denotes the
unique groups or <code>NULL</code> corresponding to a scenario without any groups.
If <code>group</code> is <code>NULL</code>, a new column <code>.group</code> is created with constant
value <code>1L</code> is created indicating that all observations belong to the same
group. In case of name conflicts with <code>data</code>, see the <code>group_var</code> element
of the return object to get the column name of the new variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the prior definitions.
</p>


<h3>Note</h3>

<p>Only the <code>prior</code> column of the output should be altered when defining
the user-defined priors for the <code>dynamite</code>.
</p>


<h3>See Also</h3>

<p>Model fitting
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+update.dynamitefit">update.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
d &lt;- data.frame(y = rnorm(10), x = 1:10, time = 1:10, id = 1)
get_priors(obs(y ~ x, family = "gaussian"),
  data = d, time = "time", group = "id"
)

</code></pre>

<hr>
<h2 id='lags'>Add Lagged Responses as Predictors to Each Channel of a Dynamite Model</h2><span id='topic+lags'></span>

<h3>Description</h3>

<p>Adds the lagged value of the response of each channel specified via
<code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> as a predictor to each channel. The added predictors
can be either time-varying or time-invariant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lags(k = 1L, type = c("fixed", "varying", "random"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lags_+3A_k">k</code></td>
<td>
<p>[<code>integer()</code>]<br />
Values lagged by <code>k</code> units of time of each observed response variable
will be added as a predictor for each channel. Should be a positive
(unrestricted) integer.</p>
</td></tr>
<tr><td><code id="lags_+3A_type">type</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> Either
<code>"fixed"</code> or <code>"varying"</code> which indicates whether the coefficients of the
added lag terms should vary in time or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lags</code>.
</p>


<h3>See Also</h3>

<p>Model formula construction
<code><a href="#topic+dynamiteformula">dynamiteformula</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+lfactor">lfactor</a>()</code>,
<code><a href="#topic+random_spec">random_spec</a>()</code>,
<code><a href="#topic+splines">splines</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
obs(y ~ -1 + varying(~x), family = "gaussian") +
  lags(type = "varying") + splines(df = 20)

# A two-channel categorical model with time-invariant predictors
# here, lag terms are specified manually
obs(x ~ z + lag(x) + lag(y), family = "categorical") +
  obs(y ~ z + lag(x) + lag(y), family = "categorical")

# The same categorical model as above, but with the lag terms
# added using 'lags'
obs(x ~ z, family = "categorical") +
  obs(y ~ z, family = "categorical") +
  lags(type = "fixed")

</code></pre>

<hr>
<h2 id='lfactor'>Define a Common Latent Factor for the Dynamite Model.</h2><span id='topic+lfactor'></span>

<h3>Description</h3>

<p>This function can be used as part of <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> to define
a common latent factor component. The latent factor is modeled as a spline
similarly as a time-varying intercept, but instead of having equal effect on
each group, there is an additional loading variable for each group so that
in the linear predictor we have a term <code class="reqn">\lambda_i \psi_t</code> for each
group <code class="reqn">i</code>. In order to keep the full factor loadings <code class="reqn">\lambda</code>,
the latent factor <code class="reqn">\psi</code> and the full model identifiable, some
restrictions are added to the model. Details will be available in an
upcoming paper. This component should be treated as experimental feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfactor(
  responses = NULL,
  nonzero_lambda = TRUE,
  correlated = TRUE,
  noncentered_psi = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfactor_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Names of the responses that the
factor should affect. Default is all responses defined with
<code>obs</code> except categorical responses, which do not (yet) support the factor
component.</p>
</td></tr>
<tr><td><code id="lfactor_+3A_nonzero_lambda">nonzero_lambda</code></td>
<td>
<p>[<code>logical()</code>]<br /> If <code>TRUE</code> (the default), assumes
that the mean of factor loadings is nonzero or not. Should be a logical
vector matching the length of <code>responses</code> or a single logical value in
case <code>responses</code> is <code>NULL</code>. See details.</p>
</td></tr>
<tr><td><code id="lfactor_+3A_correlated">correlated</code></td>
<td>
<p>[<code>logical()</code>]<br /> If <code>TRUE</code> (the default), the latent
factors are assumed to be correlated between channels.</p>
</td></tr>
<tr><td><code id="lfactor_+3A_noncentered_psi">noncentered_psi</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code>, uses a
noncentered parametrization for spline coefficients of all the factors.
The number of knots is based <code>splines()</code> call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>latent_factor</code>.
</p>


<h3>See Also</h3>

<p>Model formula construction
<code><a href="#topic+dynamiteformula">dynamiteformula</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+lags">lags</a>()</code>,
<code><a href="#topic+random_spec">random_spec</a>()</code>,
<code><a href="#topic+splines">splines</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
# three channel model with common factor affecting for responses x and y
obs(y ~ 1, family = "gaussian") +
  obs(x ~ 1, family = "poisson") +
  obs(z ~ 1, family = "gaussian") +
  lfactor(
    responses = c("y", "x"), nonzero_lambda = c(TRUE, FALSE),
    correlated = TRUE, noncentered_psi = FALSE
  )

</code></pre>

<hr>
<h2 id='lfo'>Approximate Leave-Future-Out (LFO) Cross-validation</h2><span id='topic+lfo'></span>

<h3>Description</h3>

<p>Estimates the leave-future-out (LFO) information criterion for <code>dynamite</code>
models using Pareto smoothed importance sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfo(x, L, verbose = TRUE, k_threshold = 0.7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfo_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="lfo_+3A_l">L</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> Positive integer defining how many time points
should be used for the initial fit.</p>
</td></tr>
<tr><td><code id="lfo_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default), print the progress of
the LFO computations to the console.</p>
</td></tr>
<tr><td><code id="lfo_+3A_k_threshold">k_threshold</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Threshold for the Pareto k estimate
triggering refit. Default is 0.7.</p>
</td></tr>
<tr><td><code id="lfo_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> or
<code><a href="cmdstanr.html#topic+model-method-sample">cmdstanr::sample()</a></code>, such as <code>chains</code> and <code>cores</code> (<code>parallel_chains</code> in
<code>cmdstanr</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For multichannel models, the log-likelihoods of all channels are combined.
For models with groups, expected log predictive densities (ELPDs) are
computed independently for each group, but the re-estimation of the model
is triggered if pareto k values of any group exceeds the threshold.
</p>


<h3>Value</h3>

<p>An <code>lfo</code> object which is a <code>list</code> with the following components:
</p>

<ul>
<li> <p><code>ELPD</code><br /> Expected log predictive density estimate.
</p>
</li>
<li> <p><code>ELPD_SE</code><br /> Standard error of ELPD. This is a crude approximation which
does not take into account potential serial correlations.
</p>
</li>
<li> <p><code>pareto_k</code><br /> Pareto k values.
</p>
</li>
<li> <p><code>refits</code><br /> Time points where model was re-estimated.
</p>
</li>
<li> <p><code>L</code><br /> L value used in the LFO estimation.
</p>
</li>
<li> <p><code>k_threshold</code><br /> Threshold used in the LFO estimation.
</p>
</li></ul>



<h3>References</h3>

<p>Paul-Christian BÃ¼rkner, Jonah Gabry, and Aki Vehtari (2020).
Approximate leave-future-out cross-validation for Bayesian time series
models, Journal of Statistical Computation and Simulation, 90:14, 2499-2523.
</p>


<h3>See Also</h3>

<p>Model diagnostics
<code><a href="#topic+loo.dynamitefit">loo.dynamitefit</a>()</code>,
<code><a href="#topic+mcmc_diagnostics">mcmc_diagnostics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN

# Please update your rstan and StanHeaders installation before running
# on Windows
if (!identical(.Platform$OS.type, "windows")) {
  # this gives warnings due to the small number of iterations
  out &lt;- suppressWarnings(
    lfo(gaussian_example_fit, L = 20, chains = 1, cores = 1)
  )
  out$ELPD
  out$ELPD_SE
}


</code></pre>

<hr>
<h2 id='loo.dynamitefit'>Approximate Leave-One-Out (LOO) Cross-validation</h2><span id='topic+loo.dynamitefit'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p>Estimates the leave-one-out (LOO) information criterion for <code>dynamite</code>
models using Pareto smoothed importance sampling with the <code>loo</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
loo(x, separate_channels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.dynamitefit_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="loo.dynamitefit_+3A_separate_channels">separate_channels</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code>, computes LOO
separately for each channel. This can be useful in diagnosing where the
model fails. Default is <code>FALSE</code>, in which case the likelihoods of
different channels are combined, i.e., all channels of are left out.</p>
</td></tr>
<tr><td><code id="loo.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output from <code><a href="loo.html#topic+loo">loo::loo()</a></code> or a list of such outputs (if
<code>separate_channels</code> was <code>TRUE</code>).
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew, Gelman, and Johah Gabry (2017).
Practical Bayesian model evaluation using leave-one-out cross-validation and
WAIC. Statistics and Computing. 27(5), 1413â€“1432.
</p>


<h3>See Also</h3>

<p>Model diagnostics
<code><a href="#topic+lfo">lfo</a>()</code>,
<code><a href="#topic+mcmc_diagnostics">mcmc_diagnostics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN

# Please update your rstan and StanHeaders installation before running
# on Windows
if (!identical(.Platform$OS.type, "windows")) {
  # this gives warnings due to the small number of iterations
  suppressWarnings(loo(gaussian_example_fit))
  suppressWarnings(loo(gaussian_example_fit, separate_channels = TRUE))
}


</code></pre>

<hr>
<h2 id='mcmc_diagnostics'>Diagnostic Values of a Dynamite Model</h2><span id='topic+mcmc_diagnostics'></span><span id='topic+mcmc_diagnostics.dynamitefit'></span>

<h3>Description</h3>

<p>Prints HMC diagnostics, and lists parameters with smallest effective sample
sizes and largest Rhat values. See <code><a href="rstan.html#topic+check_hmc_diagnostics">rstan::check_hmc_diagnostics()</a></code> and
<code><a href="posterior.html#topic+draws_summary">posterior::default_convergence_measures()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_diagnostics(x, n)

## S3 method for class 'dynamitefit'
mcmc_diagnostics(x, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_diagnostics_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="mcmc_diagnostics_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> How many rows to print in
parameter-specific convergence measures. The default is 3. Should be a
positive (unrestricted) integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> (invisibly).
</p>


<h3>See Also</h3>

<p>Model diagnostics
<code><a href="#topic+lfo">lfo</a>()</code>,
<code><a href="#topic+loo.dynamitefit">loo.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
mcmc_diagnostics(gaussian_example_fit)

</code></pre>

<hr>
<h2 id='multichannel_example'>Simulated Multivariate Panel Data</h2><span id='topic+multichannel_example'></span>

<h3>Description</h3>

<p>A simulated multichannel data containing multiple individuals with multiple
response variables of different distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multichannel_example
</code></pre>


<h3>Format</h3>

<p>A data frame with 3000 rows and 5 variables:
</p>

<dl>
<dt>id</dt><dd><p>Variable defining individuals (1 to 50).</p>
</dd>
<dt>time</dt><dd><p>Variable defining the time point of the measurement (1 to 20).</p>
</dd>
<dt>g</dt><dd><p>Response variable following gaussian distribution.</p>
</dd>
<dt>p</dt><dd><p>Response variable following Poisson distribution.</p>
</dd>
<dt>b</dt><dd><p>Response variable following Bernoulli distribution.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was generated according to a script in
<a href="https://github.com/ropensci/dynamite/blob/main/data-raw/multichannel_example.R">https://github.com/ropensci/dynamite/blob/main/data-raw/multichannel_example.R</a>
</p>


<h3>See Also</h3>

<p>Example models
<code><a href="#topic+categorical_example_fit">categorical_example_fit</a></code>,
<code><a href="#topic+categorical_example">categorical_example</a></code>,
<code><a href="#topic+gaussian_example_fit">gaussian_example_fit</a></code>,
<code><a href="#topic+gaussian_example">gaussian_example</a></code>,
<code><a href="#topic+gaussian_simulation_fit">gaussian_simulation_fit</a></code>,
<code><a href="#topic+multichannel_example_fit">multichannel_example_fit</a></code>
</p>

<hr>
<h2 id='multichannel_example_fit'>Model Fit for the Simulated Multivariate Panel Data</h2><span id='topic+multichannel_example_fit'></span>

<h3>Description</h3>

<p>A <code>dynamitefit</code> object obtained by running <code>dynamite</code> on the
<code>multichannel_example</code> dataset as
</p>
<pre>
set.seed(1)
library(dynamite)
f &lt;- obs(g ~ lag(g) + lag(logp), family = "gaussian") +
  obs(p ~ lag(g) + lag(logp) + lag(b), family = "poisson") +
  obs(b ~ lag(b) * lag(logp) + lag(b) * lag(g), family = "bernoulli") +
  aux(numeric(logp) ~ log(p + 1))
multichannel_example_fit &lt;- dynamite(
  f,
  data = multichannel_example,
  time = "time",
  group = "id",
  chains = 1,
  cores = 1,
  iter = 2000,
  warmup = 1000,
  init = 0,
  refresh = 0,
  thin = 5,
  save_warmup = FALSE
)
</pre>
<p>Note the small number of samples due to size restrictions on CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multichannel_example_fit
</code></pre>


<h3>Format</h3>

<p>A <code>dynamitefit</code> object.
</p>


<h3>Source</h3>

<p>Script in
<a href="https://github.com/ropensci/dynamite/blob/main/data-raw/multichannel_example_fit.R">https://github.com/ropensci/dynamite/blob/main/data-raw/multichannel_example_fit.R</a>
</p>


<h3>See Also</h3>

<p>Example models
<code><a href="#topic+categorical_example_fit">categorical_example_fit</a></code>,
<code><a href="#topic+categorical_example">categorical_example</a></code>,
<code><a href="#topic+gaussian_example_fit">gaussian_example_fit</a></code>,
<code><a href="#topic+gaussian_example">gaussian_example</a></code>,
<code><a href="#topic+gaussian_simulation_fit">gaussian_simulation_fit</a></code>,
<code><a href="#topic+multichannel_example">multichannel_example</a></code>
</p>

<hr>
<h2 id='ndraws.dynamitefit'>Return the Number of Posterior Draws of a <code>dynamitefit</code> Object</h2><span id='topic+ndraws.dynamitefit'></span><span id='topic+ndraws'></span>

<h3>Description</h3>

<p>Return the Number of Posterior Draws of a <code>dynamitefit</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
ndraws(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndraws.dynamitefit_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of posterior draws as a single <code>integer</code> value.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+nobs.dynamitefit">nobs.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
ndraws(gaussian_example_fit)

</code></pre>

<hr>
<h2 id='nobs.dynamitefit'>Extract the Number of Observations Used to Fit a Dynamite Model</h2><span id='topic+nobs.dynamitefit'></span>

<h3>Description</h3>

<p>Extract the Number of Observations Used to Fit a Dynamite Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.dynamitefit_+3A_object">object</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="nobs.dynamitefit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Total number of non-missing observations as an <code>integer</code>.
</p>


<h3>See Also</h3>

<p>Model outputs
<code><a href="#topic+as.data.frame.dynamitefit">as.data.frame.dynamitefit</a>()</code>,
<code><a href="#topic+as.data.table.dynamitefit">as.data.table.dynamitefit</a>()</code>,
<code><a href="#topic+as_draws_df.dynamitefit">as_draws_df.dynamitefit</a>()</code>,
<code><a href="#topic+coef.dynamitefit">coef.dynamitefit</a>()</code>,
<code><a href="#topic+confint.dynamitefit">confint.dynamitefit</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_code">get_code</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+get_parameter_dims">get_parameter_dims</a>()</code>,
<code><a href="#topic+get_parameter_names">get_parameter_names</a>()</code>,
<code><a href="#topic+get_parameter_types">get_parameter_types</a>()</code>,
<code><a href="#topic+ndraws.dynamitefit">ndraws.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
nobs(gaussian_example_fit)

</code></pre>

<hr>
<h2 id='plot_betas'>Plot Time-invariant Regression Coefficients of a Dynamite Model</h2><span id='topic+plot_betas'></span>

<h3>Description</h3>

<p>Plot Time-invariant Regression Coefficients of a Dynamite Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_betas(
  x,
  parameters = NULL,
  responses = NULL,
  level = 0.05,
  include_alpha = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_betas_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object</p>
</td></tr>
<tr><td><code id="plot_betas_+3A_parameters">parameters</code></td>
<td>
<p>[<code>charecter()</code>]\ Parameter name(s) for which the plots
should be drawn. Possible options can be found with function
<code>get_parameter_names(types = "beta")</code>.</p>
</td></tr>
<tr><td><code id="plot_betas_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the coefficients
should be drawn. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this whole vector.</p>
</td></tr>
<tr><td><code id="plot_betas_+3A_level">level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Level for posterior intervals.
Default is 0.05, leading to 90% intervals.</p>
</td></tr>
<tr><td><code id="plot_betas_+3A_include_alpha">include_alpha</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default), plots also
the time-invariant alphas if such parameters exists in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Drawing plots
<code><a href="#topic+plot.dynamitefit">plot.dynamitefit</a>()</code>,
<code><a href="#topic+plot_deltas">plot_deltas</a>()</code>,
<code><a href="#topic+plot_lambdas">plot_lambdas</a>()</code>,
<code><a href="#topic+plot_nus">plot_nus</a>()</code>,
<code><a href="#topic+plot_psis">plot_psis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
plot_betas(gaussian_example_fit, level = 0.1)

</code></pre>

<hr>
<h2 id='plot_deltas'>Plot Time-varying Regression Coefficients of a Dynamite Model</h2><span id='topic+plot_deltas'></span>

<h3>Description</h3>

<p>Plot Time-varying Regression Coefficients of a Dynamite Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_deltas(
  x,
  parameters = NULL,
  responses = NULL,
  level = 0.05,
  alpha = 0.5,
  scales = c("fixed", "free"),
  include_alpha = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_deltas_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object</p>
</td></tr>
<tr><td><code id="plot_deltas_+3A_parameters">parameters</code></td>
<td>
<p>[<code>charecter()</code>]\ Parameter name(s) for which the plots
should be drawn. Possible options can be found with function
<code>get_parameter_names(types = "delta")</code>.</p>
</td></tr>
<tr><td><code id="plot_deltas_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the coefficients
should be drawn. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this whole vector.</p>
</td></tr>
<tr><td><code id="plot_deltas_+3A_level">level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Level for posterior intervals.
Default is 0.05, leading to 90% intervals.</p>
</td></tr>
<tr><td><code id="plot_deltas_+3A_alpha">alpha</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Opacity level for <code>geom_ribbon</code>.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="plot_deltas_+3A_scales">scales</code></td>
<td>
<p>[<code>character(1)</code>] Should y-axis of the panels be <code>"fixed"</code>
(the default) or <code>"free"</code>? See <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_deltas_+3A_include_alpha">include_alpha</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default), plots also
the time-varying alphas if such parameters exists in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Drawing plots
<code><a href="#topic+plot.dynamitefit">plot.dynamitefit</a>()</code>,
<code><a href="#topic+plot_betas">plot_betas</a>()</code>,
<code><a href="#topic+plot_lambdas">plot_lambdas</a>()</code>,
<code><a href="#topic+plot_nus">plot_nus</a>()</code>,
<code><a href="#topic+plot_psis">plot_psis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
plot_deltas(gaussian_example_fit, level = 0.025, scales = "free") +
  ggplot2::theme_minimal()

</code></pre>

<hr>
<h2 id='plot_lambdas'>Plot Factor Loadings of a Dynamite Model</h2><span id='topic+plot_lambdas'></span>

<h3>Description</h3>

<p>Plot Factor Loadings of a Dynamite Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lambdas(x, responses = NULL, level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lambdas_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object</p>
</td></tr>
<tr><td><code id="plot_lambdas_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the coefficients
should be drawn. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this whole vector.</p>
</td></tr>
<tr><td><code id="plot_lambdas_+3A_level">level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Level for posterior intervals.
Default is 0.05, leading to 90% intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Drawing plots
<code><a href="#topic+plot.dynamitefit">plot.dynamitefit</a>()</code>,
<code><a href="#topic+plot_betas">plot_betas</a>()</code>,
<code><a href="#topic+plot_deltas">plot_deltas</a>()</code>,
<code><a href="#topic+plot_nus">plot_nus</a>()</code>,
<code><a href="#topic+plot_psis">plot_psis</a>()</code>
</p>

<hr>
<h2 id='plot_nus'>Plot Random effects of a Dynamite Model</h2><span id='topic+plot_nus'></span>

<h3>Description</h3>

<p>Note that as this function tries to draw a plot containing effects of all
groups, the plot will become messy with large number of groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_nus(x, parameters = NULL, responses = NULL, level = 0.05, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_nus_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object</p>
</td></tr>
<tr><td><code id="plot_nus_+3A_parameters">parameters</code></td>
<td>
<p>[<code>charecter()</code>]\ Parameter name(s) for which the plots
should be drawn. Possible options can be found with function
<code>get_parameter_names(types = "delta")</code>.</p>
</td></tr>
<tr><td><code id="plot_nus_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the coefficients
should be drawn. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this whole vector.</p>
</td></tr>
<tr><td><code id="plot_nus_+3A_level">level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Level for posterior intervals.
Default is 0.05, leading to 90% intervals.</p>
</td></tr>
<tr><td><code id="plot_nus_+3A_groups">groups</code></td>
<td>
<p>Group name(s) for which the plots should be drawn.
Default is all groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Drawing plots
<code><a href="#topic+plot.dynamitefit">plot.dynamitefit</a>()</code>,
<code><a href="#topic+plot_betas">plot_betas</a>()</code>,
<code><a href="#topic+plot_deltas">plot_deltas</a>()</code>,
<code><a href="#topic+plot_lambdas">plot_lambdas</a>()</code>,
<code><a href="#topic+plot_psis">plot_psis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
plot_nus(gaussian_example_fit)

</code></pre>

<hr>
<h2 id='plot_psis'>Plot Latent Factors of a Dynamite Model</h2><span id='topic+plot_psis'></span>

<h3>Description</h3>

<p>Plot Latent Factors of a Dynamite Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_psis(
  x,
  responses = NULL,
  level = 0.05,
  alpha = 0.5,
  scales = c("fixed", "free")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_psis_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object</p>
</td></tr>
<tr><td><code id="plot_psis_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the coefficients
should be drawn. Possible options are elements of
<code>unique(x$priors$response)</code>, and the default is this whole vector.</p>
</td></tr>
<tr><td><code id="plot_psis_+3A_level">level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Level for posterior intervals.
Default is 0.05, leading to 90% intervals.</p>
</td></tr>
<tr><td><code id="plot_psis_+3A_alpha">alpha</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> Opacity level for <code>geom_ribbon</code>.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="plot_psis_+3A_scales">scales</code></td>
<td>
<p>[<code>character(1)</code>] Should y-axis of the panels be <code>"fixed"</code>
(the default) or <code>"free"</code>? See <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Drawing plots
<code><a href="#topic+plot.dynamitefit">plot.dynamitefit</a>()</code>,
<code><a href="#topic+plot_betas">plot_betas</a>()</code>,
<code><a href="#topic+plot_deltas">plot_deltas</a>()</code>,
<code><a href="#topic+plot_lambdas">plot_lambdas</a>()</code>,
<code><a href="#topic+plot_nus">plot_nus</a>()</code>
</p>

<hr>
<h2 id='plot.dynamitefit'>Traceplots and Density Plots for a <code>dynamitefit</code> Object</h2><span id='topic+plot.dynamitefit'></span>

<h3>Description</h3>

<p>Produces the traceplots and the density plots of the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
plot(x, parameters = NULL, type = NULL, responses = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dynamitefit_+3A_x">x</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="plot.dynamitefit_+3A_parameters">parameters</code></td>
<td>
<p>[<code>charecter()</code>]\ Parameter name(s) for which the plots
should be drawn. Possible options can be found with the function
<code><a href="#topic+get_parameter_names">get_parameter_names()</a></code>. The default is all parameters ofa
specific type for all responses, which can lead to too crowded a plot.</p>
</td></tr>
<tr><td><code id="plot.dynamitefit_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br /> Type of the parameter for which the plots
should be drawn. Possible options can be found with the function
<code><a href="#topic+get_parameter_types">get_parameter_types()</a></code>. Ignored if the argument <code>parameters</code>
is supplied.</p>
</td></tr>
<tr><td><code id="plot.dynamitefit_+3A_responses">responses</code></td>
<td>
<p>[<code>character()</code>]<br /> Response(s) for which the plots should
be drawn. Possible options are <code>unique(x$priors$response)</code>. Default is
all responses. Ignored if the argument <code>parameters</code> is supplied.</p>
</td></tr>
<tr><td><code id="plot.dynamitefit_+3A_...">...</code></td>
<td>
<p>Not used..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Drawing plots
<code><a href="#topic+plot_betas">plot_betas</a>()</code>,
<code><a href="#topic+plot_deltas">plot_deltas</a>()</code>,
<code><a href="#topic+plot_lambdas">plot_lambdas</a>()</code>,
<code><a href="#topic+plot_nus">plot_nus</a>()</code>,
<code><a href="#topic+plot_psis">plot_psis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
plot(gaussian_example_fit, type = "beta")

</code></pre>

<hr>
<h2 id='plot.lfo'>Diagnostic Plot for Pareto k Values from LFO</h2><span id='topic+plot.lfo'></span>

<h3>Description</h3>

<p>Plots Pareto k values per each time point (with one point per group),
together with a horizontal line representing the used threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfo'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lfo_+3A_x">x</code></td>
<td>
<p>[<code>lfo</code>]<br /> Output from the <code>lfo</code> function.</p>
</td></tr>
<tr><td><code id="plot.lfo_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN

# Please update your rstan and StanHeaders installation before running
# on Windows
if (!identical(.Platform$OS.type, "windows")) {
  # This gives warnings due to the small number of iterations
  plot(suppressWarnings(
    lfo(gaussian_example_fit, L = 20, chains = 1, cores = 1)
  ))
}


</code></pre>

<hr>
<h2 id='predict.dynamitefit'>Predict Method for a Dynamite Model</h2><span id='topic+predict.dynamitefit'></span>

<h3>Description</h3>

<p>Obtain counterfactual predictions for a <code>dynamitefit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
predict(
  object,
  newdata = NULL,
  type = c("response", "mean", "link"),
  funs = list(),
  impute = c("none", "locf", "nocb"),
  new_levels = c("none", "bootstrap", "gaussian", "original"),
  global_fixed = FALSE,
  n_draws = NULL,
  expand = TRUE,
  df = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dynamitefit_+3A_object">object</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_newdata">newdata</code></td>
<td>
<p>[<code>data.frame</code>]<br /> Data used in predictions. Predictions are
computed for missing (<code>NA</code>) values in the response variable columns, and
non-missing values are assumed fixed.
If <code>NULL</code> (default), the data used in model estimation is used for
predictions as well, after all values in the response variable columns
after the first <code>fixed</code> time point are converted to <code>NA</code> values.
Missing values in predictor columns can be imputed (argument <code>impute</code>).
There should be no new time points that were not present in the data that
were used to fit the model. New group levels can be included, but if the
model contains random effects, an option for the random
effects for the new levels must be chosen (argument <code>new_levels</code>).
If the grouping variable of the original data is missing, it is assumed
that all observations in <code>newdata</code> belong to the first group in the
original data. New group levels are not allowed for models using latent
factors.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br /> Type of prediction,
<code>"response"</code> (default), <code>"mean"</code>, or <code>"link"</code>.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_funs">funs</code></td>
<td>
<p>[<code>list()</code>]<br /> A named list whose names should correspond to the
response variables of the model. Each element of <code>funs</code> should be a
a named <code>list</code> of functions that will be applied to the
corresponding predicted <code>type</code> of the channel over the individuals
for each combination of the posterior draws and time points.
In other words, the resulting predictions will be averages
over the individuals. The functions should take the corresponding
<code>type</code> variable values as their only argument.
If <code>funs</code> is empty, the full individual level values are returned
instead. Note that this argument can only be used
if there are multiple individuals (i.e., <code>group</code> was not <code>NULL</code> in the
<code>dynamite</code> call).</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_impute">impute</code></td>
<td>
<p>[<code>character(1)</code>]<br /> Which imputation scheme to use for
missing exogenous predictor values. Currently supported options are
no imputation: <code>"none"</code> (default), last observation carried forward:
<code>"locf"</code>, and next observation carried backward: <code>"nocb"</code>.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_new_levels">new_levels</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Defines if and how to sample the random effects for observations whose
group level was not present in the original data. The options are:
</p>

<ul>
<li> <p><code>"none"</code> (the default) which will signal an error if new levels
are encountered.
</p>
</li>
<li> <p><code>"bootstrap"</code> which will randomly draw from the posterior samples of
the random effects across all original levels.
</p>
</li>
<li> <p><code>"gaussian"</code> which will randomly draw from a gaussian
distribution using the posterior samples of the random effects
standard deviation (and correlation matrix if applicable).
</p>
</li>
<li> <p><code>"original"</code> which will randomly match each new level to one of
the original levels. The posterior samples of the random effects of
the matched levels will then be used for the new levels.
</p>
</li></ul>

<p>This argument is ignored if the model does not contain random effects.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_global_fixed">global_fixed</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>FALSE</code> (the default),
the first non-fixed time point is counted from the the first non-NA
observation for each group member separately. Otherwise, the first
non-fixed time point is counted from the first time point globally.
If there are no groups, then the options are equivalent.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_n_draws">n_draws</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> Number of posterior samples to use,
default is <code>NULL</code> which uses all samples.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_expand">expand</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (the default), the output
is a single <code>data.frame</code> containing the original <code>newdata</code> and the
predicted values. Otherwise, a <code>list</code> is returned with two components,
<code>simulated</code> and <code>observed</code>, where the first contains only the
predicted values, and the second contains the original <code>newdata</code>.
Setting <code>expand</code> to <code>FALSE</code> can help conserve memory because <code>newdata</code>
is not replicated <code>n_draws</code> times in the output.
This argument is ignored if <code>funs</code> are provided.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_df">df</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (default) the output
consists of <code>data.frame</code> objects, and <code>data.table</code> objects otherwise.</p>
</td></tr>
<tr><td><code id="predict.dynamitefit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that forecasting (i.e., predictions for time indices beyond the last
time index in the original data) is not supported by the <span class="pkg">dynamite</span>
package. However, such predictions can be obtained by augmenting the
original data with <code>NA</code> values before model estimation.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the predicted values or a <code>list</code> of two
<code>data.frames</code>. See the <code>expand</code> argument for details. Note that the
<code>.draw</code> column is not the same as <code>.draw</code> from <code>as.data.frame</code> and
<code>as_draws</code> methods as <code>predict</code> uses permuted samples. A mapping between
these variables can be done using information in
<code>object$stanfit@sim$permutation</code>.
</p>


<h3>See Also</h3>

<p>Obtaining predictions
<code><a href="#topic+fitted.dynamitefit">fitted.dynamitefit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
out &lt;- predict(gaussian_example_fit, type = "response", n_draws = 2L)
head(out)

# using summary functions
sumr &lt;- predict(multichannel_example_fit, type = "mean",
  funs = list(g = list(m = mean, s = sd), b = list(sum = sum)),
  n_draws = 2L)
head(sumr$simulated)

# Please update your rstan and StanHeaders installation before running
# on Windows
if (!identical(.Platform$OS.type, "windows")) {
  # Simulate from the prior predictive distribution

  f &lt;- obs(y ~ lag(y) + varying(~ -1 + x), "gaussian") +
    splines(df = 10, noncentered = TRUE)

  # Create data with missing observations
  # Note that due to the lagged term in the model,
  # we need to fix the first time point
  d &lt;- data.frame(y = c(0, rep(NA, 49)), x = rnorm(50), time = 1:50)

  # Suppress warnings due to the lack of data
  suppressWarnings(
    priors &lt;- get_priors(f, data = d, time = "time")
  )

  # Modify default priors which can produce exploding behavior when used
  # without data
  priors$prior &lt;- c(
    "normal(0, 1)",
    "normal(0.6, 0.1)",
    "normal(-0.2, 0.5)",
    "normal(0.2, 0.1)",
    "normal(0.5, 0.1)"
  )

  # Samples from the prior conditional on the first time point and x
  fit &lt;- dynamite(
    dformula = f,
    data = d,
    time = "time",
    verbose = FALSE,
    priors = priors,
    chains = 1
  )

  # Simulate new data
  pp &lt;- predict(fit)

  ggplot2::ggplot(pp, ggplot2::aes(time, y_new, group = .draw)) +
    ggplot2::geom_line(alpha = 0.1) +
    ggplot2::theme_bw()
}


</code></pre>

<hr>
<h2 id='print.lfo'>Print the results from the LFO</h2><span id='topic+print.lfo'></span>

<h3>Description</h3>

<p>Prints the summary of the leave-future-out cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfo'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lfo_+3A_x">x</code></td>
<td>
<p>x [<code>lfo</code>]<br /> Output of the <code>lfo</code> method.</p>
</td></tr>
<tr><td><code id="print.lfo_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN

# Please update your rstan and StanHeaders installation before running
# on Windows
if (!identical(.Platform$OS.type, "windows")) {
  # This gives warnings due to the small number of iterations
  suppressWarnings(lfo(gaussian_example_fit, L = 20))
}


</code></pre>

<hr>
<h2 id='random_spec'>Additional Specifications for the Group-level Random Effects of the DMPM</h2><span id='topic+random_spec'></span>

<h3>Description</h3>

<p>This function can be used as part of <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> to define
whether the group-level random effects should be modeled as correlated or
not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_spec(correlated = TRUE, noncentered = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_spec_+3A_correlated">correlated</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (the default), correlations
of random effects are modeled as multivariate normal.</p>
</td></tr>
<tr><td><code id="random_spec_+3A_noncentered">noncentered</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>TRUE</code> (the default), use a
noncentered parameterization for random effects. Try changing this if
you encounter divergences or other problems in sampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a large number of time points random intercepts can become challenging
sample with default priors. This is because with large group sizes the
group-level intercepts tend to be behave similarly to fixed group-factor
variable so the model becomes overparameterized given these and the common
intercept term. Another potential cause for sampling problems is relatively
large variation in the intercepts (large sigma_nu) compared to the sampling
variation (sigma) in the Gaussian case.
</p>


<h3>Value</h3>

<p>An object of class <code>random_spec</code>.
</p>


<h3>See Also</h3>

<p>Model formula construction
<code><a href="#topic+dynamiteformula">dynamiteformula</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+lags">lags</a>()</code>,
<code><a href="#topic+lfactor">lfactor</a>()</code>,
<code><a href="#topic+splines">splines</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
# two channel model with correlated random effects for responses x and y
obs(y ~ 1 + random(~1), family = "gaussian") +
  obs(x ~ 1 + random(~1 + z), family = "poisson") +
  random_spec(correlated = TRUE)

</code></pre>

<hr>
<h2 id='splines'>Define the B-splines Used for the Time-varying Coefficients of the Model.</h2><span id='topic+splines'></span>

<h3>Description</h3>

<p>This function can be used as part of <code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> to define the
splines used for the time-varying coefficients <code class="reqn">\delta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splines(
  df = NULL,
  degree = 3L,
  lb_tau = 0,
  noncentered = FALSE,
  override = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splines_+3A_df">df</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> Degrees of freedom, i.e., the total number of
spline coefficients. See <code><a href="splines.html#topic+bs">splines::bs()</a></code>. Note that the knots are always
defined as an equidistant sequence on the interval starting from the first
non-fixed time point to the last time point in the data. See
<code><a href="#topic+dynamiteformula">dynamiteformula()</a></code> for more information on fixed time points.
Should be an (unrestricted) positive integer.</p>
</td></tr>
<tr><td><code id="splines_+3A_degree">degree</code></td>
<td>
<p>[<code>integer(1)</code>]<br /> See <code><a href="splines.html#topic+bs">splines::bs()</a></code>. Should be an
(unrestricted) positive integer.</p>
</td></tr>
<tr><td><code id="splines_+3A_lb_tau">lb_tau</code></td>
<td>
<p>[<code>numeric()</code>]<br /> Hard constraint(s) on the lower bound of the
standard deviation parameters <code class="reqn">\tau</code> of the random walk priors. Can be
useful in avoiding divergences in some cases. See also the <code>noncentered</code>
argument. Can be a single positive value, or vector defining the
lower bound separately for each channel, even for channels without
varying effects. The ordering is based on the order of channel definitions
in the <code>dynamiteformula</code> object.</p>
</td></tr>
<tr><td><code id="splines_+3A_noncentered">noncentered</code></td>
<td>
<p>[<code>logical()</code>]<br /> If <code>TRUE</code>, use a noncentered
parameterization for the spline coefficients. Default is <code>FALSE</code>. Try
changing this if you encounter divergences or other problems in sampling
for example when simulating from prior predictive distribution.
Can be a single logical value, or vector of logical values, defining the
parameterization separately for each channel, even for channels without
varying effects.</p>
</td></tr>
<tr><td><code id="splines_+3A_override">override</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> If <code>FALSE</code> (the default), an existing
definition for the splines will not be overridden by another call to
<code>splines()</code>. If <code>TRUE</code>, any existing definitions will be replaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>splines</code>.
</p>


<h3>See Also</h3>

<p>Model formula construction
<code><a href="#topic+dynamiteformula">dynamiteformula</a>()</code>,
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+lags">lags</a>()</code>,
<code><a href="#topic+lfactor">lfactor</a>()</code>,
<code><a href="#topic+random_spec">random_spec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
# Two channel model with varying effects, with explicit lower bounds for the
# random walk prior standard deviations, with noncentered parameterization
# for the first channel and centered for the second channel.
obs(y ~ 1, family = "gaussian") + obs(x ~ 1, family = "gaussian") +
  lags(type = "varying") +
  splines(
    df = 20, degree = 3, lb_tau = c(0, 0.1),
    noncentered = c(TRUE, FALSE)
  )

</code></pre>

<hr>
<h2 id='update.dynamitefit'>Update a Dynamite Model</h2><span id='topic+update.dynamitefit'></span>

<h3>Description</h3>

<p>Note that using a different backend for the original model fit and when
updating can lead to an error due to different naming in <code>cmdstanr</code> and
<code>rstan</code> sampling arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamitefit'
update(
  object,
  dformula = NULL,
  data = NULL,
  priors = NULL,
  recompile = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.dynamitefit_+3A_object">object</code></td>
<td>
<p>[<code>dynamitefit</code>]<br /> The model fit object.</p>
</td></tr>
<tr><td><code id="update.dynamitefit_+3A_dformula">dformula</code></td>
<td>
<p>[<code>dynamiteformula</code>]<br /> Updated model formula. By default
the original formula is used.</p>
</td></tr>
<tr><td><code id="update.dynamitefit_+3A_data">data</code></td>
<td>
<p>[<code>data.frame</code>, <code>tibble::tibble</code>, or <code>data.table::data.table</code>]<br /> Data for
the updated model. By default original data is used.</p>
</td></tr>
<tr><td><code id="update.dynamitefit_+3A_priors">priors</code></td>
<td>
<p>[<code>data.frame</code>]<br /> Updated priors. By default the priors of
the original model are used.</p>
</td></tr>
<tr><td><code id="update.dynamitefit_+3A_recompile">recompile</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> Should the model be recompiled? If
<code>NULL</code> (default), tries to avoid recompilation. Recompilation is forced when
the model formula or the priors are changed, or if the new data contains
missing values in a channel which did not contain missing values in the
original data. Recompilation is also forced in case the backend previous or
new backend is <code>cmdstanr</code>.</p>
</td></tr>
<tr><td><code id="update.dynamitefit_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>dynamite</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code>dynamitefit</code> object.
</p>


<h3>See Also</h3>

<p>Model fitting
<code><a href="#topic+dynamite">dynamite</a>()</code>,
<code><a href="#topic+get_priors">get_priors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) # For CRAN
## Not run: 
# re-estimate the example fit without thinning:
# As the model is compiled on Windows, this will fail on other platforms
if (identical(.Platform$OS.type, "windows")) {
  fit &lt;- update(gaussian_example_fit, thin = 1)
}

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
