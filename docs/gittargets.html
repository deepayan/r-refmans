<!DOCTYPE html><html><head><title>Help for package gittargets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gittargets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gittargets-package'><p>targets: Dynamic Function-Oriented Make-Like Declarative Pipelines for R</p></a></li>
<li><a href='#tar_git_checkout'><p>Check out a snapshot of the data (Git)</p></a></li>
<li><a href='#tar_git_init'><p>Initialize a data repository (Git).</p></a></li>
<li><a href='#tar_git_log'><p>Data snapshots of a code branch (Git)</p></a></li>
<li><a href='#tar_git_ok'><p>Check Git</p></a></li>
<li><a href='#tar_git_snapshot'><p>Snapshot the data repository (Git).</p></a></li>
<li><a href='#tar_git_snapshot_menu'><p>Data snapshot menu (Git)</p></a></li>
<li><a href='#tar_git_status'><p>Status of the project (Git)</p></a></li>
<li><a href='#tar_git_status_code'><p>Status of the code repository (Git)</p></a></li>
<li><a href='#tar_git_status_data'><p>Status of the data repository (Git)</p></a></li>
<li><a href='#tar_git_status_targets'><p>Status of the targets (Git)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Data Version Control for the Targets Package</td>
</tr>
<tr>
<td>Description:</td>
<td>In computationally demanding data analysis pipelines,
  the 'targets' R package (2021, &lt;<a href="https://doi.org/10.21105%2Fjoss.02959">doi:10.21105/joss.02959</a>&gt;) maintains
  an up-to-date set of results while skipping tasks that do not need to rerun.
  This process increases speed and increases trust in the final end product.
  However, it also overwrites old output with new output, and past
  results disappear by default. To preserve historical output, the 'gittargets'
  package captures version-controlled snapshots of the data store,
  and each snapshot links to the underlying commit of the source code.
  That way, when the user rolls back the code to a previous branch or commit,
  'gittargets' can recover the data contemporaneous with that commit so that
  all targets remain up to date.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.7</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/gittargets/">https://docs.ropensci.org/gittargets/</a>,
<a href="https://github.com/ropensci/gittargets">https://github.com/ropensci/gittargets</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/gittargets/issues">https://github.com/ropensci/gittargets/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>callr (&ge; 3.0.0), cli (&ge; 3.1.0), data.table (&ge; 1.12.8), gert
(&ge; 1.0.0), processx (&ge; 3.0.0), stats, targets (&ge; 0.6.0),
tibble (&ge; 3.0.0), utils, uuid (&ge; 0.1.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.30), markdown (&ge; 1.1), rmarkdown (&ge; 2.4),
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Git (&gt;= 2.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 18:55:38 UTC; C240390</td>
</tr>
<tr>
<td>Author:</td>
<td>William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Saras Windecker [rev],
  David Neuzerling [rev],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Michael Landau &lt;will.landau.oss@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gittargets-package'>targets: Dynamic Function-Oriented Make-Like Declarative Pipelines for R</h2><span id='topic+gittargets-package'></span>

<h3>Description</h3>

<p>In computationally demanding data analysis pipelines,
the <code>targets</code> R package maintains an up-to-date set of results
while skipping tasks that do not need to rerun. This process
increases speed and increases trust in the final end product.
However, it also overwrites old output with new output,
and past results disappear by default. To preserve historical output,
the <code>gittargets</code> package captures version-controlled snapshots
of the data store, and each snapshot links to the underlying
commit of the source code. That way, when the user rolls back
the code to a previous branch or commit, <code>gittargets</code> can recover
the data contemporaneous with that commit so that all targets
remain up to date.
</p>

<hr>
<h2 id='tar_git_checkout'>Check out a snapshot of the data (Git)</h2><span id='topic+tar_git_checkout'></span>

<h3>Description</h3>

<p>Check out a snapshot of the data associated with
a particular code commit (default: <code>HEAD</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_checkout(
  ref = "HEAD",
  code = getwd(),
  store = targets::tar_config_get("store"),
  force = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_checkout_+3A_ref">ref</code></td>
<td>
<p>Character of length 1. SHA1 hash, branch name,
or other reference in the code repository
that points to a code commit. (You can also identify the code
commit by supplying a data branch of the form <code style="white-space: pre;">&#8288;code=&lt;SHA1&gt;&#8288;</code>.)
Defaults to <code>"HEAD"</code>, which points to the currently
checked out code commit.
</p>
<p>Once the desired code commit is identified,
<code>tar_git_snapshot()</code> checks out the latest corresponding data snapshot.
There may be earlier data snapshots corresponding to this code commit,
but <code>tar_git_snapshot()</code> only checks out the latest one.
To check out an earlier superseded data snapshot,
you will need to manually use command line Git in the data repository.
</p>
<p>If <code>tar_git_snapshot()</code> cannot find a data snapshot for the
desired code commit, then it will throw an error.
For a list of commits in the current code branch
that have available data snapshots, see the <code>commit_code</code>
column of the output of <code><a href="#topic+tar_git_log">tar_git_log()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_git_checkout_+3A_code">code</code></td>
<td>
<p>Character of length 1, directory path to the code repository,
usually the root of the <code>targets</code> project.</p>
</td></tr>
<tr><td><code id="tar_git_checkout_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="targets.html#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_git_checkout_+3A_force">force</code></td>
<td>
<p>ignore conflicts and overwrite modified files</p>
</td></tr>
<tr><td><code id="tar_git_checkout_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print R console messages
confirming that a snapshot was created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (invisibly).
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.getenv("TAR_EXAMPLES") == "true" &amp;&amp; tar_git_ok(verbose = FALSE)) {
targets::tar_dir({ # Containing code does not modify the user's filespace.
# Work on an initial branch.
targets::tar_script(tar_target(data, "old_data"))
targets::tar_make()
targets::tar_read(data) # "old_data"
gert::git_init()
gert::git_add("_targets.R")
gert::git_commit("First commit")
gert::git_branch_create("old_branch")
tar_git_init()
# Work on a new branch.
tar_git_snapshot(status = FALSE, verbose = FALSE)
targets::tar_script(tar_target(data, "new_data"))
targets::tar_make()
targets::tar_read(data) # "new_data"
gert::git_branch_create("new_branch")
gert::git_add("_targets.R")
gert::git_commit("Second commit")
tar_git_snapshot(status = FALSE, verbose = FALSE)
# Go back to the old branch.
gert::git_branch_checkout("old_branch")
# The target is out of date because we only reverted the code.
targets::tar_outdated()
# But tar_git_checkout() lets us restore the old version of the data!
tar_git_checkout()
targets::tar_read(data) # "old_data"
# Now, the target is up to date! And we did not even have to rerun it!
targets::tar_outdated()
})
}
</code></pre>

<hr>
<h2 id='tar_git_init'>Initialize a data repository (Git).</h2><span id='topic+tar_git_init'></span>

<h3>Description</h3>

<p>Initialize a Git repository for a <code>targets</code> data store.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_init(
  store = targets::tar_config_get("store"),
  stash_gitignore = TRUE,
  git_lfs = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_init_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="targets.html#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_git_init_+3A_stash_gitignore">stash_gitignore</code></td>
<td>
<p>Logical of length 1, whether to temporarily
stash the <code>.gitignore</code> file of the data store. See the
&quot;Stashing .gitignore&quot; section for details.</p>
</td></tr>
<tr><td><code id="tar_git_init_+3A_git_lfs">git_lfs</code></td>
<td>
<p>Logical, whether to automatically opt into Git LFS to track
large files in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code> more efficiently. If <code>TRUE</code>
and Git LFS is installed, it should work automatically. If <code>FALSE</code>,
you can always opt in later by running <code style="white-space: pre;">&#8288;git lfs track objects&#8288;</code>
inside the data store.</p>
</td></tr>
<tr><td><code id="tar_git_init_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print messages to the
R console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_git_init()</code> also writes a <code>.gitattributes</code> file to the
store to automatically track target output date with <code>git-lfs</code>
if it is installed on your system.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Stashing .gitignore</h3>

<p>The <code>targets</code> package writes a <code>.gitignore</code> file to new data stores
in order to prevent accidental commits to the code Git repository.
Unfortunately, for <code>gittargets</code>, this automatic <code>.gitignore</code> file
interferes with proper data versioning. So by default, <code>gittargets</code>
temporarily stashes it to a hidden file called <code>.gittargets_gitignore</code>
inside the data store. If your R program crashes while the stash
is active, you can simply move it manually back to <code>.gitignore</code>
or run <code>tar_git_status_data()</code> to restore the stash automatically
if no <code>.gitignore</code> already exists.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.getenv("TAR_EXAMPLES") == "true" &amp;&amp; tar_git_ok(verbose = FALSE)) {
targets::tar_dir({ # Containing code does not modify the user's file space.
targets::tar_script(tar_target(data, 1))
targets::tar_make()
tar_git_init()
})
}
</code></pre>

<hr>
<h2 id='tar_git_log'>Data snapshots of a code branch (Git)</h2><span id='topic+tar_git_log'></span>

<h3>Description</h3>

<p>Show all the data snapshots of a code branch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_log(
  code = getwd(),
  store = targets::tar_config_get("store"),
  branch = gert::git_branch(repo = code),
  max = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_log_+3A_code">code</code></td>
<td>
<p>Character of length 1, directory path to the code repository,
usually the root of the <code>targets</code> project.</p>
</td></tr>
<tr><td><code id="tar_git_log_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="targets.html#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_git_log_+3A_branch">branch</code></td>
<td>
<p>Character of length 1, name of the code repository branch
to query. Defaults to the currently checked-out code branch.</p>
</td></tr>
<tr><td><code id="tar_git_log_+3A_max">max</code></td>
<td>
<p>Positive numeric of length 1, maximum number of code commits
to inspect for the given branch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By design, <code>tar_git_log()</code> only queries a single
code branch at a time. This allows <code>tar_git_log()</code>
to report more detailed information about the snapshots
of the given code branch.
To query all data snapshots over all branches, simply run
<code>gert::git_branch_list(local = TRUE, repo = "_targets")</code>.
The valid snapshots show <code>"code=&lt;SHA1&gt;"</code> in the <code>name</code> column,
where <code style="white-space: pre;">&#8288;&lt;SHA1&gt;&#8288;</code> is the Git commit hash of the code commit
corresponding to the data snapshot.
</p>


<h3>Value</h3>

<p>A data frame of information about
data snapshots and code commits.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.getenv("TAR_EXAMPLES") == "true" &amp;&amp; tar_git_ok(verbose = FALSE)) {
targets::tar_dir({ # Containing code does not modify the user's filespace.
targets::tar_script(tar_target(data, 1))
targets::tar_make()
gert::git_init()
gert::git_add("_targets.R")
gert::git_commit("First commit")
tar_git_init()
tar_git_snapshot(status = FALSE, verbose = FALSE)
tar_git_log()
})
}
</code></pre>

<hr>
<h2 id='tar_git_ok'>Check Git</h2><span id='topic+tar_git_ok'></span>

<h3>Description</h3>

<p>Check if Git is installed and if <code>user.name</code> and <code>user.email</code>
are configured globally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_ok(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_ok_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can install Git from <a href="https://git-scm.com/downloads/">https://git-scm.com/downloads/</a>
and configure your identity using the instructions at
<a href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup">https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup</a>.
You may find it convenient to run <code>gert::git_config_global()</code>
with <code>name</code> equal to <code>user.name</code> and <code>user.email</code>.
</p>


<h3>Value</h3>

<p>Logical of length 1, whether Git is installed and configured
correctly.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_git_ok()
</code></pre>

<hr>
<h2 id='tar_git_snapshot'>Snapshot the data repository (Git).</h2><span id='topic+tar_git_snapshot'></span>

<h3>Description</h3>

<p>Snapshot the Git data repository of a <code>targets</code> project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_snapshot(
  message = NULL,
  ref = "HEAD",
  code = getwd(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store"),
  stash_gitignore = TRUE,
  reporter = targets::tar_config_get("reporter_outdated"),
  envir = parent.frame(),
  callr_function = callr::r,
  callr_arguments = NULL,
  status = interactive(),
  force = FALSE,
  pack_refs = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_snapshot_+3A_message">message</code></td>
<td>
<p>Optional Git commit message of the data snapshot.
If <code>NULL</code>, then the message is the Git commit message of the
matching code commit.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_ref">ref</code></td>
<td>
<p>Character of length 1, reference
(branch name, Git SHA1 hash, etc.) of the code commit
that will map to the new data snapshot. Defaults to the commit
checked out right now.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_code">code</code></td>
<td>
<p>Character of length 1, directory path to the code repository,
usually the root of the <code>targets</code> project.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="targets.html#topic+tar_script">tar_script()</a></code>,
<code><a href="targets.html#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="targets.html#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="targets.html#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_stash_gitignore">stash_gitignore</code></td>
<td>
<p>Logical of length 1, whether to temporarily
stash the <code>.gitignore</code> file of the data store. See the
&quot;Stashing .gitignore&quot; section for details.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="targets.html#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_status">status</code></td>
<td>
<p>Logical of length 1, whether to print the project status
with <code><a href="#topic+tar_git_status">tar_git_status()</a></code> and ask whether a snapshot should be created.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_force">force</code></td>
<td>
<p>Logical of length 1. Force checkout the data branch
of an existing data snapshot of the current code commit?</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_pack_refs">pack_refs</code></td>
<td>
<p>Logical of length 1, whether to run <code style="white-space: pre;">&#8288;git pack-refs --all&#8288;</code>
in the data store after taking the snapshot. Packing references
improves efficiency when the number of snapshots is large.
Learn more at <a href="https://git-scm.com/docs/git-pack-refs">https://git-scm.com/docs/git-pack-refs</a>.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print R console messages
confirming that a snapshot was created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Git-backed <code>gittargets</code> data snapshot is a special kind of
Git commit. Every data commit is part of a branch specific to
the current code commit.
That way, when you switch branches or commits in the code,
<code>tar_git_checkout()</code> checks out the latest data snapshot
that matches the code in your workspace.
That way, your targets can stay up to date even as you
transition among multiple branches.
</p>


<h3>Stashing .gitignore</h3>

<p>The <code>targets</code> package writes a <code>.gitignore</code> file to new data stores
in order to prevent accidental commits to the code Git repository.
Unfortunately, for <code>gittargets</code>, this automatic <code>.gitignore</code> file
interferes with proper data versioning. So by default, <code>gittargets</code>
temporarily stashes it to a hidden file called <code>.gittargets_gitignore</code>
inside the data store. If your R program crashes while the stash
is active, you can simply move it manually back to <code>.gitignore</code>
or run <code>tar_git_status_data()</code> to restore the stash automatically
if no <code>.gitignore</code> already exists.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.getenv("TAR_EXAMPLES") == "true" &amp;&amp; tar_git_ok(verbose = FALSE)) {
targets::tar_dir({ # Containing code does not modify the user's filespace.
targets::tar_script(tar_target(data, 1))
targets::tar_make()
gert::git_init()
gert::git_add("_targets.R")
gert::git_commit("First commit")
tar_git_init()
tar_git_snapshot(status = FALSE)
})
}
</code></pre>

<hr>
<h2 id='tar_git_snapshot_menu'>Data snapshot menu (Git)</h2><span id='topic+tar_git_snapshot_menu'></span>

<h3>Description</h3>

<p>Check the project status and show an interactive menu
for <code><a href="#topic+tar_git_snapshot">tar_git_snapshot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_snapshot_menu(
  commit,
  message,
  code,
  script,
  store,
  stash_gitignore,
  reporter,
  envir,
  callr_function,
  callr_arguments
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_snapshot_menu_+3A_commit">commit</code></td>
<td>
<p>Character of length 1, Git SHA1 hash of the code commit
that will correspond to the data snapshot (if created).</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_message">message</code></td>
<td>
<p>Optional Git commit message of the data snapshot.
If <code>NULL</code>, then the message is the Git commit message of the
matching code commit.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_code">code</code></td>
<td>
<p>Character of length 1, directory path to the code repository,
usually the root of the <code>targets</code> project.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="targets.html#topic+tar_script">tar_script()</a></code>,
<code><a href="targets.html#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="targets.html#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="targets.html#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_stash_gitignore">stash_gitignore</code></td>
<td>
<p>Logical of length 1, whether to temporarily
stash the <code>.gitignore</code> file of the data store. See the
&quot;Stashing .gitignore&quot; section for details.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="targets.html#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_git_snapshot_menu_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer of length 1: <code>2L</code> if the user agrees to snapshot,
<code>1L</code> if the user declines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples of tar_git_snapshot().
</code></pre>

<hr>
<h2 id='tar_git_status'>Status of the project (Git)</h2><span id='topic+tar_git_status'></span>

<h3>Description</h3>

<p>Print the status of the code repository,
the data repository, and the targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_status(
  code = getwd(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store"),
  stash_gitignore = TRUE,
  reporter = targets::tar_config_get("reporter_outdated"),
  envir = parent.frame(),
  callr_function = callr::r,
  callr_arguments = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_status_+3A_code">code</code></td>
<td>
<p>Character of length 1, directory path to the code repository,
usually the root of the <code>targets</code> project.</p>
</td></tr>
<tr><td><code id="tar_git_status_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="targets.html#topic+tar_script">tar_script()</a></code>,
<code><a href="targets.html#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="targets.html#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_git_status_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="targets.html#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_git_status_+3A_stash_gitignore">stash_gitignore</code></td>
<td>
<p>Logical of length 1, whether to temporarily
stash the <code>.gitignore</code> file of the data store. See the
&quot;Stashing .gitignore&quot; section for details.</p>
</td></tr>
<tr><td><code id="tar_git_status_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_git_status_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="targets.html#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_git_status_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_git_status_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). Status information is printed
to the R console.
</p>


<h3>Stashing .gitignore</h3>

<p>The <code>targets</code> package writes a <code>.gitignore</code> file to new data stores
in order to prevent accidental commits to the code Git repository.
Unfortunately, for <code>gittargets</code>, this automatic <code>.gitignore</code> file
interferes with proper data versioning. So by default, <code>gittargets</code>
temporarily stashes it to a hidden file called <code>.gittargets_gitignore</code>
inside the data store. If your R program crashes while the stash
is active, you can simply move it manually back to <code>.gitignore</code>
or run <code>tar_git_status_data()</code> to restore the stash automatically
if no <code>.gitignore</code> already exists.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.getenv("TAR_EXAMPLES") == "true" &amp;&amp; tar_git_ok(verbose = FALSE)) {
targets::tar_dir({ # Containing code does not modify the user's files pace.
targets::tar_script(tar_target(data, 1))
targets::tar_make()
list.files("_targets", all.files = TRUE)
gert::git_init()
tar_git_init()
tar_git_status()
})
}
</code></pre>

<hr>
<h2 id='tar_git_status_code'>Status of the code repository (Git)</h2><span id='topic+tar_git_status_code'></span>

<h3>Description</h3>

<p>Show the Git status of the code repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_status_code(code = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_status_code_+3A_code">code</code></td>
<td>
<p>Character of length 1, directory path to the code repository,
usually the root of the <code>targets</code> project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the code repository exists, the return value is the data frame
produced by <code>gert::git_status(repo = code)</code>. If the code has no Git
repository, then the return value is <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.getenv("TAR_EXAMPLES") == "true" &amp;&amp; tar_git_ok(verbose = FALSE)) {
targets::tar_dir({ # Containing code does not modify the user's file space.
targets::tar_script(tar_target(data, 1))
targets::tar_make()
list.files("_targets", all.files = TRUE)
gert::git_init()
tar_git_init()
tar_git_status_code()
})
}
</code></pre>

<hr>
<h2 id='tar_git_status_data'>Status of the data repository (Git)</h2><span id='topic+tar_git_status_data'></span>

<h3>Description</h3>

<p>Show the Git status of the data repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_status_data(
  store = targets::tar_config_get("store"),
  stash_gitignore = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_status_data_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="targets.html#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_git_status_data_+3A_stash_gitignore">stash_gitignore</code></td>
<td>
<p>Logical of length 1, whether to temporarily
stash the <code>.gitignore</code> file of the data store. See the
&quot;Stashing .gitignore&quot; section for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the data repository exists, the return value is the data frame
produced by <code>gert::git_status(repo = store)</code>. If the data store has no Git
repository, then the return value is <code>NULL</code>.
</p>


<h3>Stashing .gitignore</h3>

<p>The <code>targets</code> package writes a <code>.gitignore</code> file to new data stores
in order to prevent accidental commits to the code Git repository.
Unfortunately, for <code>gittargets</code>, this automatic <code>.gitignore</code> file
interferes with proper data versioning. So by default, <code>gittargets</code>
temporarily stashes it to a hidden file called <code>.gittargets_gitignore</code>
inside the data store. If your R program crashes while the stash
is active, you can simply move it manually back to <code>.gitignore</code>
or run <code>tar_git_status_data()</code> to restore the stash automatically
if no <code>.gitignore</code> already exists.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_targets">tar_git_status_targets</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.getenv("TAR_EXAMPLES") == "true" &amp;&amp; tar_git_ok(verbose = FALSE)) {
targets::tar_dir({ # Containing code does not modify the user's file space.
targets::tar_script(tar_target(data, 1))
targets::tar_make()
list.files("_targets", all.files = TRUE)
gert::git_init()
tar_git_init()
tar_git_status_data()
})
}
</code></pre>

<hr>
<h2 id='tar_git_status_targets'>Status of the targets (Git)</h2><span id='topic+tar_git_status_targets'></span>

<h3>Description</h3>

<p>Show which targets are outdated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_git_status_targets(
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store"),
  reporter = targets::tar_config_get("reporter_outdated"),
  envir = parent.frame(),
  callr_function = callr::r,
  callr_arguments = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_git_status_targets_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="targets.html#topic+tar_script">tar_script()</a></code>,
<code><a href="targets.html#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="targets.html#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_git_status_targets_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="targets.html#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="targets.html#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
<tr><td><code id="tar_git_status_targets_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_git_status_targets_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="targets.html#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_git_status_targets_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_git_status_targets_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has prettier output than <code>targets::tar_outdated()</code>,
and it mainly serves <code><a href="#topic+tar_git_status">tar_git_status()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with the names of outdated targets.
</p>


<h3>See Also</h3>

<p>Other git: 
<code><a href="#topic+tar_git_checkout">tar_git_checkout</a>()</code>,
<code><a href="#topic+tar_git_init">tar_git_init</a>()</code>,
<code><a href="#topic+tar_git_log">tar_git_log</a>()</code>,
<code><a href="#topic+tar_git_ok">tar_git_ok</a>()</code>,
<code><a href="#topic+tar_git_snapshot">tar_git_snapshot</a>()</code>,
<code><a href="#topic+tar_git_status_code">tar_git_status_code</a>()</code>,
<code><a href="#topic+tar_git_status_data">tar_git_status_data</a>()</code>,
<code><a href="#topic+tar_git_status">tar_git_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>targets::tar_dir({ # Containing code does not modify the user's file space.
targets::tar_script(tar_target(data, 1))
targets::tar_make()
list.files("_targets", all.files = TRUE)
tar_git_status_targets()
})
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
