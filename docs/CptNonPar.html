<!DOCTYPE html><html><head><title>Help for package CptNonPar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CptNonPar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multilag.cpts.merge'><p>Merge Change Point Estimators from Multiple Lags</p></a></li>
<li><a href='#multiscale.np.mojo'><p>Multiscale Nonparametric Multiple Lag Change Point Detection</p></a></li>
<li><a href='#np.mojo'><p>Nonparametric Single Lag Change Point Detection</p></a></li>
<li><a href='#np.mojo.multilag'><p>Nonparametric Multiple Lag Change Point Detection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Change Point Detection for Multivariate Time
Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Euan T. McGonigle &lt;e.t.mcgonigle@soton.ac.uk&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the nonparametric moving sum procedure for detecting 
    changes in the joint characteristic function (NP-MOJO) for multiple change
    point detection in multivariate time series. See McGonigle, E. T., Cho, H. 
    (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2305.07581">doi:10.48550/arXiv.2305.07581</a>&gt; for description of the NP-MOJO methodology.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, doParallel, parallel, parallelly, foreach, Rfast,
iterators, stats</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EuanMcGonigle/CptNonPar">https://github.com/EuanMcGonigle/CptNonPar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EuanMcGonigle/CptNonPar/issues">https://github.com/EuanMcGonigle/CptNonPar/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-23 15:15:35 UTC; euanmcgonigle</td>
</tr>
<tr>
<td>Author:</td>
<td>Euan T. McGonigle [aut, cre],
  Haeran Cho [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-23 15:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='multilag.cpts.merge'>Merge Change Point Estimators from Multiple Lags</h2><span id='topic+multilag.cpts.merge'></span>

<h3>Description</h3>

<p>Merges change point estimators from different lagged values into a final set of overall change point estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilag.cpts.merge(
  x.c,
  eta.merge = 1,
  merge.type = c("sequential", "bottom-up")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multilag.cpts.merge_+3A_x.c">x.c</code></td>
<td>
<p>A <code>list</code> object, where each element of the list is the output of the <a href="#topic+np.mojo">np.mojo</a> function computed at a
different lag.</p>
</td></tr>
<tr><td><code id="multilag.cpts.merge_+3A_eta.merge">eta.merge</code></td>
<td>
<p>A positive numeric value for the minimal mutual distance of
changes, relative to bandwidth, used to merge change point estimators across different lags.</p>
</td></tr>
<tr><td><code id="multilag.cpts.merge_+3A_merge.type">merge.type</code></td>
<td>
<p>String indicating the method used to merge change point estimators from different lags. Possible choices are
</p>

<ul>
<li> <p><code>"sequential"</code>: starting from the left-most change point estimator and proceeding forward in time, estimators
are grouped into clusters based on mutual distance. The estimator yielding the smallest corresponding p-value is
chosen as the change point estimator for that cluster. See McGonigle and Cho (2023) for details.
</p>
</li>
<li> <p><code>"bottom-up"</code>: starting with the smallest p-value, the change points are merged using bottom-up merging (Messer
et al. (2014)).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>See McGonigle and Cho (2023) for further details.
</p>


<h3>Value</h3>

<p>A <code>list</code> object which contains the following fields
</p>
<table>
<tr><td><code>cpts</code></td>
<td>
<p>A matrix with rows corresponding to final change point estimators, with estimated change point location and associated lag and p-value given in columns.</p>
</td></tr>
<tr><td><code>cpt.clusters</code></td>
<td>
<p>A <code>list</code> object of length given by the number of detected change points. Each field contains a matrix of all
change point estimators that are declared to be associated to the corresponding change point in the <code>cpts</code> field.</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E.T., Cho, H. (2023). Nonparametric data segmentation in multivariate time series via joint characteristic functions.
<em>arXiv preprint arXiv:2305.07581</em>.
</p>
<p>Messer M., Kirchner M., Schiemann J., Roeper J., Neininger R., Schneider G. (2014). A Multiple Filter Test for
the Detection of Rate Changes in Renewal Processes with Varying Variance. <em>The Annals of Applied Statistics</em>, 8(4), 2027-2067.
</p>


<h3>See Also</h3>

<p><a href="#topic+np.mojo">np.mojo</a>, <a href="#topic+np.mojo.multilag">np.mojo.multilag</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 500
noise &lt;- c(rep(1, 300), rep(0.4, 200)) * stats::arima.sim(model = list(ar = 0.3), n = n)
signal &lt;- c(rep(0, 100), rep(2, 400))
x &lt;- signal + noise
x.c0 &lt;- np.mojo(x, G = 83, lag = 0)
x.c1 &lt;- np.mojo(x, G = 83, lag = 1)
x.c &lt;- multilag.cpts.merge(list(x.c0, x.c1))
x.c
</code></pre>

<hr>
<h2 id='multiscale.np.mojo'>Multiscale Nonparametric Multiple Lag Change Point Detection</h2><span id='topic+multiscale.np.mojo'></span>

<h3>Description</h3>

<p>For a given set of bandwidths and lagged values of the time series, performs
multiscale nonparametric change point detection of a possibly multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale.np.mojo(
  x,
  G,
  lags = c(0, 1),
  kernel.f = c("quad.exp", "gauss", "euclidean", "laplace", "sine")[1],
  kern.par = 1,
  data.driven.kern.par = TRUE,
  threshold = c("bootstrap", "manual")[1],
  threshold.val = NULL,
  alpha = 0.1,
  reps = 199,
  boot.dep = 1.5 * (nrow(as.matrix(x))^(1/3)),
  parallel = FALSE,
  boot.method = c("mean.subtract", "no.mean.subtract")[1],
  criterion = c("eta", "epsilon", "eta.and.epsilon")[3],
  eta = 0.4,
  epsilon = 0.02,
  use.mean = FALSE,
  eta.merge = 1,
  merge.type = c("sequential", "bottom-up")[1],
  eta.bottom.up = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiscale.np.mojo_+3A_x">x</code></td>
<td>
<p>Input data (a <code>numeric</code> vector or an object of classes <code>ts</code> and <code>timeSeries</code>,
or a <code>numeric</code> matrix with rows representing observations and columns representing variables).</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_g">G</code></td>
<td>
<p>A numeric vector containing the moving sum bandwidths;
all values in the vector <code>G</code> should be less than half the length of the time series.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_lags">lags</code></td>
<td>
<p>A <code>numeric</code> vector giving the range of lagged values of the time series that will be used to detect changes. See
<a href="#topic+np.mojo.multilag">np.mojo.multilag</a> for further details.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_kernel.f">kernel.f</code></td>
<td>
<p>String indicating which kernel function to use when calculating the NP-MOJO detector statistics; with <code>kern.par</code> <code class="reqn">= a</code>, possible values are
</p>

<ul>
<li> <p><code>"quad.exp"</code>: kernel <code class="reqn">h_2</code> in McGonigle and Cho (2023), kernel 5 in Fan et al. (2017):
</p>
<p style="text-align: center;"><code class="reqn">h (x,y) = \prod_{i=1}^{2p} \frac{ (2a - (x_i - y_i)^2) \exp (-\frac{1}{4a} (x_i - y_i)^2 )}{2a} .</code>
</p>

</li>
<li> <p><code>"gauss"</code>: kernel <code class="reqn">h_1</code> in McGonigle and Cho (2023), the standard Gaussian kernel:
</p>
<p style="text-align: center;"><code class="reqn">h (x,y) = \exp ( - \frac{a^2}{2} \Vert x - y  \Vert^2).</code>
</p>

</li>
<li> <p><code>"euclidean"</code>: kernel <code class="reqn">h_3</code> in McGonigle and Cho (2023), the Euclidean distance-based kernel:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \Vert x - y \Vert^a .</code>
</p>

</li>
<li> <p><code>"laplace"</code>: kernel 2 in Fan et al. (2017), based on a Laplace weight function:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \prod_{i=1}^{2p} \left( 1+ a^2 (x_i - y_i)^2  \right)^{-1}.</code>
</p>

</li>
<li> <p><code>"sine"</code>: kernel 4 in Fan et al. (2017), based on a sinusoidal weight function:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \prod_{i=1}^{2p} \frac{-2 | x_i - y_i |  + | x_i - y_i - 2a|  + | x_i - y_i +2a| }{4a} .</code>
</p>

</li></ul>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_kern.par">kern.par</code></td>
<td>
<p>The tuning parameter that appears in the expression for the kernel function, which acts as a scaling parameter.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_data.driven.kern.par">data.driven.kern.par</code></td>
<td>
<p>A <code>logical</code> variable, if set to <code>TRUE</code>, then the kernel tuning parameter is calculated
using the median heuristic, if <code>FALSE</code> it is given by <code>kern.par</code>.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_threshold">threshold</code></td>
<td>
<p>String indicating how the threshold is computed. Possible values are
</p>

<ul>
<li> <p><code>"bootstrap"</code>: the threshold is calculated using the bootstrap method with
significance level <code>alpha</code>.
</p>
</li>
<li> <p><code>"manual"</code>: the threshold is set by the user and must be specified using
the <code>threshold.val</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_threshold.val">threshold.val</code></td>
<td>
<p>The value of the threshold used to declare change points, only to be used if <code>threshold = "manual"</code>.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code>; use iff <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_reps">reps</code></td>
<td>
<p>An integer value for the number of bootstrap replications performed, if <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_boot.dep">boot.dep</code></td>
<td>
<p>A positive value for the strength of dependence in the multiplier bootstrap sequence, if <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_parallel">parallel</code></td>
<td>
<p>A <code>logical</code> variable, if set to <code>TRUE</code>, then parallel computing is used in the bootstrapping procedure
if bootstrapping is performed.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_boot.method">boot.method</code></td>
<td>
<p>A string indicating the method for creating bootstrap replications. It is not recommended to change this. Possible choices are
</p>

<ul>
<li> <p><code>"mean.subtract"</code>: the default choice, as described in McGonigle and Cho (2023).
Empirical mean subtraction is performed to the bootstrapped replicates, improving power.
</p>
</li>
<li> <p><code>"no.mean.subtract"</code>: empirical mean subtraction is not performed, improving size control.
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_criterion">criterion</code></td>
<td>
<p>String indicating how to determine whether each point <code>k</code> at which NP-MOJO statistic
exceeds the threshold is a change point; possible values are
</p>

<ul>
<li> <p><code>"epsilon"</code>: <code>k</code> is the maximum of its local exceeding environment, which has
at least size <code>epsilon*G</code>.
</p>
</li>
<li> <p><code>"eta"</code>: there is no larger exceeding in an <code>eta*G</code> environment of <code>k</code>.
</p>
</li>
<li> <p><code>"eta.and.epsilon"</code>: the recommended default option; <code>k</code> satisfies both the eta
and epsilon criterion. Recommended to use with the standard value of eta that would be used
if <code>criterion = "eta"</code> (e.g. 0.4), but much smaller value of epsilon than would be used
if <code>criterion = "epsilon"</code>, e.g. 0.02.
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_eta">eta</code></td>
<td>
<p>A positive numeric value for the minimal mutual distance of
changes, relative to bandwidth (if <code>criterion = "eta"</code> or <code>criterion = "eta.and.epsilon"</code>).</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_epsilon">epsilon</code></td>
<td>
<p>a numeric value in (0,1] for the minimal size of exceeding
environments, relative to moving sum bandwidth (if <code>criterion = "epsilon"</code> or <code>criterion = "eta.and.epsilon"</code>).</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_use.mean">use.mean</code></td>
<td>
<p><code>Logical variable</code>, only to be used if <code>data.drive.kern.par=TRUE</code>. If set to <code>TRUE</code>, the mean
of pairwise distances is used to set the kernel function tuning parameter, instead of the median. May be useful for binary data,
not recommended to be used otherwise.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_eta.merge">eta.merge</code></td>
<td>
<p>A positive numeric value for the minimal mutual distance of
changes, relative to bandwidth, used to merge change point estimators across different lags.</p>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_merge.type">merge.type</code></td>
<td>
<p>String indicating the method used to merge change point estimators from different lags. Possible choices are
</p>

<ul>
<li> <p><code>"sequential"</code>:  Starting from the left-most change point estimator and proceeding forward in time, estimators
are grouped into clusters based on mutual distance. The estimator yielding the smallest corresponding p-value is
chosen as the change point estimator for that cluster. See McGonigle and Cho (2023) for details.
</p>
</li>
<li> <p><code>"bottom-up"</code>: starting with the smallest p-value, the change points are merged using bottom-up merging (Messer
et al. (2014)).
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiscale.np.mojo_+3A_eta.bottom.up">eta.bottom.up</code></td>
<td>
<p>A positive numeric value for the minimal mutual distance of
changes, relative to bandwidth, for use in bottom-up merging of change point estimators across multiple bandwidths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multi-lag NP-MOJO algorithm for nonparametric change point detection is described in McGonigle, E. T. and Cho, H. (2023)
Nonparametric data segmentation in multivariate time series via joint characteristic functions.  <em>arXiv preprint arXiv:2305.07581</em>.
The multiscale version uses bottom-up merging to combine the results of the multi-lag NP-MOJO algorithm
performed over a given set of bandwidths.
</p>


<h3>Value</h3>

<p>A <code>list</code> object that contains the following fields:
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>Set of moving window bandwidths</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>Lags used to detect changes</p>
</td></tr>
<tr><td><code>kernel.f</code>, <code>data.driven.kern.par</code>, <code>use.mean</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>threshold</code>, <code>alpha</code>, <code>reps</code>, <code>boot.dep</code>, <code>boot.method</code>, <code>parallel</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>criterion</code>, <code>eta</code>, <code>epsilon</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>A matrix with rows corresponding to final change point estimators,
with estimated change point location and associated detection bandwidth, lag and p-value given in columns.</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E.T., Cho, H. (2023). Nonparametric data segmentation
in multivariate time series via joint characteristic functions.
<em>arXiv preprint arXiv:2305.07581</em>.
</p>
<p>Fan, Y., de Micheaux, P.L., Penev, S. and Salopek, D. (2017). Multivariate nonparametric test of independence. <em>Journal of Multivariate Analysis</em>,
153, pp.189-210.
</p>
<p>Messer M., Kirchner M., Schiemann J., Roeper J., Neininger R., Schneider G. (2014). A Multiple Filter Test for
the Detection of Rate Changes in Renewal Processes with Varying Variance. <em>The Annals of Applied Statistics</em>, 8(4), 2027-2067.
</p>


<h3>See Also</h3>

<p><a href="#topic+np.mojo.multilag">np.mojo.multilag</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 500
noise &lt;- c(rep(1, 300), rep(0.4, 200)) * stats::arima.sim(model = list(ar = 0.3), n = n)
signal &lt;- c(rep(0, 100), rep(2, 400))
x &lt;- signal + noise
x.c &lt;- multiscale.np.mojo(x, G = c(50, 80), lags = c(0, 1))
x.c$cpts
</code></pre>

<hr>
<h2 id='np.mojo'>Nonparametric Single Lag Change Point Detection</h2><span id='topic+np.mojo'></span>

<h3>Description</h3>

<p>For a given lagged value of the time series, performs nonparametric change point detection of a possibly multivariate
time series. If <code>lag</code> <code class="reqn">\ell = 0</code>, then only marginal changes are detected.
If <code>lag</code> <code class="reqn">\ell \neq 0</code>, then changes in the pairwise distribution of <code class="reqn">(X_t , X_{t+\ell})</code> are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.mojo(
  x,
  G,
  lag = 0,
  kernel.f = c("quad.exp", "gauss", "euclidean", "laplace", "sine")[1],
  kern.par = 1,
  data.driven.kern.par = TRUE,
  alpha = 0.1,
  threshold = c("bootstrap", "manual")[1],
  threshold.val = NULL,
  reps = 199,
  boot.dep = 1.5 * (nrow(as.matrix(x))^(1/3)),
  parallel = FALSE,
  boot.method = c("mean.subtract", "no.mean.subtract")[1],
  criterion = c("eta", "epsilon", "eta.and.epsilon")[3],
  eta = 0.4,
  epsilon = 0.02,
  use.mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np.mojo_+3A_x">x</code></td>
<td>
<p>Input data (a <code>numeric</code> vector or an object of classes <code>ts</code> and <code>timeSeries</code>,
or a <code>numeric</code> matrix with rows representing observations and columns representing variables).</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_g">G</code></td>
<td>
<p>An integer value for the moving sum bandwidth;
<code>G</code> should be less than half the length of the time series.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_lag">lag</code></td>
<td>
<p>The lagged values of the time series used to detect changes. If <code>lag</code> <code class="reqn">\ell = 0</code>, then only marginal changes are detected.
If <code>lag</code> <code class="reqn">\ell \neq 0</code>, then changes in the pairwise distribution of <code class="reqn">(X_t , X_{t+\ell})</code> are detected.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_kernel.f">kernel.f</code></td>
<td>
<p>String indicating which kernel function to use when calculating the NP-MOJO detectors statistics; with <code>kern.par</code> <code class="reqn">= a</code>, possible values are
</p>

<ul>
<li> <p><code>"quad.exp"</code>: kernel <code class="reqn">h_2</code> in McGonigle and Cho (2023), kernel 5 in Fan et al. (2017):
</p>
<p style="text-align: center;"><code class="reqn">h (x,y) = \prod_{i=1}^{2p} \frac{ (2a - (x_i - y_i)^2) \exp (-\frac{1}{4a} (x_i - y_i)^2 )}{2a} .</code>
</p>

</li>
<li> <p><code>"gauss"</code>: kernel <code class="reqn">h_1</code> in McGonigle and Cho (2023), the standard Gaussian kernel:
</p>
<p style="text-align: center;"><code class="reqn">h (x,y) = \exp ( - \frac{a^2}{2} \Vert x - y  \Vert^2) .</code>
</p>

</li>
<li> <p><code>"euclidean"</code>: kernel <code class="reqn">h_3</code> in McGonigle and Cho (2023), the Euclidean distance-based kernel:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \Vert x - y \Vert^a  .</code>
</p>

</li>
<li> <p><code>"laplace"</code>: kernel 2 in Fan et al. (2017), based on a Laplace weight function:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \prod_{i=1}^{2p} \left( 1+ a^2 (x_i - y_i)^2  \right)^{-1}. </code>
</p>

</li>
<li> <p><code>"sine"</code>: kernel 4 in Fan et al. (2017), based on a sinusoidal weight function:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \prod_{i=1}^{2p} \frac{-2 | x_i - y_i |  + | x_i - y_i - 2a|  + | x_i - y_i +2a| }{4a} .</code>
</p>

</li></ul>
</td></tr>
<tr><td><code id="np.mojo_+3A_kern.par">kern.par</code></td>
<td>
<p>The tuning parameter that appears in the expression for the kernel function, which acts as a scaling parameter,
only to be used if <code>data.driven.kern.par = FALSE</code>. If <code>kernel.f = "euclidean"</code>, then <code>kern.par</code> <code class="reqn">\in (0,2)</code>,
otherwise <code>kern.par</code> <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_data.driven.kern.par">data.driven.kern.par</code></td>
<td>
<p>A <code>logical</code> variable, if set to <code>TRUE</code>, then the kernel tuning parameter is calculated
using the median heuristic, if <code>FALSE</code> it is given by <code>kern.par</code>.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code>; use iff <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_threshold">threshold</code></td>
<td>
<p>String indicating how the threshold is computed. Possible values are
</p>

<ul>
<li> <p><code>"bootstrap"</code>: the threshold is calculated using the bootstrap method
with significance level <code>alpha</code>.
</p>
</li>
<li> <p><code>"manual"</code>: the threshold is set by the user and must be
specified using the <code>threshold.val</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="np.mojo_+3A_threshold.val">threshold.val</code></td>
<td>
<p>The value of the threshold used to declare change points, only to be used if <code>threshold = "manual"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_reps">reps</code></td>
<td>
<p>An integer value for the number of bootstrap replications performed, if <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_boot.dep">boot.dep</code></td>
<td>
<p>A positive value for the strength of dependence in the multiplier bootstrap sequence, if <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_parallel">parallel</code></td>
<td>
<p>A <code>logical</code> variable, if set to <code>TRUE</code>, then parallel computing is used in the bootstrapping procedure
if bootstrapping is performed.</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_boot.method">boot.method</code></td>
<td>
<p>A string indicating the method for creating bootstrap replications. It is not recommended to change this. Possible choices are
</p>

<ul>
<li> <p><code>"mean.subtract"</code>: the default choice, as described in McGonigle and Cho (2023).
Empirical mean subtraction is performed to the bootstrapped replicates, improving power.
</p>
</li>
<li> <p><code>"no.mean.subtract"</code>: empirical mean subtraction is not performed, improving size control.
</p>
</li></ul>
</td></tr>
<tr><td><code id="np.mojo_+3A_criterion">criterion</code></td>
<td>
<p>String indicating how to determine whether each point <code>k</code> at which NP-MOJO statistic
exceeds the threshold is a change point; possible values are
</p>

<ul>
<li> <p><code>"epsilon"</code>: <code>k</code> is the maximum of its local exceeding environment,
which has at least size <code>epsilon*G</code>.
</p>
</li>
<li> <p><code>"eta"</code>: there is no larger exceeding in an <code>eta*G</code> environment of <code>k</code>.
</p>
</li>
<li> <p><code>"eta.and.epsilon"</code>: the recommended default option; <code>k</code> satisfies both
the eta and epsilon criterion.
Recommended to use with the standard value of eta that would be used if <code>criterion = "eta"</code> (e.g. 0.4),
but much smaller value of epsilon than would be used if <code>criterion = "epsilon"</code>, e.g. 0.02.
</p>
</li></ul>
</td></tr>
<tr><td><code id="np.mojo_+3A_eta">eta</code></td>
<td>
<p>A positive numeric value for the minimal mutual distance of
changes, relative to bandwidth (if <code>criterion = "eta"</code> or <code>criterion = "eta.and.epsilon"</code>).</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_epsilon">epsilon</code></td>
<td>
<p>a numeric value in (0,1] for the minimal size of exceeding
environments, relative to moving sum bandwidth (if <code>criterion = "epsilon"</code> or <code>criterion = "eta.and.epsilon"</code>).</p>
</td></tr>
<tr><td><code id="np.mojo_+3A_use.mean">use.mean</code></td>
<td>
<p><code>Logical variable</code>, only to be used if <code>data.drive.kern.par=TRUE</code>. If set to <code>TRUE</code>, the mean
of pairwise distances is used to set the kernel function tuning parameter, instead of the median. May be useful for binary data,
not recommended to be used otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The single-lag NP-MOJO algorithm for nonparametric change point detection is described in McGonigle, E. T. and Cho, H. (2023)
Nonparametric data segmentation in multivariate time series via joint characteristic functions.  <em>arXiv preprint arXiv:2305.07581</em>.
</p>


<h3>Value</h3>

<p>A <code>list</code> object that contains the following fields:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Moving window bandwidth</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>Lag used to detect changes</p>
</td></tr>
<tr><td><code>kernel.f</code>, <code>data.driven.kern.par</code>, <code>use.mean</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>kern.par</code></td>
<td>
<p>The value of the kernel tuning parameter</p>
</td></tr>
<tr><td><code>threshold</code>, <code>alpha</code>, <code>reps</code>, <code>boot.dep</code>, <code>boot.method</code>, <code>parallel</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>threshold.val</code></td>
<td>
<p>Threshold value for declaring change points</p>
</td></tr>
<tr><td><code>criterion</code>, <code>eta</code>, <code>epsilon</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>test.stat</code></td>
<td>
<p>A vector containing the NP-MOJO detector statistics computed from the input data</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>A vector containing the estimated change point locations</p>
</td></tr>
<tr><td><code>p.vals</code></td>
<td>
<p>The corresponding p values of the change points, if the bootstrap method was used</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E.T., Cho, H. (2023). Nonparametric data segmentation in multivariate time series via joint characteristic functions. <em>arXiv preprint arXiv:2305.07581</em>.
</p>
<p>Fan, Y., de Micheaux, P.L., Penev, S. and Salopek, D. (2017). Multivariate nonparametric test of independence. <em>Journal of Multivariate Analysis</em>,
153, pp.189-210.
</p>


<h3>See Also</h3>

<p><a href="#topic+np.mojo.multilag">np.mojo.multilag</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 500
noise &lt;- c(rep(1, 300), rep(0.4, 200)) * stats::arima.sim(model = list(ar = 0.3), n = n)
signal &lt;- c(rep(0, 100), rep(2, 400))
x &lt;- signal + noise
x.c &lt;- np.mojo(x, G = 83, lag = 0)
x.c$cpts
x.c$p.vals
</code></pre>

<hr>
<h2 id='np.mojo.multilag'>Nonparametric Multiple Lag Change Point Detection</h2><span id='topic+np.mojo.multilag'></span>

<h3>Description</h3>

<p>For a given set of lagged values of the time series, performs nonparametric change point detection of a possibly multivariate
time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.mojo.multilag(
  x,
  G,
  lags = c(0, 1),
  kernel.f = c("quad.exp", "gauss", "euclidean", "laplace", "sine")[1],
  kern.par = 1,
  data.driven.kern.par = TRUE,
  threshold = c("bootstrap", "manual")[1],
  threshold.val = NULL,
  alpha = 0.1,
  reps = 199,
  boot.dep = 1.5 * (nrow(as.matrix(x))^(1/3)),
  parallel = FALSE,
  boot.method = c("mean.subtract", "no.mean.subtract")[1],
  criterion = c("eta", "epsilon", "eta.and.epsilon")[3],
  eta = 0.4,
  epsilon = 0.02,
  use.mean = FALSE,
  eta.merge = 1,
  merge.type = c("sequential", "bottom-up")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np.mojo.multilag_+3A_x">x</code></td>
<td>
<p>Input data (a <code>numeric</code> vector or an object of classes <code>ts</code> and <code>timeSeries</code>,
or a <code>numeric</code> matrix with rows representing observations and columns representing variables).</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_g">G</code></td>
<td>
<p>An integer value for the moving sum bandwidth;
<code>G</code> should be less than half the length of the time series.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_lags">lags</code></td>
<td>
<p>A <code>numeric</code> vector giving the range of lagged values of the time series that will be used to detect changes. See
<a href="#topic+np.mojo">np.mojo</a> for further details.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_kernel.f">kernel.f</code></td>
<td>
<p>String indicating which kernel function to use when calculating the NP-MOJO detector statistics; with <code>kern.par</code> <code class="reqn">= a</code>, possible values are
</p>

<ul>
<li> <p><code>"quad.exp"</code>: kernel <code class="reqn">h_2</code> in McGonigle and Cho (2023), kernel 5 in Fan et al. (2017):
</p>
<p style="text-align: center;"><code class="reqn">h (x,y) = \prod_{i=1}^{2p} \frac{ (2a - (x_i - y_i)^2) \exp (-\frac{1}{4a} (x_i - y_i)^2 )}{2a} .</code>
</p>

</li>
<li> <p><code>"gauss"</code>: kernel <code class="reqn">h_1</code> in McGonigle and Cho (2023), the standard Gaussian kernel:
</p>
<p style="text-align: center;"><code class="reqn">h (x,y) = \exp ( - \frac{a^2}{2} \Vert x - y  \Vert^2) .</code>
</p>

</li>
<li> <p><code>"euclidean"</code>: kernel <code class="reqn">h_3</code> in McGonigle and Cho (2023), the Euclidean distance-based kernel:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \Vert x - y \Vert^a  .</code>
</p>

</li>
<li> <p><code>"laplace"</code>: kernel 2 in Fan et al. (2017), based on a Laplace weight function:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \prod_{i=1}^{2p} \left( 1+ a^2 (x_i - y_i)^2  \right)^{-1}. </code>
</p>

</li>
<li> <p><code>"sine"</code>: kernel 4 in Fan et al. (2017), based on a sinusoidal weight function:
</p>
<p style="text-align: center;"><code class="reqn">h (x, y ) = \prod_{i=1}^{2p} \frac{-2 | x_i - y_i |  + | x_i - y_i - 2a|  + | x_i - y_i +2a| }{4a} .</code>
</p>

</li></ul>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_kern.par">kern.par</code></td>
<td>
<p>The tuning parameter that appears in the expression for the kernel function, which acts as a scaling parameter.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_data.driven.kern.par">data.driven.kern.par</code></td>
<td>
<p>A <code>logical</code> variable, if set to <code>TRUE</code>, then the kernel tuning parameter is calculated
using the median heuristic, if <code>FALSE</code> it is given by <code>kern.par</code>.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_threshold">threshold</code></td>
<td>
<p>String indicating how the threshold is computed. Possible values are
</p>

<ul>
<li> <p><code>"bootstrap"</code>: the threshold is calculated using the bootstrap method with significance level <code>alpha</code>.
</p>
</li>
<li> <p><code>"manual"</code>: the threshold is set by the user and must be specified using the <code>threshold.val</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_threshold.val">threshold.val</code></td>
<td>
<p>The value of the threshold used to declare change points, only to be used if <code>threshold = "manual"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code>; use iff <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_reps">reps</code></td>
<td>
<p>An integer value for the number of bootstrap replications performed, if <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_boot.dep">boot.dep</code></td>
<td>
<p>A positive value for the strength of dependence in the multiplier bootstrap sequence, if <code>threshold = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_parallel">parallel</code></td>
<td>
<p>A <code>logical</code> variable, if set to <code>TRUE</code>, then parallel computing is used in the bootstrapping procedure
if bootstrapping is performed.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_boot.method">boot.method</code></td>
<td>
<p>A string indicating the method for creating bootstrap replications. It is not recommended to change this. Possible choices are
</p>

<ul>
<li> <p><code>"mean.subtract"</code>: the default choice, as described in McGonigle and Cho (2023).
Empirical mean subtraction is performed to the bootstrapped replicates, improving power.
</p>
</li>
<li> <p><code>"no.mean.subtract"</code>: empirical mean subtraction is not performed, improving size control.
</p>
</li></ul>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_criterion">criterion</code></td>
<td>
<p>String indicating how to determine whether each point <code>k</code> at which NP-MOJO statistic
exceeds the threshold is a change point; possible values are
</p>

<ul>
<li> <p><code>"epsilon"</code>: <code>k</code> is the maximum of its local exceeding environment,
which has at least size <code>epsilon*G</code>.
</p>
</li>
<li> <p><code>"eta"</code>: there is no larger exceeding in an <code>eta*G</code> environment of <code>k</code>.
</p>
</li>
<li> <p><code>"eta.and.epsilon"</code>: the recommended default option; <code>k</code> satisfies both the eta and epsilon criterion.
Recommended to use with the standard value of eta that would be used if <code>criterion = "eta"</code> (e.g. 0.4),
but much smaller value of epsilon than would be used if <code>criterion = "epsilon"</code>, e.g. 0.02.
</p>
</li></ul>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_eta">eta</code></td>
<td>
<p>A positive numeric value for the minimal mutual distance of
changes, relative to bandwidth (if <code>criterion = "eta"</code> or <code>criterion = "eta.and.epsilon"</code>).</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_epsilon">epsilon</code></td>
<td>
<p>a numeric value in (0,1] for the minimal size of exceeding
environments, relative to moving sum bandwidth (if <code>criterion = "epsilon"</code> or <code>criterion = "eta.and.epsilon"</code>).</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_use.mean">use.mean</code></td>
<td>
<p><code>Logical variable</code>, only to be used if <code>data.drive.kern.par=TRUE</code>. If set to <code>TRUE</code>, the mean
of pairwise distances is used to set the kernel function tuning parameter, instead of the median. May be useful for binary data,
not recommended to be used otherwise.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_eta.merge">eta.merge</code></td>
<td>
<p>A positive numeric value for the minimal mutual distance of
changes, relative to bandwidth, used to merge change point estimators across different lags.</p>
</td></tr>
<tr><td><code id="np.mojo.multilag_+3A_merge.type">merge.type</code></td>
<td>
<p>String indicating the method used to merge change point estimators from different lags. Possible choices are
</p>

<ul>
<li> <p><code>"sequential"</code>:  Starting from the left-most change point estimator and proceeding forward in time, estimators
are grouped into clusters based on mutual distance. The estimator yielding the smallest corresponding p-value is
chosen as the change point estimator for that cluster. See McGonigle and Cho (2023) for details.
</p>
</li>
<li> <p><code>"bottom-up"</code>: starting with the smallest p-value, the change points are merged using bottom-up merging (Messer
et al. (2014)).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The multi-lag NP-MOJO algorithm for nonparametric change point detection is described in McGonigle, E. T. and Cho, H. (2023)
Nonparametric data segmentation in multivariate time series via joint characteristic functions.  <em>arXiv preprint arXiv:2305.07581</em>.
</p>


<h3>Value</h3>

<p>A <code>list</code> object that contains the following fields:
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>Moving window bandwidth</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>Lags used to detect changes</p>
</td></tr>
<tr><td><code>kernel.f</code>, <code>data.driven.kern.par</code>, <code>use.mean</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>threshold</code>, <code>alpha</code>, <code>reps</code>, <code>boot.dep</code>, <code>boot.method</code>, <code>parallel</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>criterion</code>, <code>eta</code>, <code>epsilon</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>A matrix with rows corresponding to final change point estimators, with estimated change point location and associated lag and p-value given in columns.</p>
</td></tr>
<tr><td><code>cpt.clusters</code></td>
<td>
<p>A <code>list</code> object of length given by the number of detected change points. Each field contains a matrix of all
change point estimators that are declared to be associated to the corresponding change point in the <code>cpts</code> field.</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E.T., Cho, H. (2023). Nonparametric data segmentation in multivariate time series via joint characteristic functions.
<em>arXiv preprint arXiv:2305.07581</em>.
</p>
<p>Fan, Y., de Micheaux, P.L., Penev, S. and Salopek, D. (2017). Multivariate nonparametric test of independence. <em>Journal of Multivariate Analysis</em>,
153, pp.189-210.
</p>
<p>Messer M., Kirchner M., Schiemann J., Roeper J., Neininger R., Schneider G. (2014). A Multiple Filter Test for
the Detection of Rate Changes in Renewal Processes with Varying Variance. <em>The Annals of Applied Statistics</em>, 8(4), 2027-2067.
</p>


<h3>See Also</h3>

<p><a href="#topic+np.mojo">np.mojo</a>, <a href="#topic+multilag.cpts.merge">multilag.cpts.merge</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 500
noise &lt;- c(rep(1, 300), rep(0.4, 200)) * stats::arima.sim(model = list(ar = 0.3), n = n)
signal &lt;- c(rep(0, 100), rep(2, 400))
x &lt;- signal + noise
x.c &lt;- np.mojo.multilag(x, G = 83, lags = c(0, 1))
x.c$cpts
x.c$cpt.clusters
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
