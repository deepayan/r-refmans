<!DOCTYPE html><html><head><title>Help for package cem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#att'><p>Example of ATT estimation from CEM output</p></a></li>
<li><a href='#cem'><p>Coarsened Exact Matching</p></a></li>
<li><a href='#cemspace'><p>Exploration tool for CEM</p></a></li>
<li><a href='#combine.spacegraphs'><p>Combine two spacegraph objects.</p></a></li>
<li><a href='#DW'><p>Dehejia-Wahba dataset</p></a></li>
<li><a href='#imbalance'><p>Calculates several imbalance measures</p></a></li>
<li><a href='#imbspace'><p>Diagnostic tool for CEM</p></a></li>
<li><a href='#imbspace.plot'><p>Plot of imbalance space diagnostic tool for CEM</p></a></li>
<li><a href='#k2k'><p>Reduction to k2k Matching</p></a></li>
<li><a href='#L1.meas'><p>Evaluates L1 distance between multidimensional histograms</p></a></li>
<li><a href='#L1.profile'><p>Calculates L1 distance for different coarsenings</p></a></li>
<li><a href='#LeLonde'><p>Modified Lalonde dataset</p></a></li>
<li><a href='#LL'><p>Lalonde dataset</p></a></li>
<li><a href='#LLvsPSID'><p>Lalonde treated units versus PSID control individuals</p></a></li>
<li><a href='#pair'><p>Produces a paired sample out of a CEM match solution</p></a></li>
<li><a href='#pscoreSelect'><p>Heuristic search of the best propensity score model specification</p></a></li>
<li><a href='#relax.cem'><p>Diagnostic tool for CEM</p></a></li>
<li><a href='#search.match'><p>Heuristic search of match solutions</p></a></li>
<li><a href='#shift.cem'><p>Diagnostic tool for CEM</p></a></li>
<li><a href='#spacegraph'><p>Randomly compute many different matching solutions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Coarsened Exact Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.31</td>
</tr>
<tr>
<td>Depends:</td>
<td>tcltk, lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>MatchIt, combinat, randomForest, nlme</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Amelia(&ge; 1.2-0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefano M. Iacus &lt;siacus@iq.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Coarsened Exact Matching algorithm discussed 
	along with its properties in
  Iacus, King, Porro (2011) &lt;<a href="https://doi.org/10.1198%2Fjasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>&gt;;
	Iacus, King, Porro (2012) &lt;<a href="https://doi.org/10.1093%2Fpan%2Fmpr013">doi:10.1093/pan/mpr013</a>&gt; and
	Iacus, King, Porro (2019) &lt;<a href="https://doi.org/10.1017%2Fpan.2018.29">doi:10.1017/pan.2018.29</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gking.harvard.edu/cem">https://gking.harvard.edu/cem</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-08 15:25:49 UTC; jago</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefano M. Iacus [aut, cre],
  Gary King [aut],
  Giuseppe Porro [aut],
  Richard Nielsen [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-08 16:12:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='att'>Example of ATT estimation from CEM output</h2><span id='topic+att'></span><span id='topic+plot.cem.att'></span><span id='topic+summary.cem.att'></span>

<h3>Description</h3>

<p>An example of ATT estimation from CEM output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>att(obj, formula, data, model="linear", extrapolate=FALSE, ntree=2000)
## S3 method for class 'cem.att'
plot(x, obj, data, vars=NULL, plot=TRUE, ecolors, ...)
## S3 method for class 'cem.att'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="att_+3A_obj">obj</code></td>
<td>
<p>a <code>cem.match</code> or <code>cem.match.list</code> object</p>
</td></tr>
<tr><td><code id="att_+3A_formula">formula</code></td>
<td>
<p>a model formula. See Details.</p>
</td></tr>
<tr><td><code id="att_+3A_data">data</code></td>
<td>
<p>a single data.frame or a list of data.frame's in case of <code>cem.match.list</code></p>
</td></tr>
<tr><td><code id="att_+3A_model">model</code></td>
<td>
<p>one model. See Details.</p>
</td></tr>
<tr><td><code id="att_+3A_extrapolate">extrapolate</code></td>
<td>
<p>extrapolate the CEM restriced estimate to the whole data. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="att_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to generate in random forest model. Default = <code>2000</code>.</p>
</td></tr>
<tr><td><code id="att_+3A_x">x</code></td>
<td>
<p>the output from the <code>att</code> function</p>
</td></tr>
<tr><td><code id="att_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be used in the parallel plots. By default all variables
involved in data matching are used.</p>
</td></tr>
<tr><td><code id="att_+3A_object">object</code></td>
<td>
<p>an object of class <code>cem.att</code> function</p>
</td></tr>
<tr><td><code id="att_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> the plot is produced, otherwise only calculations are made.</p>
</td></tr>
<tr><td><code id="att_+3A_ecolors">ecolors</code></td>
<td>
<p>a vector of three colors respectively for positive, zero and negative 
treatment effect. Default <code>c("blue","black","red")</code>.</p>
</td></tr>
<tr><td><code id="att_+3A_...">...</code></td>
<td>
<p>passed to the plot function or to <code>printCoefmat</code> for the method summary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>model</code> can be <code>lm, linear</code> for linear regression
model; <code>logit</code> for the the logistic model;
<code>lme, linear-RE</code> for the linear model with random effects. 
Also <code>rf, forest</code> for the randomforest algorithm.
</p>
<p>If the outcome is <code>y</code> and the
treatment variable is <code>T</code>, then a <code>formula</code> like <code>y ~ T</code>
will produce the simplest estimate the ATT: with lm, it is just the
coefficient on <code>T</code>, which is the same as the difference in means,
weighted by CEM stratum size.  Users can add covariates to span any
remaining imbalance after the match, such as <code>y ~ T + age + sex</code>,
to adjust for variables <code>age</code> and <code>sex</code>.
</p>
<p>In the case of multiply imputed datasets, the model is applied to each
single matched data and the ATT and is the standard error estimated
using the standard formulas for combining results of multiply imputed
data.  
</p>
<p>When <code>extrapolate</code> = <code>TRUE</code>, the estimate model is extrapolated
to the whole set of data.
</p>
<p>There is a <code>print</code> method for the output of <code>att</code>. Specifying the
option <code>TRUE</code> in a <code>print</code> command gives complete output from the
estimated model when availalble.
</p>


<h3>Value</h3>

<p>A matrix of estimates with their standard error, or a list in
the case of <code>cem.match.list</code>.  For <code>plot.att</code> a list of strata 
estimated treatment effect and group (&quot;positive&quot;, &quot;negative&quot;, &quot;zero&quot;) and 
individual treatment and effect and group. The individual treatment effect
and group is given by the treatment effect of the strata. Similarly for
the group (&quot;positive&quot;, &quot;negative&quot;, &quot;zero&quot;). Also, colors associated to
estimated treatment effects are returned for easy subsequent plotting.
</p>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(LL)

# cem match: automatic bin choice
mat &lt;- cem(treatment="treated",data=LL, drop="re78", keep.all=TRUE)
mat
mat$k2k

# ATT estimate
homo1 &lt;- att(mat, re78~treated,  data=LL)
rand1 &lt;- att(mat, re78~treated,  data=LL, model="linear-RE")
rf1 &lt;- att(mat, re78~treated,  data=LL, model="rf")

homo2 &lt;- att(mat, re78~treated,  data=LL, extra=TRUE)
rand2 &lt;- att(mat, re78~treated,  data=LL, model="linear-RE", extra=TRUE)
rf2 &lt;- att(mat, re78~treated,  data=LL, model="rf", extra=TRUE)

homo1
summary(homo1)

rand1
rf1

homo2
rand2
rf2

plot( homo1, mat, LL, vars=c("age","education","re74","re75"))
plot( rand1, mat, LL, vars=c("age","education","re74","re75"))
plot( rf1, mat, LL, vars=c("age","education","re74","re75"))

plot( homo2, mat, LL, vars=c("age","education","re74","re75"))
plot( rand2, mat, LL, vars=c("age","education","re74","re75"))
plot( rf2, mat, LL, vars=c("age","education","re74","re75"))


# reduce the match into k2k using euclidean distance within cem strata
mat2 &lt;- k2k(mat, LL, "euclidean", 1)
mat2
mat2$k2k

# ATT estimate after k2k
att(mat2, re78~treated, data=LL)

# example with missing data
# using multiply imputated data
# we use Amelia for multiple imputation


 if(require(Amelia)){
  data(LL)
  n &lt;- dim(LL)[1]
  k &lt;- dim(LL)[2]

# we generate missing values in 30 percent of the rows of LL data
# randomly in one colum per row
  set.seed(123)
  LL1 &lt;- LL
  idx &lt;- sample(1:n, .3*n)
  for(i in idx){
    LL1[i,sample(2:k,1)] &lt;- NA
  }

  imputed &lt;- amelia(LL1)
  imputed &lt;- imputed$imputations[1:5]

  mat &lt;- cem("treated", datalist=imputed, data=LL1, drop="re78")

  print(mat)
  
  att(mat, re78 ~ treated, data=imputed)
 }

</code></pre>

<hr>
<h2 id='cem'>Coarsened Exact Matching</h2><span id='topic+cem'></span>

<h3>Description</h3>

<p>Implementation of Coarsened Exact Matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cem(treatment=NULL, data = NULL, datalist=NULL, cutpoints = NULL,  
    grouping = NULL, drop=NULL, eval.imbalance = FALSE, k2k=FALSE,  
	method=NULL, mpower=2, L1.breaks = NULL, L1.grouping = NULL, 
    verbose = 0, baseline.group="1",keep.all=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cem_+3A_treatment">treatment</code></td>
<td>
<p>character, name of the treatment variable</p>
</td></tr>
<tr><td><code id="cem_+3A_baseline.group">baseline.group</code></td>
<td>
<p>character, name of the baseline level treatment. See Details.</p>
</td></tr>
<tr><td><code id="cem_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="cem_+3A_datalist">datalist</code></td>
<td>
<p>a list of optional multiply imputed data.frame's</p>
</td></tr>
<tr><td><code id="cem_+3A_cutpoints">cutpoints</code></td>
<td>
<p>named list each describing the cutpoints for numerical
variables (the names are variable names).
Each list element is either a vector of cutpoints, a number of
cutpoints, or a method for automatic bin contruction. See Details.</p>
</td></tr>
<tr><td><code id="cem_+3A_grouping">grouping</code></td>
<td>
<p>named list, each element of which is a list of
groupings for a single categorical variable. See Details.</p>
</td></tr>
<tr><td><code id="cem_+3A_drop">drop</code></td>
<td>
<p>a vector of variable names in the data frame to ignore
during matching</p>
</td></tr>
<tr><td><code id="cem_+3A_eval.imbalance">eval.imbalance</code></td>
<td>
<p>Boolean. See Details.</p>
</td></tr>
<tr><td><code id="cem_+3A_k2k">k2k</code></td>
<td>
<p>boolean, restrict to k-to-k matching? Default = <code>FALSE</code></p>
</td></tr>
<tr><td><code id="cem_+3A_method">method</code></td>
<td>
<p>distance method to use in <code>k2k</code> matching. See Details.</p>
</td></tr>
<tr><td><code id="cem_+3A_mpower">mpower</code></td>
<td>
<p>power of the Minkowski distance. See Details.</p>
</td></tr>
<tr><td><code id="cem_+3A_l1.breaks">L1.breaks</code></td>
<td>
<p>list of cutpoints for the calculation of the L1 measure.</p>
</td></tr>
<tr><td><code id="cem_+3A_l1.grouping">L1.grouping</code></td>
<td>
<p>as <code>grouping</code> but only needed in the calculation
of the L1 measure not in matching.</p>
</td></tr>
<tr><td><code id="cem_+3A_verbose">verbose</code></td>
<td>
<p>controls level of verbosity. Default=0.</p>
</td></tr>
<tr><td><code id="cem_+3A_keep.all">keep.all</code></td>
<td>
<p>if <code>FALSE</code> the coarsened dataset is not returned. Default=<code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For multilevel (and a binary) treatment variables, the cem weights
are calulated with respect to the <code>baseline</code>. Therefore,
matched units with treatment variable equal to the baseline level receive weight 1, the others the usual cem weights. Unless specified,
by default <code>baseline</code> is set
to <code>"1"</code>. If this level is not one of the possible values taken by
the <code>treatment</code> variable, then the baseline is set to the first level of the <code>treatment</code> variable.
</p>
<p>When specifying cutpoints, several automatic methods may be chosen, including
&ldquo;<code>sturges</code>&rdquo; (Sturges' rule, the default),
&ldquo;<code>fd</code>&rdquo; (Freedman-Diaconis' rule), &ldquo;<code>scott</code>&rdquo; 
(Scott's rule) and &ldquo;ss&rdquo; (Shimazaki-Shinomoto's rule). 
See references for a description of each rule.
</p>
<p>The <code>grouping</code> option is a list where each element is itself a
list. For example, suppose for variable <code>quest1</code> you have the
following possible levels <code>"no answer", NA, "negative", "neutral",
"positive"</code> and you want to collect <code>("no answer", NA, "neutral")</code>
into a single group, then the <code>grouping</code> argument should contain
<code>list(quest1=list(c("no answer", NA, "neutral")))</code>. Or if you have
a discrete variable <code>elements</code> with values <code>1:10</code> and you want
to collect it into groups &ldquo;<code>1:3,NA</code>&rdquo;, &ldquo;<code>4</code>&rdquo;,
&ldquo;<code>5:9</code>&rdquo;, &ldquo;<code>10</code>&rdquo; you specify in <code>grouping</code> the
following list <code>list(elements=list(c(1:3,NA), 5:9))</code>.  Values not
defined in the <code>grouping</code> are left as they are. If <code>cutpoints</code>
and <code>groupings</code> are defined for the same variable, the
<code>groupings</code> take precedence and the corresponding cutpoints are set
to <code>NULL</code>.
</p>
<p><code>verbose</code>: a number greater or equal to 0. The higher, the 
more info are provided during the execution of the algorithm. 
</p>
<p>If <code>eval.imbalance</code> = <code>TRUE</code>,
<code>cem$imbalance</code> contains the imbalance measure by absolute
difference in means for numerical variables and chi-square distance for
categorical variables.  If <code>FALSE</code> (the default) then <code>cem$imbalance</code> is set
to <code>NULL</code>. If data contains missing data, the imbalance measures
are not calculated.
</p>
<p>If <code>L1.breaks</code> is missing, the default rule to calculate cutpoints
is the Scott's rule. 
</p>
<p>If <code>k2k</code> is set to <code>TRUE</code>, the algorithm return strata with
the same number of treated and control units per stratum, otherwise all
the matched units are returned (default). When <code>k2k</code> = <code>TRUE</code>,
the user can choose a <code>method</code> (between '<code>euclidean</code>',
'<code>maximum</code>', '<code>manhattan</code>', '<code>canberra</code>', '<code>binary</code>'
and '<code>minkowski</code>') for nearest neighbor matching inside each
<code>cem</code> strata. By default <code>method</code> is set to '<code>NULL</code>',
which means random matching inside <code>cem</code> strata. For the Minkowski
distance the power can be specified via the argument <code>mpower</code>'.
For more information on <code>method != NULL</code>, refer to
<code><a href="stats.html#topic+dist">dist</a></code> help page.
If <code>k2k</code> is set to <code>TRUE</code> also <code>keep.all</code> is set to <code>TRUE</code>.
</p>
<p>By default, <code>cem</code> treats missing values as distinct categories and
matches observations with missing values in the same variable in the
same stratum provided that all the remaining (corasened) covariates
match. 
</p>
<p>If argument <code>data</code> is non-<code>NULL</code> and <code>datalist</code> is
<code>NULL</code>, CEM is applied to the single data set in <code>data</code>.
</p>
<p>Argument <code>datalist</code> is a list of (multiply imputed) data frames
(i.e., with missing cell values imputed).  If <code>data</code> is
<code>NULL</code>, the function <code>cem</code> is applied independently to each
element of the list, resulting in separately matched data sets with
different numbers of treated and control units.
</p>
<p>When <code>data</code> and <code>datalist</code> are both non-<code>NULL</code>, each
multiply imputed observation is assigned to the stratum in which it has
been matched most frequently.  In this case, the algorithm outputs the
same matching solution for each multiply imputed data set (i.e., an
observation, and the number of treated and control units matched, in one
data set has the same meaning in all, and is the same for all)
</p>


<h3>Value</h3>

<p>Returns an object of class <code>cem.match</code> if only <code>data</code> is not 
<code>NULL</code> or an object of class <code>cem.match.list</code>, which is a list of
objects of class <code>cem.match</code> plus a field called <code>unique</code> which
is true only if <code>data</code> and <code>datalist</code> are not both <code>NULL</code>.   
A <code>cem.match</code> object is a list
with the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>vector of stratum number in which each observation belongs, 
NA if the observation has not been matched</p>
</td></tr>
<tr><td><code>n.strata</code></td>
<td>
<p>number of strata generated</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>report variables names used for the match</p>
</td></tr>
<tr><td><code>drop</code></td>
<td>
<p>variables removed from the match</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the coarsened dataset or NULL if <code>keep.all</code>=<code>FALSE</code></p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>named list of cutpoints, eventually NULL</p>
</td></tr>
<tr><td><code>treatment</code></td>
<td>
<p>name of the treatment variable</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>factor, each observation belong to one group generated by the 
treatment variable</p>
</td></tr>
<tr><td><code>n.groups</code></td>
<td>
<p>number of groups identified by the treatment variable</p>
</td></tr>
<tr><td><code>group.idx</code></td>
<td>
<p>named list, index of observations belonging to each group</p>
</td></tr>
<tr><td><code>group.len</code></td>
<td>
<p>sizes of groups</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>summary table of matched by group</p>
</td></tr>
<tr><td><code>imbalance</code></td>
<td>
<p>NULL or a vector of imbalances. See Details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>
<p>Shimazaki, Shinomoto (2007) <a href="https://doi.org/10.1162/neco.2007.19.6.1503">doi:10.1162/neco.2007.19.6.1503</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LL)

   
todrop &lt;- c("treated","re78")
   
imbalance(LL$treated, LL, drop=todrop)

# cem match: automatic bin choice
mat &lt;- cem(treatment="treated", data=LL, drop="re78")
mat

# cem match: user choiced coarsening
re74cut &lt;- hist(LL$re74, br=seq(0,max(LL$re74)+1000, by=1000),plot=FALSE)$breaks
re75cut &lt;- hist(LL$re75, br=seq(0,max(LL$re75)+1000, by=1000),plot=FALSE)$breaks
agecut &lt;- hist(LL$age, br=seq(15,55, length=14),plot=FALSE)$breaks
mycp &lt;- list(re75=re75cut, re74=re74cut, age=agecut)
mat &lt;- cem(treatment="treated",data=LL, drop="re78",cutpoints=mycp)
mat


# cem match: user choiced coarsening, k-to-k matching
mat &lt;- cem(treatment="treated",data=LL, drop="re78",cutpoints=mycp,k2k=TRUE)
mat

# mahalnobis matching: we use MatchIt
if(require(MatchIt)){
mah &lt;- matchit(treated~age+education+re74+re75+black+hispanic+nodegree+married+u74+u75,
   distance="mahalanobis", data=LL)
mah
#imbalance
imbalance(LL$treated, LL, drop=todrop, weights=mah$weights)
}

# Multiply Imputed data
# making use of Amelia for multiple imputation
if(require(Amelia)){
 data(LL)
 n &lt;- dim(LL)[1]
 k &lt;- dim(LL)[2]

 set.seed(123)

 LL1 &lt;- LL
 idx &lt;- sample(1:n, .3*n)
 for(i in idx){
  LL1[i,sample(2:k,1)] &lt;- NA
 }

 imputed &lt;- amelia(LL1,noms=c("black","hispanic","treated","married",
                              "nodegree","u74","u75")) 
 imputed &lt;- imputed$imputations[1:5]
# without information on which observation has missing values
 mat1 &lt;- cem("treated", datalist=imputed, drop="re78")
 mat1

# ATT estimation
 out &lt;- att(mat1, re78 ~ treated, data=imputed)


# with information about missingness
 mat2 &lt;- cem("treated", datalist=imputed, drop="re78", data=LL1)
 mat2

# ATT estimation
 out &lt;- att(mat2, re78 ~ treated, data=imputed)
}

</code></pre>

<hr>
<h2 id='cemspace'>Exploration tool for CEM</h2><span id='topic+cemspace'></span>

<h3>Description</h3>

<p>Exploration tool for CEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cemspace(treatment=NULL, data = NULL, R=100, grouping = NULL, drop=NULL,
L1.breaks = NULL, L1.grouping=NULL, plot = TRUE, fixed = NULL, 
minimal = 1, maximal = 5, M=250, raw.profile=NULL, keep.weights=FALSE,
verbose=1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cemspace_+3A_treatment">treatment</code></td>
<td>
<p>character, name of the treatment variable.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_verbose">verbose</code></td>
<td>
<p>integer, controls output.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_r">R</code></td>
<td>
<p>number of possible random coarsening for the CEM.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_grouping">grouping</code></td>
<td>
<p>named list, each element of which is a list of
groupings for a single categorical variable. For more details see <code><a href="#topic+cem">cem</a></code>.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_drop">drop</code></td>
<td>
<p>a vector of variable names in the data frame to ignore
during matching</p>
</td></tr>
<tr><td><code id="cemspace_+3A_l1.breaks">L1.breaks</code></td>
<td>
<p>list of cutpoints for the calculation of the L1 measure.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_l1.grouping">L1.grouping</code></td>
<td>
<p>as <code>grouping</code> but only needed in the calculation
of the L1 measure not in matching.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_plot">plot</code></td>
<td>
<p>plot the space of solutions?</p>
</td></tr>  
<tr><td><code id="cemspace_+3A_fixed">fixed</code></td>
<td>
<p>vector of variable names which will not be relaxed.</p>
</td></tr>  
<tr><td><code id="cemspace_+3A_minimal">minimal</code></td>
<td>
<p>the minimal number of intervals acceptable after
relaxation. Should be a nameed list of positive integers or if a number, this is
applied to all variables.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_maximal">maximal</code></td>
<td>
<p>the maximal number of intervals acceptable after
relaxation. Should be a nameed list of positive integers or if a number, this is
applied to all variables.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_m">M</code></td>
<td>
<p>number of possible random coarsening for the L1 measure</p>
</td></tr>
<tr><td><code id="cemspace_+3A_raw.profile">raw.profile</code></td>
<td>
<p>an object of class <code>L1profile</code>. If passed, the <code>L1.breaks</code> are
ignored and set to median cutpoints of L1 profile.</p>
</td></tr>
<tr><td><code id="cemspace_+3A_keep.weights">keep.weights</code></td>
<td>
<p>if <code>TRUE</code>, for each matching solutions the CEM-weights are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a tool to help the user to explore different cem solutions by choosing
random coarsenings. The algorithm tries <code>R</code> random choiches
of coarsenings into
intervals between <code>minimal</code> and <code>maximal</code> for numerical, integer or
ordered factors. It drops or include dichotomous or boolean variables. 
</p>
<p>Calling directly <code>plot</code> on the output of <code>cemspace</code> has the same
effect of calling directly <code><a href="#topic+imbspace.plot">imbspace.plot</a></code>.
</p>
<p>If you want to relax a given cem solution, use the function 
<code><a href="#topic+imbspace">imbspace</a></code> instead.
</p>


<h3>Value</h3>

<table>
<tr><td><code>val</code></td>
<td>
<p>an invisible object of class <code>imbalance.space</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+imbspace.plot">imbspace.plot</a></code>, <code><a href="#topic+cemspace">cemspace</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LL)
set.seed(123)
tmp &lt;- cemspace("treated", LL, drop="re78", M=50)

</code></pre>

<hr>
<h2 id='combine.spacegraphs'>Combine two spacegraph objects.</h2><span id='topic+combine.spacegraphs'></span>

<h3>Description</h3>

<p>Combine two spacegraph objects so that their results can be plotted together. Both spacegraphs must be from the same dataset using the same distance metric.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.spacegraphs(x,y) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.spacegraphs_+3A_x">x</code></td>
<td>
<p>a spacegraph object to be combined</p>
</td></tr>
<tr><td><code id="combine.spacegraphs_+3A_y">y</code></td>
<td>
<p>a spacegraph object to be combined</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This allows users to combine two spacegraph objects rather than having to re-run the spacegraph command from the start.
</p>
<p>Inputs must be created using <code><a href="#topic+spacegraph">spacegraph</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>val</code></td>
<td>
<p>an object of class <code>spacegraph</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard Nielsen</p>


<h3>See Also</h3>

 <p><code><a href="#topic+spacegraph">spacegraph</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LL)
set.seed(123)
sp1 &lt;- spacegraph("treated", LL, drop="re78", M=5,
                  R=list(cem=5,psm=5, mdm=0))

## Note that we must use the same L1 measure from the first spacegraph!
sp2 &lt;- spacegraph("treated", LL, drop="re78", raw.profile=sp1$raw.profile,
                  R=list(cem=0,psm=0, mdm=5))

sp3 &lt;- combine.spacegraphs(sp1,sp2)

plot(sp3)

</code></pre>

<hr>
<h2 id='DW'>Dehejia-Wahba dataset</h2><span id='topic+DW'></span>

<h3>Description</h3>

<p>A subset of the Lalonde dataset (see cited reference).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DW)</code></pre>


<h3>Format</h3>

<p>A data frame with 445 observations on the following 10 variables.
</p>

<dl>
<dt><code>treated</code></dt><dd><p>treated variable indicator</p>
</dd>
<dt><code>age</code></dt><dd><p>age</p>
</dd>
<dt><code>education</code></dt><dd><p>years of education</p>
</dd>
<dt><code>black</code></dt><dd><p>race indicator variable</p>
</dd>
<dt><code>married</code></dt><dd><p>marital status indicator variable</p>
</dd>
<dt><code>nodegree</code></dt><dd><p>indicator variable of not possessing a degree</p>
</dd>
<dt><code>re74</code></dt><dd><p>real earnings in 1974</p>
</dd>
<dt><code>re75</code></dt><dd><p>real earnings in 1975</p>
</dd>
<dt><code>re78</code></dt><dd><p>real earnings in 1978 (post treatment outcome)</p>
</dd>
<dt><code>hispanic</code></dt><dd><p>ethnic indicator variable</p>
</dd>
<dt><code>u74</code></dt><dd><p>unemployment in 1974 indicator variable</p>
</dd>
<dt><code>u75</code></dt><dd><p>unemployment in 1975 indicator variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>see references</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>
<p>Dehejia, Wahba  (1999) <a href="https://doi.org/10.1080/01621459.1999.10473858">doi:10.1080/01621459.1999.10473858</a>
</p>

<hr>
<h2 id='imbalance'>Calculates several imbalance measures</h2><span id='topic+imbalance'></span>

<h3>Description</h3>

<p>Calculates several imbalance measures for the original
and matched data sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbalance(group, data, drop=NULL, breaks = NULL, weights, grouping = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbalance_+3A_group">group</code></td>
<td>
<p>the group variable</p>
</td></tr>
<tr><td><code id="imbalance_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="imbalance_+3A_drop">drop</code></td>
<td>
<p>a vector of variable names in the data frame to ignore</p>
</td></tr>
<tr><td><code id="imbalance_+3A_breaks">breaks</code></td>
<td>
<p>a list of vectors of cutpoints used to calculate the L1
measure. See Details.</p>
</td></tr>
<tr><td><code id="imbalance_+3A_weights">weights</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="imbalance_+3A_grouping">grouping</code></td>
<td>
<p>named list, each element of which is a list of
groupings for a single categorical variable. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates several imbalance measures.
For numeric variables, the difference in means (under the column
<code>statistic</code>), the difference in quantiles and the L1 measure is
calculated. For categorical variables the L1 measure and the
Chi-squared distance (under column <code>statistic</code>) is calculated.
Column <code>type</code> reports either <code>(diff)</code> or <code>(Chi2)</code> to
indicate the type of statistic being calculated.
</p>
<p>If <code>breaks</code> is not specified, the Scott automated bin calculation
is used (which coarsens less than Sturges, which used in
<code><a href="#topic+cem">cem</a></code>).  Please refer to <code><a href="#topic+cem">cem</a></code> help page. In
this case, breaks are used to calculate the L1 measure.
</p>
<p>This function also calculate the global L1 imbalance measure. 
If <code>breaks</code> is missing, the default rule to calculate cutpoints
is the Scott's rule. 
</p>
<p>The <code>grouping</code> option is a list where each element is itself a
list. For example, suppose for variable <code>quest1</code> you have the
following possible levels <code>"no answer", NA, "negative", "neutral",
"positive"</code> and you want to collect <code>("no answer", NA, "neutral")</code>
into a single group, then the <code>grouping</code> argument should contain
<code>list(quest1=list(c("no answer", NA, "neutral")))</code>. Or if you have
a discrete variable <code>elements</code> with values <code>1:10</code> and you want
to collect it into groups &ldquo;<code>1:3,NA</code>&rdquo;, &ldquo;<code>4</code>&rdquo;,
&ldquo;<code>5:9</code>&rdquo;, &ldquo;<code>10</code>&rdquo; you specify in <code>grouping</code> the
following list <code>list(elements=list(c(1:3,NA), 5:9))</code>.  Values not
defined in the <code>grouping</code> are left as they are. If <code>cutpoints</code>
and <code>groupings</code> are defined for the same variable, the
<code>groupings</code> take precedence and the corresponding cutpoints are set
to <code>NULL</code>.
</p>
<p>See <code><a href="#topic+L1.meas">L1.meas</a></code> help page for details.  
</p>


<h3>Value</h3>

<p>An object of class <code>imbalance</code> which is a list with the following
two elements
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>Table of imbalance measures</p>
</td></tr>
<tr><td><code>L1</code></td>
<td>
<p>The global L1 measure of imbalance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


data(LL)

todrop &lt;- c("treated","re78")
   
imbalance(LL$treated, LL, drop=todrop)

# cem match: automatic bin choice
mat &lt;- cem(treatment="treated", data=LL, drop="re78")

</code></pre>

<hr>
<h2 id='imbspace'>Diagnostic tool for CEM</h2><span id='topic+imbspace'></span>

<h3>Description</h3>

<p>Diagnostic tools for CEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbspace(obj, data, depth = 1, L1.breaks = NULL, 
plot = TRUE, fixed = NULL, minimal = 1, maximal = 6,
M=250, raw.profile=NULL, verbose=1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbspace_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>cem.match</code></p>
</td></tr>
<tr><td><code id="imbspace_+3A_data">data</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code id="imbspace_+3A_depth">depth</code></td>
<td>
<p>if 1, relaxes up to dropping one var, if 2 relaxes (up to
dropping) two vars, etc.</p>
</td></tr>
<tr><td><code id="imbspace_+3A_l1.breaks">L1.breaks</code></td>
<td>
<p>list of cutpoints for the calculation of the L1 measure.</p>
</td></tr>
<tr><td><code id="imbspace_+3A_plot">plot</code></td>
<td>
<p>plot the space of solutions?</p>
</td></tr>  
<tr><td><code id="imbspace_+3A_fixed">fixed</code></td>
<td>
<p>vector of variable names which will not be relaxed.</p>
</td></tr>  
<tr><td><code id="imbspace_+3A_minimal">minimal</code></td>
<td>
<p>the minimal number of intervals acceptable after
relaxation. Should be a nameed list of positive integers or if a number, this is
applied to all variables.</p>
</td></tr>
<tr><td><code id="imbspace_+3A_maximal">maximal</code></td>
<td>
<p>the maximal number of intervals acceptable after
relaxation. Should be a nameed list of positive integers or if a number, this is
applied to all variables.</p>
</td></tr>
<tr><td><code id="imbspace_+3A_m">M</code></td>
<td>
<p>number of possible random coarsening for the L1 measure</p>
</td></tr>
<tr><td><code id="imbspace_+3A_raw.profile">raw.profile</code></td>
<td>
<p>and object of class <code>L1profile</code>. If passed, the <code>L1.breaks</code> are
ignored.</p>
</td></tr>
<tr><td><code id="imbspace_+3A_verbose">verbose</code></td>
<td>
<p>integer, controls output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a diagnostic tool to help the user in the search of different choices
of coarsenings. The algorithm tries all possible combination of coarsenings into
intervals between <code>minimal</code> and <code>maximal</code> one variable at time, for
pairs, triplets, etc depending on the value of <code>depth</code>.
</p>
<p>Calling directly <code>plot</code> on the output of <code>imbspace</code> has the same
effect of calling directly <code><a href="#topic+imbspace.plot">imbspace.plot</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>val</code></td>
<td>
<p>an invisible object of class <code>imbalance.space</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+imbspace.plot">imbspace.plot</a></code> </p>

<hr>
<h2 id='imbspace.plot'>Plot of imbalance space diagnostic tool for CEM</h2><span id='topic+imbspace.plot'></span>

<h3>Description</h3>

<p>Plot of imbalance space diagnostic tool for CEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbspace.plot(obj, group="1", data, explore=TRUE, verbose=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbspace.plot_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>imbalance.space</code></p>
</td></tr>
<tr><td><code id="imbspace.plot_+3A_group">group</code></td>
<td>
<p>character string denoting group id. Defaults to <code>"1"</code>.</p>
</td></tr>
<tr><td><code id="imbspace.plot_+3A_data">data</code></td>
<td>
<p>data for running additional matching solutions.</p>
</td></tr>
<tr><td><code id="imbspace.plot_+3A_explore">explore</code></td>
<td>
<p>if <code>TRUE</code> the user can interact and find new solutions.</p>
</td></tr>
<tr><td><code id="imbspace.plot_+3A_verbose">verbose</code></td>
<td>
<p>integer, controls output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an interactive device a two panels plot is given. On the left panel
the user can select a CEM solution and the number of cutpoints
used in that matching solution is plotted as a parallel plot on the right
plot. On exit (right-click on the left panel), the function returns
all the cem solutions highlighted in the last selection of the user.
</p>
<p>For non-interactive devices, only the space of the solutions are plotted.
</p>
<p>This plot shows the tradeoff in matching as a function of
imbalance and sample size.
</p>
<p>The imbalance of the raw data is represented as a red plot and the initial
CEM solution as a green plot. All solutions below the green dot and left to
it are better than the user choice in terms of imbalance and number of
units matched.
</p>


<h3>Value</h3>

<table>
<tr><td><code>tab</code></td>
<td>
<p>an invisible object containing the selection of cem solutions and their
coarsenings.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+imbspace">imbspace</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(cem)

data(LL)
set.seed(123)
mat &lt;- cem("treated", LL, drop=c("re78","treated"), 
 cut=list(age=4, edu=4, re74=3, re75=3), keep.all=TRUE)
mat

imb.raw &lt;- L1.profile(LL$treated, LL[, mat$vars], M=250, plot=FALSE)

imbsp &lt;- imbspace(mat, LL,depth=2, raw.profile=imb.raw, 
 maximal=6, minimal=2, fixed=c("hispanic", "black", "married", 
 "nodegree","u74","u75"), plot=FALSE)

tmp &lt;- plot(imbsp,data=LL,explore=interactive())
tmp 

</code></pre>

<hr>
<h2 id='k2k'>Reduction to k2k Matching</h2><span id='topic+k2k'></span>

<h3>Description</h3>

<p>Reduces a CEM output to a k2k matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k2k(obj, data, method=NULL, mpower=2, verbose=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k2k_+3A_obj">obj</code></td>
<td>
<p>an object as output from <code>cem</code></p>
</td></tr>
<tr><td><code id="k2k_+3A_data">data</code></td>
<td>
<p>the original data.frame used by <code>cem</code></p>
</td></tr>
<tr><td><code id="k2k_+3A_method">method</code></td>
<td>
<p>distance method to use in <code>k2k</code> matching. See Details.</p>
</td></tr>
<tr><td><code id="k2k_+3A_mpower">mpower</code></td>
<td>
<p>power of the Minkowski distance. See Details.</p>
</td></tr>
<tr><td><code id="k2k_+3A_verbose">verbose</code></td>
<td>
<p>controls level of verbosity. Default=0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function transforms a typical <code>cem</code> matching solution
to a <code>k</code>-to-<code>k</code> match, with <code>k</code> variable along strata:
i.e., in each stratum generated by <code>cem</code>, the match is reduce to have
the same number of treated and control units.  (This option will delete
some data that matched well, and thus likely increase the  variance, but
it means that subsequent analyses do not require weights.)
</p>
<p>The user can choose a <code>method</code> (between '<code>euclidean</code>',
'<code>maximum</code>', '<code>manhattan</code>', '<code>canberra</code>', '<code>binary</code>'
and '<code>minkowski</code>') for nearest neighbor matching inside each
<code>cem</code> strata. By default <code>method</code> is set to '<code>NULL</code>',
which means random matching inside <code>cem</code> strata. For the Minkowski
distance the power can be specified via the argument <code>mpower</code>'.
For more information on <code>method != NULL</code>, refer to
<code><a href="stats.html#topic+dist">dist</a></code> help page.
</p>
<p>After <code>k2k</code> the weights of each matched observation are set to unity. Please notice that option <code>keep.all=TRUE</code> must be used in <code>cem</code> calls
otherwise <code>k2k</code> will not work.
</p>


<h3>Value</h3>

<table>
<tr><td><code>obj</code></td>
<td>
<p>an object of class <code>cem.match</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LL)
set.seed(123)
# cem match: automatic bin choice
mat &lt;- cem(treatment="treated", data=LL, drop="re78", keep.all=TRUE)
mat
mat$k2k

# ATT estimate
att(mat, re78 ~ treated, data=LL)


# transform the match into k2k
mat2 &lt;- k2k(mat, LL, "euclidean", 1)
mat2
mat2$k2k

# ATT estimate after k2k
att(mat2, re78 ~ treated, data=LL)
</code></pre>

<hr>
<h2 id='L1.meas'>Evaluates L1 distance between multidimensional histograms</h2><span id='topic+L1.meas'></span>

<h3>Description</h3>

<p>Evaluates L1 distance between multidimensional histograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1.meas(group, data, drop=NULL, breaks = NULL, weights, grouping = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L1.meas_+3A_group">group</code></td>
<td>
<p>the group variable</p>
</td></tr>
<tr><td><code id="L1.meas_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="L1.meas_+3A_drop">drop</code></td>
<td>
<p>a vector of variable names in the data frame to ignore</p>
</td></tr>
<tr><td><code id="L1.meas_+3A_breaks">breaks</code></td>
<td>
<p>a list of vectors of cutpoints; if not specified,
automatic choice will be made</p>
</td></tr>
<tr><td><code id="L1.meas_+3A_weights">weights</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="L1.meas_+3A_grouping">grouping</code></td>
<td>
<p>named list, each element of which is a list of
groupings for a single categorical variable. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the L1 distance on the k-dimensional histogram
in order to measure the level of imbalance in a matching solution.
</p>
<p>If <code>breaks</code> is not specified, the Scott automated bin calculation
is used (which coarsens less than Sturges, which used in
<code><a href="#topic+cem">cem</a></code>).  Please refer to <code><a href="#topic+cem">cem</a></code> help page. In
this case, breaks are used to calculate the L1 measure.
</p>
<p>When choosing <code>breaks</code> for L1, a very fine coarsening (many cut
points) produces values of L1 close to 1.  A very mild coarsening (very
fex cutpoints), is not able to discriminate, i.e. L1 close to 0
(particularly true when the number of observations is small with respect
to the number of continuous variables).  
</p>
<p>The <code>grouping</code> option is a list where each element is itself a
list. For example, suppose for variable <code>quest1</code> you have the
following possible levels <code>"no answer", NA, "negative", "neutral",
"positive"</code> and you want to collect <code>("no answer", NA, "neutral")</code>
into a single group, then the <code>grouping</code> argument should contain
<code>list(quest1=list(c("no answer", NA, "neutral")))</code>. Or if you have
a discrete variable <code>elements</code> with values <code>1:10</code> and you want
to collect it into groups &ldquo;<code>1:3,NA</code>&rdquo;, &ldquo;<code>4</code>&rdquo;,
&ldquo;<code>5:9</code>&rdquo;, &ldquo;<code>10</code>&rdquo; you specify in <code>grouping</code> the
following list <code>list(elements=list(c(1:3,NA), 5:9))</code>.  Values not
defined in the <code>grouping</code> are left as they are. If <code>cutpoints</code>
and <code>groupings</code> are defined for the same variable, the
<code>groupings</code> take precedence and the corresponding cutpoints are set
to <code>NULL</code>.
</p>
<p>The <code><a href="#topic+L1.profile">L1.profile</a></code> function
shows how to compare matching solutions for any level of (i.e., without
regard to) coarsening.
</p>
<p>This code also calculate the Local Common Support (LCS) measure, which is
the proportion of non empty k-dimensional cells of the histogram which
contain at least one observation per group.
</p>


<h3>Value</h3>

<p>An object of class <code>L1.meas</code> which is a list with the following fields
</p>
<table>
<tr><td><code>L1</code></td>
<td>
<p>The numerical value of the L1 measure</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>A list of cutpoints used to calculate the L1 measure</p>
</td></tr>
<tr><td><code>LCS</code></td>
<td>
<p>The numerical value of the Local Common Support proportion</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LL)
set.seed(123)
L1.meas(LL$treated,LL, drop=c("treated","re78"))
</code></pre>

<hr>
<h2 id='L1.profile'>Calculates L1 distance for different coarsenings</h2><span id='topic+L1.profile'></span>

<h3>Description</h3>

<p>Calculates L1 distance for different coarsenings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1.profile(group, data, drop = NULL, min.cut = 2, max.cut = 12, 
weights, plot = TRUE, add = FALSE, col = "red", 
lty = 1, M=100, useCP=NULL, grouping=NULL, progress=TRUE,
verbose=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L1.profile_+3A_group">group</code></td>
<td>
<p>the group variable</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_drop">drop</code></td>
<td>
<p>a vector of variable names in the data frame to ignore</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_min.cut">min.cut</code></td>
<td>
<p>minimum number of cut points per variable</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_max.cut">max.cut</code></td>
<td>
<p>maximum number of cut points per variable</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_weights">weights</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_usecp">useCP</code></td>
<td>
<p>a list which elements is a list of cutpoints, usually passed from
a previous instance of <code>L1.profile</code>. If not <code>NULL</code> these coarsenings
are used instead of generating them randomly.</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_m">M</code></td>
<td>
<p>number of random coarsenings</p>
</td></tr> 
<tr><td><code id="L1.profile_+3A_plot">plot</code></td>
<td>
<p>plot a graph?</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_add">add</code></td>
<td>
<p>add graph to an existing plot? Makes sense only if <code>plot</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="L1.profile_+3A_col">col</code></td>
<td>
<p>draw in specified color</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_lty">lty</code></td>
<td>
<p>draw using specified lty</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_grouping">grouping</code></td>
<td>
<p>named list, each element of which is a list of
groupings for a single categorical variable. See Details.</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, feedback on progress is given. See Details.</p>
</td></tr>
<tr><td><code id="L1.profile_+3A_verbose">verbose</code></td>
<td>
<p>integer, controls level of output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The L1 measure depends on the coarsening chosen to calculate it, and
as such the comparison of different matching solutions may differ
depending on this somewhat arbitrary choice.  This function computes
L1 for a random  range of possible
coarsenings.  The point of this function is that if
one matching solution has a lower L1 than another, then it dominates
without regard to the choice of coarsening.  A graphic display conveys
the results succinctly.  (The logic is similar to
that for ROC curves used for classification algorithms.)
(This degree of coarsening should remain fixed for different CEM
runs.)
</p>
<p>For each variables the function generates a random number of cutpoints 
between <code>min.cut</code> and <code>max.cut</code> in which to cut  the support of each
variable. This procedure is repeated <code>M</code> times. The out is sorted in
increasing values of L1 just for graphical representation.
</p>
<p>Non numeric variables are  grouped randomly unless they appear specified in
the <code>grouping</code> argument.
</p>
<p>A <code>plot</code> method exists for the returned object.
</p>


<h3>Value</h3>

<p>An invisible object of class <code>L1profile</code> which contains a named list of coarsenings and 
values of the L1 measure for each coarsening.
</p>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
data(LL)
for(i in c(4:6,10:12))
 LL[[i]] &lt;- factor(LL[[i]])

imb0 &lt;- L1.profile(LL$treated,LL, drop=c("treated","re78"))

if(require(MatchIt)){
 m2 &lt;- matchit(treated ~ black + hispanic + married + nodegree + 
  u74 + u75 + education + age + re74 + re75, data=LL, 
  distance="logit")

 m3 &lt;- try(matchit(treated ~ black + hispanic + married + nodegree + 
  u74 + u75 + education + age + re74 + re75, data=LL, 
  distance="mahalanobis"), TRUE)
 
 L1.profile(LL$treated,LL, drop=c("treated","re78"), 
  weights=m2$w, add=TRUE, col="green", lty=2, useCP=imb0$CP)

 if(class(m3)[1]!="try-error"){
   L1.profile(LL$treated,LL, drop=c("treated","re78"), 
    weights=m3$w, add=TRUE, col="orange", lty=3, useCP=imb0$CP)
    }
}

m1 &lt;- cem("treated", LL, drop="re78")

L1.profile(LL$treated,LL, drop=c("treated","re78"), 
 weights=m1$w&gt;0, add=TRUE, col="blue", lty=4, useCP=imb0$CP)

legend(5, 0.9, legend=c("raw data", "pscore", "mahalanobis", "cem"), 
 lty=1:4, col=c("red", "green", "orange", "blue"))

</code></pre>

<hr>
<h2 id='LeLonde'>Modified Lalonde dataset</h2><span id='topic+LeLonde'></span>

<h3>Description</h3>

<p>This is a modified version of the Lalonde experimental dataset used for
explanatory reasons only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LL)</code></pre>


<h3>Format</h3>

<p>A data frame with 722 observations on the following 11 variables.
</p>

<dl>
<dt><code>treated</code></dt><dd><p>treatment variable indicator</p>
</dd>
<dt><code>age</code></dt><dd><p>age</p>
</dd>
<dt><code>education</code></dt><dd><p>years of education</p>
</dd>
<dt><code>black</code></dt><dd><p>race indicator variable</p>
</dd>
<dt><code>married</code></dt><dd><p>marital status indicator variable</p>
</dd>
<dt><code>nodegree</code></dt><dd><p>indicator variable for not possessing a degree</p>
</dd>
<dt><code>re74</code></dt><dd><p>real earnings in 1974</p>
</dd>
<dt><code>re75</code></dt><dd><p>real earnings in 1975</p>
</dd>
<dt><code>re78</code></dt><dd><p>real earnings in 1978 (post-treatment outcome)</p>
</dd>
<dt><code>hispanic</code></dt><dd><p>ethnic indicator variable</p>
</dd>
<dt><code>u74</code></dt><dd><p>unemployment in 1974 indicator variable</p>
</dd>
<dt><code>u75</code></dt><dd><p>unemployment in 1975 indicator variable</p>
</dd>
<dt><code>q1</code></dt><dd><p>answer to survey question n1</p>
</dd>	
</dl>



<h3>Details</h3>

<p>This data is a copy of the original Lalonde (1986) data set (see <code><a href="#topic+LL">LL</a></code>)
with 10% of missing data and an additional variable <code>q1</code> which is the
fictituous answer to the questionarie on &ldquo;Agreement on this job training program&rdquo;.
</p>


<h3>Source</h3>

<p>see references</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>
<p>Lalonde (1986) Evaluating the Econometric Evaluations of Training Programs with Experimental Data, <em>The American Economic Review</em>,
76(4), 604-620. 
</p>

<hr>
<h2 id='LL'>Lalonde dataset</h2><span id='topic+LL'></span>

<h3>Description</h3>

<p>Lalonde experimental dataset  (see cited reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LL)</code></pre>


<h3>Format</h3>

<p>A data frame with 722 observations on the following 10 variables.
</p>

<dl>
<dt><code>treated</code></dt><dd><p>treatment variable indicator</p>
</dd>
<dt><code>age</code></dt><dd><p>age</p>
</dd>
<dt><code>education</code></dt><dd><p>years of education</p>
</dd>
<dt><code>black</code></dt><dd><p>race indicator variable</p>
</dd>
<dt><code>married</code></dt><dd><p>marital status indicator variable</p>
</dd>
<dt><code>nodegree</code></dt><dd><p>indicator variable for not possessing a degree</p>
</dd>
<dt><code>re74</code></dt><dd><p>real earnings in 1974</p>
</dd>
<dt><code>re75</code></dt><dd><p>real earnings in 1975</p>
</dd>
<dt><code>re78</code></dt><dd><p>real earnings in 1978 (post-treatment outcome)</p>
</dd>
<dt><code>hispanic</code></dt><dd><p>ethnic indicator variable</p>
</dd>
<dt><code>u74</code></dt><dd><p>unemployment in 1974 indicator variable</p>
</dd>
<dt><code>u75</code></dt><dd><p>unemployment in 1975 indicator variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>see references</p>


<h3>References</h3>

<p>Lalonde (1986) Evaluating the Econometric Evaluations of Training Programs with Experimental Data, <em>The American Economic Review</em>,
76(4), 604-620. 
</p>

<hr>
<h2 id='LLvsPSID'>Lalonde treated units versus PSID control individuals</h2><span id='topic+LLvsPSID'></span>

<h3>Description</h3>

<p>The Lalonde set of treated units versus PSID (Panel Study of Income Dynamics) 
control individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LLvsPSID)</code></pre>


<h3>Format</h3>

<p>A data frame with 2787 observations on the following 10 variables.
</p>

<dl>
<dt><code>treated</code></dt><dd><p>treated variable indicator</p>
</dd>
<dt><code>age</code></dt><dd><p>age</p>
</dd>
<dt><code>education</code></dt><dd><p>years of education</p>
</dd>
<dt><code>black</code></dt><dd><p>race indicator variable</p>
</dd>
<dt><code>married</code></dt><dd><p>marital status indicator variable</p>
</dd>
<dt><code>nodegree</code></dt><dd><p>indicator variable of not possessing a degree</p>
</dd>
<dt><code>re74</code></dt><dd><p>real earnings in 1974</p>
</dd>
<dt><code>re75</code></dt><dd><p>real earnings in 1975</p>
</dd>
<dt><code>re78</code></dt><dd><p>real earnings in 1978 (post treatment outcome)</p>
</dd>
<dt><code>hispanic</code></dt><dd><p>ethnic indicator variable</p>
</dd>
<dt><code>u74</code></dt><dd><p>unemployment in 1974 indicator variable</p>
</dd>
<dt><code>u75</code></dt><dd><p>unemployment in 1975 indicator variable</p>
</dd>
</dl>



<h3>Details</h3>

<p>These two sets of treated and control units can be hardly matched.
</p>


<h3>Source</h3>

<p>see references</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>
<p>Lalonde (1986) Evaluating the Econometric Evaluations of Training Programs with Experimental Data, <em>The American Economic Review</em>,
76(4), 604-620. 
</p>

<hr>
<h2 id='pair'>Produces a paired sample out of a CEM match solution</h2><span id='topic+pair'></span>

<h3>Description</h3>

<p>Produces a paired sample out of a CEM match solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair(obj, data, method=NULL, mpower=2, verbose=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_+3A_obj">obj</code></td>
<td>
<p>an object as output from <code>cem</code></p>
</td></tr>
<tr><td><code id="pair_+3A_data">data</code></td>
<td>
<p>the original data.frame used by <code>cem</code></p>
</td></tr>
<tr><td><code id="pair_+3A_method">method</code></td>
<td>
<p>distance method to use in <code>k2k</code> matching. See Details.</p>
</td></tr>
<tr><td><code id="pair_+3A_mpower">mpower</code></td>
<td>
<p>power of the Minkowski distance. See Details.</p>
</td></tr>
<tr><td><code id="pair_+3A_verbose">verbose</code></td>
<td>
<p>controls level of verbosity. Default=0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a vector of paired matched units index.
</p>
<p>The user can choose a <code>method</code> (between '<code>euclidean</code>',
'<code>maximum</code>', '<code>manhattan</code>', '<code>canberra</code>', '<code>binary</code>'
and '<code>minkowski</code>') for nearest neighbor matching inside each
<code>cem</code> strata. By default <code>method</code> is set to '<code>NULL</code>',
which means random matching inside <code>cem</code> strata. For the Minkowski
distance the power can be specified via the argument <code>mpower</code>'.
For more information on <code>method != NULL</code>, refer to
<code><a href="stats.html#topic+dist">dist</a></code> help page.
</p>


<h3>Value</h3>

<table>
<tr><td><code>obj</code></td>
<td>
<p>a list with the fields <code>paired</code>, <code>full.paired</code>,
<code>reservoir</code> and <code>reservoir2</code>. The latter contain the indexes
of the unmatched units.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LL)
set.seed(123)
# cem match: automatic bin choice
mat &lt;- cem(data=LL, drop="re78")

# we want a set of paired units
psample &lt;- pair(mat, data=LL)
table(psample$paired)
psample$paired[1:100]

table(psample$full.paired)
psample$full.paired[1:10]



# cem match: automatic bin choice, we drop one row from the data set
mat1 &lt;- cem(data=LL[-1,], drop="re78")

# we want a set of paired units but we have an odd number of units in the data
psample &lt;- pair(mat1, data=LL[-1,])
table(psample$full.paired)

</code></pre>

<hr>
<h2 id='pscoreSelect'>Heuristic search of the best propensity score model specification</h2><span id='topic+pscoreSelect'></span>

<h3>Description</h3>

<p>Heuristic search of the best propensity score model specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pscoreSelect(formula, data, C.L=2*(pnorm(-1,0,1)), C.Q=0.1,verbose=1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pscoreSelect_+3A_data">data</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code id="pscoreSelect_+3A_formula">formula</code></td>
<td>
<p>formula type specification.</p>
</td></tr>
<tr><td><code id="pscoreSelect_+3A_c.l">C.L</code></td>
<td>
<p>if at leat one likelihood ration test statistic is greater
than <code>C.L</code>, then the covariate with higher likelihood ration test statistic
is added linearly to the model.</p>
</td></tr>
<tr><td><code id="pscoreSelect_+3A_c.q">C.Q</code></td>
<td>
<p>if the highest likelihood ratio statistic is greater than <code>C.Q</code>,
then interaction terms are included in the pscore model specification.</p>
</td></tr>
<tr><td><code id="pscoreSelect_+3A_verbose">verbose</code></td>
<td>
<p>integer, prints more info on screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a tool to help the user to the search for the best
propensity score model specification along the lines
suggested by Imbens and Rubin (forthcoming). The output of the function is
a model formula to be passed to <code>glm</code> or such, in order
to estimate the propensity score model and then perform 
propensity score matching.
</p>
<p>This tool is useful in combination with <code><a href="#topic+imbspace.plot">imbspace.plot</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>val</code></td>
<td>
<p>an invisible object of class <code>list</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard Nielsen</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>
<p>Imbens,  Rubin (2015)  <a href="https://doi.org/10.1017/CBO9781139025751">doi:10.1017/CBO9781139025751</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cemspace">cemspace</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
data(LL)
mod &lt;- pscoreSelect( treated ~ age + education + black+ married + nodegree + 
 re74 + re75 + hispanic + u74 + u75, data=LL)
print(mod)

</code></pre>

<hr>
<h2 id='relax.cem'>Diagnostic tool for CEM</h2><span id='topic+relax.cem'></span><span id='topic+relax.plot'></span>

<h3>Description</h3>

<p>Diagnostic tools for CEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relax.cem(obj, data, depth=1, verbose = 1, L1.breaks=NULL, plot=TRUE, 
 fixed=NULL, shifts=NULL, minimal=NULL, use.coarsened=TRUE, 
 eval.imbalance=TRUE, use.weights=FALSE, ...)
relax.plot(tab, group="1", max.terms=50, perc=.5, unique=FALSE, colors=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relax.cem_+3A_obj">obj</code></td>
<td>
<p>an object of class cem.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_data">data</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of verbosity.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_l1.breaks">L1.breaks</code></td>
<td>
<p>list of cutpoints for the calculation of the L1 measure.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_plot">plot</code></td>
<td>
<p>plot the solutions?</p>
</td></tr>  
<tr><td><code id="relax.cem_+3A_tab">tab</code></td>
<td>
<p>the output table from <code>relax.cem</code>.</p>
</td></tr>  
<tr><td><code id="relax.cem_+3A_fixed">fixed</code></td>
<td>
<p>vector of variable names which will not be relaxed.</p>
</td></tr>  
<tr><td><code id="relax.cem_+3A_max.terms">max.terms</code></td>
<td>
<p>plot only the last best results of <code>relax.cem</code>.</p>
</td></tr>  
<tr><td><code id="relax.cem_+3A_shifts">shifts</code></td>
<td>
<p>a vector of proportions of shifts.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_minimal">minimal</code></td>
<td>
<p>the minimal number of intervals acceptable after
relaxation. Should be a nameed list of positive integers.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_group">group</code></td>
<td>
<p>character string denoting group id. Defaults to <code>"1"</code>.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_perc">perc</code></td>
<td>
<p>only plot if percentage of matched units is greater than <code>perc</code>.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_unique">unique</code></td>
<td>
<p>only plot different solutions (in terms of matched units).</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_depth">depth</code></td>
<td>
<p>if 1, relaxes up to dropping one var, if 2 relaxes (up to
dropping) two vars, etc.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_use.coarsened">use.coarsened</code></td>
<td>
<p>used coarsened values for continuous variables.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_colors">colors</code></td>
<td>
<p>If <code>TRUE</code> each variable is plotted in a different colour.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_eval.imbalance">eval.imbalance</code></td>
<td>
<p>If <code>TRUE</code> L1 measure is evaluated at each iteration.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_use.weights">use.weights</code></td>
<td>
<p>If <code>TRUE</code> L1 measure is evaluated with weights calculated at each iteration. Slows down the execution.</p>
</td></tr>
<tr><td><code id="relax.cem_+3A_...">...</code></td>
<td>
<p>passed to the <code>relax.plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>relax.cem</code> starts from a cem solution (as given by
<code><a href="#topic+cem">cem</a></code>) which has to be run with argument <code>keep.all=TRUE</code>.
<code>relax.cem</code>  tries several relaxed coarsenings on the
variables. Coarsenings corresponds to dividing the support of each
variable into a decreasing number of intervals of the same length (even
if in the starting solution intervals are of different lengths).
Because CEM is MIB, the number of matched units increases as the
number of intervals decrease.  All variables are coarsened into
<code>k</code> intervals along a sequence which starts from the original
number of intervals and decreases to 10 intervals by 2,
then continues from 10 down to 1 intervals by 1. If
<code>minimal</code> is specified, variables are coarsened down to that
minimal value.
</p>
<p>To observe MIB property of CEM <code>use.coarsened</code> (default) should be
set to <code>TRUE</code>; otherwise the coarsening of the continuous variable
will be recalculated at each iteration and there is no guarantee of
monotonicity.
</p>
<p><code>relax.cem</code> outputs a list of tables. Each table is named
<code>Ggroup</code> where <code>group</code> is the id of the group.  Each
<code>Ggroup</code> table is ordered in increasing order of matched units of
group <code>group</code>.  Columns <code>PercGgroup</code> and <code>Ggroup</code> report
percentage and absolute number of matched units for each <code>group</code>.
Column <code>Relaxed</code> indicates which relaxation has been done, with
something like <code>"V1(4), V3(5)"</code>, which means &quot;variable <code>V1</code>
has been split in 4 intervals of the same length and variable <code>V3</code>
into five intervals&quot;.  Thus, the number of intervals is reported in
parenthases and if equal to 1 means that the corresponding variable is
excluded from affecting the match (i.e. all observations are assigned to
the same interval).
</p>
<p>If <code>shifts</code> is not null, each coarsening is shifted accordingly
(see <code><a href="#topic+shift.cem">shift.cem</a></code> for additional details).  In case of
shifting &ldquo;<code>S:</code>&rdquo; appears in the labels.  
</p>
<p>The <code>relax.plot</code>, plot all the different relaxation in increasing
order of number of treated units matched. For each coarsening it also reports
the value of the L1 measure. The table generated by <code>relax.cem</code> may 
contain many entries. By default, only a portion of best coarsenings
are plotted (option <code>max.terms</code>). In addition, the user can specify
to plot the corasening for which at least a certain percentage of
treated units have been matched (option <code>perc</code>, by default 50
In addition, of several different coarsenings which lead to the same number of treated 
units matched, the user can specify to plot only one of them using the
option <code>unique</code> = <code>TRUE</code> (default).
</p>
<p>If <code>L1.breaks</code> are <code>NULL</code> they are taken from the <code>cem</code> object 
if available or calculated atumatically as in <code>cem</code>.
</p>
<p>Calling directly <code>plot</code> on the output of <code>cem.relax</code> has the same
effect of calling directly <code>relax.plot</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>tab</code></td>
<td>
<p>an invisible object containing the tabs and the L1breaks
used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cem">cem</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LL)
set.seed(123)
mat &lt;- cem(treatment="treated",data=LL, drop="re78", keep.all=TRUE)
mat
tab &lt;- relax.cem(mat, LL, depth=1, plot=FALSE)

relax.plot(tab, group="1")
plot(tab, group="1")
relax.plot(tab, group="1", unique=TRUE)
relax.plot(tab, group="1", perc=0.6)
relax.plot(tab, group="1", perc=0.6,unique=TRUE)


tab1 &lt;- relax.cem(mat, LL, depth=1, minimal=list(re74=6, age=3, education=3, re75=5))
tab2 &lt;- relax.cem(mat, LL, depth=1, minimal=list(re74=6, age=3,
                  education=3, re75=5), shifts=0.01)
tab3 &lt;- relax.cem(mat, LL, depth=1, minimal=list(age=3, education=3),
                  fixed=c("re74","re75"))
tab4 &lt;- relax.cem(mat, LL, depth=2, minimal=list(age=4,
                   education=3,re75=6),plot=FALSE, fixed="re74")
relax.plot(tab4)
relax.plot(tab4, unique=TRUE)
relax.plot(tab4, perc=0.7) 

</code></pre>

<hr>
<h2 id='search.match'>Heuristic search of match solutions</h2><span id='topic+search.match'></span>

<h3>Description</h3>

<p>Heuristic search of match solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.match(data, treatment, vars, depth=3, min.vars =1, group=1, useCP,verbose=1, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.match_+3A_data">data</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code id="search.match_+3A_treatment">treatment</code></td>
<td>
<p>name of the treatment variable.</p>
</td></tr>
<tr><td><code id="search.match_+3A_depth">depth</code></td>
<td>
<p>level of interaction and squares. See Details.</p>
</td></tr>
<tr><td><code id="search.match_+3A_vars">vars</code></td>
<td>
<p>vector of variables' names to match on.</p>
</td></tr>
<tr><td><code id="search.match_+3A_min.vars">min.vars</code></td>
<td>
<p>minimum number of variables to consider in the model.</p>
</td></tr>
<tr><td><code id="search.match_+3A_group">group</code></td>
<td>
<p>the indentifier of the treated group, usually 1 or the level of the fact variable <code>treatment</code>.</p>
</td></tr>
<tr><td><code id="search.match_+3A_usecp">useCP</code></td>
<td>
<p>the cutpoints for the calculation of the L1 measure</p>
</td></tr>
<tr><td><code id="search.match_+3A_verbose">verbose</code></td>
<td>
<p>integer, prints more info on screen.</p>
</td></tr>
<tr><td><code id="search.match_+3A_...">...</code></td>
<td>
<p>passed to <code>matchit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a tool to help the user in the search of different choices models for matching.
For example, for the search of different propensity score models.
The tool tries all submodels of <code>k</code> variables starting from one covariate up to the full model. Then adds
interactions to the full model trying all pairs, triplets etc according to the parameter <code>depth</code>.
Then, for continuous variables only, adds squared terms to the full model.
</p>
<p>This tool is useful in combination with <code><a href="#topic+imbspace.plot">imbspace.plot</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>val</code></td>
<td>
<p>an invisible object of class <code>list</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+imbspace.plot">imbspace.plot</a></code> </p>

<hr>
<h2 id='shift.cem'>Diagnostic tool for CEM</h2><span id='topic+shift.cem'></span>

<h3>Description</h3>

<p>Diagnostic tools for CEM. Applies leftward and rightward shifts of the cutpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.cem(obj, data, shifts=NULL, verbose=1, plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.cem_+3A_obj">obj</code></td>
<td>
<p>and object of class cem</p>
</td></tr>
<tr><td><code id="shift.cem_+3A_data">data</code></td>
<td>
<p>the original data</p>
</td></tr>
<tr><td><code id="shift.cem_+3A_shifts">shifts</code></td>
<td>
<p>a vector of proportions of shifts</p>
</td></tr>
<tr><td><code id="shift.cem_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of verbosity</p>
</td></tr>
<tr><td><code id="shift.cem_+3A_plot">plot</code></td>
<td>
<p>whether to plot a graphic representation of the search</p>
</td></tr> </table>


<h3>Details</h3>

<p> For each variable, shift all the cutpoints left and right by
<code>shifts</code> times the smallest epsilon of the
coarsening. Shifting to the right produces a new cell on the left;
shift to the left, adds a new cell to the coarsening on the right.
Only positive proportions should be used; the algorithm
will produce shifting on the left or on the right.  The best shifting
of the original cem match is produced as output, where best is defined
in terms of the maximal total number of matched units <code>mT+mC</code> (see below).  
</p>
<p>By default, the function returns minimal information about the execution
of the algorithm. By setting a value greater than 0 in option <code>verbose</code>
more feedback on the process is returned.
</p>
<p>Option <code>plot</code> = <code>TRUE</code> plots the number of treated units 
matched <code>mT</code>, the number of control units 
matched <code>mC</code>, and the sum <code>mT+mC</code>, as a function of the shifts.
</p>


<h3>Value</h3>

<table>
<tr><td><code>tab</code></td>
<td>
<p>an invisible object containing a new cem object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>References</h3>

<p>Iacus, King, Porro (2011) <a href="https://doi.org/10.1198/jasa.2011.tm09599">doi:10.1198/jasa.2011.tm09599</a>
</p>
<p>Iacus, King, Porro (2012) <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>
<p>Iacus, King, Porro (2019) <a href="https://doi.org/10.1017/pan.2018.29">doi:10.1017/pan.2018.29</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cem">cem</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LL)
set.seed(123)
m74 &lt;- max(LL$re74, na.rm=TRUE)
s74 &lt;- seq(0,m74,by=sd(LL$re74))
l74 &lt;- length(s74)
if(max(s74) &lt; m74) s74 &lt;- c(s74, m74)

m75 &lt;- max(LL$re75, na.rm=TRUE)
s75 &lt;- seq(0,m75,by=sd(LL$re75))
l75 &lt;- length(s75)
if(max(s75) &lt; m75) s75 &lt;- c(s75, m75)

mybr = list(re74=s74, 
 re75 = s75,
 age = hist(LL$age,plot=FALSE)$breaks,
 education = hist(LL$education,plot=FALSE)$breaks)

mat &lt;- cem(treatment="treated",data=LL, drop="re78",cut=mybr)
mat

shift.cem(mat, data=LL, shifts=seq(0.01, 0.5, length=10), verb=1)

</code></pre>

<hr>
<h2 id='spacegraph'>Randomly compute many different matching solutions</h2><span id='topic+spacegraph'></span>

<h3>Description</h3>

<p>Randomly compute many different matching solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spacegraph(treatment=NULL, data = NULL, 
     R=list("cem"=50,"psm"=0,"mdm"=0,"matchit"=0),
     grouping = NULL, drop=NULL, 
     L1.breaks = NULL, L1.grouping=NULL, fixed = NULL, 
     minimal = 1, maximal = 15, M=100, 
     raw.profile=NULL, keep.weights=FALSE, progress=TRUE,
     rgrouping=FALSE, groups=NULL, psmpoly=1, mdmpoly=1, 
     other.matches=NULL, heuristic=FALSE, linear.pscore=FALSE,
     verbose=1) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spacegraph_+3A_treatment">treatment</code></td>
<td>
<p>character, name of the treatment variable</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_drop">drop</code></td>
<td>
<p>a vector of variable names in the data frame to ignore 
during matching.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_r">R</code></td>
<td>
<p>a named list that gives the number of of possible random solutions for each matching method.  Allowed methods are <code>cem</code>, <code>psm</code>, <code>mdm</code>, and <code>matchit</code>.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_grouping">grouping</code></td>
<td>
<p>named list, each element of which is a list of
groupings for a single categorical variable. For more details see <code><a href="#topic+cem">cem</a></code>.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_l1.breaks">L1.breaks</code></td>
<td>
<p>list of cutpoints for the calculation of the L1 measure.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_l1.grouping">L1.grouping</code></td>
<td>
<p>as <code>grouping</code> but only needed in the calculation
of the L1 measure not in matching.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_fixed">fixed</code></td>
<td>
<p>vector of variable names which will not be relaxed.</p>
</td></tr> 
<tr><td><code id="spacegraph_+3A_minimal">minimal</code></td>
<td>
<p>the minimal number of intervals acceptable after
relaxation. Should be a named list of positive integers or if a number, this is
applied to all variables.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_maximal">maximal</code></td>
<td>
<p>the maximal number of intervals acceptable after
relaxation. Should be a named list of positive integers or if a number, this is
applied to all variables.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_m">M</code></td>
<td>
<p>number of possible random coarsening for the L1 measure</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_raw.profile">raw.profile</code></td>
<td>
<p>an object of class <code>L1profile</code>. If passed, the <code>L1.breaks</code> are
ignored and set to median cutpoints of L1 profile.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_keep.weights">keep.weights</code></td>
<td>
<p>if <code>TRUE</code>, for each matching solutions the CEM-weights are stored.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_rgrouping">rgrouping</code></td>
<td>
<p>Boolean, specifies whether levels of categorical variables should be randomly grouped together by CEM.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_groups">groups</code></td>
<td>
<p>named list, each element of which is a list of
allowable groupings for a single categorical variable.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_psmpoly">psmpoly</code></td>
<td>
<p>numeric, specifying the order of polynomials to include in the propensity score models.  At the moment, only <code>psmpoly=1</code> is available and other values will throw warnings.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_mdmpoly">mdmpoly</code></td>
<td>
<p>numeric, specifying the order of polynomials to include in Mahalanobis matching.  At the moment, only <code>mdmpoly=1</code> is available and other values will throw warnings.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_other.matches">other.matches</code></td>
<td>
<p>This argument allows plotting of user-specified matching solutions.  The solutions must be supplied in a specific format: as a list of data frames, where each data frame contains the observation IDs, observations weights, and the method.  These must be provided in three columns of the data frame, with names (exactly) &quot;id&quot;, &quot;weight&quot;, &quot;method&quot;.  See the example.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_heuristic">heuristic</code></td>
<td>
<p>Boolean, if TRUE spacegraph uses a heuristic method to randomly select covariates for MDM and PSM rather than sampling from all possible combinations of covariates.  The heuristic tends to select most of the main effects and a small number of interactions.  This method is automatically applied with large numbers of covariates.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_progress">progress</code></td>
<td>
<p>show progress bars.</p>
</td></tr>
<tr><td><code id="spacegraph_+3A_linear.pscore">linear.pscore</code></td>
<td>
<p>does <code>linear.pscore</code></p>
</td></tr>
<tr><td><code id="spacegraph_+3A_verbose">verbose</code></td>
<td>
<p>integer, controls the level of output.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Spacegraph is a tool to help the user to the search for optimal matching solutions by generating many matching solutions from a variety of matching algorithms (currently CEM, Mahalanobis distance matching, and propensity score matching are supported).  The resulting object can be plotted with <code>plot()</code> to show where each solution falls along the bais-variance tradeoff.
</p>
<p>The <code>spacegraph</code> function currently calculates two measures of balance for each solution: the L1 metric (see <code><a href="#topic+L1.meas">L1.meas</a></code> ) and the difference in means of the covariates.  Typically, analyists look at the difference in means seperately for each variable, but this can't be plotted on a two-dimensional graph.  We summarize the difference in means by calculating the average difference in means for all of the covariates.  Specifically, we calculate the difference in means for each variable as mean(treated)-mean(control)/sd(treated) and then average across all covariates.
</p>


<h3>Value</h3>

<table>
<tr><td><code>val</code></td>
<td>
<p>an object of class <code>spacegraph</code> that can be used directly with <code>plot()</code> to produce a spacegraph.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard Nielsen, Stefano Iacus, Gary King, and Giuseppe Porro</p>


<h3>See Also</h3>

 <p><code><a href="#topic+combine.spacegraphs">combine.spacegraphs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LL)
set.seed(123)
sp &lt;- spacegraph("treated", LL, drop="re78", M=5,
                  R=list(cem=5,psm=5, mdm=5))

plot(sp)
## ABOUT THE PLOTTING TOOL:
## The circled solution is the current selection.
## Solutions that are strictly better are also circled.
## The gui provides the exact call to re-run the selected matching solution.
## The call can also be edited, re-run by clicking the button, and 
## automatically added to the existing spacegraph.
## CEM solutions can also be adjusted variable by variable and re-run.


## Some plotting parameters can be changed
plot(sp, main="Comparison of Matching Methods",
  ylab="L1", xlim=c(300,50), ylim=c(0,.7))

## You can specify whether the x-axis shows treated units, 
## control units, or all units using the argument N, which 
## can take the values "treated", "control", or "all".
## Default is "treated".

plot(sp, N="all")

## You can specify how the x-axis is scaled.  Setting scale.var=T
## gives you the scaling as 1/sqrt(n).  Setting scale.var=F gives
## scales it linearly.  Default is scale.var=TRUE.

plot(sp, scale.var=FALSE)

## You can also specify which measure of balance to use
## by specifying the argument "balance.metric" as
## "L1", "mdiff" (Avg. standardized difference in means), 
## or "mdisc" (Average Malanobis Discrepancy).  Default is "L1".

plot(sp, balance.metric="mdiff")
plot(sp, balance.metric="mdisc")


## Matching solutions from other methods can be included in
## a spacegraph by using the argument "other.matches".
## First, Run a matching method.  Here, propensity scores from MatchIt.
library(MatchIt)
m.out &lt;- matchit(formula=treated ~ education+age, data=LL, method = "nearest")

## Put the required information into a list of data frames.
## Note, there are many ways to do this.
mymatches &lt;- list(data.frame(names(m.out$w)))
names(mymatches[[1]])[1] &lt;- "id"
mymatches[[1]]$weight &lt;- m.out$w
mymatches[[1]]$method &lt;- "matchit psm"

sp &lt;- spacegraph("treated", LL, drop="re78", M=5,
 R=list(cem=5,psm=5, mdm=5), other.matches=mymatches)
plot(sp)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
