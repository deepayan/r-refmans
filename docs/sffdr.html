<!DOCTYPE html><html lang="en"><head><title>Help for package sffdr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sffdr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bmi'><p>Subset of p-values from the UK Biobank analysis</p></a></li>
<li><a href='#ffinemap'><p>Functional fine mapping</p></a></li>
<li><a href='#fpi0est'><p>Estimate the functional proportion of null tests</p></a></li>
<li><a href='#fpvalues'><p>Functional p-values</p></a></li>
<li><a href='#kernelEstimator'><p>Estimate a density on the unit interval or unit square via</p>
local regression</a></li>
<li><a href='#pi0_model'><p>Formulates the model for the proportion of null tests</p></a></li>
<li><a href='#plot.sffdr'><p>Plotting function for sffdr object</p></a></li>
<li><a href='#sffdr'><p>Estimate the functional p-values, q-values, and local false discovery rates given a set of p-values and</p>
informative variables</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Surrogate Functional False Discovery Rates for Genome-Wide
Association Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Bass &lt;ab3105@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Pleiotropy-informed significance analysis of genome-wide association studies (GWAS) with surrogate functional false discovery rates (sfFDR). The sfFDR framework adapts the fFDR to leverage informative data from multiple sets of GWAS summary statistics to increase power in study while accommodating for linkage disequilibrium. sfFDR provides estimates of key FDR quantities in a significance analysis such as the functional local FDR and q-value, and uses these estimates to derive a functional p-value for type I error rate control and a functional local Bayes' factor for post-GWAS analyses (e.g., fine mapping and colocalization). The sfFDR framework is described in Bass and Wallace (2024) &lt;<a href="https://doi.org/10.1101%2F2024.09.24.24314276">doi:10.1101/2024.09.24.24314276</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ajbass/sffdr">https://github.com/ajbass/sffdr</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>locfit, splines, dplyr, ggplot2 (&ge; 3.5.1), patchwork (&ge;
1.3.0), gam, qvalue, tibble, tidyr, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-29 14:22:57 UTC; andrewbass</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Bass [aut, cre],
  Chris Wallace [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-02 12:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='bmi'>Subset of p-values from the UK Biobank analysis</h2><span id='topic+bmi'></span><span id='topic+sumstats'></span>

<h3>Description</h3>

<p>The summary level data is a subset of independent SNPs
from the UK Biobank where we performed a GWAS of body mass index (BMI), body fat percentage (BFP),
cholesterol, and triglycerides. Note that BFP, cholesterol and triglycerides
are conditioning traits and were calculated using a separate set of individuals
than BMI. See manuscript for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bmi)
</code></pre>


<h3>Value</h3>

<p>A list called <code>sumstats</code> containing:
</p>
<table role = "presentation">
<tr><td><code>bmi</code></td>
<td>
<p>Vector of 10,000 p-values for BMI.</p>
</td></tr>
<tr><td><code>bfp</code></td>
<td>
<p>Vector of 10,000 p-values for BFP.</p>
</td></tr>
<tr><td><code>cho</code></td>
<td>
<p>Vector of 10,000 p-values for cholesterol.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>Vector of 10,000 p-values for triglycerides.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sffdr">sffdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import data
data(bmi)

# separate main p-values and conditioning p-values
p &lt;- sumstats$bmi
z &lt;- as.matrix(sumstats[, -1])

# apply pi0_model to create model
knots &lt;- c(0.005, 0.01, 0.025, 0.05, 0.1)
fmod &lt;- pi0_model(z, knots = knots)

# import data
data(bmi)

# separate main p-values and conditioning p-values
p &lt;- sumstats$bmi
z &lt;- as.matrix(sumstats[, -1])

# apply pi0_model to create model
knots &lt;- c(0.005, 0.01, 0.025, 0.05, 0.1)
fmod &lt;- pi0_model(z, knots = knots)

# estimate functional pi0
fpi0_out &lt;- fpi0est(p, z = fmod$zt, pi0_model = fmod$fmod)
fpi0 &lt;- fpi0_out$fpi0

# apply sffdr
# Note all tests are independent see 'indep_snps' argument
# The very small p-values, set epsilon to min of p
sffdr_out &lt;- sffdr(p, fpi0, epsilon = min(p))

# Plot significance results
plot(sffdr_out, rng = c(0, 5e-4))

# Functional P-values, Q-values, and local FDR
fp &lt;- sffdr_out$fpvalues
fq &lt;- sffdr_out$fqvalues
flfdr &lt;- sffdr_out$flfdr

</code></pre>

<hr>
<h2 id='ffinemap'>Functional fine mapping</h2><span id='topic+ffinemap'></span>

<h3>Description</h3>

<p>Perform functional fine mapping with a set of functional local FDRs in a region of interest (assuming a single causal variant).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffinemap(flfdr, fpi0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ffinemap_+3A_flfdr">flfdr</code></td>
<td>
<p>A vector of functional local FDRs of a region of interest</p>
</td></tr>
<tr><td><code id="ffinemap_+3A_fpi0">fpi0</code></td>
<td>
<p>An estimate of the function proportion of null tests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of object type &quot;sffdr&quot; containing:
</p>
<table role = "presentation">
<tr><td><code>BF</code></td>
<td>
<p>The functional local Bayes' factors.</p>
</td></tr>
<tr><td><code>PP</code></td>
<td>
<p>Posterior probability of a SNP being causal.</p>
</td></tr>
</table>

<hr>
<h2 id='fpi0est'>Estimate the functional proportion of null tests</h2><span id='topic+fpi0est'></span>

<h3>Description</h3>

<p>he function <code><a href="#topic+fpi0est">fpi0est</a></code> estimates the functional proportion of null tests given
a set of informative variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpi0est(
  p,
  z,
  pi0_model,
  indep_snps = NULL,
  lambda = seq(0.05, 0.9, 0.05),
  method = "gam",
  maxit = 1000,
  pi0.method.control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fpi0est_+3A_p">p</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_z">z</code></td>
<td>
<p>A vector of informative variables</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_pi0_model">pi0_model</code></td>
<td>
<p>Model formula corresponding to <code>z</code> for the functional proportion of truly null tests.</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_indep_snps">indep_snps</code></td>
<td>
<p>A boolean vector (same size as p) specifying the set of independent tests. Default is NULL and all tests are treated independently.</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_lambda">lambda</code></td>
<td>
<p>A vector of values between [0,1] to estimate the functional proportion of truly null tests.</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_method">method</code></td>
<td>
<p>Either the &quot;gam&quot; (generalized additive model) or &quot;glm&quot; (generalized linear models) approach. Default is &quot;gam&quot;.</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations for &quot;glm&quot; approach. Default is 1000.</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_pi0.method.control">pi0.method.control</code></td>
<td>
<p>A user specified set of parameters for convergence for either &quot;gam&quot; or &quot;glm&quot;. Default is NULL. See <code><a href="gam.html#topic+gam.control">gam.control</a></code> or <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="fpi0est_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="gam.html#topic+gam">gam</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code extends the function from the fFDR package to handle
multiple informative variables and linkage disequilibrium.
</p>


<h3>Value</h3>

<p>A list of object type &quot;fpi0&quot; containing:
</p>
<table role = "presentation">
<tr><td><code>fpi0</code></td>
<td>
<p>A table containing the functional proportion of truly null tests.</p>
</td></tr>
<tr><td><code>tableLambda</code></td>
<td>
<p>Functional proportion of null tests at the lambda values</p>
</td></tr>
<tr><td><code>MISE</code></td>
<td>
<p>MISE values.</p>
</td></tr>
<tr><td><code>lambda.hat</code></td>
<td>
<p>The chosen lambda value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew J. Bass, David G. Robinson (author of original function)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sffdr">sffdr</a></code>, <code><a href="#topic+plot.sffdr">plot.sffdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import data
data(bmi)

# separate main p-values and conditioning p-values
p &lt;- sumstats$bmi
z &lt;- as.matrix(sumstats[, -1])

# apply pi0_model to create model
knots &lt;- c(0.005, 0.01, 0.025, 0.05, 0.1)
fmod &lt;- pi0_model(z, knots = knots)

# Estimate functional pi0
fpi0_out &lt;- fpi0est(p, z = fmod$zt, pi0_model = fmod$fmod)
fpi0 &lt;- fpi0_out$fpi0

# See relationship of BFP/cholesterol/triglycerides and fpi0
plot(fmod$zt$bfp, fpi0)
plot(fmod$zt$cholesterol, fpi0)
plot(fmod$zt$triglycerides, fpi0)

</code></pre>

<hr>
<h2 id='fpvalues'>Functional p-values</h2><span id='topic+fpvalues'></span>

<h3>Description</h3>

<p>Calculate functional p-values from functional local FDRs. Internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpvalues(lfdr, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fpvalues_+3A_lfdr">lfdr</code></td>
<td>
<p>A vector of functional local FDRs of a region</p>
</td></tr>
<tr><td><code id="fpvalues_+3A_p">p</code></td>
<td>
<p>A vector of p-values. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of object type &quot;sffdr&quot; containing:
</p>
<table role = "presentation">
<tr><td><code>fp</code></td>
<td>
<p>Functional p-values.</p>
</td></tr>
<tr><td><code>fq</code></td>
<td>
<p>Functional q-values.</p>
</td></tr>
</table>

<hr>
<h2 id='kernelEstimator'>Estimate a density on the unit interval or unit square via
local regression</h2><span id='topic+kernelEstimator'></span>

<h3>Description</h3>

<p>This function is adapted from the fFDR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelEstimator(
  x,
  transformation = "probit",
  eval.points = x,
  subsample = 1e+07,
  epsilon = 1e-15,
  epsilon.max = 0.999,
  maxk = 10000,
  trim = 1e-15,
  nn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernelEstimator_+3A_x">x</code></td>
<td>
<p>Either a vector or a 2-column matrix</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_transformation">transformation</code></td>
<td>
<p>Either probit (default), complementary log-log, or
identity (not recommended)</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_eval.points">eval.points</code></td>
<td>
<p>Points at which to evaluate the estimate, default x</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_subsample">subsample</code></td>
<td>
<p>Number of points that are randomly subsampled for
computing the fit; useful for computational efficiency and for ensuring
the density estimation does not run out of memory. NULL means no the
fit is performed on all points</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_epsilon">epsilon</code></td>
<td>
<p>How close values are allowed to come to 0</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_epsilon.max">epsilon.max</code></td>
<td>
<p>How close values are allowed to come to 1</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_maxk">maxk</code></td>
<td>
<p>maxk argument passed to locfit</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_trim">trim</code></td>
<td>
<p>In one-dimensional fitting, the very edges often have high
variance. This parameter fixes the estimate on the intervals
(0, trim) and (1 - trim, 1).</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_nn">nn</code></td>
<td>
<p>nearest neighbor parameter</p>
</td></tr>
<tr><td><code id="kernelEstimator_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to lp in locfit, used only
if cv=FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide density estimates that are needed by <code>sffdr</code>
</p>


<h3>Value</h3>

<p>A data frame containing:
</p>
<table role = "presentation">
<tr><td><code>x1</code></td>
<td>
<p>The first column in eval.points.</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>
<p>The second column in eval.points. Note this is not returned for one dimensional density estimation.</p>
</td></tr>
<tr><td><code>s1</code></td>
<td>
<p>The transformed version of x1.</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>The transformed version of x2. Note this is not returned for one dimensional density estimation.</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>Density estimates on the original scale.</p>
</td></tr>
<tr><td><code>fs</code></td>
<td>
<p>Density estimates on the transformed scale.</p>
</td></tr>
</table>

<hr>
<h2 id='pi0_model'>Formulates the model for the proportion of null tests</h2><span id='topic+pi0_model'></span>

<h3>Description</h3>

<p><code>pi0_model</code> helps generate the model for the proportion of truly null tests.
For more details, refer to the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi0_model(z, indep_snps = NULL, basis.df = 3, knots = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pi0_model_+3A_z">z</code></td>
<td>
<p><code>matrix</code>: informative variables that impact the power of the
p-values (rows are tests and columns are different informative variables).
Currently, there must be no missing values.</p>
</td></tr>
<tr><td><code id="pi0_model_+3A_indep_snps">indep_snps</code></td>
<td>
<p><code>vector</code> Boolean indicating the set of independent SNPs</p>
</td></tr>
<tr><td><code id="pi0_model_+3A_basis.df">basis.df</code></td>
<td>
<p><code>integer</code>: the degrees of freedom for the natural cubic spline on each variable.
Default is 3 at equally space intervals.</p>
</td></tr>
<tr><td><code id="pi0_model_+3A_knots">knots</code></td>
<td>
<p><code>vector</code>: Specify the location of the knots in natural cubic spline. Note
that the knots are specified using quantiles by default. Default is NULL and uses basis.df at equally space intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We note that this function is specifically designed for informative p-values and other
complex models should be created outside this function.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ol>
<li><p> fmod: model formula
</p>
</li>
<li><p> zt: matrix of rank-transformed informative variables
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Andrew Bass
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sffdr">sffdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bmi)

p &lt;- sumstats$bmi
z &lt;- as.matrix(sumstats[, -1])

# For p-values, you want to specify the lower quantiles
fmod &lt;- pi0_model(z, knots = c(0.005, 0.01, 0.025, 0.05, 0.1))

</code></pre>

<hr>
<h2 id='plot.sffdr'>Plotting function for sffdr object</h2><span id='topic+plot.sffdr'></span><span id='topic+plot+2C'></span>

<h3>Description</h3>

<p>Graphical display of the sffdr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sffdr'
plot(x, rng = c(0, 5e-08), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sffdr_+3A_x">x</code></td>
<td>
<p>A sffdr object.</p>
</td></tr>
<tr><td><code id="plot.sffdr_+3A_rng">rng</code></td>
<td>
<p>Significance region to show. Optional.</p>
</td></tr>
<tr><td><code id="plot.sffdr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plotting function to summarize significance results from sffdr.
</p>


<h3>Author(s)</h3>

<p>Andrew J. Bass
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sffdr">sffdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import data
data(bmi)

# separate main p-values and conditioning p-values
p &lt;- sumstats$bmi
z &lt;- as.matrix(sumstats[, -1])

# apply pi0_model to create model
knots &lt;- c(0.005, 0.01, 0.025, 0.05, 0.1)
fmod &lt;- pi0_model(z, knots = knots)

# estimate functional pi0
fpi0_out &lt;- fpi0est(p, z = fmod$zt, pi0_model = fmod$fmod)
fpi0 &lt;- fpi0_out$fpi0

# apply sffdr
# Note all tests are independent see 'indep_snps' argument
# The very small p-values, set epsilon to min of p
sffdr_out &lt;- sffdr(p, fpi0, epsilon = min(p))

# Plot significance results
plot(sffdr_out, rng = c(0, 5e-4))

</code></pre>

<hr>
<h2 id='sffdr'>Estimate the functional p-values, q-values, and local false discovery rates given a set of p-values and
informative variables</h2><span id='topic+sffdr'></span>

<h3>Description</h3>

<p>Estimate the functional p-values, q-values, and local false discovery rates given a set of p-values and informative
variables. The functional p-values is mapping from the functional q-value (FDR-based measure) to a p-value for type I error rate control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sffdr(
  p.value,
  fpi0,
  surrogate = NULL,
  indep_snps = NULL,
  monotone.window = NULL,
  epsilon = 1e-15,
  nn = NULL,
  fp_ties = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sffdr_+3A_p.value">p.value</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_fpi0">fpi0</code></td>
<td>
<p>An estimate of the function proportion of null tests using the <code><a href="#topic+fpi0est">fpi0est</a></code> function.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_surrogate">surrogate</code></td>
<td>
<p>A surrogate variable that compresses more than one informative variables.
Default is NULL. If <code>fpi0</code> is specified and <code>surrogate</code> is NULL then <code>fpi0</code> is used as the surrogate variable.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_indep_snps">indep_snps</code></td>
<td>
<p>A boolean vector (same size as p) specifying the set of independent tests. Default is NULL and all tests are treated independently.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_monotone.window">monotone.window</code></td>
<td>
<p>Enforce monotonicity at specified step size. Default is NULL.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_epsilon">epsilon</code></td>
<td>
<p>A numerical value the truncation for the p-values during density estimation. Default is 1e-15. You may want to consider decreasing this value if there are a substantial number of small p-values.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_nn">nn</code></td>
<td>
<p>A numerical value specifying the nearest neighbor parameter in <code><a href="#topic+kernelEstimator">kernelEstimator</a></code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_fp_ties">fp_ties</code></td>
<td>
<p>A boolean specifying whether ties should be broken using the ordering of the p-values when calculating the fp-values. Only impacts the tests when the local FDR is tied. Default is TRUE.</p>
</td></tr>
<tr><td><code id="sffdr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+kernelEstimator">kernelEstimator</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+fpi0est">fpi0est</a></code> should be called externally to estimate the
functional proportion of null tests given the set of informative variables.
The surrogate functional FDR methodology builds from the functional FDR
methodology and implements some of the functions from the package.
</p>


<h3>Value</h3>

<p>A list of object type &quot;sffdr&quot; containing:
</p>
<table role = "presentation">
<tr><td><code>pvalues</code></td>
<td>
<p>A vector of the original p-values.</p>
</td></tr>
<tr><td><code>fpvalues</code></td>
<td>
<p>A vector of the estimated functional p-values.</p>
</td></tr>
<tr><td><code>fqvalues</code></td>
<td>
<p>A vector of the estimated functional q-values.</p>
</td></tr>
<tr><td><code>flfdr</code></td>
<td>
<p>A vector of the estimated functional local FDR values.</p>
</td></tr>
<tr><td><code>pi0</code></td>
<td>
<p>An vector of the original functional proportion of null tests.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>An object containing the kernel density estimates from <code>kernelEstimator</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew J. Bass
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpi0est">fpi0est</a></code>, <code><a href="#topic+plot.sffdr">plot.sffdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import data
data(bmi)

# separate main p-values and conditioning p-values
p &lt;- sumstats$bmi
z &lt;- as.matrix(sumstats[, -1])

# apply pi0_model to create model
knots &lt;- c(0.005, 0.01, 0.025, 0.05, 0.1)
fmod &lt;- pi0_model(z, knots = knots)

# estimate functional pi0
fpi0_out &lt;- fpi0est(p, z = fmod$zt, pi0_model = fmod$fmod)
fpi0 &lt;- fpi0_out$fpi0

# apply sffdr
# Note all tests are independent see 'indep_snps' argument
# The data has very small p-values, set epsilon to min of p
sffdr_out &lt;- sffdr(p, fpi0, epsilon = min(p))

# Plot significance results
plot(sffdr_out, rng = c(0, 5e-4))

# Functional P-values, Q-values, and local FDR
fp &lt;- sffdr_out$fpvalues
fq &lt;- sffdr_out$fqvalues
flfdr &lt;- sffdr_out$flfdr

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
