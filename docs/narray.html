<!DOCTYPE html><html><head><title>Help for package narray</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {narray}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#narray'><p>R package for subset- and name-aware array utility functions</p></a></li>
<li><a href='#+25or+25'><p>Operator for array-like logical operations</p></a></li>
<li><a href='#bind'><p>Binds arrays together disregarding names</p></a></li>
<li><a href='#collect'><p>Converts a logical matrix to a list of character vectors</p></a></li>
<li><a href='#construct'><p>Transform a data.frame with axes and value into an array</p></a></li>
<li><a href='#dim'><p>base::dim, but returning 1 for vector</p></a></li>
<li><a href='#dimnames'><p>Return dimension names of an array respecting the number of dimensions</p></a></li>
<li><a href='#drop_if'><p>Drop unused dims if flag is TRUE</p></a></li>
<li><a href='#filter'><p>Function to discard subsets of an array (NA or drop)</p></a></li>
<li><a href='#flatten'><p>Flattens an array along an axis</p></a></li>
<li><a href='#guess_structure'><p>Infer array structure from data.frame</p></a></li>
<li><a href='#intersect'><p>Intersects all passed arrays along a give dimension, and modifies them in place</p></a></li>
<li><a href='#intersect_list'><p>Intersects a lits of arrays for common dimension names</p></a></li>
<li><a href='#lambda'><p>Lambda syntax for array iteration</p></a></li>
<li><a href='#like'><p>Reshapes <code>x</code> to be like <code>like</code>, including dimension names</p></a></li>
<li><a href='#map'><p>Maps a function along an array preserving its structure</p></a></li>
<li><a href='#map_one'><p>Apply function that preserves order of dimensions</p></a></li>
<li><a href='#mask'><p>Converts a list of character vectors to a logical matrix</p></a></li>
<li><a href='#match'><p>match() function with extended functionality</p></a></li>
<li><a href='#melt'><p>Function to melt data.frame from one or multiple arrays</p></a></li>
<li><a href='#named_dots'><p>Return a list of named dot-arguments</p></a></li>
<li><a href='#pb'><p>Progress bar format to be consistent</p></a></li>
<li><a href='#rep'><p>Repeats an array along an arbitrary axis</p></a></li>
<li><a href='#restore_null_dimnames'><p>If no dimnames, return NULL and not list of NULLs</p></a></li>
<li><a href='#split'><p>Splits and array along a given axis, either totally or only subsets</p></a></li>
<li><a href='#stack'><p>Stacks arrays while respecting names in each dimension</p></a></li>
<li><a href='#subset'><p>Subsets an array using a list with indices or names</p></a></li>
<li><a href='#translate'><p>Translate an axis between two sets of identifiers</p></a></li>
<li><a href='#vectors_to_row_or_col'><p>Converts vectors in a list to row- or column vectors</p></a></li>
<li><a href='#which'><p>A multidimensional <code>which</code> function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Subset- And Name-Aware Array Utility Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Schubert &lt;mschu.dev@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Schubert &lt;mschu.dev@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Stacking arrays according to dimension names, subset-aware
    splitting and mapping of functions, intersecting along arbitrary
    dimensions, converting to and from data.frames, and many other helper
    functions.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mschubert/narray">https://github.com/mschubert/narray</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mschubert/narray/issues">https://github.com/mschubert/narray/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Imports:</td>
<td>progress, Rcpp, stats, stringr, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-02 12:56:25 UTC; mschu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-02 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='narray'>R package for subset- and name-aware array utility functions</h2><span id='topic+narray'></span><span id='topic+narray-package'></span>

<h3>Description</h3>

<p>Stacking arrays according to dimension names, subset-aware splitting and
mapping of functions, intersecting along arbitrary dimensions, converting to
and from data.frames, and many other helper functions.
</p>

<hr>
<h2 id='+25or+25'>Operator for array-like logical operations</h2><span id='topic++25or+25'></span>

<h3>Description</h3>

<p>Operator for array-like logical operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %or% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25or+2B25_+3A_a">a</code></td>
<td>
<p>First vector</p>
</td></tr>
<tr><td><code id="+2B25or+2B25_+3A_b">b</code></td>
<td>
<p>Second vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE for each element
</p>

<hr>
<h2 id='bind'>Binds arrays together disregarding names</h2><span id='topic+bind'></span>

<h3>Description</h3>

<p>Binds arrays together disregarding names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind(..., along = length(dim(arrayList[[1]])) + 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>N-dimensional arrays, or a list thereof</p>
</td></tr>
<tr><td><code id="bind_+3A_along">along</code></td>
<td>
<p>Along which axis to bind them together (default: new axis)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A joined array
</p>

<hr>
<h2 id='collect'>Converts a logical matrix to a list of character vectors</h2><span id='topic+collect'></span>

<h3>Description</h3>

<p>This currently only supports x with only one non-zero element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect(x, along = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_+3A_x">x</code></td>
<td>
<p>A logical matrix</p>
</td></tr>
<tr><td><code id="collect_+3A_along">along</code></td>
<td>
<p>Which axis to spread mask on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector or list thereof
</p>

<hr>
<h2 id='construct'>Transform a data.frame with axes and value into an array</h2><span id='topic+construct'></span>

<h3>Description</h3>

<p>The construct() function can be called either with the data.frame as the
first argument or the formula and then specify 'data=&lt;data.frame&gt;'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct(data, formula = guess_structure(data), fill = NA,
  name_axes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="construct_+3A_formula">formula</code></td>
<td>
<p>A formula: value ~ axis1 [+ axis2 + axis n ..]</p>
</td></tr>
<tr><td><code id="construct_+3A_fill">fill</code></td>
<td>
<p>Value to fill array with if undefined</p>
</td></tr>
<tr><td><code id="construct_+3A_name_axes">name_axes</code></td>
<td>
<p>Keep column names of 'data' as axis names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structured array
</p>

<hr>
<h2 id='dim'>base::dim, but returning 1 for vector</h2><span id='topic+dim'></span>

<h3>Description</h3>

<p>base::dim, but returning 1 for vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_+3A_x">x</code></td>
<td>
<p>Object to get dimensions on</p>
</td></tr>
</table>

<hr>
<h2 id='dimnames'>Return dimension names of an array respecting the number of dimensions</h2><span id='topic+dimnames'></span>

<h3>Description</h3>

<p>Act on each element if 'x' is a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimnames(x, along = TRUE, null_as_integer = FALSE,
  drop = !identical(along, TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimnames_+3A_x">x</code></td>
<td>
<p>An n-dimensional array</p>
</td></tr>
<tr><td><code id="dimnames_+3A_along">along</code></td>
<td>
<p>Limit to dimension (default: all)</p>
</td></tr>
<tr><td><code id="dimnames_+3A_null_as_integer">null_as_integer</code></td>
<td>
<p>Whether nameless dimensions should be <code>NULL</code> or
numbered</p>
</td></tr>
<tr><td><code id="dimnames_+3A_drop">drop</code></td>
<td>
<p>Drop list of only one axis requested (default: if not
returning all dimensions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dimension names with length <code>length(ndim(X))</code>
</p>

<hr>
<h2 id='drop_if'>Drop unused dims if flag is TRUE</h2><span id='topic+drop_if'></span>

<h3>Description</h3>

<p>Drop unused dims if flag is TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_if(x, flag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_if_+3A_x">x</code></td>
<td>
<p>An array object</p>
</td></tr>
<tr><td><code id="drop_if_+3A_flag">flag</code></td>
<td>
<p>Whether to drop unused dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object in full or with dropped dimensions
</p>

<hr>
<h2 id='filter'>Function to discard subsets of an array (NA or drop)</h2><span id='topic+filter'></span>

<h3>Description</h3>

<p>Function to discard subsets of an array (NA or drop)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter(X, along, FUN, subsets = base::rep(1, dim(X)[along]),
  na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_x">X</code></td>
<td>
<p>An n-dimensional array</p>
</td></tr>
<tr><td><code id="filter_+3A_along">along</code></td>
<td>
<p>Along which axis to apply <code>FUN</code></p>
</td></tr>
<tr><td><code id="filter_+3A_fun">FUN</code></td>
<td>
<p>Function to apply, needs to return <code>TRUE</code> (keep) or <code>FALSE</code></p>
</td></tr>
<tr><td><code id="filter_+3A_subsets">subsets</code></td>
<td>
<p>Subsets that should be used when applying <code>FUN</code></p>
</td></tr>
<tr><td><code id="filter_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to omit columns and rows with <code>NA</code>s</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array where filtered values are <code>NA</code> or dropped
</p>

<hr>
<h2 id='flatten'>Flattens an array along an axis</h2><span id='topic+flatten'></span>

<h3>Description</h3>

<p>Flattens an array along an axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten(x, along = -1, name_sep = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_+3A_x">x</code></td>
<td>
<p>Array</p>
</td></tr>
<tr><td><code id="flatten_+3A_along">along</code></td>
<td>
<p>Along which axis to bind them together (default: last)</p>
</td></tr>
<tr><td><code id="flatten_+3A_name_sep">name_sep</code></td>
<td>
<p>Which character to use for naming new arrays [default: NA, do not touch names]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with n-1 dimensions
</p>

<hr>
<h2 id='guess_structure'>Infer array structure from data.frame</h2><span id='topic+guess_structure'></span>

<h3>Description</h3>

<p>Infer array structure from data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_structure(df, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_structure_+3A_df">df</code></td>
<td>
<p>A data.frame with ordered axes, value field last</p>
</td></tr>
<tr><td><code id="guess_structure_+3A_verbose">verbose</code></td>
<td>
<p>Print message with inferred structure (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula describing this structure
</p>

<hr>
<h2 id='intersect'>Intersects all passed arrays along a give dimension, and modifies them in place</h2><span id='topic+intersect'></span>

<h3>Description</h3>

<p>TODO: accept along=c(1,2,1,1...) [maybe list w/ vectors as well?]
TODO: accept data=env/list arg? [sig-comb/drug-tissue/assocs.r#62-65]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect(..., along = 1, envir = parent.frame(), drop = FALSE,
  fail_if_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_+3A_...">...</code></td>
<td>
<p>Arrays that should be intersected</p>
</td></tr>
<tr><td><code id="intersect_+3A_along">along</code></td>
<td>
<p>The axis along which to intersect</p>
</td></tr>
<tr><td><code id="intersect_+3A_envir">envir</code></td>
<td>
<p>A list or environment to act upon</p>
</td></tr>
<tr><td><code id="intersect_+3A_drop">drop</code></td>
<td>
<p>Drop unused dimensions on result</p>
</td></tr>
<tr><td><code id="intersect_+3A_fail_if_empty">fail_if_empty</code></td>
<td>
<p>Stop if intersection yields empty set</p>
</td></tr>
</table>

<hr>
<h2 id='intersect_list'>Intersects a lits of arrays for common dimension names</h2><span id='topic+intersect_list'></span>

<h3>Description</h3>

<p>Intersects a lits of arrays for common dimension names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_list(l., along = 1, drop = FALSE, fail_if_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_list_+3A_l.">l.</code></td>
<td>
<p>List of arrays to perform operations on</p>
</td></tr>
<tr><td><code id="intersect_list_+3A_along">along</code></td>
<td>
<p>The axis along which to intersect</p>
</td></tr>
<tr><td><code id="intersect_list_+3A_drop">drop</code></td>
<td>
<p>Drop unused dimensions on result</p>
</td></tr>
<tr><td><code id="intersect_list_+3A_fail_if_empty">fail_if_empty</code></td>
<td>
<p>Stop if intersection yields empty set</p>
</td></tr>
</table>

<hr>
<h2 id='lambda'>Lambda syntax for array iteration</h2><span id='topic+lambda'></span>

<h3>Description</h3>

<p>Lambda syntax for array iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(fml, along, group = c(), simplify = TRUE, expand_grid = TRUE,
  envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_+3A_fml">fml</code></td>
<td>
<p>A call prefixed with a tilde</p>
</td></tr>
<tr><td><code id="lambda_+3A_along">along</code></td>
<td>
<p>A named vector which objects to subset (eg: c(x=1))</p>
</td></tr>
<tr><td><code id="lambda_+3A_group">group</code></td>
<td>
<p>Not implemented</p>
</td></tr>
<tr><td><code id="lambda_+3A_simplify">simplify</code></td>
<td>
<p>Return array instead of index+result if scalar</p>
</td></tr>
<tr><td><code id="lambda_+3A_expand_grid">expand_grid</code></td>
<td>
<p>Use all combinations of indices (default: TRUE)</p>
</td></tr>
<tr><td><code id="lambda_+3A_envir">envir</code></td>
<td>
<p>Environment where variables can be found</p>
</td></tr>
</table>

<hr>
<h2 id='like'>Reshapes <code>x</code> to be like <code>like</code>, including dimension names</h2><span id='topic+like'></span>

<h3>Description</h3>

<p>Reshapes <code>x</code> to be like <code>like</code>, including dimension names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>like(x, like)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="like_+3A_x">x</code></td>
<td>
<p>An n-dimensional array</p>
</td></tr>
<tr><td><code id="like_+3A_like">like</code></td>
<td>
<p>An n-dimensional array whose form <code>X</code> should inherit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with values of <code>X</code> and structure of <code>like</code>
</p>

<hr>
<h2 id='map'>Maps a function along an array preserving its structure</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Maps a function along an array preserving its structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(X, along, FUN, subsets = base::rep(1, dim(X)[along]), drop = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_x">X</code></td>
<td>
<p>An n-dimensional array</p>
</td></tr>
<tr><td><code id="map_+3A_along">along</code></td>
<td>
<p>Along which axis to apply the function</p>
</td></tr>
<tr><td><code id="map_+3A_fun">FUN</code></td>
<td>
<p>A function that maps a vector to the same length or a scalar</p>
</td></tr>
<tr><td><code id="map_+3A_subsets">subsets</code></td>
<td>
<p>Whether to apply <code>FUN</code> along the whole axis or subsets thereof</p>
</td></tr>
<tr><td><code id="map_+3A_drop">drop</code></td>
<td>
<p>Remove unused dimensions after mapping; default: TRUE</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array where <code>FUN</code> has been applied
</p>

<hr>
<h2 id='map_one'>Apply function that preserves order of dimensions</h2><span id='topic+map_one'></span>

<h3>Description</h3>

<p>Apply function that preserves order of dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_one(X, along, FUN, pb, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_one_+3A_x">X</code></td>
<td>
<p>An n-dimensional array</p>
</td></tr>
<tr><td><code id="map_one_+3A_along">along</code></td>
<td>
<p>Along which axis to apply the function</p>
</td></tr>
<tr><td><code id="map_one_+3A_fun">FUN</code></td>
<td>
<p>A function that maps a vector to the same length or a scalar</p>
</td></tr>
<tr><td><code id="map_one_+3A_pb">pb</code></td>
<td>
<p>progress bar object</p>
</td></tr>
<tr><td><code id="map_one_+3A_drop">drop</code></td>
<td>
<p>Remove unused dimensions after mapping; default: TRUE</p>
</td></tr>
<tr><td><code id="map_one_+3A_...">...</code></td>
<td>
<p>Arguments passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array where <code>FUN</code> has been applied
</p>

<hr>
<h2 id='mask'>Converts a list of character vectors to a logical matrix</h2><span id='topic+mask'></span>

<h3>Description</h3>

<p>Converts a list of character vectors to a logical matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask(x, along = 2, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_+3A_x">x</code></td>
<td>
<p>A list of character vectors</p>
</td></tr>
<tr><td><code id="mask_+3A_along">along</code></td>
<td>
<p>Which axis to spread mask on</p>
</td></tr>
<tr><td><code id="mask_+3A_na_rm">na_rm</code></td>
<td>
<p>Remove values that were translated to NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical occurrence matrix
</p>

<hr>
<h2 id='match'>match() function with extended functionality</h2><span id='topic+match'></span>

<h3>Description</h3>

<p>match() function with extended functionality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match(x, from, to, filter_from = NULL, filter_to = NULL,
  data = parent.frame(), fuzzy_level = 0, table = FALSE,
  na_rm = FALSE, warn = !table &amp;&amp; fuzzy_level &gt; 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_+3A_x">x</code></td>
<td>
<p>Vector of identifiers that should be mapped</p>
</td></tr>
<tr><td><code id="match_+3A_from">from</code></td>
<td>
<p>Vector of identifiers that can be mapped</p>
</td></tr>
<tr><td><code id="match_+3A_to">to</code></td>
<td>
<p>Matched mapping for all identifiers</p>
</td></tr>
<tr><td><code id="match_+3A_filter_from">filter_from</code></td>
<td>
<p>Restrict matching to a subset from 'from'</p>
</td></tr>
<tr><td><code id="match_+3A_filter_to">filter_to</code></td>
<td>
<p>Restrict matching to a subset from 'to'</p>
</td></tr>
<tr><td><code id="match_+3A_data">data</code></td>
<td>
<p>List containing the data 'from' and 'to' reference</p>
</td></tr>
<tr><td><code id="match_+3A_fuzzy_level">fuzzy_level</code></td>
<td>
<p>0 for exact, 1 punctuation, and 2 closest character</p>
</td></tr>
<tr><td><code id="match_+3A_table">table</code></td>
<td>
<p>Return a matching table instead of just the matches</p>
</td></tr>
<tr><td><code id="match_+3A_na_rm">na_rm</code></td>
<td>
<p>Flag to remove items that can not be mapped</p>
</td></tr>
<tr><td><code id="match_+3A_warn">warn</code></td>
<td>
<p>Display warning for all fuzzy matches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mapped values
</p>

<hr>
<h2 id='melt'>Function to melt data.frame from one or multiple arrays</h2><span id='topic+melt'></span>

<h3>Description</h3>

<p>Function to melt data.frame from one or multiple arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt(..., dimnames = NULL, na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_+3A_...">...</code></td>
<td>
<p>Array[s] or data.frame[s] to be melted</p>
</td></tr>
<tr><td><code id="melt_+3A_dimnames">dimnames</code></td>
<td>
<p>List of names along the dimensions</p>
</td></tr>
<tr><td><code id="melt_+3A_na_rm">na_rm</code></td>
<td>
<p>Remove rows with NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with 'value' (or object names if multiple) indexed by axes
</p>

<hr>
<h2 id='named_dots'>Return a list of named dot-arguments</h2><span id='topic+named_dots'></span>

<h3>Description</h3>

<p>Return a list of named dot-arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_dots(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="named_dots_+3A_...">...</code></td>
<td>
<p>Function arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named function arguments
</p>

<hr>
<h2 id='pb'>Progress bar format to be consistent</h2><span id='topic+pb'></span>

<h3>Description</h3>

<p>Progress bar format to be consistent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pb(ticks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pb_+3A_ticks">ticks</code></td>
<td>
<p>Number of ticks the bar has</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A progress bar object
</p>

<hr>
<h2 id='rep'>Repeats an array along an arbitrary axis</h2><span id='topic+rep'></span><span id='topic+crep'></span><span id='topic+rrep'></span>

<h3>Description</h3>

<p>Repeats an array along an arbitrary axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep(x, n, along = 1)

crep(x, n)

rrep(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_+3A_x">x</code></td>
<td>
<p>An array object</p>
</td></tr>
<tr><td><code id="rep_+3A_n">n</code></td>
<td>
<p>Integer, how often to repeat</p>
</td></tr>
<tr><td><code id="rep_+3A_along">along</code></td>
<td>
<p>Along which axis to repeat (default: 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array that is repeated 'n' times on axis 'along'
</p>

<hr>
<h2 id='restore_null_dimnames'>If no dimnames, return NULL and not list of NULLs</h2><span id='topic+restore_null_dimnames'></span>

<h3>Description</h3>

<p>If no dimnames, return NULL and not list of NULLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restore_null_dimnames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restore_null_dimnames_+3A_x">x</code></td>
<td>
<p>An array object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with NULL if no dimnames
</p>

<hr>
<h2 id='split'>Splits and array along a given axis, either totally or only subsets</h2><span id='topic+split'></span>

<h3>Description</h3>

<p>Splits and array along a given axis, either totally or only subsets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split(X, along, subsets = c(1:dim(X)[along]), drop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_x">X</code></td>
<td>
<p>An array that should be split</p>
</td></tr>
<tr><td><code id="split_+3A_along">along</code></td>
<td>
<p>Along which axis to split; use -1 for highest dimension</p>
</td></tr>
<tr><td><code id="split_+3A_subsets">subsets</code></td>
<td>
<p>Whether to split each element or keep some together</p>
</td></tr>
<tr><td><code id="split_+3A_drop">drop</code></td>
<td>
<p>Remove unused dimensions after mapping
default: drop if all resulting arrays have same number of dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arrays that combined make up the input array
</p>

<hr>
<h2 id='stack'>Stacks arrays while respecting names in each dimension</h2><span id='topic+stack'></span>

<h3>Description</h3>

<p>Stacks arrays while respecting names in each dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack(..., along = length(dim(arrayList[[1]])) + 1, fill = NA,
  drop = FALSE, keep_empty = FALSE, allow_overwrite = FALSE,
  fail_if_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_+3A_...">...</code></td>
<td>
<p>N-dimensional arrays, or a list thereof</p>
</td></tr>
<tr><td><code id="stack_+3A_along">along</code></td>
<td>
<p>Which axis arrays should be stacked on (default: new axis)</p>
</td></tr>
<tr><td><code id="stack_+3A_fill">fill</code></td>
<td>
<p>Value for unknown values (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="stack_+3A_drop">drop</code></td>
<td>
<p>Drop unused dimensions (default: FALSE)</p>
</td></tr>
<tr><td><code id="stack_+3A_keep_empty">keep_empty</code></td>
<td>
<p>Keep empty elements when stacking (default: FALSE)</p>
</td></tr>
<tr><td><code id="stack_+3A_allow_overwrite">allow_overwrite</code></td>
<td>
<p>Overwrite values if more arrays share same key</p>
</td></tr>
<tr><td><code id="stack_+3A_fail_if_empty">fail_if_empty</code></td>
<td>
<p>Stop if no arrays left after removing empty elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stacked array, either n or n+1 dimensional
</p>

<hr>
<h2 id='subset'>Subsets an array using a list with indices or names</h2><span id='topic+subset'></span>

<h3>Description</h3>

<p>Subsets an array using a list with indices or names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset(X, index, along = -1, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">X</code></td>
<td>
<p>The array to subset</p>
</td></tr>
<tr><td><code id="subset_+3A_index">index</code></td>
<td>
<p>A list of vectors to use for subsetting, or vector if along is given</p>
</td></tr>
<tr><td><code id="subset_+3A_along">along</code></td>
<td>
<p>Along which dimension to subset if index is a vector; default
is last dimension; argument is ignored if X is a vector</p>
</td></tr>
<tr><td><code id="subset_+3A_drop">drop</code></td>
<td>
<p>Remove unused dimensions after mapping; default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of the array
</p>

<hr>
<h2 id='translate'>Translate an axis between two sets of identifiers</h2><span id='topic+translate'></span>

<h3>Description</h3>

<p>Translate an axis between two sets of identifiers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(x, along = 1, to, from = dimnames(x)[[along]], ..., FUN,
  na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="translate_+3A_along">along</code></td>
<td>
<p>Along which axis to summarize</p>
</td></tr>
<tr><td><code id="translate_+3A_to">to</code></td>
<td>
<p>Names that this dimension should be summarized to</p>
</td></tr>
<tr><td><code id="translate_+3A_from">from</code></td>
<td>
<p>Names that match the dimension 'along'</p>
</td></tr>
<tr><td><code id="translate_+3A_...">...</code></td>
<td>
<p>Parameters passed to 'match'</p>
</td></tr>
<tr><td><code id="translate_+3A_fun">FUN</code></td>
<td>
<p>Which function to apply, default is throwing error on aggregation</p>
</td></tr>
<tr><td><code id="translate_+3A_na_rm">na_rm</code></td>
<td>
<p>Remove values that were translated to NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summarized matrix as defined by 'from', 'to'
</p>

<hr>
<h2 id='vectors_to_row_or_col'>Converts vectors in a list to row- or column vectors</h2><span id='topic+vectors_to_row_or_col'></span>

<h3>Description</h3>

<p>Converts vectors in a list to row- or column vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectors_to_row_or_col(xlist, along)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectors_to_row_or_col_+3A_xlist">xlist</code></td>
<td>
<p>List of array-like elements and vectors</p>
</td></tr>
<tr><td><code id="vectors_to_row_or_col_+3A_along">along</code></td>
<td>
<p>Along which dimension vectors should be aligned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List where vectors are replaced by row- or col vectors (2d)
</p>

<hr>
<h2 id='which'>A multidimensional <code>which</code> function</h2><span id='topic+which'></span>

<h3>Description</h3>

<p>A multidimensional <code>which</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which(x, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_+3A_x">x</code></td>
<td>
<p>N-dimensional logical array</p>
</td></tr>
<tr><td><code id="which_+3A_drop">drop</code></td>
<td>
<p>Return a vector if called on a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with indices where <code>A == TRUE</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
