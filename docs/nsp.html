<!DOCTYPE html><html><head><title>Help for package nsp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nsp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nsp-package'><p>nsp: Narrowest Significance Pursuit: Inference for Multiple Change-points in Linear Models</p></a></li>
<li><a href='#cov_dep_multi_norm'><p>Simulate covariate-dependent multiscale sup-norm for use in NSP</p></a></li>
<li><a href='#cov_dep_multi_norm_poly'><p>Simulate covariate-dependent multiscale sup-norm for use in NSP, for piecewise-polynomial models</p></a></li>
<li><a href='#cpt_importance'><p>Change-point importance (prominence) plot</p></a></li>
<li><a href='#draw_rects'><p>Draw NSP intervals of significance as shaded rectangular areas on the current plot</p></a></li>
<li><a href='#draw_rects_advanced'><p>Plot NSP intervals of significance at appropriate places along the graph of data</p></a></li>
<li><a href='#nsp'><p>Narrowest Significance Pursuit algorithm with general covariates and user-specified threshold</p></a></li>
<li><a href='#nsp_poly'><p>Narrowest Significance Pursuit algorithm for piecewise-polynomial signals</p></a></li>
<li><a href='#nsp_poly_ar'><p>Narrowest Significance Pursuit algorithm for piecewise-polynomial signals with autoregression</p></a></li>
<li><a href='#nsp_poly_selfnorm'><p>Self-normalised Narrowest Significance Pursuit algorithm for piecewise-polynomial signals</p></a></li>
<li><a href='#nsp_selfnorm'><p>Self-normalised Narrowest Significance Pursuit algorithm with general covariates and user-specified threshold</p></a></li>
<li><a href='#nsp_tvreg'><p>Narrowest Significance Pursuit algorithm with general covariates</p></a></li>
<li><a href='#sim_max_holder'><p>Simulate Holder-like norm of the Wiener process for use in self-normalised NSP</p></a></li>
<li><a href='#thresh_kab'><p>Compute the theoretical threshold for the multiscale sup-norm if the underlying distribution is standard normal</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Inference for Multiple Change-Points in Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Narrowest Significance Pursuit, a general and
    flexible methodology for automatically detecting localised regions in data sequences
    which each must contain a change-point (understood as an abrupt change in the
    parameters of an underlying linear model), at a prescribed global significance level.
    Narrowest Significance Pursuit works with a wide range of distributional assumptions
    on the errors, and yields exact desired finite-sample coverage probabilities,
    regardless of the form or number of the covariates. For details, see P. Fryzlewicz
    (2021) <a href="https://stats.lse.ac.uk/fryzlewicz/nsp/nsp.pdf">https://stats.lse.ac.uk/fryzlewicz/nsp/nsp.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lpSolve</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-20 18:01:02 UTC; piotr</td>
</tr>
<tr>
<td>Author:</td>
<td>Piotr Fryzlewicz <a href="https://orcid.org/0000-0002-9676-902X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Piotr Fryzlewicz &lt;p.fryzlewicz@lse.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-21 07:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='nsp-package'>nsp: Narrowest Significance Pursuit: Inference for Multiple Change-points in Linear Models</h2><span id='topic+nsp-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Implementation of Narrowest Significance Pursuit (NSP), a general and
flexible methodology for automatically detecting localised regions in data sequences
which each must contain a change-point (understood as an abrupt change in the
parameters of an underlying linear model), at a prescribed global significance level.
NSP works with a wide range of distributional assumptions on the errors, and yields
exact desired finite-sample coverage probabilities, regardless of the form or number
of the regressors. A good place to start exploring the package are the <code>nsp*</code> functions.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp">nsp</a></code>, <code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly_ar">nsp_poly_ar</a></code>, <code><a href="#topic+nsp_tvreg">nsp_tvreg</a></code>, <code><a href="#topic+nsp_selfnorm">nsp_selfnorm</a></code>,
<code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>
</p>

<hr>
<h2 id='cov_dep_multi_norm'>Simulate covariate-dependent multiscale sup-norm for use in NSP</h2><span id='topic+cov_dep_multi_norm'></span>

<h3>Description</h3>

<p>This function simulates the multiscale sup-norm adjusted for the form of the covariates, as described in Section 5.3
of the paper. This is done for i.i.d. N(0,1) innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_dep_multi_norm(x, N = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_dep_multi_norm_+3A_x">x</code></td>
<td>
<p>The design matrix with the regressors (covariates) as columns.</p>
</td></tr>
<tr><td><code id="cov_dep_multi_norm_+3A_n">N</code></td>
<td>
<p>Desired number of simulated values of the norm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>Sample of size <code>N</code> containing the simulated norms.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov_dep_multi_norm_poly">cov_dep_multi_norm_poly</a></code>, <code><a href="#topic+sim_max_holder">sim_max_holder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- c(rep(0, 100), rep(2, 100))
x.g &lt;- g + stats::rnorm(200)
mscale.norm.200 &lt;- cov_dep_multi_norm(matrix(1, 200, 1), 100)
nsp_poly(x.g, 100, thresh.val = stats::quantile(mscale.norm.200, .95))
</code></pre>

<hr>
<h2 id='cov_dep_multi_norm_poly'>Simulate covariate-dependent multiscale sup-norm for use in NSP, for piecewise-polynomial models</h2><span id='topic+cov_dep_multi_norm_poly'></span>

<h3>Description</h3>

<p>This function simulates the multiscale sup-norm adjusted for the form of the covariates, as described in Section 5.3
of the paper, for piecewise-polynomial models of degree <code>deg</code>. This is done for i.i.d. N(0,1) innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_dep_multi_norm_poly(n, deg, N = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_dep_multi_norm_poly_+3A_n">n</code></td>
<td>
<p>The data length (for which the multiscale norm is to be simulated)</p>
</td></tr>
<tr><td><code id="cov_dep_multi_norm_poly_+3A_deg">deg</code></td>
<td>
<p>The degree of the polynomial model (0 for the piecewise-constant model; 1 for piecewise-linearity, etc.).</p>
</td></tr>
<tr><td><code id="cov_dep_multi_norm_poly_+3A_n">N</code></td>
<td>
<p>Desired number of simulated values of the norm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>Sample of size <code>N</code> containing the simulated norms.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov_dep_multi_norm">cov_dep_multi_norm</a></code>, <code><a href="#topic+sim_max_holder">sim_max_holder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- c(rep(0, 100), rep(2, 100))
x.g &lt;- g + stats::rnorm(200)
mscale.norm.200 &lt;- cov_dep_multi_norm_poly(200, 0, 100)
nsp_poly(x.g, 100, thresh.val = stats::quantile(mscale.norm.200, .95))
</code></pre>

<hr>
<h2 id='cpt_importance'>Change-point importance (prominence) plot</h2><span id='topic+cpt_importance'></span>

<h3>Description</h3>

<p>This function produces a change-point prominence plot based on the NSP object provided. The heights of the bars are arranged in non-decreasing
order and correspond directly to the lengths of the NSP intervals of significance. Each bar is labelled as s-e where s (e) is the start (end) of the
corresponding NSP interval of significance, respectively. The change-points corresponding to the narrower intervals can be seen as more prominent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt_importance(nsp.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpt_importance_+3A_nsp.obj">nsp.obj</code></td>
<td>
<p>Object returned by one of the <code>nsp*</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>The function does not return a value.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_rects">draw_rects</a></code>, <code><a href="#topic+draw_rects_advanced">draw_rects_advanced</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
f &lt;- c(rep(0, 100), 1:100, rep(101, 100))
x.f &lt;- f + 15 * stats::rnorm(300)
x.f.n &lt;- nsp_poly(x.f, 100, "sim", deg=1)
cpt_importance(x.f.n)
</code></pre>

<hr>
<h2 id='draw_rects'>Draw NSP intervals of significance as shaded rectangular areas on the current plot</h2><span id='topic+draw_rects'></span>

<h3>Description</h3>

<p>This function draws intervals of significance returned by one of the <code>nsp*</code> functions on the current plot. It shows them as shaded
rectangular areas (hence the name of the function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_rects(nsp.obj, yrange, density = 10, col = "red", x.axis.start = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_rects_+3A_nsp.obj">nsp.obj</code></td>
<td>
<p>Object returned by one of the <code>nsp*</code> functions.</p>
</td></tr>
<tr><td><code id="draw_rects_+3A_yrange">yrange</code></td>
<td>
<p>Vector of length two specifying the (lower, upper) vertical limit of the rectangles.</p>
</td></tr>
<tr><td><code id="draw_rects_+3A_density">density</code></td>
<td>
<p>Density of the shading.</p>
</td></tr>
<tr><td><code id="draw_rects_+3A_col">col</code></td>
<td>
<p>Colour of the shading.</p>
</td></tr>
<tr><td><code id="draw_rects_+3A_x.axis.start">x.axis.start</code></td>
<td>
<p>Time index the x axis starts from. The NSP intervals of significance get shifted by <code>x.axis.start-1</code> prior to plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>The function does not return a value.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_rects_advanced">draw_rects_advanced</a></code>, <code><a href="#topic+nsp">nsp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
h &lt;- c(rep(0, 150), 1:150)
x.h &lt;- h + stats::rnorm(300) * 50
x.h.n &lt;- nsp_poly(x.h, 1000, "sim", deg=1)
draw_rects(x.h.n, c(-100, 100))
</code></pre>

<hr>
<h2 id='draw_rects_advanced'>Plot NSP intervals of significance at appropriate places along the graph of data</h2><span id='topic+draw_rects_advanced'></span>

<h3>Description</h3>

<p>This function plots the intervals of significance returned by one of the <code>nsp*</code> functions, at appropriate places along the graph of data.
It shows them as shaded rectangular areas (hence the name of the function) &quot;attached&quot; to the graph of the data. Note: the data sequence <code>y</code>
needs to have been plotted beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_rects_advanced(
  y,
  nsp.obj,
  half.height = NULL,
  show.middles = TRUE,
  col.middles = "blue",
  lwd = 3,
  density = 10,
  col.rects = "red",
  x.axis.start = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_rects_advanced_+3A_y">y</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_nsp.obj">nsp.obj</code></td>
<td>
<p>Object returned by one of the <code>nsp*</code> functions with <code>y</code> on input.</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_half.height">half.height</code></td>
<td>
<p>Half-height of each rectangle; if <code>NULL</code> then set to twice the estimated standard deviation of the data.</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_show.middles">show.middles</code></td>
<td>
<p>Whether to display lines corresponding to the midpoints of the rectanlges (rough change-point location estimates).</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_col.middles">col.middles</code></td>
<td>
<p>Colour of the midpoint lines.</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_lwd">lwd</code></td>
<td>
<p>Line width for the midpoint lines.</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_density">density</code></td>
<td>
<p>Density of the shading.</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_col.rects">col.rects</code></td>
<td>
<p>Colour of the shading.</p>
</td></tr>
<tr><td><code id="draw_rects_advanced_+3A_x.axis.start">x.axis.start</code></td>
<td>
<p>Time index the x axis starts from. The NSP intervals of significance get shifted by <code>x.axis.start-1</code> prior to plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>The function does not return a value.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_rects">draw_rects</a></code>, <code><a href="#topic+nsp">nsp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
f &lt;- c(rep(0, 100), 1:100, rep(101, 100))
x.f &lt;- f + 15 * stats::rnorm(300)
x.f.n &lt;- nsp_poly(x.f, 100, "sim", deg=1)
stats::ts.plot(x.f)
draw_rects_advanced(x.f, x.f.n, density = 3)
</code></pre>

<hr>
<h2 id='nsp'>Narrowest Significance Pursuit algorithm with general covariates and user-specified threshold</h2><span id='topic+nsp'></span>

<h3>Description</h3>

<p>This function runs the bare-bones Narrowest Significance Pursuit (NSP) algorithm on data sequence <code>y</code> and design matrix <code>x</code>
to obtain localised regions (intervals) of the domain in which the parameters of the linear regression model y_t = beta(t) x_t + z_t significantly
depart from constancy (e.g. by containing change-points). For any interval considered by the algorithm,
significance is achieved if the multiscale supremum-type
deviation measure (see Details for the literature reference) exceeds <code>lambda</code>. This function is
mainly to be used by the higher-level functions <code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly_ar">nsp_poly_ar</a></code> and <code><a href="#topic+nsp_tvreg">nsp_tvreg</a></code>
(which estimate a suitable <code>lambda</code> so that a given global significance level is guaranteed), and human users may prefer to use those functions
instead; however, <code>nsp</code> can also be run directly, if desired.
The function works best when the errors z_t in the linear regression formulation y_t = beta(t) x_t + z_t are independent and
identically distributed Gaussians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsp(y, x, M, lambda, overlap = FALSE, buffer = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsp_+3A_y">y</code></td>
<td>
<p>A vector containing the data sequence being the response in the linear model y_t = beta(t) x_t + z_t.</p>
</td></tr>
<tr><td><code id="nsp_+3A_x">x</code></td>
<td>
<p>The design matrix in the regression model above, with the regressors as columns.</p>
</td></tr>
<tr><td><code id="nsp_+3A_m">M</code></td>
<td>
<p>The minimum number of intervals considered at each recursive stage, unless the number of all intervals is smaller, in which case all intervals
are used.</p>
</td></tr>
<tr><td><code id="nsp_+3A_lambda">lambda</code></td>
<td>
<p>The threshold parameter for measuring the significance of non-constancy (of the linear regression parameters), for use with the multiscale
supremum-type deviation measure described in the paper.</p>
</td></tr>
<tr><td><code id="nsp_+3A_overlap">overlap</code></td>
<td>
<p>If <code>FALSE</code>, then on discovering a significant interval, the search continues recursively to the left and to the right of that
interval. If <code>TRUE</code>, then the search continues to the left and to the right of the midpoint of that interval.</p>
</td></tr>
<tr><td><code id="nsp_+3A_buffer">buffer</code></td>
<td>
<p>A non-negative integer specifying how many observations to leave out immediately to the left and to the right of a detected interval of
significance before recursively continuing the search
for the next interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>intervals</code></td>
<td>
<p>A data frame containing the estimated intervals of significance: <code>starts</code> and <code>ends</code> is where the intervals start and end,
respectively; <code>values</code> are the values of the deviation measure on each given interval; <code>midpoints</code> are the midpoints of the intervals.</p>
</td></tr>
<tr><td><code>threshold.used</code></td>
<td>
<p>The threshold <code>lambda</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly_ar">nsp_poly_ar</a></code>, <code><a href="#topic+nsp_tvreg">nsp_tvreg</a></code>, <code><a href="#topic+nsp_selfnorm">nsp_selfnorm</a></code>, <code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
f &lt;- c(1:100, 100:1, 1:100)
y &lt;- f + stats::rnorm(300) * 15
x &lt;- matrix(0, 300, 2)
x[,1] &lt;- 1
x[,2] &lt;- seq(from = 0, to = 1, length = 300)
nsp(y, x, 100, 15 * thresh_kab(300, .1))
</code></pre>

<hr>
<h2 id='nsp_poly'>Narrowest Significance Pursuit algorithm for piecewise-polynomial signals</h2><span id='topic+nsp_poly'></span>

<h3>Description</h3>

<p>This function runs the Narrowest Significance Pursuit (NSP) algorithm on a data sequence <code>y</code> believed to follow the model
y_t = f_t + z_t, where f_t is a piecewise polynomial of degree <code>deg</code>, and z_t is noise. It returns localised regions (intervals) of the
domain, such that each interval must contain a change-point in the parameters of the polynomial f_t
at the global significance level <code>alpha</code>.
For any interval considered by the algorithm,
significant departure from parameter constancy is achieved if the multiscale supremum-type
deviation measure (see Details for the literature reference) exceeds a threshold, which is either provided as input
or determined from the data (as a function of <code>alpha</code>). The function works best when the errors z_t are independent and
identically distributed Gaussians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsp_poly(
  y,
  M = 1000,
  thresh.type = "univ",
  thresh.val = NULL,
  sigma = NULL,
  alpha = 0.1,
  deg = 0,
  overlap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsp_poly_+3A_y">y</code></td>
<td>
<p>A vector containing the data sequence.</p>
</td></tr>
<tr><td><code id="nsp_poly_+3A_m">M</code></td>
<td>
<p>The minimum number of intervals considered at each recursive stage, unless the number of all intervals is smaller, in which case all intervals
are used.</p>
</td></tr>
<tr><td><code id="nsp_poly_+3A_thresh.type">thresh.type</code></td>
<td>
<p><code>"univ"</code> if the significance threshold is to be determined as in Kabluchko (2007); <code>"sim"</code> for the degree-dependent
threshold determined
by simulation (this is only available if the length of <code>y</code> does not exceed 2150; for longer sequences obtain a suitable threshold by running
<code>cov_dep_multi_norm_poly</code> first).</p>
</td></tr>
<tr><td><code id="nsp_poly_+3A_thresh.val">thresh.val</code></td>
<td>
<p>Numerical value of the significance threshold (lambda in the paper); or <code>NULL</code> if the threshold is to be determined from
the data (see <code>thresh.type</code>).</p>
</td></tr>
<tr><td><code id="nsp_poly_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the errors z_t; if <code>NULL</code> then will be estimated from the data via Median Absolute Deviation (for i.i.d.
Gaussian sequences) of the first difference.</p>
</td></tr>
<tr><td><code id="nsp_poly_+3A_alpha">alpha</code></td>
<td>
<p>Desired maximum probability of obtaining an interval that does not contain a change-point (the significance threshold will be
determined as a function of this parameter).</p>
</td></tr>
<tr><td><code id="nsp_poly_+3A_deg">deg</code></td>
<td>
<p>The degree of the polynomial pieces in f_t (0 for the piecewise-constant model; 1 for piecewise-linearity, etc.).</p>
</td></tr>
<tr><td><code id="nsp_poly_+3A_overlap">overlap</code></td>
<td>
<p>If <code>FALSE</code>, then on discovering a significant interval, the search continues recursively to the left and to the right of that
interval. If <code>TRUE</code>, then the search continues to the left and to the right of the midpoint of that interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint. For how to determine the <code>"univ"</code> threshold, see Kabluchko, Z. (2007) &quot;Extreme-value analysis of standardized Gaussian increments&quot;.
Unpublished.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>intervals</code></td>
<td>
<p>A data frame containing the estimated intervals of significance: <code>starts</code> and <code>ends</code> is where the intervals start and end,
respectively; <code>values</code> are the values of the deviation measure on each given interval; <code>midpoints</code> are their midpoints.</p>
</td></tr>
<tr><td><code>threshold.used</code></td>
<td>
<p>The threshold value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp">nsp</a></code>, <code><a href="#topic+nsp_poly_ar">nsp_poly_ar</a></code>, <code><a href="#topic+nsp_tvreg">nsp_tvreg</a></code>, <code><a href="#topic+nsp_selfnorm">nsp_selfnorm</a></code>, <code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
f &lt;- c(1:100, 100:1, 1:100)
y &lt;- f + stats::rnorm(300) * 15
nsp_poly(y, 100, deg = 1)
</code></pre>

<hr>
<h2 id='nsp_poly_ar'>Narrowest Significance Pursuit algorithm for piecewise-polynomial signals with autoregression</h2><span id='topic+nsp_poly_ar'></span>

<h3>Description</h3>

<p>This function runs the Narrowest Significance Pursuit (NSP) algorithm on a data sequence <code>y</code> believed to follow the model
Phi(B)y_t = f_t + z_t, where f_t is a piecewise polynomial of degree <code>deg</code>, Phi(B) is a characteristic polynomial of autoregression of order
<code>ord</code> with unknown coefficients, and z_t is noise. The function returns localised regions (intervals) of the domain, such that each interval
must contain a change-point in the parameters of the polynomial f_t, or in the autoregressive parameters,
at the global significance level <code>alpha</code>.
For any interval considered by the algorithm,
significant departure from parameter constancy is achieved if the multiscale
deviation measure (see Details for the literature reference) exceeds a threshold, which is either provided as input
or determined from the data (as a function of <code>alpha</code>). The function works best when the errors z_t are independent and
identically distributed Gaussians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsp_poly_ar(
  y,
  ord = 1,
  M = 1000,
  thresh.type = "univ",
  thresh.val = NULL,
  sigma = NULL,
  alpha = 0.1,
  deg = 0,
  power = 1/2,
  min.size = 20,
  overlap = FALSE,
  buffer = ord
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsp_poly_ar_+3A_y">y</code></td>
<td>
<p>A vector containing the data sequence.</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_ord">ord</code></td>
<td>
<p>The assumed order of the autoregression.</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_m">M</code></td>
<td>
<p>The minimum number of intervals considered at each recursive stage, unless the number of all intervals is smaller, in which case all intervals
are used.</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_thresh.type">thresh.type</code></td>
<td>
<p><code>"univ"</code> if the significance threshold is to be determined as in Kabluchko (2007); <code>"sim"</code> for the degree-dependent
threshold determined
by simulation (this is only available if the length of <code>y</code> does not exceed 2150; for longer sequences obtain a suitable threshold by running
<code>cov_dep_multi_norm_poly</code> first).</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_thresh.val">thresh.val</code></td>
<td>
<p>Numerical value of the significance threshold (lambda in the paper); or <code>NULL</code> if the threshold is to be determined from
the data (see <code>thresh.type</code>).</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the errors z_t; if <code>NULL</code> then will be estimated from the data via the MOLS estimator described in the paper.</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_alpha">alpha</code></td>
<td>
<p>Desired maximum probability of obtaining an interval that does not contain a change-point (the significance threshold will be
determined as a function of this parameter).</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_deg">deg</code></td>
<td>
<p>The degree of the polynomial pieces in f_t (0 for the piecewise-constant model; 1 for piecewise-linearity, etc.).</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_power">power</code></td>
<td>
<p>A parameter for the MOLS estimator of sigma; the span of the moving window in the MOLS estimator is <code>min(n, max(round(n^power), min.size))</code>,
where <code>n</code> is the length of <code>y</code> (minus <code>ord</code>).</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_min.size">min.size</code></td>
<td>
<p>(See immediately above.)</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_overlap">overlap</code></td>
<td>
<p>If <code>FALSE</code>, then on discovering a significant interval, the search continues recursively to the left and to the right of that
interval. If <code>TRUE</code>, then the search continues to the left and to the right of the midpoint of that interval.</p>
</td></tr>
<tr><td><code id="nsp_poly_ar_+3A_buffer">buffer</code></td>
<td>
<p>A non-negative integer specifying how many observations to leave out immediately to the left and to the right of a detected interval of
significance before recursively continuing the search
for the next interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint. For how to determine the <code>"univ"</code> threshold, see Kabluchko, Z. (2007) &quot;Extreme-value analysis of standardized Gaussian increments&quot;.
Unpublished.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>intervals</code></td>
<td>
<p>A data frame containing the estimated intervals of significance: <code>starts</code> and <code>ends</code> is where the intervals start and end,
respectively; <code>values</code> are the values of the deviation measure on each given interval; <code>midpoints</code> are their midpoints.</p>
</td></tr>
<tr><td><code>threshold.used</code></td>
<td>
<p>The threshold value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp">nsp</a></code>, <code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_tvreg">nsp_tvreg</a></code>, <code><a href="#topic+nsp_selfnorm">nsp_selfnorm</a></code>, <code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- c(rep(0, 100), rep(10, 100), rep(0, 100))
nsp_poly_ar(stats::filter(g + 2 * stats::rnorm(300), .5, "recursive"), thresh.type="sim")
</code></pre>

<hr>
<h2 id='nsp_poly_selfnorm'>Self-normalised Narrowest Significance Pursuit algorithm for piecewise-polynomial signals</h2><span id='topic+nsp_poly_selfnorm'></span>

<h3>Description</h3>

<p>This function runs the Narrowest Significance Pursuit (NSP) algorithm on a data sequence <code>y</code> believed to follow the model
y_t = f_t + z_t, where f_t is a piecewise polynomial of degree <code>deg</code>, and z_t is noise. It returns localised regions (intervals) of the
domain, such that each interval must contain a change-point in the parameters of the polynomial f_t
at the global significance level <code>alpha</code>.
For any interval considered by the algorithm,
significant departure from parameter constancy is achieved if the multiscale
deviation measure (see Details for the literature reference) exceeds a threshold, which is either provided as input
or determined from the data (as a function of <code>alpha</code>). The function assumes independence, symmetry and finite variance of the
errors z_t, but little else; in particular they do not need to have a constant variance across t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsp_poly_selfnorm(
  y,
  M = 1000,
  thresh.val = NULL,
  power = 1/2,
  min.size = 20,
  alpha = 0.1,
  deg = 0,
  eps = 0.03,
  c = exp(1 + 2 * eps),
  overlap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsp_poly_selfnorm_+3A_y">y</code></td>
<td>
<p>A vector containing the data sequence.</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_m">M</code></td>
<td>
<p>The minimum number of intervals considered at each recursive stage, unless the number of all intervals is smaller, in which case all intervals
are used.</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_thresh.val">thresh.val</code></td>
<td>
<p>Numerical value of the significance threshold (lambda in the paper); or <code>NULL</code> if the threshold is to be determined from
the data.</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_power">power</code></td>
<td>
<p>A parameter for the (rough) estimator of the global sum of squares of z_t; the span of the moving window in that estimator is
<code>min(n, max(round(n^power), min.size))</code>, where <code>n</code> is the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_min.size">min.size</code></td>
<td>
<p>(See immediately above.)</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_alpha">alpha</code></td>
<td>
<p>Desired maximum probability of obtaining an interval that does not contain a change-point (the significance threshold will be
determined as a function of this parameter).</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_deg">deg</code></td>
<td>
<p>The degree of the polynomial pieces in f_t (0 for the piecewise-constant model; 1 for piecewise-linearity, etc.).</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_eps">eps</code></td>
<td>
<p>Parameter of the self-normalisation statistic as described in the paper; use default if unsure how to set.</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_c">c</code></td>
<td>
<p>Parameter of the self-normalisation statistic as described in the paper; use default if unsure how to set.</p>
</td></tr>
<tr><td><code id="nsp_poly_selfnorm_+3A_overlap">overlap</code></td>
<td>
<p>If <code>FALSE</code>, then on discovering a significant interval, the search continues recursively to the left and to the right of that
interval. If <code>TRUE</code>, then the search continues to the left and to the right of the midpoint of that interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>intervals</code></td>
<td>
<p>A data frame containing the estimated intervals of significance: <code>starts</code> and <code>ends</code> is where the intervals start and end,
respectively; <code>values</code> are the values of the deviation measure on each given interval; <code>midpoints</code> are their midpoints.</p>
</td></tr>
<tr><td><code>threshold.used</code></td>
<td>
<p>The threshold value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly_ar">nsp_poly_ar</a></code>, <code><a href="#topic+nsp_tvreg">nsp_tvreg</a></code>, <code><a href="#topic+nsp_selfnorm">nsp_selfnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- c(rep(0, 100), rep(10, 100), rep(0, 100))
x.g &lt;- g + stats::rnorm(300) * seq(from = 1, to = 4, length = 300)
nsp_poly_selfnorm(x.g, 100)
</code></pre>

<hr>
<h2 id='nsp_selfnorm'>Self-normalised Narrowest Significance Pursuit algorithm with general covariates and user-specified threshold</h2><span id='topic+nsp_selfnorm'></span>

<h3>Description</h3>

<p>This function runs the self-normalised Narrowest Significance Pursuit (NSP) algorithm on data sequence <code>y</code> and design matrix <code>x</code>
to obtain localised regions (intervals) of the domain in which the parameters of the linear regression model y_t = beta(t) x_t + z_t significantly
depart from constancy (e.g. by containing change-points). For any interval considered by the algorithm,
significant departure from parameter constancy is achieved if the self-normalised multiscale
deviation measure (see Details for the literature reference) exceeds <code>lambda</code>. This function is
used by the higher-level function <code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>
(which estimates a suitable <code>lambda</code> so that a given global significance level is guaranteed), and human users may prefer to use that function
if <code>x</code> describe polynomial covariates; however, <code>nsp_selfnorm</code> can also be run directly, if desired.
The function assumes independence, symmetry and finite variance of the errors z_t, but little else; in particular they do not need to have a constant
variance across t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsp_selfnorm(
  y,
  x,
  M,
  lambda,
  power = 1/2,
  min.size = 20,
  eps = 0.03,
  c = exp(1 + 2 * eps),
  overlap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsp_selfnorm_+3A_y">y</code></td>
<td>
<p>A vector containing the data sequence being the response in the linear model y_t = beta(t) x_t + z_t.</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_x">x</code></td>
<td>
<p>The design matrix in the regression model above, with the regressors as columns.</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_m">M</code></td>
<td>
<p>The minimum number of intervals considered at each recursive stage, unless the number of all intervals is smaller, in which case all intervals
are used.</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_lambda">lambda</code></td>
<td>
<p>The threshold parameter for measuring the significance of non-constancy (of the linear regression parameters), for use with the
self-normalised multiscale supremum-type deviation measure described in the paper.</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_power">power</code></td>
<td>
<p>A parameter for the (rough) estimator of the global sum of squares of z_t; the span of the moving window in that estimator is
<code>min(n, max(round(n^power), min.size))</code>, where <code>n</code> is the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_min.size">min.size</code></td>
<td>
<p>(See immediately above.)</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_eps">eps</code></td>
<td>
<p>Parameter of the self-normalisation statistic as described in the paper; use default if unsure how to set.</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_c">c</code></td>
<td>
<p>Parameter of the self-normalisation statistic as described in the paper; use default if unsure how to set.</p>
</td></tr>
<tr><td><code id="nsp_selfnorm_+3A_overlap">overlap</code></td>
<td>
<p>If <code>FALSE</code>, then on discovering a significant interval, the search continues recursively to the left and to the right of that
interval. If <code>TRUE</code>, then the search continues to the left and to the right of the midpoint of that interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>intervals</code></td>
<td>
<p>A data frame containing the estimated intervals of significance: <code>starts</code> and <code>ends</code> is where the intervals start and end,
respectively; <code>values</code> are the values of the deviation measure on each given interval; <code>midpoints</code> are their midpoints.</p>
</td></tr>
<tr><td><code>threshold.used</code></td>
<td>
<p>The threshold <code>lambda</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly_ar">nsp_poly_ar</a></code>, <code><a href="#topic+nsp_tvreg">nsp_tvreg</a></code>, <code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- c(rep(0, 100), rep(10, 100), rep(0, 100))
x.g &lt;- g + stats::rnorm(300) * seq(from = 1, to = 4, length = 300)
wn003 &lt;- sim_max_holder(100, 500, .03)
lambda &lt;- as.numeric(stats::quantile(wn003, .9))
nsp_selfnorm(x.g, matrix(1, 300, 1), 100, lambda)
</code></pre>

<hr>
<h2 id='nsp_tvreg'>Narrowest Significance Pursuit algorithm with general covariates</h2><span id='topic+nsp_tvreg'></span>

<h3>Description</h3>

<p>This function runs the Narrowest Significance Pursuit (NSP) algorithm on data sequence <code>y</code> and design matrix <code>x</code>
to return localised regions (intervals) of the domain in which the parameters of the linear regression model y_t = beta(t) x_t + z_t significantly
depart from constancy (e.g. by containing change-points), at the global significance level <code>alpha</code>. For any interval considered by the algorithm,
significant departure from parameter constancy is achieved if the multiscale
deviation measure (see Details for the literature reference) exceeds a threshold, which is either provided as input
or determined from the data (as a function of <code>alpha</code>).
The function works best when the errors z_t in the linear regression formulation y_t = beta(t) x_t + z_t are independent and
identically distributed Gaussians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsp_tvreg(
  y,
  x,
  M = 1000,
  thresh.val = NULL,
  sigma = NULL,
  alpha = 0.1,
  power = 1/2,
  min.size = 20,
  overlap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsp_tvreg_+3A_y">y</code></td>
<td>
<p>A vector containing the data sequence being the response in the linear model y_t = beta(t) x_t + z_t.</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_x">x</code></td>
<td>
<p>The design matrix in the regression model above, with the regressors as columns.</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_m">M</code></td>
<td>
<p>The minimum number of intervals considered at each recursive stage, unless the number of all intervals is smaller, in which case all intervals
are used.</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_thresh.val">thresh.val</code></td>
<td>
<p>Numerical value of the significance threshold (lambda in the paper); or <code>NULL</code> if the threshold is to be determined from
the data (see <code>thresh.type</code>).</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the errors z_t; if <code>NULL</code> then will be estimated from the data via the MOLS estimator described in the paper.</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_alpha">alpha</code></td>
<td>
<p>Desired maximum probability of obtaining an interval that does not contain a change-point (the significance threshold will be
determined as a function of this parameter).</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_power">power</code></td>
<td>
<p>A parameter for the MOLS estimator of sigma; the span of the moving window in the MOLS estimator is <code>min(n, max(round(n^power), min.size))</code>,
where <code>n</code> is the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_min.size">min.size</code></td>
<td>
<p>(See immediately above.)</p>
</td></tr>
<tr><td><code id="nsp_tvreg_+3A_overlap">overlap</code></td>
<td>
<p>If <code>FALSE</code>, then on discovering a significant interval, the search continues recursively to the left and to the right of that
interval. If <code>TRUE</code>, then the search continues to the left and to the right of the midpoint of that interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>intervals</code></td>
<td>
<p>A data frame containing the estimated intervals of significance: <code>starts</code> and <code>ends</code> is where the intervals start and end,
respectively; <code>values</code> are the values of the deviation measure on each given interval; <code>midpoints</code> are their midpoints.</p>
</td></tr>
<tr><td><code>threshold.used</code></td>
<td>
<p>The threshold value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp">nsp</a></code>, <code><a href="#topic+nsp_poly">nsp_poly</a></code>, <code><a href="#topic+nsp_poly_ar">nsp_poly_ar</a></code>, <code><a href="#topic+nsp_selfnorm">nsp_selfnorm</a></code>, <code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
f &lt;- c(1:100, 100:1, 1:100)
y &lt;- f + stats::rnorm(300) * 15
x &lt;- matrix(0, 300, 2)
x[,1] &lt;- 1
x[,2] &lt;- seq(from = 0, to = 1, length = 300)
nsp_tvreg(y, x, 100)
</code></pre>

<hr>
<h2 id='sim_max_holder'>Simulate Holder-like norm of the Wiener process for use in self-normalised NSP</h2><span id='topic+sim_max_holder'></span>

<h3>Description</h3>

<p>This function simulates a sample of size <code>N</code> of values of the Holder-like norm of the Wiener process discretised with step 1/<code>n</code>.
The sample can then be used to find a suitable threshold for use with the self-normalised NSP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_max_holder(n, N, eps, c = exp(1 + 2 * eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_max_holder_+3A_n">n</code></td>
<td>
<p>Number of equispaced sampling points for the Wiener process on <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="sim_max_holder_+3A_n">N</code></td>
<td>
<p>Desired number of simulated values of the norm.</p>
</td></tr>
<tr><td><code id="sim_max_holder_+3A_eps">eps</code></td>
<td>
<p>Parameter of the self-normalisation statistic as described in the paper.</p>
</td></tr>
<tr><td><code id="sim_max_holder_+3A_c">c</code></td>
<td>
<p>Parameter of the self-normalisation statistic as described in the paper; use default if unsure how to set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NSP algorithm is described in P. Fryzlewicz (2021) &quot;Narrowest Significance Pursuit: inference for multiple change-points in linear
models&quot;, preprint.
</p>


<h3>Value</h3>

<p>Sample of size <code>N</code> containing the simulated norms.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsp_selfnorm">nsp_selfnorm</a></code>, <code><a href="#topic+nsp_poly_selfnorm">nsp_poly_selfnorm</a></code>, <code><a href="#topic+cov_dep_multi_norm">cov_dep_multi_norm</a></code>, <code><a href="#topic+cov_dep_multi_norm_poly">cov_dep_multi_norm_poly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- c(rep(0, 100), rep(10, 100), rep(0, 100))
x.g &lt;- g + stats::rnorm(300) * seq(from = 1, to = 4, length = 300)
wn003 &lt;- sim_max_holder(100, 500, .03)
lambda &lt;- as.numeric(stats::quantile(wn003, .9))
nsp_poly_selfnorm(x.g, M = 100, thresh.val = lambda)
</code></pre>

<hr>
<h2 id='thresh_kab'>Compute the theoretical threshold for the multiscale sup-norm if the underlying distribution is standard normal</h2><span id='topic+thresh_kab'></span>

<h3>Description</h3>

<p>This function computes the theoretical threshold, corresponding to the given significance level <code>alpha</code>, for the multiscale sup-norm
if the underlying distribution is standard normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresh_kab(n, alpha = 0.1, method = "asymp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresh_kab_+3A_n">n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="thresh_kab_+3A_alpha">alpha</code></td>
<td>
<p>The significance level.</p>
</td></tr>
<tr><td><code id="thresh_kab_+3A_method">method</code></td>
<td>
<p>&quot;asymp&quot; for the asymptotic method; &quot;bound&quot; for the Bonferroni method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the underlying theory, see Z. Kabluchko (2007) Extreme-value analysis of standardized Gaussian increments. Unpublished.
</p>


<h3>Value</h3>

<p>The desired threshold.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov_dep_multi_norm">cov_dep_multi_norm</a></code>, <code><a href="#topic+cov_dep_multi_norm_poly">cov_dep_multi_norm_poly</a></code>, <code><a href="#topic+sim_max_holder">sim_max_holder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
f &lt;- c(1:100, 100:1, 1:100)
y &lt;- f + stats::rnorm(300) * 15
x &lt;- matrix(0, 300, 2)
x[,1] &lt;- 1
x[,2] &lt;- seq(from = 0, to = 1, length = 300)
nsp(y, x, 100, 15 * thresh_kab(300, .1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
