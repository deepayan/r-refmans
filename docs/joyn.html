<!DOCTYPE html><html><head><title>Help for package joyn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {joyn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#freq_table'><p>tabulate simple frequencies</p></a></li>
<li><a href='#is_id'><p>Make sure the match type is correct</p></a></li>
<li><a href='#merge'><p>Merge two tables</p></a></li>
<li><a href='#possible_ids'><p>Find possible unique identifies of data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tool for Diagnosis of Tables Joins and Complementary Join
Features</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Tool for diagnosing table joins. It combines the speed
    'data.table', the flexibility of 'dplyr', and the diagnosis and features of
    the 'merge' command in 'Stata'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/randrescastaneda/joyn">https://github.com/randrescastaneda/joyn</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/randrescastaneda/joyn/issues">https://github.com/randrescastaneda/joyn/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>badger, covr, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, data.table, glue, cli, stats, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-13 17:29:41 UTC; wb384996</td>
</tr>
<tr>
<td>Author:</td>
<td>R.Andres Castaneda [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>R.Andres Castaneda &lt;acastanedaa@worldbank.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-14 13:00:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='freq_table'>tabulate simple frequencies</h2><span id='topic+freq_table'></span>

<h3>Description</h3>

<p>tabulate one variable frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_table(x, byvar, digits = 1, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_table_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="freq_table_+3A_byvar">byvar</code></td>
<td>
<p>character: name of variable to tabulate. Use Standard evaluation.</p>
</td></tr>
<tr><td><code id="freq_table_+3A_digits">digits</code></td>
<td>
<p>numeric: number of decimal places to display. Default is 1.</p>
</td></tr>
<tr><td><code id="freq_table_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if TRUE remove NAs from calculations. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x4 = data.table(id1 = c(1, 1, 2, 3, 3),
                id2 = c(1, 1, 2, 3, 4),
                t   = c(1L, 2L, 1L, 2L, NA_integer_),
                x   = c(16, 12, NA, NA, 15))
freq_table(x4, "id1")
</code></pre>

<hr>
<h2 id='is_id'>Make sure the match type is correct</h2><span id='topic+is_id'></span>

<h3>Description</h3>

<p>Make sure the match type is correct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_id(dt, by, verbose = TRUE, return_report = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_id_+3A_dt">dt</code></td>
<td>
<p>either right of left table</p>
</td></tr>
<tr><td><code id="is_id_+3A_by">by</code></td>
<td>
<p>by argument in merge</p>
</td></tr>
<tr><td><code id="is_id_+3A_verbose">verbose</code></td>
<td>
<p>logical: if TRUE messages will be displayed</p>
</td></tr>
<tr><td><code id="is_id_+3A_return_report">return_report</code></td>
<td>
<p>logical: if TRUE, returns data with summary of duplicates.
If FALSE, returns logical value depending on whether <code>dt</code> is uniquely identified
by <code>by</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical or data.frame, depending on the value of argument <code>return_report</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
y3 &lt;- data.table(id = c("c","b", "c", "a"),
                 y  = c(11L, 15L, 18L, 20L))
is_id(y3, by = "id")
is_id(y3, by = "id", return_report = TRUE)
</code></pre>

<hr>
<h2 id='merge'>Merge two tables</h2><span id='topic+merge'></span>

<h3>Description</h3>

<p>This is the main and, basically, the only function in joyn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge(
  x,
  y,
  by = intersect(names(x), names(y)),
  yvars = TRUE,
  match_type = c("m:m", "m:1", "1:m", "1:1"),
  keep = c("full", "left", "master", "right", "using", "inner"),
  update_values = FALSE,
  update_NAs = update_values,
  reportvar = "report",
  reporttype = c("character", "numeric"),
  roll = NULL,
  keep_y_in_x = FALSE,
  sort = TRUE,
  verbose = getOption("joyn.verbose"),
  allow.cartesian = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_x">x</code></td>
<td>
<p>data frame: referred to <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="merge_+3A_y">y</code></td>
<td>
<p>data frame: referred to <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="merge_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
joyn will do a natural join, using all variables with common names across
the two tables. A message lists the variables so that you can check they're
right (to suppress the message, simply explicitly list the variables that
you want to join). To join by different variables on x and y use a vector
of expressions. For example, <code>by = c("a = b", "z")</code> will use &quot;a&quot; in x, &quot;b&quot;
in y, and &quot;z&quot; in both tables.</p>
</td></tr>
<tr><td><code id="merge_+3A_yvars">yvars</code></td>
<td>
<p>character: Vector of variable names that will be kept after the
merge. If TRUE (the default), it keeps all the brings all the variables in
y into x. If FALSE or NULL, it does not bring any variable into x, but a
report will be generated.</p>
</td></tr>
<tr><td><code id="merge_+3A_match_type">match_type</code></td>
<td>
<p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;m:m&quot;</em> since this is the default generally used in joins in R.
However, following Stata's recommendation, it is better to be explicit and
use any of the other three match types (See details in <em>match types
sections</em>).</p>
</td></tr>
<tr><td><code id="merge_+3A_keep">keep</code></td>
<td>
<p>character: One of <em>&quot;full&quot;</em>, <em>&quot;left&quot;</em>, <em>&quot;master&quot;</em>, <em>&quot;right&quot;</em>,
<em>&quot;using&quot;</em>, <em>&quot;inner&quot;</em>. Default is <em>&quot;full&quot;</em>. Even though this is not the
regular behavior of joins in R, the objective of <code>joyn</code> is to present a
diagnosis of the join, so that it must use by default a full join. Yet, if
<em>&quot;left&quot;</em> or <em>&quot;master&quot;</em>, it keeps the observations that matched in both
tables and the ones that did not match in x. The ones in y will be
discarded. If <em>&quot;right&quot;</em> or <em>&quot;using&quot;</em>, it keeps the observations that
matched in both tables and the ones that did not match in y. The ones in x
will be discarded. If <em>&quot;inner&quot;</em>, it only keeps the observations that
matched both tables.</p>
</td></tr>
<tr><td><code id="merge_+3A_update_values">update_values</code></td>
<td>
<p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</td></tr>
<tr><td><code id="merge_+3A_update_nas">update_NAs</code></td>
<td>
<p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="merge_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default if &quot;report&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="merge_+3A_reporttype">reporttype</code></td>
<td>
<p>character: One of <em>&quot;character&quot;</em> or <em>&quot;numeric&quot;</em>. Default is
<em>&quot;character&quot;</em>. If <em>&quot;numeric&quot;</em>, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table.</p>
</td></tr>
<tr><td><code id="merge_+3A_roll">roll</code></td>
<td>
<p>double: <em>to be implemented</em></p>
</td></tr>
<tr><td><code id="merge_+3A_keep_y_in_x">keep_y_in_x</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable from
y when both tables have common variable names. Thus, the prefix &quot;y.&quot; will
be added to the original name to distinguish from the resulting variable in
the joined table.</p>
</td></tr>
<tr><td><code id="merge_+3A_sort">sort</code></td>
<td>
<p>logical: If TRUE, sort by key variables in <code>by</code>. Default is
TRUE.</p>
</td></tr>
<tr><td><code id="merge_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
<tr><td><code id="merge_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>logical: Check documentation in official <a href="https://rdatatable.gitlab.io/data.table/reference/merge.html/">web site</a>.
Default is <code>NULL</code>, which implies that if the join is &quot;1:1&quot; it will be
<code>FALSE</code>, but if the join has any &quot;m&quot; on it, it will be converted to <code>TRUE</code>.
By specifying <code>TRUE</code> of <code>FALSE</code> you force the behavior of the join.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table joining x and y.
</p>


<h3>match types</h3>

<p>Using the same wording of the <a href="https://www.stata.com/manuals/dmerge.pdf">Stata manual</a>
</p>
<p><strong>1:1</strong>: specifies a one-to-one match merge. The variables specified in
<code>by</code>  uniquely identify single observations in both table.
</p>
<p><strong>1:m and m:1</strong>: specify <em>one-to-many</em> and <em>many-to-one</em> match merges,
respectively. This means that in of the tables the observations are
uniquely identify by the variables in <code>by</code>, while in the other table many
(two or more)  of the observations are identify by the variables in <code>by</code>
</p>
<p><strong>m:m</strong> refers to <em>many-to-many merge</em>. variables in <code>by</code> does not uniquely
identify the observations in either table. Matching is performed by
combining observations with equal values in <code>by</code>; within matching values,
the first observation in the master (i.e. left or x) table is matched with
the first matching observation in the using (i.e. right or y) table; the
second, with the second; and so on. If there is an unequal number of
observations within a group, then the last observation of the shorter group
is used repeatedly to match with subsequent observations of the longer
group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple merge
library(data.table)
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
t  = c(1L, 2L, 1L, 2L, NA_integer_),
x  = 11:15)

y1 = data.table(id = 1:2,
                y  = c(11L, 15L))

x2 = data.table(id = c(1, 1, 2, 3, NA),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = c(16, 12, NA, NA, 15))

y2 = data.table(id = c(1, 2, 5, 6, 3),
              yd = c(1, 2, 5, 6, 3),
              y  = c(11L, 15L, 20L, 13L, 10L),
              x  = c(16:20))
merge(x1, y1)

# Bad merge for not specifying by argument
merge(x2, y2)

# good merge, ignoring variable x from y
merge(x2, y2, by = "id")

# update NAs in x variable form x
merge(x2, y2, by = "id", update_NAs = TRUE)

# Update values in x with variables from y
merge(x2, y2, by = "id", update_values = TRUE)

</code></pre>

<hr>
<h2 id='possible_ids'>Find possible unique identifies of data frame</h2><span id='topic+possible_ids'></span>

<h3>Description</h3>

<p>Find possible unique identifies of data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possible_ids(
  dt,
  exclude = NULL,
  include = NULL,
  verbose = getOption("possible_ids.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="possible_ids_+3A_dt">dt</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_exclude">exclude</code></td>
<td>
<p>character: Exclude variables to be selected as identifiers. It
could be either the name of the variables of one type of the variable
prefixed by &quot;_&quot;. For instance, &quot;_numeric&quot; or &quot;_character&quot;.</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_include">include</code></td>
<td>
<p>character: Name of variable to be included, that might belong
to the group excluded in the <code>exclude</code></p>
</td></tr>
<tr><td><code id="possible_ids_+3A_verbose">verbose</code></td>
<td>
<p>logical: If FALSE no message will be displayed. Default is
TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with possible identifiers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x4 = data.table(id1 = c(1, 1, 2, 3, 3),
                id2 = c(1, 1, 2, 3, 4),
                t   = c(1L, 2L, 1L, 2L, NA_integer_),
                x   = c(16, 12, NA, NA, 15))
possible_ids(x4)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
