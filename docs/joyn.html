<!DOCTYPE html><html lang="en"><head><title>Help for package joyn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {joyn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#joyn-package'><p>joyn: Tool for Diagnosis of Tables Joins and Complementary Join Features</p></a></li>
<li><a href='#anti_join'><p>Anti join on two data frames</p></a></li>
<li><a href='#arguments_checks'><p>Perform necessary preliminary checks on arguments that are passed to joyn</p></a></li>
<li><a href='#check_by_vars'><p>Check <code>by</code> input</p></a></li>
<li><a href='#check_dt_by'><p>Check dt <code>by</code> vars</p></a></li>
<li><a href='#check_duplicate_names'><p>Check if vars in dt have duplicate names</p></a></li>
<li><a href='#check_match_type'><p>Check match type consistency</p></a></li>
<li><a href='#check_new_y_vars'><p>Rename vars in y so they are different to x's when joined</p></a></li>
<li><a href='#check_reportvar'><p>Check reporting variable</p></a></li>
<li><a href='#check_unmatched_keys'><p>Conduct all unmatched keys checks and return error if necessary</p></a></li>
<li><a href='#check_xy'><p>Check tables X and Y</p></a></li>
<li><a href='#check_y_vars_to_keep'><p>Check variables in y that will be kept in returning table</p></a></li>
<li><a href='#clear_joynenv'><p>Clearing joyn environment</p></a></li>
<li><a href='#correct_names'><p>Function used to correct names in input data frames using <code>by</code> argument</p></a></li>
<li><a href='#create_ids'><p>Create variables that uniquely identify rows in a data table</p></a></li>
<li><a href='#freq_table'><p>Tabulate simple frequencies</p></a></li>
<li><a href='#full_join'><p>Full join two data frames</p></a></li>
<li><a href='#get_joyn_options'><p>Get joyn options</p></a></li>
<li><a href='#inner_join'><p>Inner join two data frames</p></a></li>
<li><a href='#is_balanced'><p>Is data frame balanced by group?</p></a></li>
<li><a href='#is_id'><p>Check if dt is uniquely identified by <code>by</code> variable</p></a></li>
<li><a href='#is_match_type_error'><p>Confirm if match type error</p></a></li>
<li><a href='#is_valid_m_key'><p>Check whether specified &quot;many&quot; relationship is valid</p></a></li>
<li><a href='#joyn'><p>Join two tables</p></a></li>
<li><a href='#joyn_msg'><p>display type of joyn message</p></a></li>
<li><a href='#joyn_msgs_exist'><p>Presence of joyn msgs in the environment</p></a></li>
<li><a href='#joyn_report'><p>Print JOYn report table</p></a></li>
<li><a href='#joyn_workhorse'><p>Internal workhorse join function, used in the back-end of <code>joyn</code></p></a></li>
<li><a href='#left_join'><p>Left join two data frames</p></a></li>
<li><a href='#merge'><p>Merge two data frames</p></a></li>
<li><a href='#msg_type_dt'><p>convert style of joyn message to data frame containing type and message</p></a></li>
<li><a href='#possible_ids'><p>Find possible unique identifies of data frame</p></a></li>
<li><a href='#process_by_vector'><p>Process the <code>by</code> vector</p></a></li>
<li><a href='#rename_to_valid'><p>Rename to syntactically valid names</p></a></li>
<li><a href='#report_from_attr'><p>Report frequencies from attributes in report var</p></a></li>
<li><a href='#right_join'><p>Right join two data frames</p></a></li>
<li><a href='#set_col_names'><p>Add x key var and y key var (with suffixes) to x and y</p>
-when joining by different variables and keep is true</a></li>
<li><a href='#set_joyn_options'><p>Set joyn options</p></a></li>
<li><a href='#split_match_type'><p>Split matching type</p></a></li>
<li><a href='#store_checked_ids'><p>store checked variables as possible ids</p></a></li>
<li><a href='#store_joyn_msg'><p>Wrapper for store_msg function</p>
This function serves as a wrapper for the store_msg function, which is used to store various types of messages within the .joyn environment.
:errors, warnings, timing information, or info</a></li>
<li><a href='#store_msg'><p>Store joyn message to .joynenv environment</p></a></li>
<li><a href='#style'><p>style of text displayed</p></a></li>
<li><a href='#type_choices'><p>Choice of messages</p></a></li>
<li><a href='#unmatched_keys'><p>Check for unmatched keys</p></a></li>
<li><a href='#update_na_values'><p>Update NA and/or values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tool for Diagnosis of Tables Joins and Complementary Join
Features</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Tool for diagnosing table joins. It combines the speed of 'collapse'
     and 'data.table', the flexibility of 'dplyr', and the diagnosis and features 
     of the 'merge' command in 'Stata'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/randrescastaneda/joyn">https://github.com/randrescastaneda/joyn</a>,
<a href="https://randrescastaneda.github.io/joyn/">https://randrescastaneda.github.io/joyn/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/randrescastaneda/joyn/issues">https://github.com/randrescastaneda/joyn/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>badger, covr, knitr, rmarkdown, testthat (&ge; 3.0.0), withr,
dplyr, tibble</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, data.table, cli, utils, collapse (&ge; 2.0.15), lifecycle</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-13 23:00:39 UTC; wb384996</td>
</tr>
<tr>
<td>Author:</td>
<td>R.Andres Castaneda [aut, cre],
  Zander Prinsloo [aut],
  Rossana Tatulli [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>R.Andres Castaneda &lt;acastanedaa@worldbank.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-13 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='joyn-package'>joyn: Tool for Diagnosis of Tables Joins and Complementary Join Features</h2><span id='topic+joyn-package'></span>

<h3>Description</h3>

<p>Tool for diagnosing table joins. It combines the speed of 'collapse' and 'data.table', the flexibility of 'dplyr', and the diagnosis and features of the 'merge' command in 'Stata'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: R.Andres Castaneda <a href="mailto:acastanedaa@worldbank.org">acastanedaa@worldbank.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Zander Prinsloo <a href="mailto:zprinsloo@worldbank.org">zprinsloo@worldbank.org</a>
</p>
</li>
<li><p> Rossana Tatulli <a href="mailto:rtatulli@worldbank.org">rtatulli@worldbank.org</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/randrescastaneda/joyn">https://github.com/randrescastaneda/joyn</a>
</p>
</li>
<li> <p><a href="https://randrescastaneda.github.io/joyn/">https://randrescastaneda.github.io/joyn/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/randrescastaneda/joyn/issues">https://github.com/randrescastaneda/joyn/issues</a>
</p>
</li></ul>


<hr>
<h2 id='anti_join'>Anti join on two data frames</h2><span id='topic+anti_join'></span>

<h3>Description</h3>

<p>This is a <code>joyn</code> wrapper that works in a similar fashion to
<a href="dplyr.html#topic+filter-joins">dplyr::anti_join</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anti_join(
  x,
  y,
  by = intersect(names(x), names(y)),
  copy = FALSE,
  suffix = c(".x", ".y"),
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  relationship = "many-to-many",
  y_vars_to_keep = FALSE,
  reportvar = getOption("joyn.reportvar"),
  reporttype = c("factor", "character", "numeric"),
  roll = NULL,
  keep_common_vars = FALSE,
  sort = TRUE,
  verbose = getOption("joyn.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anti_join_+3A_x">x</code></td>
<td>
<p>data frame: referred to as <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_y">y</code></td>
<td>
<p>data frame: referred to as <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
joyn will do a natural join, using all variables with common names across
the two tables. A message lists the variables so that you can check they're
correct (to suppress the message, simply explicitly list the variables that
you want to join). To join by different variables on x and y use a vector
of expressions. For example, <code>by = c("a = b", "z")</code> will use &quot;a&quot; in <code>x</code>,
&quot;b&quot; in <code>y</code>, and &quot;z&quot; in both tables.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="anti_join_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="anti_join_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="anti_join_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>character: Vector of variable names in <code>y</code> that will be
kept after the merge. If TRUE (the default), it keeps all the brings all
the variables in y into x. If FALSE or NULL, it does not bring any variable
into x, but a report will be generated.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_reporttype">reporttype</code></td>
<td>
<p>character: One of <em>&quot;character&quot;</em> or <em>&quot;numeric&quot;</em>. Default is
<em>&quot;character&quot;</em>. If <em>&quot;numeric&quot;</em>, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table. See below for more information.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_roll">roll</code></td>
<td>
<p>double: <em>to be implemented</em></p>
</td></tr>
<tr><td><code id="anti_join_+3A_keep_common_vars">keep_common_vars</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable
from y when both tables have common variable names. Thus, the prefix &quot;y.&quot;
will be added to the original name to distinguish from the resulting
variable in the joined table.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_sort">sort</code></td>
<td>
<p>logical: If TRUE, sort by key variables in <code>by</code>. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
<tr><td><code id="anti_join_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+joyn">joyn</a></code>
</p>

<dl>
<dt><code>match_type</code></dt><dd><p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</dd>
<dt><code>update_NAs</code></dt><dd><p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</dd>
<dt><code>update_values</code></dt><dd><p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</dd>
<dt><code>allow.cartesian</code></dt><dd><p>logical: Check documentation in official <a href="https://rdatatable.gitlab.io/data.table/reference/merge.html/">web site</a>.
Default is <code>NULL</code>, which implies that if the join is &quot;1:1&quot; it will be
<code>FALSE</code>, but if the join has any &quot;m&quot; on it, it will be converted to <code>TRUE</code>.
By specifying <code>TRUE</code> of <code>FALSE</code> you force the behavior of the join.</p>
</dd>
<dt><code>suffixes</code></dt><dd><p>A character(2) specifying the suffixes to be used for making
non-by column names unique. The suffix behaviour works in a similar fashion
as the <a href="base.html#topic+merge">base::merge</a> method does.</p>
</dd>
<dt><code>yvars</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now <code>y_vars_to_keep</code></p>
</dd>
<dt><code>keep_y_in_x</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now
<code>keep_common_vars</code></p>
</dd>
<dt><code>msg_type</code></dt><dd><p>character: type of messages to display by default</p>
</dd>
<dt><code>na.last</code></dt><dd> <p><code>logical</code>. If <code>TRUE</code>, missing values in the data are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed.
<code>na.last=NA</code> is valid only for <code>x[order(., na.last)]</code> and its
default is <code>TRUE</code>. <code>setorder</code> and <code>setorderv</code> only accept
<code>TRUE</code>/<code>FALSE</code> with default <code>FALSE</code>. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An data frame of the same class as <code>x</code>. The properties of the output
are as close as possible to the ones returned by the dplyr alternative.
</p>


<h3>See Also</h3>

<p>Other dplyr alternatives: 
<code><a href="#topic+full_join">full_join</a>()</code>,
<code><a href="#topic+inner_join">inner_join</a>()</code>,
<code><a href="#topic+left_join">left_join</a>()</code>,
<code><a href="#topic+right_join">right_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple anti join
library(data.table)

x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
anti_join(x1, y1, relationship = "many-to-one")
</code></pre>

<hr>
<h2 id='arguments_checks'>Perform necessary preliminary checks on arguments that are passed to joyn</h2><span id='topic+arguments_checks'></span>

<h3>Description</h3>

<p>Perform necessary preliminary checks on arguments that are passed to joyn
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arguments_checks(
  x,
  y,
  by,
  copy,
  keep,
  suffix,
  na_matches,
  multiple,
  relationship,
  reportvar
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arguments_checks_+3A_x">x</code></td>
<td>
<p>data frame: left table</p>
</td></tr>
<tr><td><code id="arguments_checks_+3A_y">y</code></td>
<td>
<p>data frame: right table</p>
</td></tr>
<tr><td><code id="arguments_checks_+3A_by">by</code></td>
<td>
<p>character vector or variables to join by</p>
</td></tr>
<tr><td><code id="arguments_checks_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="arguments_checks_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="arguments_checks_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="arguments_checks_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="arguments_checks_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="arguments_checks_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
<tr><td><code id="arguments_checks_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of checked arguments to pass on to the main joyn function
</p>

<hr>
<h2 id='check_by_vars'>Check <code>by</code> input</h2><span id='topic+check_by_vars'></span>

<h3>Description</h3>

<p>This function checks the variable name(s) to be used as key(s) of the join
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_by_vars(by, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_by_vars_+3A_by">by</code></td>
<td>
<p>A vector of shared column names in <code>x</code> and <code>y</code> to merge on.
This defaults to the shared key columns between the two tables.
If <code>y</code> has no key columns, this defaults to the key of <code>x</code>.</p>
</td></tr>
<tr><td><code id="check_by_vars_+3A_x">x</code>, <code id="check_by_vars_+3A_y">y</code></td>
<td>
<p><code>data table</code>s. <code>y</code> is coerced to a <code>data.table</code> if
it isn't one already.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with information about by variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x1 = data.frame(
       id = c(1L, 1L, 2L, 3L, NA_integer_),
       t  = c(1L, 2L, 1L, 2L, NA_integer_),
       x  = 11:15)
y1 = data.frame(id = 1:2,
                y  = c(11L, 15L))
# With var "id" shared in x and y
joyn:::check_by_vars(by = "id", x = x1, y = y1)

## End(Not run)
</code></pre>

<hr>
<h2 id='check_dt_by'>Check dt <code>by</code> vars</h2><span id='topic+check_dt_by'></span>

<h3>Description</h3>

<p>check variable(s) by which data frames are joined: either a single <code>by</code> var, common to right and left dt,
or
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dt_by(x, y, by, by.x, by.y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dt_by_+3A_x">x</code></td>
<td>
<p>left table</p>
</td></tr>
<tr><td><code id="check_dt_by_+3A_y">y</code></td>
<td>
<p>right table</p>
</td></tr>
<tr><td><code id="check_dt_by_+3A_by">by</code></td>
<td>
<p>character: variable to join by (common variable to x and y)</p>
</td></tr>
<tr><td><code id="check_dt_by_+3A_by.x">by.x</code></td>
<td>
<p>character: specified var in x to join by</p>
</td></tr>
<tr><td><code id="check_dt_by_+3A_by.y">by.y</code></td>
<td>
<p>character: specified var in y to join by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character specifying checked variable(s) to join by
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x = data.table(id1 = c(1, 1, 2, 3, 3),
               id2 = c(1, 1, 2, 3, 4),
               t   = c(1L, 2L, 1L, 2L, NA_integer_),
               x   = c(16, 12, NA, NA, 15))
y = data.table(id  = c(1, 2, 5, 6, 3),
               id2 = c(1, 1, 2, 3, 4),
               y   = c(11L, 15L, 20L, 13L, 10L),
               x   = c(16:20))
# example specifying by.x and by.y
joyn:::check_dt_by(x, y, by.x = "id1", by.y = "id2")

## End(Not run)
</code></pre>

<hr>
<h2 id='check_duplicate_names'>Check if vars in dt have duplicate names</h2><span id='topic+check_duplicate_names'></span>

<h3>Description</h3>

<p>Check if vars in dt have duplicate names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_duplicate_names(dt, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_duplicate_names_+3A_dt">dt</code></td>
<td>
<p>data.frame to check</p>
</td></tr>
<tr><td><code id="check_duplicate_names_+3A_name">name</code></td>
<td>
<p>var name to check if has duplicates in dt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical either TRUE, if any duplicates are found, or FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# When no duplicates
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
joyn:::check_duplicate_names(x1, "x")

# When duplicates
x1_duplicates = data.frame(id = c(1L, 1L, 2L, 3L, NA_integer_),
                           x  = c(1L, 2L, 1L, 2L, NA_integer_),
                           x  = 11:15,
                           check.names = FALSE)
joyn:::check_duplicate_names(x1_duplicates, "x")

## End(Not run)
</code></pre>

<hr>
<h2 id='check_match_type'>Check match type consistency</h2><span id='topic+check_match_type'></span>

<h3>Description</h3>

<p>This function checks if the match type chosen by the user is consistent with the data.
<br>(Match type must be one of the valid types: &quot;1:1&quot;, &quot;1:m&quot;, &quot;m:1&quot;, &quot;m:m&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_match_type(x, y, by, match_type, verbose = getOption("joyn.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_match_type_+3A_x">x</code>, <code id="check_match_type_+3A_y">y</code></td>
<td>
<p><code>data table</code>s. <code>y</code> is coerced to a <code>data.table</code> if
it isn't one already.</p>
</td></tr>
<tr><td><code id="check_match_type_+3A_by">by</code></td>
<td>
<p>A vector of shared column names in <code>x</code> and <code>y</code> to merge on.
This defaults to the shared key columns between the two tables.
If <code>y</code> has no key columns, this defaults to the key of <code>x</code>.</p>
</td></tr>
<tr><td><code id="check_match_type_+3A_match_type">match_type</code></td>
<td>
<p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector from <a href="#topic+split_match_type">split_match_type</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Consistent match type
x1 = data.frame(
       id = c(1L, 1L, 2L, 3L, NA_integer_),
       t  = c(1L, 2L, 1L, 2L, NA_integer_),
       x  = 11:15)
y1 = data.frame(id = 1:2,
                y  = c(11L, 15L))
joyn:::check_match_type(x = x1, y=y1, by="id", match_type = "m:1")

# Inconsistent match type
joyn:::check_match_type(x = x1, y=y1, by="id", match_type = "1:1")

## End(Not run)
</code></pre>

<hr>
<h2 id='check_new_y_vars'>Rename vars in y so they are different to x's when joined</h2><span id='topic+check_new_y_vars'></span>

<h3>Description</h3>

<p>Check vars in y with same names as vars in x, and return new variables names for those y vars for the joined data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_new_y_vars(x, by, y_vars_to_keep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_new_y_vars_+3A_x">x</code></td>
<td>
<p>master table</p>
</td></tr>
<tr><td><code id="check_new_y_vars_+3A_by">by</code></td>
<td>
<p>character: by vars</p>
</td></tr>
<tr><td><code id="check_new_y_vars_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>character vector of y variables to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with new variable names for y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
y2 = data.frame(id = c(1, 2, 5, 6, 3),
                yd = c(1, 2, 5, 6, 3),
                y  = c(11L, 15L, 20L, 13L, 10L),
                x  = c(16:20))
joyn:::y_vars_to_keep &lt;- check_y_vars_to_keep(TRUE, y2, by = "id")
x2 = data.frame(id = c(1, 1, 2, 3, NA),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = c(16, 12, NA, NA, 15))
joyn:::check_new_y_vars(x = x2, by="id", y_vars_to_keep)

## End(Not run)
</code></pre>

<hr>
<h2 id='check_reportvar'>Check reporting variable</h2><span id='topic+check_reportvar'></span>

<h3>Description</h3>

<p>check reportvar input <br> If resulting data frame has a reporting variable (storing joyn's report), check and return a valid name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_reportvar(reportvar, verbose = getOption("joyn.verbose"))
</code></pre>


<h3>Value</h3>

<p>if input reportvar is character, return valid name for the report var. If NULL or FALSE, return NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# When null - reporting variable not returned in merged dt
joyn:::check_reportvar(reportvar = NULL)
# When FALSE - reporting variable not returned in merged dt
joyn:::check_reportvar(reportvar = FALSE)
# When character
joyn:::check_reportvar(reportvar = ".joyn")

## End(Not run)
</code></pre>

<hr>
<h2 id='check_unmatched_keys'>Conduct all unmatched keys checks and return error if necessary</h2><span id='topic+check_unmatched_keys'></span>

<h3>Description</h3>

<p>Conduct all unmatched keys checks and return error if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_unmatched_keys(x, y, out, by, jn_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_unmatched_keys_+3A_x">x</code></td>
<td>
<p>left table</p>
</td></tr>
<tr><td><code id="check_unmatched_keys_+3A_y">y</code></td>
<td>
<p>right table</p>
</td></tr>
<tr><td><code id="check_unmatched_keys_+3A_out">out</code></td>
<td>
<p>output from join</p>
</td></tr>
<tr><td><code id="check_unmatched_keys_+3A_by">by</code></td>
<td>
<p>character vector of keys that x and y are joined by</p>
</td></tr>
<tr><td><code id="check_unmatched_keys_+3A_jn_type">jn_type</code></td>
<td>
<p>character: &quot;left&quot;, &quot;right&quot;, or &quot;inner&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>error message
</p>

<hr>
<h2 id='check_xy'>Check tables X and Y</h2><span id='topic+check_xy'></span>

<h3>Description</h3>

<p>This function performs checks inspired on merge.data.table: it detects errors
</p>

<ul>
<li><p> if x and/or y have no columns
</p>
</li>
<li><p> if x and/or y contain duplicate column names
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>check_xy(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_xy_+3A_x">x</code></td>
<td>
<p>data frame: referred to as <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="check_xy_+3A_y">y</code></td>
<td>
<p>data frame: referred to as <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Check passing with no errors
library(data.table)
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
joyn:::check_xy(x = x1, y=y1)

## End(Not run)
</code></pre>

<hr>
<h2 id='check_y_vars_to_keep'>Check variables in y that will be kept in returning table</h2><span id='topic+check_y_vars_to_keep'></span>

<h3>Description</h3>

<p>check and return variable names in y to keep in returning table, excluding those that are keys of the merge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_y_vars_to_keep(y_vars_to_keep, y, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_y_vars_to_keep_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>either TRUE, if keep all vars in <code>y</code>;
FALSE or NULL, if keep no vars; or character vector specifying which variables in <code>y</code> to keep</p>
</td></tr>
<tr><td><code id="check_y_vars_to_keep_+3A_y">y</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="check_y_vars_to_keep_+3A_by">by</code></td>
<td>
<p>A vector of shared column names in <code>x</code> and <code>y</code> to merge on.
This defaults to the shared key columns between the two tables.
If <code>y</code> has no key columns, this defaults to the key of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with variable names from <code>y</code> table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
y1 = data.table(id = 1:2,
               y  = c(11L, 15L))
# With y_vars_to_keep TRUE
joyn:::check_y_vars_to_keep(TRUE, y1, by = "id")
# With y_vars_to_keep FALSE
joyn:::check_y_vars_to_keep(FALSE, y1, by = "id")
# Specifying which y vars to keep
joyn:::check_y_vars_to_keep("y", y1, by = "id")

## End(Not run)
</code></pre>

<hr>
<h2 id='clear_joynenv'>Clearing joyn environment</h2><span id='topic+clear_joynenv'></span>

<h3>Description</h3>

<p>Clearing joyn environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_joynenv()
</code></pre>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+joyn_msg">joyn_msg</a>()</code>,
<code><a href="#topic+joyn_msgs_exist">joyn_msgs_exist</a>()</code>,
<code><a href="#topic+joyn_report">joyn_report</a>()</code>,
<code><a href="#topic+msg_type_dt">msg_type_dt</a>()</code>,
<code><a href="#topic+store_msg">store_msg</a>()</code>,
<code><a href="#topic+style">style</a>()</code>,
<code><a href="#topic+type_choices">type_choices</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Storing a message
joyn:::store_msg("info", "simple message")

# Clearing the environment
joyn:::clear_joynenv()

# Checking it does not exist in the environment
print(joyn:::joyn_msgs_exist())

## End(Not run)
</code></pre>

<hr>
<h2 id='correct_names'>Function used to correct names in input data frames using <code>by</code> argument</h2><span id='topic+correct_names'></span>

<h3>Description</h3>

<p>Function used to correct names in input data frames using <code>by</code> argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_names(by, x, y, order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_names_+3A_by">by</code></td>
<td>
<p><code>by</code> argument parsed from higher level function</p>
</td></tr>
<tr><td><code id="correct_names_+3A_x">x</code></td>
<td>
<p>left data frame</p>
</td></tr>
<tr><td><code id="correct_names_+3A_y">y</code></td>
<td>
<p>right data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='create_ids'>Create variables that uniquely identify rows in a data table</h2><span id='topic+create_ids'></span>

<h3>Description</h3>

<p>This function generates unique identifier columns for a given number of rows, based on the specified number of identifier variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ids(n_rows, n_ids, prefix = "id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_ids_+3A_n_rows">n_rows</code></td>
<td>
<p>An integer specifying the number of rows in the data table for which unique identifiers need to be generated.</p>
</td></tr>
<tr><td><code id="create_ids_+3A_n_ids">n_ids</code></td>
<td>
<p>An integer specifying the number of identifiers to be created. If <code>n_ids</code> is 1, a simple sequence of unique IDs is created. If greater than 1, a combination of IDs is generated.</p>
</td></tr>
<tr><td><code id="create_ids_+3A_prefix">prefix</code></td>
<td>
<p>A character string specifying the prefix for the identifier variable names (default is <code>"id"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list where each element is a vector representing a unique identifier column. The number of elements in the list corresponds to the number of identifier variables (<code>n_ids</code>). The length of each element is equal to <code>n_rows</code>.
</p>

<hr>
<h2 id='freq_table'>Tabulate simple frequencies</h2><span id='topic+freq_table'></span>

<h3>Description</h3>

<p>tabulate one variable frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_table(x, byvar, digits = 1, na.rm = FALSE, freq_var_name = "n")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freq_table_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="freq_table_+3A_byvar">byvar</code></td>
<td>
<p>character: name of variable to tabulate. Use Standard evaluation.</p>
</td></tr>
<tr><td><code id="freq_table_+3A_digits">digits</code></td>
<td>
<p>numeric: number of decimal places to display. Default is 1.</p>
</td></tr>
<tr><td><code id="freq_table_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: report NA values in frequencies. Default is FALSE.</p>
</td></tr>
<tr><td><code id="freq_table_+3A_freq_var_name">freq_var_name</code></td>
<td>
<p>character: name for frequency variable. Default is &quot;n&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x4 = data.table(id1 = c(1, 1, 2, 3, 3),
                id2 = c(1, 1, 2, 3, 4),
                t   = c(1L, 2L, 1L, 2L, NA_integer_),
                x   = c(16, 12, NA, NA, 15))
freq_table(x4, "id1")
</code></pre>

<hr>
<h2 id='full_join'>Full join two data frames</h2><span id='topic+full_join'></span>

<h3>Description</h3>

<p>This is a <code>joyn</code> wrapper that works in a similar
fashion to <a href="dplyr.html#topic+mutate-joins">dplyr::full_join</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_join(
  x,
  y,
  by = intersect(names(x), names(y)),
  copy = FALSE,
  suffix = c(".x", ".y"),
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = "one-to-one",
  y_vars_to_keep = TRUE,
  update_values = FALSE,
  update_NAs = update_values,
  reportvar = getOption("joyn.reportvar"),
  reporttype = c("factor", "character", "numeric"),
  roll = NULL,
  keep_common_vars = FALSE,
  sort = TRUE,
  verbose = getOption("joyn.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full_join_+3A_x">x</code></td>
<td>
<p>data frame: referred to as <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="full_join_+3A_y">y</code></td>
<td>
<p>data frame: referred to as <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="full_join_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
joyn will do a natural join, using all variables with common names across
the two tables. A message lists the variables so that you can check they're
correct (to suppress the message, simply explicitly list the variables that
you want to join). To join by different variables on x and y use a vector
of expressions. For example, <code>by = c("a = b", "z")</code> will use &quot;a&quot; in <code>x</code>, &quot;b&quot;
in <code>y</code>, and &quot;z&quot; in both tables.</p>
</td></tr>
<tr><td><code id="full_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="full_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="full_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="full_join_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="full_join_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="full_join_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="full_join_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
<tr><td><code id="full_join_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>character: Vector of variable names in <code>y</code> that will be
kept after the merge. If TRUE (the default), it keeps all the brings all
the variables in y into x. If FALSE or NULL, it does not bring any variable
into x, but a report will be generated.</p>
</td></tr>
<tr><td><code id="full_join_+3A_update_values">update_values</code></td>
<td>
<p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</td></tr>
<tr><td><code id="full_join_+3A_update_nas">update_NAs</code></td>
<td>
<p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="full_join_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="full_join_+3A_reporttype">reporttype</code></td>
<td>
<p>character: One of <em>&quot;character&quot;</em> or <em>&quot;numeric&quot;</em>. Default is
<em>&quot;character&quot;</em>. If <em>&quot;numeric&quot;</em>, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table. See below for more information.</p>
</td></tr>
<tr><td><code id="full_join_+3A_roll">roll</code></td>
<td>
<p>double: <em>to be implemented</em></p>
</td></tr>
<tr><td><code id="full_join_+3A_keep_common_vars">keep_common_vars</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable
from y when both tables have common variable names. Thus, the prefix &quot;y.&quot;
will be added to the original name to distinguish from the resulting
variable in the joined table.</p>
</td></tr>
<tr><td><code id="full_join_+3A_sort">sort</code></td>
<td>
<p>logical: If TRUE, sort by key variables in <code>by</code>. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="full_join_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
<tr><td><code id="full_join_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+joyn">joyn</a></code>
</p>

<dl>
<dt><code>match_type</code></dt><dd><p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</dd>
<dt><code>allow.cartesian</code></dt><dd><p>logical: Check documentation in official <a href="https://rdatatable.gitlab.io/data.table/reference/merge.html/">web site</a>.
Default is <code>NULL</code>, which implies that if the join is &quot;1:1&quot; it will be
<code>FALSE</code>, but if the join has any &quot;m&quot; on it, it will be converted to <code>TRUE</code>.
By specifying <code>TRUE</code> of <code>FALSE</code> you force the behavior of the join.</p>
</dd>
<dt><code>suffixes</code></dt><dd><p>A character(2) specifying the suffixes to be used for making
non-by column names unique. The suffix behaviour works in a similar fashion
as the <a href="base.html#topic+merge">base::merge</a> method does.</p>
</dd>
<dt><code>yvars</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now <code>y_vars_to_keep</code></p>
</dd>
<dt><code>keep_y_in_x</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now
<code>keep_common_vars</code></p>
</dd>
<dt><code>msg_type</code></dt><dd><p>character: type of messages to display by default</p>
</dd>
<dt><code>na.last</code></dt><dd> <p><code>logical</code>. If <code>TRUE</code>, missing values in the data are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed.
<code>na.last=NA</code> is valid only for <code>x[order(., na.last)]</code> and its
default is <code>TRUE</code>. <code>setorder</code> and <code>setorderv</code> only accept
<code>TRUE</code>/<code>FALSE</code> with default <code>FALSE</code>. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An data frame of the same class as <code>x</code>. The properties of the output
are as close as possible to the ones returned by the dplyr alternative.
</p>


<h3>See Also</h3>

<p>Other dplyr alternatives: 
<code><a href="#topic+anti_join">anti_join</a>()</code>,
<code><a href="#topic+inner_join">inner_join</a>()</code>,
<code><a href="#topic+left_join">left_join</a>()</code>,
<code><a href="#topic+right_join">right_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple full join
library(data.table)

x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
full_join(x1, y1, relationship = "many-to-one")
</code></pre>

<hr>
<h2 id='get_joyn_options'>Get joyn options</h2><span id='topic+get_joyn_options'></span>

<h3>Description</h3>

<p>This function aims to display and store info on joyn options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_joyn_options(env = .joynenv, display = TRUE, option = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_joyn_options_+3A_env">env</code></td>
<td>
<p>environment, which is joyn environment by default</p>
</td></tr>
<tr><td><code id="get_joyn_options_+3A_display">display</code></td>
<td>
<p>logical, if TRUE displays (i.e., print) info on joyn options and
corresponding default and current values</p>
</td></tr>
<tr><td><code id="get_joyn_options_+3A_option">option</code></td>
<td>
<p>character or NULL. If character, name of a specific joyn option.
If NULL, all joyn options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>joyn options and values invisibly as a list
</p>


<h3>See Also</h3>

<p>JOYn options functions
<code><a href="#topic+set_joyn_options">set_joyn_options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# display all joyn options, their default and current values
joyn:::get_joyn_options()

# store list of option = value pairs AND do not display info
joyn_options &lt;- joyn:::get_joyn_options(display = FALSE)

# get info on one specific option and store it
joyn.verbose &lt;- joyn:::get_joyn_options(option = "joyn.verbose")

# get info on two specific option
joyn:::get_joyn_options(option = c("joyn.verbose", "joyn.reportvar"))


## End(Not run)
</code></pre>

<hr>
<h2 id='inner_join'>Inner join two data frames</h2><span id='topic+inner_join'></span>

<h3>Description</h3>

<p>This is a <code>joyn</code> wrapper that works in a similar fashion to
<a href="dplyr.html#topic+mutate-joins">dplyr::inner_join</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_join(
  x,
  y,
  by = intersect(names(x), names(y)),
  copy = FALSE,
  suffix = c(".x", ".y"),
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = "one-to-one",
  y_vars_to_keep = TRUE,
  update_values = FALSE,
  update_NAs = update_values,
  reportvar = getOption("joyn.reportvar"),
  reporttype = c("factor", "character", "numeric"),
  roll = NULL,
  keep_common_vars = FALSE,
  sort = TRUE,
  verbose = getOption("joyn.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_join_+3A_x">x</code></td>
<td>
<p>data frame: referred to as <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_y">y</code></td>
<td>
<p>data frame: referred to as <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
joyn will do a natural join, using all variables with common names across
the two tables. A message lists the variables so that you can check they're
correct (to suppress the message, simply explicitly list the variables that
you want to join). To join by different variables on x and y use a vector
of expressions. For example, <code>by = c("a = b", "z")</code> will use &quot;a&quot; in <code>x</code>,
&quot;b&quot; in <code>y</code>, and &quot;z&quot; in both tables.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>character: Vector of variable names in <code>y</code> that will be
kept after the merge. If TRUE (the default), it keeps all the brings all
the variables in y into x. If FALSE or NULL, it does not bring any variable
into x, but a report will be generated.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_update_values">update_values</code></td>
<td>
<p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</td></tr>
<tr><td><code id="inner_join_+3A_update_nas">update_NAs</code></td>
<td>
<p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="inner_join_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_reporttype">reporttype</code></td>
<td>
<p>character: One of <em>&quot;character&quot;</em> or <em>&quot;numeric&quot;</em>. Default is
<em>&quot;character&quot;</em>. If <em>&quot;numeric&quot;</em>, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table. See below for more information.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_roll">roll</code></td>
<td>
<p>double: <em>to be implemented</em></p>
</td></tr>
<tr><td><code id="inner_join_+3A_keep_common_vars">keep_common_vars</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable
from y when both tables have common variable names. Thus, the prefix &quot;y.&quot;
will be added to the original name to distinguish from the resulting
variable in the joined table.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_sort">sort</code></td>
<td>
<p>logical: If TRUE, sort by key variables in <code>by</code>. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+joyn">joyn</a></code>
</p>

<dl>
<dt><code>match_type</code></dt><dd><p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</dd>
<dt><code>allow.cartesian</code></dt><dd><p>logical: Check documentation in official <a href="https://rdatatable.gitlab.io/data.table/reference/merge.html/">web site</a>.
Default is <code>NULL</code>, which implies that if the join is &quot;1:1&quot; it will be
<code>FALSE</code>, but if the join has any &quot;m&quot; on it, it will be converted to <code>TRUE</code>.
By specifying <code>TRUE</code> of <code>FALSE</code> you force the behavior of the join.</p>
</dd>
<dt><code>suffixes</code></dt><dd><p>A character(2) specifying the suffixes to be used for making
non-by column names unique. The suffix behaviour works in a similar fashion
as the <a href="base.html#topic+merge">base::merge</a> method does.</p>
</dd>
<dt><code>yvars</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now <code>y_vars_to_keep</code></p>
</dd>
<dt><code>keep_y_in_x</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now
<code>keep_common_vars</code></p>
</dd>
<dt><code>msg_type</code></dt><dd><p>character: type of messages to display by default</p>
</dd>
<dt><code>na.last</code></dt><dd> <p><code>logical</code>. If <code>TRUE</code>, missing values in the data are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed.
<code>na.last=NA</code> is valid only for <code>x[order(., na.last)]</code> and its
default is <code>TRUE</code>. <code>setorder</code> and <code>setorderv</code> only accept
<code>TRUE</code>/<code>FALSE</code> with default <code>FALSE</code>. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An data frame of the same class as <code>x</code>. The properties of the output
are as close as possible to the ones returned by the dplyr alternative.
</p>


<h3>See Also</h3>

<p>Other dplyr alternatives: 
<code><a href="#topic+anti_join">anti_join</a>()</code>,
<code><a href="#topic+full_join">full_join</a>()</code>,
<code><a href="#topic+left_join">left_join</a>()</code>,
<code><a href="#topic+right_join">right_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple full join
library(data.table)

x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
inner_join(x1, y1, relationship = "many-to-one")
</code></pre>

<hr>
<h2 id='is_balanced'>Is data frame balanced by group?</h2><span id='topic+is_balanced'></span>

<h3>Description</h3>

<p>Check if the data frame is balanced by group of columns, i.e., if it contains every combination of the elements in the specified variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_balanced(df, by, return = c("logic", "table"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_balanced_+3A_df">df</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="is_balanced_+3A_by">by</code></td>
<td>
<p>character: variables used to check if <code>df</code> is balanced</p>
</td></tr>
<tr><td><code id="is_balanced_+3A_return">return</code></td>
<td>
<p>character: either &quot;logic&quot; or &quot;table&quot;. If &quot;logic&quot;, returns <code>TRUE</code>
or <code>FALSE</code> depending on whether data frame is balanced. If &quot;table&quot; returns the unbalanced
observations - i.e. the combinations of elements in specified variables not found in input <code>df</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, if return == &quot;logic&quot;, else returns data frame of unbalanced observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 = data.frame(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
is_balanced(df = x1,
            by = c("id", "t"),
            return = "table") # returns combination of elements in "id" and "t" not present in df
is_balanced(df = x1,
            by = c("id", "t"),
            return = "logic") # FALSE
</code></pre>

<hr>
<h2 id='is_id'>Check if dt is uniquely identified by <code>by</code> variable</h2><span id='topic+is_id'></span>

<h3>Description</h3>

<p>report if dt is uniquely identified by <code>by</code> var or, if report = TRUE, the duplicates in <code>by</code> variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_id(
  dt,
  by,
  verbose = getOption("joyn.verbose", default = FALSE),
  return_report = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_id_+3A_dt">dt</code></td>
<td>
<p>either right of left table</p>
</td></tr>
<tr><td><code id="is_id_+3A_by">by</code></td>
<td>
<p>variable to merge by</p>
</td></tr>
<tr><td><code id="is_id_+3A_verbose">verbose</code></td>
<td>
<p>logical: if TRUE messages will be displayed</p>
</td></tr>
<tr><td><code id="is_id_+3A_return_report">return_report</code></td>
<td>
<p>logical: if TRUE, returns data with summary of duplicates.
If FALSE, returns logical value depending on whether <code>dt</code> is uniquely identified
by <code>by</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical or data.frame, depending on the value of argument <code>return_report</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

# example with data frame not uniquely identified by `by` var

y &lt;- data.table(id = c("c","b", "c", "a"),
                 y  = c(11L, 15L, 18L, 20L))
is_id(y, by = "id")
is_id(y, by = "id", return_report = TRUE)

# example with data frame uniquely identified by `by` var

y1 &lt;- data.table(id = c("1","3", "2", "9"),
                 y  = c(11L, 15L, 18L, 20L))
is_id(y1, by = "id")
</code></pre>

<hr>
<h2 id='is_match_type_error'>Confirm if match type error</h2><span id='topic+is_match_type_error'></span>

<h3>Description</h3>

<p>Confirm if match type error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_match_type_error(x, name, by, verbose, match_type_error)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_match_type_error_+3A_name">name</code></td>
<td>
<p>name of data frame</p>
</td></tr>
<tr><td><code id="is_match_type_error_+3A_by">by</code></td>
<td>
<p>A vector of shared column names in <code>x</code> and <code>y</code> to merge on.
This defaults to the shared key columns between the two tables.
If <code>y</code> has no key columns, this defaults to the key of <code>x</code>.</p>
</td></tr>
<tr><td><code id="is_match_type_error_+3A_match_type_error">match_type_error</code></td>
<td>
<p>logical: from existing code</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example with dt not uniquely identified by "id"
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
joyn:::is_match_type_error(x1, name = "x1", by = "id")

## End(Not run)
</code></pre>

<hr>
<h2 id='is_valid_m_key'>Check whether specified &quot;many&quot; relationship is valid</h2><span id='topic+is_valid_m_key'></span>

<h3>Description</h3>

<p>When &quot;many&quot; relationship is specified, check if it is valid. <br> (Specified many relationship not valid if the dt is instead uniquely identified by specified keys)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_m_key(dt, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_valid_m_key_+3A_dt">dt</code></td>
<td>
<p>data object</p>
</td></tr>
<tr><td><code id="is_valid_m_key_+3A_by">by</code></td>
<td>
<p>character vector: specified keys, already fixed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: <code>TRUE</code> if valid, <code>FALSE</code> if uniquely identified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example with data frame uniquely identified by specified `by` vars
x1 = data.frame(id  = c(1L, 1L, 2L, 3L, NA_integer_),
                 t  = c(1L, 2L, 1L, 2L, NA_integer_),
                 x  = 11:15)

joyn:::is_valid_m_key(x1, by = c("id", "t"))
# example with valid specified "many" relationship
x2 = data.frame(id  = c(1L, 1L, 1L, 3L, NA_integer_),
                 t  = c(1L, 2L, 1L, 2L, NA_integer_),
                 x  = 11:15)
joyn:::is_valid_m_key(x2, by = c("id", "t"))

## End(Not run)
</code></pre>

<hr>
<h2 id='joyn'>Join two tables</h2><span id='topic+joyn'></span>

<h3>Description</h3>

<p>This is the primary function in the <code>joyn</code> package. It executes a full join,
performs a number of checks, and filters to allow the user-specified join.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joyn(
  x,
  y,
  by = intersect(names(x), names(y)),
  match_type = c("1:1", "1:m", "m:1", "m:m"),
  keep = c("full", "left", "master", "right", "using", "inner", "anti"),
  y_vars_to_keep = ifelse(keep == "anti", FALSE, TRUE),
  update_values = FALSE,
  update_NAs = update_values,
  reportvar = getOption("joyn.reportvar"),
  reporttype = c("factor", "character", "numeric"),
  roll = NULL,
  keep_common_vars = FALSE,
  sort = FALSE,
  verbose = getOption("joyn.verbose"),
  suffixes = getOption("joyn.suffixes"),
  allow.cartesian = deprecated(),
  yvars = deprecated(),
  keep_y_in_x = deprecated(),
  na.last = getOption("joyn.na.last"),
  msg_type = getOption("joyn.msg_type")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joyn_+3A_x">x</code></td>
<td>
<p>data frame: referred to as <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="joyn_+3A_y">y</code></td>
<td>
<p>data frame: referred to as <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="joyn_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
joyn will do a natural join, using all variables with common names across
the two tables. A message lists the variables so that you can check they're
correct (to suppress the message, simply explicitly list the variables that
you want to join). To join by different variables on x and y use a vector
of expressions. For example, <code>by = c("a = b", "z")</code> will use &quot;a&quot; in <code>x</code>,
&quot;b&quot; in <code>y</code>, and &quot;z&quot; in both tables.</p>
</td></tr>
<tr><td><code id="joyn_+3A_match_type">match_type</code></td>
<td>
<p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</td></tr>
<tr><td><code id="joyn_+3A_keep">keep</code></td>
<td>
<p>atomic character vector of length 1: One of <em>&quot;full&quot;</em>, <em>&quot;left&quot;</em>,
<em>&quot;master&quot;</em>, <em>&quot;right&quot;</em>,
<em>&quot;using&quot;</em>, <em>&quot;inner&quot;</em>. Default is <em>&quot;full&quot;</em>. Even though this is not the
regular behavior of joins in R, the objective of <code>joyn</code> is to present a
diagnosis of the join which requires a full join. That is why the default
is a a full join. Yet, if <em>&quot;left&quot;</em> or <em>&quot;master&quot;</em>, it keeps the observations
that matched in both tables and the ones that did not match in x. The ones
in y will be discarded. If <em>&quot;right&quot;</em> or <em>&quot;using&quot;</em>, it keeps the
observations that matched in both tables and the ones that did not match in
y. The ones in x will be discarded. If <em>&quot;inner&quot;</em>, it only keeps the
observations that matched both tables. Note that if, for example, a <code style="white-space: pre;">&#8288;keep = "left", the &#8288;</code>joyn()<code style="white-space: pre;">&#8288;function still executes a full join under the hood and then filters so that only rows the output table is a left join. This behaviour, while inefficient, allows all the diagnostics and checks conducted by&#8288;</code>joyn'.</p>
</td></tr>
<tr><td><code id="joyn_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>character: Vector of variable names in <code>y</code> that will be
kept after the merge. If TRUE (the default), it keeps all the brings all
the variables in y into x. If FALSE or NULL, it does not bring any variable
into x, but a report will be generated.</p>
</td></tr>
<tr><td><code id="joyn_+3A_update_values">update_values</code></td>
<td>
<p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</td></tr>
<tr><td><code id="joyn_+3A_update_nas">update_NAs</code></td>
<td>
<p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="joyn_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="joyn_+3A_reporttype">reporttype</code></td>
<td>
<p>character: One of <em>&quot;character&quot;</em> or <em>&quot;numeric&quot;</em>. Default is
<em>&quot;character&quot;</em>. If <em>&quot;numeric&quot;</em>, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table. See below for more information.</p>
</td></tr>
<tr><td><code id="joyn_+3A_roll">roll</code></td>
<td>
<p>double: <em>to be implemented</em></p>
</td></tr>
<tr><td><code id="joyn_+3A_keep_common_vars">keep_common_vars</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable
from y when both tables have common variable names. Thus, the prefix &quot;y.&quot;
will be added to the original name to distinguish from the resulting
variable in the joined table.</p>
</td></tr>
<tr><td><code id="joyn_+3A_sort">sort</code></td>
<td>
<p>logical: If TRUE, sort by key variables in <code>by</code>. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="joyn_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
<tr><td><code id="joyn_+3A_suffixes">suffixes</code></td>
<td>
<p>A character(2) specifying the suffixes to be used for making
non-by column names unique. The suffix behaviour works in a similar fashion
as the <a href="base.html#topic+merge">base::merge</a> method does.</p>
</td></tr>
<tr><td><code id="joyn_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>logical: Check documentation in official <a href="https://rdatatable.gitlab.io/data.table/reference/merge.html/">web site</a>.
Default is <code>NULL</code>, which implies that if the join is &quot;1:1&quot; it will be
<code>FALSE</code>, but if the join has any &quot;m&quot; on it, it will be converted to <code>TRUE</code>.
By specifying <code>TRUE</code> of <code>FALSE</code> you force the behavior of the join.</p>
</td></tr>
<tr><td><code id="joyn_+3A_yvars">yvars</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now <code>y_vars_to_keep</code></p>
</td></tr>
<tr><td><code id="joyn_+3A_keep_y_in_x">keep_y_in_x</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now
<code>keep_common_vars</code></p>
</td></tr>
<tr><td><code id="joyn_+3A_na.last">na.last</code></td>
<td>
 <p><code>logical</code>. If <code>TRUE</code>, missing values in the data are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed.
<code>na.last=NA</code> is valid only for <code>x[order(., na.last)]</code> and its
default is <code>TRUE</code>. <code>setorder</code> and <code>setorderv</code> only accept
<code>TRUE</code>/<code>FALSE</code> with default <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="joyn_+3A_msg_type">msg_type</code></td>
<td>
<p>character: type of messages to display by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table joining x and y.
</p>


<h3>match types</h3>

<p>Using the same wording of the <a href="https://www.stata.com/manuals/dmerge.pdf">Stata manual</a>
</p>
<p><strong>1:1</strong>: specifies a one-to-one match merge. The variables specified in
<code>by</code>  uniquely identify single observations in both table.
</p>
<p><strong>1:m and m:1</strong>: specify <em>one-to-many</em> and <em>many-to-one</em> match merges,
respectively. This means that in of the tables the observations are
uniquely identify by the variables in <code>by</code>, while in the other table many
(two or more)  of the observations are identify by the variables in <code>by</code>
</p>
<p><strong>m:m</strong> refers to <em>many-to-many merge</em>. variables in <code>by</code> does not uniquely
identify the observations in either table. Matching is performed by
combining observations with equal values in <code>by</code>; within matching values,
the first observation in the master (i.e. left or x) table is matched with
the first matching observation in the using (i.e. right or y) table; the
second, with the second; and so on. If there is an unequal number of
observations within a group, then the last observation of the shorter group
is used repeatedly to match with subsequent observations of the longer
group.
</p>


<h3>reporttype</h3>

<p>If <code>reporttype = "numeric"</code>, then the numeric values have the following
meaning:
</p>
<p>1: row comes from <code>x</code>, i.e. &quot;x&quot; 2: row comes from <code>y</code>, i.e. &quot;y&quot; 3: row from
both <code>x</code> and <code>y</code>, i.e. &quot;x &amp; y&quot; 4: row has NA in <code>x</code> that has been updated
with <code>y</code>, i.e. &quot;NA updated&quot; 5: row has valued in <code>x</code> that has been updated
with <code>y</code>, i.e. &quot;value updated&quot; 6: row from <code>x</code> that has not been updated,
i.e. &quot;not updated&quot;
</p>


<h3>NAs order</h3>

<p><code>NA</code>s are placed either at first or at last in the
resulting data.frame depending on the value of <code>getOption("joyn.na.last")</code>.
The Default is <code>FALSE</code> as it is the default value of
<a href="data.table.html#topic+setorder">data.table::setorderv</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple join
library(data.table)
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
t  = c(1L, 2L, 1L, 2L, NA_integer_),
x  = 11:15)

y1 = data.table(id = 1:2,
                y  = c(11L, 15L))

x2 = data.table(id = c(1, 1, 2, 3, NA),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = c(16, 12, NA, NA, 15))

y2 = data.table(id = c(1, 2, 5, 6, 3),
              yd = c(1, 2, 5, 6, 3),
              y  = c(11L, 15L, 20L, 13L, 10L),
              x  = c(16:20))
joyn(x1, y1, match_type = "m:1")

# Bad merge for not specifying by argument or match_type
joyn(x2, y2)

# good merge, ignoring variable x from y
joyn(x2, y2, by = "id", match_type = "m:1")

# update NAs in x variable form x
joyn(x2, y2, by = "id", update_NAs = TRUE, match_type = "m:1")

# Update values in x with variables from y
joyn(x2, y2, by = "id", update_values = TRUE, match_type = "m:1")

</code></pre>

<hr>
<h2 id='joyn_msg'>display type of joyn message</h2><span id='topic+joyn_msg'></span>

<h3>Description</h3>

<p>display type of joyn message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joyn_msg(msg_type = getOption("joyn.msg_type"), msg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joyn_msg_+3A_msg_type">msg_type</code></td>
<td>
<p>character: one or more of the following:
all, basic, info, note, warn, timing, or err</p>
</td></tr>
<tr><td><code id="joyn_msg_+3A_msg">msg</code></td>
<td>
<p>character vector to be parsed to <code><a href="cli.html#topic+cli_abort">cli::cli_abort()</a></code>. Default is
NULL. It only works if <code>"err" %in% msg_type</code>. This is an internal argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns data frame with message invisibly. print message in console
</p>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+clear_joynenv">clear_joynenv</a>()</code>,
<code><a href="#topic+joyn_msgs_exist">joyn_msgs_exist</a>()</code>,
<code><a href="#topic+joyn_report">joyn_report</a>()</code>,
<code><a href="#topic+msg_type_dt">msg_type_dt</a>()</code>,
<code><a href="#topic+store_msg">store_msg</a>()</code>,
<code><a href="#topic+style">style</a>()</code>,
<code><a href="#topic+type_choices">type_choices</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
t  = c(1L, 2L, 1L, 2L, NA_integer_),
x  = 11:15)

y1 = data.table(id = 1:2,
                y  = c(11L, 15L))
df &lt;- joyn(x1, y1, match_type = "m:1")
joyn_msg("basic")
joyn_msg("all")
</code></pre>

<hr>
<h2 id='joyn_msgs_exist'>Presence of joyn msgs in the environment</h2><span id='topic+joyn_msgs_exist'></span>

<h3>Description</h3>

<p>Checks the presence of joyn messages stored in joyn environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joyn_msgs_exist()
</code></pre>


<h3>Value</h3>

<p>invisible TRUE
</p>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+clear_joynenv">clear_joynenv</a>()</code>,
<code><a href="#topic+joyn_msg">joyn_msg</a>()</code>,
<code><a href="#topic+joyn_report">joyn_report</a>()</code>,
<code><a href="#topic+msg_type_dt">msg_type_dt</a>()</code>,
<code><a href="#topic+store_msg">store_msg</a>()</code>,
<code><a href="#topic+style">style</a>()</code>,
<code><a href="#topic+type_choices">type_choices</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Storing a message
joyn:::store_msg("info", "simple message")
Checking if it exists in the environment
print(joyn:::joyn_msgs_exist())

## End(Not run)
</code></pre>

<hr>
<h2 id='joyn_report'>Print JOYn report table</h2><span id='topic+joyn_report'></span>

<h3>Description</h3>

<p>Print JOYn report table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joyn_report(verbose = getOption("joyn.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joyn_report_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible table of frequencies
</p>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+clear_joynenv">clear_joynenv</a>()</code>,
<code><a href="#topic+joyn_msg">joyn_msg</a>()</code>,
<code><a href="#topic+joyn_msgs_exist">joyn_msgs_exist</a>()</code>,
<code><a href="#topic+msg_type_dt">msg_type_dt</a>()</code>,
<code><a href="#topic+store_msg">store_msg</a>()</code>,
<code><a href="#topic+style">style</a>()</code>,
<code><a href="#topic+type_choices">type_choices</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
t  = c(1L, 2L, 1L, 2L, NA_integer_),
x  = 11:15)

y1 = data.table(id = 1:2,
                y  = c(11L, 15L))

d &lt;- joyn(x1, y1, match_type = "m:1")
joyn_report(verbose = TRUE)
</code></pre>

<hr>
<h2 id='joyn_workhorse'>Internal workhorse join function, used in the back-end of <code>joyn</code></h2><span id='topic+joyn_workhorse'></span>

<h3>Description</h3>

<p>Always executes a full join.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joyn_workhorse(
  x,
  y,
  by = intersect(names(x), names(y)),
  sort = FALSE,
  suffixes = getOption("joyn.suffixes"),
  reportvar = getOption("joyn.reportvar")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joyn_workhorse_+3A_x">x</code></td>
<td>
<p>data object, &quot;left&quot; or &quot;master&quot;</p>
</td></tr>
<tr><td><code id="joyn_workhorse_+3A_y">y</code></td>
<td>
<p>data object, &quot;right&quot; or &quot;using&quot;</p>
</td></tr>
<tr><td><code id="joyn_workhorse_+3A_by">by</code></td>
<td>
<p>atomic character vector: key specifying join</p>
</td></tr>
<tr><td><code id="joyn_workhorse_+3A_sort">sort</code></td>
<td>
<p>logical: sort the result by the columns in <code>by</code>
<code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="joyn_workhorse_+3A_suffixes">suffixes</code></td>
<td>
<p>atomic character vector: give suffixes to columns common to both</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data object of same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Full join
library(data.table)
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
joyn:::joyn_workhorse(x = x1, y=y1)

## End(Not run)
</code></pre>

<hr>
<h2 id='left_join'>Left join two data frames</h2><span id='topic+left_join'></span>

<h3>Description</h3>

<p>This is a <code>joyn</code> wrapper that works in a similar
fashion to <a href="dplyr.html#topic+mutate-joins">dplyr::left_join</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left_join(
  x,
  y,
  by = intersect(names(x), names(y)),
  copy = FALSE,
  suffix = c(".x", ".y"),
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL,
  y_vars_to_keep = TRUE,
  update_values = FALSE,
  update_NAs = update_values,
  reportvar = getOption("joyn.reportvar"),
  reporttype = c("factor", "character", "numeric"),
  roll = NULL,
  keep_common_vars = FALSE,
  sort = TRUE,
  verbose = getOption("joyn.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="left_join_+3A_x">x</code></td>
<td>
<p>data frame: referred to as <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="left_join_+3A_y">y</code></td>
<td>
<p>data frame: referred to as <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="left_join_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
joyn will do a natural join, using all variables with common names across
the two tables. A message lists the variables so that you can check they're
correct (to suppress the message, simply explicitly list the variables that
you want to join). To join by different variables on x and y use a vector
of expressions. For example, <code>by = c("a = b", "z")</code> will use &quot;a&quot; in <code>x</code>, &quot;b&quot;
in <code>y</code>, and &quot;z&quot; in both tables.</p>
</td></tr>
<tr><td><code id="left_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="left_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="left_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
<tr><td><code id="left_join_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>character: Vector of variable names in <code>y</code> that will be
kept after the merge. If TRUE (the default), it keeps all the brings all
the variables in y into x. If FALSE or NULL, it does not bring any variable
into x, but a report will be generated.</p>
</td></tr>
<tr><td><code id="left_join_+3A_update_values">update_values</code></td>
<td>
<p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</td></tr>
<tr><td><code id="left_join_+3A_update_nas">update_NAs</code></td>
<td>
<p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="left_join_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="left_join_+3A_reporttype">reporttype</code></td>
<td>
<p>character: One of <em>&quot;character&quot;</em> or <em>&quot;numeric&quot;</em>. Default is
<em>&quot;character&quot;</em>. If <em>&quot;numeric&quot;</em>, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table. See below for more information.</p>
</td></tr>
<tr><td><code id="left_join_+3A_roll">roll</code></td>
<td>
<p>double: <em>to be implemented</em></p>
</td></tr>
<tr><td><code id="left_join_+3A_keep_common_vars">keep_common_vars</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable
from y when both tables have common variable names. Thus, the prefix &quot;y.&quot;
will be added to the original name to distinguish from the resulting
variable in the joined table.</p>
</td></tr>
<tr><td><code id="left_join_+3A_sort">sort</code></td>
<td>
<p>logical: If TRUE, sort by key variables in <code>by</code>. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="left_join_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
<tr><td><code id="left_join_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+joyn">joyn</a></code>
</p>

<dl>
<dt><code>match_type</code></dt><dd><p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</dd>
<dt><code>allow.cartesian</code></dt><dd><p>logical: Check documentation in official <a href="https://rdatatable.gitlab.io/data.table/reference/merge.html/">web site</a>.
Default is <code>NULL</code>, which implies that if the join is &quot;1:1&quot; it will be
<code>FALSE</code>, but if the join has any &quot;m&quot; on it, it will be converted to <code>TRUE</code>.
By specifying <code>TRUE</code> of <code>FALSE</code> you force the behavior of the join.</p>
</dd>
<dt><code>suffixes</code></dt><dd><p>A character(2) specifying the suffixes to be used for making
non-by column names unique. The suffix behaviour works in a similar fashion
as the <a href="base.html#topic+merge">base::merge</a> method does.</p>
</dd>
<dt><code>yvars</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now <code>y_vars_to_keep</code></p>
</dd>
<dt><code>keep_y_in_x</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now
<code>keep_common_vars</code></p>
</dd>
<dt><code>msg_type</code></dt><dd><p>character: type of messages to display by default</p>
</dd>
<dt><code>na.last</code></dt><dd> <p><code>logical</code>. If <code>TRUE</code>, missing values in the data are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed.
<code>na.last=NA</code> is valid only for <code>x[order(., na.last)]</code> and its
default is <code>TRUE</code>. <code>setorder</code> and <code>setorderv</code> only accept
<code>TRUE</code>/<code>FALSE</code> with default <code>FALSE</code>. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An data frame of the same class as <code>x</code>. The properties of the output
are as close as possible to the ones returned by the dplyr alternative.
</p>


<h3>See Also</h3>

<p>Other dplyr alternatives: 
<code><a href="#topic+anti_join">anti_join</a>()</code>,
<code><a href="#topic+full_join">full_join</a>()</code>,
<code><a href="#topic+inner_join">inner_join</a>()</code>,
<code><a href="#topic+right_join">right_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple left join
library(data.table)

x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
left_join(x1, y1, relationship = "many-to-one")
</code></pre>

<hr>
<h2 id='merge'>Merge two data frames</h2><span id='topic+merge'></span>

<h3>Description</h3>

<p>This is a joyn wrapper that works in a similar fashion to <a href="base.html#topic+merge">base::merge</a> and
<a href="data.table.html#topic+merge">data.table::merge</a>, which is why <a href="#topic+merge">merge</a> masks the other two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge(
  x,
  y,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  all = FALSE,
  all.x = all,
  all.y = all,
  sort = TRUE,
  suffixes = c(".x", ".y"),
  no.dups = TRUE,
  allow.cartesian = getOption("datatable.allow.cartesian"),
  match_type = c("m:m", "m:1", "1:m", "1:1"),
  keep_common_vars = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_+3A_x">x</code>, <code id="merge_+3A_y">y</code></td>
<td>
<p><code>data table</code>s. <code>y</code> is coerced to a <code>data.table</code> if
it isn't one already.</p>
</td></tr>
<tr><td><code id="merge_+3A_by">by</code></td>
<td>
<p>A vector of shared column names in <code>x</code> and <code>y</code> to merge on.
This defaults to the shared key columns between the two tables.
If <code>y</code> has no key columns, this defaults to the key of <code>x</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_by.x">by.x</code>, <code id="merge_+3A_by.y">by.y</code></td>
<td>
<p>Vectors of column names in <code>x</code> and <code>y</code> to merge on.</p>
</td></tr>
<tr><td><code id="merge_+3A_all">all</code></td>
<td>
<p>logical; <code>all = TRUE</code> is shorthand to save setting both
<code>all.x = TRUE</code> and <code>all.y = TRUE</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_all.x">all.x</code></td>
<td>
<p>logical; if <code>TRUE</code>, rows from <code>x</code> which have no matching row
in <code>y</code> are included. These rows will have 'NA's in the columns that are usually
filled with values from <code>y</code>. The default is <code>FALSE</code> so that only rows with
data from both <code>x</code> and <code>y</code> are included in the output.</p>
</td></tr>
<tr><td><code id="merge_+3A_all.y">all.y</code></td>
<td>
<p>logical; analogous to <code>all.x</code> above.</p>
</td></tr>
<tr><td><code id="merge_+3A_sort">sort</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the rows of the merged
<code>data.table</code> are sorted by setting the key to the <code>by / by.x</code> columns. If
<code>FALSE</code>, unlike base R's <code>merge</code> for which row order is unspecified, the
row order in <code>x</code> is retained (including retaining the position of missing entries when
<code>all.x=TRUE</code>), followed by <code>y</code> rows that don't match <code>x</code> (when <code>all.y=TRUE</code>)
retaining the order those appear in <code>y</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_suffixes">suffixes</code></td>
<td>
<p>A <code>character(2)</code> specifying the suffixes to be used for
making non-<code>by</code> column names unique. The suffix behaviour works in a similar
fashion as the <code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code> method does.</p>
</td></tr>
<tr><td><code id="merge_+3A_no.dups">no.dups</code></td>
<td>
<p>logical indicating that <code>suffixes</code> are also appended to
non-<code>by.y</code> column names in <code>y</code> when they have the same column name
as any <code>by.x</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>See <code>allow.cartesian</code> in <code><a href="data.table.html#topic++5B.data.table">[.data.table</a></code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_match_type">match_type</code></td>
<td>
<p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</td></tr>
<tr><td><code id="merge_+3A_keep_common_vars">keep_common_vars</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable
from y when both tables have common variable names. Thus, the prefix &quot;y.&quot;
will be added to the original name to distinguish from the resulting
variable in the joined table.</p>
</td></tr>
<tr><td><code id="merge_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+joyn">joyn</a></code>
</p>

<dl>
<dt><code>y_vars_to_keep</code></dt><dd><p>character: Vector of variable names in <code>y</code> that will be
kept after the merge. If TRUE (the default), it keeps all the brings all
the variables in y into x. If FALSE or NULL, it does not bring any variable
into x, but a report will be generated.</p>
</dd>
<dt><code>reportvar</code></dt><dd><p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</dd>
<dt><code>update_NAs</code></dt><dd><p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</dd>
<dt><code>update_values</code></dt><dd><p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</dd>
<dt><code>verbose</code></dt><dd><p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table merging x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 = data.frame(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.frame(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
joyn::merge(x1, y1, by = "id")
# example of using by.x and by.y
x2 = data.frame(id1 = c(1, 1, 2, 3, 3),
                id2 = c(1, 1, 2, 3, 4),
                t   = c(1L, 2L, 1L, 2L, NA_integer_),
                x   = c(16, 12, NA, NA, 15))
y2 = data.frame(id  = c(1, 2, 5, 6, 3),
                id2 = c(1, 1, 2, 3, 4),
                y   = c(11L, 15L, 20L, 13L, 10L),
                x   = c(16:20))
jn &lt;- joyn::merge(x2,
            y2,
            match_type = "m:m",
            all.x = TRUE,
            by.x = "id1",
            by.y = "id2")
# example with all = TRUE
jn &lt;- joyn::merge(x2,
            y2,
            match_type = "m:m",
            by.x = "id1",
            by.y = "id2",
            all = TRUE)
</code></pre>

<hr>
<h2 id='msg_type_dt'>convert style of joyn message to data frame containing type and message</h2><span id='topic+msg_type_dt'></span>

<h3>Description</h3>

<p>convert style of joyn message to data frame containing type and message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msg_type_dt(type, ...)
</code></pre>


<h3>Value</h3>

<p>data frame with two variables, type and msg
</p>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+clear_joynenv">clear_joynenv</a>()</code>,
<code><a href="#topic+joyn_msg">joyn_msg</a>()</code>,
<code><a href="#topic+joyn_msgs_exist">joyn_msgs_exist</a>()</code>,
<code><a href="#topic+joyn_report">joyn_report</a>()</code>,
<code><a href="#topic+store_msg">store_msg</a>()</code>,
<code><a href="#topic+style">style</a>()</code>,
<code><a href="#topic+type_choices">type_choices</a>()</code>
</p>

<hr>
<h2 id='possible_ids'>Find possible unique identifies of data frame</h2><span id='topic+possible_ids'></span>

<h3>Description</h3>

<p>Identify possible combinations of variables that  uniquely identifying dt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possible_ids(
  dt,
  vars = NULL,
  exclude = NULL,
  include = NULL,
  exclude_classes = NULL,
  include_classes = NULL,
  verbose = getOption("possible_ids.verbose", default = FALSE),
  min_combination_size = 1,
  max_combination_size = 5,
  max_processing_time = 60,
  max_numb_possible_ids = 100,
  get_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="possible_ids_+3A_dt">dt</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_vars">vars</code></td>
<td>
<p>character: A vector of variable names to consider for identifying unique combinations.</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_exclude">exclude</code></td>
<td>
<p>character: Names of variables to exclude from analysis</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_include">include</code></td>
<td>
<p>character: Name of variable to be included, that might belong
to the group excluded in the <code>exclude</code></p>
</td></tr>
<tr><td><code id="possible_ids_+3A_exclude_classes">exclude_classes</code></td>
<td>
<p>character: classes to exclude from analysis (e.g.,
&quot;numeric&quot;, &quot;integer&quot;, &quot;date&quot;)</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_include_classes">include_classes</code></td>
<td>
<p>character: classes to include in the analysis (e.g.,
&quot;numeric&quot;, &quot;integer&quot;, &quot;date&quot;)</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_verbose">verbose</code></td>
<td>
<p>logical: If FALSE no message will be displayed. Default is
TRUE</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_min_combination_size">min_combination_size</code></td>
<td>
<p>numeric: Min number of combinations. Default is
1, so all combinations.</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_max_combination_size">max_combination_size</code></td>
<td>
<p>numeric. Max number of combinations. Default is
5. If there is a combinations of identifiers larger than
<code>max_combination_size</code>, they won't be found</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_max_processing_time">max_processing_time</code></td>
<td>
<p>numeric: Max time to process in seconds. After
that, it returns what it found.</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_max_numb_possible_ids">max_numb_possible_ids</code></td>
<td>
<p>numeric: Max number of possible IDs to find. See
details.</p>
</td></tr>
<tr><td><code id="possible_ids_+3A_get_all">get_all</code></td>
<td>
<p>logical: get all possible combinations based on the parameters
above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with possible identifiers
</p>


<h3>Number of possible IDs</h3>

<p>The number of possible IDs in a dataframe could be very large. This is why,
<code>possible_ids()</code> makes use of heuristics to return something useful without
wasting the time of the user. In addition, we provide multiple parameter so
that the user can fine tune their search for possible IDs easily and
quickly.
</p>
<p>Say for instance that you have a dataframe with 10 variables. Testing every
possible pair of variables will give you 90 possible unique identifiers for
this dataframe. If you want to test all the possible IDs, you will have to
test more 5000 combinations. If the dataframe has many rows, it may take a
while.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x4 = data.table(id1 = c(1, 1, 2, 3, 3),
                id2 = c(1, 1, 2, 3, 4),
                t   = c(1L, 2L, 1L, 2L, NA_integer_),
                x   = c(16, 12, NA, NA, 15))
possible_ids(x4)
</code></pre>

<hr>
<h2 id='process_by_vector'>Process the <code>by</code> vector</h2><span id='topic+process_by_vector'></span>

<h3>Description</h3>

<p>Gives as output a vector of names to be used for the specified
table that correspond to the <code>by</code> argument for that table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_by_vector(by, input = c("left", "right"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_by_vector_+3A_by">by</code></td>
<td>
<p>character vector: by argument for join</p>
</td></tr>
<tr><td><code id="process_by_vector_+3A_input">input</code></td>
<td>
<p>character: either &quot;left&quot; or &quot;right&quot;, indicating
whether to give the left or right side of the equals (&quot;=&quot;) if
the equals is part of the <code>by</code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>joyn:::process_by_vector(by = c("An = foo", "example"), input = "left")
</code></pre>

<hr>
<h2 id='rename_to_valid'>Rename to syntactically valid names</h2><span id='topic+rename_to_valid'></span>

<h3>Description</h3>

<p>Rename to syntactically valid names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_to_valid(name, verbose = getOption("joyn.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_to_valid_+3A_name">name</code></td>
<td>
<p>character: name to be coerced to syntactically valid name</p>
</td></tr>
<tr><td><code id="rename_to_valid_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>valid character name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>joyn:::rename_to_valid("x y")
</code></pre>

<hr>
<h2 id='report_from_attr'>Report frequencies from attributes in report var</h2><span id='topic+report_from_attr'></span>

<h3>Description</h3>

<p>Report frequencies from attributes in report var
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_from_attr(x, y, reportvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="report_from_attr_+3A_x">x</code></td>
<td>
<p>dataframe from <a href="#topic+joyn_workhorse">joyn_workhorse</a></p>
</td></tr>
<tr><td><code id="report_from_attr_+3A_y">y</code></td>
<td>
<p>dataframe from original merge (&quot;right&quot; or &quot;using&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with frequencies of report var
</p>

<hr>
<h2 id='right_join'>Right join two data frames</h2><span id='topic+right_join'></span>

<h3>Description</h3>

<p>This is a <code>joyn</code> wrapper that works in a similar
fashion to <a href="dplyr.html#topic+mutate-joins">dplyr::right_join</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>right_join(
  x,
  y,
  by = intersect(names(x), names(y)),
  copy = FALSE,
  suffix = c(".x", ".y"),
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = "one-to-one",
  y_vars_to_keep = TRUE,
  update_values = FALSE,
  update_NAs = update_values,
  reportvar = getOption("joyn.reportvar"),
  reporttype = c("factor", "character", "numeric"),
  roll = NULL,
  keep_common_vars = FALSE,
  sort = TRUE,
  verbose = getOption("joyn.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="right_join_+3A_x">x</code></td>
<td>
<p>data frame: referred to as <em>left</em> in R terminology, or <em>master</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="right_join_+3A_y">y</code></td>
<td>
<p>data frame: referred to as <em>right</em> in R terminology, or <em>using</em> in
Stata terminology.</p>
</td></tr>
<tr><td><code id="right_join_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
joyn will do a natural join, using all variables with common names across
the two tables. A message lists the variables so that you can check they're
correct (to suppress the message, simply explicitly list the variables that
you want to join). To join by different variables on x and y use a vector
of expressions. For example, <code>by = c("a = b", "z")</code> will use &quot;a&quot; in <code>x</code>, &quot;b&quot;
in <code>y</code>, and &quot;z&quot; in both tables.</p>
</td></tr>
<tr><td><code id="right_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="right_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="right_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
<tr><td><code id="right_join_+3A_y_vars_to_keep">y_vars_to_keep</code></td>
<td>
<p>character: Vector of variable names in <code>y</code> that will be
kept after the merge. If TRUE (the default), it keeps all the brings all
the variables in y into x. If FALSE or NULL, it does not bring any variable
into x, but a report will be generated.</p>
</td></tr>
<tr><td><code id="right_join_+3A_update_values">update_values</code></td>
<td>
<p>logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
<strong>NAs from y won't be used to update actual values in x</strong>. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
<code>update_NAs = FALSE</code></p>
</td></tr>
<tr><td><code id="right_join_+3A_update_nas">update_NAs</code></td>
<td>
<p>logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if <code>update_values</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="right_join_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="right_join_+3A_reporttype">reporttype</code></td>
<td>
<p>character: One of <em>&quot;character&quot;</em> or <em>&quot;numeric&quot;</em>. Default is
<em>&quot;character&quot;</em>. If <em>&quot;numeric&quot;</em>, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table. See below for more information.</p>
</td></tr>
<tr><td><code id="right_join_+3A_roll">roll</code></td>
<td>
<p>double: <em>to be implemented</em></p>
</td></tr>
<tr><td><code id="right_join_+3A_keep_common_vars">keep_common_vars</code></td>
<td>
<p>logical: If TRUE, it will keep the original variable
from y when both tables have common variable names. Thus, the prefix &quot;y.&quot;
will be added to the original name to distinguish from the resulting
variable in the joined table.</p>
</td></tr>
<tr><td><code id="right_join_+3A_sort">sort</code></td>
<td>
<p>logical: If TRUE, sort by key variables in <code>by</code>. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="right_join_+3A_verbose">verbose</code></td>
<td>
<p>logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.</p>
</td></tr>
<tr><td><code id="right_join_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+joyn">joyn</a></code>
</p>

<dl>
<dt><code>match_type</code></dt><dd><p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</dd>
<dt><code>allow.cartesian</code></dt><dd><p>logical: Check documentation in official <a href="https://rdatatable.gitlab.io/data.table/reference/merge.html/">web site</a>.
Default is <code>NULL</code>, which implies that if the join is &quot;1:1&quot; it will be
<code>FALSE</code>, but if the join has any &quot;m&quot; on it, it will be converted to <code>TRUE</code>.
By specifying <code>TRUE</code> of <code>FALSE</code> you force the behavior of the join.</p>
</dd>
<dt><code>suffixes</code></dt><dd><p>A character(2) specifying the suffixes to be used for making
non-by column names unique. The suffix behaviour works in a similar fashion
as the <a href="base.html#topic+merge">base::merge</a> method does.</p>
</dd>
<dt><code>yvars</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now <code>y_vars_to_keep</code></p>
</dd>
<dt><code>keep_y_in_x</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>: use now
<code>keep_common_vars</code></p>
</dd>
<dt><code>msg_type</code></dt><dd><p>character: type of messages to display by default</p>
</dd>
<dt><code>na.last</code></dt><dd> <p><code>logical</code>. If <code>TRUE</code>, missing values in the data are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed.
<code>na.last=NA</code> is valid only for <code>x[order(., na.last)]</code> and its
default is <code>TRUE</code>. <code>setorder</code> and <code>setorderv</code> only accept
<code>TRUE</code>/<code>FALSE</code> with default <code>FALSE</code>. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An data frame of the same class as <code>x</code>. The properties of the output
are as close as possible to the ones returned by the dplyr alternative.
</p>


<h3>See Also</h3>

<p>Other dplyr alternatives: 
<code><a href="#topic+anti_join">anti_join</a>()</code>,
<code><a href="#topic+full_join">full_join</a>()</code>,
<code><a href="#topic+inner_join">inner_join</a>()</code>,
<code><a href="#topic+left_join">left_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple right join
library(data.table)

x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)
y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))
right_join(x1, y1, relationship = "many-to-one")
</code></pre>

<hr>
<h2 id='set_col_names'>Add x key var and y key var (with suffixes) to x and y
-when joining by different variables and keep is true</h2><span id='topic+set_col_names'></span>

<h3>Description</h3>

<p>Add x key var and y key var (with suffixes) to x and y
-when joining by different variables and keep is true
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_col_names(x, y, by, suffix, jn_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_col_names_+3A_x">x</code></td>
<td>
<p>data table: left table</p>
</td></tr>
<tr><td><code id="set_col_names_+3A_y">y</code></td>
<td>
<p>data table: right table</p>
</td></tr>
<tr><td><code id="set_col_names_+3A_by">by</code></td>
<td>
<p>character vector of variables to join by</p>
</td></tr>
<tr><td><code id="set_col_names_+3A_suffix">suffix</code></td>
<td>
<p>character(2) specifying the suffixes to be used for making non-by column names unique</p>
</td></tr>
<tr><td><code id="set_col_names_+3A_jn_type">jn_type</code></td>
<td>
<p>character specifying type of join</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing x and y
</p>

<hr>
<h2 id='set_joyn_options'>Set joyn options</h2><span id='topic+set_joyn_options'></span>

<h3>Description</h3>

<p>This function is used to change the value of one or more joyn options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_joyn_options(..., env = .joynenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_joyn_options_+3A_...">...</code></td>
<td>
<p>pairs of option = value</p>
</td></tr>
<tr><td><code id="set_joyn_options_+3A_env">env</code></td>
<td>
<p>environment, which is joyn environment by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>joyn new options and values invisibly as a list
</p>


<h3>See Also</h3>

<p>JOYn options functions
<code><a href="#topic+get_joyn_options">get_joyn_options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>joyn:::set_joyn_options(joyn.verbose = FALSE, joyn.reportvar = "joyn_status")
joyn:::set_joyn_options() # return to default options
</code></pre>

<hr>
<h2 id='split_match_type'>Split matching type</h2><span id='topic+split_match_type'></span>

<h3>Description</h3>

<p>Split matching type (one of <code style="white-space: pre;">&#8288;"1:1", "m:1", "1:m", "m:m"&#8288;</code>) into its two components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_match_type(match_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_match_type_+3A_match_type">match_type</code></td>
<td>
<p>character: one of <em>&quot;m:m&quot;</em>, <em>&quot;m:1&quot;</em>, <em>&quot;1:m&quot;</em>, <em>&quot;1:1&quot;</em>.
Default is <em>&quot;1:1&quot;</em> since this the most restrictive. However, following
Stata's recommendation, it is better to be explicit and use any of the
other three match types (See details in <em>match types sections</em>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='store_checked_ids'>store checked variables as possible ids</h2><span id='topic+store_checked_ids'></span>

<h3>Description</h3>

<p>This function processes a list of possible IDs by removing any <code>NULL</code> entries,
storing a set of checked variables as an attribute and in the specified environment,
and then returning the updated list of possible IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_checked_ids(checked_ids, possible_ids, env = .joynenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_checked_ids_+3A_checked_ids">checked_ids</code></td>
<td>
<p>A vector of variable names that have been checked as possible IDs.</p>
</td></tr>
<tr><td><code id="store_checked_ids_+3A_possible_ids">possible_ids</code></td>
<td>
<p>A list containing potential identifiers. This list may contain <code>NULL</code> values, which will be removed by the function.</p>
</td></tr>
<tr><td><code id="store_checked_ids_+3A_env">env</code></td>
<td>
<p>An environment where the <code>checked_ids</code> will be stored. The default is <code>.joynenv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of possible IDs with <code>NULL</code> values removed, and the <code>checked_ids</code> stored as an attribute.
</p>

<hr>
<h2 id='store_joyn_msg'>Wrapper for store_msg function
This function serves as a wrapper for the store_msg function, which is used to store various types of messages within the .joyn environment.
:errors, warnings, timing information, or info</h2><span id='topic+store_joyn_msg'></span>

<h3>Description</h3>

<p>Wrapper for store_msg function
This function serves as a wrapper for the store_msg function, which is used to store various types of messages within the .joyn environment.
:errors, warnings, timing information, or info
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_joyn_msg(err = NULL, warn = NULL, timing = NULL, info = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_joyn_msg_+3A_err">err</code></td>
<td>
<p>A character string representing an error message to be stored. Default value is NULL</p>
</td></tr>
<tr><td><code id="store_joyn_msg_+3A_warn">warn</code></td>
<td>
<p>A character string representing a warning message to be stored. Default value is NULL</p>
</td></tr>
<tr><td><code id="store_joyn_msg_+3A_timing">timing</code></td>
<td>
<p>A character string representing a timing message to be stored. Default value is NULL</p>
</td></tr>
<tr><td><code id="store_joyn_msg_+3A_info">info</code></td>
<td>
<p>A character string representing an info message to be stored. Default value is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible TRUE
</p>


<h3>Hot to pass the message string</h3>

<p>The function allows for the customization of the message string using cli classes to emphasize specific components of the message
Here's how to format the message string:
*For variables:            .strongVar
*For function arguments:   .strongArg
*For dt/df:                .strongTable
*For text/anything else:   .strong
*NOTE: By default, the number of seconds specified in timing messages is
automatically emphasized using a custom formatting approach.
You do not need to apply cli classes nor to specify that the number is in seconds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Timing msg
joyn:::store_joyn_msg(timing = paste("  The entire joyn function, including checks,
                                       is executed in  ", round(1.8423467, 6)))

# Error msg
joyn:::store_joyn_msg(err = " Input table {.strongTable x} has no columns.")

# Info msg
joyn:::store_joyn_msg(info = "Joyn's report available in variable {.strongVar .joyn}")


</code></pre>

<hr>
<h2 id='store_msg'>Store joyn message to .joynenv environment</h2><span id='topic+store_msg'></span>

<h3>Description</h3>

<p>Store joyn message to .joynenv environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_msg(type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_msg_+3A_...">...</code></td>
<td>
<p>combination of type and text in the form <code style="white-space: pre;">&#8288;style1 = text1, style2 = text2&#8288;</code>, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>current message data frame invisibly
</p>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+clear_joynenv">clear_joynenv</a>()</code>,
<code><a href="#topic+joyn_msg">joyn_msg</a>()</code>,
<code><a href="#topic+joyn_msgs_exist">joyn_msgs_exist</a>()</code>,
<code><a href="#topic+joyn_report">joyn_report</a>()</code>,
<code><a href="#topic+msg_type_dt">msg_type_dt</a>()</code>,
<code><a href="#topic+style">style</a>()</code>,
<code><a href="#topic+type_choices">type_choices</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Storing msg with msg_type "info"
joyn:::store_msg("info",
  ok = cli::symbol$tick, "  ",
  pale = "This is an info message")

# Storing msg with msg_type "warn"
joyn:::store_msg("warn",
  err = cli::symbol$cross, "  ",
  note = "This is a warning message")
</code></pre>

<hr>
<h2 id='style'>style of text displayed</h2><span id='topic+style'></span>

<h3>Description</h3>

<p>This is an adaptation from
https://github.com/r-lib/pkgbuild/blob/3ba537ab8a6ac07d3fe11c17543677d2a0786be6/R/styles.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style(..., sep = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="style_+3A_...">...</code></td>
<td>
<p>combination of type and text in the form
<code style="white-space: pre;">&#8288;type1 = text1, type2 = text2&#8288;</code></p>
</td></tr>
<tr><td><code id="style_+3A_sep">sep</code></td>
<td>
<p>a character string to separate the terms to <a href="base.html#topic+paste">paste</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted text
</p>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+clear_joynenv">clear_joynenv</a>()</code>,
<code><a href="#topic+joyn_msg">joyn_msg</a>()</code>,
<code><a href="#topic+joyn_msgs_exist">joyn_msgs_exist</a>()</code>,
<code><a href="#topic+joyn_report">joyn_report</a>()</code>,
<code><a href="#topic+msg_type_dt">msg_type_dt</a>()</code>,
<code><a href="#topic+store_msg">store_msg</a>()</code>,
<code><a href="#topic+type_choices">type_choices</a>()</code>
</p>

<hr>
<h2 id='type_choices'>Choice of messages</h2><span id='topic+type_choices'></span>

<h3>Description</h3>

<p>Choice of messages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_choices()
</code></pre>


<h3>Value</h3>

<p>character vector with choices of types
</p>


<h3>See Also</h3>

<p>Messages functions
<code><a href="#topic+clear_joynenv">clear_joynenv</a>()</code>,
<code><a href="#topic+joyn_msg">joyn_msg</a>()</code>,
<code><a href="#topic+joyn_msgs_exist">joyn_msgs_exist</a>()</code>,
<code><a href="#topic+joyn_report">joyn_report</a>()</code>,
<code><a href="#topic+msg_type_dt">msg_type_dt</a>()</code>,
<code><a href="#topic+store_msg">store_msg</a>()</code>,
<code><a href="#topic+style">style</a>()</code>
</p>

<hr>
<h2 id='unmatched_keys'>Check for unmatched keys</h2><span id='topic+unmatched_keys'></span>

<h3>Description</h3>

<p>Gives TRUE if unmatched keys, FALSE if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmatched_keys(x, out, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unmatched_keys_+3A_x">x</code></td>
<td>
<p>input table to join</p>
</td></tr>
<tr><td><code id="unmatched_keys_+3A_out">out</code></td>
<td>
<p>output of join</p>
</td></tr>
<tr><td><code id="unmatched_keys_+3A_by">by</code></td>
<td>
<p>by argument, giving keys for join</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='update_na_values'>Update NA and/or values</h2><span id='topic+update_na_values'></span>

<h3>Description</h3>

<p>The function updates NAs and/or values in the following way:
</p>

<ul>
<li><p> If only update_NAs is TRUE: update NAs of var in x with values of var y of the same name
</p>
</li>
<li><p> If only update_values = TRUE: update all values, but NOT NAs, of var in x with values of var y of the same name.
NAs from y are not used to update values in x . (e.g., if x.var = 10 and y.var = NA, x.var remains 10)
</p>
</li>
<li><p> If both update_NAs and update_values are TRUE, both NAs and values in x are updated as described above
</p>
</li>
<li><p> If both update_NAs and update_values are FALSE, no update
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>update_na_values(
  dt,
  var,
  reportvar = getOption("joyn.reportvar"),
  suffixes = getOption("joyn.suffixes"),
  rep_NAs = FALSE,
  rep_values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_na_values_+3A_dt">dt</code></td>
<td>
<p>joined data.table</p>
</td></tr>
<tr><td><code id="update_na_values_+3A_var">var</code></td>
<td>
<p>variable(s) to be updated</p>
</td></tr>
<tr><td><code id="update_na_values_+3A_reportvar">reportvar</code></td>
<td>
<p>character: Name of reporting variable. Default is &quot;.joyn&quot;.
This is the same as variable &quot;_merge&quot; in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.</p>
</td></tr>
<tr><td><code id="update_na_values_+3A_suffixes">suffixes</code></td>
<td>
<p>A character(2) specifying the suffixes to be used for making
non-by column names unique. The suffix behaviour works in a similar fashion
as the <a href="base.html#topic+merge">base::merge</a> method does.</p>
</td></tr>
<tr><td><code id="update_na_values_+3A_rep_nas">rep_NAs</code></td>
<td>
<p>inherited from joyn update_NAs</p>
</td></tr>
<tr><td><code id="update_na_values_+3A_rep_values">rep_values</code></td>
<td>
<p>inherited from joyn update_values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
