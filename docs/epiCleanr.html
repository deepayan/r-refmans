<!DOCTYPE html><html lang="en"><head><title>Help for package epiCleanr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epiCleanr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clean_admin_names'><p>Clean and Match Administrative Names</p></a></li>
<li><a href='#clean_names_strings'><p>Clean variable names or column names in various styles</p></a></li>
<li><a href='#consistency_check'><p>Consistency Check Function</p></a></li>
<li><a href='#create_test'><p>Create Test Function</p></a></li>
<li><a href='#export'><p>Export Data to Various File Formats</p></a></li>
<li><a href='#get_admin_names'><p>Retrieve Administrative Names from GeoNames</p></a></li>
<li><a href='#handle_outliers'><p>Detect and Handle Outliers in Dataset</p></a></li>
<li><a href='#import'><p>Import Data from Various File Formats</p></a></li>
<li><a href='#missing_plot'><p>Plot Missing data over time</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Tidy Solution for Epidemiological Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Offers a tidy solution for epidemiological data. It houses a range of functions for epidemiologists and public health data wizards for data management and cleaning.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/truenomad/epiCleanr">https://github.com/truenomad/epiCleanr</a>,
<a href="https://truenomad.github.io/epiCleanr/">https://truenomad.github.io/epiCleanr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/truenomad/epiCleanr/issues">https://github.com/truenomad/epiCleanr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rio, dplyr, tidyr, tools, withr, ggplot2, stringr, tidyselect,
rlang, glue, crayon, countrycode, purrr, tibble, janitor</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, haven, readxl, openxlsx, foreign, yaml,
clipr, xml2, readODS, rmatio, jsonlite, fst, feather, arrow,
xts, data.table, R.utils, stringdist, stringi, ggtext, ggdist,
zoo, wesanderson, scales, spsUtil, rmarkdown, ggh4x</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-28 11:59:45 UTC; mohamedyusuf</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohamed A. Yusuf <a href="https://orcid.org/0000-0002-9339-4613"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohamed A. Yusuf &lt;mohamedayusuf87@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-28 12:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='clean_admin_names'>Clean and Match Administrative Names</h2><span id='topic+clean_admin_names'></span>

<h3>Description</h3>

<p>This function takes administrative names and cleans them using various
matching and string distance algorithms. It can also match the cleaned names
with a base list provided by the user or fetched from 'GeoNames', which is a
official repository of standard spellings of all foreign geographic names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_admin_names(
  admin_names_to_clean,
  country_code,
  admin_level = "adm2",
  user_base_admin_names = NULL,
  user_base_only = FALSE,
  report_mode = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_admin_names_+3A_admin_names_to_clean">admin_names_to_clean</code></td>
<td>
<p>A character vector of administrative names to
clean.</p>
</td></tr>
<tr><td><code id="clean_admin_names_+3A_country_code">country_code</code></td>
<td>
<p>sed if 'use_get_admin_names' is TRUE. A character string
or numerical value of the country code (e.g., &quot;KE&quot;). This can be
in various formats such as country name, ISO codes, UN codes, etc.,
see <code><a href="countrycode.html#topic+countrycode">countrycode::codelist()</a></code> for the full
list of codes and naming conventions used.</p>
</td></tr>
<tr><td><code id="clean_admin_names_+3A_admin_level">admin_level</code></td>
<td>
<p>A character string indicating the administrative level
(e.g., &quot;adm2&quot;).</p>
</td></tr>
<tr><td><code id="clean_admin_names_+3A_user_base_admin_names">user_base_admin_names</code></td>
<td>
<p>A character of of administrative names that the
use would like to use as reference. This is no necessary, downloaded
'GeoNames' will be used if missing.</p>
</td></tr>
<tr><td><code id="clean_admin_names_+3A_user_base_only">user_base_only</code></td>
<td>
<p>A logical indicating whether to use only the
user-provided base administrative names ('user_base_admin_names') for
matching. If TRUE, 'country_code' and 'admin_names_to_clean' are not
required. Default is FALSE.</p>
</td></tr>
<tr><td><code id="clean_admin_names_+3A_report_mode">report_mode</code></td>
<td>
<p>A logical indicating whether to return a detailed report.
Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'report_mode' is set to TRUE, a data frame containing the original
admin names and the matched and cleaned admin names with inormation
of the source of data used to clean including the algorithm used,
else a cleaned list of names is returned.
</p>


<h3>See Also</h3>

<p><code><a href="countrycode.html#topic+countrycode">countrycode::codelist()</a></code>
for the full list of codes and naming conventions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Example with country code
base_names &lt;- c(
  "Paris", "Marseille", "Lyon",
  "Toulouse", "Nice", "Nantes", "Strasbourg",
  "Montpellier", "Bordeaux", "Lille"
)

unclean_names &lt;- c(
  "Pariis", "Marseill", "Lyone",
  "Toulous", "Niice", "Nantees", "Strasbourgh",
  "Montpeelier", "Bordeuax", "Lilie"
)

france_new &lt;- clean_admin_names(
  country_code = "Fr",
  user_base_admin_names = base_names,
  admin_names_to_clean = unclean_names
)

print(france_new)


</code></pre>

<hr>
<h2 id='clean_names_strings'>Clean variable names or column names in various styles</h2><span id='topic+clean_names_strings'></span>

<h3>Description</h3>

<p>This function transforms variable names or column names into one of the
standard cleaned formats specified by the 'style' argument. It offers more
flexibility than <code><a href="janitor.html#topic+janitor">janitor::clean_names()</a></code>
function by supporting individual strings and providing multiple naming
styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_names_strings(input, style = "snake_case")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_names_strings_+3A_input">input</code></td>
<td>
<p>A data frame, tibble, matrix, list, or character vector
representing the names to be cleaned.</p>
</td></tr>
<tr><td><code id="clean_names_strings_+3A_style">style</code></td>
<td>
<p>A character string specifying the naming style to use.
Available options are &quot;snake_case&quot; (default), &quot;camel_case&quot;, and
&quot;simple_clean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with cleaned names.
</p>


<h3>See Also</h3>

<p><code><a href="janitor.html#topic+janitor">janitor::clean_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
library(zoo)
library(xts)

# For data frame with snake_case (default)
data("iris")
cleaned_iris &lt;- clean_names_strings(iris)
colnames(cleaned_iris)

# For data frame with camel_case
cleaned_iris_camel &lt;- clean_names_strings(iris, style = "camel_case")
colnames(cleaned_iris_camel)

# For character vector
original_names &lt;- c("Some Column", "Another-Column!", "Yet Another Column")
cleaned_names &lt;- clean_names_strings(original_names, style = "simple_clean")
print(cleaned_names)

# For matrix
mat &lt;- matrix(1:4, ncol = 2)
colnames(mat) &lt;- c("Some Column", "Another Column")
cleaned_mat &lt;- clean_names_strings(mat)
colnames(cleaned_mat)

# For list
lst &lt;- list("Some Column" = 1, "Another Column" = 2)
cleaned_lst &lt;- clean_names_strings(lst)
names(cleaned_lst)

# For xts object
xts_obj &lt;- xts(x = matrix(1:4, ncol = 2),
               order.by = as.Date('2021-01-01') + 0:1)
colnames(xts_obj) &lt;- c("Some Column", "Another Column")
cleaned_xts &lt;- clean_names_strings(xts_obj)
print(colnames(cleaned_xts))

zoo_obj &lt;- zoo(matrix(1:4, ncol = 2), order.by = 1:2)
colnames(zoo_obj) &lt;- c("Some Column", "Another Column")
cleaned_zoo &lt;- clean_names_strings(zoo_obj)
print(colnames(cleaned_zoo))

# for Data table
dt &lt;- data.table("Some Column" = 1:2, "Another Column" = 3:4)
cleaned_dt &lt;- clean_names_strings(dt)
print(names(cleaned_dt))

</code></pre>

<hr>
<h2 id='consistency_check'>Consistency Check Function</h2><span id='topic+consistency_check'></span>

<h3>Description</h3>

<p>This function performs a consistency check to ensure that the number of tests
is greater than the number of cases for given columns in a dataset. It
returns a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object visualizing the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consistency_check(data, tests, cases)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consistency_check_+3A_data">data</code></td>
<td>
<p>A data frame containing the test and case data.</p>
</td></tr>
<tr><td><code id="consistency_check_+3A_tests">tests</code></td>
<td>
<p>A character vector specifying the column names for the test
data.</p>
</td></tr>
<tr><td><code id="consistency_check_+3A_cases">cases</code></td>
<td>
<p>A character vector specifying the column names for the case
data. The length of 'tests' and 'cases' must be the same, and each element
in 'tests' corresponds to an element in 'cases'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot2">ggplot2::ggplot()</a></code> object showing
the consistency between the number of tests and cases. The x-axis represents
the cases, and the y-axis represents the tests. Each facet represents a
disease, and the diagonal line shows where the number of tests equals the
number of cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># check the consistency between malaria tests and cases

# get path
path &lt;- system.file(
        "extdata",
        "fake_epi_df_togo.rds",
         package = "epiCleanr")

fake_epi_df_togo &lt;- import(path)

consistency_check(fake_epi_df_togo,
                  tests = c("malaria_tests","cholera_tests"),
                  cases = c("malaria_cases", "cholera_cases"))


</code></pre>

<hr>
<h2 id='create_test'>Create Test Function</h2><span id='topic+create_test'></span>

<h3>Description</h3>

<p>This function creates a test function to perform various data validation
checks. The returned function can be applied to a dataset to perform the
specified tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_test(
  dimension_test = NULL,
  combinations_test = NULL,
  row_duplicates = FALSE,
  col_duplicates = FALSE,
  min_threshold_test = NULL,
  max_threshold_test = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_test_+3A_dimension_test">dimension_test</code></td>
<td>
<p>A vector of two integers specifying the expected number
of rows and columns.</p>
</td></tr>
<tr><td><code id="create_test_+3A_combinations_test">combinations_test</code></td>
<td>
<p>A list with the elements 'variables' (character
vector of variable names) and 'expectation' (integer specifying the expected
number of unique combinations for each column).</p>
</td></tr>
<tr><td><code id="create_test_+3A_row_duplicates">row_duplicates</code></td>
<td>
<p>Logical. If TRUE, checks for duplicate rows.</p>
</td></tr>
<tr><td><code id="create_test_+3A_col_duplicates">col_duplicates</code></td>
<td>
<p>Logical. If TRUE, checks for duplicate columns.</p>
</td></tr>
<tr><td><code id="create_test_+3A_min_threshold_test">min_threshold_test</code></td>
<td>
<p>Named list of minimum threshold values for
specified columns.</p>
</td></tr>
<tr><td><code id="create_test_+3A_max_threshold_test">max_threshold_test</code></td>
<td>
<p>Named list of maximum threshold values for
specified columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function to be applied to the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get path
path &lt;- system.file(
        "extdata",
        "fake_epi_df_togo.rds",
         package = "epiCleanr")

fake_epi_df_togo &lt;- import(path)

# Set up unit-test function
my_tests &lt;- create_test(
  # For checking the dimension of the data
  dimension_test = c(900, 9),
  # For expected number of combinations in data
 combinations_test = list(
   variables = c("month", "year", "district"),
   expectation = 12 * 5 * 15),
  # Check repeated cols, rows and max and min thresholds
  row_duplicates = TRUE, col_duplicates = TRUE,
  max_threshold_test = list(malaria_tests = 1000, cholera_tests = 1000),
 min_threshold_test = list(cholera_cases = 0, cholera_cases = 0)
)

result &lt;- my_tests(fake_epi_df_togo)

</code></pre>

<hr>
<h2 id='export'>Export Data to Various File Formats</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>This function provides a unified interface for exporting data to various
file formats supported by the <code><a href="rio.html#topic+rio">rio::export()</a></code>
function. The format is automatically detected from the file extension to
simplify the exporting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(data, file_path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_+3A_data">data</code></td>
<td>
<p>The dataset to be exported.</p>
</td></tr>
<tr><td><code id="export_+3A_file_path">file_path</code></td>
<td>
<p>Character string specifying the path to the output file.</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the underlying write
functions. These arguments are specific to the file format being exported.
Please refer to the documentation of each package used for more
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="rio.html#topic+rio">rio::export()</a></code>, which this function is
based on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary account
tmpdir &lt;- tempfile()
dir.create(tmpdir)

# Export a CSV file
export(mtcars, file_path = file.path(tmpdir, "file.csv"))

# Export an Excel file
export(mtcars, file_path = file.path(tmpdir, "file.xlsx"))

# Export a Stata DTA file
export(mtcars, file_path = file.path(tmpdir, "file.dta"))

# Export an RDS file
export(mtcars, file_path = file.path(tmpdir, "file.rds"))

# Export an RData file
export(list(mtcars = mtcars, iris = iris),
       file_path = file.path(tmpdir, "file.RData"))

# Remove the temporary directory and its contents
unlink(tmpdir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='get_admin_names'>Retrieve Administrative Names from GeoNames</h2><span id='topic+get_admin_names'></span>

<h3>Description</h3>

<p>This function grabs administrative region names (such as districts,
provinces, etc.) for a given country from the 'GeoNames' website. It accepts
both country names and various country coding schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_admin_names(country_name_or_code, silent_mode = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_admin_names_+3A_country_name_or_code">country_name_or_code</code></td>
<td>
<p>Character or numeric. The name or code of the
country for which administrative names are to be retrieved. This can be in
various formats such as country name, ISO codes, UN codes, etc., see
'countrycode::codelist()' for the full list of codes and naming conventions
used.</p>
</td></tr>
<tr><td><code id="get_admin_names_+3A_silent_mode">silent_mode</code></td>
<td>
<p>A logical indicating whether to suppress messages.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing administrative region names and details for
different administrative levels (e.g., ADM1, ADM2, etc.). Each
element of the list corresponds to a different administrative level
and contains a data frame with columns such as country_code,  ascii
name, alternate names, latitude, longitude, and date last updated.
</p>


<h3>See Also</h3>

<p>'Geonames' website for the source of admin
names data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example using different naming/code conventions
three_digit &lt;- get_admin_names("TGO")   # using 3 digit iso codes
two_digit &lt;- get_admin_names("TG")      # using 2 digit iso codes
un_code &lt;- get_admin_names(768)         # using UN codes
full_name &lt;-  get_admin_names("Togo")   # using full names

str(full_name$adm2)


</code></pre>

<hr>
<h2 id='handle_outliers'>Detect and Handle Outliers in Dataset</h2><span id='topic+handle_outliers'></span>

<h3>Description</h3>

<p>This function identifies and handles outliers in a given dataset using
various methods including Z-Score, Modified Z-Score, and Inter-Quartile Range
(IQR). It also provides options to treat the identified outliers, using
mean, median, rolling mean by group and inter-quartile range. It also has
the option to generate a summary report and a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_outliers(
  data,
  vars = NULL,
  method = NULL,
  zscore_threshold = 3,
  mod_zscore_threshold = 3.5,
  iqr_k_value = 1.5,
  treat_method = "none",
  grouping_vars = NULL,
  report_mode = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_outliers_+3A_data">data</code></td>
<td>
<p>Dataframe containing the variables to be checked for outliers.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_vars">vars</code></td>
<td>
<p>Character vector of variable names to check for outliers. Default
is NULL, which selects all numeric columns.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_method">method</code></td>
<td>
<p>Character indicating the method for outlier detection. Options
are &quot;zscore&quot;, &quot;mod_zscore&quot;, and &quot;iqr_method&quot;.
Default is NULL, which applies all methods.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_zscore_threshold">zscore_threshold</code></td>
<td>
<p>Numeric value for Z-Score threshold. Default is 3.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_mod_zscore_threshold">mod_zscore_threshold</code></td>
<td>
<p>Numeric value for Modified Z-Score threshold.
Default is 3.5.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_iqr_k_value">iqr_k_value</code></td>
<td>
<p>Numeric value for IQR multiplier. Default is 1.5.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_treat_method">treat_method</code></td>
<td>
<p>Character indicating how to treat outliers. Options are
&quot;none&quot;, &quot;remove&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;grouped_mean&quot;, and
&quot;quantile&quot;. Default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_grouping_vars">grouping_vars</code></td>
<td>
<p>Character vector of grouping variables for
&quot;grouped_mean&quot;. Required only if treat_method is
&quot;grouped_mean&quot;.</p>
</td></tr>
<tr><td><code id="handle_outliers_+3A_report_mode">report_mode</code></td>
<td>
<p>Logical, if TRUE, the function returns a summary report
and a plot. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If report_mode is TRUE, a list containing a summary dataframe and a ggplot
object. Otherwise, a dataframe with outliers treated according to
treat_method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get path
path &lt;- system.file(
        "extdata",
        "fake_epi_df_togo.rds",
         package = "epiCleanr")

fake_epi_df_togo &lt;- import(path)

variables &lt;- c("malaria_tests", "malaria_cases",
                 "cholera_tests", "cholera_cases")
result &lt;- handle_outliers(fake_epi_df_togo, vars = variables,
               method = "zscore", report_mode = TRUE)

print(result$report)

print(result$plot)

</code></pre>

<hr>
<h2 id='import'>Import Data from Various File Formats</h2><span id='topic+import'></span>

<h3>Description</h3>

<p>This function provides a unified interface for importing data from various
file formats supported by the <code><a href="rio.html#topic+rio">rio</a></code> package. The format is
automatically detected from the file extension to simplify the importing
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import(file_path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_+3A_file_path">file_path</code></td>
<td>
<p>Character string specifying the path to the input file or
a URL pointing to the dataset.</p>
</td></tr>
<tr><td><code id="import_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the underlying read
functions. These arguments are specific to the file format being imported.
Please refer to the documentation of each package used for more
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or appropriate R object containing the imported data.
</p>


<h3>See Also</h3>

<p><code><a href="rio.html#topic+rio">rio::import()</a></code>,  which this function is based on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Locate test data directory
path &lt;-  system.file("extdata",
                     package = "epiCleanr")

# Import a CSV file
data_csv &lt;- import(file_path = file.path(path, "test_data.csv"))

# Import an Excel file
data_excel &lt;- import(file_path = file.path(path, "test_data.xlsx"))

# Import a Stata DTA file
data_dta &lt;- import(file_path = file.path(path, "test_data.dta"))

# Import an RDS file
data_rds &lt;- import(file_path = file.path(path, "test_data.rds"))

# Import an RData file
data_rdata &lt;- import(file_path = file.path(path, "test_data.RData"))

# Import an SPSS file
data_spss &lt;- import(file_path = file.path(path, "test_data.sav"))

</code></pre>

<hr>
<h2 id='missing_plot'>Plot Missing data over time</h2><span id='topic+missing_plot'></span>

<h3>Description</h3>

<p>This function visualizes the proportion of missing data or reporting rate for
specified variables in a dataset. It creates a tile plot using
<code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>; where the x-axis can
represent any categorical time such as time (e.g., year, month), and the
y-axis can represents either variables or groupings (e.g., state). The
output can further be manipulated to one's needs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_plot(data, x_var, y_var = NULL, miss_vars = NULL, use_rep_rate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missing_plot_+3A_data">data</code></td>
<td>
<p>A data frame containing the data to be visualized. Must include
columns specified in 'x_var', 'y_var', and 'vars'.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_x_var">x_var</code></td>
<td>
<p>A character string specifying the time variable in 'data'
(e.g., &quot;year&quot;, &quot;month&quot;). Must be provided.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_y_var">y_var</code></td>
<td>
<p>An optional character string specifying the grouping
variable in 'data' (e.g., &quot;state&quot;). If provided, only one variable can be
specified in 'vars'.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_miss_vars">miss_vars</code></td>
<td>
<p>An optional character vector specifying the variables
to be visualized in 'data'. If NULL, all variables except 'x_var' and
'y_var' will be used.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_use_rep_rate">use_rep_rate</code></td>
<td>
<p>A logical value. If TRUE, the reporting rate is
visualized; otherwise, the proportion of missing data is visualized.
Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object representing the tile plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# get path
path &lt;- system.file(
        "extdata",
        "fake_epi_df_togo.rds",
         package = "epiCleanr")

fake_epi_df_togo &lt;- import(path)

# Check misisng data by year
result &lt;- missing_plot(fake_epi_df_togo,
             x_var = "year", use_rep_rate = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
