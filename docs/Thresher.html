<!DOCTYPE html><html><head><title>Help for package Thresher</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Thresher}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#generics'><p>Generic Methods in the Thresher package</p></a></li>
<li><a href='#matchLabels'>
<p>Match Arbitrary Class Assignments Across Methods</p></a></li>
<li><a href='#Reaper-class'><p>Class <code>"Reaper"</code></p></a></li>
<li><a href='#SignalSet-class'><p>Class <code>"SignalSet"</code></p></a></li>
<li><a href='#SimThresher-class'><p>Class <code>"SimThresher"</code></p></a></li>
<li><a href='#Thresher class unions'><p>Class Unions</p></a></li>
<li><a href='#Thresher-class'><p>Class <code>"Thresher"</code></p></a></li>
<li><a href='#Thresher-data'><p>Thresher and Reaper Simulated Data</p></a></li>
<li><a href='#unitize'>
<p>Convert a Vector to Unit Length</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Threshing and Reaping for Principal Components</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines the classes used to identify
  outliers (threshing) and compute the number of significant principal
  components and number of clusters (reaping) in a joint application
  of PCA and hierarchical clustering. See Wang et al., 2018,
  &lt;<a href="https://doi.org/10.1186%2Fs12859-017-1998-9">doi:10.1186/s12859-017-1998-9</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1), ClassDiscovery, PCDimension</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, grDevices, MASS, colorspace, movMF,
ade4, oompaBase</td>
</tr>
<tr>
<td>Suggests:</td>
<td>NbClust</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>biocViews:</td>
<td>Clustering</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-17 16:08:28 UTC; KRC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-17 19:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='generics'>Generic Methods in the Thresher package</h2><span id='topic+makeFigures'></span><span id='topic+makeFigures+2CANY-method'></span><span id='topic+scatter'></span><span id='topic+scatter+2CANY-method'></span><span id='topic+heat'></span><span id='topic+heat+2CANY-method'></span><span id='topic+getSplit'></span><span id='topic+getSplit+2CANY-method'></span><span id='topic+getColors'></span><span id='topic+getColors+2CANY-method'></span><span id='topic+getStyles'></span><span id='topic+getStyles+2CANY-method'></span>

<h3>Description</h3>

<p>New generic functions for threshing and reaping datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
getColors(object, ...)
## S4 method for signature 'ANY'
getSplit(object, ...)
## S4 method for signature 'ANY'
getStyles(object, ...)
## S4 method for signature 'ANY'
scatter(object, ...)
## S4 method for signature 'ANY'
heat(object, ...)
## S4 method for signature 'ANY'
makeFigures(object, DIR=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generics_+3A_object">object</code></td>
<td>
<p>an object of any class, but typically
<code><a href="#topic+Thresher">Thresher</a></code>, <code><a href="#topic+Reaper">Reaper</a></code>, or
<code><a href="#topic+SimThresher">SimThresher</a></code>. </p>
</td></tr> 
<tr><td><code id="generics_+3A_dir">DIR</code></td>
<td>
<p>a character string containing the name of an existing directory.</p>
</td></tr>
<tr><td><code id="generics_+3A_...">...</code></td>
<td>
<p>extra arguments for generic routines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>getColors</code>, <code>getSplit</code>. and <code>getStyles</code>
are used to extract the implicit color assignments used in standard
plots of objects of the <code>Thresher</code> or <code>Reaper</code> classes.
</p>
<p>The <code>heat</code> and <code>scatter</code> methods represent generic heat maps
and scatter plots, respectively.
</p>
<p>The <code>makeFigures</code> method is to generate a standard suite of
figures for an object.  If the <code>DIR</code> argument is not NULL, then
the figures will be written to the indicated directory in PNG
format. Otherwise, the figures will be displayed interactivey on
screen, waiting for user input to show each plot.
</p>


<h3>Value</h3>

<p>The form of the value returned by these functions may change depending
on the class of its argument. See the documentation of the particular
methods for details of what is produced by that method. 
</p>
<p>The <code>getColors</code> method should return a vector of colors with
length equal to the number of columns in a data set.
</p>
<p>The <code>getSplit</code> method should return a vector of colors with
length equal to the number of rows in a data set.
</p>
<p>The <code>heat</code>, <code>scatter</code>, and <code>makeFigures</code> methods are
called for their side effects of producing plots.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Thresher">Thresher</a></code>, <code><a href="#topic+Reaper">Reaper</a></code>, and <code><a href="#topic+SimThresher">SimThresher</a></code>.
</p>

<hr>
<h2 id='matchLabels'>
Match Arbitrary Class Assignments Across Methods
</h2><span id='topic+matchLabels'></span><span id='topic+labelMatcher'></span><span id='topic+labelAccuracy'></span><span id='topic+countAgreement'></span><span id='topic+bestMetric'></span><span id='topic+remap'></span>

<h3>Description</h3>

<p>These functions provide a set of tools to find the best match between
the labels used by two different algorithms to cluster the same set of
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelMatcher(tab, verbose = FALSE)
matchLabels(tab)
countAgreement(tab)
labelAccuracy(data, labels, linkage="ward.D2")
bestMetric(data, labels)
remap(fix, vary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchLabels_+3A_tab">tab</code></td>
<td>
<p>A contingency table, represented as a square <code>matrix</code>
or <code>table</code> as an R object.  Both dimensions represent an
assignment of class labels, with each row and column representing
one of the labels.  Entries should be non-negative integer counts of
the number of objects having the labels represented by the row and
column.</p>
</td></tr>
<tr><td><code id="matchLabels_+3A_verbose">verbose</code></td>
<td>
<p>A logical value; should the routine print something out
periodically so you know it's still working?</p>
</td></tr>
<tr><td><code id="matchLabels_+3A_data">data</code></td>
<td>
<p>A matrix whose columns represent objects to be clustered
and whose rows represent the anonymous features used to perform the
clustering.</p>
</td></tr>
<tr><td><code id="matchLabels_+3A_labels">labels</code></td>
<td>
<p>A factor (or character vector) of class labels for the
objects in the <code>data</code> matrix.</p>
</td></tr>
<tr><td><code id="matchLabels_+3A_linkage">linkage</code></td>
<td>
<p>A linkage rule accepted by the <code><a href="stats.html#topic+hclust">hclust</a></code>
function.</p>
</td></tr>
<tr><td><code id="matchLabels_+3A_fix">fix</code></td>
<td>
<p>A vector of cluater assignments.</p>
</td></tr>
<tr><td><code id="matchLabels_+3A_vary">vary</code></td>
<td>
<p>A vector of cluater assignments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the most general sense, clustering can be viewed as a function from
the space of &quot;objects&quot; of interest into a space of &quot;class labels&quot;.  In
less mathematical terms, this simply means that each object gets
assigned an (arbitrary) class label. This is all well-and-good until
you try to compare the results of running two different clustering
algorithms that use different labels (or even worse, use the same
labels &ndash; typically the integers <code class="reqn">1, 2, \dots, K</code> &ndash; with
different meanings).  When that happens, you need a way to decide
which labels from the different sets are closest to meaning the
&quot;same thing&quot;.
</p>
<p>That's where this set of functions comes in. The core algorithm is
implemented in the function <code>labelMatcher</code>, which works on a
contingency table whose entries <code class="reqn">N_{ij}</code> are the number of samples
with row-label = <code class="reqn">i</code> and column-label = <code class="reqn">j</code>.  To find  the
best match, one computes (heuristically) the values <code class="reqn">F_{ij}</code> that
describe the fraction of all entries in row <code class="reqn">i</code> and column <code class="reqn">j</code>
represented by <code class="reqn">N_{ij}</code>.  Perfectly matched labels would consist
of a row <code class="reqn">i</code> and a column <code class="reqn">j</code> where <code class="reqn">N_{ij}</code> is the only
nonzero entry in its row and column, so <code class="reqn">F_{ij} = 1</code>. The largest
value for <code class="reqn">F_{ij}</code> (with ties broken simply by which entry is
closer to the upper-left corner of the matrix) defines the best
match. The matched row and column are then removed from the matrix and
the process repeats recursively.
</p>
<p>We apply this method to determine which distance metric, when used in
hierarchical clustering, best matches a &quot;gold standard&quot; set of class
labels.  (These may not really be gold, of course; they can also be a
set of labels determined by k-means or another clustering algorithm.)
The idea is to cluster the samples using a variety of different
metrics, and select the one whose label assignments best macth the
standard.
</p>


<h3>Value</h3>

<p>The <code>labelMatcher</code> function returns a list of two vectors of the
same length.  These contain the matched label-indices, in the order
they were matched by the algorithm.
</p>
<p>The <code>matchLabels</code> function is a user-friendly front-end to the
<code>labelmatcher</code> function.  It returns a matrix, with the rows and
columns reordered so the labels match.
</p>
<p>The <code>countAgreement</code> function returns an integer, the number of
samples with the &quot;same&quot; labels, computed by summing the diagonal of
the reordered matrix produced by <code>matchLabels</code>.
</p>
<p>The <code>labelAccuracy</code> function returns a vector indexed by the set
of nine distance metrics hard-coded in the function.  Each entry is
the fraction of samples whose hierarchical clusters match the
prespecified <code>labels</code>.
</p>
<p>The <code>bestMetric</code> function is a user-friendly front-end to the
<code>labelAccuracy</code> function.  It returns the name of the distance
metric whose hierarchical clusters best match the prespecified
<code>labels</code>.
</p>
<p>The <code>remap</code> function takes two sets of integer cluster
assignments and returns a new set of labels for the target that best
matches the source.
</p>


<h3>Note</h3>

<p>The <code>labelAccuracy</code> function should probably allow the user
to supply a list of distance metrics instead of relying on the
hard-coded list internally.</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p>Hierarchical clustering is implemented in the <code><a href="stats.html#topic+hclust">hclust</a></code>
function.  We use the extended set of distance metrics provided by the
<code><a href="ClassDiscovery.html#topic+distanceMatrix">distanceMatrix</a></code> function from the ClassDiscovery package.
This set includes all of the  metrics from the <code><a href="stats.html#topic+dist">dist</a></code>
funciton. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>factor1 &lt;- sample(c("A", "B", "C"), 30, replace=TRUE)
factor2 &lt;- rep(c("X", "Y", "Z"), each=10)
tab &lt;- table(factor1, factor2)
matchLabels(tab)
labelMatcher(tab)
R &lt;- remap(factor1, factor2)
table(R, factor2) # remapping
table(R, factor1) # cross-comparison
</code></pre>

<hr>
<h2 id='Reaper-class'>Class <code>"Reaper"</code></h2><span id='topic+Reaper-class'></span><span id='topic+Reaper'></span><span id='topic+getColors+2CReaper-method'></span><span id='topic+getSplit+2CReaper-method'></span><span id='topic+getStyles+2CReaper-method'></span><span id='topic+makeFigures+2CReaper-method'></span>

<h3>Description</h3>

<p>The <code>Reaper</code> class implements the second step in the algorithm to
combine outlier detection with cliustering.  The first step, implemented
in the <a href="#topic+Thresher-class">Thresher-class</a>, performs principal components analysis an
computes the PC dimension.  Features with short loading vectors are
identified as outliers. Remaining features are clustering, based on the
directions of the loading vectors, using mixtures of von Mises-Fisher
distributions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reaper(thresher, useLoadings = FALSE, cutoff = 0.3,
       metric = NULL, linkage="ward.D2",
       maxSampleGroups = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reaper-class_+3A_thresher">thresher</code></td>
<td>
<p>A <code>Thresher</code> object.</p>
</td></tr>
<tr><td><code id="Reaper-class_+3A_useloadings">useLoadings</code></td>
<td>
<p>A logical value; should model-based clustering
using von Mises-Fisher distributions be performed in the principal
component space?</p>
</td></tr>
<tr><td><code id="Reaper-class_+3A_cutoff">cutoff</code></td>
<td>
<p>A real number; what length loading vector should be used
to separate outliers from significant contributers.</p>
</td></tr>
<tr><td><code id="Reaper-class_+3A_metric">metric</code></td>
<td>
<p>A character string containing the name of a clustering metric
recognized by either <code><a href="stats.html#topic+dist">dist</a></code> or <code><a href="ClassDiscovery.html#topic+distanceMatrix">distanceMatrix</a></code>.</p>
</td></tr> 
<tr><td><code id="Reaper-class_+3A_linkage">linkage</code></td>
<td>
<p>A character string containing the name of a linkage rule
recognized by <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="Reaper-class_+3A_maxsamplegroups">maxSampleGroups</code></td>
<td>
<p>An integer; the maximum number of sample groups
to be indicated by color in plots of the object.</p>
</td></tr>
<tr><td><code id="Reaper-class_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the
<code><a href="#topic+Thresher">Thresher</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the dimension computed when constructing the
<code><a href="#topic+Thresher">Thresher</a></code> object, we computed the lengths of the loading
vectors associated to features in the data set.  Features whose length
is less than a specified <code>cutoff</code> are identified as outliers and
removed. (Based on extensive simulations, the default cutoff is
taken to be 0.3.) We then refit the Thresher model on the remaining
features, which should, in theory, leave the PC dimension, <code>D</code>,
unchanged.  We then rescale the remaining loading vectors to unit
length, so they can be viewed as points on a hypersphere. In order to
cluster points on a hypersphere, we use a model based on a mixture
of von Mises-Fisher distributions. We fit mixtures for every integer
in the range <code class="reqn">D \le N \le 2D+1</code>; this range accounts for the
possibility that each axis has both positively and negatively
correlated features.  The extra <code class="reqn">+1</code> handles the degenerate case when
<code class="reqn">D=0</code>.  The best fit is determined using the Bayes Information
Criterion (BIC). The final step is to compute a
<code><a href="#topic+SignalSet">SignalSet</a></code>; see the description of that class for more
details.
</p>


<h3>Value</h3>

<p>The <code>Reaper</code> function returns an object of the Reaper class.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be defined using the <code>Reaper</code> constructor. In
the simplest case, you simply pass in a previously computed
<code>Thresher</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>useLoadings</code>:</dt><dd><p>Logical; should model-based clustering be
performed in PC space?</p>
</dd>
<dt><code>keep</code>:</dt><dd><p>Logical vector: which of the features (columns)
should be retained as meaningful signal instead of being removed
as outliers?</p>
</dd>
<dt><code>nGroups</code>:</dt><dd><p>Object of class <code>"number or miss"</code>; the
optimal number of groups/clusters found by the algorithm. If all
of the fits fail, this is NA. </p>
</dd>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"fit or miss"</code>; the best
mixture model fit.  Can be an NA if something goes wrong
when trying to fit mixture models.</p>
</dd>
<dt><code>allfits</code>:</dt><dd><p>Object of class <code>"list"</code>; a list, each
of whose entries should be the results of fitting a mixture model
with a different number of components.</p>
</dd>
<dt><code>bic</code>:</dt><dd><p>Object of class <code>"number or miss"</code>; the
optimal valus of the Bayes Information Criterion; can be NA if all
attempts to fit models fail.</p>
</dd>
<dt><code>metric</code>:</dt><dd><p>A character string; the preferred distance
metric for hierarchical clustering. If not specified by the user,
then this is computed using the <code>bestMetric</code> function.</p>
</dd>
<dt><code>signalSet</code>:</dt><dd><p>Object of class <code><a href="#topic+SignalSet">SignalSet</a></code></p>
</dd>
<dt><code>maxSampleGroups</code>:</dt><dd><p>An integer; the maximum number of
sample groups to be distinguished by color in plots of the
object.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Thresher-class">Thresher</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>makeFigures</dt><dd><p><code>signature(object = "Reaper")</code>: This is a
convenience function to produce a standard set of figures. In
addition tot he plots preodcued for<code>Thresher</code> object, this
function also produces heatmaps where sample clustering depends
on either the continuous or binary signal sets.
If the <code>DIR</code> argument is
non-null, it is treated as the name of an existing directory where the
figures are stored as PNG files. Otherwise, the figures are
displayed interactively, one at a time, in a window on screen.</p>
</dd>
<dt>getColors</dt><dd><p><code>signature(object = "Reaper")</code>: Returns the
vector of colors assigned to the clustered columns in the data set.</p>
</dd>
<dt>getSplit</dt><dd><p><code>signature(object = "Reaper")</code>:  Returns the
vector of colors assigned to the clustered rows in the data set.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Min Wang.
</p>


<h3>References</h3>

<p>Wang M, Abrams ZB, Kornblau SM, Coombes KR.
Thresher: determining the number of clusters while removing outliers.
BMC Bioinformatics, 2018; 19(1):1-9. doi://10.1186/s12859-017-1998-9.
</p>
<p>Wang M, Kornblau SM, Coombes KR.
Decomposing the Apoptosis Pathway Into Biologically Interpretable
Principal Components.
bioRxiv, 2017. doi://10.1101/237883.
</p>
<p>Banerjee A, Dhillon IS, Ghosh J, Sra S.
Clustering on the unit hypersphere using von Mises-Fisher distributions.
Journal of Machine Learning Research, 2005; 6:1345&ndash;1382.
</p>
<p>Kurt Hornik and Bettina Gr\&quot;un.
movMF: An R Package for Fitting Mixtures of von Mises-Fisher Distributions.
Journal of Statistical Software, 2014; 58(10):1&ndash;31.
</p>


<h3>See Also</h3>

<p><code><a href="PCDimension.html#topic+PCDimension">PCDimension</a></code>, <code><a href="#topic+SignalSet">SignalSet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate  a data set with some structure
set.seed(250264)
sigma1 &lt;- matrix(0, ncol=16, nrow=16)
sigma1[1:7, 1:7] &lt;- 0.7
sigma1[8:14, 8:14] &lt;- 0.3
diag(sigma1) &lt;- 1
st &lt;- SimThresher(sigma1, nSample=300)
# Threshing is completed; now we can reap
reap &lt;- Reaper(st)
screeplot(reap, col='pink', lcol='red')
scatter(reap)
plot(reap)
heat(reap)
</code></pre>

<hr>
<h2 id='SignalSet-class'>Class <code>"SignalSet"</code></h2><span id='topic+SignalSet-class'></span><span id='topic+SignalSet'></span>

<h3>Description</h3>

<p>We use the term &quot;(continuous) signal&quot; to refer to a weighted sum (by
default, the mean) of gene-features.  By dichotomizing a continuous
signals, we obtain a &quot;binary signal&quot;. The <code>SignalSet</code> class
represents the set of continuous and binary signals obtained after
clustering the features in a data set.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SignalSet",
  ...)</code>.  However, users are styrongly discouraged from contructing a
<code>SignalSet</code> manually. They are only used in the code internal to the
construction of a <code>Reaper</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>members</code>:</dt><dd><p>Object of class <code>"list"</code>. Each member of
the list is a character vector enumerating the features defining
each signal.</p>
</dd>
<dt><code>continuous</code>:</dt><dd><p>A matrix where the number of columns
equals the length of the <code>members</code> list; each column contains
the mean expression of the (assumed standardized) corresponding features.</p>
</dd>
<dt><code>binary</code>:</dt><dd><p>A matrix where the number of columns
equals the length of the <code>members</code> list; each column contains
expression values dichotmoized to 0 or 1 by splitting the
conmtinuous siognal at zero.</p>
</dd>
<dt><code>continuousClusters</code>:</dt><dd><p>Object of class <code>"hclust"</code>
obtained by clustering samples based on the continuous signals.</p>
</dd>
<dt><code>binaryClusters</code>:</dt><dd><p>Object of class <code>"hclust"</code>
obtained by clustering samples based on the binary signals.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;SignalSet&quot; in the signature.
</p>


<h3>Note</h3>

<p>The length of <code>members</code> and thus the number of signals may be
smaller than expected from the number of clusters found by
<code>Reaper</code>. The implementation of the <code>SignalSet</code> tries to
determine if two signals are pointing in opposite directions, which
could happen if they are postively and negatively correlated
sets. This behavior is likely to change in the future.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Reaper">Reaper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate  a data set with some structure
set.seed(250264)
sigma1 &lt;- matrix(0, ncol=16, nrow=16)
sigma1[1:7, 1:7] &lt;- 0.7
sigma1[8:14, 8:14] &lt;- 0.3
diag(sigma1) &lt;- 1
st &lt;- SimThresher(sigma1, nSample=300)
# Threshing is completed; now we can reap
reap &lt;- Reaper(st)
# now extract the signal set
ss &lt;- reap@signalSet
dim(ss@continuous)
dim(ss@binary)
table(ss@binary[,1], ss@binary[,2])
plot(ss@continuousClusters)
</code></pre>

<hr>
<h2 id='SimThresher-class'>Class <code>"SimThresher"</code></h2><span id='topic+SimThresher-class'></span><span id='topic+SimThresher'></span><span id='topic+image+2CSimThresher-method'></span><span id='topic+makeFigures+2CSimThresher-method'></span>

<h3>Description</h3>

<p>The <code>SimThresher</code> class is used to simulate <code><a href="#topic+Thresher">Thresher</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimThresher(ss, nSample, nm = deparse(substitute(ss)), rho = NULL,
            agfun = agDimTwiceMean, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimThresher-class_+3A_ss">ss</code></td>
<td>
<p>A covariance matrix.</p>
</td></tr>
<tr><td><code id="SimThresher-class_+3A_nsample">nSample</code></td>
<td>
<p>An integer; the number of samples to simulate.</p>
</td></tr>
<tr><td><code id="SimThresher-class_+3A_nm">nm</code></td>
<td>
<p>A character string; the name of this object.</p>
</td></tr>
<tr><td><code id="SimThresher-class_+3A_rho">rho</code></td>
<td>
<p>A numeric vector; the correlation between different
variables. If NULL, then these are obtained from the covariance
matrix.</p>
</td></tr>
<tr><td><code id="SimThresher-class_+3A_agfun">agfun</code></td>
<td>
<p>A function used by the <code><a href="PCDimension.html#topic+AuerGervini">AuerGervini</a></code>
function to determine the number of principal components.</p>
</td></tr>
<tr><td><code id="SimThresher-class_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to the <code><a href="#topic+Thresher">Thresher</a></code>
constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, given a number of samples and a covariance matrix,
simulate a data matrix of the appropriate size and multivariate normal
structure by assuming that all of the means are zero. After simulating
the data, we apply the Thresher algorithm. The result is an
object that combines the simulation parameters, simulated data, and
fitted model.
</p>


<h3>Value</h3>

<p>The <code>SimThresher</code> function returns an object of the
<code>SimThresher</code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be created using the <code>SimThresher</code> constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nSample</code>:</dt><dd><p>An integer; the number of simulated samples.</p>
</dd>
<dt><code>covariance</code>:</dt><dd><p>A covariance matrix.</p>
</dd>
<dt><code>rho</code>:</dt><dd><p>A vector of correlation coefficients; essentially
the unique values in the upper triangular part of the covariance
matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+Thresher-class">Thresher</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>image</dt><dd><p><code>signature(x = "SimThresher")</code>: Produces an image
of the covariance matrix.</p>
</dd>
<dt>makeFigures</dt><dd><p><code>signature(object = "SimThresher")</code>: This is a
convenience function to produce a standard set of figures. In
addition tot he plots preodcued for<code>Thresher</code> object, this
function also produces an image of te covariance matrix used in
the simulations.
If the <code>DIR</code> argument is
non-null, it is treated as the name of an existing directory where the
figures are stored as PNG files. Otherwise, the figures are
displayed interactively, one at a time, in a window on screen.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Min Wang.
</p>


<h3>References</h3>

<p>Wang M, Abrams ZB, Kornblau SM, Coombes KR.
Thresher: determining the number of clusters while removing outliers.
BMC Bioinformatics, 2018; 19(1):1-9. doi://10.1186/s12859-017-1998-9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Thresher">Thresher</a></code>, <code><a href="#topic+Reaper">Reaper</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(250264)
rho &lt;- 0.5
nProtein &lt;- 16
splinter &lt;- sample((nProtein/2) + (-3:3), 1)
sigma1 &lt;- matrix(rho, ncol=nProtein, nrow=nProtein)
diag(sigma1) &lt;- 1
st &lt;- SimThresher(sigma1, nSample=300)
image(st, col=redgreen(64), zlim=c(-1,1))
screeplot(st, col='pink', lcol='red')
plot(st)
scatter(st)
heat(st)
</code></pre>

<hr>
<h2 id='Thresher+20class+20unions'>Class Unions</h2><span id='topic+fit+20or+20miss-class'></span><span id='topic+number+20or+20miss-class'></span>

<h3>Description</h3>

<p>The implemetation of the <code>Reaper</code> class makes use of two class
unions in order to deal with cases when we are unable to fit a
model.
</p>
<p>The <code>number or miss</code> class union can either hold a
numeric vector or a logical vector.
</p>
<p>The <code>fit or miss</code> class union
can hold either a fitted <code>movMF</code> object or a logical vector.
</p>


<h3>Objects from the Class</h3>

<p>Virtual Class: No objects may be
created directly from either of these class-unions.</p>


<h3>Methods</h3>

<p>No methods are defined with class &quot;number or miss&quot; or  &quot;fit or miss&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;
</p>

<hr>
<h2 id='Thresher-class'>Class <code>"Thresher"</code></h2><span id='topic+Thresher-class'></span><span id='topic+Thresher'></span><span id='topic+heat+2CThresher-method'></span><span id='topic+makeFigures+2CThresher-method'></span><span id='topic+plot+2CThresher+2Cmissing-method'></span><span id='topic+scatter+2CThresher-method'></span><span id='topic+screeplot+2CThresher-method'></span><span id='topic+getColors+2CThresher-method'></span><span id='topic+getSplit+2CThresher-method'></span><span id='topic+getStyles+2CThresher-method'></span>

<h3>Description</h3>

<p>The <code>Thresher</code> class represents the first step of an algorithm that
combines outlier detection with clustering. The object combines the
results of hierarchical clustering and principal components analysis
(with a computation of its dimension) on the same data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Thresher(data, nm = deparse(substitute(data)),
         metric = "pearson", linkage="ward.D2",
         method = c("auer.gervini", "broken.stick"),
         scale = TRUE, agfun = agDimTwiceMean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Thresher-class_+3A_data">data</code></td>
<td>
<p>A data matrix.</p>
</td></tr>
<tr><td><code id="Thresher-class_+3A_nm">nm</code></td>
<td>
<p>A character string; the name of this object.</p>
</td></tr>
<tr><td><code id="Thresher-class_+3A_metric">metric</code></td>
<td>
<p>A character string containing the name of a clustering metric
recognized by either <code><a href="stats.html#topic+dist">dist</a></code> or
<code><a href="ClassDiscovery.html#topic+distanceMatrix">distanceMatrix</a></code>.</p>
</td></tr> 
<tr><td><code id="Thresher-class_+3A_linkage">linkage</code></td>
<td>
<p>A character string containing the name of a linkage rule
recognized by <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="Thresher-class_+3A_method">method</code></td>
<td>
<p>A character string describing the algorthim used from the
<code>PCDimension</code> package to compute the number of
significant components.</p>
</td></tr>
<tr><td><code id="Thresher-class_+3A_scale">scale</code></td>
<td>
<p>A logical value; should the data be scaled before use?</p>
</td></tr>
<tr><td><code id="Thresher-class_+3A_agfun">agfun</code></td>
<td>
<p>A function that will be accepted by the
<code><a href="PCDimension.html#topic+AuerGervini">AuerGervini</a></code> function in the
<code>PCDimension</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Thresher</code> operates on a data matrix that is assumed to be
organized with rows equal to samples and columns equal to features
(like genes or proteins).   The algorithm begins by centering and (by
default, though this can be overridden with the <code>scale</code>
parameter) standardizes the data columns. It then performs a principal
components analysis, and uses the Auer-Gervini method, as automated in
the <code><a href="PCDimension.html#topic+PCDimension">PCDimension</a></code> package, to determine the number, <code>D</code>, of
statistically significant principal components. For each
column-feature, it computes and remembers the length of its loading
vector in D-dimensional space. (In case the Auer-Gervini method finds
that <code class="reqn">D=0</code>, the length is instead computed using <code class="reqn">D=1</code>.) These
loading-lengths will be used later to identify and remove features
that act as outliers and do not contribute to clustering the
samples. Finally, <code>Thresher</code> computes and saves the results of
hierarchically clustering the features in the data set, using the
specified distance <code>metric</code> and <code>linkage</code> rule.
</p>


<h3>Value</h3>

<p>The <code>Thresher</code> function constructs and returns an object of the
<code>Thresher</code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be defined using the <code>Thresher</code> constructor. In
the simplest case, you simply pass in the data matrix that you want to
cluster using the Thresher algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code>; the name of
this object. </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"matrix"</code>; the data that
was used for clustering. </p>
</dd>
<dt><code>spca</code>:</dt><dd><p>Object of class <code>"SamplePCA"</code>; represents
the results of performing a principal components analysis on the
original <code>data</code>.</p>
</dd>
<dt><code>loadings</code>:</dt><dd><p>Object of class <code>"matrix"</code>; the matrix
of loading vectors from the principal components analysis.</p>
</dd>
<dt><code>gc</code>:</dt><dd><p>Object of class <code>"hclust"</code>; the result of performing
hierarchical clustering on the data columns.</p>
</dd>
<dt><code>pcdim</code>:</dt><dd><p>Object of class <code>"numeric"</code>; the number of
significant principal components.</p>
</dd>
<dt><code>delta</code>:</dt><dd><p>Object of class <code>"numeric"</code>; the lengths of
the loading vectors in the principal component space of dimension
equal to <code>pcdim</code>.</p>
</dd>
<dt><code>ag</code>:</dt><dd><p>Object of class <code>"AuerGervini"</code>; represents
the result of running the automated Auer-Gervini algorithm to
detemine the number of principal components.</p>
</dd>
<dt><code>agfun</code>:</dt><dd><p>A function, which is used as the default method
for computing the principal component dimension from the Auer-Gervini
plot.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>screeplot</dt><dd><p><code>signature(x = "Thresher")</code>: Produce a scree
plot of the PCA part of the Thresher object.</p>
</dd>
<dt>scatter</dt><dd><p><code>signature(object = "Thresher")</code>: Produce a
scatter plot of the first two principal components.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "Thresher", y = "missing")</code>: In two
dimensions, plot the loading vectors of the PCA part of the
object.</p>
</dd>
<dt>heat</dt><dd><p><code>signature(object = "Thresher")</code>: Produce a heatmap
of the data set.</p>
</dd>
<dt>makeFigures</dt><dd><p><code>signature(object = "Thresher")</code>: This is a
convenience function to produce a standard set of figures for a
<code>Thresher</code> object. These are (1) a scree plot, (2) a plot of
teh Auer-Gervini slot, (3) a scatter plot of the firtst trwo
principal components, (4) one or more plots of the loading
vectors, depending on the PCV dimension, and (5) a heat map.
If the <code>DIR</code> argument is
non-null, it is treated as the name of an existing directory where the
figures are stored as PNG files. Otherwise, the figures are
displayed interactively, one at a time, in a window on screen.</p>
</dd>
<dt>getColors</dt><dd><p><code>signature(object = "Thresher")</code>: Returns the
vector of colors assigned to the clustered columns in the data set.</p>
</dd>
<dt>getSplit</dt><dd><p><code>signature(object = "Thresher")</code>:  Returns the
vector of colors assigned to the clustered rows in the data set.</p>
</dd>
<dt>getStyles</dt><dd><p><code>signature(object = "Thresher")</code>: I refuse to
document this, since I am not convinced that it should actually exist.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Min Wang.
</p>


<h3>References</h3>

<p>Wang M, Abrams ZB, Kornblau SM, Coombes KR.
Thresher: determining the number of clusters while removing outliers.
BMC Bioinformatics, 2018; 19(1):1-9. doi://10.1186/s12859-017-1998-9.
</p>
<p>Wang M, Kornblau SM, Coombes KR.
Decomposing the Apoptosis Pathway Into Biologically Interpretable
Principal Components.
bioRxiv, 2017. doi://10.1101/237883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Thresher">Thresher</a></code>, <code><a href="#topic+Reaper-class">Reaper-class</a></code>, <code><a href="PCDimension.html#topic+AuerGervini-class">AuerGervini-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3928270)
ranData &lt;- matrix(rnorm(100*12), ncol=12)
colnames(ranData) &lt;- paste("G", 1:12, sep='')
thresh &lt;- Thresher(ranData) # fit the model
screeplot(thresh)           # check the scree plot; suggests dim = 4
plot(thresh@ag, list(thresh@agfun)) # Auer-Gervini object; dim = 0
scatter(thresh)             # PCA scatter plot  (rows = samples)
plot(thresh)                # PCA loadings plot (cols = features)
heat(thresh)                # ubiquitous 2-way heatmap
</code></pre>

<hr>
<h2 id='Thresher-data'>Thresher and Reaper Simulated Data</h2><span id='topic+Thresher-data'></span><span id='topic+sigma'></span><span id='topic+savedSims'></span><span id='topic+savedReap'></span>

<h3>Description</h3>

<p>This data set contains five related simulated data sets, along with
the Thresher and Reaper objects obtained by clustering the data sets
and removing outliers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(savedSims)
</code></pre>


<h3>Format</h3>


<ol>
<li> <p><code>sigma</code>: A list of length five; each entry is a covariance matrix
used to simulate data.
</p>
</li>
<li> <p><code>savedSims</code>: A list of length five; each entry is a
<code><a href="#topic+SimThresher">SimThresher</a></code> object obtained by simulating data from
one of the covariance matrices and running the <code><a href="#topic+Thresher">Thresher</a></code>
algorithm.
</p>
</li>
<li> <p><code>savedReap</code>: A list of length five; each entry is a
<code><a href="#topic+Reaper">Reaper</a></code> object obtained by applying the <code>Reaper</code>
function.
</p>
</li></ol>



<h3>Source</h3>

<p>The simulated data sets were prepared by running the script
<code>Examples/makeSims.R</code> that is installed along with the
<code>Thresher</code> package. The five covariance matrices vary in the
number of correlated subgroups (one or two) and whether they include
both positively and negatively correlated variables, or just
positively correlated ones. Each data set also includes two
uncorrelated &quot;noise&quot; variables that should automatically be removed by
the Reper-Thresher algorithms.
</p>


<h3>References</h3>

<p>Wang M, Abrams ZB, Kornblau SM, Coombes KR.
Thresher: determining the number of clusters while removing outliers.
BMC Bioinformatics, 2018; 19(1):1-9. doi://10.1186/s12859-017-1998-9.
</p>

<hr>
<h2 id='unitize'>
Convert a Vector to Unit Length
</h2><span id='topic+unitize'></span>

<h3>Description</h3>

<p>Rescales each column of a matrix to produce vectors of length one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitize(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitize_+3A_mat">mat</code></td>
<td>
<p>A matrix of real numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details beyond the simple description are requires; it is implemented
exactly the way you would suspect.
</p>


<h3>Value</h3>

<p>A matrix of the same size as the input matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simmat &lt;- matrix(rnorm(12), 3, 4)
U &lt;- unitize(simmat)
apply(U^2, 2, sum)  # check unit length
simmat/U            # view normalization factors
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
