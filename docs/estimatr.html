<!DOCTYPE html><html><head><title>Help for package estimatr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {estimatr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#estimatr'><p>estimatr</p></a></li>
<li><a href='#alo_star_men'><p>Replication data for Lin 2013</p></a></li>
<li><a href='#commarobust'><p>Build lm_robust object from lm fit</p></a></li>
<li><a href='#declaration_to_condition_pr_mat'><p>Builds condition probability matrices for Horvitz-Thompson estimation from</p>
<span class="pkg">randomizr</span> declaration</a></li>
<li><a href='#difference_in_means'><p>Design-based difference-in-means estimator</p></a></li>
<li><a href='#estimatr_glancers'><p>Glance at an estimatr object</p></a></li>
<li><a href='#estimatr_tidiers'><p>Tidy an estimatr object</p></a></li>
<li><a href='#extract.robust_default'><p>Extract model data for <span class="pkg">texreg</span> package</p></a></li>
<li><a href='#gen_pr_matrix_cluster'><p>Generate condition probability matrix given clusters and probabilities</p></a></li>
<li><a href='#horvitz_thompson'><p>Horvitz-Thompson estimator for two-armed trials</p></a></li>
<li><a href='#iv_robust'><p>Two-Stage Least Squares Instrumental Variables Regression</p></a></li>
<li><a href='#lh_robust'><p>Linear Hypothesis for Ordinary Least Squares with Robust Standard Errors</p></a></li>
<li><a href='#lm_lin'><p>Linear regression with the Lin (2013) covariate adjustment</p></a></li>
<li><a href='#lm_robust'><p>Ordinary Least Squares with Robust Standard Errors</p></a></li>
<li><a href='#lm_robust_fit'><p>Internal method that creates linear fits</p></a></li>
<li><a href='#na.omit_detailed.data.frame'><p>Extra logging on na.omit handler</p></a></li>
<li><a href='#permutations_to_condition_pr_mat'><p>Builds condition probability matrices for Horvitz-Thompson estimation from</p>
permutation matrix</a></li>
<li><a href='#predict.lm_robust'><p>Predict method for <code>lm_robust</code> object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#starprep'><p>Prepare model fits for stargazer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Estimators for Design-Based Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast procedures for small set of commonly-used, design-appropriate estimators with robust standard errors and confidence intervals. Includes estimators for linear regression, instrumental variables regression, difference-in-means, Horvitz-Thompson estimation, and regression improving precision of experimental estimates by interacting treatment with centered pre-treatment covariates introduced by Lin (2013) &lt;<a href="https://doi.org/10.1214%2F12-AOAS583">doi:10.1214/12-AOAS583</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://declaredesign.org/r/estimatr/">https://declaredesign.org/r/estimatr/</a>,
<a href="https://github.com/DeclareDesign/estimatr">https://github.com/DeclareDesign/estimatr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DeclareDesign/estimatr/issues">https://github.com/DeclareDesign/estimatr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula, generics, methods, Rcpp (&ge; 0.12.16), rlang (&ge;
0.2.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fabricatr (&ge; 0.10.0), randomizr (&ge; 0.20.0), AER,
clubSandwich, emmeans (&ge; 1.4), estimability, margins,
modelsummary, prediction, RcppEigen, sandwich, stargazer,
testthat, car</td>
</tr>
<tr>
<td>Enhances:</td>
<td>texreg</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-30 03:51:08 UTC; blair</td>
</tr>
<tr>
<td>Author:</td>
<td>Graeme Blair [aut, cre],
  Jasper Cooper [aut],
  Alexander Coppock [aut],
  Macartan Humphreys [aut],
  Luke Sonnet [aut],
  Neal Fultz [ctb],
  Lily Medina [ctb],
  Russell Lenth [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Graeme Blair &lt;graeme.blair@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-31 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='estimatr'>estimatr</h2><span id='topic+estimatr-package'></span><span id='topic+estimatr'></span>

<h3>Description</h3>

<p>Fast procedures for small set of commonly-used, design-appropriate estimators with robust standard errors and confidence intervals. Includes estimators for linear regression, instrumental variables regression, difference-in-means, Horvitz-Thompson estimation, and regression improving precision of experimental estimates by interacting treatment with centered pre-treatment covariates introduced by Lin (2013) &lt;doi:10.1214/12-AOAS583&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Graeme Blair <a href="mailto:graeme.blair@gmail.com">graeme.blair@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jasper Cooper <a href="mailto:jjc2247@columbia.edu">jjc2247@columbia.edu</a>
</p>
</li>
<li><p> Alexander Coppock <a href="mailto:alex.coppock@yale.edu">alex.coppock@yale.edu</a>
</p>
</li>
<li><p> Macartan Humphreys <a href="mailto:macartan@gmail.com">macartan@gmail.com</a>
</p>
</li>
<li><p> Luke Sonnet <a href="mailto:luke.sonnet@gmail.com">luke.sonnet@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Neal Fultz <a href="mailto:nfultz@gmail.com">nfultz@gmail.com</a> [contributor]
</p>
</li>
<li><p> Lily Medina <a href="mailto:lilymiru@gmail.com">lilymiru@gmail.com</a> [contributor]
</p>
</li>
<li><p> Russell Lenth <a href="mailto:russell-lenth@uiowa.edu">russell-lenth@uiowa.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://declaredesign.org/r/estimatr/">https://declaredesign.org/r/estimatr/</a>
</p>
</li>
<li> <p><a href="https://github.com/DeclareDesign/estimatr">https://github.com/DeclareDesign/estimatr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DeclareDesign/estimatr/issues">https://github.com/DeclareDesign/estimatr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='alo_star_men'>Replication data for Lin 2013</h2><span id='topic+alo_star_men'></span>

<h3>Description</h3>

<p>A dataset containing the data to replicate:
Lin, Winston. 2013. &quot;Agnostic notes on regression adjustments to experimental
data: Reexamining Freedman's critique.&quot; The Annals of Applied Statistics.
Stat. 7(1): 295-318. doi:10.1214/12-AOAS583.
https://projecteuclid.org/euclid.aoas/1365527200.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alo_star_men
</code></pre>


<h3>Format</h3>

<p>A data frame with educational treatments and outcomes:
</p>

<dl>
<dt>gpa0</dt><dd><p>high school GPA</p>
</dd>
<dt>sfsp</dt><dd><p>financial incentives and support treatment</p>
</dd>
<dt>ssp</dt><dd><p>support only treatment</p>
</dd>
<dt>GPA_year1</dt><dd><p>college GPA year 1</p>
</dd>
<dt>GPA_year2</dt><dd><p>college GPA year 2</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data was originally taken from the following paper, subset to men who
showed up to college, were in one of the arms with the support condition,
and had GPA data for their first year in college.
</p>
<p>Angrist, Joshua, Daniel Lang, and Philip Oreopoulos. 2009. &quot;Incentives and
Services for College Achievement: Evidence from a Randomized Trial.&quot; American
Economic Journal: Applied Economics 1(1): 136-63.
https://www.aeaweb.org/articles?id=10.1257/app.1.1.136
</p>


<h3>Source</h3>

<p><a href="https://www.aeaweb.org/articles?id=10.1257/app.1.1.136">https://www.aeaweb.org/articles?id=10.1257/app.1.1.136</a>
</p>

<hr>
<h2 id='commarobust'>Build lm_robust object from lm fit</h2><span id='topic+commarobust'></span>

<h3>Description</h3>

<p>Build lm_robust object from lm fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commarobust(model, se_type = NULL, clusters = NULL, ci = TRUE, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commarobust_+3A_model">model</code></td>
<td>
<p>an lm model object</p>
</td></tr>
<tr><td><code id="commarobust_+3A_se_type">se_type</code></td>
<td>
<p>The sort of standard error sought. If <code>clusters</code> is
not specified the options are &quot;HC0&quot;, &quot;HC1&quot; (or &quot;stata&quot;, the equivalent),
&quot;HC2&quot; (default), &quot;HC3&quot;, or &quot;classical&quot;. If <code>clusters</code> is specified the
options are &quot;CR0&quot;, &quot;CR2&quot; (default), or &quot;stata&quot;. Can also specify &quot;none&quot;,
which may speed up estimation of the coefficients.</p>
</td></tr>
<tr><td><code id="commarobust_+3A_clusters">clusters</code></td>
<td>
<p>A vector corresponding to the clusters in the data.</p>
</td></tr>
<tr><td><code id="commarobust_+3A_ci">ci</code></td>
<td>
<p>logical. Whether to compute and return p-values and confidence
intervals, TRUE by default.</p>
</td></tr>
<tr><td><code id="commarobust_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, 0.05 by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+lm_robust">lm_robust</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lmo &lt;- lm(mpg ~ hp, data = mtcars)

# Default HC2
commarobust(lmo)

commarobust(lmo, se_type = "HC3")

commarobust(lmo, se_type = "stata", clusters = mtcars$carb)

</code></pre>

<hr>
<h2 id='declaration_to_condition_pr_mat'>Builds condition probability matrices for Horvitz-Thompson estimation from
<span class="pkg">randomizr</span> declaration</h2><span id='topic+declaration_to_condition_pr_mat'></span>

<h3>Description</h3>

<p>Builds condition probability matrices for Horvitz-Thompson estimation from
<span class="pkg">randomizr</span> declaration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>declaration_to_condition_pr_mat(
  ra_declaration,
  condition1 = NULL,
  condition2 = NULL,
  prob_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="declaration_to_condition_pr_mat_+3A_ra_declaration">ra_declaration</code></td>
<td>
<p>An object of class <code>"ra_declaration"</code>, generated
by the <code><a href="randomizr.html#topic+declare_ra">declare_ra</a></code> function in <span class="pkg">randomizr</span>. This
object contains the experimental design that will be represented in a
condition probability matrix</p>
</td></tr>
<tr><td><code id="declaration_to_condition_pr_mat_+3A_condition1">condition1</code></td>
<td>
<p>The name of the first condition, often the control group. If <code>NULL</code>,
defaults to first condition in randomizr declaration. Either both <code>condition1</code>
and <code>condition2</code> have to be specified or both left as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="declaration_to_condition_pr_mat_+3A_condition2">condition2</code></td>
<td>
<p>The name of the second condition, often the treatment group. If <code>NULL</code>,
defaults to second condition in randomizr declaration. Either both <code>condition1</code>
and <code>condition2</code> have to be specified or both left as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="declaration_to_condition_pr_mat_+3A_prob_matrix">prob_matrix</code></td>
<td>
<p>An optional probability matrix to override the one in
<code>ra_declaration</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a <code>"ra_declaration"</code>, generated
by the <code><a href="randomizr.html#topic+declare_ra">declare_ra</a></code> function in <span class="pkg">randomizr</span> and
returns a 2n*2n matrix that can be used to fully specify the design for
<code><a href="#topic+horvitz_thompson">horvitz_thompson</a></code> estimation. This is done by passing this
matrix to the <code>condition_pr_mat</code> argument of
<code><a href="#topic+horvitz_thompson">horvitz_thompson</a></code>.
</p>
<p>Currently, this function can learn the condition probability matrix for a
wide variety of randomizations: simple, complete, simple clustered, complete
clustered, blocked, block-clustered.
</p>
<p>A condition probability matrix is made up of four submatrices, each of which
corresponds to the
joint and marginal probability that each observation is in one of the two
treatment conditions.
</p>
<p>The upper-left quadrant is an n*n matrix. On the diagonal is the marginal
probability of being in condition 1, often control, for every unit
(Pr(Z_i = Condition1) where Z represents the vector of treatment conditions).
The off-diagonal elements are the joint probabilities of each unit being in
condition 1 with each other unit, Pr(Z_i = Condition1, Z_j = Condition1)
where i indexes the rows and j indexes the columns.
</p>
<p>The upper-right quadrant is also an n*n matrix. On the diagonal is the joint
probability of a unit being in condition 1 and condition 2, often the
treatment, and thus is always 0. The off-diagonal elements are the joint
probability of unit i being in condition 1 and unit j being in condition 2,
Pr(Z_i = Condition1, Z_j = Condition2).
</p>
<p>The lower-left quadrant is also an n*n matrix. On the diagonal is the joint
probability of a unit being in condition 1 and condition 2, and thus is
always 0. The off-diagonal elements are the joint probability of unit i
being in condition 2 and unit j being in condition 1,
Pr(Z_i = Condition2, Z_j = Condition1).
</p>
<p>The lower-right quadrant is an n*n matrix. On the diagonal is the marginal
probability of being in condition 2, often treatment, for every unit
(Pr(Z_i = Condition2)). The off-diagonal elements are the joint probability
of each unit being in condition 2 together,
Pr(Z_i = Condition2, Z_j = Condition2).
</p>


<h3>Value</h3>

<p>a numeric 2n*2n matrix of marginal and joint condition treatment
probabilities to be passed to the <code>condition_pr_mat</code> argument of
<code><a href="#topic+horvitz_thompson">horvitz_thompson</a></code>. See details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+permutations_to_condition_pr_mat">permutations_to_condition_pr_mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Learn condition probability matrix from complete blocked design
library(randomizr)
n &lt;- 100
dat &lt;- data.frame(
  blocks = sample(letters[1:10], size = n, replace = TRUE),
  y = rnorm(n)
)

# Declare complete blocked randomization
bl_declaration &lt;- declare_ra(blocks = dat$blocks, prob = 0.4, simple = FALSE)
# Get probabilities
block_pr_mat &lt;- declaration_to_condition_pr_mat(bl_declaration, 0, 1)
# Do randomiztion
dat$z &lt;- conduct_ra(bl_declaration)

horvitz_thompson(y ~ z, data = dat, condition_pr_mat = block_pr_mat)

# When you pass a declaration to horvitz_thompson, this function is called

# Equivalent to above call
horvitz_thompson(y ~ z, data = dat, ra_declaration = bl_declaration)

</code></pre>

<hr>
<h2 id='difference_in_means'>Design-based difference-in-means estimator</h2><span id='topic+difference_in_means'></span>

<h3>Description</h3>

<p>Difference-in-means estimators that selects the appropriate
point estimate, standard errors, and degrees of freedom for a variety of
designs: unit randomized, cluster randomized, block randomized,
block-cluster randomized, matched-pairs, and matched-pair cluster
randomized designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference_in_means(
  formula,
  data,
  blocks,
  clusters,
  weights,
  subset,
  se_type = c("default", "none"),
  condition1 = NULL,
  condition2 = NULL,
  ci = TRUE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference_in_means_+3A_formula">formula</code></td>
<td>
<p>an object of class formula, as in <code><a href="stats.html#topic+lm">lm</a></code>, such as
<code>Y ~ Z</code> with only one variable on the right-hand side, the treatment.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_blocks">blocks</code></td>
<td>
<p>An optional bare (unquoted) name of the block variable. Use
for blocked designs only.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_clusters">clusters</code></td>
<td>
<p>An optional bare (unquoted) name of the variable that
corresponds to the clusters in the data; used for cluster randomized
designs. For blocked designs, clusters must nest within blocks.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_weights">weights</code></td>
<td>
<p>the bare (unquoted) names of the weights variable in the
supplied data.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_subset">subset</code></td>
<td>
<p>An optional bare (unquoted) expression specifying a subset of
observations to be used.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_se_type">se_type</code></td>
<td>
<p>An optional string that can be one of <code>c("default", "none")</code>. If &quot;default&quot; (the default), it will use the default standard error estimator for the design, and if &quot;none&quot; then standard errors will not be computed which may speed up run time if only the point estimate is required.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_condition1">condition1</code></td>
<td>
<p>value in the treatment vector of the condition
to be the control. Effects are
estimated with <code>condition1</code> as the control and <code>condition2</code> as the
treatment. If unspecified, <code>condition1</code> is the &quot;first&quot; condition and
<code>condition2</code> is the &quot;second&quot; according to levels if the treatment is a
factor or according to a sortif it is a numeric or character variable (i.e
if unspecified and the treatment is 0s and 1s, <code>condition1</code> will by
default be 0 and <code>condition2</code> will be 1). See the examples for more.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_condition2">condition2</code></td>
<td>
<p>value in the treatment vector of the condition to be the
treatment. See <code>condition1</code>.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_ci">ci</code></td>
<td>
<p>logical. Whether to compute and return p-values and
confidence intervals, TRUE by default.</p>
</td></tr>
<tr><td><code id="difference_in_means_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, 0.05 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a difference-in-means estimator, with
support for blocked, clustered, matched-pairs, block-clustered, and
matched-pair clustered designs. One specifies their design by passing
the blocks and clusters in their data and this function chooses which
estimator is most appropriate.
</p>
<p>If you pass only <code>blocks</code>, if all blocks are of size two, we will
infer that the design is a matched-pairs design. If they are all size four
or larger, we will infer that it is a regular blocked design. If you pass
both <code>blocks</code> and <code>clusters</code>, we will similarly
infer whether it is a matched-pairs clustered design or a block-clustered
design the number of clusters per block. If the user passes only
<code>clusters</code>, we will infer that the design was cluster-randomized. If
the user specifies neither the <code>blocks</code> nor the <code>clusters</code>,
a regular Welch's t-test will be performed.
</p>
<p>Importantly, if the user specifies weights, the estimation is handed off
to <code><a href="#topic+lm_robust">lm_robust</a></code> with the appropriate robust standard errors
as weighted difference-in-means estimators are not implemented here.
More details of the about each of the estimators can be found in the
<a href="https://declaredesign.org/r/estimatr/articles/mathematical-notes.html">mathematical notes</a>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"difference_in_means"</code>.
</p>
<p>The post-estimation commands functions <code>summary</code> and <code><a href="#topic+tidy">tidy</a></code>
return results in a <code>data.frame</code>. To get useful data out of the return,
you can use these data frames, you can use the resulting list directly, or
you can use the generic accessor functions <code>coef</code> and
<code>confint</code>.
</p>
<p>An object of class <code>"difference_in_means"</code> is a list containing at
least the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated difference in means</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>the estimated standard error</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the t-statistic</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the estimated degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value from a two-sided t-test using <code>coefficients</code>, <code>std.error</code>, and <code>df</code></p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>the lower bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>the upper bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a character vector of coefficient names</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the significance level specified by the user</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>the name of the outcome variable</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the name of the design learned from the arguments passed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gerber, Alan S, and Donald P Green. 2012. Field Experiments: Design, Analysis, and Interpretation. New York: W.W. Norton.
</p>
<p>Imai, Kosuke, Gary King, Clayton Nall. 2009. &quot;The Essential Role of Pair Matching in Cluster-Randomized Experiments, with Application to the Mexican Universal Health Insurance Evaluation.&quot; Statistical Science 24 (1). Institute of Mathematical Statistics: 29-53. <a href="https://doi.org/10.1214/08-STS274">doi:10.1214/08-STS274</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm_lin">lm_lin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fabricatr)
library(randomizr)
# Get appropriate standard errors for unit-randomized designs

# ----------
# 1. Unit randomized
# ----------
dat &lt;- fabricate(
  N = 100,
  Y = rnorm(100),
  Z_comp = complete_ra(N, prob = 0.4),
)

table(dat$Z_comp)
difference_in_means(Y ~ Z_comp, data = dat)

# ----------
# 2. Cluster randomized
# ----------
# Accurates estimates and standard errors for clustered designs
dat$clust &lt;- sample(20, size = nrow(dat), replace = TRUE)
dat$Z_clust &lt;- cluster_ra(dat$clust, prob = 0.6)

table(dat$Z_clust, dat$clust)
summary(difference_in_means(Y ~ Z_clust, clusters = clust, data = dat))

# ----------
# 3. Block randomized
# ----------
dat$block &lt;- rep(1:10, each = 10)
dat$Z_block &lt;- block_ra(dat$block, prob = 0.5)

table(dat$Z_block, dat$block)
difference_in_means(Y ~ Z_block, blocks = block, data = dat)

# ----------
# 4. Block cluster randomized
# ----------
# Learns this design if there are two clusters per block
dat$small_clust &lt;- rep(1:50, each = 2)
dat$big_blocks &lt;- rep(1:5, each = 10)

dat$Z_blcl &lt;- block_and_cluster_ra(
  blocks = dat$big_blocks,
  clusters = dat$small_clust
 )

difference_in_means(
  Y ~ Z_blcl,
  blocks = big_blocks,
  clusters = small_clust,
  data = dat
 )

# ----------
# 5. Matched-pairs
# ----------
# Matched-pair estimates and standard errors are also accurate
# Specified same as blocked design, function learns that
# it is matched pair from size of blocks!
dat$pairs &lt;- rep(1:50, each = 2)
dat$Z_pairs &lt;- block_ra(dat$pairs, prob = 0.5)

table(dat$pairs, dat$Z_pairs)
difference_in_means(Y ~ Z_pairs, blocks = pairs, data = dat)

# ----------
# 6. Matched-pair cluster randomized
# ----------
# Learns this design if there are two clusters per block
dat$small_clust &lt;- rep(1:50, each = 2)
dat$cluster_pairs &lt;- rep(1:25, each = 4)
table(dat$cluster_pairs, dat$small_clust)

dat$Z_mpcl &lt;- block_and_cluster_ra(
  blocks = dat$cluster_pairs,
  clusters = dat$small_clust
 )

difference_in_means(
  Y ~ Z_mpcl,
  blocks = cluster_pairs,
  clusters = small_clust,
  data = dat
 )

# ----------
# Other examples
# ----------

# Also works with multi-valued treatments if users specify
# comparison of interest
dat$Z_multi &lt;- simple_ra(
  nrow(dat),
  conditions = c("Treatment 2", "Treatment 1", "Control"),
  prob_each = c(0.4, 0.4, 0.2)
)

# Only need to specify which condition is treated `condition2` and
# which is control `condition1`
difference_in_means(
  Y ~ Z_multi,
  condition1 = "Treatment 2",
  condition2 = "Control",
  data = dat
)
difference_in_means(
  Y ~ Z_multi,
  condition1 = "Treatment 1",
  condition2 = "Control",
  data = dat
)

# Specifying weights will result in estimation via lm_robust()
dat$w &lt;- runif(nrow(dat))
difference_in_means(Y ~ Z_comp, weights = w, data = dat)
lm_robust(Y ~ Z_comp, weights = w, data = dat)

</code></pre>

<hr>
<h2 id='estimatr_glancers'>Glance at an estimatr object</h2><span id='topic+estimatr_glancers'></span><span id='topic+glance.lm_robust'></span><span id='topic+glance.lh_robust'></span><span id='topic+glance.iv_robust'></span><span id='topic+glance.difference_in_means'></span><span id='topic+glance.horvitz_thompson'></span>

<h3>Description</h3>

<p>Glance at an estimatr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_robust'
glance(x, ...)

## S3 method for class 'lh_robust'
glance(x, ...)

## S3 method for class 'iv_robust'
glance(x, ...)

## S3 method for class 'difference_in_means'
glance(x, ...)

## S3 method for class 'horvitz_thompson'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatr_glancers_+3A_x">x</code></td>
<td>
<p>An object returned by one of the estimators</p>
</td></tr>
<tr><td><code id="estimatr_glancers_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>glance.lm_robust</code>, a data.frame with columns:
</p>
<table>
<tr><td><code>r.squared</code></td>
<td>
<p>the <code class="reqn">R^2</code>,
</p>
<p style="text-align: center;"><code class="reqn">R^2 = 1 - Sum(e[i]^2) / Sum((y[i] - y^*)^2),</code>
</p>
<p> where <code class="reqn">y^*</code>
is the mean of <code class="reqn">y[i]</code> if there is an intercept and zero otherwise,
and <code class="reqn">e[i]</code> is the ith residual.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the <code class="reqn">R^2</code> but penalized for having more parameters, <code>rank</code></p>
</td></tr>
<tr><td><code>se_type</code></td>
<td>
<p>the standard error type specified by the user</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the F-statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value from the F test</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
</table>
<p>For <code>glance.lh_robust</code>, we glance the <code>lm_robust</code> component only. You can access the linear hypotheses as a data.frame directy from the <code>lh</code> component of the <code>lh_robust</code> object
</p>
<p>For <code>glance.iv_robust</code>, a data.frame with columns:
</p>
<table>
<tr><td><code>r.squared</code></td>
<td>
<p>The <code class="reqn">R^2</code> of the second stage regression</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>The <code class="reqn">R^2</code> but penalized for having more parameters, <code>rank</code></p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>se_type</code></td>
<td>
<p>the standard error type specified by the user</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the F-statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value from the F test</p>
</td></tr>
<tr><td><code>statistic.weakinst</code></td>
<td>
<p>the value of the first stage F-statistic, useful for the weak instruments test; only reported if there is only one endogenous variable</p>
</td></tr>
<tr><td><code>p.value.weakinst</code></td>
<td>
<p>p-value from the first-stage F test, a test of weak instruments; only reported if there is only one endogenous variable</p>
</td></tr>
<tr><td><code>statistic.endogeneity</code></td>
<td>
<p>the value of the F-statistic for the test of endogeneity; often called the Wu-Hausman statistic, with robust standard errors, we employ the regression based test</p>
</td></tr>
<tr><td><code>p.value.endogeneity</code></td>
<td>
<p>p-value from the F-test for endogeneity</p>
</td></tr>
<tr><td><code>statistic.overid</code></td>
<td>
<p>the value of the chi-squared statistic for the test of instrument correlation with the error term; only reported with overidentification</p>
</td></tr>
<tr><td><code>p.value.overid</code></td>
<td>
<p>p-value from the chi-squared test; only reported with overidentification</p>
</td></tr>
</table>
<p>For <code>glance.difference_in_means</code>, a data.frame with columns:
</p>
<table>
<tr><td><code>design</code></td>
<td>
<p>the design used, and therefore the estimator used</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>nblocks</code></td>
<td>
<p>the number of blocks, if used</p>
</td></tr>
<tr><td><code>nclusters</code></td>
<td>
<p>the number of clusters, if used</p>
</td></tr>
<tr><td><code>condition2</code></td>
<td>
<p>the second, &quot;treatment&quot;, condition</p>
</td></tr>
<tr><td><code>condition1</code></td>
<td>
<p>the first, &quot;control&quot;, condition</p>
</td></tr>
</table>
<p>For <code>glance.horvitz_thompson</code>, a data.frame with columns:
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>se_type</code></td>
<td>
<p>the type of standard error estimator used</p>
</td></tr>
<tr><td><code>condition2</code></td>
<td>
<p>the second, &quot;treatment&quot;, condition</p>
</td></tr>
<tr><td><code>condition1</code></td>
<td>
<p>the first, &quot;control&quot;, condition</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+glance">generics::glance()</a></code>, <code><a href="#topic+lm_robust">lm_robust()</a></code>, <code><a href="#topic+lm_lin">lm_lin()</a></code>, <code><a href="#topic+iv_robust">iv_robust()</a></code>, <code><a href="#topic+difference_in_means">difference_in_means()</a></code>, <code><a href="#topic+horvitz_thompson">horvitz_thompson()</a></code>
</p>

<hr>
<h2 id='estimatr_tidiers'>Tidy an estimatr object</h2><span id='topic+estimatr_tidiers'></span><span id='topic+tidy.lm_robust'></span><span id='topic+tidy.iv_robust'></span><span id='topic+tidy.difference_in_means'></span><span id='topic+tidy.horvitz_thompson'></span><span id='topic+tidy.lh_robust'></span><span id='topic+tidy.lh'></span>

<h3>Description</h3>

<p>Tidy an estimatr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_robust'
tidy(x, conf.int = TRUE, conf.level = NULL, ...)

## S3 method for class 'iv_robust'
tidy(x, conf.int = TRUE, conf.level = NULL, ...)

## S3 method for class 'difference_in_means'
tidy(x, conf.int = TRUE, conf.level = NULL, ...)

## S3 method for class 'horvitz_thompson'
tidy(x, conf.int = TRUE, conf.level = NULL, ...)

## S3 method for class 'lh_robust'
tidy(x, conf.int = TRUE, conf.level = NULL, ...)

## S3 method for class 'lh'
tidy(x, conf.int = TRUE, conf.level = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatr_tidiers_+3A_x">x</code></td>
<td>
<p>An object returned by one of the estimators</p>
</td></tr>
<tr><td><code id="estimatr_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a
confidence interval in the tidied output. Defaults to ‘TRUE’.</p>
</td></tr>
<tr><td><code id="estimatr_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence
interval if ‘conf.int = TRUE’. Must be strictly greater than 0 and less
than 1. Defaults to 0.95, which corresponds to a 95 percent confidence
interval.</p>
</td></tr>
<tr><td><code id="estimatr_tidiers_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns for coefficient names, estimates, standard
errors, confidence intervals, p-values, degrees of freedom, and the
name of the outcome variable
</p>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+tidy">generics::tidy()</a></code>, <code><a href="#topic+lm_robust">lm_robust()</a></code>, <code><a href="#topic+iv_robust">iv_robust()</a></code>,  <code><a href="#topic+difference_in_means">difference_in_means()</a></code>, <code><a href="#topic+horvitz_thompson">horvitz_thompson()</a></code>
</p>

<hr>
<h2 id='extract.robust_default'>Extract model data for <span class="pkg">texreg</span> package</h2><span id='topic+extract.robust_default'></span><span id='topic+extract.lm_robust'></span><span id='topic+extract.iv_robust'></span>

<h3>Description</h3>

<p>Prepares a <code>"lm_robust"</code> or <code>"iv_robust"</code> object for the <span class="pkg">texreg</span>
package. This is largely a clone of the <code>extract.lm</code>
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.robust_default(
  model,
  include.ci = TRUE,
  include.rsquared = TRUE,
  include.adjrs = TRUE,
  include.nobs = TRUE,
  include.fstatistic = FALSE,
  include.rmse = TRUE,
  include.nclusts = TRUE,
  ...
)

extract.lm_robust(
  model,
  include.ci = TRUE,
  include.rsquared = TRUE,
  include.adjrs = TRUE,
  include.nobs = TRUE,
  include.fstatistic = FALSE,
  include.rmse = TRUE,
  include.nclusts = TRUE,
  ...
)

extract.iv_robust(
  model,
  include.ci = TRUE,
  include.rsquared = TRUE,
  include.adjrs = TRUE,
  include.nobs = TRUE,
  include.fstatistic = FALSE,
  include.rmse = TRUE,
  include.nclusts = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.robust_default_+3A_model">model</code></td>
<td>
<p>an object of class <code><a href="#topic+lm_robust">lm_robust</a></code> or <code>"iv_robust"</code></p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_include.ci">include.ci</code></td>
<td>
<p>logical. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_include.rsquared">include.rsquared</code></td>
<td>
<p>logical. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_include.adjrs">include.adjrs</code></td>
<td>
<p>logical. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_include.nobs">include.nobs</code></td>
<td>
<p>logical. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_include.fstatistic">include.fstatistic</code></td>
<td>
<p>logical. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_include.rmse">include.rmse</code></td>
<td>
<p>logical. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_include.nclusts">include.nclusts</code></td>
<td>
<p>logical. Defaults to TRUE if clusters in <code>model</code></p>
</td></tr>
<tr><td><code id="extract.robust_default_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='gen_pr_matrix_cluster'>Generate condition probability matrix given clusters and probabilities</h2><span id='topic+gen_pr_matrix_cluster'></span>

<h3>Description</h3>

<p>Generate condition probability matrix given clusters and probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_pr_matrix_cluster(clusters, treat_probs, simple)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_pr_matrix_cluster_+3A_clusters">clusters</code></td>
<td>
<p>A vector of clusters</p>
</td></tr>
<tr><td><code id="gen_pr_matrix_cluster_+3A_treat_probs">treat_probs</code></td>
<td>
<p>A vector of treatment (condition 2) probabilities</p>
</td></tr>
<tr><td><code id="gen_pr_matrix_cluster_+3A_simple">simple</code></td>
<td>
<p>A boolean for whether the assignment is a random sample
assignment (TRUE, default) or complete random assignment (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric 2n*2n matrix of marginal and joint condition treatment
probabilities to be passed to the <code>condition_pr_mat</code> argument of
<code><a href="#topic+horvitz_thompson">horvitz_thompson</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+declaration_to_condition_pr_mat">declaration_to_condition_pr_mat</a></code>
</p>

<hr>
<h2 id='horvitz_thompson'>Horvitz-Thompson estimator for two-armed trials</h2><span id='topic+horvitz_thompson'></span>

<h3>Description</h3>

<p>Horvitz-Thompson estimators that are unbiased for designs in
which the randomization scheme is known
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horvitz_thompson(
  formula,
  data,
  blocks,
  clusters,
  simple = NULL,
  condition_prs,
  condition_pr_mat = NULL,
  ra_declaration = NULL,
  subset,
  condition1 = NULL,
  condition2 = NULL,
  se_type = c("youngs", "constant", "none"),
  ci = TRUE,
  alpha = 0.05,
  return_condition_pr_mat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horvitz_thompson_+3A_formula">formula</code></td>
<td>
<p>an object of class formula, as in <code><a href="stats.html#topic+lm">lm</a></code>, such as
<code>Y ~ Z</code> with only one variable on the right-hand side, the treatment.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_data">data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_blocks">blocks</code></td>
<td>
<p>An optional bare (unquoted) name of the block variable. Use
for blocked designs only. See details.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_clusters">clusters</code></td>
<td>
<p>An optional bare (unquoted) name of the variable that
corresponds to the clusters in the data; used for cluster randomized
designs. For blocked designs, clusters must be within blocks.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_simple">simple</code></td>
<td>
<p>logical, optional. Whether the randomization is simple
(TRUE) or complete (FALSE). This is ignored if <code>blocks</code> are specified,
as all blocked designs use complete randomization, or either
<code>ra_declaration</code> or <code>condition_pr_mat</code> are passed. Otherwise, it
defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_condition_prs">condition_prs</code></td>
<td>
<p>An optional bare (unquoted) name of the variable with
the condition 2 (treatment) probabilities. See details. May also use a single
number for the condition 2 probability if it is constant.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_condition_pr_mat">condition_pr_mat</code></td>
<td>
<p>An optional 2n * 2n matrix of marginal and joint
probabilities of all units in condition1 and condition2. See details.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_ra_declaration">ra_declaration</code></td>
<td>
<p>An object of class <code>"ra_declaration"</code>, from
the <code><a href="randomizr.html#topic+declare_ra">declare_ra</a></code> function in the <span class="pkg">randomizr</span>
package. This is the third way that one can specify a design for this
estimator. Cannot be used along with any of <code>condition_prs</code>,
<code>blocks</code>, <code>clusters</code>, or <code>condition_pr_mat</code>. See details.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_subset">subset</code></td>
<td>
<p>An optional bare (unquoted) expression specifying a subset of
observations to be used.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_condition1">condition1</code></td>
<td>
<p>value in the treatment vector of the condition
to be the control. Effects are
estimated with <code>condition1</code> as the control and <code>condition2</code> as the
treatment. If unspecified, <code>condition1</code> is the &quot;first&quot; condition and
<code>condition2</code> is the &quot;second&quot; according to levels if the treatment is a
factor or according to a sortif it is a numeric or character variable (i.e
if unspecified and the treatment is 0s and 1s, <code>condition1</code> will by
default be 0 and <code>condition2</code> will be 1). See the examples for more.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_condition2">condition2</code></td>
<td>
<p>value in the treatment vector of the condition to be the
treatment. See <code>condition1</code>.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_se_type">se_type</code></td>
<td>
<p>can be one of <code>c("youngs", "constant", "none")</code> and corresponds
the estimator of the standard errors. Default estimator uses Young's
inequality (and is conservative) while the other uses a constant treatment
effects assumption and only works for simple randomized designs at the
moment. If &quot;none&quot; then standard errors will not be computed which may speed up run time if only the point estimate is required.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_ci">ci</code></td>
<td>
<p>logical. Whether to compute and return p-values and
confidence intervals, TRUE by default.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, 0.05 by default.</p>
</td></tr>
<tr><td><code id="horvitz_thompson_+3A_return_condition_pr_mat">return_condition_pr_mat</code></td>
<td>
<p>logical. Whether to return the condition
probability matrix. Returns NULL if the design is simple randomization,
FALSE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the Horvitz-Thompson estimator for
treatment effects for two-armed trials. This estimator is useful for estimating unbiased
treatment effects given any randomization scheme as long as the
randomization scheme is known.
</p>
<p>In short, the Horvitz-Thompson estimator essentially reweights each unit
by the probability of it being in its observed condition. Pivotal to the
estimation of treatment effects using this estimator are the marginal
condition probabilities (i.e., the probability that any one unit is in
a particular treatment condition). Pivotal to estimating the variance
whenever the design is more complicated than simple randomization are the
joint condition probabilities (i.e., the probabilities that any two units
have a particular set of treatment conditions, either the same or
different). The estimator we provide here considers the case with two
treatment conditions.
</p>
<p>Users interested in more details can see the
<a href="https://declaredesign.org/r/estimatr/articles/mathematical-notes.html">mathematical notes</a>
for more information and references, or see the references below.
</p>
<p>There are three distinct ways that users can specify the design to the
function. The preferred way is to use
the <code><a href="randomizr.html#topic+declare_ra">declare_ra</a></code> function in the <span class="pkg">randomizr</span>
package. This function takes several arguments, including blocks, clusters,
treatment probabilities, whether randomization is simple or not, and more.
Passing the outcome of that function, an object of class
<code>"ra_declaration"</code> to the <code>ra_declaration</code> argument in this function,
will lead to a call of the <code><a href="#topic+declaration_to_condition_pr_mat">declaration_to_condition_pr_mat</a></code>
function which generates the condition probability matrix needed to
estimate treatment effects and standard errors. We provide many examples
below of how this could be done.
</p>
<p>The second way is to pass the names of vectors in your <code>data</code> to
<code>condition_prs</code>, <code>blocks</code>, and <code>clusters</code>. You can further
specify whether the randomization was simple or complete using the <code>simple</code>
argument. Note that if <code>blocks</code> are specified the randomization is
always treated as complete. From these vectors, the function learns how to
build the condition probability matrix that is used in estimation.
</p>
<p>In the case
where <code>condition_prs</code> is specified, this function assumes those
probabilities are the marginal probability that each unit is in condition2
and then uses the other arguments (<code>blocks</code>, <code>clusters</code>,
<code>simple</code>) to learn the rest of the design. If users do not pass
<code>condition_prs</code>, this function learns the probability of being in
condition2 from the data. That is, none of these arguments are specified,
we assume that there was a simple randomization where the probability
of each unit being in condition2 was the average of all units in condition2.
Similarly, we learn the block-level probability of treatment within
<code>blocks</code> by looking at the mean number of units in condition2 if
<code>condition_prs</code> is not specified.
</p>
<p>The third way is to pass a <code>condition_pr_mat</code> directly. One can
see more about this object in the documentation for
<code><a href="#topic+declaration_to_condition_pr_mat">declaration_to_condition_pr_mat</a></code> and
<code><a href="#topic+permutations_to_condition_pr_mat">permutations_to_condition_pr_mat</a></code>. Essentially, this 2n * 2n
matrix allows users to specify marginal and joint marginal probabilities
of units being in conditions 1 and 2 of arbitrary complexity. Users should
only use this option if they are certain they know what they are doing.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"horvitz_thompson"</code>.
</p>
<p>The post-estimation commands functions <code>summary</code> and <code><a href="#topic+tidy">tidy</a></code>
return results in a <code>data.frame</code>. To get useful data out of the return,
you can use these data frames, you can use the resulting list directly, or
you can use the generic accessor functions <code>coef</code> and
<code>confint</code>.
</p>
<p>An object of class <code>"horvitz_thompson"</code> is a list containing at
least the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated difference in totals</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>the estimated standard error</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the z-statistic</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the estimated degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value from a two-sided z-test using <code>coefficients</code> and <code>std.error</code></p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>the lower bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>the upper bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a character vector of coefficient names</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the significance level specified by the user</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>the name of the outcome variable</p>
</td></tr>
<tr><td><code>condition_pr_mat</code></td>
<td>
<p>the condition probability matrix if <code>return_condition_pr_mat</code> is TRUE</p>
</td></tr>
</table>


<h3>References</h3>

<p>Aronow, Peter M, and Joel A Middleton. 2013. &quot;A Class of Unbiased Estimators of the Average Treatment Effect in Randomized Experiments.&quot; Journal of Causal Inference 1 (1): 135-54. <a href="https://doi.org/10.1515/jci-2012-0009">doi:10.1515/jci-2012-0009</a>.
</p>
<p>Aronow, Peter M, and Cyrus Samii. 2017. &quot;Estimating Average Causal Effects Under Interference Between Units.&quot; Annals of Applied Statistics, forthcoming. <a href="https://arxiv.org/abs/1305.6156v3">https://arxiv.org/abs/1305.6156v3</a>.
</p>
<p>Middleton, Joel A, and Peter M Aronow. 2015. &quot;Unbiased Estimation of the Average Treatment Effect in Cluster-Randomized Experiments.&quot; Statistics, Politics and Policy 6 (1-2): 39-75. <a href="https://doi.org/10.1515/spp-2013-0002">doi:10.1515/spp-2013-0002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="randomizr.html#topic+declare_ra">declare_ra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set seed
set.seed(42)

# Simulate data
n &lt;- 10
dat &lt;- data.frame(y = rnorm(n))

library(randomizr)

#----------
# 1. Simple random assignment
#----------
dat$p &lt;- 0.5
dat$z &lt;- rbinom(n, size = 1, prob = dat$p)

# If you only pass condition_prs, we assume simple random sampling
horvitz_thompson(y ~ z, data = dat, condition_prs = p)
# Assume constant effects instead
horvitz_thompson(y ~ z, data = dat, condition_prs = p, se_type = "constant")

# Also can use randomizr to pass a declaration
srs_declaration &lt;- declare_ra(N = nrow(dat), prob = 0.5, simple = TRUE)
horvitz_thompson(y ~ z, data = dat, ra_declaration = srs_declaration)

#----------
# 2. Complete random assignment
#----------

dat$z &lt;- sample(rep(0:1, each = n/2))
# Can use a declaration
crs_declaration &lt;- declare_ra(N = nrow(dat), prob = 0.5, simple = FALSE)
horvitz_thompson(y ~ z, data = dat, ra_declaration = crs_declaration)
# Can precompute condition_pr_mat and pass it
# (faster for multiple runs with same condition probability matrix)
crs_pr_mat &lt;- declaration_to_condition_pr_mat(crs_declaration)
horvitz_thompson(y ~ z, data = dat, condition_pr_mat = crs_pr_mat)

#----------
# 3. Clustered treatment, complete random assigment
#-----------
# Simulating data
dat$cl &lt;- rep(1:4, times = c(2, 2, 3, 3))
dat$prob &lt;- 0.5
clust_crs_decl &lt;- declare_ra(N = nrow(dat), clusters = dat$cl, prob = 0.5)
dat$z &lt;- conduct_ra(clust_crs_decl)
# Easiest to specify using declaration
ht_cl &lt;- horvitz_thompson(y ~ z, data = dat, ra_declaration = clust_crs_decl)
# Also can pass the condition probability and the clusters
ht_cl_manual &lt;- horvitz_thompson(
  y ~ z,
  data = dat,
  clusters = cl,
  condition_prs = prob,
  simple = FALSE
)
ht_cl
ht_cl_manual

# Blocked estimators specified similarly

#----------
# More complicated assignment
#----------

# arbitrary permutation matrix
possible_treats &lt;- cbind(
  c(1, 1, 0, 1, 0, 0, 0, 1, 1, 0),
  c(0, 1, 1, 0, 1, 1, 0, 1, 0, 1),
  c(1, 0, 1, 1, 1, 1, 1, 0, 0, 0)
)
arb_pr_mat &lt;- permutations_to_condition_pr_mat(possible_treats)
# Simulating a column to be realized treatment
dat$z &lt;- possible_treats[, sample(ncol(possible_treats), size = 1)]
horvitz_thompson(y ~ z, data = dat, condition_pr_mat = arb_pr_mat)

</code></pre>

<hr>
<h2 id='iv_robust'>Two-Stage Least Squares Instrumental Variables Regression</h2><span id='topic+iv_robust'></span>

<h3>Description</h3>

<p>This formula estimates an instrumental variables regression
using two-stage least squares with a variety of options for robust
standard errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_robust(
  formula,
  data,
  weights,
  subset,
  clusters,
  fixed_effects,
  se_type = NULL,
  ci = TRUE,
  alpha = 0.05,
  diagnostics = FALSE,
  return_vcov = TRUE,
  try_cholesky = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iv_robust_+3A_formula">formula</code></td>
<td>
<p>an object of class formula of the regression and the instruments.
For example, the formula <code>y ~ x1 + x2 | z1 + z2</code> specifies <code>x1</code> and <code>x2</code>
as endogenous regressors and <code>z1</code> and <code>z2</code> as their respective instruments.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="iv_robust_+3A_weights">weights</code></td>
<td>
<p>the bare (unquoted) names of the weights variable in the
supplied data.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_subset">subset</code></td>
<td>
<p>An optional bare (unquoted) expression specifying a subset
of observations to be used.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_clusters">clusters</code></td>
<td>
<p>An optional bare (unquoted) name of the variable that
corresponds to the clusters in the data.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>An optional right-sided formula containing the fixed
effects that will be projected out of the data, such as <code>~ blockID</code>. Do not
pass multiple-fixed effects with intersecting groups. Speed gains are greatest for
variables with large numbers of groups and when using &quot;HC1&quot; or &quot;stata&quot; standard errors.
See 'Details'.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_se_type">se_type</code></td>
<td>
<p>The sort of standard error sought. If <code>clusters</code> is
not specified the options are &quot;HC0&quot;, &quot;HC1&quot; (or &quot;stata&quot;, the equivalent),
&quot;HC2&quot; (default), &quot;HC3&quot;, or
&quot;classical&quot;. If <code>clusters</code> is specified the options are &quot;CR0&quot;, &quot;CR2&quot; (default), or &quot;stata&quot;. Can also specify &quot;none&quot;, which may speed up estimation of the coefficients.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_ci">ci</code></td>
<td>
<p>logical. Whether to compute and return p-values and confidence
intervals, TRUE by default.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, 0.05 by default.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_diagnostics">diagnostics</code></td>
<td>
<p>logical. Whether to compute and return instrumental variable diagnostic statistics and tests.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_return_vcov">return_vcov</code></td>
<td>
<p>logical. Whether to return the variance-covariance
matrix for later usage, TRUE by default.</p>
</td></tr>
<tr><td><code id="iv_robust_+3A_try_cholesky">try_cholesky</code></td>
<td>
<p>logical. Whether to try using a Cholesky
decomposition to solve least squares instead of a QR decomposition,
FALSE by default. Using a Cholesky decomposition may result in speed gains, but should only
be used if users are sure their model is full-rank (i.e., there is no
perfect multi-collinearity)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs two-stage least squares estimation to fit
instrumental variables regression. The syntax is similar to that in
<code>ivreg</code> from the <code>AER</code> package. Regressors and instruments
should be specified in a two-part formula, such as
<code>y ~ x1 + x2 | z1 + z2 + z3</code>, where <code>x1</code> and <code>x2</code> are
regressors and <code>z1</code>, <code>z2</code>, and <code>z3</code> are instruments. Unlike
<code>ivreg</code>, you must explicitly specify all exogenous regressors on
both sides of the bar.
</p>
<p>The default variance estimators are the same as in <code><a href="#topic+lm_robust">lm_robust</a></code>.
Without clusters, we default to <code>HC2</code> standard errors, and with clusters
we default to <code>CR2</code> standard errors. 2SLS variance estimates are
computed using the same estimators as in <code><a href="#topic+lm_robust">lm_robust</a></code>, however the
design matrix used are the second-stage regressors, which includes the estimated
endogenous regressors, and the residuals used are the difference
between the outcome and a fit produced by the second-stage coefficients and the
first-stage (endogenous) regressors. More notes on this can be found at
<a href="https://declaredesign.org/r/estimatr/articles/mathematical-notes.html">the mathematical appendix</a>.
</p>
<p>If <code>fixed_effects</code> are specified, both the outcome, regressors, and instruments
are centered using the method of alternating projections (Halperin 1962; Gaure 2013). Specifying
fixed effects in this way will result in large speed gains with standard error
estimators that do not need to invert the matrix of fixed effects. This means using
&quot;classical&quot;, &quot;HC0&quot;, &quot;HC1&quot;, &quot;CR0&quot;, or &quot;stata&quot; standard errors will be faster than other
standard error estimators. Be wary when specifying fixed effects that may result
in perfect fits for some observations or if there are intersecting groups across
multiple fixed effect variables (e.g. if you specify both &quot;year&quot; and &quot;country&quot; fixed effects
with an unbalanced panel where one year you only have data for one country).
</p>
<p>If <code>diagnostics</code> are requested, we compute and return three sets of diagnostics.
First, we return tests for weak instruments using first-stage F-statistics (<code>diagnostic_first_stage_fstatistic</code>). Specifically,
the F-statistics reported compare the model regressing each endogeneous variable on both the
included exogenous variables and the instruments to a model where each endogenous variable is
regressed only on the included exogenous variables (without the instruments). A significant F-test
for weak instruments provides evidence against the null hypothesis that the instruments are weak.
Second, we return tests for the endogeneity of the endogenous variables, often called the Wu-Hausman
test  (<code>diagnostic_endogeneity_test</code>). We implement the regression test from Hausman (1978), which allows for robust variance estimation.
A significant endogeneity test provides evidence against the null that all the variables are exogenous.
Third, we return a test for the correlation between the instruments and the error term  (<code>diagnostic_overid_test</code>). We implement
the Wooldridge (1995) robust score test, which is identical to Sargan's (1958) test with classical
standard errors. This test is only reported if the model is overidentified (i.e. the number of
instruments is greater than the number of endogenous regressors), and if no weights are specified.
</p>


<h3>Value</h3>

<p>An object of class <code>"iv_robust"</code>.
</p>
<p>The post-estimation commands functions <code>summary</code> and <code><a href="#topic+tidy">tidy</a></code>
return results in a <code>data.frame</code>. To get useful data out of the return,
you can use these data frames, you can use the resulting list directly, or
you can use the generic accessor functions <code>coef</code>, <code>vcov</code>,
<code>confint</code>, and <code>predict</code>.
</p>
<p>An object of class <code>"iv_robust"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated coefficients</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>the estimated standard errors</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the t-statistic</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the estimated degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-values from a two-sided t-test using <code>coefficients</code>, <code>std.error</code>, and <code>df</code></p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>the lower bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>the upper bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a character vector of coefficient names</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the significance level specified by the user</p>
</td></tr>
<tr><td><code>se_type</code></td>
<td>
<p>the standard error type specified by the user</p>
</td></tr>
<tr><td><code>res_var</code></td>
<td>
<p>the residual variance</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of columns in the design matrix (includes linearly dependent columns!)</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the fitted model</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the fitted variance covariance matrix</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>the <code class="reqn">R^2</code> of the second stage regression</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the <code class="reqn">R^2</code> of the second stage regression, but penalized for having more parameters, <code>rank</code></p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a vector with the value of the second stage F-statistic with the numerator and denominator degrees of freedom</p>
</td></tr>
<tr><td><code>firststage_fstatistic</code></td>
<td>
<p>a vector with the value of the first stage F-statistic with the numerator and denominator degrees of freedom, useful for a test for weak instruments</p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>whether or not weights were applied</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the matrix of predicted means</p>
</td></tr>
</table>
<p>We also return <code>terms</code> with the second stage terms and <code>terms_regressors</code> with the first stage terms, both of which used by <code>predict</code>. If <code>fixed_effects</code> are specified, then we return <code>proj_fstatistic</code>, <code>proj_r.squared</code>, and <code>proj_adj.r.squared</code>, which are model fit statistics that are computed on the projected model (after demeaning the fixed effects).
</p>
<p>We also return various diagnostics when <code>`diagnostics` == TRUE</code>. These are stored in <code>diagnostic_first_stage_fstatistic</code>, <code>diagnostic_endogeneity_test</code>, and <code>diagnostic_overid_test</code>. They have the test statistic, relevant degrees of freedom, and p.value in a named vector. See 'Details' for more. These are printed in a formatted table when the model object is passed to <code>summary()</code>.
</p>


<h3>References</h3>

<p>Gaure, Simon. 2013. &quot;OLS with multiple high dimensional category variables.&quot; Computational Statistics &amp; Data Analysis 66: 8-1. <a href="https://doi.org/10.1016/j.csda.2013.03.024">doi:10.1016/j.csda.2013.03.024</a>
</p>
<p>Halperin, I. 1962. &quot;The product of projection operators.&quot; Acta Scientiarum Mathematicarum (Szeged) 23(1-2): 96-99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fabricatr)
dat &lt;- fabricate(
  N = 40,
  Y = rpois(N, lambda = 4),
  Z = rbinom(N, 1, prob = 0.4),
  D  = Z * rbinom(N, 1, prob = 0.8),
  X = rnorm(N),
  G = sample(letters[1:4], N, replace = TRUE)
)

# Instrument for treatment `D` with encouragement `Z`
tidy(iv_robust(Y ~ D + X | Z + X, data = dat))

# Instrument with Stata's `ivregress 2sls , small rob` HC1 variance
tidy(iv_robust(Y ~ D | Z, data = dat, se_type = "stata"))

# With clusters, we use CR2 errors by default
dat$cl &lt;- rep(letters[1:5], length.out = nrow(dat))
tidy(iv_robust(Y ~ D | Z, data = dat, clusters = cl))

# Again, easy to replicate Stata (again with `small` correction in Stata)
tidy(iv_robust(Y ~ D | Z, data = dat, clusters = cl, se_type = "stata"))

# We can also specify fixed effects, that will be taken as exogenous regressors
# Speed gains with fixed effects are greatests with "stata" or "HC1" std.errors
tidy(iv_robust(Y ~ D | Z, data = dat, fixed_effects = ~ G, se_type = "HC1"))

</code></pre>

<hr>
<h2 id='lh_robust'>Linear Hypothesis for Ordinary Least Squares with Robust Standard Errors</h2><span id='topic+lh_robust'></span>

<h3>Description</h3>

<p>This function fits a linear model with robust standard errors and performs linear hypothesis test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lh_robust(..., data, linear_hypothesis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lh_robust_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to  <code><a href="#topic+lm_robust">lm_robust</a></code></p>
</td></tr>
<tr><td><code id="lh_robust_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="lh_robust_+3A_linear_hypothesis">linear_hypothesis</code></td>
<td>
<p>A character string or a matrix specifying combination, to be passed to the hypothesis.matrix argument of car::linearHypothesis
See <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code><a href="#topic+lm_robust">lm_robust</a></code> and for
<code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>. It first runs <code>lm_robust</code> and
next passes <code>"lm_robust"</code> object as an argument to <code>linearHypothesis</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"lh_robust"</code> containing the two following components:
</p>
<table>
<tr><td><code>lm_robust</code></td>
<td>
<p>an object as returned by <code>lm_robust</code>.</p>
</td></tr>
<tr><td><code>lh</code></td>
<td>
<p>A data frame with most of its columns pulled from <code>linearHypothesis</code>' output.</p>
</td></tr>
</table>
<p>The only analyis directly performed by <code>lh_robust</code> is a <code>t-test</code> for the null hypothesis of no effects of the linear combination of coefficients as specified by the user.
All other output components are either extracted from <code>linearHypothesis</code> or <code>lm_robust</code>.
</p>
<p>The original output returned by <code>linearHypothesis</code> is added as an attribute under the <code>"linear_hypothesis"</code> attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fabricatr)
dat &lt;- fabricate(
  N = 40,
  y = rpois(N, lambda = 4),
  x = rnorm(N),
  z = rbinom(N, 1, prob = 0.4),
  clusterID = sample(1:4, 40, replace = TRUE)
)

# Default variance estimator is HC2 robust standard errors
lhro &lt;- lh_robust(y ~ x + z, data = dat, linear_hypothesis = "z + 2x = 0")

# The linear hypothesis argument can be specified equivalently as:
lh_robust(y ~ x + z, data = dat, linear_hypothesis = "z = 2x")
lh_robust(y ~ x + z, data = dat, linear_hypothesis = "2*x +1*z")
lh_robust(y ~ x + z, data = dat, linear_hypothesis = "z + 2x = 0")

# Also recovers other sorts of standard erorrs just as specified in \code{\link{lm_robust}}
lh_robust(y ~ x + z, data = dat, linear_hypothesis = "z + 2x = 0", se_type = "classical")
lh_robust(y ~ x + z, data = dat, linear_hypothesis = "z + 2x = 0", se_type =  "HC1")

#  Can tidy() main output and subcomponents in to a data.frame
lhro &lt;- lh_robust(y ~ x + z, data = dat, linear_hypothesis = "z + 2x = 0")
tidy(lhro )
tidy(lhro$lm_robust)
tidy(lhro$lh)

# Can use summary() to get more statistics on the main output and subcomponents.
summary(lhro)
summary(lhro$lm_robust)
summary(lhro$lh)

</code></pre>

<hr>
<h2 id='lm_lin'>Linear regression with the Lin (2013) covariate adjustment</h2><span id='topic+lm_lin'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code><a href="#topic+lm_robust">lm_robust</a></code> that
is useful for estimating treatment effects with pre-treatment covariate
data. This implements the method described by Lin (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_lin(
  formula,
  covariates,
  data,
  weights,
  subset,
  clusters,
  se_type = NULL,
  ci = TRUE,
  alpha = 0.05,
  return_vcov = TRUE,
  try_cholesky = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_lin_+3A_formula">formula</code></td>
<td>
<p>an object of class formula, as in <code><a href="stats.html#topic+lm">lm</a></code>, such as
<code>Y ~ Z</code> with only one variable on the right-hand side, the treatment</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_covariates">covariates</code></td>
<td>
<p>a right-sided formula with pre-treatment covariates on
the right hand side, such as <code> ~ x1 + x2 + x3</code>.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="lm_lin_+3A_weights">weights</code></td>
<td>
<p>the bare (unquoted) names of the weights variable in the
supplied data.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_subset">subset</code></td>
<td>
<p>An optional bare (unquoted) expression specifying a subset
of observations to be used.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_clusters">clusters</code></td>
<td>
<p>An optional bare (unquoted) name of the variable that
corresponds to the clusters in the data.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_se_type">se_type</code></td>
<td>
<p>The sort of standard error sought. If <code>clusters</code> is
not specified the options are &quot;HC0&quot;, &quot;HC1&quot; (or &quot;stata&quot;, the equivalent),
&quot;HC2&quot; (default), &quot;HC3&quot;, or  &quot;classical&quot;. If <code>clusters</code> is specified the
options are &quot;CR0&quot;, &quot;CR2&quot; (default), or &quot;stata&quot; are
permissible.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_ci">ci</code></td>
<td>
<p>logical. Whether to compute and return p-values and confidence
intervals, TRUE by default.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, 0.05 by default.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_return_vcov">return_vcov</code></td>
<td>
<p>logical. Whether to return the variance-covariance
matrix for later usage, TRUE by default.</p>
</td></tr>
<tr><td><code id="lm_lin_+3A_try_cholesky">try_cholesky</code></td>
<td>
<p>logical. Whether to try using a Cholesky
decomposition to solve least squares instead of a QR decomposition,
FALSE by default. Using a Cholesky decomposition may result in speed gains, but should only
be used if users are sure their model is full-rank (i.e., there is no
perfect multi-collinearity)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is simply a wrapper for <code><a href="#topic+lm_robust">lm_robust</a></code> and implements
the Lin estimator (see the reference below). This method
pre-processes the data by taking the covariates specified in the
<code>`covariates`</code> argument, centering them by subtracting from each covariate
its mean, and interacting them with the treatment. If the treatment has
multiple values, a series of dummies for each value is created and each of
those is interacted with the demeaned covariates. More details can be found
in the
<a href="https://declaredesign.org/r/estimatr/articles/getting-started.html">Getting Started vignette</a>
and the
<a href="https://declaredesign.org/r/estimatr/articles/mathematical-notes.html">mathematical notes</a>.
</p>


<h3>Value</h3>

<p>An object of class <code>"lm_robust"</code>.
</p>
<p>The post-estimation commands functions <code>summary</code> and <code><a href="#topic+tidy">tidy</a></code>
return results in a <code>data.frame</code>. To get useful data out of the return,
you can use these data frames, you can use the resulting list directly, or
you can use the generic accessor functions <code>coef</code>, <code>vcov</code>,
<code>confint</code>, and <code>predict</code>. Marginal effects and uncertainty about
them can be gotten by passing this object to
<code><a href="margins.html#topic+margins">margins</a></code> from the <span class="pkg">margins</span>.
</p>
<p>Users who want to print the results in TeX of HTML can use the
<code><a href="texreg.html#topic+extract">extract</a></code> function and the <span class="pkg">texreg</span> package.
</p>
<p>An object of class <code>"lm_robust"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated coefficients</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>the estimated standard errors</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the t-statistic</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the estimated degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-values from a two-sided t-test using <code>coefficients</code>, <code>std.error</code>, and <code>df</code></p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>the lower bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>the upper bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a character vector of coefficient names</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the significance level specified by the user</p>
</td></tr>
<tr><td><code>se_type</code></td>
<td>
<p>the standard error type specified by the user</p>
</td></tr>
<tr><td><code>res_var</code></td>
<td>
<p>the residual variance</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of columns in the design matrix (includes linearly dependent columns!)</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the fitted model</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the fitted variance covariance matrix</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>The <code class="reqn">R^2</code>,
</p>
<p style="text-align: center;"><code class="reqn">R^2 = 1 - Sum(e[i]^2) / Sum((y[i] - y^*)^2),</code>
</p>
<p> where <code class="reqn">y^*</code>
is the mean of <code class="reqn">y[i]</code> if there is an intercept and zero otherwise,
and <code class="reqn">e[i]</code> is the ith residual.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>The <code class="reqn">R^2</code> but penalized for having more parameters, <code>rank</code></p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>whether or not weights were applied</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the matrix of predicted means</p>
</td></tr>
</table>
<p>We also return <code>terms</code> and <code>contrasts</code>, used by <code>predict</code>,
and <code>scaled_center</code> (the means of each of the covariates used for centering them).
</p>


<h3>References</h3>

<p>Freedman, David A. 2008. &quot;On Regression Adjustments in Experiments with Several Treatments.&quot; The Annals of Applied Statistics. JSTOR, 176-96. <a href="https://doi.org/10.1214/07-AOAS143">doi:10.1214/07-AOAS143</a>.
</p>
<p>Lin, Winston. 2013. &quot;Agnostic Notes on Regression Adjustments to Experimental Data: Reexamining Freedman's Critique.&quot; The Annals of Applied Statistics 7 (1). Institute of Mathematical Statistics: 295-318. <a href="https://doi.org/10.1214/12-AOAS583">doi:10.1214/12-AOAS583</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm_robust">lm_robust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fabricatr)
library(randomizr)
dat &lt;- fabricate(
  N = 40,
  x = rnorm(N, mean = 2.3),
  x2 = rpois(N, lambda = 2),
  x3 = runif(N),
  y0 = rnorm(N) + x,
  y1 = rnorm(N) + x + 0.35
)

dat$z &lt;- complete_ra(N = nrow(dat))
dat$y &lt;- ifelse(dat$z == 1, dat$y1, dat$y0)

# Same specification as lm_robust() with one additional argument
lmlin_out &lt;- lm_lin(y ~ z, covariates = ~ x, data = dat)
tidy(lmlin_out)

# Works with multiple pre-treatment covariates
lm_lin(y ~ z, covariates = ~ x + x2, data = dat)

# Also centers data AFTER evaluating any functions in formula
lmlin_out2 &lt;- lm_lin(y ~ z, covariates = ~ x + log(x3), data = dat)
lmlin_out2$scaled_center["log(x3)"]
mean(log(dat$x3))

# Works easily with clusters
dat$clusterID &lt;- rep(1:20, each = 2)
dat$z_clust &lt;- cluster_ra(clusters = dat$clusterID)

lm_lin(y ~ z_clust, covariates = ~ x, data = dat, clusters = clusterID)

# Works with multi-valued treatments
dat$z_multi &lt;- sample(1:3, size = nrow(dat), replace = TRUE)
lm_lin(y ~ z_multi, covariates = ~ x, data = dat)

# Stratified estimator with blocks
dat$blockID &lt;- rep(1:5, each = 8)
dat$z_block &lt;- block_ra(blocks = dat$blockID)

lm_lin(y ~ z_block, ~ factor(blockID), data = dat)

## Not run: 
  # Can also use 'margins' package if you have it installed to get
  # marginal effects
  library(margins)
  lmlout &lt;- lm_lin(y ~ z_block, ~ x, data = dat)
  summary(margins(lmlout))

  # Can output results using 'texreg'
  library(texreg)
  texregobj &lt;- extract(lmlout)

## End(Not run)

</code></pre>

<hr>
<h2 id='lm_robust'>Ordinary Least Squares with Robust Standard Errors</h2><span id='topic+lm_robust'></span>

<h3>Description</h3>

<p>This formula fits a linear model, provides a variety of
options for robust standard errors, and conducts coefficient tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_robust(
  formula,
  data,
  weights,
  subset,
  clusters,
  fixed_effects,
  se_type = NULL,
  ci = TRUE,
  alpha = 0.05,
  return_vcov = TRUE,
  try_cholesky = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_robust_+3A_formula">formula</code></td>
<td>
<p>an object of class formula, as in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm_robust_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="lm_robust_+3A_weights">weights</code></td>
<td>
<p>the bare (unquoted) names of the weights variable in the
supplied data.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_subset">subset</code></td>
<td>
<p>An optional bare (unquoted) expression specifying a subset
of observations to be used.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_clusters">clusters</code></td>
<td>
<p>An optional bare (unquoted) name of the variable that
corresponds to the clusters in the data.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>An optional right-sided formula containing the fixed
effects that will be projected out of the data, such as <code>~ blockID</code>. Do not
pass multiple-fixed effects with intersecting groups. Speed gains are greatest for
variables with large numbers of groups and when using &quot;HC1&quot; or &quot;stata&quot; standard errors.
See 'Details'.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_se_type">se_type</code></td>
<td>
<p>The sort of standard error sought. If <code>clusters</code> is
not specified the options are &quot;HC0&quot;, &quot;HC1&quot; (or &quot;stata&quot;, the equivalent),
&quot;HC2&quot; (default), &quot;HC3&quot;, or
&quot;classical&quot;. If <code>clusters</code> is specified the options are &quot;CR0&quot;, &quot;CR2&quot; (default), or &quot;stata&quot;. Can also specify &quot;none&quot;, which may speed up estimation of the coefficients.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_ci">ci</code></td>
<td>
<p>logical. Whether to compute and return p-values and confidence
intervals, TRUE by default.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, 0.05 by default.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_return_vcov">return_vcov</code></td>
<td>
<p>logical. Whether to return the variance-covariance
matrix for later usage, TRUE by default.</p>
</td></tr>
<tr><td><code id="lm_robust_+3A_try_cholesky">try_cholesky</code></td>
<td>
<p>logical. Whether to try using a Cholesky
decomposition to solve least squares instead of a QR decomposition,
FALSE by default. Using a Cholesky decomposition may result in speed gains, but should only
be used if users are sure their model is full-rank (i.e., there is no
perfect multi-collinearity)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs linear regression and provides a variety of standard
errors. It takes a formula and data much in the same was as <code><a href="stats.html#topic+lm">lm</a></code>
does, and all auxiliary variables, such as clusters and weights, can be
passed either as quoted names of columns, as bare column names, or
as a self-contained vector. Examples of usage can be seen below and in the
<a href="https://declaredesign.org/r/estimatr/articles/getting-started.html">Getting Started vignette</a>.
</p>
<p>The mathematical notes in
<a href="https://declaredesign.org/r/estimatr/articles/mathematical-notes.html">this vignette</a>
specify the exact estimators used by this function.
The default variance estimators have been chosen largely in accordance with the
procedures in
<a href="https://github.com/acoppock/Green-Lab-SOP/blob/master/Green_Lab_SOP.pdf">this manual</a>.
The default for the case
without clusters is the HC2 estimator and the default with clusters is the
analogous CR2 estimator. Users can easily replicate Stata standard errors in
the clustered or non-clustered case by setting <code>`se_type` = "stata"</code>.
</p>
<p>The function estimates the coefficients and standard errors in C++, using
the <code>RcppEigen</code> package. By default, we estimate the coefficients
using Column-Pivoting QR decomposition from the Eigen C++ library, although
users could get faster solutions by setting <code>`try_cholesky` = TRUE</code> to
use a Cholesky decomposition instead. This will likely result in quicker
solutions, but the algorithm does not reliably detect when there are linear
dependencies in the model and may fail silently if they exist.
</p>
<p>If <code>`fixed_effects`</code> are specified, both the outcome and design matrix
are centered using the method of alternating projections (Halperin 1962; Gaure 2013). Specifying
fixed effects in this way will result in large speed gains with standard error
estimators that do not need to invert the matrix of fixed effects. This means using
&quot;classical&quot;, &quot;HC0&quot;, &quot;HC1&quot;, &quot;CR0&quot;, or &quot;stata&quot; standard errors will be faster than other
standard error estimators. Be wary when specifying fixed effects that may result
in perfect fits for some observations or if there are intersecting groups across
multiple fixed effect variables (e.g. if you specify both &quot;year&quot; and &quot;country&quot; fixed effects
with an unbalanced panel where one year you only have data for one country).
</p>
<p>As with <code>`lm()`</code>, multivariate regression (multiple outcomes) will only admit
observations into the estimation that have no missingness on any outcome.
</p>


<h3>Value</h3>

<p>An object of class <code>"lm_robust"</code>.
</p>
<p>The post-estimation commands functions <code>summary</code> and <code><a href="#topic+tidy">tidy</a></code>
return results in a <code>data.frame</code>. To get useful data out of the return,
you can use these data frames, you can use the resulting list directly, or
you can use the generic accessor functions <code>coef</code>, <code>vcov</code>,
<code>confint</code>, and <code>predict</code>. Marginal effects and uncertainty about
them can be gotten by passing this object to
<code><a href="margins.html#topic+margins">margins</a></code> from the <span class="pkg">margins</span>,
or to <code>emmeans</code> in the <span class="pkg">emmeans</span> package.
</p>
<p>Users who want to print the results in TeX of HTML can use the
<code><a href="texreg.html#topic+extract">extract</a></code> function and the <span class="pkg">texreg</span> package.
</p>
<p>If users specify a multivariate linear regression model (multiple outcomes),
then some of the below components will be of higher dimension to accommodate
the additional models.
</p>
<p>An object of class <code>"lm_robust"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated coefficients</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>the estimated standard errors</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the t-statistic</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the estimated degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-values from a two-sided t-test using <code>coefficients</code>, <code>std.error</code>, and <code>df</code></p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>the lower bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>the upper bound of the <code>1 - alpha</code> percent confidence interval</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a character vector of coefficient names</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the significance level specified by the user</p>
</td></tr>
<tr><td><code>se_type</code></td>
<td>
<p>the standard error type specified by the user</p>
</td></tr>
<tr><td><code>res_var</code></td>
<td>
<p>the residual variance</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the number of observations used</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of columns in the design matrix (includes linearly dependent columns!)</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the fitted model</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the fitted variance covariance matrix</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>The <code class="reqn">R^2</code>,
</p>
<p style="text-align: center;"><code class="reqn">R^2 = 1 - Sum(e[i]^2) / Sum((y[i] - y^*)^2),</code>
</p>
<p> where <code class="reqn">y^*</code>
is the mean of <code class="reqn">y[i]</code> if there is an intercept and zero otherwise,
and <code class="reqn">e[i]</code> is the ith residual.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>The <code class="reqn">R^2</code> but penalized for having more parameters, <code>rank</code></p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a vector with the value of the F-statistic with the numerator and denominator degrees of freedom</p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>whether or not weights were applied</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the matrix of predicted means</p>
</td></tr>
</table>
<p>We also return <code>terms</code> and <code>contrasts</code>, used by <code>predict</code>. If <code>fixed_effects</code> are specified, then we return <code>proj_fstatistic</code>, <code>proj_r.squared</code>, and <code>proj_adj.r.squared</code>, which are model fit statistics that are computed on the projected model (after demeaning the fixed effects).
</p>


<h3>References</h3>

<p>Abadie, Alberto, Susan Athey, Guido W Imbens, and Jeffrey Wooldridge. 2017. &quot;A Class of Unbiased Estimators of the Average Treatment Effect in Randomized Experiments.&quot; arXiv Pre-Print. <a href="https://arxiv.org/abs/1710.02926v2">https://arxiv.org/abs/1710.02926v2</a>.
</p>
<p>Bell, Robert M, and Daniel F McCaffrey. 2002. &quot;Bias Reduction in Standard Errors for Linear Regression with Multi-Stage Samples.&quot; Survey Methodology 28 (2): 169-82.
</p>
<p>Gaure, Simon. 2013. &quot;OLS with multiple high dimensional category variables.&quot; Computational Statistics &amp; Data Analysis 66: 8-1. <a href="https://doi.org/10.1016/j.csda.2013.03.024">doi:10.1016/j.csda.2013.03.024</a>
</p>
<p>Halperin, I. 1962. &quot;The product of projection operators.&quot; Acta Scientiarum Mathematicarum (Szeged) 23(1-2): 96-99.
</p>
<p>MacKinnon, James, and Halbert White. 1985. &quot;Some Heteroskedasticity-Consistent Covariance Matrix Estimators with Improved Finite Sample Properties.&quot; Journal of Econometrics 29 (3): 305-25. <a href="https://doi.org/10.1016/0304-4076%2885%2990158-7">doi:10.1016/0304-4076(85)90158-7</a>.
</p>
<p>Pustejovsky, James E, and Elizabeth Tipton. 2016. &quot;Small Sample Methods for Cluster-Robust Variance Estimation and Hypothesis Testing in Fixed Effects Models.&quot; Journal of Business &amp; Economic Statistics. Taylor &amp; Francis. <a href="https://doi.org/10.1080/07350015.2016.1247004">doi:10.1080/07350015.2016.1247004</a>.
</p>
<p>Samii, Cyrus, and Peter M Aronow. 2012. &quot;On Equivalencies Between Design-Based and Regression-Based Variance Estimators for Randomized Experiments.&quot; Statistics and Probability Letters 82 (2). <a href="https://doi.org/10.1016/j.spl.2011.10.024">doi:10.1016/j.spl.2011.10.024</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(15)
library(fabricatr)
dat &lt;- fabricate(
  N = 40,
  y = rpois(N, lambda = 4),
  x = rnorm(N),
  z = rbinom(N, 1, prob = 0.4)
)

# Default variance estimator is HC2 robust standard errors
lmro &lt;- lm_robust(y ~ x + z, data = dat)

# Can tidy() the data in to a data.frame
tidy(lmro)
# Can use summary() to get more statistics
summary(lmro)
# Can also get coefficients three ways
lmro$coefficients
coef(lmro)
tidy(lmro)$estimate
# Can also get confidence intervals from object or with new 1 - `alpha`
lmro$conf.low
confint(lmro, level = 0.8)

# Can recover classical standard errors
lmclassic &lt;- lm_robust(y ~ x + z, data = dat, se_type = "classical")
tidy(lmclassic)

# Can easily match Stata's robust standard errors
lmstata &lt;- lm_robust(y ~ x + z, data = dat, se_type = "stata")
tidy(lmstata)

# Easy to specify clusters for cluster-robust inference
dat$clusterID &lt;- sample(1:10, size = 40, replace = TRUE)

lmclust &lt;- lm_robust(y ~ x + z, data = dat, clusters = clusterID)
tidy(lmclust)

# Can also match Stata's clustered standard errors
lm_robust(
  y ~ x + z,
  data = dat,
  clusters = clusterID,
  se_type = "stata"
)

# Works just as LM does with functions in the formula
dat$blockID &lt;- rep(c("A", "B", "C", "D"), each = 10)

lm_robust(y ~ x + z + factor(blockID), data = dat)

# Weights are also easily specified
dat$w &lt;- runif(40)

lm_robust(
  y ~ x + z,
  data = dat,
  weights = w,
  clusters = clusterID
)

# Subsetting works just as in `lm()`
lm_robust(y ~ x, data = dat, subset = z == 1)

# One can also choose to set the significance level for different CIs
lm_robust(y ~ x + z, data = dat, alpha = 0.1)

# We can also specify fixed effects
# Speed gains with fixed effects are greatest with "stata" or "HC1" std.errors
tidy(lm_robust(y ~ z, data = dat, fixed_effects = ~ blockID, se_type = "HC1"))

## Not run: 
  # Can also use 'margins' or 'emmeans' package if you have them installed
  # to get marginal effects
  library(margins)
  lmrout &lt;- lm_robust(y ~ x + z, data = dat)
  summary(margins(lmrout))

  # Can output results using 'texreg'
  library(texreg)
  texreg(lmrout)

  # Using emmeans to obtain covariate-adjusted means
  library(emmeans)
  fiber.rlm &lt;- lm_robust(strength ~ diameter + machine, data = fiber)
  emmeans(fiber.rlm, "machine")

## End(Not run)

</code></pre>

<hr>
<h2 id='lm_robust_fit'>Internal method that creates linear fits</h2><span id='topic+lm_robust_fit'></span>

<h3>Description</h3>

<p>Internal method that creates linear fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_robust_fit(
  y,
  X,
  yoriginal = NULL,
  Xoriginal = NULL,
  weights,
  cluster,
  fixed_effects = NULL,
  ci = TRUE,
  se_type,
  has_int,
  alpha = 0.05,
  return_vcov = TRUE,
  return_fit = TRUE,
  try_cholesky = FALSE,
  iv_stage = list(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_robust_fit_+3A_y">y</code></td>
<td>
<p>numeric outcome vector</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_x">X</code></td>
<td>
<p>numeric design matrix</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_yoriginal">yoriginal</code></td>
<td>
<p>numeric outcome vector, unprojected if there are fixed effects</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_xoriginal">Xoriginal</code></td>
<td>
<p>numeric design matrix, unprojected if there are fixed effects. Any column named <code>"(Intercept)" will be dropped</code></p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_weights">weights</code></td>
<td>
<p>numeric weights vector</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_cluster">cluster</code></td>
<td>
<p>numeric cluster vector</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>character matrix of fixed effect groups</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_ci">ci</code></td>
<td>
<p>boolean that when T returns confidence intervals and p-values</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_se_type">se_type</code></td>
<td>
<p>character denoting which kind of SEs to return</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_has_int">has_int</code></td>
<td>
<p>logical, whether the model has an intercept, used for <code class="reqn">R^2</code></p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_alpha">alpha</code></td>
<td>
<p>numeric denoting the test size for confidence intervals</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_return_vcov">return_vcov</code></td>
<td>
<p>logical, whether to return the vcov matrix for later usage</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_return_fit">return_fit</code></td>
<td>
<p>logical, whether to return fitted values</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_try_cholesky">try_cholesky</code></td>
<td>
<p>logical, whether to try using a cholesky decomposition to solve LS instead of a QR decomposition</p>
</td></tr>
<tr><td><code id="lm_robust_fit_+3A_iv_stage">iv_stage</code></td>
<td>
<p>list of length two, the first element denotes the stage of 2SLS IV estimation, where 0 is used for OLS. The second element is only used for the second stage of 2SLS and has the first stage design matrix. For OLS, the default, <code>list(0)</code>, for the first stage of 2SLS <code>list(1)</code>, for second stage of 2SLS <code>list(2, first_stage_design_mat)</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='na.omit_detailed.data.frame'>Extra logging on na.omit handler</h2><span id='topic+na.omit_detailed.data.frame'></span>

<h3>Description</h3>

<p>Extra logging on na.omit handler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.omit_detailed.data.frame(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.omit_detailed.data.frame_+3A_object">object</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a normal <code>omit</code> object, with the extra attribute <code>why_omit</code>,
which contains the leftmost column containing an NA for each row that was dropped, by
column name, if any were dropped.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.omit">na.omit</a></code>
</p>

<hr>
<h2 id='permutations_to_condition_pr_mat'>Builds condition probability matrices for Horvitz-Thompson estimation from
permutation matrix</h2><span id='topic+permutations_to_condition_pr_mat'></span>

<h3>Description</h3>

<p>Builds condition probability matrices for Horvitz-Thompson estimation from
permutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations_to_condition_pr_mat(permutations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutations_to_condition_pr_mat_+3A_permutations">permutations</code></td>
<td>
<p>A matrix where the rows are units and the columns are
different treatment permutations; treated units must be represented with a
1 and control units with a 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a matrix of permutations, for example from
the <code><a href="randomizr.html#topic+obtain_permutation_matrix">obtain_permutation_matrix</a></code> function in
<span class="pkg">randomizr</span> or through simulation and returns a 2n*2n matrix that can
be used to fully specify the design for <code><a href="#topic+horvitz_thompson">horvitz_thompson</a></code>
estimation. You can read more about these matrices in the documentation for
the <code><a href="#topic+declaration_to_condition_pr_mat">declaration_to_condition_pr_mat</a></code> function.
</p>
<p>This is done by passing this matrix to the <code>condition_pr_mat</code> argument
of
</p>


<h3>Value</h3>

<p>a numeric 2n*2n matrix of marginal and joint condition treatment
probabilities to be passed to the <code>condition_pr_mat</code> argument of
<code><a href="#topic+horvitz_thompson">horvitz_thompson</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="randomizr.html#topic+declare_ra">declare_ra</a></code>,
<code><a href="#topic+declaration_to_condition_pr_mat">declaration_to_condition_pr_mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Complete randomization
perms &lt;- replicate(1000, sample(rep(0:1, each = 50)))
comp_pr_mat &lt;- permutations_to_condition_pr_mat(perms)

# Arbitrary randomization
possible_treats &lt;- cbind(
  c(1, 1, 0, 1, 0, 0, 0, 1, 1, 0),
  c(0, 1, 1, 0, 1, 1, 0, 1, 0, 1),
  c(1, 0, 1, 1, 1, 1, 1, 0, 0, 0)
)
arb_pr_mat &lt;- permutations_to_condition_pr_mat(possible_treats)
# Simulating a column to be realized treatment
z &lt;- possible_treats[, sample(ncol(possible_treats), size = 1)]
y &lt;- rnorm(nrow(possible_treats))
horvitz_thompson(y ~ z, condition_pr_mat = arb_pr_mat)

</code></pre>

<hr>
<h2 id='predict.lm_robust'>Predict method for <code>lm_robust</code> object</h2><span id='topic+predict.lm_robust'></span>

<h3>Description</h3>

<p>Predict method for <code>lm_robust</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_robust'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  alpha = 0.05,
  na.action = na.pass,
  pred.var = NULL,
  weights,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lm_robust_+3A_object">object</code></td>
<td>
<p>an object of class 'lm_robust'</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_newdata">newdata</code></td>
<td>
<p>a data frame in which to look for variables with which to predict</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_se.fit">se.fit</code></td>
<td>
<p>logical. Whether standard errors are required, default = FALSE</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation. Can be abbreviated, default = none</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_alpha">alpha</code></td>
<td>
<p>numeric denoting the test size for confidence intervals</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing
values in newdata. The default is to predict NA.</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_pred.var">pred.var</code></td>
<td>
<p>the variance(s) for future observations to be assumed for
prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_weights">weights</code></td>
<td>
<p>variance weights for prediction. This can be a numeric
vector or a bare (unquoted) name of the weights variable in the supplied
newdata.</p>
</td></tr>
<tr><td><code id="predict.lm_robust_+3A_...">...</code></td>
<td>
<p>other arguments, unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces predicted values, obtained by evaluating the regression
function in the frame <code>newdata</code> for fits from <code>lm_robust</code> and
<code>lm_lin</code>. If the logical se.fit is TRUE, standard errors of the
predictions are calculated. Setting intervals specifies computation of
confidence or prediction (tolerance) intervals at the specified level,
sometimes referred to as narrow vs. wide intervals.
</p>
<p>The equation used for the standard error of a prediction given a row of
data <code class="reqn">x</code> is:
</p>
<p><code class="reqn">\sqrt(x \Sigma x')</code>,
</p>
<p>where <code class="reqn">\Sigma</code> is the estimated variance-covariance matrix from
<code>lm_robust</code>.
</p>
<p>The prediction intervals are for a single observation at each case in
<code>newdata</code> with error variance(s) <code>pred.var</code>. The the default is to assume
that future observations have the same error variance as those used for
fitting, which is gotten from the fit <code><a href="#topic+lm_robust">lm_robust</a></code> object. If
weights is supplied, the inverse of this is used as a scale factor. If the
fit was weighted, the default is to assume constant prediction variance,
with a warning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set seed
set.seed(42)

# Simulate data
n &lt;- 10
dat &lt;- data.frame(y = rnorm(n), x = rnorm(n))

# Fit lm
lm_out &lt;- lm_robust(y ~ x, data = dat)
# Get predicted fits
fits &lt;- predict(lm_out, newdata = dat)
# With standard errors and confidence intervals
fits &lt;- predict(lm_out, newdata = dat, se.fit = TRUE, interval = "confidence")

# Use new data as well
new_dat &lt;- data.frame(x = runif(n, 5, 8))
predict(lm_out, newdata = new_dat)

# You can also supply custom variance weights for prediction intervals
new_dat$w &lt;- runif(n)
predict(lm_out, newdata = new_dat, weights = w, interval = "prediction")

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+glance'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='starprep'>Prepare model fits for stargazer</h2><span id='topic+starprep'></span>

<h3>Description</h3>

<p>Prepare model fits for stargazer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starprep(
  ...,
  stat = c("std.error", "statistic", "p.value", "ci", "df"),
  se_type = NULL,
  clusters = NULL,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="starprep_+3A_...">...</code></td>
<td>
<p>a list of lm_robust or lm objects</p>
</td></tr>
<tr><td><code id="starprep_+3A_stat">stat</code></td>
<td>
<p>either &quot;std.error&quot; (the default), &quot;statistic&quot; (the t-statistic), &quot;p.value&quot;, &quot;ci&quot;, or &quot;df&quot;</p>
</td></tr>
<tr><td><code id="starprep_+3A_se_type">se_type</code></td>
<td>
<p>(optional) if any of the objects are lm objects, what standard
errors should be used. Must only be one type and will be used for all lm
objects passed to starprep. See <code>commarobust</code> for more.</p>
</td></tr>
<tr><td><code id="starprep_+3A_clusters">clusters</code></td>
<td>
<p>(optional) if any of the objects are lm objects, what clusters
should be used, if clusters should be used. Must only be one vector and will
be used for all lm objects passed to starprep. See <code>commarobust</code> for more.</p>
</td></tr>
<tr><td><code id="starprep_+3A_alpha">alpha</code></td>
<td>
<p>(optional) if any of the objects are lm objects, what significance level
should be used for the p-values or confidence intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to help extract statistics from lists of model fits for stargazer.
Prefers lm_robust objects, but because <code>stargazer</code> does not work with <code>lm_robust</code>
objects, <code>starprep</code> can also take <code>lm</code> objects and calls <code>commarobust</code> to get
the preferred, robust statistics.
</p>


<h3>Value</h3>

<p>a list of vectors of extracted statistics for stargazers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(stargazer)

lm1 &lt;- lm(mpg ~ hp, data = mtcars)
lm2 &lt;- lm(mpg ~ hp + wt, data = mtcars)

# Use default "HC2" standard errors
stargazer(lm1, lm2,
          se = starprep(lm1, lm2),
          p = starprep(lm1, lm2, stat = "p.value"),
          omit.stat = "f")
# NB: We remove the F-stat because stargazer only can use original F-stat
# which uses classical SEs

# Use default "CR2" standard errors with clusters
stargazer(lm1, lm2,
          se = starprep(lm1, lm2, clusters = mtcars$carb),
          p = starprep(lm1, lm2, clusters = mtcars$carb, stat = "p.value"),
          omit.stat = "f")

# Can also specify significance levels and different standard errors
stargazer(lm1, lm2,
          ci.custom = starprep(lm1, lm2, se_type = "HC3", alpha = 0.1, stat = "ci"),
          omit.stat = "f")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
