<!DOCTYPE html><html lang="en"><head><title>Help for package tgstat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tgstat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tgstat-package'><p>tgstat: Amos Tanay's Group High Performance Statistical Utilities</p></a></li>
<li><a href='#tgs_cor'><p>Calculates correlation or auto-correlation</p></a></li>
<li><a href='#tgs_dist'><p>Calculates distances between the matrix rows</p></a></li>
<li><a href='#tgs_finite'><p>Checks whether all the elements of the vector are finite</p></a></li>
<li><a href='#tgs_graph'><p>Builds directed graph of correlations</p></a></li>
<li><a href='#tgs_graph_cover'><p>Clusters directed graph</p></a></li>
<li><a href='#tgs_graph_cover_resample'><p>Clusters directed graph multiple times with randomized sample subset</p></a></li>
<li><a href='#tgs_knn'><p>Returns k highest values of each column</p></a></li>
<li><a href='#tgs_matrix_tapply'><p>For each matrix row apply a function over a ragged array</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Amos Tanay's Group High Performance Statistical Utilities</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.28</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hoichman [aut],
  Aviezer Lifshitz [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aviezer Lifshitz &lt;aviezer.lifshitz@weizmann.ac.il&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of high performance utilities to compute
    distance, correlation, auto correlation, clustering and other tasks.
    Contains graph clustering algorithm described in "MetaCell: analysis
    of single-cell RNA-seq data using K-nn graph partitions" (Yael Baran,
    Akhiad Bercovich, Arnau Sebe-Pedros, Yaniv Lubling, Amir Giladi, Elad
    Chomsky, Zohar Meir, Michael Hoichman, Aviezer Lifshitz &amp; Amos Tanay,
    2019 &lt;<a href="https://doi.org/10.1186%2Fs13059-019-1812-2">doi:10.1186/s13059-019-1812-2</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tanaylab/tgstat/issues">https://github.com/tanaylab/tgstat/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tanaylab.github.io/tgstat/">https://tanaylab.github.io/tgstat/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>OS_type:</td>
<td>unix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-23 19:46:25 UTC; aviezerl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tgstat-package'>tgstat: Amos Tanay's Group High Performance Statistical Utilities</h2><span id='topic+tgstat-package'></span><span id='topic+tgstat'></span>

<h3>Description</h3>

<p>A collection of high performance utilities to compute distance, correlation, auto correlation, clustering and other tasks. Contains graph clustering algorithm described in &quot;MetaCell: analysis of single-cell RNA-seq data using K-nn graph partitions&quot; (Yael Baran, Akhiad Bercovich, Arnau Sebe-Pedros, Yaniv Lubling, Amir Giladi, Elad Chomsky, Zohar Meir, Michael Hoichman, Aviezer Lifshitz &amp; Amos Tanay, 2019 <a href="https://doi.org/10.1186/s13059-019-1812-2">doi:10.1186/s13059-019-1812-2</a>).
</p>
<p>'tgstat' package is intended to help users to efficiently analyze data in
time-patient space.
</p>


<h3>Details</h3>

<p>For a complete list of help resources, use <code>library(help = "tgstat")</code>.
</p>
<p>More information about the options can be found in 'User manual' of the
package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aviezer Lifshitz <a href="mailto:aviezer.lifshitz@weizmann.ac.il">aviezer.lifshitz@weizmann.ac.il</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Michael Hoichman <a href="mailto:misha@hoichman.com">misha@hoichman.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tanaylab.github.io/tgstat/">https://tanaylab.github.io/tgstat/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tanaylab/tgstat/issues">https://github.com/tanaylab/tgstat/issues</a>
</p>
</li></ul>


<hr>
<h2 id='tgs_cor'>Calculates correlation or auto-correlation</h2><span id='topic+tgs_cor'></span><span id='topic+tgs_cor_knn'></span>

<h3>Description</h3>

<p>Calculates correlation between two matrices columns or auto-correlation
between a matrix columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_cor(
  x,
  y = NULL,
  pairwise.complete.obs = FALSE,
  spearman = FALSE,
  tidy = FALSE,
  threshold = 0
)

tgs_cor_knn(
  x,
  y,
  knn,
  pairwise.complete.obs = FALSE,
  spearman = FALSE,
  threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_cor_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="tgs_cor_+3A_y">y</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="tgs_cor_+3A_pairwise.complete.obs">pairwise.complete.obs</code></td>
<td>
<p>see below</p>
</td></tr>
<tr><td><code id="tgs_cor_+3A_spearman">spearman</code></td>
<td>
<p>if 'TRUE' Spearman correlation is computed, otherwise
Pearson</p>
</td></tr>
<tr><td><code id="tgs_cor_+3A_tidy">tidy</code></td>
<td>
<p>if 'TRUE' data is outputed in tidy format</p>
</td></tr>
<tr><td><code id="tgs_cor_+3A_threshold">threshold</code></td>
<td>
<p>absolute threshold above which values are outputed in tidy
format</p>
</td></tr>
<tr><td><code id="tgs_cor_+3A_knn">knn</code></td>
<td>
<p>the number of highest correlations returned per column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'tgs_cor' is very similar to 'stats::cor'. Unlike the latter it uses
all available CPU cores to compute the correlation in a much faster way. The
basic implementation of 'pairwise.complete.obs' is also more efficient
giving overall great run-time advantage.
</p>
<p>Unlike 'stats::cor' 'tgs_cor' implements only two modes of treating
data containing NA, which are equivalent to 'use=&quot;everything&quot;' and
'use=&quot;pairwise.complete.obs&quot;. Please refer the documentation of this
function for more details.
</p>
<p>'tgs_cor(x, y, spearman = FALSE)' is equivalent to 'cor(x, y, method =
&quot;pearson&quot;)' 'tgs_cor(x, y, spearman = TRUE)' is equivalent to 'cor(x, y, method
= &quot;spearman&quot;)' 'tgs_cor(x, y, pairwise.complete.obs = TRUE, spearman = TRUE)' is
equivalent to 'cor(x, y, use = &quot;pairwise.complete.obs&quot;, method =
&quot;spearman&quot;)' 'tgs_cor(x, y, pairwise.complete.obs = TRUE, spearman = FALSE)' is
equivalent to 'cor(x, y, use = &quot;pairwise.complete.obs&quot;, method = &quot;pearson&quot;)'
</p>
<p>'tgs_cor' can output its result in &quot;tidy&quot; format: a data frame with three
columns named 'col1', 'col2' and 'cor'. Only the correlation values which
abs are equal or above the 'threshold' are reported. For auto-correlation
(i.e. when 'y=NULL') a pair of columns numbered X and Y is reported only if
X &lt; Y.
</p>
<p>'tgs_cor_knn' works similarly to 'tgs_cor'. Unlike the latter it returns
only the highest 'knn' correlations for each column in 'x'. The result of
'tgs_cor_knn' is always outputed in &quot;tidy&quot; format.
</p>
<p>One of the reasons to opt 'tgs_cor_knn' over a pair of calls to 'tgs_cor'
and 'tgs_knn' is the reduced memory consumption of the former. For
auto-correlation case (i.e. 'y=NULL') given that the number of columns NC
exceeds the number of rows NR, then 'tgs_cor' memory consumption becomes a
factor of NCxNC. In contrast 'tgs_cor_knn' would consume in the similar
scenario a factor of max(NCxNR,NCxKNN). Similarly 'tgs_cor(x,y)' would
consume memory as a factor of NCXxNCY, wherever 'tgs_cor_knn(x,y,knn)' would
reduce that to max((NCX+NCY)xNR,NCXxKNN).
</p>


<h3>Value</h3>

<p>'tgs_cor_knn' or 'tgs_cor' with 'tidy=TRUE' return a data frame,
where each row represents correlation between two pairs of columns from 'x'
and 'y' (or two columns of 'x' itself if 'y==NULL'). 'tgs_cor' with the
'tidy=FALSE' returns a matrix of correlation values, where <code>val[X,Y]</code>
represents the correlation between columns X and Y of the input matrices (if
'y' is not 'NULL') or the correlation between columns X and Y of 'x' (if 'y'
is 'NULL').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: all the available CPU cores might be used

set.seed(seed = 0)
rows &lt;- 100
cols &lt;- 1000
vals &lt;- sample(1:(rows * cols / 2), rows * cols, replace = TRUE)
m &lt;- matrix(vals, nrow = rows, ncol = cols)
m[sample(1:(rows * cols), rows * cols / 1000)] &lt;- NA

r1 &lt;- tgs_cor(m, spearman = FALSE)
r2 &lt;- tgs_cor(m, pairwise.complete.obs = TRUE, spearman = TRUE)
r3 &lt;- tgs_cor_knn(m, NULL, 5, spearman = FALSE)




</code></pre>

<hr>
<h2 id='tgs_dist'>Calculates distances between the matrix rows</h2><span id='topic+tgs_dist'></span>

<h3>Description</h3>

<p>Calculates distances between the matrix rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_dist(x, diag = FALSE, upper = FALSE, tidy = FALSE, threshold = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_dist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="tgs_dist_+3A_diag">diag</code></td>
<td>
<p>see 'dist' documentation</p>
</td></tr>
<tr><td><code id="tgs_dist_+3A_upper">upper</code></td>
<td>
<p>see 'dist' documentation</p>
</td></tr>
<tr><td><code id="tgs_dist_+3A_tidy">tidy</code></td>
<td>
<p>if 'TRUE' data is outputed in tidy format</p>
</td></tr>
<tr><td><code id="tgs_dist_+3A_threshold">threshold</code></td>
<td>
<p>threshold below which values are outputed in tidy format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very similar to 'package:stats::dist'. Unlike the latter it
uses all available CPU cores to compute the distances in a much faster way.
</p>
<p>Unlike 'package:stats::dist' 'tgs_dist' uses always &quot;euclidean&quot; metrics (see
'method' parameter of 'dist' function). Thus:
</p>
<p>'tgs_dist(x)' is equivalent to 'dist(x, method = &quot;euclidean&quot;)'
</p>
<p>'tgs_dist' can output its result in &quot;tidy&quot; format: a data frame with three
columns named 'row1', 'row2' and 'dist'. Only the distances that are less or
equal than the 'threshold' are reported. Distance between row number X and Y
is reported only if X &lt; Y. 'diag' and 'upper' parameters are ignored when
the result is returned in &quot;tidy&quot; format.
</p>


<h3>Value</h3>

<p>If 'tidy' is 'FALSE' - the output is similar to that of 'dist'
function. If 'tidy' is 'TRUE' - 'tgs_dist' returns a data frame, where each
row represents distances between two pairs of original rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: all the available CPU cores might be used

set.seed(seed = 0)
rows &lt;- 100
cols &lt;- 1000
vals &lt;- sample(1:(rows * cols / 2), rows * cols, replace = TRUE)
m &lt;- matrix(vals, nrow = rows, ncol = cols)
m[sample(1:(rows * cols), rows * cols / 1000)] &lt;- NA
r &lt;- tgs_dist(m)




</code></pre>

<hr>
<h2 id='tgs_finite'>Checks whether all the elements of the vector are finite</h2><span id='topic+tgs_finite'></span>

<h3>Description</h3>

<p>Checks whether all the elements of the vector are finite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_finite(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_finite_+3A_x">x</code></td>
<td>
<p>numeric or integer vector or matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'tgs_finite' returns 'TRUE' if all the elements of 'x' are finite numbers.
(See: 'is.finite'.)
</p>


<h3>Value</h3>

<p>'TRUE' if all the elements of 'x' are finite, otherwise 'FALSE'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tgs_finite(1:10)
tgs_finite(c(1:10, NaN))
tgs_finite(c(1:10, Inf))

</code></pre>

<hr>
<h2 id='tgs_graph'>Builds directed graph of correlations</h2><span id='topic+tgs_graph'></span>

<h3>Description</h3>

<p>Builds directed graph of correlations where the nodes are the matrix
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_graph(x, knn, k_expand, k_beta = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_graph_+3A_x">x</code></td>
<td>
<p>see below</p>
</td></tr>
<tr><td><code id="tgs_graph_+3A_knn">knn</code></td>
<td>
<p>maximal node degree</p>
</td></tr>
<tr><td><code id="tgs_graph_+3A_k_expand">k_expand</code></td>
<td>
<p>see below</p>
</td></tr>
<tr><td><code id="tgs_graph_+3A_k_beta">k_beta</code></td>
<td>
<p>see below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds a directed graph based on the edges in 'x' and their
ranks.
</p>
<p>'x' is a data frame containing 4 columns named: 'col1', 'col2', 'val',
'rank'. The third column ('val' can have a different name). The result in
the compatible format is returned, for example, by 'tgs_knn' function.
</p>
<p>'tgs_graph' prunes some of the edges in 'x' based on the following steps:
</p>

<ol>
<li><p> A pair of columns i, j that appears in 'x' in 'col1', 'col2' implies the
edge in the graph from i to j: edge(i,j). Let the rank of i and j be
rank(i,j).
</p>
</li>
<li><p> Calculate symmetrised rank of i and j: sym_rank(i,j) = rank(i,j) *
rank(j,i). If one of the ranks is missing from the previous result sym_rank
is set to NA.
</p>
</li>
<li><p> Prune the edges: remove edge(i,j) if sym_rank(i,j) == NA OR sym_rank(i,j)
&lt; knn * knn * k_expand
</p>
</li>
<li><p> Prune excessive incoming edges: remove edge(i,j) if more than knn *
k_beta edges of type edge(node,j) exist and sym_rank(i,j) is higher than
sym_rank(node,j) for node != j.
</p>
</li>
<li><p> Prune excessive outgoing edges: remove edge(i,j) if more than knn edges
of type edge(i,node) exist and sym_rank(i,j) is higher than sym_rank(i,node)
for node != i.
</p>
</li></ol>



<h3>Value</h3>

<p>The graph edges are returned in a data frame, with the weight of
each edge. edge(i,j) receives weight 1 if its sym_rank is the lowest among
all edges of type edge(i,node). Formally defined: weight(i,j) = 1 -
(place(i,j) - 1) / knn, where place(i,j) is the location of edge(i,j) within
the sorted set of edges outgoing from i, i.e. edge(i,node). The sort is done
by sym_rank of the edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: all the available CPU cores might be used

set.seed(seed = 1)
rows &lt;- 100
cols &lt;- 1000
vals &lt;- sample(1:(rows * cols / 2), rows * cols, replace = TRUE)
m &lt;- matrix(vals, nrow = rows, ncol = cols)
m[sample(1:(rows * cols), rows * cols / 1000)] &lt;- NA

r1 &lt;- tgs_cor(m, pairwise.complete.obs = FALSE, spearman = TRUE)
r2 &lt;- tgs_knn(r1, knn = 30, diag = FALSE)
r3 &lt;- tgs_graph(r2, knn = 3, k_expand = 10)




</code></pre>

<hr>
<h2 id='tgs_graph_cover'>Clusters directed graph</h2><span id='topic+tgs_graph_cover'></span>

<h3>Description</h3>

<p>Clusters directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_graph_cover(graph, min_cluster_size, cooling = 1.05, burn_in = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_graph_cover_+3A_graph">graph</code></td>
<td>
<p>directed graph in the format returned by tgs_graph</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_+3A_min_cluster_size">min_cluster_size</code></td>
<td>
<p>used to determine the candidates for seeding (= min
weight)</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_+3A_cooling">cooling</code></td>
<td>
<p>factor that is used to gradually increase the chance of a
node to stay in the cluster</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_+3A_burn_in">burn_in</code></td>
<td>
<p>number of node reassignments after which cooling is applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is explained in a &quot;MetaCell: analysis of single-cell RNA-seq
data using K-nn graph partitions&quot; paper, published in &quot;Genome Biology&quot; #20:
https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1812-2
</p>


<h3>Value</h3>

<p>Data frame that maps each node to its cluster.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tgs_graph">tgs_graph()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: all the available CPU cores might be used

set.seed(seed = 0)
rows &lt;- 100
cols &lt;- 1000
vals &lt;- sample(1:(rows * cols / 2), rows * cols, replace = TRUE)
m &lt;- matrix(vals, nrow = rows, ncol = cols)
m[sample(1:(rows * cols), rows * cols / 1000)] &lt;- NA

r1 &lt;- tgs_cor(m, pairwise.complete.obs = FALSE, spearman = TRUE)
r2 &lt;- tgs_knn(r1, knn = 30, diag = FALSE)
r3 &lt;- tgs_graph(r2, knn = 3, k_expand = 10)
r4 &lt;- tgs_graph_cover(r3, 5)




</code></pre>

<hr>
<h2 id='tgs_graph_cover_resample'>Clusters directed graph multiple times with randomized sample subset</h2><span id='topic+tgs_graph_cover_resample'></span>

<h3>Description</h3>

<p>Clusters directed graph multiple times with randomized sample subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_graph_cover_resample(
  graph,
  knn,
  min_cluster_size,
  cooling = 1.05,
  burn_in = 10,
  p_resamp = 0.75,
  n_resamp = 500,
  method = "hash"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_graph_cover_resample_+3A_graph">graph</code></td>
<td>
<p>directed graph in the format returned by tgs_graph</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_resample_+3A_knn">knn</code></td>
<td>
<p>maximal number of edges used per node for each sample subset</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_resample_+3A_min_cluster_size">min_cluster_size</code></td>
<td>
<p>used to determine the candidates for seeding (= min
weight)</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_resample_+3A_cooling">cooling</code></td>
<td>
<p>factor that is used to gradually increase the chance of a
node to stay in the cluster</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_resample_+3A_burn_in">burn_in</code></td>
<td>
<p>number of node reassignments after which cooling is applied</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_resample_+3A_p_resamp">p_resamp</code></td>
<td>
<p>fraction of total number of nodes used in each sample subset</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_resample_+3A_n_resamp">n_resamp</code></td>
<td>
<p>number iterations the clustering is run on different sample
subsets</p>
</td></tr>
<tr><td><code id="tgs_graph_cover_resample_+3A_method">method</code></td>
<td>
<p>method for calculating co_cluster and co_sample; valid values:
&quot;hash&quot;, &quot;full&quot;, &quot;edges&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is explained in a &quot;MetaCell: analysis of single-cell RNA-seq
data using K-nn graph partitions&quot; paper, published in &quot;Genome Biology&quot; #20:
https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1812-2
</p>


<h3>Value</h3>

<p>If method == &quot;hash&quot;, a list with two members. The first member is a
data frame with 3 columns: &quot;node1&quot;, &quot;node2&quot; and &quot;cnt&quot;. &quot;cnt&quot; indicates the
number of times &quot;node1&quot; and &quot;node2&quot; appeared in the same cluster. The second
member of the list is a vector of <strong>number of nodes</strong> length reflecting how
many times each node was used in the subset.
</p>
<p>If method == &quot;full&quot;, a list containing two matrices: co_cluster and
co_sample.
</p>
<p>If method == &quot;edges&quot;, a list containing two data frames: co_cluster and
co_sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tgs_graph">tgs_graph()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: all the available CPU cores might be used

set.seed(seed = 0)
rows &lt;- 100
cols &lt;- 200
vals &lt;- sample(1:(rows * cols / 2), rows * cols, replace = TRUE)
m &lt;- matrix(vals, nrow = rows, ncol = cols)

r1 &lt;- tgs_cor(m, pairwise.complete.obs = FALSE, spearman = TRUE)
r2 &lt;- tgs_knn(r1, knn = 20, diag = FALSE)
r3 &lt;- tgs_graph(r2, knn = 3, k_expand = 10)
r4 &lt;- tgs_graph_cover_resample(r3, 10, 1)




</code></pre>

<hr>
<h2 id='tgs_knn'>Returns k highest values of each column</h2><span id='topic+tgs_knn'></span>

<h3>Description</h3>

<p>Returns k highest values of each column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_knn(x, knn, diag = FALSE, threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_knn_+3A_x">x</code></td>
<td>
<p>numeric matrix or data frame (see below)</p>
</td></tr>
<tr><td><code id="tgs_knn_+3A_knn">knn</code></td>
<td>
<p>the number of highest values returned per column</p>
</td></tr>
<tr><td><code id="tgs_knn_+3A_diag">diag</code></td>
<td>
<p>if 'F' values of row 'i' and col 'j' are skipped for each i == j</p>
</td></tr>
<tr><td><code id="tgs_knn_+3A_threshold">threshold</code></td>
<td>
<p>filter out values lower than threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'tgs_knn' returns the highest 'knn' values of each column of 'x' (if 'x' is
a matrix). 'x' can be also a sparse matrix given in a data frame of 'col',
'row', 'value' format.
</p>
<p>'NA' and 'Inf' values are skipped as well as the values below 'threshold'.
If 'diag' is 'F' values of the diagonal (row == col) are skipped too.
</p>


<h3>Value</h3>

<p>A sparse matrix in a data frame format with 'col1', 'col2', 'val'
and 'rank' columns. 'col1' and 'col2' represent the column and the row
number of 'x'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: all the available CPU cores might be used

set.seed(seed = 1)
rows &lt;- 100
cols &lt;- 1000
vals &lt;- sample(1:(rows * cols / 2), rows * cols, replace = TRUE)
m &lt;- matrix(vals, nrow = rows, ncol = cols)
m[sample(1:(rows * cols), rows * cols / 1000)] &lt;- NA
r &lt;- tgs_knn(m, 3)




</code></pre>

<hr>
<h2 id='tgs_matrix_tapply'>For each matrix row apply a function over a ragged array</h2><span id='topic+tgs_matrix_tapply'></span>

<h3>Description</h3>

<p>For each matrix row apply a function to each cell of a ragged array, that is
to each (non-empty) group of values given by a unique combination of the
levels of certain factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgs_matrix_tapply(x, index, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgs_matrix_tapply_+3A_x">x</code></td>
<td>
<p>a matrix or a sparse matrix of 'dgCMatrix' type</p>
</td></tr>
<tr><td><code id="tgs_matrix_tapply_+3A_index">index</code></td>
<td>
<p>a 'list' of one or more 'factor's, each of same length as the
number of columns in 'x'. The elements are coerced to factors by
'as.factor'.</p>
</td></tr>
<tr><td><code id="tgs_matrix_tapply_+3A_fun">fun</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="tgs_matrix_tapply_+3A_...">...</code></td>
<td>
<p>optional arguments to 'fun'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'tgs_matrix_tapply(x, index, fun)' is essentialy an efficient implementation
of 'apply(mat, 1, function(x) tapply(x, index, fun))'.
</p>


<h3>Value</h3>

<p>A matrix of length(index) X nrow(x) size. Each <code>[i,j]</code> element
represents the result of applying 'fun' to
<code>x[i,which(index==levels(index)[j])]</code>. <br />
Note that the return value is a dense matrix even when <code>x</code> is sparse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: all the available CPU cores might be used

set.seed(seed = 1)
nr &lt;- 6
nc &lt;- 10
mat &lt;- matrix(sample(c(rep(0, 6), 1:3), nr * nc, replace = TRUE), nrow = nr, ncol = nc)
index &lt;- factor(rep_len(1:3, ncol(mat)), levels = 0:5)
r1 &lt;- apply(mat, 1, function(x) tapply(x, index, sum))
r2 &lt;- tgs_matrix_tapply(mat, index, sum)




</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
