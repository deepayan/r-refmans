<!DOCTYPE html><html><head><title>Help for package strand</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {strand}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#example_shiny_app'><p>Run an example shiny app</p></a></li>
<li><a href='#example_strategy_config'><p>Load example strategy configuration</p></a></li>
<li><a href='#make_ft'><p>Make Basic Flextable</p></a></li>
<li><a href='#PortOpt'><p>Portfolio optimization class</p></a></li>
<li><a href='#sample_inputs'><p>Sample security inputs for examples and testing</p></a></li>
<li><a href='#sample_pricing'><p>Sample security pricing data for examples and testing</p></a></li>
<li><a href='#sample_secref'><p>Sample security reference data for examples and testing</p></a></li>
<li><a href='#show_best_worst'><p>Show Best/Worst Performers</p></a></li>
<li><a href='#show_config'><p>Show Strategy Configuration</p></a></li>
<li><a href='#show_constraints'><p>Show Strategy Constraints</p></a></li>
<li><a href='#show_monthly_returns'><p>Show monthly returns</p></a></li>
<li><a href='#show_stats'><p>Show Overall Stats Table</p></a></li>
<li><a href='#Simulation'><p>Simulation class</p></a></li>
<li><a href='#strand-package'><p>strand: a framework for investment strategy simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Framework for Investment Strategy Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-11-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework for performing discrete (share-level) simulations of
  investment strategies. Simulated portfolios optimize exposure to an input signal subject
  to constraints such as position size and factor exposure. For background see L. Chincarini
  and D. Kim (2010, ISBN:978-0-07-145939-6) "Quantitative Equity Portfolio Management".</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/strand-tech/strand">https://github.com/strand-tech/strand</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/strand-tech/strand/issues">https://github.com/strand-tech/strand/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, Matrix, Rglpk, dplyr, tidyr, arrow, lubridate, rlang,
yaml, ggplot2, tibble, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, shiny, shinyFiles, shinyjs, DT,
Rsymphony, officer, flextable, plotly</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-19 01:59:29 UTC; enos</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeff Enos [cre, aut, cph],
  David Kane [aut],
  Ben Czekanski [ctb],
  Robert Hoover [ctb],
  Jack Luby [ctb],
  Nils Wallin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeff Enos &lt;jeffrey.enos@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-19 21:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='example_shiny_app'>Run an example shiny app</h2><span id='topic+example_shiny_app'></span>

<h3>Description</h3>

<p>Runs a shiny app that allows interactively configuring and running a
simulation. Once the simulation is finished results, such as performance
statistics and plots of exposures, are available in a results panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_shiny_app()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  example_shiny_app()
}

</code></pre>

<hr>
<h2 id='example_strategy_config'>Load example strategy configuration</h2><span id='topic+example_strategy_config'></span>

<h3>Description</h3>

<p>Loads an example strategy configuration file for use in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_strategy_config()
</code></pre>


<h3>Value</h3>

<p>An object of class <code>list</code> that contains the example
configuration. The list object is the result of loading the package's
example yaml configuration file <code>application/strategy_config.yaml</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
config &lt;- example_strategy_config()
names(config$strategies)
show(config$strategies$strategy_1)

</code></pre>

<hr>
<h2 id='make_ft'>Make Basic Flextable</h2><span id='topic+make_ft'></span>

<h3>Description</h3>

<p>Make a flextable with preferred formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ft(x, title = NULL, col_names = NULL, hlines = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ft_+3A_x">x</code></td>
<td>
<p>The data.frame to use for flextable</p>
</td></tr>
<tr><td><code id="make_ft_+3A_title">title</code></td>
<td>
<p>The string to use as the table title</p>
</td></tr>
<tr><td><code id="make_ft_+3A_col_names">col_names</code></td>
<td>
<p>A character vector of preferred column names for flextable. 
Length of character vector must be equal to the number of columns. Defaults 
to NULL, in which case the column names of x are used in the flextable.</p>
</td></tr>
<tr><td><code id="make_ft_+3A_hlines">hlines</code></td>
<td>
<p>The row numbers to draw horizontal lines beneath. Defaults to 
&quot;all&quot;, can be &quot;all&quot;, &quot;none&quot;, or a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flextable object with the argued formatting
</p>

<hr>
<h2 id='PortOpt'>Portfolio optimization class</h2><span id='topic+PortOpt'></span>

<h3>Description</h3>

<p>The <code>PortOpt</code> object is used to set up and solve a
portfolio optimization problem.
</p>


<h3>Details</h3>

<p>A <code>PortOpt</code> object is configured in the same way as a
<code>Simulation</code> object, by supplying configuration in a yaml file or list
to the object constructor. Methods are available for adding constraints and
retrieving information about the optimization setup and results. See the
package vignette for information on configuration file setup.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>PortOpt$new()</code></a>
</p>
</li>
<li> <p><a href="#method-setVerbose"><code>PortOpt$setVerbose()</code></a>
</p>
</li>
<li> <p><a href="#method-addConstraints"><code>PortOpt$addConstraints()</code></a>
</p>
</li>
<li> <p><a href="#method-getConstraintMatrix"><code>PortOpt$getConstraintMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-getConstraintMeta"><code>PortOpt$getConstraintMeta()</code></a>
</p>
</li>
<li> <p><a href="#method-solve"><code>PortOpt$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-getResultData"><code>PortOpt$getResultData()</code></a>
</p>
</li>
<li> <p><a href="#method-getLoosenedConstraints"><code>PortOpt$getLoosenedConstraints()</code></a>
</p>
</li>
<li> <p><a href="#method-getMaxPosition"><code>PortOpt$getMaxPosition()</code></a>
</p>
</li>
<li> <p><a href="#method-getMaxOrder"><code>PortOpt$getMaxOrder()</code></a>
</p>
</li>
<li> <p><a href="#method-summaryDf"><code>PortOpt$summaryDf()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>PortOpt$print()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>PortOpt$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>PortOpt</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$new(config, input_data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>An object of class <code>list</code> or <code>character</code>. If the
value passed is a character vector, it should be of length 1 and
specify the path to a yaml configuration file that contains the
object's configuration info. If the value passed is of class list(),
the list should contain the object's configuration info in list form
(e.g, the return value of calling <code>yaml.load_file</code> on the
configuration file).</p>
</dd>
<dt><code>input_data</code></dt><dd><p>A <code>data.frame</code> that contains all necessary input
for the optimization.
</p>
<p>If the top-level configuration item <code>price_var</code> is not set, prices will be expected
in the <code>ref_price</code> column of <code>input_data</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>PortOpt</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>library(dplyr)
data(sample_secref)
data(sample_inputs)
data(sample_pricing)

# Construct optimization input for one day from sample data. The columns
# of the input data must match the input configuration.
optim_input &lt;-
  inner_join(sample_inputs, sample_pricing,
             by = c("id", "date")) %&gt;%
  left_join(sample_secref, by = "id") %&gt;%
  filter(date %in% as.Date("2020-06-01")) %&gt;%
  mutate(ref_price = price_unadj,
                shares_strategy_1 = 0)

opt &lt;-
  PortOpt$new(config = example_strategy_config(),
              input_data = optim_input)

# The problem is not solved until the \code{solve} method is called
# explicitly.
opt$solve()
</pre>
</div>


<hr>
<a id="method-setVerbose"></a>



<h4>Method <code>setVerbose()</code></h4>

<p>Set the verbose flag to control the amount of informational
output.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$setVerbose(verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>Logical flag indicating whether to be verbose or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-addConstraints"></a>



<h4>Method <code>addConstraints()</code></h4>

<p>Add optimization constraints.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$addConstraints(constraint_matrix, dir, rhs, name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>constraint_matrix</code></dt><dd><p>Matrix with one row per constraint and <code class="reqn">(S+1) \times N</code>
columns, where S is number of strategies and N is the number of stocks.
</p>
<p>The variables in the optimization are
</p>
<p style="text-align: center;"><code class="reqn">x_{1,1}, x_{2,1}, \ldots, x_{N,1},</code>
</p>

<p style="text-align: center;"><code class="reqn">x_{1,2}, x_{2,2}, \ldots, x_{N,2},</code>
</p>

<p style="text-align: center;"><code class="reqn">\vdots</code>
</p>

<p style="text-align: center;"><code class="reqn">x_{1,S}, x_{2,S}, \ldots, x_{N,S},</code>
</p>

<p style="text-align: center;"><code class="reqn">y_1, \ldots, y_N</code>
</p>

<p>The first <code class="reqn">N \times S</code> variables are the individual strategy
trades. Variable <code class="reqn">x_{i,s}</code> represents the signed trade for stock i
in strategy s. The following N auxillary variables <code class="reqn">y_1, \ldots, y_N</code>
represent the absolute value of the net trade in each stock. So
for a stock i, we have:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \sum_s |x_{i,s}|</code>
</p>
</dd>
<dt><code>dir</code></dt><dd><p>Vector of class character of length
<code>nrow(constraint_matrix)</code> that specifies the direction of the
constraints. All elements must be one of &quot;&gt;=&quot;, &quot;==&quot;, or &quot;&lt;=&quot;.</p>
</dd>
<dt><code>rhs</code></dt><dd><p>Vector of class numeric of length
<code>nrow(constraint_matrix)</code> that specifies the bounds of the
constraints.</p>
</dd>
<dt><code>name</code></dt><dd><p>Character vector of length 1 that specifies a name for the
set of constraints that are being created.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-getConstraintMatrix"></a>



<h4>Method <code>getConstraintMatrix()</code></h4>

<p>Constraint matrix access.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$getConstraintMatrix()</pre></div>



<h5>Returns</h5>

<p>The optimization's constraint matrix.
</p>


<hr>
<a id="method-getConstraintMeta"></a>



<h4>Method <code>getConstraintMeta()</code></h4>

<p>Provide high-level constraint information.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$getConstraintMeta()</pre></div>



<h5>Returns</h5>

<p>A data frame that contains constraint metadata, such as current constraint value and
whether a constraint is currently within bounds, for all single-row
constraints. Explicitly exclude net trade constraints and constraints
that involve net trade variables.
</p>


<hr>
<a id="method-solve"></a>



<h4>Method <code>solve()</code></h4>

<p>Solve the optimization. After running <code>solve()</code>,
results can be retrieved using <code>getResultData()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$solve()</pre></div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-getResultData"></a>



<h4>Method <code>getResultData()</code></h4>

<p>Get optimization result.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$getResultData()</pre></div>



<h5>Returns</h5>

<p>A data frame that contains the number of shares and the net
market value of the trades at the strategy and joint (net) level
for each stock in the optimization's input.
</p>


<hr>
<a id="method-getLoosenedConstraints"></a>



<h4>Method <code>getLoosenedConstraints()</code></h4>

<p>Provide information about any constraints that were loosened
in order to solve the optimization.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$getLoosenedConstraints()</pre></div>



<h5>Returns</h5>

<p>Object of class <code>list</code> where keys are the names of the
loosened constraints and values are how much they were loosened toward
current values. Values are expressed as (current constraint value -
loosened constraint value) / (current constraint value - violated
constraint value). A value of 0 means a constraint was loosened 100%
and is not binding.
</p>


<hr>
<a id="method-getMaxPosition"></a>



<h4>Method <code>getMaxPosition()</code></h4>

<p>Provide information about the maximum position size allowed
for long and short positions.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$getMaxPosition()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains the limits on
size for long and short positions for each strategy and security. The
columns in the data frame are:
</p>

<dl>
<dt>id</dt><dd><p>Security identifier.</p>
</dd>
<dt>strategy</dt><dd><p>Strategy name.</p>
</dd>
<dt>max_pos_lmv</dt><dd><p>Maximum net market value for a long position.</p>
</dd>
<dt>max_pos_smv</dt><dd><p>Maximum net market value for a short position.</p>
</dd>
</dl>



<hr>
<a id="method-getMaxOrder"></a>



<h4>Method <code>getMaxOrder()</code></h4>

<p>Provide information about the maximum order size allowed
for each security and strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$getMaxOrder()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains the limit on
order size for each strategy and security. The
columns in the data frame are:
</p>

<dl>
<dt>id</dt><dd><p>Security identifier.</p>
</dd>
<dt>strategy</dt><dd><p>Strategy name.</p>
</dd>
<dt>max_order_gmv</dt><dd><p>Maximum gross market value allowed for an order.</p>
</dd>
</dl>



<hr>
<a id="method-summaryDf"></a>



<h4>Method <code>summaryDf()</code></h4>

<p>Provide aggregate level optimization information if the
problem has been solved.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$summaryDf()</pre></div>



<h5>Returns</h5>

<p>A data frame with one row per strategy, including the joint (net)
level, and columns for starting and ending market values and factor
expoure values.
</p>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print summary information.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$print()</pre></div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PortOpt$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `PortOpt$new`
## ------------------------------------------------

library(dplyr)
data(sample_secref)
data(sample_inputs)
data(sample_pricing)

# Construct optimization input for one day from sample data. The columns
# of the input data must match the input configuration.
optim_input &lt;-
  inner_join(sample_inputs, sample_pricing,
             by = c("id", "date")) %&gt;%
  left_join(sample_secref, by = "id") %&gt;%
  filter(date %in% as.Date("2020-06-01")) %&gt;%
  mutate(ref_price = price_unadj,
                shares_strategy_1 = 0)

opt &lt;-
  PortOpt$new(config = example_strategy_config(),
              input_data = optim_input)

# The problem is not solved until the \code{solve} method is called
# explicitly.
opt$solve()
</code></pre>

<hr>
<h2 id='sample_inputs'>Sample security inputs for examples and testing</h2><span id='topic+sample_inputs'></span>

<h3>Description</h3>

<p>A dataset containing sample security input data for 492 securities and 65
weekdays, from 2020-06-01 to 2020-08-31. Data items include average trading
dollar volume, market cap, and normalized size and value factors. The pricing
data used to construct the dataset was downloaded using the
<a href="https://api.tiingo.com/">Tiingo Stock API</a> and is used with permission.
Fundamental data items were downloaded from EDGAR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_inputs)
</code></pre>


<h3>Format</h3>

<p>A data frame with 31980 rows and 7 variables: 
</p>

<dl>
<dt>date</dt><dd><p>Input date. It is assumed that the input data for day X is
known at the beginning of day X (e.g., the data is as-of the previous day's
close).</p>
</dd>
<dt>id</dt><dd><p>Security identifier.</p>
</dd>
<dt>rc_vol</dt><dd><p>Average dollar
trading volume for the security over the past 20 trading days.</p>
</dd>
<dt>market_cap</dt><dd><p>Market capitalization, in dollars. The shares outstanding
value used to calculate market cap is the latest value available at the
beginning of the month.</p>
</dd>
<dt>book_to_price</dt><dd><p>Ratio of total equity to
market cap. The stockholders' equity value used to calculate book to price
is the latest value available at the beginning of the month.</p>
</dd>
<dt>size</dt><dd><p>Market cap factor normalized to be N(0,1) for each day.</p>
</dd>
<dt>value</dt><dd><p>Book to price factor normalized to be N(0,1) for each day.</p>
</dd> </dl>



<h3>Details</h3>

<p>Data for most members of the S&amp;P 500 are present. Some securities have been
omitted due to data processing complexities. For example, securities for
companies with multiple share classes have been omitted in the current
version.
</p>
<p>Values for shares outstanding and stockholders' equity downloaded from EDGAR may be
inaccurate due to XBRL parsing issues.
</p>
<p>Full code for reconstructing the dataset can be found in the
<a href="https://github.com/strand-tech/pystrand">pystrand</a> repository.
</p>

<hr>
<h2 id='sample_pricing'>Sample security pricing data for examples and testing</h2><span id='topic+sample_pricing'></span>

<h3>Description</h3>

<p>A dataset containing sample security pricing data for 492 securities and 65
weekdays, from 2020-06-01 to 2020-08-31. This data was downloaded using the
<a href="https://api.tiingo.com/">Tiingo Stock API</a> and is redistributed with
permission.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_pricing)
</code></pre>


<h3>Format</h3>

<p>A data frame with 31980 rows and 8 variables:
</p>

<dl>
<dt>date</dt><dd><p>Pricing date.</p>
</dd>
<dt>id</dt><dd><p>Security identifier.</p>
</dd>
<dt>price_unadj</dt><dd><p>The unadjusted price of the security.</p>
</dd>
<dt>prior_close_unadj</dt><dd><p>The unadjusted prior closing price of the security.</p>
</dd>
<dt>dividend_unadj</dt><dd><p>The dividend for the security on an unadjusted basis, if any.</p>
</dd>
<dt>distribution_unadj</dt><dd><p>The distribution (e.g., spin-off) for the
security on an unadjusted basis (note that there is no spin-off information
in this dataset, so all values are zero).</p>
</dd>
<dt>volume</dt><dd><p>Trading volume for the security, in shares.</p>
</dd>
<dt>adjustment_ratio</dt><dd><p>The adjustment ratio for the security. For example,
AAPL has an adjustment ratio of 0.25 to account for its 4:1 split on
2020-08-31.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Full code for reconstructing the dataset can be found in the
<a href="https://github.com/strand-tech/pystrand">pystrand</a> repository.
</p>

<hr>
<h2 id='sample_secref'>Sample security reference data for examples and testing</h2><span id='topic+sample_secref'></span>

<h3>Description</h3>

<p>A dataset containing sample reference data for the securities of 492 large
companies. All securities in the dataset were in the S&amp;P 500 for most or all
of the period June-August 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_secref)
</code></pre>


<h3>Format</h3>

<p>A data frame with 492 rows and 4 variables:
</p>

<dl>
<dt>id</dt><dd><p>Unique security identifier (the security's ticker).</p>
</dd>
<dt>name</dt><dd><p>Company name.</p>
</dd>
<dt>symbol</dt><dd><p>Human-readable symbol for display and reporting purposes. In
the case of this dataset it is the same as the <code>id</code> variable.</p>
</dd>
<dt>sector</dt><dd><p>GICS sector for the company according to the Wikipedia page <a href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies">List of S&amp;P 500 companies</a>.</p>
</dd> </dl>


<hr>
<h2 id='show_best_worst'>Show Best/Worst Performers</h2><span id='topic+show_best_worst'></span>

<h3>Description</h3>

<p>Build a flextable object showing a Simulation's best and worst 
performers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_best_worst(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_best_worst_+3A_sim">sim</code></td>
<td>
<p>A Simulation object to show the best and worst performers for</p>
</td></tr>
</table>

<hr>
<h2 id='show_config'>Show Strategy Configuration</h2><span id='topic+show_config'></span>

<h3>Description</h3>

<p>Build a flextable object showing a Simulation's configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_config(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_config_+3A_sim">sim</code></td>
<td>
<p>A Simulation object to show the configuration for</p>
</td></tr>
</table>

<hr>
<h2 id='show_constraints'>Show Strategy Constraints</h2><span id='topic+show_constraints'></span>

<h3>Description</h3>

<p>Build a flextable object showing a Simulation's risk constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_constraints(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_constraints_+3A_sim">sim</code></td>
<td>
<p>A Simulation object to show the configuration for</p>
</td></tr>
</table>

<hr>
<h2 id='show_monthly_returns'>Show monthly returns</h2><span id='topic+show_monthly_returns'></span>

<h3>Description</h3>

<p>Build a flextable object that shows a simulation's return by
month by formatting the output of 'Simulation$overallReturnsByMonthDf'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_monthly_returns(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_monthly_returns_+3A_sim">sim</code></td>
<td>
<p>A Simulation object with results to display</p>
</td></tr>
</table>

<hr>
<h2 id='show_stats'>Show Overall Stats Table</h2><span id='topic+show_stats'></span>

<h3>Description</h3>

<p>Build a flextable object showing a Simulation's overall statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_stats(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_stats_+3A_sim">sim</code></td>
<td>
<p>A Simulation object to show the statistics for</p>
</td></tr>
</table>

<hr>
<h2 id='Simulation'>Simulation class</h2><span id='topic+Simulation'></span>

<h3>Description</h3>

<p>Class for running a simulation and getting results.
</p>


<h3>Details</h3>

<p>The <code>Simulation</code> class is used to set up and run a daily
simulation over a particular period. Portfolio construction parameters and
other simulator settings can be configured in a yaml file that is passed to
the object's constructor. See <code>vignette("strand")</code> for information on
configuration file setup.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Simulation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-setVerbose"><code>Simulation$setVerbose()</code></a>
</p>
</li>
<li> <p><a href="#method-setShinyCallback"><code>Simulation$setShinyCallback()</code></a>
</p>
</li>
<li> <p><a href="#method-getSecurityReference"><code>Simulation$getSecurityReference()</code></a>
</p>
</li>
<li> <p><a href="#method-run"><code>Simulation$run()</code></a>
</p>
</li>
<li> <p><a href="#method-getSimDates"><code>Simulation$getSimDates()</code></a>
</p>
</li>
<li> <p><a href="#method-getSimSummary"><code>Simulation$getSimSummary()</code></a>
</p>
</li>
<li> <p><a href="#method-getSimDetail"><code>Simulation$getSimDetail()</code></a>
</p>
</li>
<li> <p><a href="#method-getPositionSummary"><code>Simulation$getPositionSummary()</code></a>
</p>
</li>
<li> <p><a href="#method-getInputStats"><code>Simulation$getInputStats()</code></a>
</p>
</li>
<li> <p><a href="#method-getLooseningInfo"><code>Simulation$getLooseningInfo()</code></a>
</p>
</li>
<li> <p><a href="#method-getOptimizationSummary"><code>Simulation$getOptimizationSummary()</code></a>
</p>
</li>
<li> <p><a href="#method-getExposures"><code>Simulation$getExposures()</code></a>
</p>
</li>
<li> <p><a href="#method-getDelistings"><code>Simulation$getDelistings()</code></a>
</p>
</li>
<li> <p><a href="#method-getSingleStrategySummaryDf"><code>Simulation$getSingleStrategySummaryDf()</code></a>
</p>
</li>
<li> <p><a href="#method-plotPerformance"><code>Simulation$plotPerformance()</code></a>
</p>
</li>
<li> <p><a href="#method-plotContribution"><code>Simulation$plotContribution()</code></a>
</p>
</li>
<li> <p><a href="#method-plotMarketValue"><code>Simulation$plotMarketValue()</code></a>
</p>
</li>
<li> <p><a href="#method-plotCategoryExposure"><code>Simulation$plotCategoryExposure()</code></a>
</p>
</li>
<li> <p><a href="#method-plotFactorExposure"><code>Simulation$plotFactorExposure()</code></a>
</p>
</li>
<li> <p><a href="#method-plotNumPositions"><code>Simulation$plotNumPositions()</code></a>
</p>
</li>
<li> <p><a href="#method-plotTurnover"><code>Simulation$plotTurnover()</code></a>
</p>
</li>
<li> <p><a href="#method-plotUniverseSize"><code>Simulation$plotUniverseSize()</code></a>
</p>
</li>
<li> <p><a href="#method-plotNonInvestablePct"><code>Simulation$plotNonInvestablePct()</code></a>
</p>
</li>
<li> <p><a href="#method-overallStatsDf"><code>Simulation$overallStatsDf()</code></a>
</p>
</li>
<li> <p><a href="#method-overallReturnsByMonthDf"><code>Simulation$overallReturnsByMonthDf()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>Simulation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-writeFeather"><code>Simulation$writeFeather()</code></a>
</p>
</li>
<li> <p><a href="#method-readFeather"><code>Simulation$readFeather()</code></a>
</p>
</li>
<li> <p><a href="#method-getConfig"><code>Simulation$getConfig()</code></a>
</p>
</li>
<li> <p><a href="#method-writeReport"><code>Simulation$writeReport()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Simulation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Simulation</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$new(
  config = NULL,
  raw_input_data = NULL,
  input_dates = NULL,
  raw_pricing_data = NULL,
  security_reference_data = NULL,
  delisting_data = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>An object of class <code>list</code> or <code>character</code>, or
<code>NULL</code>. If the value passed is a character vector, it should be of
length 1 and specify the path to a yaml configuration file that
contains the object's configuration info. If the value passed is of
class list(), the list should contain the object's configuration info
in list form (e.g, the return value of calling <code>yaml.load_file</code> on
the configuration file). If the value passed is <code>NULL</code>, then there
will be no configuration information associated with the simulation and
it will not possible to call the <code>run</code> method. Setting
<code>config = NULL</code> is useful when creating simulation objects into
which results will be loaded with <code>readFeather</code>.</p>
</dd>
<dt><code>raw_input_data</code></dt><dd><p>A data frame that contains all of the input data
(for all periods) for the simulation. The data frame must have a
<code>date</code> column. Data supplied using this parameter will be
used if the configuration option <code>simulator/input_data/type</code> is
set to <code>object</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>input_dates</code></dt><dd><p>Vector of class <code>Date</code> that specifies  when input
data should be updated. If data is being supplied using the
<code>raw_input_data</code> parameter, then <code>input_dates</code> defaults to
set of dates present in this data.</p>
</dd>
<dt><code>raw_pricing_data</code></dt><dd><p>A data frame that contains all of the input data
(for all periods) for the simulation. The data frame must have a
<code>date</code> column. Data supplied using this parameter will only be
used if the configuration option <code>simulator/pricing_data/type</code> is
set to <code>object</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>security_reference_data</code></dt><dd><p>A data frame that contains reference data
on the securities in the simulation, including any categories that are
used in portfolio construction constraints. Note that the simulator
will throw an error if there are input data records for which there is
no entry in the security reference. Data supplied using this parameter
will only be used if the configuration option
<code>simulator/secref_data/type</code> is set to <code>object</code>. Defaults to
<code>NULL</code>.</p>
</dd>
<dt><code>delisting_data</code></dt><dd><p>A data frame that contains delisting dates and
associated returns. It must contain three columns: id (character),
delisting_date (Date), and delisting_return (numeric). The date in the
delisting_date column means the day on which a stock will be removed
from the simulation portfolio. It is typically the day after the last
day of trading. The delisting_return column reflects what, if any, P&amp;L
should be recorded on the delisting date. A delisting_return of -1
means that the shares were deemed worthless. The delisting return is
multiplied by the starting net market value of the position to
determine P&amp;L for the delisted position on the delisting date. Note
that the portfolio optimization does not include stocks that are being
removed due to delisting. Data supplied using this parameter will only
be used if the configuration option
<code>simulator/delisting_data/type</code> is set to <code>object</code>. Defaults
to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Simulation</code> object.
</p>


<hr>
<a id="method-setVerbose"></a>



<h4>Method <code>setVerbose()</code></h4>

<p>Set the verbose flag to control info output.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$setVerbose(verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>Logical flag indicating whether to be verbose or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-setShinyCallback"></a>



<h4>Method <code>setShinyCallback()</code></h4>

<p>Set the callback function for updating progress when running
a simulation in shiny.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$setShinyCallback(callback)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>callback</code></dt><dd><p>A function suitable for updating a shiny Progress object.
It must have two parameters: <code>value</code>, indicating the progress
amount, and detail, and <code>detail</code>, a text string for display on the
progress bar.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-getSecurityReference"></a>



<h4>Method <code>getSecurityReference()</code></h4>

<p>Get security reference information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getSecurityReference()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains the security
reference data for the simulation.
</p>


<hr>
<a id="method-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$run()</pre></div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-getSimDates"></a>



<h4>Method <code>getSimDates()</code></h4>

<p>Get a list of all date for the simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getSimDates()</pre></div>



<h5>Returns</h5>

<p>A vector of class <code>Date</code> over which the simulation currently iterates: all
weekdays between the 'from' and 'to' dates in the simulation's config.
</p>


<hr>
<a id="method-getSimSummary"></a>



<h4>Method <code>getSimSummary()</code></h4>

<p>Get summary information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getSimSummary(strategy_name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 that specifies the
strategy for which to get detail data. If <code>NULL</code> data for all
strategies is returned. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains summary data
for the simulation, by period, at the joint and strategy level. The data
frame contains the following columns:
</p>

<dl>
<dt>strategy</dt><dd><p>Strategy name, or 'joint' for the aggregate strategy.</p>
</dd>
<dt>sim_date</dt><dd><p>Date of the summary data.</p>
</dd>
<dt>market_fill_nmv</dt><dd><p>Total net market value of fills that do not
net down across strategies.</p>
</dd>
<dt>transfer_fill_nmv</dt><dd><p>Total net market value of fills that
represent &quot;internal transfers&quot;, i.e., fills in one strategy that net
down with fills in another. Note that at the joint level this column
by definition is 0.</p>
</dd>
<dt>market_order_gmv</dt><dd><p>Total gross market value of orders that do not
net down across strategies.</p>
</dd>
<dt>market_fill_gmv</dt><dd><p>Total gross market value of fills that do not
net down across strategies.</p>
</dd>
<dt>transfer_fill_gmv</dt><dd><p>Total gross market value of fills that
represent &quot;internal transfers&quot;, i.e., fills in one strategy that net
down with fills in another.</p>
</dd>
<dt>start_nmv</dt><dd><p>Total net market value of all positions at the start
of the period.</p>
</dd>
<dt>start_lmv</dt><dd><p>Total net market value of all long positions at the
start of the period.</p>
</dd>
<dt>start_smv</dt><dd><p>Total net market value of all short positions at the
start of the period.</p>
</dd>
<dt>end_nmv</dt><dd><p>Total net market value of all positions at the end of
the period.</p>
</dd>
<dt>end_gmv</dt><dd><p>Total gross market value of all positions at the end
of the period.</p>
</dd>
<dt>end_lmv</dt><dd><p>Total net market value of all long positions at the
end of the period.</p>
</dd>
<dt>end_smv</dt><dd><p>Total net market value of all short positions at the
end of the period.</p>
</dd>
<dt>end_num</dt><dd><p>Total number of positions at the end of the period.</p>
</dd>
<dt>end_num_long</dt><dd><p>Total number of long positions at the end of the
period.</p>
</dd>
<dt>end_num_short</dt><dd><p>Total number of short positions at the end of
the period.</p>
</dd>
<dt>position_pnl</dt><dd><p>The total difference between the end and start
market value of positions.</p>
</dd>
<dt>trading_pnl</dt><dd><p>The total difference between the market value of
trades at the benchmark price and at the end price. Note: currently
assuming benchmark price is the closing price, so trading P&amp;L is
zero.</p>
</dd>
<dt>gross_pnl</dt><dd><p>Total P&amp;L gross of costs, calculated as position_pnl
+ trading_pnl.</p>
</dd>
<dt>trade_costs</dt><dd><p>Total trade costs (slippage).</p>
</dd>
<dt>financing_costs</dt><dd><p>Total financing/borrow costs.</p>
</dd>
<dt>net_pnl</dt><dd><p>Total P&amp;L net of costs, calculated as gross_pnl -
trade_costs - financing_costs.</p>
</dd>
<dt>fill_rate_pct</dt><dd><p>Total fill rate across all market orders,
calculated as 100 * market_fill_gmv / market_order_gmv.</p>
</dd>
<dt>num_investable</dt><dd><p>Number of investable securities (size of universe).</p>
</dd>
</dl>



<hr>
<a id="method-getSimDetail"></a>



<h4>Method <code>getSimDetail()</code></h4>

<p>Get detail information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getSimDetail(
  sim_date = NULL,
  strategy_name = NULL,
  security_id = NULL,
  columns = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sim_date</code></dt><dd><p>Vector of length 1 of class Date or character that
specifies the period for which to get detail information. If
<code>NULL</code> then data from all periods is returned. Defaults
to <code>NULL</code>.</p>
</dd>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 that specifies the
strategy for which to get detail data. If <code>NULL</code> data for all
strategies is returned. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>security_id</code></dt><dd><p>Character vector of length 1 that specifies the
security for which to get detail data. If <code>NULL</code> data for all
securities is returned. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>columns</code></dt><dd><p>Vector of class character specifying the columns to
return. This parameter can be useful when dealing with very large
detail datasets.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains security-level
detail data for the simulation for the desired strategies, securities,
dates, and columns. Available columns include:
</p>

<dl>
<dt>id</dt><dd><p>Security identifier.</p>
</dd>
<dt>strategy</dt><dd><p>Strategy name, or 'joint' for the aggregate strategy.</p>
</dd>
<dt>sim_date</dt><dd><p>Date to which the data pertains.</p>
</dd>
<dt>shares</dt><dd><p>Shares at the start of the period.</p>
</dd>
<dt>int_shares</dt><dd><p>Shares at the start of the period that net down
with positions in other strategies.</p>
</dd>
<dt>ext_shares</dt><dd><p>Shares at the start of the period that do not net
down with positions in other strategies.</p>
</dd>
<dt>order_shares</dt><dd><p>Order, in shares.</p>
</dd>
<dt>market_order_shares</dt><dd><p>Order that does not net down with orders
in other strategies, in shares.</p>
</dd>
<dt>transfer_order_shares</dt><dd><p>Order that nets down with orders in
other strategies, in shares.</p>
</dd>
<dt>fill_shares</dt><dd><p>Fill, in shares.</p>
</dd>
<dt>market_fill_shares</dt><dd><p>Fill that does not net down with fills in
other strategies, in shares.</p>
</dd>
<dt>transfer_fill_shares</dt><dd><p>Fill that nets down with fills in other
strategies, in shares.</p>
</dd>
<dt>end_shares</dt><dd><p>Shares at the end of the period.</p>
</dd>
<dt>end_int_shares</dt><dd><p>Shares at the end of the period that net down
with positions in other strategies.</p>
</dd>
<dt>end_ext_shares</dt><dd><p>Shares at the end of the period that do not net
down with positions in other strategies.</p>
</dd>
<dt>start_price</dt><dd><p>Price for the security at the beginning of the
period.</p>
</dd>
<dt>end_price</dt><dd><p>Price for the security at the end of the period.</p>
</dd>
<dt>dividend</dt><dd><p>Dividend for the security, if any, for the
period.</p>
</dd>
<dt>distribution</dt><dd><p>Distribution (e.g., spin-off) for the security, if
any, for the period.</p>
</dd>
<dt>investable</dt><dd><p>Logical indicating whether the security is part of
the investable universe. The value of the flag is set to TRUE if the
security has not been delisted and satisfies the universe criterion
provided (if any) in the <code>simulator/universe</code> configuration
option.</p>
</dd>
<dt>delisting</dt><dd><p>Logical indicating whether a position in the
security was removed due to delisting. If delisting is set to TRUE,
the gross_pnl and net_pnl columns will contain the P&amp;L
due to delisting, if any. P&amp;L due to delisting is calculated as the
delisting return times the <code>start_nmv</code> of the position.</p>
</dd>
<dt>position_pnl</dt><dd><p>Position P&amp;L, calculated as shares * (end_price +
dividend + distribution - start_price)</p>
</dd>
<dt>trading_pnl</dt><dd><p>The difference between the market value of
trades at the benchmark price and at the end price. Note: currently
assuming benchmark price is the closing price, so trading P&amp;L is
zero.</p>
</dd>
<dt>trade_costs</dt><dd><p>Trade costs, calculated as a fixed percentage (set
in the simulation configuration) of the notional of the market trade
(valued at the close).</p>
</dd>
<dt>financing_costs</dt><dd><p>Financing cost for the position, calculated as
a fixed percentage (set in the simulation configuration) of the
notional of the starting value of the portfolio's external positions.
External positions are positions held on the street and are recorded
in the ext_shares column.</p>
</dd>
<dt>gross_pnl</dt><dd><p>Gross P&amp;L, calculated as position_pnl + trading_pnl.</p>
</dd>
<dt>net_pnl</dt><dd><p>Net P&amp;L, calculated as gross_pnl - trade_costs -
financing_costs.</p>
</dd>
<dt>market_order_nmv</dt><dd><p>Net market value of the order that does not
net down with orders in other strategies.</p>
</dd>
<dt>market_fill_gmv</dt><dd><p>Gross market value of the order that does not
net down with orders in other strategies.</p>
</dd>
<dt>market_fill_nmv</dt><dd><p>Net market value of the fill that does not net
down with orders in other strategies.</p>
</dd>
<dt>market_fill_gmv</dt><dd><p>Gross market value of the fill that does not
net down with orders in other strategies.</p>
</dd>
<dt>transfer_fill_nmv</dt><dd><p>Net market value of the fill that nets down
with fills in other strategies.</p>
</dd>
<dt>transfer_fill_gmv</dt><dd><p>Gross market value of the fill that nets down
with fills in other strategies.</p>
</dd>
<dt>start_nmv</dt><dd><p>Net market value of the position at the start of the
period.</p>
</dd>
<dt>end_nmv</dt><dd><p>Net market value of the position at the end of the
period.</p>
</dd>
<dt>end_gmv</dt><dd><p>Gross market value of the position at the end of the
period.</p>
</dd>
</dl>



<hr>
<a id="method-getPositionSummary"></a>



<h4>Method <code>getPositionSummary()</code></h4>

<p>Get summary information by security. This method can be
used, for example, to calculate the biggest winners and losers over the
course of the simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getPositionSummary(strategy_name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 that specifies the
strategy for which to get detail data. If <code>NULL</code> data for all
strategies is returned. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains summary
information aggregated by security. The data frame contains the
following columns:
</p>

<dl>
<dt>id</dt><dd><p>Security identifier.</p>
</dd>
<dt>strategy</dt><dd><p>Strategy name, or 'joint' for the aggregate
strategy.</p>
</dd>
<dt>gross_pnl</dt><dd><p>Gross P&amp;L for the position over the entire
simulation.</p>
</dd>
<dt>gross_pnl</dt><dd><p>Net P&amp;L for the position over the entire
simulation.</p>
</dd>
<dt>average_market_value</dt><dd><p>Average net market value of the
position over days in the simulation where the position was not
flat.</p>
</dd>
<dt>total_trading</dt><dd><p>Total gross market value of trades for the
security.</p>
</dd>
<dt>trade_costs</dt><dd><p>Total cost of trades for the security over the
entire simulation.</p>
</dd>
<dt>trade_costs</dt><dd><p>Total cost of financing for the position over the
entire simulation.</p>
</dd>
<dt>days_in_portfolio</dt><dd><p>Total number of days there was a position in
the security in the portfolio over the entire simulation.</p>
</dd>
</dl>



<hr>
<a id="method-getInputStats"></a>



<h4>Method <code>getInputStats()</code></h4>

<p>Get input statistics.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getInputStats()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains statistics on
select columns of input data. Statistics are tracked for the columns
listed in the configuration variable
<code>simulator/input_data/track_metadata</code>. The data frame contains the
following columns:
</p>

<dl>
<dt>period</dt><dd><p>Period to which statistics pertain.</p>
</dd>
<dt>input_rows</dt><dd><p>Total number of rows of input data, including
rows carried forward from the previous period.</p>
</dd>
<dt>cf_rows</dt><dd><p>Total number of rows carried forward from the previous
period.</p>
</dd>
<dt>num_na_<em>column</em></dt><dd><p>Number of NA values in <em>column</em>.  This
measure appears for each element of <code>track_metadata</code>.</p>
</dd>
<dt>cor_<em>column</em></dt><dd><p>Period-over-period correlation for <em>column</em>.
This measure appears for each element of <code>track_metadata</code>.</p>
</dd>
</dl>



<hr>
<a id="method-getLooseningInfo"></a>



<h4>Method <code>getLooseningInfo()</code></h4>

<p>Get loosening information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getLooseningInfo()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains, for each
period, which constraints were loosened in order to solve the portfolio
optimization problem, if any. The data frame contains the
following columns:
</p>

<dl>
<dt>date</dt><dd><p>Date for which the constraint was loosened.</p>
</dd>
<dt>constraint_name</dt><dd><p>Name of the constraint that was loosened.</p>
</dd>
<dt>pct_loosened</dt><dd><p>Percentage by which the constraint was loosened,
where 100 means loosened fully (i.e., the constraint is effectively
removed).</p>
</dd>
</dl>



<hr>
<a id="method-getOptimizationSummary"></a>



<h4>Method <code>getOptimizationSummary()</code></h4>

<p>Get optimization summary information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getOptimizationSummary()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains optimization
summary information, such as starting and ending factor constraint
values, at the strategy and joint level. The data frame contains the
following columns:
</p>

<dl>
<dt>strategy</dt><dd><p>Strategy name, or 'joint' for the aggregate strategy.</p>
</dd>
<dt>sim_date</dt><dd><p>Date to which the data pertains.</p>
</dd>
<dt>order_gmv</dt><dd><p>Total gross market value of orders generated by the
optimization.</p>
</dd>
<dt>start_smv</dt><dd><p>Total net market value of short positions at the
start of the optimization.</p>
</dd>
<dt>start_lmv</dt><dd><p>Total net market value of long positions at the
start of the optimization.</p>
</dd>
<dt>end_smv</dt><dd><p>Total net market value of short positions at the end
of the optimization.</p>
</dd>
<dt>end_lmv</dt><dd><p>Total net market value of long positions at the end of
the optimization.</p>
</dd>
<dt>start_<em>factor</em></dt><dd><p>Total net exposure to <em>factor</em> at the
start of the optimization, for each factor constraint.</p>
</dd>
<dt>end_<em>factor</em></dt><dd><p>Total net exposure to <em>factor</em> at the
start of the optimization, for each factor constraint.</p>
</dd>
</dl>



<hr>
<a id="method-getExposures"></a>



<h4>Method <code>getExposures()</code></h4>

<p>Get end-of-period exposure information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getExposures(type = "net")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Vector of length 1 that may be one of <code>"net"</code>,
<code>"long"</code>, <code>"short"</code>, and <code>"gross"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains end-of-period
exposure information for the simulation portfolio. The units of the
exposures are portfolio weight relative to strategy_captial (i.e., net
market value of exposure divided by strategy capital). The data frame
contains the following columns:
</p>

<dl>
<dt>strategy</dt><dd><p>Strategy name, or 'joint' for the aggregate strategy.</p>
</dd>
<dt>sim_date</dt><dd><p>Date of the exposure data.</p>
</dd>
<dt><em>category</em>_<em>level</em></dt><dd><p>Exposure to <em>level</em>
within <em>category</em>, for all levels of all category constraints, at the end
of the period.</p>
</dd>
<dt><em>factor</em></dt><dd><p>Exposure to <em>factor</em>, for all factor
constraints, at the end of the period.</p>
</dd>
</dl>



<hr>
<a id="method-getDelistings"></a>



<h4>Method <code>getDelistings()</code></h4>

<p>Get information on positions removed due to delisting.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getDelistings()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>data.frame</code> that contains a row for each
position that is removed from the simulation portfolio due to a
delisting. Each row contains the size of the position on the day on
which it was removed from the portfolio.
</p>


<hr>
<a id="method-getSingleStrategySummaryDf"></a>



<h4>Method <code>getSingleStrategySummaryDf()</code></h4>

<p>Get summary information for a single strategy suitable for
plotting input.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getSingleStrategySummaryDf(
  strategy_name = "joint",
  include_zero_row = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Strategy for which to return summary data.</p>
</dd>
<dt><code>include_zero_row</code></dt><dd><p>Logical flag indicatiing whether to prepend a row
to the summary data with starting values at zero. Defaults to <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame that contains summary information for the desired
strategy, as well as columns for cumulative net and gross total return,
calculated as pnl divided by ending gross market value.
</p>


<hr>
<a id="method-plotPerformance"></a>



<h4>Method <code>plotPerformance()</code></h4>

<p>Draw a plot of cumulative gross and net return by date.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotPerformance(strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotContribution"></a>



<h4>Method <code>plotContribution()</code></h4>

<p>Draw a plot of contribution to net return on GMV for levels
of a specified category.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotContribution(category_var, strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>category_var</code></dt><dd><p>Plot performance contribution for the levels of
<code>category_var</code>. <code>category_var</code> must be present in the
simulation's security reference, and detail data must be present in the
object's result data.</p>
</dd>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotMarketValue"></a>



<h4>Method <code>plotMarketValue()</code></h4>

<p>Draw a plot of total gross, long, short, and net market
value by date.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotMarketValue(strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotCategoryExposure"></a>



<h4>Method <code>plotCategoryExposure()</code></h4>

<p>Draw a plot of exposure to all levels in a category by date.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotCategoryExposure(in_var, strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>in_var</code></dt><dd><p>Category for which exposures are plotted. In order to plot
exposures for category <code>in_var</code>, we must have run the simulation
with <code>in_var</code> in the config setting
<code>simulator/calculate_exposures/category_vars</code>.</p>
</dd>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotFactorExposure"></a>



<h4>Method <code>plotFactorExposure()</code></h4>

<p>Draw a plot of exposure to factors by date.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotFactorExposure(in_var, strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>in_var</code></dt><dd><p>Factors for which exposures are plotted.</p>
</dd>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotNumPositions"></a>



<h4>Method <code>plotNumPositions()</code></h4>

<p>Draw a plot of number of long and short positions by date.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotNumPositions(strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotTurnover"></a>



<h4>Method <code>plotTurnover()</code></h4>

<p>Draw a plot of number of long and short positions by date.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotTurnover(strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotUniverseSize"></a>



<h4>Method <code>plotUniverseSize()</code></h4>

<p>Draw a plot of the universe size, or number of investable
stocks, over time.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotUniverseSize(strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>joint</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotNonInvestablePct"></a>



<h4>Method <code>plotNonInvestablePct()</code></h4>

<p>Draw a plot of the percentage of portfolio GMV held in
non-investable stocks (e.g., stocks that do not satisfy universe criteria)
for a given strategy. Note that this plot requires detail data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$plotNonInvestablePct(strategy_name = "joint")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy_name</code></dt><dd><p>Character vector of length 1 specifying the strategy
for the plot. Defaults to <code>"joint"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-overallStatsDf"></a>



<h4>Method <code>overallStatsDf()</code></h4>

<p>Calculate overall simulation summary statistics, such as
total P&amp;L, Sharpe, average market values and counts, etc.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$overallStatsDf()</pre></div>



<h5>Returns</h5>

<p>A data frame that contains summary statistics, suitable for
reporting.
</p>


<hr>
<a id="method-overallReturnsByMonthDf"></a>



<h4>Method <code>overallReturnsByMonthDf()</code></h4>

<p>Calculate return for each month and summary statistics for
each year, such as total return and annualized Sharpe. Return in data
frame format suitable for reporting.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$overallReturnsByMonthDf()</pre></div>



<h5>Returns</h5>

<p>The data frame contains one row for each calendar year in the
simulation, and up to seventeen columns: one column for year, one
column for each calendar month, and columns for the year's total
return, annualized return, annualized volatility, and annualized
Sharpe. Total return is the sum of daily net returns. Annualized return
is the mean net return times 252. Annualized volatility is the standard
deviation of net return times the square root of 252. Annualized Sharpe
is the ratio of annualized return to annualized volatility. All returns
are in percent.
</p>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print overall simulation statistics.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$print()</pre></div>


<hr>
<a id="method-writeFeather"></a>



<h4>Method <code>writeFeather()</code></h4>

<p>Write the data in the object to feather files.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$writeFeather(out_loc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>out_loc</code></dt><dd><p>Directory in which output files should be created.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-readFeather"></a>



<h4>Method <code>readFeather()</code></h4>

<p>Load files created with <code>writeFeather</code> into the object.
Note that because detail data is not re-split by period, it will not be
possible to use the <code>sim_date</code> parameter when calling
<code>getSimDetail</code> on the populated object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$readFeather(in_loc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>in_loc</code></dt><dd><p>Directory that contains files to be loaded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value, called for side effects.
</p>


<hr>
<a id="method-getConfig"></a>



<h4>Method <code>getConfig()</code></h4>

<p>Get the object's configuration information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$getConfig()</pre></div>



<h5>Returns</h5>

<p>Object of class <code>list</code> that contains the simulation's
configuration information.
</p>


<hr>
<a id="method-writeReport"></a>



<h4>Method <code>writeReport()</code></h4>

<p>Write an html document of simulation results.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$writeReport(
  out_dir,
  out_file,
  out_fmt = "html",
  contrib_vars = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>out_dir</code></dt><dd><p>Directory in which output files should be created</p>
</dd>
<dt><code>out_file</code></dt><dd><p>File name for output</p>
</dd>
<dt><code>out_fmt</code></dt><dd><p>Format in which output files should be created. The
default is html and that is currently the only option.</p>
</dd>
<dt><code>contrib_vars</code></dt><dd><p>Security reference variables for which to plot return
contribution.</p>
</dd>
<dt><code>res</code></dt><dd><p>The object of class 'Simulation' which we want to write the
report about.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='strand-package'>strand: a framework for investment strategy simulation</h2><span id='topic+strand-package'></span><span id='topic+strand'></span>

<h3>Description</h3>

<p>The strand package provides a framework for performing discrete (share-level)
simulations of investment strategies. Simulated portfolios optimize exposure
to an input signal subject to constraints such as position size and factor
exposure.
</p>
<p>For an introduction to running simulations using the package, see
<code>vignette("strand")</code>. For details on available methods see the
documentation for the <code><a href="#topic+Simulation">Simulation</a></code> class.
</p>


<h3>Author(s)</h3>

<p>Jeff Enos <a href="mailto:jeffrey.enos@gmail.com">jeffrey.enos@gmail.com</a> and David Kane <a href="mailto:dave.kane@gmail.com">dave.kane@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load up sample data
data(sample_secref)
data(sample_pricing)
data(sample_inputs)

# Load sample configuration
config &lt;- example_strategy_config()

# Override config file end date to run a one-week sim
config$to &lt;- as.Date("2020-06-05")

# Create the Simulation object and run
sim &lt;- Simulation$new(config,
                      raw_input_data = sample_inputs,
                      raw_pricing_data = sample_pricing,
                      security_reference_data = sample_secref)
sim$run()

# Print overall statistics
sim$overallStatsDf()

# Access tabular result data
head(sim$getSimSummary())
head(sim$getSimDetail())
head(sim$getPositionSummary())
head(sim$getInputStats())
head(sim$getOptimizationSummary())
head(sim$getExposures())

# Plot results
## Not run: 
sim$plotPerformance()
sim$plotMarketValue()
sim$plotCategoryExposure("sector") 
sim$plotFactorExposure(c("value", "size"))
sim$plotNumPositions()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
