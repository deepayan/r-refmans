<!DOCTYPE html><html><head><title>Help for package ccid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ccid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ccid'><p>ccid: a change-point detection method for estimating dynamic functional connectivity</p></a></li>
<li><a href='#detect.ic'><p>Multiple change-point detection in the cross-covariance structure of</p>
multivariate high-dimensional time series using a model selection
criterion optimisation</a></li>
<li><a href='#detect.th'><p>Multiple change-point detection in the cross-covariance structure</p>
of multivariate high-dimensional time series using a thresholding
based procedure and, wherever possible, extraction of the component
time series where the changes occurred</a></li>
<li><a href='#match.cpt.ts'><p>Associating the change-points with the component time series</p></a></li>
<li><a href='#preaverage'><p>Preaveraging the multivariate time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cross-Covariance Isolate Detect: a New Change-Point Method for
Estimating Dynamic Functional Connectivity</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>IDetect, hdbinseg, GeneNet, gdata</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides efficient implementation of the Cross-Covariance
    Isolate Detect (CCID) methodology for the estimation of the number
    and location of multiple change-points in the second-order
    (cross-covariance or network) structure of multivariate, possibly
    high-dimensional time series. The method is motivated by the detection
    of change points in functional connectivity networks for functional
    magnetic resonance imaging (fMRI), electroencephalography (EEG),
    magentoencephalography (MEG) and electrocorticography (ECoG) data. The
    main routines in the package have been extensively tested on fMRI data. 
    For details on the CCID methodology, please see Anastasiou et
    al (2022), Cross-covariance isolate detect: A new change-point method for
    estimating dynamic functional connectivity. Medical Image Analysis, Volume
    75.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Anastasiou-Andreas/ccid">https://github.com/Anastasiou-Andreas/ccid</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Anastasiou-Andreas/ccid/issues">https://github.com/Anastasiou-Andreas/ccid/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-01 10:24:25 UTC; ANASTAS7</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Anastasiou [aut, cre],
  Ivor Cribben [aut],
  Piotr Fryzlewicz [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Anastasiou &lt;anastasiou.andreas@ucy.ac.cy&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-01 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ccid'>ccid: a change-point detection method for estimating dynamic functional connectivity</h2><span id='topic+ccid'></span>

<h3>Description</h3>

<p>The <code>ccid</code> package implements the Cross-Covariance Isolate Detect
(CCID) methodology for the estimation of the number and location of
multiple change-points in the second-order (cross-covariance or network)
structure of multivariate, possibly high-dimensional time series. The
method is motivated by the detection of change points in functional
connectivity networks for functional magnetic resonance imaging (fMRI),
electroencephalography (EEG), magentoencephalography (MEG) and
electrocorticography (ECoG) data. The stopping rules used for the
change-point detection rely either on thresholding or on the optimization
of a model selection criterion. The main routines of the package are
<code><a href="#topic+detect.th">detect.th</a></code> and <code><a href="#topic+detect.ic">detect.ic</a></code>. The functions have been
extensively tested on fMRI data, therefore, their parameters have been
tuned to work well on this data and the functions might not work well
in other structures, such as time series that are negatively serially
correlated.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:anastasiou.andreas@ucy.ac.cy">anastasiou.andreas@ucy.ac.cy</a>, Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>, Ivor Cribben, <a href="mailto:cribben@ualberta.ca">cribben@ualberta.ca</a>
</p>


<h3>References</h3>

<p>&ldquo;Cross-covariance isolate detect: a new change-point method for estimating
dynamic functional connectivity&rdquo;, Anastasiou et al (2020), preprint.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+detect.th">detect.th</a></code> and <code><a href="#topic+detect.ic">detect.ic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See Examples for the function ``detect.th''.
</code></pre>

<hr>
<h2 id='detect.ic'>Multiple change-point detection in the cross-covariance structure of
multivariate high-dimensional time series using a model selection
criterion optimisation</h2><span id='topic+detect.ic'></span>

<h3>Description</h3>

<p>This function detects multiple change-points in the cross-covariance
structure of a multivariate time series using a model selection
criterion optimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.ic(
  X,
  approach = c("euclidean", "infinity"),
  th_max = 2.1,
  th_sum = 0.5,
  pointsgen = 10,
  scales = -1,
  alpha_gen = 0.1,
  preaverage_gen = FALSE,
  scal_gen = 3,
  min_dist = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect.ic_+3A_x">X</code></td>
<td>
<p>A numerical matrix representing the multivariate time series,
with the columns representing its components.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_approach">approach</code></td>
<td>
<p>A character string, which defines the metric to be used in
order to detect the change-points. If approach = &ldquo;euclidean&rdquo;, which is
also the default value, then the <code class="reqn">L_2</code> metric will be followed for
the detection. If approach = &ldquo;infinity&rdquo;, then the <code class="reqn">L_{\infty}</code>
metric will be used for the detection.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_th_max">th_max</code></td>
<td>
<p>A positive real number with default value equal to 2.1. It is
used to define the threshold for the change-point overestimation step if
the <code class="reqn">L_{\infty}</code> metric is chosen in <code>approach</code> .</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_th_sum">th_sum</code></td>
<td>
<p>A positive real number with default value equal to 0.5. It is
used to define the threshold for the change-point overestimation step if
the <code class="reqn">L_2</code> metric is chosen in <code>approach</code>.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_pointsgen">pointsgen</code></td>
<td>
<p>A positive integer with default value equal to 10. It
defines the distance between two consecutive end- or start-points of
the right- or left-expanding intervals, respectively; see Details
for more information.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_scales">scales</code></td>
<td>
<p>Negative integers for wavelet scales, with a small negative
integer representing a fine scale. The default value is equal to -1.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_alpha_gen">alpha_gen</code></td>
<td>
<p>A positive real number with default value equal to 0.1.
It is used to define how strict the user wants to be with the penalty
used.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_preaverage_gen">preaverage_gen</code></td>
<td>
<p>A logical variable with default value equal to
<code>FALSE</code>. If <code>FALSE</code>, then pre-averaging the data is not
required. If <code>TRUE</code>, then we need to pre-average the data before
proceeding with the detection of the change-points.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_scal_gen">scal_gen</code></td>
<td>
<p>A positive integer number with default value equal to 3.
It is used to define the way we pre-average the given data sequence
only if <code>preaverage_gen = TRUE</code>. See the Details in
<code><a href="#topic+preaverage">preaverage</a></code> for more information on how we pre-average.</p>
</td></tr>
<tr><td><code id="detect.ic_+3A_min_dist">min_dist</code></td>
<td>
<p>A positive integer number with default value equal to 1. It
is used in order to provide the minimum distance acceptable between
detected change-points if such restrictions apply.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time series <code class="reqn">X_t</code> is of dimensionality <code class="reqn">p</code> and we are
looking for changes in the cross-covariance structure between the
different time series components
<code class="reqn">X_{t}^{(1)}, X_{t}^{(2)}, ..., X_{t}^{(p)}</code>. We first use a
wavelet-based approach for the various given scales in <code>scales</code> in
order to transform the given time series <code class="reqn">X_t</code> to a multiplicative
model <code class="reqn">Y_{t}^{(k)} = \sigma^{(k)}_t (Z_t^{(k)})^2; t=1,2,\ldots,T; k = 1,2,\ldots,d,</code>
where <code class="reqn">Z_t^{(k)}</code> is a sequence of standard normal random variables,
<code class="reqn">E(Y_t^{(k)}) = \sigma_t^{(k)}</code>, and <code class="reqn">d</code> is the new
dimensionality, which depends on the value given in <code>scales</code>.
The function has been extensively tested on fMRI data, hence, its parameters
have been tuned for this data type. The function might not work well in other
structures, such as time series that are negatively serially correlated.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>changepoints</code> </td><td style="text-align: left;"> The locations of the detected change-points.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no.of.cpts</code> </td><td style="text-align: left;"> The number of the detected change-points.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>sol_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>ic_curve</code>   </td><td style="text-align: left;"> A vector with values of the information criterion for
   different number of change-points.
 </td>
</tr>

</table>

<p>If the minimum distance between the detected change-points is less than
the value given in <code>min_dist</code>, then only the number and the locations of the
&ldquo;pruned&rdquo; change-points are returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:anastasiou.andreas@ucy.ac.cy">anastasiou.andreas@ucy.ac.cy</a>
</p>


<h3>References</h3>

<p>&ldquo;Cross-covariance isolate detect: a new change-point method
for estimating dynamic functional connectivity&rdquo;, Anastasiou et al (2020),
preprint &lt;doi:10.1101/2020.12.20.423696&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+detect.th">detect.th</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(11)
  A &lt;- matrix(rnorm(10*200), nrow = 200) ## No change-point
  M1 &lt;- detect.ic(A, approach = 'euclidean', scales = -1)
  M2 &lt;- detect.ic(A, approach = 'infinity', scales = -1)
  M1$changepoints
  M2$changepoints

  set.seed(1)
  num.nodes &lt;- 30 # number of nodes
  etaA.1    &lt;- 0.95
  etaA.2    &lt;- 0.05
  pcor1     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.1)
  pcor2     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.2)

  n &lt;- 50
  data1 &lt;- GeneNet::ggm.simulate.data(n, pcor1)
  data2 &lt;- GeneNet::ggm.simulate.data(n, pcor2)
  X1 &lt;- rbind(data1, data2, data1, data2) ## change-points at 50, 100, 150
  N1 &lt;- detect.ic(X1, approach = 'euclidean', scales = -1)
  N2 &lt;- detect.ic(X1, approach = 'infinity', scales = -1)
  N1$changepoints
  N2$changepoints
  N1$no.of.cpts
  N2$no.of.cpts
  N1$sol_path
  N2$sol_path
</code></pre>

<hr>
<h2 id='detect.th'>Multiple change-point detection in the cross-covariance structure
of multivariate high-dimensional time series using a thresholding
based procedure and, wherever possible, extraction of the component
time series where the changes occurred</h2><span id='topic+detect.th'></span>

<h3>Description</h3>

<p>This function detects multiple change-points in the cross-covariance
structure of a multivariate time series using a thresholding based procedure.
It also, wherever possible, returns the relevant, transformed
time series where each change-point was detected. See Details for a brief
explanation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.th(
  X,
  approach = c("euclidean", "infinity"),
  th_max = 2.25,
  th_sum = 0.65,
  pointsgen = 10,
  scales = -1,
  preaverage_gen = FALSE,
  scal_gen = 3,
  min_dist = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect.th_+3A_x">X</code></td>
<td>
<p>A numerical matrix representing the multivariate time series,
with the columns representing its components.</p>
</td></tr>
<tr><td><code id="detect.th_+3A_approach">approach</code></td>
<td>
<p>A character string, which defines the metric to be used
in order to detect the change-points. If approach = &ldquo;euclidean&rdquo;, which
is also the default value, then the <code class="reqn">L_2</code> metric will be followed
for the detection. If approach = &ldquo;infinity&rdquo;, then the <code class="reqn">L_{\infty}</code>
metric will be used for the detection.</p>
</td></tr>
<tr><td><code id="detect.th_+3A_th_max">th_max</code></td>
<td>
<p>A positive real number with default value equal to 2.25. It is
used to define the threshold if the <code class="reqn">L_{\infty}</code> metric is chosen in
<code>approach</code> .</p>
</td></tr>
<tr><td><code id="detect.th_+3A_th_sum">th_sum</code></td>
<td>
<p>A positive real number with default value equal to 0.65. It is
used to define the threshold if the <code class="reqn">L_2</code> metric is chosen in
<code>approach</code>.</p>
</td></tr>
<tr><td><code id="detect.th_+3A_pointsgen">pointsgen</code></td>
<td>
<p>A positive integer with default value equal to 10. It
defines the distance between two consecutive end- or start-points of
the right- or left-expanding intervals, respectively; see Details for
more information.</p>
</td></tr>
<tr><td><code id="detect.th_+3A_scales">scales</code></td>
<td>
<p>Negative integers for wavelet scales, with a small negative
integer representing  a fine scale. The default value is equal to -1.</p>
</td></tr>
<tr><td><code id="detect.th_+3A_preaverage_gen">preaverage_gen</code></td>
<td>
<p>A logical variable with default value equal to
<code>FALSE</code>. If <code>FALSE</code>, then pre-averaging the data is not
required. If <code>TRUE</code>, then we need to pre-average the data before
proceeding with the detection of the change-points.</p>
</td></tr>
<tr><td><code id="detect.th_+3A_scal_gen">scal_gen</code></td>
<td>
<p>A positive integer number with default value equal to 3. It
is used to define the way we pre-average the given data sequence only if
<code>preaverage_gen = TRUE</code>. See the Details in <code><a href="#topic+preaverage">preaverage</a></code>
for more information on how we pre-average.</p>
</td></tr>
<tr><td><code id="detect.th_+3A_min_dist">min_dist</code></td>
<td>
<p>A positive integer number with default value equal to 1. It
is used in order to provide the minimum distance acceptable between
detected change-points if such restrictions apply.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time series <code class="reqn">X_t</code> is of dimensionality <code class="reqn">p</code> and we are
looking for changes in the cross-covariance structure between the
different time series components
<code class="reqn">X_{t}^{(1)}, X_{t}^{(2)}, ..., X_{t}^{(p)}</code>. We first use a
wavelet-based approach for the various given scales in <code>scales</code>
in order to transform the given time series <code class="reqn">X_t</code> to a multiplicative
model <code class="reqn">Y_{t}^{(k)} = \sigma^{(k)}_t (Z_t^{(k)})^2; t=1,2,\ldots,T; k = 1,2,\ldots,d,</code>
where <code class="reqn">Z_t^{(k)}</code> is a sequence of standard normal random variables,
<code class="reqn">E(Y_t^{(k)}) = \sigma_t^{(k)}</code>, and <code class="reqn">d</code> is the new
dimensionality, which depends on the value given in <code>scales</code>.
The function has been extensively tested on fMRI data, hence, its parameters
have been tuned for this data type. The function might not work well in other
structures, such as time series that are negatively serially correlated.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>changepoints</code> </td><td style="text-align: left;"> The locations of the detected change-points.
</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no.of.cpts</code> </td><td style="text-align: left;"> The number of the detected change-points.
</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>time_series</code> </td><td style="text-align: left;"> A list with two components that indicates which combinations
</td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> of time series are responsible for each change-point detected. See the outcome
</td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> values <code>time_series_indicator</code> and <code>most_important</code> of the function
</td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> <code><a href="#topic+match.cpt.ts">match.cpt.ts</a></code> for more information.
   </td>
</tr>

</table>

<p>If the minimum distance between the detected change-points is less than
the value given in <code>min_dist</code>, then only the number and the locations of
the &ldquo;pruned&rdquo; change-points are returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:anastasiou.andreas@ucy.ac.cy">anastasiou.andreas@ucy.ac.cy</a>
</p>


<h3>References</h3>

<p>&ldquo;Cross-covariance isolate detect: a new change-point method
for estimating dynamic functional connectivity&rdquo;, Anastasiou et al (2020),
preprint &lt;doi:10.1101/2020.12.20.423696&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+detect.ic">detect.ic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(111)
  A &lt;- matrix(rnorm(20*400), nrow = 400) ## No change-point
  M1 &lt;- detect.th(A, approach = 'euclidean', scales = -1)
  M2 &lt;- detect.th(A, approach = 'infinity', scales = -1)
  M1
  M2

  set.seed(111)
  num.nodes &lt;- 40 # number of nodes
  etaA.1    &lt;- 0.95
  etaA.2    &lt;- 0.05
  pcor1     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.1)
  pcor2     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.2)

  n &lt;- 100
  data1 &lt;- GeneNet::ggm.simulate.data(n, pcor1)
  data2 &lt;- GeneNet::ggm.simulate.data(n, pcor2)

  X1 &lt;- rbind(data1, data2) ## change-point at 100
  N1 &lt;- detect.th(X1, approach = 'euclidean', scales = -1)
  N2 &lt;- detect.th(X1, approach = 'infinity', scales = -1)
  N1$changepoints
  N1$time_series
  N2$changepoints
  N2$time_series
</code></pre>

<hr>
<h2 id='match.cpt.ts'>Associating the change-points with the component time series</h2><span id='topic+match.cpt.ts'></span>

<h3>Description</h3>

<p>This function performs a contrast function based approach in order to
match each change-point and time series. In simple terms, for a given
change-point set this function associates each change-point with the
respective data sequence (or sequences) from which it was detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.cpt.ts(
  X,
  cpt,
  thr_const = 1,
  thr_fin = thr_const * sqrt(2 * log(nrow(X))),
  scales = -1,
  count = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.cpt.ts_+3A_x">X</code></td>
<td>
<p>A numerical matrix representing the multivariate periodograms.
Each column contains a different periodogram which is the result of
applying the wavelet transformation to the initial multivariate time
series.</p>
</td></tr>
<tr><td><code id="match.cpt.ts_+3A_cpt">cpt</code></td>
<td>
<p>A positive integer vector with the locations of the
change-points. If missing, then our approach with the <code class="reqn">L_2</code>
aggregation is called internally to extract the change-points in
<code>X</code>.</p>
</td></tr>
<tr><td><code id="match.cpt.ts_+3A_thr_const">thr_const</code></td>
<td>
<p>A positive real number with default value equal to 1. It is
used to define the threshold; see <code>thr_fin</code>.</p>
</td></tr>
<tr><td><code id="match.cpt.ts_+3A_thr_fin">thr_fin</code></td>
<td>
<p>With <code>T</code> the length of the data sequence, this is a
positive real number with default value equal to
<code>thr_const * log(T)</code>. It is the threshold, which is used in the
detection process.</p>
</td></tr>
<tr><td><code id="match.cpt.ts_+3A_scales">scales</code></td>
<td>
<p>Negative integers for the wavelet scales used to create the periodograms,
with a small negative integer representing a fine scale. The default value is equal
to -1.</p>
</td></tr>
<tr><td><code id="match.cpt.ts_+3A_count">count</code></td>
<td>
<p>Positive integer with default value equal to 5. It can be used
so that the function will return only the <code>count</code> most important
matches of each change-points with the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>time_series_indicator</code> </td><td style="text-align: left;"> A list of matrices. There are as many matrices as
   </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> the number of change-points. Each change-point has its own matrix, with
   </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> each row of the matrix representing the associated combination of time
   </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> series that are associated with the respective change-point.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>most_important</code> </td><td style="text-align: left;"> A list of matrices. There are as many matrices as
   </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> the number of change-points. Each change-point has its own matrix, with
   </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> each row of the matrix representing the associated combination of time
   </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> series that are associated with the respective change-point. It shows the
   </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> <code>count</code> most important time series combinations for each change-point.
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:anastasiou.andreas@ucy.ac.cy">anastasiou.andreas@ucy.ac.cy</a>
</p>


<h3>References</h3>

<p>&ldquo;Cross-covariance isolate detect: a new change-point method
for estimating dynamic functional connectivity&rdquo;, Anastasiou et al (2020),
preprint &lt;doi:10.1101/2020.12.20.423696&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1)
  num.nodes &lt;- 40 # number of nodes
  etaA.1    &lt;- 0.95
  etaA.2    &lt;- 0.05
  pcor1     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.1)
  pcor2     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.2)

  n &lt;- 100
  data1 &lt;- GeneNet::ggm.simulate.data(n, pcor1)
  data2 &lt;- GeneNet::ggm.simulate.data(n, pcor2)
  X &lt;- rbind(data1, data2, data1, data2) ## change-points at 100, 200, 300
  sgn &lt;- sign(stats::cor(X))
  M1 &lt;- match.cpt.ts(t(hdbinseg::gen.input(x = t(X),scales = -1, sq = TRUE,
  diag = FALSE, sgn = sgn)))
  M1
</code></pre>

<hr>
<h2 id='preaverage'>Preaveraging the multivariate time series</h2><span id='topic+preaverage'></span>

<h3>Description</h3>

<p>This function pre-processes the given data in order to remove serial
correlation that might exist in the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preaverage(X, scal = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preaverage_+3A_x">X</code></td>
<td>
<p>A numerical matrix representing the multivariate time series,
with the columns representing its components.</p>
</td></tr>
<tr><td><code id="preaverage_+3A_scal">scal</code></td>
<td>
<p>A positive integer number with default value equal to 3. It is
used to define the way we pre-average the data sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given natural number <code>scal</code> and data matrix <code>X</code> of
dimensionality <code class="reqn">T \times d</code>, let us denote by
<code class="reqn">Q = \lceil T/scal \rceil</code>. Then, <code><a href="#topic+preaverage">preaverage</a></code> calculates,
for all <code class="reqn">j = 1,2, ..., d</code>,
</p>
<p style="text-align: center;"><code class="reqn">\tilde{X}_{q, j} = 1/scal\sum_{t=(q-1) * sc + 1}^{q * sc}X_{t, j},</code>
</p>

<p>for <code class="reqn">q=1, 2, ..., Q-1</code>, while
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{Q, j} = (T - (Q-1) * sc)^{-1}\sum_{t = (Q-1) * sc + 1}^{T}X_{t, j}.</code>
</p>



<h3>Value</h3>

<p>The &ldquo;preaveraged&rdquo; matrix <code class="reqn">\tilde{X}</code> of dimensionality
<code class="reqn">Q \times d</code>, as explained in Details.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:anastasiou.andreas@ucy.ac.cy">anastasiou.andreas@ucy.ac.cy</a>
</p>


<h3>References</h3>

<p>&ldquo;Cross-covariance isolate detect: a new change-point method
for estimating dynamic functional connectivity&rdquo;, Anastasiou et al (2020),
preprint &lt;doi:10.1101/2020.12.20.423696&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(1:32, 8, 4)
A
A1 &lt;- preaverage(A, scal = 3)
A1
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
