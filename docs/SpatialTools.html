<!DOCTYPE html><html><head><title>Help for package SpatialTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coincident'><p>Determine coincident coordinates</p></a></li>
<li><a href='#cov.sp'>
<p>Calculates spatial covariance</p></a></li>
<li><a href='#cov.st'>
<p>Calculates spatio-temporal covariance</p></a></li>
<li><a href='#decomp.cov'>
<p>Calculates decomposition of covariance matrix</p></a></li>
<li><a href='#dist1'><p>Calculate Euclidean distance matrix for a matrix of coordinates</p></a></li>
<li><a href='#dist2'><p>Calculate Euclidean distance matrix between coordinates of two matrices</p></a></li>
<li><a href='#get.contours'>
<p>Extracts coordinates from contourLines function</p></a></li>
<li><a href='#krige.ok'>
<p>Performs Ordinary Kriging</p></a></li>
<li><a href='#krige.sk'>
<p>Performs simple kriging</p></a></li>
<li><a href='#krige.uk'>
<p>Performs universal kriging</p></a></li>
<li><a href='#maxlik.cov.sp'>
<p>Determines maximum likelihood estimates of covariance parameters</p></a></li>
<li><a href='#maxlik.cov.st'>
<p>Determines maximum likelihood estimates of covariance parameters</p></a></li>
<li><a href='#plot.contourLines'>
<p>Plot contour lines</p></a></li>
<li><a href='#rcondnorm'>
<p>Generate from conditional normal distribution</p></a></li>
<li><a href='#rmvnorm'>
<p>Generates realizations from a multivariate normal distribution</p></a></li>
<li><a href='#simple.cov.sp'>
<p>Calculates spatial covariance based on distance matrix</p></a></li>
<li><a href='#simple.cov.time'>
<p>Calculates temporal covariance based on distance matrix</p></a></li>
<li><a href='#spLMPredictJoint'>
<p>Returns posterior predictive sample from spLM object</p></a></li>
<li><a href='#toydata'>
<p>A toy data set for use in examples.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Spatial Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua French &lt;joshua.french@ucdenver.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua French &lt;joshua.french@ucdenver.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spBayes (&ge; 0.3.0), Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.9.10), RcppArmadillo (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for spatial data analysis.  Emphasis on kriging.  Provides functions for prediction and simulation.  Intended to be relatively straightforward, fast, and flexible.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-18 17:26:37 UTC; frencjos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-18 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coincident'>Determine coincident coordinates</h2><span id='topic+coincident'></span>

<h3>Description</h3>

<p><code>coincident</code> takes the coordinate matrices
<code>coords1</code> and <code>coords2</code> and returns the indices
of the coincident coordinates of the two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coincident(coords1, coords2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coincident_+3A_coords1">coords1</code></td>
<td>
<p>An <code class="reqn">n1 \times 2</code> numeric matrix of
coordinates.</p>
</td></tr>
<tr><td><code id="coincident_+3A_coords2">coords2</code></td>
<td>
<p>An <code class="reqn">n2 \times 2</code> numeric matrix of
coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls a compiled <code>C++</code> program created
using the Rcpp package. This (may) result in a significant
speedup over pure R code since the search algorithm
involves loops. We assume that there are no duplicate
coordinates in <code>coords1</code> and <code>coords2</code>,
respectively. In other words, each row of <code>coords1</code> is
unique and each row of <code>coords2</code> is unique. There is
at most 1 row of <code>coords1</code> that will match with a row
in <code>coords2</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix with the indices of the coincident
locations. Specifically, an <code class="reqn">r \times 2</code> matrix will be
returned, with <code class="reqn">r</code> being the number of coordinates in
<code>coords1</code> coinciding with coordinates in
<code>coords2</code>. If row <code>i</code> of the matrix is c(2, 5),
then the <code>i</code>th set of coincident locations is between
the 2nd row of <code>coords1</code> and the 5th row of
<code>coords2</code>. If there are no coincident locations, then
a matrix of size <code class="reqn">0 \times 2</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate two sets of coordinates
loc1 &lt;- as.matrix(expand.grid(seq(0, 1, len = 25), seq(0, 1, len = 25)))
loc2 &lt;- as.matrix(expand.grid(seq(0, 1, len = 101), seq(0, 1, len = 101)))
coincident(loc1, loc2)
</code></pre>

<hr>
<h2 id='cov.sp'>
Calculates spatial covariance
</h2><span id='topic+cov.sp'></span>

<h3>Description</h3>

<p>Calculates spatial covariance matrix of the observed responses, and 
possibly, the responses to be predicted.  
If <code>pcoords</code> is not provided, then only <code>V</code>, 
the covariance matrix of the observed responses will be returned.  
If <code>pcoords</code> is provided, then <code>Vp</code> and <code>Vop</code> 
(the covariance matrix for predicted responses and between observed and 
predicted responses, respectively) will also be returned.	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	cov.sp(coords, sp.type = "exponential", 
		sp.par = stop("specify sp.par argument"), 
		error.var = 0, smoothness = 0.5, finescale.var = 0, 
		pcoords = NULL, D = NULL, Dp = NULL, Dop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.sp_+3A_coords">coords</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times d</code> containing the observed data locations.</p>
</td></tr> 
<tr><td><code id="cov.sp_+3A_sp.type">sp.type</code></td>
<td>
<p>A character vector specifying the spatial covariance type.  Valid types are currently exponential, gaussian, matern, matern2, and spherical.</p>
</td></tr> 
<tr><td><code id="cov.sp_+3A_sp.par">sp.par</code></td>
<td>
<p>A vector of length 2 specifying the scale and strength of dependence of the covariance function.  The first element is the variance of the underlying spatial process (also known as the hidden or latent spatial process).  This value is also called the partial sill.   The second element is the strength of dependence between responses.</p>
</td></tr>
<tr><td><code id="cov.sp_+3A_error.var">error.var</code></td>
<td>
<p>A non-negative number indicating the variance of the error term.</p>
</td></tr> 
<tr><td><code id="cov.sp_+3A_smoothness">smoothness</code></td>
<td>
<p>A positive number indicating the variance of the error term.</p>
</td></tr> 
<tr><td><code id="cov.sp_+3A_finescale.var">finescale.var</code></td>
<td>
<p>A non-negative positive number indicating the finescale variability.  The is also called the microscale variance</p>
</td></tr> 
<tr><td><code id="cov.sp_+3A_pcoords">pcoords</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">np \times d</code> containing the locations of the responses to be predicted.</p>
</td></tr> 
<tr><td><code id="cov.sp_+3A_d">D</code></td>
<td>
<p>The Euclidean distance matrix for the <code>coords</code> matrix.  Must be of size <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code id="cov.sp_+3A_dp">Dp</code></td>
<td>
<p>The Eucliean distance matrix for the <code>pcoords</code> matrix.  Must be of size <code class="reqn">np \times np</code>.</p>
</td></tr>
<tr><td><code id="cov.sp_+3A_dop">Dop</code></td>
<td>
<p>The Euclidean intersite distance matrix between the locations in <code>coords</code> and the locations in <code>pcoords</code>.  Must be of size <code class="reqn">n \times np</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial covariance functions are parameterized in a manner 
consistent with the <code>cov.spatial</code> function in the 
<code>geoR</code> package.  The <code>matern2</code> covariance function is an alternative covariance function suggested by Handcock and Wallis (1994).  
The benefit of this parameterization is that the range parameter is that it allows the effective range to be less dependent on the smoothness parameter.
</p>
<p>The <code>D</code>, <code>Dp</code>, and <code>Dop</code> arguments are supplied to decrease the number of necessary computations needed when performing repetitive analysis or simulations.  It is probably in the user's interest to not supply these arguments unless the duration of analysis is an important consideration.  Note that these arguments override the information given in <code>coords</code> and <code>pcoords</code>, i.e., if dist1(coords) != D, then D is used in subsequent calculations, etc.  This could create problems.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>
<table>
<tr><td><code>V</code></td>
<td>
<p> The covariance matrix for the observed responses.   Will be of size <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code>Vp</code></td>
<td>
<p> The covariance matrix for the predicted responses.  Only returned if <code>pcoords</code> is supplied.  Will be of size <code class="reqn">np \times np</code>.</p>
</td></tr>
<tr><td><code>Vp</code></td>
<td>
<p> The covariance matrix between the observed responses and the predicted responses.  Only returned if <code>pcoords</code> is supplied.  Will be of size <code class="reqn">n \times np</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>References</h3>

<p> M.S. Handcock, J.R. Wallis.  An approach to statistical spatial-temporal modeling of meteorological fields (with discussion).  
Journal of the American Statistical Association, 89 (1994), pp. 368&ndash;390. </p>


<h3>See Also</h3>

<p><code>simple.cov.sp</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    coords &lt;- matrix(rnorm(30), ncol = 3)
    cov.sp(coords = coords, sp.type = "exponential", sp.par = c(2, 1),
        error.var = 1)
</code></pre>

<hr>
<h2 id='cov.st'>
Calculates spatio-temporal covariance
</h2><span id='topic+cov.st'></span>

<h3>Description</h3>

<p>Calculates spatial covariance matrix of the observed responses, and 
possibly, the responses to be predicted.  
If <code>pcoords</code> is not provided, then only <code>V</code>, 
the covariance matrix of the observed responses will be returned.  
If <code>pcoords</code> is provided, then <code>Vp</code> and <code>Vop</code> 
(the covariance matrix for predicted responses and between observed and 
predicted responses, respectively) will also be returned.	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	cov.st(coords, time, sp.type = "exponential", 
	    sp.par = stop("specify sp.par argument"),
 	    error.var = 0, smoothness = 0.5, finescale.var = 0, 
	    t.type = "ar1", t.par = .5, 
	    pcoords = NULL, ptime = NULL, 
	    D = NULL, Dp = NULL, Dop = NULL, 
	    T = NULL, Tp = NULL, Top = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.st_+3A_coords">coords</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times d</code> containing the observed data locations.</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_time">time</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times 1</code> containing the times at which the data was observed.</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_sp.type">sp.type</code></td>
<td>
<p>A character vector specifying the spatial covariance type.  Valid types are currently exponential, gaussian, matern, and spherical.</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_sp.par">sp.par</code></td>
<td>
<p>A vector of length 2 specifying the scale and dependence of the covariance function.  The first element refers to the variance of the hidden process (sometimes this is called the partial sill) while the second elements determines the strength of dependence between locations.</p>
</td></tr>
<tr><td><code id="cov.st_+3A_error.var">error.var</code></td>
<td>
<p>A non-negative number indicating the variance of the error term.</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_smoothness">smoothness</code></td>
<td>
<p>A positive number indicating the variance of the error term.</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_finescale.var">finescale.var</code></td>
<td>
<p>A non-negative positive number indicating the finescale variability.  The is also called the microscale variance</p>
</td></tr>
<tr><td><code id="cov.st_+3A_t.type">t.type</code></td>
<td>
<p>A character vector indicating the temporal dependance structure.  Currently, only &quot;ar1&quot; is implemented.</p>
</td></tr>
<tr><td><code id="cov.st_+3A_t.par">t.par</code></td>
<td>
<p>A numeric vector of length 1 indicating the strength of temporal dependence.</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_pcoords">pcoords</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">np \times d</code> containing the locations of the responses to be predicted</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_ptime">ptime</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">np \times 1</code> containing the times at which the responses are to be predicted.</p>
</td></tr> 
<tr><td><code id="cov.st_+3A_d">D</code></td>
<td>
<p>The Euclidean distance matrix for the coords matrix.  Must be of size <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code id="cov.st_+3A_dp">Dp</code></td>
<td>
<p>The Eucliean distance matrix for the pcoords matrix.  Must be of size <code class="reqn">np \times np</code>.</p>
</td></tr>
<tr><td><code id="cov.st_+3A_dop">Dop</code></td>
<td>
<p>The Eucliean intersite distance matrix between the locations in coords and the locations in pcoords.  Must be of size <code class="reqn">n \times np</code>.</p>
</td></tr>
<tr><td><code id="cov.st_+3A_t">T</code></td>
<td>
<p>The Euclidean distance matrix for the time matrix.  Must be of size <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code id="cov.st_+3A_tp">Tp</code></td>
<td>
<p>The Eucliean distance matrix for the ptime matrix.  Must be of size <code class="reqn">np \times np</code>.</p>
</td></tr>
<tr><td><code id="cov.st_+3A_top">Top</code></td>
<td>
<p>The Eucliean intertime distance matrix between the times in <code>time</code> and <code>ptime</code>.  Must be of size <code class="reqn">n \times np</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At this point, this function only implements a separable spatio-temporal covariance funcation.  If <code class="reqn">h</code> is the distance between
two sites, and <code class="reqn">t</code> is the temporal lag between the times when the associated responses were observed, then the covariance function
<code class="reqn">C(h,t) = Cs(h) \times Ct(t)</code> where <code class="reqn">Cs</code> is a spatial covariance function corresponding to the 
exponential, matern, gaussian, or spherical and <code class="reqn">Ct</code> is the temporal covariance function corresponding to an ar1 process with 
<code class="reqn">Ct(t) = \phi ^ t</code>.
</p>
<p>The <code>D</code>, <code>Dp</code>, <code>Dop</code>, <code>T</code>, <code>Tp</code>, <code>Top</code> arguments are supplied to decrease the number of necessary computations needed when performing repetitive analysis or simulations.  It is probably in the user's interest to not supply these arguments unless the duration of analysis is an important consideration.  Note that these arguments override the information given in <code>coords</code>, <code>pcoords</code>, <code>time</code>, and <code>prime</code>, i.e., if dist1(coords) != D, then D is used in subsequent calculations, etc.  This could create problems.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>
<table>
<tr><td><code>V</code></td>
<td>
<p> The covariance matrix for the observed responses. </p>
</td></tr>
<tr><td><code>Vp</code></td>
<td>
<p> The covariance matrix for the predicted responses.  Only returned if <code>pcoords</code> is supplied.</p>
</td></tr>
<tr><td><code>Vp</code></td>
<td>
<p> The covariance matrix between the observed responses and the predicted responses.  Only returned if <code>pcoords</code> is supplied.  Will be of size <code class="reqn">n \times np</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p><code>simple.cov.sp</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>	coords &lt;- matrix(rnorm(30), ncol = 3)
	pcoords &lt;- matrix(rnorm(90), ncol = 3)
	time &lt;- 1:10
	ptime &lt;- 1:30
	cov.st(coords = coords, time = time, sp.type = "exponential", 
	    sp.par = c(2, 1), error.var = 1, t.type = "ar1", t.par = .5, 
	    pcoords = pcoords, ptime = ptime)
</code></pre>

<hr>
<h2 id='decomp.cov'>
Calculates decomposition of covariance matrix
</h2><span id='topic+decomp.cov'></span>

<h3>Description</h3>

<p>Calculates a decomposition of the provided covariance matrix, <code>V</code>, using the chosen method.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	decomp.cov(V, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp.cov_+3A_v">V</code></td>
<td>
<p>A (symmetric, positive-definite) covariance matrix.</p>
</td></tr> 
<tr><td><code id="decomp.cov_+3A_method">method</code></td>
<td>
<p>A character vector specifying the method used to decompose <code>V</code>.  Options are &quot;eigen&quot;, &quot;chol&quot;, or &quot;svd&quot; (Eigen decomposition, Cholesky decomposition, or Singular value decomposition, respectively).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p> The matrix <code>V</code> is assumed to be symmetric and positive definite.  Symmetry is checked, but the positive definiteness of the matrix is not.  Returns a decomposition matrix <code>U</code> such that <code>V</code> = <code>U</code> %*% <code>t(U)</code>.
</p>


<h3>Value</h3>

<p>Returns a decomposition matrix <code>U</code> such that <code>V</code> = <code>U</code> %*% <code>t(U)</code>. 
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p><code>cov.sp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(toydata)
	U &lt;- decomp.cov(toydata$V, method = "chol")
	#range(toydata$V - U %*% t(U))
</code></pre>

<hr>
<h2 id='dist1'>Calculate Euclidean distance matrix for a matrix of coordinates</h2><span id='topic+dist1'></span>

<h3>Description</h3>

<p><code>dist1</code> takes a matrix of coordinates and returns the
Euclidean distance matrix of the coordinates.  It does this
using a compiled <code>C</code> program, so it is faster than the
builtin R <code>dist</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist1(coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist1_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">nr \times nc</code> numeric matrix of
coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">nr \times nr</code> matrix of Euclidean distances.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+dist">dist</a>, <a href="#topic+dist2">dist2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(30), ncol = 3)
dist1(x)
</code></pre>

<hr>
<h2 id='dist2'>Calculate Euclidean distance matrix between coordinates of two matrices</h2><span id='topic+dist2'></span>

<h3>Description</h3>

<p><code>dist2</code> takes the matrices of coordinates
<code>coords1</code> and <code>coords2</code> and returns the
inter-Euclidean distances between coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2(coords1, coords2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist2_+3A_coords1">coords1</code></td>
<td>
<p>An <code class="reqn">nr1 \times nc1</code> numeric matrix of
coordinates.</p>
</td></tr>
<tr><td><code id="dist2_+3A_coords2">coords2</code></td>
<td>
<p>An <code class="reqn">nr2 \times nc2</code> numeric matrix of
coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">nr1 \times nr2</code> matrix of Euclidean distances.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p>dist, dist1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(rnorm(30), ncol = 3)
x2 &lt;- matrix(rnorm(60), ncol = 3)
dist2(x1, x2)
</code></pre>

<hr>
<h2 id='get.contours'>
Extracts coordinates from contourLines function
</h2><span id='topic+get.contours'></span>

<h3>Description</h3>

<p>Takes contours of <code>contourLines</code> function and extracts the associated coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	get.contours(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.contours_+3A_x">x</code></td>
<td>
<p>A list returned by the <code>contourLines</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a 2-column matrix containing the coordinates making up the contours in contours.list.
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p>contourLines, contour</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volcano)
x &lt;- 10*1:nrow(volcano)
y &lt;- 10*1:ncol(volcano)
cL &lt;- contourLines(x, y, volcano)
out &lt;- get.contours(cL)
</code></pre>

<hr>
<h2 id='krige.ok'>
Performs Ordinary Kriging
</h2><span id='topic+krige.ok'></span>

<h3>Description</h3>

<p>Performs Ordinary Kriging using <code>y</code>, the <code class="reqn">n \times 1</code> matrix of observed responses,
<code>V</code>, the (positive definite) covariance matrix of the 
observed responses, <code>Vp</code>, the 
<code class="reqn">np \times np</code>
covariance matrix of the responses to be predicted, and <code>Vop</code>, 
the <code class="reqn">n \times np</code> matrix of covariances between the observed 
responses and the responses to be predicted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	krige.ok(y, V, Vp, Vop, nsim = 0, Ve.diag = NULL, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige.ok_+3A_y">y</code></td>
<td>
<p>The vector of observed responses.
Should be a matrix of size <code class="reqn">n \times 1</code> or a vector of 
length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="krige.ok_+3A_v">V</code></td>
<td>
<p>The covariance matrix of the observed responses.  
The size is <code class="reqn">n \times n</code>.</p>
</td></tr> 
<tr><td><code id="krige.ok_+3A_vp">Vp</code></td>
<td>
<p>The covariance matrix of the responses to be predicted.
The size is <code class="reqn">np \times np</code>.</p>
</td></tr> 
<tr><td><code id="krige.ok_+3A_vop">Vop</code></td>
<td>
<p>The cross-covariance between the observed responses 
and the responses to be predicted.  The size is 
<code class="reqn">n \times np</code></p>
</td></tr> 
<tr><td><code id="krige.ok_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulated data sets to sample from the conditional predictive distribution.</p>
</td></tr>
<tr><td><code id="krige.ok_+3A_ve.diag">Ve.diag</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> specifying the measure error variances of the observed data.  Only needed if <code>nsim</code> &gt; 0.</p>
</td></tr>
<tr><td><code id="krige.ok_+3A_method">method</code></td>
<td>
<p>The method for decomposing <code>V</code> in conditional simulation.  Default is &quot;eigen&quot;, for the Eigen decomposition.  Alternatives are &quot;chol&quot; (Cholesky) and &quot;svd&quot; (Singular Value Decomposition).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that there are <code class="reqn">n</code> observed data values
and that we wish to make predictions at <code class="reqn">np</code> locations.
</p>
<p>If doing conditional simulation, the Cholesky decomposition should not work when there are coincident locations between the observed data locations and the predicted data locations.    Both the Eigen and Singular Value Decompositions should work.
</p>
<p>If user specifies <code>nsim</code> to be a positive integer, then <code>nsim</code> conditional realizations of the predictive distribution will be generated.  If this is less than 1, then no conditional simulation is done.  If <code>nsim</code> is a positive integer, then <code>Ve.diag</code> must also be supplied.  <code>Ve.diag</code> is should be a vector of length <code class="reqn">n</code> specifying the measurement error variances of the observed data.  This information is only used for conditional simulation, so this argument is only needed when <code>nsim</code> &gt; 0.  When conditional simulation is desired, then the argument <code>method</code> can be to specify the method used to decompose <code>V</code>.  Options are &quot;eigen&quot;, &quot;chol&quot;, or &quot;svd&quot; (Eigen decomposition, Cholesky decomposition, or Singular value decomposition, respectively).  This information is only used for conditional simulation, so this argument is only applicable when <code>nsim</code> &gt; 0.
</p>


<h3>Value</h3>

<p>The function returns a list containing the following objects:
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>A vector of length <code class="reqn">np</code> containing the predicted
responses.</p>
</td></tr>
<tr><td><code>mspe</code></td>
<td>
<p>A vector of length <code class="reqn">np</code> containing the 
mean-square prediction error of the predicted
responses.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>A vector of length <code class="reqn">k</code> containing the estimated
regression coefficients.</p>
</td></tr> 
<tr><td><code>vcov.coeff</code></td>
<td>
<p>A <code class="reqn">k \times k</code> matrix containing the
(estimated) covariance matrix of estimated the regression coefficients.</p>
</td></tr> 
<tr><td><code>simulations</code></td>
<td>
<p>An <code class="reqn">n \times nsim</code> matrix containing the <code>nsim</code> realizations of the conditional realizations.  Each column of the matrix represents a realization of the conditional normal distribution.</p>
</td></tr>
</table>
<p>If <code>nsim</code> &gt; 0, this list has class &quot;krigeConditionalSample&quot;.
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>References</h3>

<p> Statistical Methods for Spatial Data Analysis, Schabenberger and Gotway (2003).  See p. 226-228.</p>


<h3>Examples</h3>

<pre><code class='language-R'># create observed and predicted coordinates
ocoords &lt;- matrix(runif(100), ncol = 2)
pcoords &lt;- matrix(runif(200), ncol = 2)

# include some observed locations in the predicted coordinates
acoords &lt;- rbind(ocoords, pcoords)

# create covariance matrix
C3 &lt;- cov.sp(coords = ocoords, sp.type = "matern", sp.par = c(2, 1), smoothness = 1, 
	finescale = 0, error = 0.5, pcoords = acoords)

# generate data with error
y &lt;- rmvnorm(nsim = 1, mu = rep(2, 50), V = C3$V) + rnorm(50, sd = sqrt(.5))

# use universal kriging to make predictions.  Do not do conditional simulation
krige.obj &lt;- krige.ok(as.vector(y), V = C3$V, Vp = C3$Vp, Vop = C3$Vop, 
	nsim = 0)

#Do conditional simulation
krige.obj2 &lt;- krige.ok(as.vector(y), V = C3$V, Vp = C3$Vp, Vop = C3$Vop, 
	nsim = 100, Ve.diag = rep(.5, 50), method = "eigen")

</code></pre>

<hr>
<h2 id='krige.sk'>
Performs simple kriging
</h2><span id='topic+krige.sk'></span>

<h3>Description</h3>

<p>Performs simple kriging using <code>y</code>, a vector of length <code class="reqn">n</code>,
<code>V</code>, the (positive definite) covariance matrix of the 
observed responses, <code>Vp</code>, the 
<code class="reqn">np \times np</code>
covariance matrix of the responses to be predicted, <code>Vop</code>, 
the <code class="reqn">n \times np</code> matrix of covariances between the observed 
responses and the responses to be predicted, and <code>m</code>, a numeric vector 
of length 1 identifying the value of the mean
for each response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	krige.sk(y, V, Vp, Vop, m = 0, nsim = 0, Ve.diag = NULL, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige.sk_+3A_y">y</code></td>
<td>
<p>The vector of observed responses.
Should be a matrix of size <code class="reqn">n \times 1</code> or a vector of 
length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="krige.sk_+3A_v">V</code></td>
<td>
<p>The covariance matrix of the observed responses.  
The size is <code class="reqn">n \times n</code>.</p>
</td></tr> 
<tr><td><code id="krige.sk_+3A_vp">Vp</code></td>
<td>
<p>The covariance matrix of the responses to be predicted.
The size is <code class="reqn">np \times np</code></p>
</td></tr> 
<tr><td><code id="krige.sk_+3A_vop">Vop</code></td>
<td>
<p>The cross-covariance between the observed responses 
and the responses to be predicted.  The size is 
<code class="reqn">n \times np</code>.</p>
</td></tr> 
<tr><td><code id="krige.sk_+3A_m">m</code></td>
<td>
<p>A numeric vector of length 1 giving the mean of each response.</p>
</td></tr>
<tr><td><code id="krige.sk_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulated data sets to sample from the conditional predictive distribution.</p>
</td></tr>
<tr><td><code id="krige.sk_+3A_ve.diag">Ve.diag</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> specifying the measure error variances of the observed data.  Only needed if <code>nsim</code> &gt; 0.</p>
</td></tr>
<tr><td><code id="krige.sk_+3A_method">method</code></td>
<td>
<p>The method for decomposing <code>V</code> in conditional simulation.  Default is &quot;eigen&quot;, for the Eigen decomposition.  Alternatives are &quot;chol&quot; (Cholesky) and &quot;svd&quot; (Singular Value Decomposition).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that there are <code class="reqn">n</code> observed data values
and that we wish to make predictions at <code class="reqn">np</code> locations.
The mean is subtracted from each value of <code>y</code> before determining the kriging weights, 
and then the mean is added onto the predicted response.
</p>
<p>If doing conditional simulation, the Cholesky decomposition should not work when there are coincident locations between the observed data locations and the predicted data locations.    Both the Eigen and Singular Value Decompositions should work.
</p>
<p>If user specifies <code>nsim</code> to be a positive integer, then <code>nsim</code> conditional realizations of the predictive distribution will be generated.  If this is less than 1, then no conditional simulation is done.  If <code>nsim</code> is a positive integer, then <code>Ve.diag</code> must also be supplied.  <code>Ve.diag</code> is should be a vector of length <code class="reqn">n</code> specifying the measurement error variances of the observed data.  This information is only used for conditional simulation, so this argument is only needed when <code>nsim</code> &gt; 0.  When conditional simulation is desired, then the argument <code>method</code> can be to specify the method used to decompose <code>V</code>.  Options are &quot;eigen&quot;, &quot;chol&quot;, or &quot;svd&quot; (Eigen decomposition, Cholesky decomposition, or Singular value decomposition, respectively).  This information is only used for conditional simulation, so this argument is only applicable when <code>nsim</code> &gt; 0.
</p>


<h3>Value</h3>

<p>The function returns a list containing the following objects:
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>A vector of length <code class="reqn">np</code> containing the predicted
responses.</p>
</td></tr>
<tr><td><code>mspe</code></td>
<td>
<p>A vector of length <code class="reqn">np</code> containing the 
mean-square prediction error of the predicted
responses.</p>
</td></tr>
<tr><td><code>simulations</code></td>
<td>
<p>An <code class="reqn">n \times nsim</code> matrix containing the <code>nsim</code> realizations of the conditional realizations.  Each column of the matrix represents a realization of the conditional normal distribution.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The mean value (m) originally provided to the function</p>
</td></tr></table>
<p>.  
If <code>nsim</code> &gt; 0, this list has class &quot;krigeConditionalSample&quot;.
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>References</h3>

<p> Statistical Methods for Spatial Data Analysis, Schabenberger and Gotway (2003).  See p. 226-228.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(toydata)
	y &lt;- as.vector(toydata$y)
	V &lt;- toydata$V
	Vp &lt;- toydata$Vp
	Vop &lt;- toydata$Vop
	krige.sk(y, V, Vp, Vop, m = 2)
</code></pre>

<hr>
<h2 id='krige.uk'>
Performs universal kriging
</h2><span id='topic+krige.uk'></span>

<h3>Description</h3>

<p>Performs universal kriging using <code>X</code>, the <code class="reqn">n \times k</code> 
design matrix for the regression coefficients of the observed 
data, <code>y</code>, the <code class="reqn">n \times 1</code> matrix of observed responses,
<code>V</code>, the (positive definite) covariance matrix of the 
observed responses, <code>Xp</code>, the <code class="reqn">np \times k</code> design matrix
of the responses to be predicted, <code>Vp</code>, the 
<code class="reqn">np \times np</code>
covariance matrix of the responses to be predicted, and <code>Vop</code>, 
the <code class="reqn">n \times np</code> matrix of covariances between the observed 
responses and the responses to be predicted.  If user specifies <code>nsim</code> to be a positive integer, then <code>nsim</code> conditional realizations of the predictive distribution will be generated.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	krige.uk(y, V, Vp, Vop, X, Xp, nsim = 0, Ve.diag = NULL, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige.uk_+3A_y">y</code></td>
<td>
<p>The vector of observed responses.  Should be a matrix of size <code class="reqn">n \times 1</code> or a vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="krige.uk_+3A_v">V</code></td>
<td>
<p>The covariance matrix of the observed responses.  
The size is <code class="reqn">n \times n</code>.</p>
</td></tr> 
<tr><td><code id="krige.uk_+3A_vp">Vp</code></td>
<td>
<p>The covariance matrix of the responses to be predicted.  The size is <code class="reqn">np \times np</code></p>
</td></tr> 
<tr><td><code id="krige.uk_+3A_vop">Vop</code></td>
<td>
<p>The cross-covariance between the observed responses and the responses to be predicted.  The size is <code class="reqn">n \times np</code></p>
</td></tr> 
<tr><td><code id="krige.uk_+3A_x">X</code></td>
<td>
<p>The design matrix of the observed data.  The size is <code class="reqn">n \times k</code></p>
</td></tr> 
<tr><td><code id="krige.uk_+3A_xp">Xp</code></td>
<td>
<p>The design matrix of the responses to be predicted.  
The size is <code class="reqn">np \times k</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="krige.uk_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulated data sets to sample from the conditional predictive distribution.</p>
</td></tr>
<tr><td><code id="krige.uk_+3A_ve.diag">Ve.diag</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> specifying the measure error variances of the observed data.</p>
</td></tr>
<tr><td><code id="krige.uk_+3A_method">method</code></td>
<td>
<p>The method for decomposing <code>V</code> in conditional simulation.  Default is &quot;eigen&quot;, for the Eigen decomposition.  Alternatives are &quot;chol&quot; (Cholesky) and &quot;svd&quot; (Singular Value Decomposition).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that there are <code class="reqn">n</code> observed data values
and that we wish to make predictions at <code class="reqn">np</code> locations.  We assume
that there are <code class="reqn">k</code> regression coefficients (including the intercept).
Both <code>X</code> and <code>Xp</code> should contain a column of 1's if an intercept
is desired.
</p>
<p>If doing conditional simulation, the Cholesky decomposition should not work when there are coincident locations between the observed data locations and the predicted data locations.    Both the Eigen and Singular Value Decompositions should work.
</p>
<p>If user specifies <code>nsim</code> to be a positive integer, then <code>nsim</code> conditional realizations of the predictive distribution will be generated.  If this is less than 1, then no conditional simulation is done.  If <code>nsim</code> is a positive integer, then <code>Ve.diag</code> must also be supplied.  <code>Ve.diag</code> is should be a vector of length <code class="reqn">n</code> specifying the measurement error variances of the observed data.  This information is only used for conditional simulation, so this argument is only needed when <code>nsim</code> &gt; 0.  When conditional simulation is desired, then the argument <code>method</code> can be to specify the method used to decompose <code>V</code>.  Options are &quot;eigen&quot;, &quot;chol&quot;, or &quot;svd&quot; (Eigen decomposition, Cholesky decomposition, or Singular value decomposition, respectively).  This information is only used for conditional simulation, so this argument is only applicable when <code>nsim</code> &gt; 0.
</p>


<h3>Value</h3>

<p>The function returns a list containing the following objects:
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>A vector of length <code class="reqn">np</code> containing the predicted
responses.</p>
</td></tr>
<tr><td><code>mspe</code></td>
<td>
<p>A vector of length <code class="reqn">np</code> containing the 
mean-square prediction error of the predicted
responses.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>A vector of length <code class="reqn">k</code> containing the estimated
regression coefficients.</p>
</td></tr> 
<tr><td><code>vcov.coeff</code></td>
<td>
<p>A <code class="reqn">k \times k</code> matrix containing the
(estimated) covariance matrix of estimated the regression coefficients.</p>
</td></tr> 
<tr><td><code>sim</code></td>
<td>
<p>An <code class="reqn">n \times nsim</code> matrix containing the <code>nsim</code> realizations of the conditional realizations.  Each column of the matrix represents a realization of the conditional normal distribution.</p>
</td></tr>
</table>
<p>If <code>nsim</code> &gt; 0, this list has class &quot;krigeConditionalSample&quot;.	
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>References</h3>

<p> Statistical Methods for Spatial Data Analysis, Schabenberger and Gotway (2003).  See p. 241-243.</p>


<h3>Examples</h3>

<pre><code class='language-R'># create observed and predicted coordinates
ocoords &lt;- matrix(runif(100), ncol = 2)
pcoords &lt;- matrix(runif(200), ncol = 2)

# include some observed locations in the predicted coordinates
acoords &lt;- rbind(ocoords, pcoords)

# create design matrices
X &lt;- as.matrix(cbind(1, ocoords))
Xa &lt;- as.matrix(cbind(1, acoords))

# create covariance matrix
C3 &lt;- cov.sp(coords = ocoords, sp.type = "matern", sp.par = c(2, 1), smoothness = 1, 
	finescale = 0, error = 0.5, pcoords = acoords)

# set values of regression coefficients
coeff &lt;- matrix(c(1, 2, 3), nrow = 1)

# generate data with error
y &lt;- rmvnorm(nsim = 1, mu = tcrossprod(X, coeff), V = C3$V) + rnorm(50, sd = sqrt(.5))

# use universal kriging to make predictions.  Do not do 
# conditional simulation
krige.obj &lt;- krige.uk(as.vector(y), V = C3$V, Vp = C3$Vp, Vop = C3$Vop, 
	X = X, Xp = Xa, nsim = 0)

#Do kriging with conditional simulation
krige.obj2 &lt;- krige.uk(as.vector(y), V = C3$V, Vp = C3$Vp, Vop = C3$Vop, 
	X = X, Xp = Xa, nsim = 100, 
	Ve.diag = rep(.5, 50), method = "eigen")
</code></pre>

<hr>
<h2 id='maxlik.cov.sp'>
Determines maximum likelihood estimates of covariance parameters
</h2><span id='topic+maxlik.cov.sp'></span>

<h3>Description</h3>

<p>Estimates covariance parameters of spatial covariance functions using maximum likelihood or restricted maximum likelihood.  See <code>cov.sp</code> for more details of covariance functions to be estimated.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	maxlik.cov.sp(X, y, coords, sp.type = "exponential", 
	    range.par = stop("specify range.par argument"), 
	    error.ratio = stop("specify error.ratio argument"), 
	    smoothness = 0.5,  
	    D = NULL, reml = TRUE, lower = NULL, upper = NULL, 
	    control = list(trace = TRUE), optimizer="nlminb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxlik.cov.sp_+3A_x">X</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times k</code> containing the design matrix of the data locations.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.sp_+3A_y">y</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> containing the observed responses.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.sp_+3A_coords">coords</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times d</code> containing the locations of the observed responses.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.sp_+3A_sp.type">sp.type</code></td>
<td>
<p>A character vector specifying the spatial covariance type.  Valid types are currently exponential, gaussian, matern, and spherical.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.sp_+3A_range.par">range.par</code></td>
<td>
<p>An initial guess for the spatial dependence parameter.</p>
</td></tr>
<tr><td><code id="maxlik.cov.sp_+3A_error.ratio">error.ratio</code></td>
<td>
<p>A value non-negative value indicating the ratio <code>error.var/sp.par[1]</code>.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.sp_+3A_smoothness">smoothness</code></td>
<td>
<p>A positive number indicating the smoothness of the matern covariance function, if applicable.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.sp_+3A_d">D</code></td>
<td>
<p>The Euclidean distance matrix for the coords matrix.  Must be of size <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code id="maxlik.cov.sp_+3A_reml">reml</code></td>
<td>
<p>A boolean value indicating whether restricted maximum likelihood estimation should be used.  Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="maxlik.cov.sp_+3A_lower">lower</code></td>
<td>
<p>A vector giving lower bounds for the covariance parameters <code>sp.par[2]</code>, <code>error.ratio</code>, and <code>smoothness</code> (when the model is matern).  Order matters!  If not given defaults to an upper bound of Inf for <code>sp.par[2]</code>, 1 for <code>error.ratio</code>, and 10 for <code>smoothness</code>.</p>
</td></tr>
<tr><td><code id="maxlik.cov.sp_+3A_upper">upper</code></td>
<td>
<p>A vector giving upper bounds for the covariance parameters <code>sp.par[2]</code>, <code>error.ratio</code>, and <code>smoothness</code> (when the model is matern).  Order matters!  If not given defaults to an upper bound of Inf for <code>sp.par[2]</code>, 1 for <code>error.ratio</code>, and 10 for <code>smoothness</code>.</p>
</td></tr>
<tr><td><code id="maxlik.cov.sp_+3A_control">control</code></td>
<td>
<p>A list giving tuning parameters for the <code>nlminb</code> function.  See <code>nlminb</code> for more details.</p>
</td></tr>
<tr><td><code id="maxlik.cov.sp_+3A_optimizer">optimizer</code></td>
<td>
<p>A vector describing the optimization function to use for the optimization.  Currently, only <code>nlminb</code> is an acceptable value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When doing the numerical optimizaiton, the covariance function is reparameterized slightly to speedup computation.  
Specifically, the variance parameter for the process of interest,<code>sp.par[1]</code>, is profiled out,
and the <code>error.var</code> parameter is parameterized as <code>sp.par[1] * error.ratio</code>, where <code>error.ratio = error.var/sp.par[1]</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>
<table>
<tr><td><code>sp.type</code></td>
<td>
<p> The covariance form used. </p>
</td></tr>
<tr><td><code>sp.par</code></td>
<td>
<p> A vector containing the estimated variance of the hidden process and the spatial dependence.</p>
</td></tr>
<tr><td><code>error.var</code></td>
<td>
<p> The estimated error variance.</p>
</td></tr>
<tr><td><code>smoothness</code></td>
<td>
<p> The smoothness of the matern covariance function.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p> The final values of the optimization parameters.  Note that these will not necessarily match <code>sp.par</code>, <code>error.var</code>, and <code>smoothness</code> because of the reparameterization.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> Convergence message from <code>nlminb</code>.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p> Message from <code>nlminb</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p> Number of iterations for optimization to converge.</p>
</td></tr>
<tr><td><code>evaluations</code></td>
<td>
<p> Evaluations from <code>nlminb</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

 <p><code>cov.st</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate 20 random (x, y) coordinates
coords &lt;- matrix(rnorm(20), ncol = 2)

#create design matrix
X &lt;- cbind(1, coords)

#create mean for observed data to be generated
mu &lt;- X %*% c(1, 2, 3)

#generate covariance matrix
V &lt;- exp(-dist1(coords))

#generate observe data
y &lt;- rmvnorm(mu = mu, V = V)

#find maximum likelihood estimates of covariance parameters
maxlik.cov.sp(X = X, y = y, coords = coords,
    sp.type = "exponential", range.par = 1, error.ratio = 0, 
    reml = TRUE)
</code></pre>

<hr>
<h2 id='maxlik.cov.st'>
Determines maximum likelihood estimates of covariance parameters
</h2><span id='topic+maxlik.cov.st'></span>

<h3>Description</h3>

<p>Estimates covariance parameters of spatio-temporal covariance functions using maximum likelihood or restricted maximum likelihood.  See <code>cov.st</code> for more details of covariance functions to be estimated.  The covariance function is reparameterized slightly to speedup computation.  Specifically, the variance parameter for the hidden process, sp.par[1], is profiled out and the error.var parameter is parameterized as sp.par[1] * error.ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	maxlik.cov.st(X, y, coords, time, sp.type = "exponential", 
	    range.par = stop("specify range.par argument"), 
	    error.ratio = stop("specify error.ratio argument"), 
	    smoothness = 0.5, t.type = "ar1", t.par = .5, D = NULL, T = NULL, 
	    reml = TRUE, lower = NULL, upper = NULL, control = list(trace = TRUE), 
	    optimizer="nlminb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxlik.cov.st_+3A_x">X</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times k</code> containing the design matrix of the data locations.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_y">y</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> containing the observed responses.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_coords">coords</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times d</code> containing the locations of the observed responses.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_time">time</code></td>
<td>
<p>A numeric vector of length n containing the time at which the responses were observed.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_sp.type">sp.type</code></td>
<td>
<p>A character vector specifying the spatial covariance type.  Valid types are currently exponential, gaussian, matern, and spherical.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_range.par">range.par</code></td>
<td>
<p>An initial guess for the spatial dependence parameter.</p>
</td></tr>
<tr><td><code id="maxlik.cov.st_+3A_error.ratio">error.ratio</code></td>
<td>
<p>A value non-negative value indicating the ratio <code>error.var/sp.par[1]</code>.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_smoothness">smoothness</code></td>
<td>
<p>A positive number indicating the variance of the error term.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_t.type">t.type</code></td>
<td>
<p>A character vector indicating the spatial covariance type.  Only <code>ar1</code> is currently available.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_t.par">t.par</code></td>
<td>
<p>A value specifying the temporal dependence parameter of the ar1 process.</p>
</td></tr> 
<tr><td><code id="maxlik.cov.st_+3A_d">D</code></td>
<td>
<p>The Euclidean distance matrix for the coords matrix.  Must be of size <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code id="maxlik.cov.st_+3A_t">T</code></td>
<td>
<p>The Euclidean distance matrix for the time matrix.  Must be of size <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code id="maxlik.cov.st_+3A_reml">reml</code></td>
<td>
<p>A boolean value indicating whether restricted maximum likelihood estimation should be used.  Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="maxlik.cov.st_+3A_lower">lower</code></td>
<td>
<p>A vector giving lower bounds for the covariance parameters <code>sp.par[2]</code>, <code>error.ratio</code>, and <code>smoothness</code> (when the model is matern).  Order matters!  If not given defaults to a lower bound of .001 for <code>sp.par[2]</code>, 0 for <code>error.ratio</code>, and .001 for <code>smoothness</code>.</p>
</td></tr>
<tr><td><code id="maxlik.cov.st_+3A_upper">upper</code></td>
<td>
<p>A vector giving upper bounds for the covariance parameters <code>sp.par[2]</code>, <code>error.ratio</code>, and <code>smoothness</code> (when the model is matern).  Order matters!  If not given defaults to an upper bound of Inf for <code>sp.par[2]</code>, 1 for <code>error.ratio</code>, and 10 for <code>smoothness</code>.</p>
</td></tr>
<tr><td><code id="maxlik.cov.st_+3A_control">control</code></td>
<td>
<p>A list giving tuning parameters for the <code>nlminb</code> function.  See <code>nlminb</code> for more details.</p>
</td></tr>
<tr><td><code id="maxlik.cov.st_+3A_optimizer">optimizer</code></td>
<td>
<p>A vector describing the optimization function to use for the optimization.  Currently, only <code>nlminb</code> is an acceptable value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When doing the numerical optimization, the covariance function is reparameterized slightly to speedup computation.  
Specifically, the variance parameter for the process of interest,<code>sp.par[1]</code>, is profiled out,
and the <code>error.var</code> parameter is parameterized as <code>sp.par[1] * error.ratio</code>, where <code>error.ratio = error.var/sp.par[1]</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>
<table>
<tr><td><code>sp.type</code></td>
<td>
<p> The covariance form used. </p>
</td></tr>
<tr><td><code>sp.par</code></td>
<td>
<p> A vector containing the estimated variance of the hidden process and the spatial dependence.</p>
</td></tr>
<tr><td><code>error.var</code></td>
<td>
<p> The estimated error variance.</p>
</td></tr>
<tr><td><code>smoothness</code></td>
<td>
<p> The smoothness of the matern covariance function.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p> The final values of the optimization parameters.  Note that these will not necessarily match <code>sp.par</code>, <code>error.var</code>, and <code>smoothness</code> because of the reparameterization.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> Convergence message from <code>nlminb</code>.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p> Message from <code>nlminb</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p> Number of iterations for optimization to converge.</p>
</td></tr>
<tr><td><code>evaluations</code></td>
<td>
<p> Evaluations from <code>nlminb</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

 <p><code>cov.st</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate locations and observed times
coords &lt;- matrix(rnorm(40), ncol = 2)
time &lt;- rep(1:2, each = 10)

#Calculate distance matrix for time vector
T &lt;- dist1(matrix(time))

#create design matrix
X &lt;- cbind(1, coords)

#create mean for observed data to be generated
mu &lt;- X %*% c(1, 2, 3)

#generate covariance matrix for spatio-temporal data
V &lt;- exp(-dist1(coords)) * .25^T

#generate observe data
y &lt;- rmvnorm(mu = mu, V = V)

maxlik.cov.st(X = X, y = y, coords = coords, time = time,
    sp.type = "exponential", range.par = 1, error.ratio = 0, 
    t.type = "ar1", t.par = .5, reml = TRUE)

</code></pre>

<hr>
<h2 id='plot.contourLines'>
Plot contour lines
</h2><span id='topic+plot.contourLines'></span>

<h3>Description</h3>

<p>Plot contour lines from list produced by <code>contourLines</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'contourLines'
plot(x, begin=1, end = length(x), add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.contourLines_+3A_x">x</code></td>
<td>

<p>The list of contour lines (created by <code>contourLines</code>) you want to plot.
</p>
</td></tr>
<tr><td><code id="plot.contourLines_+3A_begin">begin</code></td>
<td>

<p>Beginning position in list of contour lines you want to plot.
</p>
</td></tr>
<tr><td><code id="plot.contourLines_+3A_end">end</code></td>
<td>

<p>Ending position in list of contour lines you want to plot.
</p>
</td></tr>
<tr><td><code id="plot.contourLines_+3A_add">add</code></td>
<td>

<p>A boolean value indicating whether the contour lines should be added to an existing plot (add = TRUE) or should be plotted on a new plot (add = FALSE).
</p>
</td></tr>
<tr><td><code id="plot.contourLines_+3A_...">...</code></td>
<td>

<p>Additional arguments that will be passed to the <code>plot</code> or <code>lines</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything; it only creates a new plot or modifies an existing plot.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volcano)
x &lt;- 10*1:nrow(volcano)
y &lt;- 10*1:ncol(volcano)
cL &lt;- contourLines(x, y, volcano)
plot.contourLines(cL)
</code></pre>

<hr>
<h2 id='rcondnorm'>
Generate from conditional normal distribution
</h2><span id='topic+rcondnorm'></span>

<h3>Description</h3>

<p>Generates realizations from a multivariate normal distribution conditional on observed data vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	rcondnorm(nsim = 1, y, mu, mup, V, Vp, Vop, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcondnorm_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of realizations from the distribution.</p>
</td></tr> 
<tr><td><code id="rcondnorm_+3A_y">y</code></td>
<td>
<p>A vector of length <code>n</code> contained the observed data.</p>
</td></tr> 
<tr><td><code id="rcondnorm_+3A_mu">mu</code></td>
<td>
<p>The mean vector of the observed data.  Should be a vector of length <code>n</code>.</p>
</td></tr> 
<tr><td><code id="rcondnorm_+3A_mup">mup</code></td>
<td>
<p>The mean vector of the responses to be generated.  Should be a vector of length <code>np</code>.</p>
</td></tr> 
<tr><td><code id="rcondnorm_+3A_v">V</code></td>
<td>
<p>The covariance matrix of the observed data.  The matrix should be symmetric and positive definite.  The size must be <code class="reqn">n times n</code>.</p>
</td></tr> 
<tr><td><code id="rcondnorm_+3A_vp">Vp</code></td>
<td>
<p>The covariance matrix of the responses to be generated.  The matrix should be symmetric and positive definite.  The size must be <code class="reqn">np times np</code>.</p>
</td></tr> 
<tr><td><code id="rcondnorm_+3A_vop">Vop</code></td>
<td>
<p>The cross-covariance matrix between the observed data and the responses to be generated.  The size must be <code class="reqn">n times np</code>.</p>
</td></tr> 
<tr><td><code id="rcondnorm_+3A_method">method</code></td>
<td>
<p>The method for performing a decomposition of the covariance matrix.  Possible values are &quot;eigen&quot;, &quot;chol&quot;, and &quot;svd&quot;, Eigen value decomposition, Cholesky decomposition, or Singular Value Decomposoition, respectively.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>An <code class="reqn">np \times nsim</code> matrix containing the <code>nsim</code> realizations of the conditional normal distribution.  Each column of the matrix represents a realization of the multivariate normal distribution.
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p>rmvnorm</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
np &lt;- 100

mu &lt;- rep(1, 100)
mup &lt;- rep(2, 100)

coords &lt;- matrix(runif(2 * n), ncol = 2)
pcoords &lt;- matrix(runif(2 * np), ncol = 2)

myV &lt;- cov.sp(coords, sp.type = "exponential", c(1, 2), error.var = 1, pcoords = pcoords)

y &lt;- rmvnorm(1, mu = mu, V = myV$V)

rcondnorm(3, y = y, mu = mu, mup = mup, V = myV$V, Vp = myV$Vp, Vop = myV$Vop, method = "chol")
</code></pre>

<hr>
<h2 id='rmvnorm'>
Generates realizations from a multivariate normal distribution
</h2><span id='topic+rmvnorm'></span>

<h3>Description</h3>

<p>Generates realizations from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	rmvnorm(nsim = 1, mu, V, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of realizations from the distribution.</p>
</td></tr> 
<tr><td><code id="rmvnorm_+3A_mu">mu</code></td>
<td>
<p>A vector of length n containing the mean values of the multivariate normal distribution.</p>
</td></tr> 
<tr><td><code id="rmvnorm_+3A_v">V</code></td>
<td>
<p>The covariance matrix of the multivariate normal distribution.  The matrix should be symmetric and positive definite.  The size must be <code class="reqn">n times n</code>.</p>
</td></tr> 
<tr><td><code id="rmvnorm_+3A_method">method</code></td>
<td>
<p>The method for performing a decomposition of the covariance matrix.  Possible values are &quot;eigen&quot;, &quot;chol&quot;, and &quot;svd&quot;, Eigen value decomposition, Cholesky decomposition, or Singular Value Decomposoition, respectively.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times nsim</code> matrix containing the <code>nsim</code> realizations of the multivariate normal distribution.  Each column of the matrix represents a realization of the multivariate normal distribution.
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p>rmvnorm</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
mu &lt;- 1:n
V &lt;- exp(-dist1(matrix(rnorm(n))))
rmvnorm(nsim = 100, mu = mu, V = V, method = "eigen")
</code></pre>

<hr>
<h2 id='simple.cov.sp'>
Calculates spatial covariance based on distance matrix
</h2><span id='topic+simple.cov.sp'></span>

<h3>Description</h3>

<p>Calculates a spatial covariance using a (Euclidean) distance matrix <code>D</code>.  Not intended to be used directly by user (though it may be helpful to some).  It is strongly recommended that you use the <code>cov.sp</code> function.  No argument or error checking is provided for this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	simple.cov.sp(D, sp.type, sp.par, error.var, smoothness, finescale.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple.cov.sp_+3A_d">D</code></td>
<td>
<p>A distance matrix between locations</p>
</td></tr> 
<tr><td><code id="simple.cov.sp_+3A_sp.type">sp.type</code></td>
<td>
<p>A character vector specifying the spatial covariance type.  Valid types are currently exponential, gaussian, matern, and spherical.</p>
</td></tr> 
<tr><td><code id="simple.cov.sp_+3A_sp.par">sp.par</code></td>
<td>
<p>A vector of length 2 specifying the scale and dependence of the covariance function.  The first element refers to the variance of the hidden process (sometimes this is called the partial sill) while the second elements determines the strength of dependence between locations.</p>
</td></tr> 
<tr><td><code id="simple.cov.sp_+3A_error.var">error.var</code></td>
<td>
<p>A non-negative number indicating the variance of the error term.</p>
</td></tr> 
<tr><td><code id="simple.cov.sp_+3A_smoothness">smoothness</code></td>
<td>
<p>A positive number indicating the variance of the error term.</p>
</td></tr> 
<tr><td><code id="simple.cov.sp_+3A_finescale.var">finescale.var</code></td>
<td>
<p>A non-negative positive number indicating the finescale variability.  The is also called the microscale variance</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a covariance matrix. 
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p> ~ <code>cov.sp</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>	coords &lt;- matrix(rnorm(30), ncol = 3)
	D &lt;- dist1(coords)
	simple.cov.sp(D = D, sp.type = "exponential", sp.par = c(2, 1),
		error.var = 1, smoothness = 0.5, finescale.var = 0)
</code></pre>

<hr>
<h2 id='simple.cov.time'>
Calculates temporal covariance based on distance matrix
</h2><span id='topic+simple.cov.time'></span>

<h3>Description</h3>

<p>Calculates a temporal covariance using a (Euclidean) distance matrix <code>T</code>.  Not intended to be used directly by user (though it may be helpful to some).  It is used in the <code>covets</code> function.  No argument or error checking is provided for this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	simple.cov.time(T, t.type, t.par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple.cov.time_+3A_t">T</code></td>
<td>
<p>A distance matrix.</p>
</td></tr> 
<tr><td><code id="simple.cov.time_+3A_t.type">t.type</code></td>
<td>
<p>A character vector specifying the temporal covariance type.  Only &quot;ar1&quot; is currently implemented.</p>
</td></tr> 
<tr><td><code id="simple.cov.time_+3A_t.par">t.par</code></td>
<td>
<p>A vector of length 1 specifying the strength of dependence of the covariance function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a covariance matrix. 
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p> ~ <code>cov.st</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>	T &lt;- dist1(matrix(1:10))
	simple.cov.time(T = T, t.type = "ar1", t.par = .5)
</code></pre>

<hr>
<h2 id='spLMPredictJoint'>
Returns posterior predictive sample from spLM object
</h2><span id='topic+spLMPredictJoint'></span>

<h3>Description</h3>

<p>The function <code>spLMPredictJoint</code> collects posterior predictive samples
for a set of new locations given a <code>spLM</code> object from the <code>spBayes</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  spLMPredictJoint(sp.obj, pred.coords, pred.covars, start = 1, 
    end = nrow(sp.obj$p.theta.samples), thin = 1, verbose = TRUE, n.report = 100, 
    noisy = FALSE, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spLMPredictJoint_+3A_sp.obj">sp.obj</code></td>
<td>
<p>An <code>spLM</code> object returned by the <code>spLM</code> function in the <code>spBayes</code> package.</p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_pred.coords">pred.coords</code></td>
<td>
<p>An <code class="reqn">np \times 2</code> matrix of <code class="reqn">np</code> prediction
location coordinates in <code class="reqn">R^2</code> (e.g., easting and northing).
The first column is assumed to be easting coordinates and the second column
northing coordinates.  </p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_pred.covars">pred.covars</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of covariates matrix associated with the new locations.</p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_start">start</code></td>
<td>
<p>Specifies the first sample included in the composition sampling.</p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_end">end</code></td>
<td>
<p>Specifies the last sample included in the composition.
The default is to use all posterior samples in <code>sp.obj</code>. </p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_thin">thin</code></td>
<td>
<p>A sample thinning factor.  The default of 1 considers all
samples between <code>start</code> and <code>end</code>.  For example, if <code>thin = 10</code> then 1 in 10 samples are considered between <code>start</code> and
<code>end</code>. </p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_n.report">n.report</code></td>
<td>
<p>The interval to report sampling progress. </p>
</td></tr>  
<tr><td><code id="spLMPredictJoint_+3A_noisy">noisy</code></td>
<td>
<p>If <code>TRUE</code>, then the posterior sample for the response is for the signal + error noise.  The default, <code>FALSE</code>, assumes the user wants the error-free process.</p>
</td></tr>
<tr><td><code id="spLMPredictJoint_+3A_method">method</code></td>
<td>
<p>Method used to decompose covariance matrix.  Options are &quot;chol&quot;, &quot;eigen&quot;, and &quot;svd&quot; for the Cholesky, Eigen, and singular value decomposition approaches, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples from the joint posterior predictive distribution of a Bayesian spatial linear model. Specifically, it is intended to be similar to the <code>spPredict</code> function in the <code>spBayes</code> except that it samples from the joint distribution instead of the marginal distribution.  However, it will only work for <code>spLM</code> objects and should have the same limitations as the <code>spLM</code> and <code>spPredict</code> functions.  Note that the <code>spRecover</code> function is called internally to recover the posterior samples form the posterior distribution of the spatial model.  
</p>


<h3>Value</h3>

<p>The function returns a <code class="reqn">np \times B</code> matrix of posterior predictive samples, where <code>B</code> is the number of posterior samples.  The class is <code>jointPredicitveSample</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>See Also</h3>

<p>spLM, spPredict, spRecover</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set parameters
n &lt;- 100
np &lt;- 12
n.samples &lt;- 10
burnin.start &lt;- .5 * n.samples + 1
sigmasq &lt;- 1
tausq &lt;- 0.0
phi &lt;- 1
cov.model &lt;- "exponential"
n.report &lt;- 5

# Generate coordinates
coords &lt;- matrix(runif(2 * n), ncol = 2); 
pcoords &lt;- as.matrix(expand.grid(seq(0, 1, len = 12), seq(0, 1, len = 12)))
  
# Construct design matrices
X &lt;- as.matrix(cbind(1, coords))
Xp &lt;- cbind(1, pcoords)

# Specify priors
starting &lt;- list("phi" = phi, "sigma.sq"= sigmasq, "tau.sq" = tausq)
tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)
priors.1 &lt;- list("beta.Norm"=list(c(1, 2, 1), diag(100, 3)),
                     "phi.Unif"=c(0.00001, 10), "sigma.sq.IG"=c(1, 1))

# Generate data
B &lt;- rnorm(3, c(1, 2, 1), sd = 10)
phi &lt;- runif(1, 0, 10)
sigmasq &lt;- 1/rgamma(1, 1, 1)
V &lt;- simple.cov.sp(D = dist1(coords), cov.model, c(sigmasq, 1/phi), error.var = tausq, 
	smoothness = nu, finescale.var = 0)
y &lt;- X %*% B + rmvnorm(1, rep(0, n), V) + rnorm(n, 0, sqrt(tausq))

# Create spLM object
library(spBayes)
m1 &lt;- spBayes::spLM(y ~ X - 1, coords = coords, starting = starting,
	tuning = tuning, priors = priors.1, cov.model = cov.model,
	n.samples = n.samples, verbose = FALSE, n.report = n.report)

# Sample from joint posterior predictive distribution
y1 &lt;- spLMPredictJoint(m1, pred.coords = pcoords, pred.covars = Xp, 
	start = burnin.start, verbose = FALSE, method = "chol")
</code></pre>

<hr>
<h2 id='toydata'>
A toy data set for use in examples.
</h2><span id='topic+toydata'></span>

<h3>Description</h3>

<p>A list containing <code>X</code>, a 50 x 3 design matrix, <code>y</code>, a vector of length 50 of observed responses, <code>V</code>, a 50 x 50 covariance matrix for the observed data, <code>Xp</code>, a 121 x 3 design matrix for the predicted responses, <code>Vp</code>, the 121 x 121 covariance matrix of the predicted responses, <code>Vop</code>, the 50 x 121 covariance matrix between the observed responses and the predicted responses, <code>coords</code>, a 50 x 2 matrix containing the sites of the 50 observed responses, and <code>pcoords</code>, a 121 x 2 matrix containing the 121 sites for the predicted responses (a 11 x 11 regular grid over the domain [0, 1]x[0, 1]).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(toydata)
</code></pre>


<h3>Author(s)</h3>

<p>Joshua French</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(toydata)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
