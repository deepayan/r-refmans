<!DOCTYPE html><html lang="en"><head><title>Help for package pROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pROC-package'><p>pROC</p></a></li>
<li><a href='#are.paired'>
<p>Are two ROC curves paired?</p></a></li>
<li><a href='#aSAH'>
<p>Subarachnoid hemorrhage data</p></a></li>
<li><a href='#auc'>
<p>Compute the area under the ROC curve</p></a></li>
<li><a href='#ci'>
<p>Compute the confidence interval of a ROC curve</p></a></li>
<li><a href='#ci.auc'>
<p>Compute the confidence interval of the AUC</p></a></li>
<li><a href='#ci.coords'>
<p>Compute the confidence interval of arbitrary coordinates</p></a></li>
<li><a href='#ci.se'>
<p>Compute the confidence interval of sensitivities at given specificities</p></a></li>
<li><a href='#ci.sp'>
<p>Compute the confidence interval of specificities at given sensitivities</p></a></li>
<li><a href='#ci.thresholds'>
<p>Compute the confidence interval of thresholds</p></a></li>
<li><a href='#coords'>
<p>Coordinates of a ROC curve</p></a></li>
<li><a href='#coords_transpose'><p>Transposing the output of <code>coords</code></p></a></li>
<li><a href='#cov.roc'>
<p>Covariance of two paired ROC curves</p></a></li>
<li><a href='#ggroc.roc'>
<p>Plot a ROC curve with ggplot2</p></a></li>
<li><a href='#groupGeneric'>
<p>pROC Group Generic Functions</p></a></li>
<li><a href='#has.partial.auc'>
<p>Does the ROC curve have a partial AUC?</p></a></li>
<li><a href='#lines.roc'>
<p>Add a ROC line to a ROC plot</p></a></li>
<li><a href='#multiclass.roc'>
<p>Multi-class AUC</p></a></li>
<li><a href='#plot.ci'>
<p>Plot confidence intervals</p></a></li>
<li><a href='#plot.roc'>
<p>Plot a ROC curve</p></a></li>
<li><a href='#power.roc.test'>
<p>Sample size and power computation for ROC curves</p></a></li>
<li><a href='#print'>
<p>Print a ROC curve object</p></a></li>
<li><a href='#roc'>
<p>Build a ROC curve</p></a></li>
<li><a href='#roc.test'>
<p>Compare two ROC curves</p></a></li>
<li><a href='#smooth'>
<p>Smooth a ROC curve</p></a></li>
<li><a href='#var.roc'>
<p>Variance of a ROC curve</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Display and Analyze ROC Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>1.18.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-01</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, plyr, Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>microbenchmark, tcltk, MASS, logcondens, doParallel,
testthat, vdiffr, ggplot2, rlang</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for visualizing, smoothing and comparing receiver operating characteristic (ROC curves). (Partial) area under the curve (AUC) can be compared with statistical tests based on U-statistics or bootstrap. Confidence intervals can be computed for (p)AUC or ROC curves.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://xrobin.github.io/pROC/">https://xrobin.github.io/pROC/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/xrobin/pROC/issues">https://github.com/xrobin/pROC/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-01 09:04:05 UTC; xavier</td>
</tr>
<tr>
<td>Author:</td>
<td>Xavier Robin <a href="https://orcid.org/0000-0002-6813-3200"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Natacha Turck [aut],
  Alexandre Hainard [aut],
  Natalia Tiberti [aut],
  Frédérique Lisacek [aut],
  Jean-Charles Sanchez [aut],
  Markus Müller [aut],
  Stefan Siegert [ctb] (Fast DeLong code),
  Matthias Doering [ctb] (Hand &amp; Till Multiclass),
  Zane Billings [ctb] (DeLong paired test CI)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xavier Robin &lt;pROC-cran@xavier.robin.name&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-01 17:50:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='pROC-package'>pROC</h2><span id='topic+pROC-package'></span><span id='topic+pROC'></span>

<h3>Description</h3>

<p>Tools for visualizing, smoothing and comparing receiver operating
characteristic (ROC curves). (Partial) area under the curve (AUC) can
be compared with statistical tests based on U-statistics or
bootstrap. Confidence intervals can be computed for (p)AUC or ROC
curves. Sample size / power computation for one or two ROC curves are available.
</p>


<h3>Details</h3>

<p>The basic unit of the pROC package is the <code><a href="#topic+roc">roc</a></code> function. It
will build a ROC curve, smooth it if requested (if <code>smooth=TRUE</code>),
compute the AUC (if <code>auc=TRUE</code>), the confidence interval (CI) if 
requested (if <code>ci=TRUE</code>) and plot the curve if requested (if
<code>plot=TRUE</code>). 
</p>
<p>The <code><a href="#topic+roc">roc</a></code> function will call <code><a href="#topic+smooth.roc">smooth</a></code>,
<code><a href="#topic+auc">auc</a></code>,
<code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+plot">plot</a></code> as necessary. See these
individual functions for the arguments that can be passed to them
through <code><a href="#topic+roc">roc</a></code>. These function can be called separately.
</p>
<p>Two paired (that is <code><a href="#topic+roc">roc</a></code> objects with the same
<code>response</code>) or unpaired (with different <code>response</code>) ROC
curves can be compared with the <code><a href="#topic+roc.test">roc.test</a></code> function.
</p>


<h3>Citation</h3>

<p>If you use pROC in published research, please cite the following paper:
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, Natalia Tiberti,
Frédérique Lisacek, Jean-Charles Sanchez and Markus Müller (2011).
&ldquo;pROC: an open-source package for R and S+ to analyze and compare ROC
curves&rdquo;. <em>BMC Bioinformatics</em>, <b>12</b>, p. 77. DOI: 
doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>
</p>
<p>Type <code>citation("pROC")</code> for a BibTeX entry.
</p>
<p>The authors would be glad to hear how pROC is employed. You are kindly
encouraged to notify Xavier Robin &lt;pROC-cran@xavier.robin.name&gt;
about any work you publish.
</p>


<h3>Abbreviations</h3>

<p>The following abbreviations are employed extensively in this package:
</p>

<ul>
<li><p> ROC: receiver operating characteristic
</p>
</li>
<li><p> AUC: area under the ROC curve
</p>
</li>
<li><p> pAUC: partial area under the ROC curve
</p>
</li>
<li><p> CI: confidence interval
</p>
</li>
<li><p> SP: specificity
</p>
</li>
<li><p> SE: sensitivity
</p>
</li></ul>



<h3>Functions</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+roc">roc</a></code> </td><td style="text-align: left;"> Build a ROC curve</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+are.paired">are.paired</a></code> </td><td style="text-align: left;"> Dertermine if two ROC curves are paired </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+auc">auc</a></code> </td><td style="text-align: left;"> Compute the area under the ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ci">ci</a></code> </td><td style="text-align: left;"> Compute confidence intervals of a ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ci.auc">ci.auc</a></code> </td><td style="text-align: left;"> Compute the CI of the AUC </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ci.coords">ci.coords</a></code> </td><td style="text-align: left;"> Compute the CI of arbitrary coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ci.se">ci.se</a></code> </td><td style="text-align: left;"> Compute the CI of sensitivities at given specificities </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ci.sp">ci.sp</a></code> </td><td style="text-align: left;"> Compute the CI of specificities at given sensitivities </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ci.thresholds">ci.thresholds</a></code> </td><td style="text-align: left;"> Compute the CI of specificity and sensitivity of thresholds </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ci.coords">ci.coords</a></code> </td><td style="text-align: left;"> Compute the CI of arbitrary coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+coords">coords</a></code> </td><td style="text-align: left;"> Coordinates of the ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cov.roc">cov</a></code> </td><td style="text-align: left;"> Covariance between two AUCs</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ggroc">ggroc</a></code> </td><td style="text-align: left;"> Plot a ROC curve with <span class="pkg">ggplot2</span></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+has.partial.auc">has.partial.auc</a></code> </td><td style="text-align: left;"> Determine if the ROC curve have a partial AUC</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lines.roc">lines.roc</a></code> </td><td style="text-align: left;"> Add a ROC line to a ROC plot </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.ci">plot.ci</a></code> </td><td style="text-align: left;"> Plot CIs </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.roc">plot</a></code> </td><td style="text-align: left;"> Plot a ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+power.roc.test">power.roc.test</a></code> </td><td style="text-align: left;"> Sample size and power computation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+print.roc">print</a></code> </td><td style="text-align: left;"> Print a ROC curve object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+roc.test">roc.test</a></code> </td><td style="text-align: left;"> Compare two ROC curves </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+smooth.roc">smooth</a></code> </td><td style="text-align: left;"> Smooth a ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+var.roc">var</a></code> </td><td style="text-align: left;"> Variance of the AUC
  </td>
</tr>

</table>



<h3>Dataset</h3>

<p>This package comes with a dataset of 141 patients with aneurysmal
subarachnoid hemorrhage: <code><a href="#topic+aSAH">aSAH</a></code>.
</p>


<h3>Installing and using</h3>

<p>To install this package, make sure you are connected to the internet and issue the following command in the R prompt:
</p>
<pre>
    install.packages("pROC")
  </pre>
<p>To load the package in R:
</p>
<pre>
    library(pROC)
  </pre>


<h3>Experimental: pipelines</h3>

<p>Since version 1.15.0, the <code><a href="#topic+roc">roc</a></code> function can be used in pipelines, for instance with <span class="pkg">dplyr</span> or <span class="pkg">magrittr</span>. This is still a highly experimental feature and will change significantly in future versions  (see <a href="https://github.com/xrobin/pROC/issues/54">issue 54</a>).
The <code><a href="#topic+roc.data.frame">roc.data.frame</a></code> method supports both standard and non-standard evaluation (NSE), and the <code><a href="#topic+roc_">roc_</a></code>
function supports standard evaluation only.
</p>
<pre>
library(dplyr)
aSAH %&gt;% 
    filter(gender == "Female") %&gt;%
    roc(outcome, s100b)
	</pre>
<p>By default it returns the <code><a href="#topic+roc">roc</a></code> object, which can then be piped to
the <code><a href="#topic+coords">coords</a></code> function to extract coordinates that can be used
in further pipelines.
</p>
<pre>
aSAH %&gt;% 
    filter(gender == "Female") %&gt;%
    roc(outcome, s100b) %&gt;%
    coords(transpose=FALSE) %&gt;%
    filter(sensitivity &gt; 0.6, 
           specificity &gt; 0.6)
	</pre>
<p>More details and use cases are available in the <code><a href="#topic+roc">roc</a></code> help page.
</p>


<h3>Bootstrap</h3>

<p>All the bootstrap operations for <a href="#topic+roc.test">significance testing</a>, <a href="#topic+ci">confidence interval</a>, <a href="#topic+var">variance</a> and <a href="#topic+cov">covariance</a> computation are performed with non-parametric stratified or non-stratified resampling (according to the <code>stratified</code> argument) and with the percentile method, as described in Carpenter and Bithell (2000) sections 2.1 and 3.3.
</p>
<p>Stratification of bootstrap can be controlled
with <code>boot.stratified</code>. In stratified bootstrap (the default), each replicate
contains the same number of cases and controls than the original
sample. Stratification is especially useful if one group has only
little observations, or if groups are not balanced.
</p>
<p>The number of bootstrap replicates is controlled by <code>boot.n</code>. Higher numbers will give a more precise estimate of the significance tests and confidence intervals
but take more time to compute. 2000 is recommanded by Carpenter and Bithell (2000) for confidence intervals. In our experience this is sufficient for a good estimation of the 
first significant digit only, so we recommend the use of 10000 bootstrap replicates to obtain a good estimate of the second significant digit whenever possible.
</p>


<h4>Progress bars</h4>

<p>A progressbar shows the progress of bootstrap operations. It is handled by the <span class="pkg">plyr</span> package (Wickham, 2011),
and is created by the <code>progress_*</code> family of functions.
Sensible defaults are guessed during the package loading:
</p>

<ul>
<li><p> In non-<a href="base.html#topic+interactive">interactive</a> mode, no progressbar is displayed.
</p>
</li>
<li><p> In embedded GNU Emacs &ldquo;ESS&rdquo;, a <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>
</p>
</li>
<li><p> In Windows, a <code><a href="utils.html#topic+winProgressBar">winProgressBar</a></code> bar.
</p>
</li>
<li><p> In Windows, a <code>winProgressBar</code> bar.
</p>
</li>
<li><p> In other systems with or without a graphical display, a <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.
</p>
</li></ul>

<p>The default can be changed with the option &ldquo;pROCProgress&rdquo;. The option must be a list with
a <code>name</code> item setting the type of progress bar (&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo;
or &ldquo;text&rdquo;). Optional items of the list are &ldquo;width&rdquo;, &ldquo;char&rdquo; and &ldquo;style&rdquo;,
corresponding to the arguments to the underlying progressbar functions.
For example, to force a text progress bar:
</p>
<pre>options(pROCProgress = list(name = "text", width = NA, char = "=", style = 3)</pre>
<p>To inhibit the progress bars completely:
</p>
<pre>options(pROCProgress = list(name = "none"))</pre>



<h3>Handling large datasets</h3>



<h4>Algorithms</h4>

<p>Over the years, a significant amount of time has been invested in making pROC run faster and faster.
From the naive algorithm iterating over all thresholds implemented in the first version (<code>algorithm = 1</code>), we went to a
C++ implementation (with <span class="pkg">Rcpp</span>, <code>algorithm = 3</code>), and a different algorithm using cummulative sum of responses sorted 
by the predictor, which scales only with the number of data points, independently on the number of thresholds (<code>algorithm = 2</code>).
The curves themselves are identical, but computation time has been decreased massively.
</p>
<p>Since version 1.12, pROC was able to automatically select the fastest algorithm for your dataset based on the number of thresholds of the ROC curve.
Initially this number was around 1500 thresholds, above which algorithm 3 was selected. But with pROC 1.15 additional code profiling
enabled us implement additional speedups that brought this number down to less than 100 thresholds. 
As the detection of the number of thresholds itself can have a large impact comparatively (up to 10% now), a new <code>algorithm = 6</code>
was implemented, which assumes that <code><a href="base.html#topic+ordered">ordered</a></code> datasets should have relatively few levels, and hence thresholds. These predictors
are processed with <code>algorithm = 3</code>. Any numeric dataset is now assumed to have a sufficient number of thresholds 
to be processed with <code>algorithm = 2</code> efficiently. In the off-chance that you have a very large numeric dataset with very few thresholds,
<code>algorithm = 3</code> can be selected manually (in the call to <code><a href="#topic+roc">roc</a></code>). For instance with 5 thresholds you can
expect a speedup of around to 3 times. This effect disappears altogether as soon as the curve gets to 50-100 thresholds.
</p>
<p>This simple selection should work in most cases. However if you are unsure or want to test it for yourself, use <code>algorithm=0</code> to run a quick benchmark between 2 and 3. Make sure <span class="pkg">microbenchmark</span> is installed. Beware, this is very slow as it will repeat the computation 10 times to obtain a decent estimate of each algorithm speed.
</p>
<pre>
if (!requireNamespace("microbenchmark")) install.packages("microbenchmark")

# First a ROC curve with many thresholds. Algorithm 2 is much faster.
response &lt;- rbinom(5E3, 1, .5)
predictor &lt;- rnorm(5E3)
rocobj &lt;- roc(response, predictor, algorithm = 0)


# Next a ROC curve with few thresholds but more data points
response &lt;- rbinom(1E6, 1, .5)
predictor &lt;- rpois(1E6, 1)
rocobj &lt;- roc(response, predictor, algorithm = 0)
    </pre>

<p>Other functions have been optimized too, and bottlenecks removed. In particular, the <code>coords</code> function is orders of magnitude faster in pROC 1.15.
The DeLong algorithm has been improved in versions 1.6, 1.7 and 1.9.1, and currently uses a much more efficient algorithm, both
in computation time and memory footprint. We will keep working on improvements to make pROC more suited to large datasets in the future.
</p>


<h4>Boostrap</h4>

<p>Bootstrap is typically slow because it involves repeatedly computing the ROC curve (or a part of it).
</p>
<p>Some bootstrap functions are faster than others. Typically, <code><a href="#topic+ci.thresholds">ci.thresholds</a></code> is the fastest, and <code><a href="#topic+ci.coords">ci.coords</a></code> the slowest. Use <code><a href="#topic+ci.coords">ci.coords</a></code> only if the CI you need cannot be computed by the specialized CI functions <code><a href="#topic+ci.thresholds">ci.thresholds</a></code>, <code><a href="#topic+ci.se">ci.se</a></code> and <code><a href="#topic+ci.sp">ci.sp</a></code>. Note that <code><a href="#topic+ci.auc">ci.auc</a></code> cannot be replaced anyway.
</p>
<p>A naive way to speed-up the boostrap is by removing the progress bar:
</p>
<pre>
rocobj &lt;- roc(response, round(predictor))
system.time(ci(rocobj))
system.time(ci(rocobj, progress = "none"))
    </pre>
<p>It is of course possible to reduce the number of boostrap iterations. See the <code>boot.n</code> argument to <code><a href="#topic+ci">ci</a></code>. This will reduce the precision of the bootstrap estimate.
</p>


<h5>Parallel processing</h5>

<p>Bootstrap operations can be performed in parallel. The backend provided by the <span class="pkg">plyr</span> package is used, which in turn relies on the <span class="pkg">foreach</span> package.
</p>
<p>To enable parallell processing, you first need to load an adaptor for the <span class="pkg">foreach</span> package (<span class="pkg">doMC</span>, <span class="pkg">doMPI</span>, <span class="pkg">doParallel</span>, <span class="pkg">doRedis</span>, <span class="pkg">doRNG</span> or <span class="pkg">doSNOW</span>)), register the backend, and set <code>parallel=TRUE</code>. 
</p>
<pre>
library(doParallel)
registerDoParallel(cl &lt;- makeCluster(getOption("mc.cores", 2)))
ci(rocobj, method="bootstrap", parallel=TRUE)
stopCluster(cl)
  		</pre>
<p>Progress bars are not available when parallel processing is enabled.
</p>




<h4>Using DeLong instead of boostrap</h4>

<p>DeLong is an asymptotically exact method to evaluate the uncertainty of an AUC (DeLong <em>et al.</em> (1988)). Since version 1.9, pROC uses the algorithm proposed by Sun and Xu (2014) which has an O(N log N) complexity and is always faster than bootstrapping. By default, pROC will choose the DeLong method whenever possible.
</p>
<pre>
rocobj &lt;- roc(response, round(predictor), algorithm=3)
system.time(ci(rocobj, method="delong"))
system.time(ci(rocobj, method="bootstrap", parallel = TRUE))
    </pre>



<h3>Author(s)</h3>

<p>Xavier Robin, Natacha Turck, Jean-Charles Sanchez and Markus Müller
</p>
<p>Maintainer: Xavier Robin &lt;pROC-cran@xavier.robin.name&gt;
</p>


<h3>References</h3>

<p>James Carpenter and John Bithell (2000) &ldquo;Bootstrap condence intervals:
when, which, what? A practical guide for medical statisticians&rdquo;.
<em>Statistics in Medicine</em> <b>19</b>, 1141&ndash;1164.
DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F">10.1002/(SICI)1097-0258(20000515)19:9&lt;1141::AID-SIM479&gt;3.0.CO;2-F</a>.
</p>
<p>Elisabeth R. DeLong, David M. DeLong and Daniel L. Clarke-Pearson
(1988) &ldquo;Comparing the areas under two or more correlated receiver
operating characteristic curves: a nonparametric
approach&rdquo;. <em>Biometrics</em> <b>44</b>, 837&ndash;845.
</p>
<p>Tom Fawcett (2006) &ldquo;An introduction to ROC analysis&rdquo;. <em>Pattern
Recognition Letters</em> <b>27</b>, 861&ndash;874. DOI:
doi: <a href="https://doi.org/10.1016/j.patrec.2005.10.010">10.1016/j.patrec.2005.10.010</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>Xu Sun and Weichao Xu (2014) &ldquo;Fast Implementation of DeLongs Algorithm for Comparing
the Areas Under Correlated Receiver Operating Characteristic Curves&rdquo;. <em>IEEE Signal
Processing Letters</em>, <b>21</b>, 1389&ndash;1393. 
DOI: doi: <a href="https://doi.org/10.1109/LSP.2014.2337313">10.1109/LSP.2014.2337313</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p>CRAN packages <span class="pkg">ROCR</span>, <span class="pkg">verification</span> or Bioconductor's <span class="pkg">roc</span>
for ROC curves.
</p>
<p>CRAN packages <span class="pkg">plyr</span>, <span class="pkg">MASS</span> and <span class="pkg">logcondens</span> employed in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

## Build a ROC object and compute the AUC ##
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)
print(roc1)

# With a formula
roc(outcome ~ s100b, aSAH)
# With pipes, dplyr-style:
## Not run: 
library(dplyr)
aSAH %&gt;% roc(outcome, s100b)
## End(Not run)

# Create a few more curves for the next examples
roc2 &lt;- roc(aSAH$outcome, aSAH$wfns)
roc3 &lt;- roc(aSAH$outcome, aSAH$ndka)


## AUC ##
auc(roc1, partial.auc = c(1, .9))


## Smooth ROC curve ##
smooth(roc1)


## Summary statistics
var(roc1)
cov(roc1, roc3)


## Plot the curve ##
plot(roc1)

#  More plotting options, CI and plotting
# with all-in-one syntax:
roc4 &lt;- roc(aSAH$outcome,
            aSAH$s100b, percent=TRUE,
            # arguments for auc
            partial.auc=c(100, 90), partial.auc.correct=TRUE,
            partial.auc.focus="sens",
            # arguments for ci
            ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
            # arguments for plot
            plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
            print.auc=TRUE, show.thres=TRUE)

# Add to an existing plot. Beware of 'percent' specification!
roc5 &lt;- roc(aSAH$outcome, aSAH$wfns,
            plot=TRUE, add=TRUE, percent=roc4$percent)


## With ggplot2 ##
if (require(ggplot2)) {
# Create multiple curves to plot
rocs &lt;- roc(outcome ~ wfns + s100b + ndka, data = aSAH)
ggroc(rocs)
}


## Coordinates of the curve ##
coords(roc1, "best", ret=c("threshold", "specificity", "1-npv"))
coords(roc2, "local maximas", ret=c("threshold", "sens", "spec", "ppv", "npv"))


## Confidence intervals ##

# CI of the AUC
ci(roc2)

## Not run: 
# CI of the curve
sens.ci &lt;- ci.se(roc1, specificities=seq(0, 100, 5))
plot(sens.ci, type="shape", col="lightblue")
plot(sens.ci, type="bars")
## End(Not run)

# need to re-add roc2 over the shape
plot(roc2, add=TRUE)

## Not run: 
# CI of thresholds
plot(ci.thresholds(roc2))
## End(Not run)

# In parallel
if (require(doParallel)) {
    registerDoParallel(cl &lt;- makeCluster(getOption("mc.cores", 2L)))
    ## Not run: ci(roc2, method="bootstrap", parallel=TRUE)
    
    stopCluster(cl)
}


## Comparisons ##

# Test on the whole AUC
roc.test(roc1, roc2, reuse.auc=FALSE)

## Not run: 
# Test on a portion of the whole AUC
roc.test(roc1, roc2, reuse.auc=FALSE, partial.auc=c(100, 90),
         partial.auc.focus="se", partial.auc.correct=TRUE)

# With modified bootstrap parameters
roc.test(roc1, roc2, reuse.auc=FALSE, partial.auc=c(100, 90),
         partial.auc.correct=TRUE, boot.n=1000, boot.stratified=FALSE)
## End(Not run)


## Power &amp; sample size ##

# Power
# 1 curve
power.roc.test(roc1)
# 2 curves
power.roc.test(roc3, roc2)

# Sample size 
# 1 curve
power.roc.test(roc3, power = 0.9)
# 2 curves
power.roc.test(roc1, roc2, power = 0.9)

# Also without ROC objects.
# For instance what AUC would be significantly different from 0.5?
power.roc.test(ncases=41, ncontrols=72, sig.level=0.05, power=0.95)
</code></pre>

<hr>
<h2 id='are.paired'>
Are two ROC curves paired?
</h2><span id='topic+are.paired'></span><span id='topic+are.paired.smooth.roc'></span><span id='topic+are.paired.auc'></span><span id='topic+are.paired.roc'></span>

<h3>Description</h3>

<p>This function determines if two ROC curves can be paired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are.paired(...)
## S3 method for class 'auc'
are.paired(roc1, roc2, ...)
## S3 method for class 'smooth.roc'
are.paired(roc1, roc2, ...)
## S3 method for class 'roc'
are.paired(roc1, roc2, return.paired.rocs=FALSE,
  reuse.auc = TRUE, reuse.ci = FALSE, reuse.smooth=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="are.paired_+3A_roc1">roc1</code>, <code id="are.paired_+3A_roc2">roc2</code></td>
<td>
<p>the two ROC curves to compare. Either
&ldquo;<a href="#topic+roc">roc</a>&rdquo;, &ldquo;<a href="#topic+auc">auc</a>&rdquo; or
&ldquo;<a href="#topic+smooth.roc">smooth.roc</a>&rdquo; objects (types can be mixed).
</p>
</td></tr>
<tr><td><code id="are.paired_+3A_return.paired.rocs">return.paired.rocs</code></td>
<td>
<p>if <code>TRUE</code> and the ROC curves can be
paired, the two paired ROC curves with <code>NA</code>s removed will be
returned.
</p>
</td></tr>
<tr><td><code id="are.paired_+3A_reuse.auc">reuse.auc</code>, <code id="are.paired_+3A_reuse.ci">reuse.ci</code>, <code id="are.paired_+3A_reuse.smooth">reuse.smooth</code></td>
<td>

<p>if <code>return.paired.rocs=TRUE</code>, determines if <code><a href="#topic+auc">auc</a></code>,
<code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+smooth.roc">smooth</a></code> should be re-computed
(with the same parameters than the original ROC curves)
</p>
</td></tr>
<tr><td><code id="are.paired_+3A_...">...</code></td>
<td>
<p>additionnal arguments for <code>are.paired.roc</code>. Ignored
in <code>are.paired.roc</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two ROC curves are paired if they are built on two variables observed
on the same sample.
</p>
<p>In practice, the paired status is granted if the <code>response</code> and <code>levels</code> vector
of both ROC curves are <a href="base.html#topic+identical">identical</a>. If the <code>response</code>s are different, this can be
due to missing values differing between the curves. In this case, the
function will strip all <code>NA</code>s in both curves and check for
identity again.
</p>
<p>It can raise false positives if the responses are identical but correspond
to different patients.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>roc1</code> and <code>roc2</code> are paired, <code>FALSE</code>
otherwise. 
</p>
<p>In addition, if <code>TRUE</code> and <code>return.paired.rocs=TRUE</code>, the
following atributes are defined:
</p>
<table role = "presentation">
<tr><td><code>roc1</code>, <code>roc2</code></td>
<td>
<p>the two ROC curve with all <code>NA</code>s values removed
in both curves.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+roc.test">roc.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)
aSAH.copy &lt;- aSAH

# artificially insert NAs for demonstration purposes
aSAH.copy$outcome[42] &lt;- NA
aSAH.copy$s100b[24] &lt;- NA
aSAH.copy$ndka[1:10] &lt;- NA

# Call roc() on the whole data
roc1 &lt;- roc(aSAH.copy$outcome, aSAH.copy$s100b)
roc2 &lt;- roc(aSAH.copy$outcome, aSAH.copy$ndka)
# are.paired can still find that the curves were paired
are.paired(roc1, roc2) # TRUE

# Removing the NAs manually before passing to roc() un-pairs the ROC curves
nas &lt;- is.na(aSAH.copy$outcome) | is.na(aSAH.copy$ndka)
roc2b &lt;- roc(aSAH.copy$outcome[!nas], aSAH.copy$ndka[!nas])
are.paired(roc1, roc2b) # FALSE

# Getting the two paired ROC curves with additional smoothing and ci options
roc2$ci &lt;- ci(roc2)
paired &lt;- are.paired(smooth(roc1), roc2, return.paired.rocs=TRUE, reuse.ci=TRUE)
paired.roc1 &lt;- attr(paired, "roc1")
paired.roc2 &lt;- attr(paired, "roc2")

</code></pre>

<hr>
<h2 id='aSAH'>
Subarachnoid hemorrhage data
</h2><span id='topic+aSAH'></span>

<h3>Description</h3>

<p>This dataset summarizes several clinical and one laboratory variable
of 113 patients with an aneurysmal subarachnoid hemorrhage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aSAH</code></pre>


<h3>Format</h3>

<p>A data.frame containing 113 observations of 7 variables.</p>


<h3>Source</h3>

<p>Natacha Turck, Laszlo Vutskits, Paola Sanchez-Pena, Xavier
Robin, Alexandre Hainard, Marianne Gex-Fabry, Catherine Fouda, Hadiji
Bassem, Markus Mueller, Frédérique Lisacek, Louis Puybasset and
Jean-Charles Sanchez (2010) &ldquo;A multiparameter panel method for outcome
prediction following aneurysmal subarachnoid hemorrhage&rdquo;.
<em>Intensive Care Medicine</em> <b>36</b>(1), 107&ndash;115. DOI:
doi: <a href="https://doi.org/10.1007/s00134-009-1641-y">10.1007/s00134-009-1641-y</a>.
</p>


<h3>See Also</h3>

<p>Other examples can be found in all the documentation pages of this
package: 
<code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code>,
<code><a href="#topic+ci.auc">ci.auc</a></code>, <code><a href="#topic+ci.se">ci.se</a></code>, <code><a href="#topic+ci.sp">ci.sp</a></code>,
<code><a href="#topic+ci.thresholds">ci.thresholds</a></code>, <code><a href="#topic+coords">coords</a></code>,
<code><a href="#topic+plot.ci">plot.ci</a></code>, <code><a href="#topic+plot.roc">plot.roc</a></code>,
<code><a href="#topic+print.roc">print.roc</a></code>, <code><a href="#topic+roc.test">roc.test</a></code> and
<code><a href="#topic+smooth">smooth</a></code>.
</p>
<p>An example analysis with pROC is shown in:
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(aSAH)

# Gender, outcome and set
with(aSAH, table(gender, outcome))

# Age
with(aSAH, by(age, outcome, mean))
with(aSAH, by(age, outcome,
     function(x) sprintf("mean: %.1f (+/- %.1f), median: %.1f (%i-%i)",
                         mean(x), sd(x), median(x), min(x), max(x))))

# WFNS score
with(aSAH, table(wfns=ifelse(wfns&lt;=2, "1-2", "3-4-5"), outcome))

</code></pre>

<hr>
<h2 id='auc'>
Compute the area under the ROC curve
</h2><span id='topic+auc'></span><span id='topic+auc.default'></span><span id='topic+auc.formula'></span><span id='topic+auc.roc'></span><span id='topic+auc.smooth.roc'></span><span id='topic+auc.multiclass.roc'></span>

<h3>Description</h3>

<p>This function computes the numeric value of area under the ROC curve
(AUC) with the trapezoidal rule. Two syntaxes are possible: one object of class &ldquo;<a href="#topic+roc">roc</a>&rdquo;, or either
two vectors (response, predictor) or a formula (response~predictor) as
in the <code><a href="#topic+roc">roc</a></code> function.
By default, the total AUC is computed, but a portion of the ROC curve
can be specified with <code>partial.auc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(...)
## S3 method for class 'roc'
auc(roc, partial.auc=FALSE, partial.auc.focus=c("specificity",
"sensitivity"), partial.auc.correct=FALSE, 
allow.invalid.partial.auc.correct = FALSE, ...)
## S3 method for class 'smooth.roc'
auc(smooth.roc, ...)
## S3 method for class 'multiclass.roc'
auc(multiclass.roc, ...)
## S3 method for class 'formula'
auc(formula, data, ...)
## Default S3 method:
auc(response, predictor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc_+3A_roc">roc</code>, <code id="auc_+3A_smooth.roc">smooth.roc</code>, <code id="auc_+3A_multiclass.roc">multiclass.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function, or a &ldquo;multiclass.roc&rdquo;
or &ldquo;mv.multiclass.roc&rdquo; from the <code><a href="#topic+multiclass.roc">multiclass.roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="auc_+3A_response">response</code>, <code id="auc_+3A_predictor">predictor</code></td>
<td>
<p>arguments for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="auc_+3A_formula">formula</code>, <code id="auc_+3A_data">data</code></td>
<td>
<p>a formula (and possibly a data object) of type response~predictor for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="auc_+3A_partial.auc">partial.auc</code></td>
<td>
<p>either <code>FALSE</code> (default: consider total area) or a
numeric vector of length 2: boundaries of the AUC to consider in
[0,1] (or [0,100] if percent is <code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="auc_+3A_partial.auc.focus">partial.auc.focus</code></td>
<td>
<p>if <code>partial.auc</code> is not <code>FALSE</code> and a partial
AUC is computed, specifies if <code>partial.auc</code> specifies the bounds in
terms of specificity (default) or sensitivity. Can be shortened to spec/sens
or even sp/se. Ignored if <code>partial.auc=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="auc_+3A_partial.auc.correct">partial.auc.correct</code></td>
<td>
<p>logical indicating if the correction of
AUC must be applied in order to have a maximal AUC of 1.0 and a
non-discriminant AUC of 0.5 whatever the <code>partial.auc</code>
defined. Ignored if <code>partial.auc=FALSE</code>. Default: <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="auc_+3A_allow.invalid.partial.auc.correct">allow.invalid.partial.auc.correct</code></td>
<td>
<p>logical indicating if
the correction must return <code>NA</code> (with a <code><a href="base.html#topic+warning">warning</a></code>)
when attempting to correct a pAUC below the diagonal.
Set to <code>TRUE</code> to return a (probably invalid) corrected AUC.
This is useful especially to avoid introducing a bias against low
pAUCs in bootstrap operations.</p>
</td></tr>
<tr><td><code id="auc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> when calling
<code>auc.default</code>, <code>auc.formula</code>, <code>auc.smooth.roc</code>.
Note that the <code>auc</code>
argument of <code><a href="#topic+roc">roc</a></code> is not allowed. Unused in
<code>auc.roc</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically called from <code><a href="#topic+roc">roc</a></code> when <code>auc=TRUE</code>
(default). It is also used by <code><a href="#topic+ci">ci</a></code>. When it is called with
two vectors (response, predictor) or a formula (response~predictor)
arguments, the <code><a href="#topic+roc">roc</a></code> function is called and only the AUC is
returned.
</p>
<p>By default the total area under the curve is computed, but a partial AUC (pAUC)
can be
specified with the <code>partial.auc</code> argument. It specifies the bounds of
specificity or sensitivity (depending on <code>partial.auc.focus</code>) between
which the AUC will be computed. As it specifies specificities or
sensitivities, you must adapt it in relation to the 'percent'
specification (see details in <code><a href="#topic+roc">roc</a></code>).
</p>
<p><code>partial.auc.focus</code> is ignored if
<code>partial.auc=FALSE</code> (default). If a partial AUC is computed,
<code>partial.auc.focus</code> specifies if the bounds specified in
<code>partial.auc</code> must be interpreted as sensitivity or
specificity. Any other value will produce an error. It is recommended to
<code><a href="#topic+plot.roc">plot</a></code> the ROC curve with <code>auc.polygon=TRUE</code> in order to 
make sure the specification is correct.
</p>
<p>If a pAUC is defined, it can be standardized (corrected). This correction is 
controled by the <code>partial.auc.correct</code> argument. If <code>partial.auc.correct=TRUE</code>,
the correction by McClish will be applied:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1+\frac{auc-min}{max-min}}{2}</code>
</p>

<p>where auc is the uncorrected pAUC computed in the region defined by <code>partial.auc</code>,
min is the value of the non-discriminant AUC (with an AUC of 0.5 or 50
in the region and max is the maximum possible AUC in the region. With this correction, the AUC
will be 0.5 if non discriminant and 1.0 if maximal, whatever the region
defined. This correction is fully compatible with <code>percent</code>.
</p>
<p>Note that this correction is undefined for curves below the diagonal (auc &lt; min). Attempting
to correct such an AUC will return <code>NA</code> with a warning.
</p>


<h3>Value</h3>

<p>The numeric AUC value, of class <code>c("auc", "numeric")</code> (or
<code>c("multiclass.auc", "numeric")</code> or <code>c("mv.multiclass.auc", "numeric")</code>
if a &ldquo;multiclass.roc&rdquo; was supplied), in
fraction of the area or in percent if <code>percent=TRUE</code>, with the
following attributes:
</p>
<table role = "presentation">
<tr><td><code>partial.auc</code></td>
<td>
<p>if the AUC is full (FALSE) or partial (and in this
case the bounds), as defined in argument.</p>
</td></tr>
<tr><td><code>partial.auc.focus</code></td>
<td>
<p>only for a partial AUC, if the bound specifies
the sensitivity or specificity, as defined in argument.</p>
</td></tr>
<tr><td><code>partial.auc.correct</code></td>
<td>
<p>only for a partial AUC, was it corrected?
As defined in argument.</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>whether the AUC is given in percent or fraction.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>the original ROC curve, as a &ldquo;<a href="#topic+roc">roc</a>&rdquo;,
&ldquo;<a href="#topic+smooth.roc">smooth.roc</a>&rdquo; or &ldquo;<a href="#topic+multiclass.roc">multiclass.roc</a>&rdquo; object.</p>
</td></tr>
</table>


<h3>Smoothed ROC curves</h3>

<p>There is no difference in the computation of the area under a smoothed
ROC curve, except for curves smoothed with <code>method="binomial"</code>. In this case
and only if a full AUC is requested, the classical binormal AUC formula is applied:
</p>
<p style="text-align: center;"><code class="reqn">auc=\phi\frac{a}{\sqrt{1 + b^2}}.</code>
</p>

<p>If the ROC curve is smoothed with any other <code>method</code> or if a partial AUC
is requested, the empirical AUC described in the previous section is applied.
</p>


<h3>Multi-class AUCs</h3>

<p>With an object of class &ldquo;multiclass.roc&rdquo;, a multi-class AUC is
computed as an average AUC as defined by Hand and Till (equation 7).
</p>
<p style="text-align: center;"><code class="reqn">auc=\frac{2}{c(c-1)}\sum{aucs}</code>
</p>

<p>with aucs all the pairwise roc curves.
</p>


<h3>References</h3>

<p>Tom Fawcett (2006) &ldquo;An introduction to ROC analysis&rdquo;. <em>Pattern
Recognition Letters</em> <b>27</b>, 861&ndash;874. DOI:
doi: <a href="https://doi.org/10.1016/j.patrec.2005.10.010">10.1016/j.patrec.2005.10.010</a>.
</p>
<p>David J. Hand and Robert J. Till (2001). A Simple Generalisation of
the Area Under the ROC Curve for Multiple Class Classification
Problems. <em>Machine Learning</em> <b>45</b>(2), p. 171&ndash;186. DOI:
doi: <a href="https://doi.org/10.1023/A:1010920819831">10.1023/A:1010920819831</a>.
</p>
<p>Donna Katzman McClish (1989) &ldquo;Analyzing a Portion of the ROC
Curve&rdquo;. <em>Medical Decision Making</em> <b>9</b>(3), 190&ndash;195. DOI:
doi: <a href="https://doi.org/10.1177/0272989X8900900307">10.1177/0272989X8900900307</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+ci.auc">ci.auc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a ROC curve:
data(aSAH)
roc.s100b &lt;- roc(aSAH$outcome, aSAH$s100b)

# Get the full AUC
auc(roc.s100b)

# Get the partial AUC:
auc(roc.s100b, partial.auc=c(1, .8), partial.auc.focus="se", partial.auc.correct=TRUE)

</code></pre>

<hr>
<h2 id='ci'>
Compute the confidence interval of a ROC curve
</h2><span id='topic+ci'></span><span id='topic+ci.default'></span><span id='topic+ci.formula'></span><span id='topic+ci.roc'></span><span id='topic+ci.smooth.roc'></span><span id='topic+ci.multiclass.roc'></span><span id='topic+ci.multiclass.auc'></span>

<h3>Description</h3>

<p>This function computes the confidence interval (CI) of a ROC curve. The
<code>of</code> argument controls the type of CI that will be computed.
By default, the 95% CI are computed with 2000 stratified bootstrap
replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(...)
## S3 method for class 'roc'
ci(roc, of = c("auc", "thresholds", "sp", "se", "coords"), ...)
## S3 method for class 'smooth.roc'
ci(smooth.roc, of = c("auc", "sp", "se", "coords"), ...)
## S3 method for class 'multiclass.roc'
ci(multiclass.roc, of = "auc", ...)
## S3 method for class 'multiclass.auc'
ci(multiclass.auc, of = "auc", ...)
## S3 method for class 'formula'
ci(formula, data, ...)
## Default S3 method:
ci(response, predictor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_+3A_roc">roc</code>, <code id="ci_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, or a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci_+3A_multiclass.roc">multiclass.roc</code>, <code id="ci_+3A_multiclass.auc">multiclass.auc</code></td>
<td>
<p>not implemented.</p>
</td></tr>
<tr><td><code id="ci_+3A_response">response</code>, <code id="ci_+3A_predictor">predictor</code></td>
<td>
<p>arguments for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci_+3A_formula">formula</code>, <code id="ci_+3A_data">data</code></td>
<td>
<p>a formula (and possibly a data object) of type
response~predictor for the <code><a href="#topic+roc">roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci_+3A_of">of</code></td>
<td>
<p>The type of confidence interval. One of &ldquo;auc&rdquo;,
&ldquo;thresholds&rdquo;, &ldquo;sp&rdquo;, &ldquo;se&rdquo; or &ldquo;coords&rdquo;. Note that
confidence interval on &ldquo;thresholds&rdquo; are not available for
smoothed ROC curves.
</p>
</td></tr>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+roc">roc</a></code>, and the specific
<code>ci</code> functions <code><a href="#topic+ci.auc">ci.auc</a></code>, <code><a href="#topic+ci.se">ci.se</a></code>,
<code><a href="#topic+ci.sp">ci.sp</a></code> and <code><a href="#topic+ci.thresholds">ci.thresholds</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ci.formula</code> and <code>ci.default</code> are convenience methods
that build the ROC curve (with the <code><a href="#topic+roc">roc</a></code> function) before
calling <code>ci.roc</code>. You can pass them arguments for both
<code><a href="#topic+roc">roc</a></code> and <code>ci.roc</code>. Simply use <code>ci</code>
that will dispatch to the correct method.
</p>
<p>This function is typically called from <code><a href="#topic+roc">roc</a></code> when <code>ci=TRUE</code> (not by
default). Depending on the <code>of</code> argument, the specific
<code>ci</code> functions <code><a href="#topic+ci.auc">ci.auc</a></code>, <code><a href="#topic+ci.thresholds">ci.thresholds</a></code>,
<code><a href="#topic+ci.sp">ci.sp</a></code>, <code><a href="#topic+ci.se">ci.se</a></code> or <code><a href="#topic+ci.coords">ci.coords</a></code> are called.
</p>
<p>When the ROC curve has an <code><a href="#topic+auc">auc</a></code> of 1 (or 100%), the confidence interval will always be null
(there is no interval). This is true for both &ldquo;delong&rdquo; and &ldquo;bootstrap&rdquo; methods that can
not properly assess the variance in this case. This result is misleading, as the variance is of course not null.
A <code><a href="base.html#topic+warning">warning</a></code> will be displayed to inform of this condition, and of the misleading output.
</p>
<p>CI of multiclass ROC curves and AUC is not implemented yet. Attempting to call these
methods returns an error.
</p>


<h3>Value</h3>

<p>The return value of the specific <code>ci</code> functions
<code><a href="#topic+ci.auc">ci.auc</a></code>, <code><a href="#topic+ci.thresholds">ci.thresholds</a></code>, <code><a href="#topic+ci.sp">ci.sp</a></code>, <code><a href="#topic+ci.se">ci.se</a></code> or <code><a href="#topic+ci.coords">ci.coords</a></code>, depending on the
<code>of</code> argument.
</p>


<h3>References</h3>

<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci.auc">ci.auc</a></code>,
<code><a href="#topic+ci.thresholds">ci.thresholds</a></code>, <code><a href="#topic+ci.sp">ci.sp</a></code>, <code><a href="#topic+ci.se">ci.se</a></code>, <code><a href="#topic+ci.coords">ci.coords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a ROC curve:
data(aSAH)
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)


## AUC ## 
ci(roc1)
# this is equivalent to:
ci(roc1, of = "auc")
# or:
ci.auc(roc1)


## Coordinates ##
## Not run: 
# Thresholds
ci(roc1, of = "thresholds")
ci(roc1, of = "thresholds", thresholds = "all")
ci(roc1, of = "thresholds", thresholds = 0.51)
# equivalent to:
ci.thresholds(roc1, thresholds = 0.51)

# SE/SP
ci(roc1, of = "sp", sensitivities = c(.95, .9, .85))
ci.sp(roc1)
ci(roc1, of = "se")
ci.se(roc1)

# Arbitrary coordinates
ci(roc1, of = "coords", "best")
ci.coords(roc1, 0.51, "threshold")
## End(Not run)

</code></pre>

<hr>
<h2 id='ci.auc'>
Compute the confidence interval of the AUC
</h2><span id='topic+ci.auc'></span><span id='topic+ci.auc.auc'></span><span id='topic+ci.auc.default'></span><span id='topic+ci.auc.formula'></span><span id='topic+ci.auc.roc'></span><span id='topic+ci.auc.smooth.roc'></span><span id='topic+ci.auc.multiclass.roc'></span><span id='topic+ci.auc.multiclass.auc'></span>

<h3>Description</h3>

<p>This function computes the confidence interval (CI) of an area under
the curve (AUC). By default, the 95% CI is computed with 2000
stratified bootstrap replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># ci.auc(...)
## S3 method for class 'roc'
ci.auc(roc, conf.level=0.95, method=c("delong",
"bootstrap"), boot.n = 2000, boot.stratified = TRUE, reuse.auc=TRUE,
progress = getOption("pROCProgress")$name, parallel=FALSE, ...)
## S3 method for class 'smooth.roc'
ci.auc(smooth.roc, conf.level=0.95, boot.n=2000,
boot.stratified=TRUE, reuse.auc=TRUE,
progress=getOption("pROCProgress")$name, parallel=FALSE, ...)
## S3 method for class 'auc'
ci.auc(auc, ...)
## S3 method for class 'multiclass.roc'
ci.auc(multiclass.roc, ...)
## S3 method for class 'multiclass.auc'
ci.auc(multiclass.auc, ...)
## S3 method for class 'auc'
ci.auc(auc, ...)
## S3 method for class 'formula'
ci.auc(formula, data, ...)
## Default S3 method:
ci.auc(response, predictor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci.auc_+3A_roc">roc</code>, <code id="ci.auc_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, or a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_auc">auc</code></td>
<td>
<p>an &ldquo;auc&rdquo; object from the <code><a href="#topic+auc">auc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_multiclass.roc">multiclass.roc</code>, <code id="ci.auc_+3A_multiclass.auc">multiclass.auc</code></td>
<td>
<p>not implemented.</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_response">response</code>, <code id="ci.auc_+3A_predictor">predictor</code></td>
<td>
<p>arguments for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_formula">formula</code>, <code id="ci.auc_+3A_data">data</code></td>
<td>
<p>a formula (and possibly a data object) of type
response~predictor for the <code><a href="#topic+roc">roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_conf.level">conf.level</code></td>
<td>
<p>the width of the confidence interval as [0,1], never
in percent. Default: 0.95, resulting in a 95% CI.
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_method">method</code></td>
<td>
<p>the method to use, either &ldquo;delong&rdquo; or
&ldquo;bootstrap&rdquo;. The first letter is sufficient. If omitted, the
appropriate method is selected as explained in details.
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_boot.n">boot.n</code></td>
<td>
<p>the number of bootstrap replicates. Default: 2000.</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>should the bootstrap be stratified (default, same number
of cases/controls in each replicate than in the original sample) or
not.
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_reuse.auc">reuse.auc</code></td>
<td>
<p>if <code>TRUE</code> (default) and the &ldquo;roc&rdquo; object
contains an &ldquo;auc&rdquo; field, re-use these specifications for the
test. If false, use optional <code>...</code> arguments to
<code><a href="#topic+auc">auc</a></code>. See details.
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, the bootstrap is processed in parallel, using 
parallel backend provided by plyr (foreach).
</p>
</td></tr>
<tr><td><code id="ci.auc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> and <code>roc.test.roc</code>
when calling <code>roc.test.default</code> or <code>roc.test.formula</code>.
Arguments for <code><a href="#topic+auc">auc</a></code>
and <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only <code>char</code> and <code>style</code>)
if applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the CI of an AUC. Two methods are available:
&ldquo;delong&rdquo; and &ldquo;bootstrap&rdquo; with the parameters defined in &ldquo;roc$auc&rdquo; to
compute a CI. When it is called with two vectors (response, predictor)
or a formula (response~predictor) arguments, the <code><a href="#topic+roc">roc</a></code>
function is called to build the ROC curve first.
</p>
<p>The default is to use
&ldquo;delong&rdquo; method except for comparison of partial AUC and smoothed
curves, where <code>bootstrap</code> is used. Using &ldquo;delong&rdquo; for
partial AUC and smoothed ROCs is not supported.
</p>
<p>With <code>method="bootstrap"</code>, the function calls <code><a href="#topic+auc">auc</a></code>
<code>boot.n</code> times. For more details about the bootstrap, see the Bootstrap section in
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
<p>For <a href="#topic+smooth.roc">smoothed ROC curves</a>, smoothing is performed again at each
bootstrap replicate with the parameters originally provided.
If a density smoothing was performed with user-provided
<code>density.cases</code> or <code>density.controls</code> the bootstrap cannot
be performed and an error is issued.
</p>
<p>With <code>method="delong"</code>, the variance of the AUC is computed as
defined by DeLong <em>et al.</em> (1988) using the algorithm by Sun and Xu (2014) 
and the CI is deduced with <code><a href="stats.html#topic+qnorm">qnorm</a></code>.
</p>
<p>CI of multiclass ROC curves and AUC is not implemented yet. Attempting to call these
methods returns an error.
</p>


<h3>Value</h3>

<p>A numeric vector of length 3 and class &ldquo;ci.auc&rdquo;, &ldquo;ci&rdquo; and &ldquo;numeric&rdquo; (in this order), with the lower
bound, the median and the upper bound of the CI, and the following attributes:
</p>
<table role = "presentation">
<tr><td><code>conf.level</code></td>
<td>
<p>the width of the CI, in fraction.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method employed.</p>
</td></tr>
<tr><td><code>boot.n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code>boot.stratified</code></td>
<td>
<p>whether or not the bootstrapping was stratified.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>an object of class &ldquo;<a href="#topic+auc">auc</a>&rdquo; stored for reference about the
compued AUC details (partial, percent, ...)</p>
</td></tr>
</table>
<p>The <code>aucs</code> item is not included in this list since version 1.2 for
consistency reasons.
</p>


<h3>AUC specification</h3>

<p>The comparison of the CI needs a specification of the AUC. This allows
to compute the CI for full or partial AUCs. The specification is defined by:
</p>

<ol>
<li><p> the &ldquo;auc&rdquo; field in the &ldquo;<a href="#topic+roc">roc</a>&rdquo; object if
<code>reuse.auc</code> is set to <code>TRUE</code> (default). It is naturally
inherited from any call to <code><a href="#topic+roc">roc</a></code> and fits most cases.
</p>
</li>
<li><p> passing the specification to <code><a href="#topic+auc">auc</a></code> with ...
(arguments <code>partial.auc</code>, <code>partial.auc.correct</code> and
<code>partial.auc.focus</code>). In this case, you must ensure either that
the <code><a href="#topic+roc">roc</a></code> object do not contain an <code>auc</code> field (if
you called <code><a href="#topic+roc">roc</a></code> with <code>auc=FALSE</code>), or set
<code>reuse.auc=FALSE</code>.
</p>
</li></ol>

<p>If <code>reuse.auc=FALSE</code> the <code><a href="#topic+auc">auc</a></code> function will always
be called with <code>...</code> to determine the specification, even if
the &ldquo;<a href="#topic+roc">roc</a>&rdquo; object do contain an <code>auc</code> field.
</p>
<p>As well if the &ldquo;<a href="#topic+roc">roc</a>&rdquo; object do not contain an <code>auc</code>
field, the <code><a href="#topic+auc">auc</a></code> function will always be called with
<code>...</code> to determine the specification.
</p>
<p>Warning: if the roc object passed to ci contains an <code>auc</code>
field and <code>reuse.auc=TRUE</code>, <a href="#topic+auc">auc</a> is not called and
arguments such as <code>partial.auc</code> are silently ignored.
</p>


<h3>Warnings</h3>

<p>If <code>method="delong"</code> and the AUC specification specifies a
partial AUC, the warning &ldquo;Using DeLong's test for partial AUC is
not supported. Using bootstrap test instead.&rdquo; is issued. The
<code>method</code> argument is ignored and &ldquo;bootstrap&rdquo; is used
instead.
</p>
<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, or that there are not enough
points for smoothing, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>


<h3>Errors</h3>

<p>If <code>density.cases</code> and <code>density.controls</code> were provided
for smoothing, the error &ldquo;Cannot compute the statistic on ROC
curves smoothed with density.controls and density.cases.&rdquo; is issued.
</p>


<h3>References</h3>

<p>James Carpenter and John Bithell (2000) &ldquo;Bootstrap condence intervals:
when, which, what? A practical guide for medical statisticians&rdquo;.
<em>Statistics in Medicine</em> <b>19</b>, 1141&ndash;1164.
DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F">10.1002/(SICI)1097-0258(20000515)19:9&lt;1141::AID-SIM479&gt;3.0.CO;2-F</a>.
</p>
<p>Elisabeth R. DeLong, David M. DeLong and Daniel L. Clarke-Pearson
(1988) &ldquo;Comparing the areas under two or more correlated receiver
operating characteristic curves: a nonparametric
approach&rdquo;. <em>Biometrics</em> <b>44</b>, 837&ndash;845.
</p>
<p>Xu Sun and Weichao Xu (2014) &ldquo;Fast Implementation of DeLongs Algorithm for Comparing
the Areas Under Correlated Receiver Operating Characteristic Curves&rdquo;. <em>IEEE Signal
Processing Letters</em>, <b>21</b>, 1389&ndash;1393. 
DOI: doi: <a href="https://doi.org/10.1109/LSP.2014.2337313">10.1109/LSP.2014.2337313</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a ROC curve:
data(aSAH)
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)


## Basic example ##
ci.auc(roc1)

# You can also write:
ci(roc1)
ci(auc(roc1))


## More options ##
# Partial AUC and customized bootstrap:
## Not run: 
ci.auc(roc1,
       conf.level=0.9,
	   partial.auc=c(1, .8),  partial.auc.focus="se", partial.auc.correct=TRUE,
       boot.n=10000, stratified=FALSE)
## End(Not run)

# Note that the following will NOT give a CI of the partial AUC:
## Not run: 
ci.auc(roc1,
       partial.auc=c(1, .8), partial.auc.focus="se", partial.auc.correct=FALSE)
## End(Not run)
# This is because rocobj$auc is not a partial AUC and reuse.auc = TRUE by default.
# You can overcome this problem by passing an AUC instead:
auc1 &lt;- auc(roc1, partial.auc=c(1, .8), partial.auc.focus="se", 
            partial.auc.correct=FALSE)
## Not run: 
ci.auc(auc1)
## End(Not run)


## On smoothed ROC curves with bootstrap ##
## Not run: 
ci.auc(smooth(roc1, method="density"))
## End(Not run)
</code></pre>

<hr>
<h2 id='ci.coords'>
Compute the confidence interval of arbitrary coordinates
</h2><span id='topic+ci.coords'></span><span id='topic+ci.coords.default'></span><span id='topic+ci.coords.formula'></span><span id='topic+ci.coords.roc'></span><span id='topic+ci.coords.smooth.roc'></span>

<h3>Description</h3>

<p>This function computes the confidence interval (CI) of the coordinates
of a ROC curves with the <code><a href="#topic+coords">coords</a></code> function.
By default, the 95% CI are computed with 2000 stratified bootstrap replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># ci.coords(...)
## S3 method for class 'roc'
ci.coords(roc, x,
input=c("threshold", "specificity", "sensitivity"),
ret=c("threshold", "specificity", "sensitivity"),
best.method=c("youden", "closest.topleft"), best.weights=c(1, 0.5),
best.policy = c("stop", "omit", "random"),
conf.level=0.95, boot.n=2000,
boot.stratified=TRUE,
progress=getOption("pROCProgress")$name, ...) 
## S3 method for class 'formula'
ci.coords(formula, data, ...)
## S3 method for class 'smooth.roc'
ci.coords(smooth.roc, x,
input=c("specificity", "sensitivity"), ret=c("specificity", "sensitivity"),
best.method=c("youden", "closest.topleft"), best.weights=c(1, 0.5),
best.policy = c("stop", "omit", "random"),
conf.level=0.95, boot.n=2000,
boot.stratified=TRUE,
progress=getOption("pROCProgress")$name, ...)
## Default S3 method:
ci.coords(response, predictor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci.coords_+3A_roc">roc</code>, <code id="ci.coords_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, or a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_response">response</code>, <code id="ci.coords_+3A_predictor">predictor</code></td>
<td>
<p>arguments for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_formula">formula</code>, <code id="ci.coords_+3A_data">data</code></td>
<td>
<p>a formula (and possibly a data object) of type
response~predictor for the <code><a href="#topic+roc">roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_x">x</code>, <code id="ci.coords_+3A_input">input</code>, <code id="ci.coords_+3A_ret">ret</code>, <code id="ci.coords_+3A_best.method">best.method</code>, <code id="ci.coords_+3A_best.weights">best.weights</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+coords">coords</a></code>.
See there for more details. The only difference is on the <code>x</code> argument which cannot be
&ldquo;all&rdquo; or &ldquo;local maximas&rdquo;.
</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_best.policy">best.policy</code></td>
<td>
<p>The policy follow when multiple &ldquo;best&rdquo; thresholds are returned by <code><a href="#topic+coords">coords</a></code>.
&ldquo;stop&rdquo; will abort the processing with <code><a href="base.html#topic+stop">stop</a></code> (default),
&ldquo;omit&rdquo; will ignore the sample (as in <code><a href="base.html#topic+NA">NA</a></code>) 
and &ldquo;random&rdquo; will select one of the threshold randomly.
</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_conf.level">conf.level</code></td>
<td>
<p>the width of the confidence interval as [0,1], never
in percent. Default: 0.95, resulting in a 95% CI.
</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_boot.n">boot.n</code></td>
<td>
<p>the number of bootstrap replicates. Default: 2000.</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>should the bootstrap be stratified (default, same number
of cases/controls in each replicate than in the original sample) or
not.
</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="ci.coords_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> and <code>ci.coords.roc</code>
when calling <code>ci.coords.default</code> or <code>ci.coords.formula</code>.
Arguments for <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only 
<code>char</code> and <code>style</code>) if applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ci.coords.formula</code> and <code>ci.coords.default</code> are convenience methods
that build the ROC curve (with the <code><a href="#topic+roc">roc</a></code> function) before
calling <code>ci.coords.roc</code>. You can pass them arguments for both
<code><a href="#topic+roc">roc</a></code> and <code>ci.coords.roc</code>. Simply use <code>ci.coords</code>
that will dispatch to the correct method.
</p>
<p>This function creates <code>boot.n</code> bootstrap replicate of the ROC
curve, and evaluates the coordinates specified by the <code>x</code>, <code>input</code>,
<code>ret</code>, <code>best.method</code> and <code>best.weights</code> arguments. Then it computes the
confidence interval as the percentiles given by <code>conf.level</code>.
</p>
<p>When <code>x="best"</code>, the best threshold is determined at each bootstrap 
iteration, effectively assessing the confidence interval of choice of the &quot;best&quot;
threshold itself.  This differs from the behavior of <code><a href="#topic+ci.thresholds">ci.thresholds</a></code>,
where the &quot;best&quot; threshold is assessed on the given ROC curve before
resampling.
</p>
<p>For more details about the bootstrap, see the Bootstrap section in
<a href="#topic+pROC-package">this package's documentation</a>.
</p>


<h3>Value</h3>

<p><b>Note:</b> changed in version 1.16.
</p>
<p>A list of the same length as <code>ret</code> and named as <code>ret</code>, and of 
class &ldquo;ci.thresholds&rdquo;, &ldquo;ci&rdquo; and &ldquo;list&rdquo; (in this order).
</p>
<p>Each element of the list is a matrix of the confidence intervals with
rows given by <code>x</code> and with 3 columns, the lower bound of the CI, 
the median, and the upper bound of the CI.
</p>
<p>Additionally, the list has the following attributes: 
</p>
<table role = "presentation">
<tr><td><code>conf.level</code></td>
<td>
<p>the width of the CI, in fraction.</p>
</td></tr>
<tr><td><code>boot.n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code>boot.stratified</code></td>
<td>
<p>whether or not the bootstrapping was stratified.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the input coordinate, as given in argument.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the coordinates used to calculate the CI, as given in argument.</p>
</td></tr>
<tr><td><code>ret</code></td>
<td>
<p>the return values, as given in argument or substituted by
<code>link{coords}</code>.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>the object of class &ldquo;<a href="#topic+roc">roc</a>&rdquo; that was used to
compute the CI.
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>
<p>This warning will also be displayed if you chose <code>best.policy = "omit"</code>
and a ROC curve with multiple &ldquo;best&rdquo; threshold was generated
during at least one of the replicates.
</p>


<h3>References</h3>

<p>James Carpenter and John Bithell (2000) &ldquo;Bootstrap condence intervals:
when, which, what? A practical guide for medical statisticians&rdquo;.
<em>Statistics in Medicine</em> <b>19</b>, 1141&ndash;1164.
DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F">10.1002/(SICI)1097-0258(20000515)19:9&lt;1141::AID-SIM479&gt;3.0.CO;2-F</a>.
</p>
<p>Tom Fawcett (2006) &ldquo;An introduction to ROC analysis&rdquo;. <em>Pattern
Recognition Letters</em> <b>27</b>, 861&ndash;874. DOI:
doi: <a href="https://doi.org/10.1016/j.patrec.2005.10.010">10.1016/j.patrec.2005.10.010</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>,
<code><a href="#topic+coords">coords</a></code>,
<code><a href="#topic+ci">ci</a></code>
</p>
<p>CRAN package <span class="pkg">plyr</span>, employed in this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a ROC curve:
data(aSAH)
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)


## Basic example ##
## Not run: 
ci.coords(roc1, x="best", input = "threshold", 
          ret=c("specificity", "ppv", "tp"))


## More options ##
ci.coords(roc1, x=0.9, input = "sensitivity", ret="specificity")
ci.coords(roc1, x=0.9, input = "sensitivity", ret=c("specificity", "ppv", "tp"))
ci.coords(roc1, x=c(0.1, 0.5, 0.9), input = "sensitivity", ret="specificity")
ci.coords(roc1, x=c(0.1, 0.5, 0.9), input = "sensitivity", ret=c("specificity", "ppv", "tp"))

# Return everything we can:
rets &lt;- c("threshold", "specificity", "sensitivity", "accuracy", "tn", "tp", "fn", "fp", "npv", 
          "ppv", "1-specificity", "1-sensitivity", "1-accuracy", "1-npv", "1-ppv")
ci.coords(roc1, x="best", input = "threshold", ret=rets)
## End(Not run)


## On smoothed ROC curves with bootstrap ##
## Not run: 
ci.coords(smooth(roc1), x=0.9, input = "sensitivity", ret=c("specificity", "ppv", "tp"))
## End(Not run)
</code></pre>

<hr>
<h2 id='ci.se'>
Compute the confidence interval of sensitivities at given specificities
</h2><span id='topic+ci.se'></span><span id='topic+ci.se.default'></span><span id='topic+ci.se.formula'></span><span id='topic+ci.se.roc'></span><span id='topic+ci.se.smooth.roc'></span>

<h3>Description</h3>

<p>This function computes the confidence interval (CI) of the sensitivity
at the given specificity points.
By default, the 95% CI are computed with 2000 stratified bootstrap replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># ci.se(...)
## S3 method for class 'roc'
ci.se(roc, specificities = seq(0, 1, .1) * ifelse(roc$percent,
100, 1), conf.level=0.95, boot.n=2000, boot.stratified=TRUE,
progress=getOption("pROCProgress")$name, parallel=FALSE, ...) 
## S3 method for class 'smooth.roc'
ci.se(smooth.roc, specificities = seq(0, 1, .1) *
ifelse(smooth.roc$percent, 100, 1), conf.level=0.95, boot.n=2000,
boot.stratified=TRUE, progress=getOption("pROCProgress")$name,
parallel=FALSE, ...)
## S3 method for class 'formula'
ci.se(formula, data, ...)
## Default S3 method:
ci.se(response, predictor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci.se_+3A_roc">roc</code>, <code id="ci.se_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, or a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.se_+3A_response">response</code>, <code id="ci.se_+3A_predictor">predictor</code></td>
<td>
<p>arguments for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci.se_+3A_formula">formula</code>, <code id="ci.se_+3A_data">data</code></td>
<td>
<p>a formula (and possibly a data object) of type
response~predictor for the <code><a href="#topic+roc">roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.se_+3A_specificities">specificities</code></td>
<td>
<p>on which specificities to evaluate the CI.
</p>
</td></tr>
<tr><td><code id="ci.se_+3A_conf.level">conf.level</code></td>
<td>
<p>the width of the confidence interval as [0,1], never
in percent. Default: 0.95, resulting in a 95% CI.
</p>
</td></tr>
<tr><td><code id="ci.se_+3A_boot.n">boot.n</code></td>
<td>
<p>the number of bootstrap replicates. Default: 2000.</p>
</td></tr>
<tr><td><code id="ci.se_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>should the bootstrap be stratified (default, same number
of cases/controls in each replicate than in the original sample) or
not.
</p>
</td></tr>
<tr><td><code id="ci.se_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="ci.se_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, the bootstrap is processed in parallel, using 
parallel backend provided by plyr (foreach).
</p>
</td></tr>
<tr><td><code id="ci.se_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> and <code>ci.se.roc</code>
when calling <code>ci.se.default</code> or <code>ci.se.formula</code>.
Arguments for <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only 
<code>char</code> and <code>style</code>) if applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ci.se.formula</code> and <code>ci.se.default</code> are convenience methods
that build the ROC curve (with the <code><a href="#topic+roc">roc</a></code> function) before
calling <code>ci.se.roc</code>. You can pass them arguments for both
<code><a href="#topic+roc">roc</a></code> and <code>ci.se.roc</code>. Simply use <code>ci.se</code>
that will dispatch to the correct method.
</p>
<p>The <code>ci.se.roc</code> function creates <code>boot.n</code> bootstrap replicate of the ROC
curve, and evaluates the sensitivity at specificities
given by the <code>specificities</code> argument. Then it computes the
confidence interval as the percentiles given by <code>conf.level</code>.
</p>
<p>For more details about the bootstrap, see the Bootstrap section in
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
<p>For <a href="#topic+smooth.roc">smoothed ROC curves</a>, smoothing is performed again at each
bootstrap replicate with the parameters originally provided.
If a density smoothing was performed with user-provided
<code>density.cases</code> or <code>density.controls</code> the bootstrap cannot
be performed and an error is issued.
</p>


<h3>Value</h3>

<p>A matrix of class &ldquo;ci.se&rdquo;, &ldquo;ci&rdquo; and &ldquo;matrix&rdquo; (in this order)
containing the given sensitivities. Row (names) are the
specificities, the first column the lower bound, the 2nd column the
median and the 3rd column the upper bound.
</p>
<p>Additionally, the list has the following attributes: 
</p>
<table role = "presentation">
<tr><td><code>conf.level</code></td>
<td>
<p>the width of the CI, in fraction.</p>
</td></tr>
<tr><td><code>boot.n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code>boot.stratified</code></td>
<td>
<p>whether or not the bootstrapping was stratified.</p>
</td></tr>
<tr><td><code>specificities</code></td>
<td>
<p>the specificities as given in argument.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>the object of class &ldquo;<a href="#topic+roc">roc</a>&rdquo; that was used to
compute the CI.
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, or that there are not enough
points for smoothing, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>


<h3>Errors</h3>

<p>If <code>density.cases</code> and <code>density.controls</code> were provided
for smoothing, the error &ldquo;Cannot compute the statistic on ROC
curves smoothed with density.controls and density.cases.&rdquo; is issued.
</p>


<h3>References</h3>

<p>James Carpenter and John Bithell (2000) &ldquo;Bootstrap condence intervals:
when, which, what? A practical guide for medical statisticians&rdquo;.
<em>Statistics in Medicine</em> <b>19</b>, 1141&ndash;1164.
DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F">10.1002/(SICI)1097-0258(20000515)19:9&lt;1141::AID-SIM479&gt;3.0.CO;2-F</a>.
</p>
<p>Tom Fawcett (2006) &ldquo;An introduction to ROC analysis&rdquo;. <em>Pattern
Recognition Letters</em> <b>27</b>, 861&ndash;874. DOI:
doi: <a href="https://doi.org/10.1016/j.patrec.2005.10.010">10.1016/j.patrec.2005.10.010</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>,
<code><a href="#topic+ci">ci</a></code>,
<code><a href="#topic+ci.sp">ci.sp</a></code>,
<code><a href="#topic+plot.ci">plot.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a ROC curve:
data(aSAH)
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)


## Basic example ##
## Not run: 
ci.se(roc1)
## End(Not run)


## More options ##
# Customized bootstrap and specificities:
## Not run: 
ci.se(roc1, c(.95, .9, .85), boot.n=10000, conf.level=0.9, stratified=FALSE)
## End(Not run)


## Plotting the CI ##
ci1 &lt;- ci.se(roc1, boot.n = 10)
plot(roc1)
plot(ci1)


## On smoothed ROC curves with bootstrap ##
## Not run: 
ci.se(smooth(roc1, method="density"))
## End(Not run)
</code></pre>

<hr>
<h2 id='ci.sp'>
Compute the confidence interval of specificities at given sensitivities
</h2><span id='topic+ci.sp'></span><span id='topic+ci.sp.default'></span><span id='topic+ci.sp.formula'></span><span id='topic+ci.sp.roc'></span><span id='topic+ci.sp.smooth.roc'></span>

<h3>Description</h3>

<p>This function computes the confidence interval (CI) of the specificity
at the given sensitivity points.
By default, the 95% CI are computed with 2000 stratified bootstrap replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># ci.sp(...)
## S3 method for class 'roc'
ci.sp(roc, sensitivities = seq(0, 1, .1) * ifelse(roc$percent,
100, 1), conf.level=0.95, boot.n=2000, boot.stratified=TRUE,
progress=getOption("pROCProgress")$name, parallel=FALSE, ...) 
## S3 method for class 'smooth.roc'
ci.sp(smooth.roc, sensitivities = seq(0, 1, .1) *
ifelse(smooth.roc$percent, 100, 1), conf.level=0.95, boot.n=2000,
boot.stratified=TRUE, progress=getOption("pROCProgress")$name, parallel=FALSE, ...)
## S3 method for class 'formula'
ci.sp(formula, data, ...)
## Default S3 method:
ci.sp(response, predictor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci.sp_+3A_roc">roc</code>, <code id="ci.sp_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, or a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_response">response</code>, <code id="ci.sp_+3A_predictor">predictor</code></td>
<td>
<p>arguments for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_formula">formula</code>, <code id="ci.sp_+3A_data">data</code></td>
<td>
<p>a formula (and possibly a data object) of type
response~predictor for the <code><a href="#topic+roc">roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_sensitivities">sensitivities</code></td>
<td>
<p>on which sensitivities to evaluate the CI.
</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_conf.level">conf.level</code></td>
<td>
<p>the width of the confidence interval as [0,1], never
in percent. Default: 0.95, resulting in a 95% CI.
</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_boot.n">boot.n</code></td>
<td>
<p>the number of bootstrap replicates. Default: 2000.</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>should the bootstrap be stratified (default, same number
of cases/controls in each replicate than in the original sample) or
not.
</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, the bootstrap is processed in parallel, using 
parallel backend provided by plyr (foreach).
</p>
</td></tr>
<tr><td><code id="ci.sp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> and <code>ci.sp.roc</code>
when calling <code>ci.sp.default</code> or <code>ci.sp.formula</code>.
Arguments for <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only 
<code>char</code> and <code>style</code>) if applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ci.sp.formula</code> and <code>ci.sp.default</code> are convenience methods
that build the ROC curve (with the <code><a href="#topic+roc">roc</a></code> function) before
calling <code>ci.sp.roc</code>. You can pass them arguments for both
<code><a href="#topic+roc">roc</a></code> and <code>ci.sp.roc</code>. Simply use <code>ci.sp</code>
that will dispatch to the correct method.
</p>
<p>The <code>ci.sp.roc</code> function creates <code>boot.n</code> bootstrap replicate of the ROC
curve, and evaluates the specificity at sensitivities
given by the <code>sensitivities</code> argument. Then it computes the
confidence interval as the percentiles given by <code>conf.level</code>.
</p>
<p>For more details about the bootstrap, see the Bootstrap section in
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
<p>For <a href="#topic+smooth.roc">smoothed ROC curves</a>, smoothing is performed again at each
bootstrap replicate with the parameters originally provided.
If a density smoothing was performed with user-provided
<code>density.cases</code> or <code>density.controls</code> the bootstrap cannot
be performed and an error is issued.
</p>


<h3>Value</h3>

<p>A matrix of class &ldquo;ci.sp&rdquo;, &ldquo;ci&rdquo; and &ldquo;matrix&rdquo; (in this order)
containing the given specificities. Row (names) are the
sensitivities, the first column the lower bound, the 2nd column the
median and the 3rd column the upper bound.
</p>
<p>Additionally, the list has the following attributes: 
</p>
<table role = "presentation">
<tr><td><code>conf.level</code></td>
<td>
<p>the width of the CI, in fraction.</p>
</td></tr>
<tr><td><code>boot.n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code>boot.stratified</code></td>
<td>
<p>whether or not the bootstrapping was stratified.</p>
</td></tr>
<tr><td><code>sensitivities</code></td>
<td>
<p>the sensitivities as given in argument.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>the object of class &ldquo;<a href="#topic+roc">roc</a>&rdquo; that was used to
compute the CI.
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, or that there are not enough
points for smoothing, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>


<h3>Errors</h3>

<p>If <code>density.cases</code> and <code>density.controls</code> were provided
for smoothing, the error &ldquo;Cannot compute the statistic on ROC
curves smoothed with density.controls and density.cases.&rdquo; is issued.
</p>


<h3>References</h3>

<p>James Carpenter and John Bithell (2000) &ldquo;Bootstrap condence intervals:
when, which, what? A practical guide for medical statisticians&rdquo;.
<em>Statistics in Medicine</em> <b>19</b>, 1141&ndash;1164.
DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F">10.1002/(SICI)1097-0258(20000515)19:9&lt;1141::AID-SIM479&gt;3.0.CO;2-F</a>.
</p>
<p>Tom Fawcett (2006) &ldquo;An introduction to ROC analysis&rdquo;. <em>Pattern
Recognition Letters</em> <b>27</b>, 861&ndash;874. DOI:
doi: <a href="https://doi.org/10.1016/j.patrec.2005.10.010">10.1016/j.patrec.2005.10.010</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>,
<code><a href="#topic+ci">ci</a></code>,
<code><a href="#topic+ci.se">ci.se</a></code>,
<code><a href="#topic+plot.ci">plot.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a ROC curve:
data(aSAH)
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)


## Basic example ##
## Not run: 
ci.sp(roc1)
## End(Not run)


## More options ##
# Customized bootstrap and sensitivities:
## Not run: 
ci.sp(roc1, c(.95, .9, .85), boot.n=10000, conf.level=0.9, stratified=FALSE)
## End(Not run)


## Plotting the CI ##
ci1 &lt;- ci.sp(roc1, boot.n = 10)
plot(roc1)
plot(ci1)


## On smoothed ROC curves with bootstrap ##
## Not run: 
ci.sp(smooth(roc1, method="density"))
## End(Not run)
</code></pre>

<hr>
<h2 id='ci.thresholds'>
Compute the confidence interval of thresholds
</h2><span id='topic+ci.thresholds'></span><span id='topic+ci.thresholds.default'></span><span id='topic+ci.thresholds.formula'></span><span id='topic+ci.thresholds.roc'></span><span id='topic+ci.thresholds.smooth.roc'></span>

<h3>Description</h3>

<p>This function computes the confidence interval (CI) of the sensitivity
and specificity of the thresholds given in argument.
By default, the 95% CI are computed with 2000 stratified bootstrap replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># ci.thresholds(...)
## S3 method for class 'roc'
ci.thresholds(roc, conf.level=0.95, boot.n=2000,
boot.stratified=TRUE, thresholds = "local maximas",
progress=getOption("pROCProgress")$name, parallel=FALSE, ...) 
## S3 method for class 'formula'
ci.thresholds(formula, data, ...)
## S3 method for class 'smooth.roc'
ci.thresholds(smooth.roc, ...)
## Default S3 method:
ci.thresholds(response, predictor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci.thresholds_+3A_roc">roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>not available for <a href="#topic+smooth.roc">smoothed</a> ROC
curves, available only to catch the error and provide a clear error
message.
</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_response">response</code>, <code id="ci.thresholds_+3A_predictor">predictor</code></td>
<td>
<p>arguments for the <code><a href="#topic+roc">roc</a></code> function.</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_formula">formula</code>, <code id="ci.thresholds_+3A_data">data</code></td>
<td>
<p>a formula (and possibly a data object) of type
response~predictor for the <code><a href="#topic+roc">roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_conf.level">conf.level</code></td>
<td>
<p>the width of the confidence interval as [0,1], never
in percent. Default: 0.95, resulting in a 95% CI.
</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_boot.n">boot.n</code></td>
<td>
<p>the number of bootstrap replicates. Default: 2000.</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>should the bootstrap be stratified (default, same number
of cases/controls in each replicate than in the original sample) or
not.
</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_thresholds">thresholds</code></td>
<td>
<p>on which thresholds to evaluate the CI. Either the
numeric values of the thresholds, a logical vector (as index of
<code>roc$thresholds</code>) or a character &ldquo;all&rdquo;, &ldquo;local
maximas&rdquo; or &ldquo;best&rdquo; that will be used to determine the threshold(s) 
on the supplied curve with <code><a href="#topic+coords">coords</a></code> (not on the resampled curves).
</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, the bootstrap is processed in parallel, using 
parallel backend provided by plyr (foreach).
</p>
</td></tr>
<tr><td><code id="ci.thresholds_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> and <code>ci.thresholds.roc</code>
when calling <code>ci.thresholds.default</code> or <code>ci.thresholds.formula</code>.
Arguments for <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only 
<code>char</code> and <code>style</code>) if applicable. 
Arguments <code>best.method</code> and <code>best.weights</code> to <code><a href="#topic+coords">coords</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ci.thresholds.formula</code> and <code>ci.thresholds.default</code> are convenience methods
that build the ROC curve (with the <code><a href="#topic+roc">roc</a></code> function) before
calling <code>ci.thresholds.roc</code>. You can pass them arguments for both
<code><a href="#topic+roc">roc</a></code> and <code>ci.thresholds.roc</code>. Simply use <code>ci.thresholds</code>
that will dispatch to the correct method.
</p>
<p>This function creates <code>boot.n</code> bootstrap replicate of the ROC
curve, and evaluates the sensitivity and specificity at thresholds
given by the <code>thresholds</code> argument. Then it computes the
confidence interval as the percentiles given by <code>conf.level</code>.
</p>
<p>A threshold given as a <code>logical</code> vector or <code>character</code> is converted to the corresponding numeric vector once
<em>using the supplied ROC curve</em>, and not at each bootstrap iteration. See <code><a href="#topic+ci.coords">ci.coords</a></code> for the latter behaviour.
</p>
<p>For more details about the bootstrap, see the Bootstrap section in
<a href="#topic+pROC-package">this package's documentation</a>.
</p>


<h3>Value</h3>

<p>A list of length 2 and class &ldquo;ci.thresholds&rdquo;, &ldquo;ci&rdquo; and &ldquo;list&rdquo; (in this order), with the confidence
intervals of the CI and the following items:
</p>
<table role = "presentation">
<tr><td><code>specificity</code></td>
<td>
<p>a matrix of CI for the specificity. Row (names) are the
thresholds, the first column the lower bound, the 2nd column the
median and the 3rd column the upper bound.
</p>
</td></tr>
<tr><td><code>sensitivity</code></td>
<td>
<p>same than specificity.</p>
</td></tr>
</table>
<p>Additionally, the list has the following attributes: 
</p>
<table role = "presentation">
<tr><td><code>conf.level</code></td>
<td>
<p>the width of the CI, in fraction.</p>
</td></tr>
<tr><td><code>boot.n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code>boot.stratified</code></td>
<td>
<p>whether or not the bootstrapping was stratified.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>the thresholds, as given in argument.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>the object of class &ldquo;<a href="#topic+roc">roc</a>&rdquo; that was used to
compute the CI.
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>


<h3>References</h3>

<p>James Carpenter and John Bithell (2000) &ldquo;Bootstrap condence intervals:
when, which, what? A practical guide for medical statisticians&rdquo;.
<em>Statistics in Medicine</em> <b>19</b>, 1141&ndash;1164.
DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F">10.1002/(SICI)1097-0258(20000515)19:9&lt;1141::AID-SIM479&gt;3.0.CO;2-F</a>.
</p>
<p>Tom Fawcett (2006) &ldquo;An introduction to ROC analysis&rdquo;. <em>Pattern
Recognition Letters</em> <b>27</b>, 861&ndash;874. DOI:
doi: <a href="https://doi.org/10.1016/j.patrec.2005.10.010">10.1016/j.patrec.2005.10.010</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>,
<code><a href="#topic+ci">ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

# Create a ROC curve:
data(aSAH)
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)


## Basic example ##
# Compute CI of all local maxima thresholds
## Not run: 
ci.thresholds(roc1)
## End(Not run)


## More options ##
# Customized bootstrap and thresholds:
## Not run: 
ci.thresholds(roc1,
			  thresholds=c(0.5, 1, 2),
              boot.n=10000, conf.level=0.9, stratified=FALSE)
## End(Not run)


## Plotting the CI ##
## Not run: 
ci1 &lt;- ci.thresholds(roc1)
## End(Not run)
plot(roc1)
plot(ci1)
</code></pre>

<hr>
<h2 id='coords'>
Coordinates of a ROC curve
</h2><span id='topic+coords'></span><span id='topic+coords.roc'></span><span id='topic+coords.smooth.roc'></span>

<h3>Description</h3>

<p>This function returns the coordinates of the ROC curve at one
or several specified point(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords(...)
## S3 method for class 'roc'
coords(roc, x, input="threshold", ret=c("threshold",
"specificity", "sensitivity"),
as.list=FALSE, drop=TRUE, best.method=c("youden", "closest.topleft"),
best.weights=c(1, 0.5), transpose = FALSE, as.matrix=FALSE, ...)
## S3 method for class 'smooth.roc'
coords(smooth.roc, x, input, ret=c("specificity",
"sensitivity"), as.list=FALSE, drop=TRUE, best.method=c("youden",
"closest.topleft"), best.weights=c(1, 0.5), transpose = FALSE,
as.matrix=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coords_+3A_roc">roc</code>, <code id="coords_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, or a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function.
</p>
</td></tr>
<tr><td><code id="coords_+3A_x">x</code></td>
<td>

<p>the coordinates to look for. Numeric (if so, their meaning is
defined by the <code>input</code> argument) or one of &ldquo;all&rdquo; (all
the points of the ROC curve), &ldquo;local maximas&rdquo; (the local
maximas of the ROC curve) or &ldquo;best&rdquo; (see <code>best.method</code>
argument). If missing or <code>NULL</code>, defaults to &ldquo;all&rdquo;.
</p>
</td></tr>
<tr><td><code id="coords_+3A_input">input</code></td>
<td>

<p>If <code>x</code> is numeric, the kind of input coordinate (x).
Typically one of &ldquo;threshold&rdquo;, &ldquo;specificity&rdquo; or 
&ldquo;sensitivity&rdquo;, but can be any of the monotone coordinate available,
see the &ldquo;Valid input&rdquo; column under &ldquo;Available coordinates&rdquo;.
Can be shortened like <code>ret</code>. Defaults to &ldquo;threshold&rdquo;. Note
that &ldquo;threshold&rdquo; is not allowed in <code>coords.smooth.roc</code> and that
the argument is ignored when <code>x</code> is a character.
</p>
</td></tr>
<tr><td><code id="coords_+3A_ret">ret</code></td>
<td>
<p>The coordinates to return. See &ldquo;Available coordinates&rdquo;
section below. Alternatively, the single value &ldquo;all&rdquo; can be used to return
every coordinate available.
</p>
</td></tr>
<tr><td><code id="coords_+3A_as.list">as.list</code></td>
<td>
<p>DEPRECATED. If the returned object must be a list.
Will be removed in a future version.
</p>
</td></tr>
<tr><td><code id="coords_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> the result is coerced to the lowest
possible dimension, as per <a href="base.html#topic+Extract">Extract</a>. By default only drops
if <code>transpose = TRUE</code> and either <code>ret</code> or <code>x</code> is
of length 1.
</p>
</td></tr>
<tr><td><code id="coords_+3A_best.method">best.method</code></td>
<td>
<p>if <code>x="best"</code>, the method to determine the
best threshold. Defaults to &quot;youden&quot;. See details in the
&lsquo;Best thresholds&rsquo; section.
</p>
</td></tr>
<tr><td><code id="coords_+3A_best.weights">best.weights</code></td>
<td>
<p>if <code>x="best"</code>, the weights to determine the
best threshold. See details in the &lsquo;Best thresholds&rsquo; section.
</p>
</td></tr>
<tr><td><code id="coords_+3A_transpose">transpose</code></td>
<td>
<p>whether
to return the thresholds in columns (<code>TRUE</code>) or rows (<code>FALSE</code>).
Since pROC 1.16 the default value is <code>FALSE</code>.
See <a href="#topic+coords_transpose">coords_transpose</a> for more details the change.
</p>
</td></tr>
<tr><td><code id="coords_+3A_as.matrix">as.matrix</code></td>
<td>
<p>if <code>transpose</code> is <code>FALSE</code>, whether to return
a <code><a href="base.html#topic+matrix">matrix</a></code> (<code>TRUE</code>) or a <code><a href="base.html#topic+data.frame">data.frame</a></code>
(<code>FALSE</code>, the default). A <code>data.frame</code> is more convenient
and flexible to use, but incurs a slight speed penalty. Consider
setting this argument to <code>TRUE</code> if you are calling the function
repeatedly.
</p>
</td></tr>
<tr><td><code id="coords_+3A_...">...</code></td>
<td>
<p>further arguments passed from other methods. Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a &ldquo;roc&rdquo;  or &ldquo;smooth.roc&rdquo; object as
first argument, on which the coordinates will be determined. The
coordinates are defined by the <code>x</code> and <code>input</code>
arguments. &ldquo;threshold&rdquo; coordinates cannot be determined in a
smoothed ROC.
</p>
<p>If <code>input="threshold"</code>, the coordinates for the threshold
are reported, even if the exact threshold do not define the ROC
curve. The following convenience characters are allowed: &ldquo;all&rdquo;,
&ldquo;local maximas&rdquo; and &ldquo;best&rdquo;. They will return all the
thresholds, only the thresholds defining local maximas (upper angles of the
ROC curve), or only the threshold(s) corresponding to the best sum of
sensitivity + specificity respectively. Note that &ldquo;best&rdquo; can
return more than one threshold. If <code>x</code> is a character, the
coordinates are limited to the thresholds within the partial AUC if it
has been defined, and not necessarily to the whole curve.
</p>
<p>For <code>input="specificity"</code> and <code>input="sensitivity"</code>,
the function checks if the specificity or sensitivity is one of the
points of the ROC curve (in <code>roc$sensitivities</code> or
<code>roc$specificities</code>). More than one point may match (in
<em>step</em> curves), then only the upper-left-most point coordinates
are returned. Otherwise,
the specificity and specificity of the point is interpolated and
<code>NA</code> is returned as threshold.
</p>
<p>The coords function in this package is a generic, but it might be
superseded by functions in other packages such as
<span class="pkg">colorspace</span> or <span class="pkg">spatstat</span> if they are loaded after
<span class="pkg">pROC</span>. In this case, call the <code>pROC::coords</code> explicitly.
</p>


<h4>Best thresholds</h4>

<p>If <code>x="best"</code>, the <code>best.method</code> argument controls how the
optimal threshold is determined.
</p>

<dl>
<dt>&ldquo;youden&rdquo;</dt><dd>
<p>Youden's J statistic (Youden, 1950) is employed (default). The optimal 
cut-off is the threshold that maximizes the distance to the identity
(diagonal) line. Can be shortened to &ldquo;y&rdquo;.
</p>
<p>The optimality criterion is:
</p>
<p style="text-align: center;"><code class="reqn">max(sensitivities + specificities)</code>
</p>

</dd>
<dt>&ldquo;closest.topleft&rdquo;</dt><dd>
<p>The optimal threshold is the point closest to the top-left part of
the plot with perfect sensitivity or specificity. Can be shortened
to &ldquo;c&rdquo; or &ldquo;t&rdquo;.
</p>
<p>The optimality criterion is:
</p>
<p style="text-align: center;"><code class="reqn">min((1 - sensitivities)^2 + (1- specificities)^2)</code>
</p>

</dd>
</dl>

<p>In addition, weights can be supplied if false positive and false
negative predictions are not equivalent: a numeric vector of length 2
to the <code>best.weights</code> argument. The elements define
</p>

<ol>
<li><p> the relative cost of of a false negative classification (as compared with a false positive classification)
</p>
</li>
<li><p> the prevalence, or the proportion of cases in the population (<code class="reqn">\frac{n_{cases}}{n_{controls}+n_{cases}}</code>). 
</p>
</li></ol>

<p>The optimality criteria are modified as proposed by Perkins and Schisterman:
</p>

<dl>
<dt>&ldquo;youden&rdquo;</dt><dd>
<p style="text-align: center;"><code class="reqn">max(sensitivities + r * specificities)</code>
</p>

</dd>
<dt>&ldquo;closest.topleft&rdquo;</dt><dd>
<p style="text-align: center;"><code class="reqn">min((1 - sensitivities)^2 + r * (1- specificities)^2)</code>
</p>

</dd>
</dl>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">r = \frac{1 - prevalence}{cost * prevalence}</code>
</p>

<p>By default, prevalence is 0.5 and cost is 1 so that no weight is
applied in effect.
</p>
<p>Note that several thresholds might be equally optimal.
</p>



<h4>Available coordinates</h4>

<p>The following table lists the coordinates that are available in the <code>ret</code>
and <code>input</code> arguments.
</p>

<table>
<tr>
 <td style="text-align: right;">
		Value </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Formula </td><td style="text-align: left;"> Synonyms </td><td style="text-align: left;"> Valid input </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>threshold</code> </td><td style="text-align: left;"> The threshold value </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>tn</code> </td><td style="text-align: left;"> True negative count </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>tp</code> </td><td style="text-align: left;"> True positive count </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>fn</code> </td><td style="text-align: left;"> False negative count </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>fp</code> </td><td style="text-align: left;"> False positive count </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>specificity</code> </td><td style="text-align: left;"> Specificity  </td><td style="text-align: left;"> tn / (tn + fp) </td><td style="text-align: left;"> tnr </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>sensitivity</code> </td><td style="text-align: left;"> Sensitivity </td><td style="text-align: left;"> tp / (tp + fn)  </td><td style="text-align: left;"> recall, tpr </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>accuracy</code> </td><td style="text-align: left;"> Accuracy </td><td style="text-align: left;">  (tp + tn) / N </td><td style="text-align: left;"> - </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>npv</code> </td><td style="text-align: left;"> Negative Predictive Value </td><td style="text-align: left;"> tn / (tn + fn) </td><td style="text-align: left;"> - </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>ppv</code> </td><td style="text-align: left;"> Positive Predictive Value </td><td style="text-align: left;"> tp / (tp + fp) </td><td style="text-align: left;"> precision </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>precision</code> </td><td style="text-align: left;"> Precision </td><td style="text-align: left;"> tp / (tp + fp) </td><td style="text-align: left;"> ppv </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>recall</code> </td><td style="text-align: left;"> Recall </td><td style="text-align: left;"> tp / (tp + fn) </td><td style="text-align: left;"> sensitivity, tpr </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>tpr</code> </td><td style="text-align: left;"> True Positive Rate </td><td style="text-align: left;"> tp / (tp + fn) </td><td style="text-align: left;"> sensitivity, recall </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>fpr</code> </td><td style="text-align: left;"> False Positive Rate </td><td style="text-align: left;"> fp / (tn + fp) </td><td style="text-align: left;"> 1-specificity </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>tnr</code> </td><td style="text-align: left;"> True Negative Rate </td><td style="text-align: left;"> tn / (tn + fp) </td><td style="text-align: left;"> specificity </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>fnr</code> </td><td style="text-align: left;"> False Negative Rate </td><td style="text-align: left;"> fn / (tp + fn) </td><td style="text-align: left;"> 1-sensitivity </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>fdr</code> </td><td style="text-align: left;"> False Discovery Rate </td><td style="text-align: left;"> fp / (tp + fp) </td><td style="text-align: left;"> 1-ppv </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>youden</code> </td><td style="text-align: left;"> Youden Index </td><td style="text-align: left;"> 
			se + r * sp
			</td><td style="text-align: left;"> - </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: right;">
		<code>closest.topleft</code> </td><td style="text-align: left;"> Distance to the top left corner of the ROC space </td><td style="text-align: left;"> 
			- ((1 - se)^2 + r * (1 - sp)^2)
			</td><td style="text-align: left;"> - </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: right;">
	</td>
</tr>

</table>

<p>The value &ldquo;threshold&rdquo; is not allowed in <code>coords.smooth.roc</code>.
</p>
<p>Values can be shortenend (for example to &ldquo;thr&rdquo;, &ldquo;sens&rdquo; and &ldquo;spec&rdquo;, or even to
&ldquo;se&rdquo;, &ldquo;sp&rdquo; or &ldquo;1-np&rdquo;). In addition, some values can be prefixed with
<code>1-</code> to get their complement:
<code>1-specificity</code>, <code>1-sensitivity</code>, <code>1-accuracy</code>, <code>1-npv</code>, <code>1-ppv</code>.
</p>
<p>The values <code>npe</code> and <code>ppe</code> are automatically replaced with
<code>1-npv</code> and <code>1-ppv</code>, respectively (and will therefore not appear
as is in the output, but as <code>1-npv</code> and <code>1-ppv</code> instead).
These must be used verbatim in ROC curves with <code>percent=TRUE</code> 
(ie. &ldquo;100-ppv&rdquo; is never accepted).
</p>
<p>The &ldquo;youden&rdquo; and &ldquo;closest.topleft&rdquo; are weighted with <code>r</code>, 
according to the value of the <code>best.weights</code> argument. See the 
&ldquo;Best thresholds&rdquo; section above for more details.
</p>
<p>For <code>ret</code>, the single value &ldquo;all&rdquo; can be used to return
every coordinate available.
</p>



<h3>Value</h3>

<p>Depending on the length of <code>x</code> and <code>as.list</code> argument.
</p>

<table>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;">
	length(x) == 1 or length(ret) == 1 </td><td style="text-align: left;">
	length(x) &gt; 1 or length(ret) &gt; 1 or drop == FALSE
	</td>
</tr>
<tr>
 <td style="text-align: left;">
	
    <code>as.list=TRUE</code> </td><td style="text-align: left;">
	a list of the length of, in the order of, and named after, <code>ret</code>. </td><td style="text-align: left;">
	a list of the length of, and named after, <code>x</code>. Each element of this list is a list of the length of, in the order of, and named after, <code>ret</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>as.list=FALSE</code>  </td><td style="text-align: left;">
	a numeric vector of the length of, in the order of, and named after, <code>ret</code> (if <code>length(x) == 1</code>)
	or a numeric vector of the length of, in the order of, and named after, <code>x</code> (if <code>length(ret) == 1</code>.</td><td style="text-align: left;">
	a numeric matrix with one row for each <code>ret</code> and one column for each <code>x</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>In all cases if <code>input="specificity"</code> or <code>input="sensitivity"</code>
and interpolation was required, threshold is returned as <code>NA</code>.
</p>
<p>Note that if giving a character as <code>x</code> (&ldquo;all&rdquo;,
&ldquo;local maximas&rdquo; or &ldquo;best&rdquo;), you cannot predict the
dimension of the return value unless <code>drop=FALSE</code>. Even
&ldquo;best&rdquo; may return more than one value (for example if the ROC
curve is below the identity line, both extreme points). 
</p>
<p><code>coords</code> may also return <code>NULL</code> when there a partial area is
defined but no point of the ROC curve falls within the region.
</p>


<h3>References</h3>

<p>Neil J. Perkins, Enrique F. Schisterman (2006) &ldquo;The Inconsistency of &quot;Optimal&quot; Cutpoints
Obtained using Two Criteria based on the Receiver Operating
Characteristic Curve&rdquo;. <em>American Journal of Epidemiology</em>
<b>163</b>(7), 670&ndash;675. DOI: doi: <a href="https://doi.org/10.1093/aje/kwj063">10.1093/aje/kwj063</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>W. J. Youden (1950) &ldquo;Index for rating diagnostic tests&rdquo;. <em>Cancer</em>, 
<b>3</b>, 32&ndash;35. DOI: 
doi: <a href="https://doi.org/10.1002/1097-0142(1950)3:1%3C32::AID-CNCR2820030106%3E3.0.CO;2-3">10.1002/1097-0142(1950)3:1&lt;32::AID-CNCR2820030106&gt;3.0.CO;2-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+ci.coords">ci.coords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a ROC curve:
data(aSAH)
roc.s100b &lt;- roc(aSAH$outcome, aSAH$s100b, percent = TRUE)

# Get the coordinates of S100B threshold 0.55
coords(roc.s100b, 0.55, transpose = FALSE)

# Get the coordinates at 50% sensitivity
coords(roc=roc.s100b, x=50, input="sensitivity", transpose = FALSE)
# Can be abbreviated:
coords(roc.s100b, 50, "se", transpose = FALSE)

# Works with smoothed ROC curves
coords(smooth(roc.s100b), 90, "specificity", transpose = FALSE)

# Get the sensitivities for all thresholds
cc &lt;- coords(roc.s100b, "all", ret="sensitivity", transpose = FALSE)
print(cc$sensitivity)

# Get the best threshold
coords(roc.s100b, "best", ret="threshold", transpose = FALSE)

# Get the best threshold according to different methods
roc.ndka &lt;- roc(aSAH$outcome, aSAH$ndka, percent=TRUE)
coords(roc.ndka, "best", ret="threshold", transpose = FALSE, 
       best.method="youden") # default
coords(roc.ndka, "best", ret="threshold", transpose = FALSE, 
       best.method="closest.topleft")

# and with different weights
coords(roc.ndka, "best", ret="threshold", transpose = FALSE, 
       best.method="youden", best.weights=c(50, 0.2))
coords(roc.ndka, "best", ret="threshold", transpose = FALSE, 
       best.method="closest.topleft", best.weights=c(5, 0.2))
       
# This is available with the plot.roc function too:
plot(roc.ndka, print.thres="best", print.thres.best.method="youden",
                                 print.thres.best.weights=c(50, 0.2)) 

# Return more values:
coords(roc.s100b, "best", ret=c("threshold", "specificity", "sensitivity", "accuracy",
                           "precision", "recall"), transpose = FALSE)

# Return all values
coords(roc.s100b, "best", ret = "all", transpose = FALSE)
                           
# You can use coords to plot for instance a sensitivity + specificity vs. cut-off diagram
plot(specificity + sensitivity ~ threshold, 
     coords(roc.ndka, "all", transpose = FALSE), 
     type = "l", log="x", 
     subset = is.finite(threshold))

# Plot the Precision-Recall curve
plot(precision ~ recall, 
     coords(roc.ndka, "all", ret = c("recall", "precision"), transpose = FALSE),
     type="l", ylim = c(0, 100))

# Alternatively plot the curve with TPR and FPR instead of SE/SP 
# (identical curve, only the axis change)
plot(tpr ~ fpr, 
     coords(roc.ndka, "all", ret = c("tpr", "fpr"), transpose = FALSE),
     type="l")
</code></pre>

<hr>
<h2 id='coords_transpose'>Transposing the output of <code>coords</code></h2><span id='topic+coords_transpose'></span>

<h3>Description</h3>

<p>This help page desribes recent and upcoming changes in the 
return values of the <code><a href="#topic+coords">coords</a></code> function.</p>


<h3>Background information</h3>

<p>Until the release of pROC 1.16, the <code>coords</code> function was returning 
a matrix with thresholds in columns, and the coordinate variables in rows.
</p>
<pre>
data(aSAH)
rocobj &lt;- roc(aSAH$outcome, aSAH$s100b)
coords(rocobj, c(0.05, 0.2, 0.5))
#                   0.05       0.2       0.5
# threshold   0.05000000 0.2000000 0.5000000
# specificity 0.06944444 0.8055556 0.9722222
# sensitivity 0.97560976 0.6341463 0.2926829

</pre>
<p>This format didn't conform to the grammar of the 
<a href="https://www.tidyverse.org/">tidyverse</a> which has become prevalent in modern
R language.
</p>
<p>In addition, the dropping of dimensions by default makes it difficult to guess
what type of data <code>coords</code> is going to return.
</p>
<pre>
coords(rocobj, "best")
#   threshold specificity sensitivity 
#   0.2050000   0.8055556   0.6341463 
# A numeric vector

</pre>
<p>Although it is possible to pass <code>drop = FALSE</code>, the fact that it is not the
default makes the behaviour unintuitive.
</p>
<p>In pROC version 1.16, this was changed and <code>coords</code> now returns
a <code><a href="base.html#topic+data.frame">data.frame</a></code> with the thresholds in rows and measurement in colums by default.
</p>
<pre>
 coords(rocobj, c(0.05, 0.2, 0.5), transpose = FALSE)
#      threshold specificity sensitivity
# 0.05      0.05  0.06944444   0.9756098
# 0.2       0.20  0.80555556   0.6341463
# 0.5       0.50  0.97222222   0.2926829
</pre>


<h3>Changes in 1.15</h3>


<ol>
<li><p>Addition of the <code>transpose</code> argument.
</p>
</li>
<li><p>Display a warning if <code>transpose</code> is missing. Pass <code>transpose</code> explicitly to silence the warning.
</p>
</li>
<li><p>Deprecation of <code>as.list</code>.
</p>
</li></ol>



<h3>Changes in 1.16</h3>


<ol>
<li><p>Change of the default <code>transpose</code> to <code>TRUE</code>.
</p>
</li></ol>

<p>THIS CHANGE IS BACKWARDS INCOMPATIBLE AND IS EXPECTED TO BREAK LEGACY CODE.
</p>


<h3>Changes in 1.17</h3>


<ol>
<li><p>Dropped the warning if <code>transpose</code> is missing.
</p>
</li></ol>



<h3>Changes in future versions</h3>


<ol>
<li><p>Support for  the <code>as.list</code> argument might be dropped in the future.
This is still under consideration.
</p>
</li>
<li>
<p>The <code>transpose</code> and <code>drop</code> arguments might be deprecated in the future, but will remain available for a few additional major versions.

</p>
</li></ol>



<h3>Related changes in ci.coords</h3>

<p>In version 1.16, the format of the <code><a href="#topic+ci.coords">ci.coords</a></code> return value was changed from a matrix-like object with mixed <code>x</code> and <code>ret</code> in rows and 3 columns, into a list-like object which should be easier to use programatically.
</p>


<h3>Recommendations</h3>

<p>If you are writing a new script calling the <code>coords</code> function, set <code>transpose = FALSE</code> to silence the warning and benefit from the latest improvements in pROC and obtain a tidy data.
</p>


<h3>See also</h3>

<p><a href="https://github.com/xrobin/pROC/issues/54">The GitHub issue tracking the changes described in this manual page</a>.
</p>

<hr>
<h2 id='cov.roc'>
Covariance of two paired ROC curves
</h2><span id='topic+cov'></span><span id='topic+cov.default'></span><span id='topic+cov.auc'></span><span id='topic+cov.smooth.roc'></span><span id='topic+cov.roc'></span>

<h3>Description</h3>

<p>This function computes the covariance between the AUC of two correlated (or paired) ROC
curves. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov(...)
## Default S3 method:
cov(...)
## S3 method for class 'auc'
cov(roc1, roc2, ...)
## S3 method for class 'smooth.roc'
cov(roc1, roc2, ...)
## S3 method for class 'roc'
cov(roc1, roc2, method=c("delong", "bootstrap", "obuchowski"),
  reuse.auc=TRUE, boot.n=2000, boot.stratified=TRUE, boot.return=FALSE,
  progress=getOption("pROCProgress")$name, parallel=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov.roc_+3A_roc1">roc1</code>, <code id="cov.roc_+3A_roc2">roc2</code></td>
<td>
<p>the two ROC curves on which to compute the covariance. Either
&ldquo;<a href="#topic+roc">roc</a>&rdquo;, &ldquo;<a href="#topic+auc">auc</a>&rdquo; or
&ldquo;<a href="#topic+smooth.roc">smooth.roc</a>&rdquo; objects (types can be mixed as long as
the original ROC curve are paired).
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_method">method</code></td>
<td>
<p>the method to use, either &ldquo;delong&rdquo; or
&ldquo;bootstrap&rdquo;. The first letter is
sufficient. If omitted, the appropriate method is selected as
explained in details.
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_reuse.auc">reuse.auc</code></td>
<td>
<p>if <code>TRUE</code> (default) and the &ldquo;roc&rdquo; objects
contain an &ldquo;auc&rdquo; field, re-use these specifications for the
test. See details.
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_boot.n">boot.n</code></td>
<td>
<p>for <code>method="bootstrap"</code> only: the number of
bootstrap replicates or permutations. Default: <var>2000</var>.
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>for <code>method="bootstrap"</code> only:
should the bootstrap be stratified (same number 
of cases/controls in each replicate than in the original sample) or
not. Default: <var>TRUE</var>.
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_boot.return">boot.return</code></td>
<td>

<p>if <var>TRUE</var> and <code>method="bootstrap"</code>, also return the
bootstrapped values. See the &ldquo;Value&rdquo; section for
more details.
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, the bootstrap is processed in parallel, using 
parallel backend provided by plyr (foreach).
</p>
</td></tr>
<tr><td><code id="cov.roc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code>cov.roc</code> when calling <code>cov</code>,
<code>cov.auc</code> or <code>cov.smooth.roc</code>. Arguments for
<code><a href="#topic+auc">auc</a></code> (if <code>reuse.auc=FALSE</code>) and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only <code>char</code> and <code>style</code>) if
applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the covariance between the AUC of two
correlated (or paired, according to the detection of <code><a href="#topic+are.paired">are.paired</a></code>) ROC
curves. It is typically called with the two <a href="#topic+roc">roc</a> objects of
interest. Two methods are available: &ldquo;delong&rdquo; and
&ldquo;bootstrap&rdquo; (see &ldquo;Computational
details&rdquo; section below).
</p>
<p>The default is to use &ldquo;delong&rdquo; method except with
partial AUC and smoothed curves where &ldquo;bootstrap&rdquo; is employed.
Using &ldquo;delong&rdquo; for partial AUC and smoothed ROCs is not
supported.
</p>
<p>For <a href="#topic+smooth.roc">smoothed ROC curves</a>, smoothing is performed again at each
bootstrap replicate with the parameters originally provided.
If a density smoothing was performed with user-provided
<code>density.cases</code> or <code>density.controls</code> the bootstrap cannot
be performed and an error is issued.
</p>
<p><code>cov.default</code> forces the usage of the
<code><a href="stats.html#topic+cor">cov</a></code> function in the <span class="pkg">stats</span> package, so
that other code relying on <code>cov</code> should continue to function
normally.
</p>


<h3>Value</h3>

<p>The numeric value of the covariance.
</p>
<p>If <code>boot.return=TRUE</code> and <code>method="bootstrap"</code>, an attribute
<code>resampled.values</code> is set with the resampled (bootstrapped)
values. It contains a matrix with the columns representing the two ROC
curves, and the rows the <code>boot.n</code> bootstrap replicates.
</p>


<h3>AUC specification</h3>

<p>To compute the covariance of the AUC of the ROC curves, <code>cov</code> needs a specification of the
AUC. The specification is defined by:
</p>

<ol>
<li><p> the &ldquo;auc&rdquo; field in the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects if
<code>reuse.auc</code> is set to <code>TRUE</code> (default)
</p>
</li>
<li><p> passing the specification to <code><a href="#topic+auc">auc</a></code> with ...
(arguments <code>partial.auc</code>, <code>partial.auc.correct</code> and
<code>partial.auc.focus</code>). In this case, you must ensure either that
the <code><a href="#topic+roc">roc</a></code> object do not contain an <code>auc</code> field (if
you called <code><a href="#topic+roc">roc</a></code> with <code>auc=FALSE</code>), or set
<code>reuse.auc=FALSE</code>.
</p>
</li></ol>

<p>If <code>reuse.auc=FALSE</code> the <code><a href="#topic+auc">auc</a></code> function will always
be called with <code>...</code> to determine the specification, even if
the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do contain an <code>auc</code> field.
</p>
<p>As well if the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do not contain an <code>auc</code>
field, the <code><a href="#topic+auc">auc</a></code> function will always be called with
<code>...</code> to determine the specification.
</p>
<p>Warning: if the roc object passed to roc.test contains an <code>auc</code>
field and <code>reuse.auc=TRUE</code>, <a href="#topic+auc">auc</a> is not called and
arguments such as <code>partial.auc</code> are silently ignored.
</p>


<h3>Computation details</h3>

<p>With <code>method="bootstrap"</code>, the processing is done as follow:
</p>

<ol>
<li> <p><code>boot.n</code> bootstrap replicates are drawn from the
data. If <code>boot.stratified</code> is <var>TRUE</var>, each replicate contains
exactly the same number of controls and cases than the original
sample, otherwise if <var>FALSE</var> the numbers can vary.
</p>
</li>
<li><p> for each bootstrap replicate, the AUC of the two ROC curves
are computed and stored.
</p>
</li>
<li><p> the variance (as per <code><a href="#topic+var.roc">var.roc</a></code>) of the resampled
AUCs and their covariance are assessed in a single bootstrap pass.
</p>
</li>
<li><p> The following formula is used to compute the final covariance:
<code class="reqn">Var[AUC1] + Var[AUC2] - 2cov[AUC1,AUC2]</code>
</p>
</li></ol>

<p>With <code>method="delong"</code>, the processing is done as described in
Hanley and Hajian-Tilaki (1997) using the algorithm by Sun and Xu (2014). 
</p>
<p>With <code>method="obuchowski"</code>, the processing is done as described
in Obuchowski and McClish (1997), Table 1 and Equation 5, p. 1531. The
computation of <code class="reqn">g</code> for partial area under the ROC curve is
modified as: 
</p>
<p style="text-align: center;"><code class="reqn">expr1 * (2 * pi * expr2) ^ {(-1)} * (-expr4) - A * B * expr1 * (2 * pi * expr2^3) ^ {(-1/2)} * expr3</code>
</p>
<p>.
</p>


<h3>Binormality assumption</h3>

<p>The &ldquo;obuchowski&rdquo; method makes the assumption that the data is binormal.
If the data shows a deviation from this assumption, it might help to
normalize the data first (that is, before calling <code><a href="#topic+roc">roc</a></code>),
for example with quantile normalization: 
</p>
<pre>
    norm.x &lt;- qnorm(rank(x)/(length(x)+1))
    cov(roc(response, norm.x, ...), ...)
  </pre>
<p>&ldquo;delong&rdquo; and &ldquo;bootstrap&rdquo; methods make no such assumption.
</p>


<h3>Errors</h3>

<p>If <code>density.cases</code> and <code>density.controls</code> were provided
for smoothing, the error &ldquo;Cannot compute the covariance on ROC
curves smoothed with density.controls and density.cases.&rdquo; is
issued.
</p>


<h3>Warnings</h3>

<p>If &ldquo;auc&rdquo; specifications are different in both roc objects, the
warning &ldquo;Different AUC specifications in the ROC
curves. Enforcing the inconsistency, but unexpected results may be
produced.&rdquo; is issued. Unexpected results may be produced.
</p>
<p>If one or both ROC curves are &ldquo;smooth.roc&rdquo; objects with
different smoothing specifications, the warning 
&ldquo;Different smoothing parameters in the ROC curves. Enforcing
the inconsistency, but unexpected results may be produced.&rdquo; is issued.
This warning can be benign, especially if ROC curves were generated
with <code>roc(..., smooth=TRUE)</code> with different arguments to other
functions (such as plot), or if you really want to compare two ROC
curves smoothed differently.
</p>
<p>If <code>method="delong"</code> and the AUC specification specifies a
partial AUC, the warning &ldquo;Using DeLong for partial AUC is
not supported. Using bootstrap test instead.&rdquo; is issued. The
<code>method</code> argument is ignored and &ldquo;bootstrap&rdquo; is used instead.
</p>
<p>If <code>method="delong"</code> and the ROC
curve is smoothed, the warning &ldquo;Using DeLong for
smoothed ROCs is not supported. Using bootstrap instead.&rdquo; is
issued. The <code>method</code> argument is ignored and &ldquo;bootstrap&rdquo;
is used instead.
</p>
<p>DeLong ignores the direction of the ROC curve so that if two
ROC curves have a different <code>direction</code>, the warning
&ldquo;&quot;DeLong should not be applied to ROC curves with a different
direction.&quot;&rdquo; is printed. However, the spurious computation is enforced.
</p>
<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, or that there are not enough
points for smoothing, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>
<p>When both ROC curves have an <code><a href="#topic+auc">auc</a></code> of 1 (or 100%), their covariance will always be null.
This is true for both &ldquo;delong&rdquo; and &ldquo;bootstrap&rdquo; and methods. This result is misleading,
as the covariance is of course not null.
A <code><a href="base.html#topic+warning">warning</a></code> will be displayed to inform of this condition, and of the misleading output.
</p>


<h3>Messages</h3>

<p>The covariance can only be computed on paired data. This
assumption is enforced by <code><a href="#topic+are.paired">are.paired</a></code>. If the ROC curves
are not paired, the covariance is <code>0</code> and the message &ldquo;ROC
curves are unpaired.&rdquo; is printed. If your ROC curves are paired, make
sure they fit <code><a href="#topic+are.paired">are.paired</a></code> criteria.
</p>


<h3>References</h3>

<p>Elisabeth R. DeLong, David M. DeLong and Daniel L. Clarke-Pearson
(1988) &ldquo;Comparing the areas under two or more correlated receiver
operating characteristic curves: a nonparametric
approach&rdquo;. <em>Biometrics</em> <b>44</b>, 837&ndash;845.
</p>
<p>James A. Hanley and Karim O. Hajian-Tilaki (1997) &ldquo;Sampling
variability of nonparametric estimates of the areas under receiver
operating characteristic curves: An update&rdquo;. <em>Academic
Radiology</em> <b>4</b>, 49&ndash;58. DOI:
doi: <a href="https://doi.org/10.1016/S1076-6332(97)80161-4">10.1016/S1076-6332(97)80161-4</a>.
</p>
<p>Nancy A. Obuchowski, Donna K. McClish (1997). &ldquo;Sample size
determination for diagnostic accurary studies involving binormal ROC
curve indices&rdquo;. <em>Statistics in Medicine</em>, <b>16</b>(13),
1529&ndash;1542. DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(19970715)16:13%3C1529::AID-SIM565%3E3.0.CO;2-H">10.1002/(SICI)1097-0258(19970715)16:13&lt;1529::AID-SIM565&gt;3.0.CO;2-H</a>.
</p>
<p>Xu Sun and Weichao Xu (2014) &ldquo;Fast Implementation of DeLongs Algorithm for Comparing
the Areas Under Correlated Receiver Operating Characteristic Curves&rdquo;. <em>IEEE Signal
Processing Letters</em>, <b>21</b>, 1389&ndash;1393. 
DOI: doi: <a href="https://doi.org/10.1109/LSP.2014.2337313">10.1109/LSP.2014.2337313</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+var.roc">var.roc</a></code>
</p>
<p>CRAN package <span class="pkg">plyr</span>, employed in this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

# Basic example with 2 roc objects
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)
roc2 &lt;- roc(aSAH$outcome, aSAH$wfns)
cov(roc1, roc2)

## Not run: 
# The latter used Delong. To use bootstrap:
cov(roc1, roc2, method="bootstrap")
# Decrease boot.n for a faster execution:
cov(roc1, roc2, method="bootstrap", boot.n=1000)

## End(Not run)

# To use Obuchowski:
cov(roc1, roc2, method="obuchowski")

## Not run: 
# Comparison can be done on smoothed ROCs
# Smoothing is re-done at each iteration, and execution is slow
cov(smooth(roc1), smooth(roc2))

## End(Not run)
# or from an AUC (no smoothing)
cov(auc(roc1), roc2)

## Not run: 
# With bootstrap and return.values, one can compute the variances of the
# ROC curves in one single bootstrap run:
cov.rocs &lt;- cov(roc1, roc2, method="bootstrap", boot.return=TRUE)
# var(roc1):
var(attr(cov.rocs, "resampled.values")[,1])
# var(roc2):
var(attr(cov.rocs, "resampled.values")[,2])

## End(Not run)

## Not run: 
# Covariance of partial AUC:
roc3 &lt;- roc(aSAH$outcome, aSAH$s100b, partial.auc=c(1, 0.8), partial.auc.focus="se")
roc4 &lt;- roc(aSAH$outcome, aSAH$wfns, partial.auc=c(1, 0.8), partial.auc.focus="se")
cov(roc3, roc4)
# This is strictly equivalent to:
cov(roc3, roc4, method="bootstrap")

# Alternatively, we could re-use roc1 and roc2 to get the same result:
cov(roc1, roc2, reuse.auc=FALSE, partial.auc=c(1, 0.8), partial.auc.focus="se")

## End(Not run)

# Spurious use of DeLong's test with different direction:
roc5 &lt;- roc(aSAH$outcome, aSAH$s100b, direction="&lt;")
roc6 &lt;- roc(aSAH$outcome, aSAH$s100b, direction="&gt;")
cov(roc5, roc6, method="delong")

## Test data from Hanley and Hajian-Tilaki, 1997
disease.present &lt;- c("Yes", "No", "Yes", "No", "No", "Yes", "Yes", "No",
                     "No", "Yes", "No", "No", "Yes", "No", "No")
field.strength.1 &lt;- c(1, 2, 5, 1, 1, 1, 2, 1, 2, 2, 1, 1, 5, 1, 1)
field.strength.2 &lt;- c(1, 1, 5, 1, 1, 1, 4, 1, 2, 2, 1, 1, 5, 1, 1)
roc7 &lt;- roc(disease.present, field.strength.1)
roc8 &lt;- roc(disease.present, field.strength.2)
# Assess the covariance:
cov(roc7, roc8)

## Not run: 
# With bootstrap:
cov(roc7, roc8, method="bootstrap")

## End(Not run)

</code></pre>

<hr>
<h2 id='ggroc.roc'>
Plot a ROC curve with ggplot2
</h2><span id='topic+ggroc.roc'></span><span id='topic+ggroc.smooth.roc'></span><span id='topic+ggroc.list'></span><span id='topic+ggroc'></span>

<h3>Description</h3>

<p>This function plots a ROC curve with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
ggroc(data, legacy.axes = FALSE, ...)
## S3 method for class 'smooth.roc'
ggroc(data, legacy.axes = FALSE, ...)
## S3 method for class 'list'
ggroc(data, aes = c("colour", "alpha", "linetype", "linewidth", "size", "group"),
      legacy.axes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggroc.roc_+3A_data">data</code></td>
<td>
<p>a roc object from the <a href="#topic+roc">roc</a> function, or a list of roc objects.
</p>
</td></tr>
<tr><td><code id="ggroc.roc_+3A_aes">aes</code></td>
<td>
<p>the name(s) of the aesthetics for <code><a href="ggplot2.html#topic+geom_path">geom_line</a></code> 
to map to the different ROC curves supplied.
</p>
</td></tr>
<tr><td><code id="ggroc.roc_+3A_legacy.axes">legacy.axes</code></td>
<td>
<p>a logical indicating if the specificity axis (x
axis) must be plotted as as decreasing &ldquo;specificity&rdquo;
(<code>FALSE</code>, the default) or increasing &ldquo;1 - specificity&rdquo;
(<code>TRUE</code>) as in most legacy software.
</p>
</td></tr>
<tr><td><code id="ggroc.roc_+3A_...">...</code></td>
<td>
<p>additional aesthetics for <code><a href="ggplot2.html#topic+geom_path">geom_line</a></code>
to set: <code>alpha</code>, <code>colour</code>, <code>linetype</code>, <code>linewidth</code> 
(new in ggplot2 3.4.0), and <code>size</code> (before ggplot2 3.4.0).
The <code>group</code> aesthetic is always active since version 1.18.5 and is
kept for backwards compatibility.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function initializes a ggplot object from a ROC curve (or multiple if a list is passed). It returns the ggplot with a line layer on it. You can print it directly or add your own layers and theme elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+plot.roc">plot.roc</a></code>, <span class="pkg"><a href="ggplot2.html#topic+ggplot2-package">ggplot2</a></span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a basic roc object
data(aSAH)
rocobj &lt;- roc(aSAH$outcome, aSAH$s100b)
rocobj2 &lt;- roc(aSAH$outcome, aSAH$wfns)

if (require(ggplot2)) {
g &lt;- ggroc(rocobj)
g
# with additional aesthetics:
ggroc(rocobj, alpha = 0.5, colour = "red", linetype = 2, size = 2)

# You can then your own theme, etc.
g + theme_minimal() + ggtitle("My ROC curve") + 
    geom_segment(aes(x = 1, xend = 0, y = 0, yend = 1), color="grey", linetype="dashed")

# And change axis labels to FPR/FPR
gl &lt;- ggroc(rocobj, legacy.axes = TRUE)
gl
gl + xlab("FPR") + ylab("TPR") + 
    geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color="darkgrey", linetype="dashed")

# Multiple curves:
g2 &lt;- ggroc(list(s100b=rocobj, wfns=rocobj2, ndka=roc(aSAH$outcome, aSAH$ndka)))
g2

# This is equivalent to using roc.formula:
roc.list &lt;- roc(outcome ~ s100b + ndka + wfns, data = aSAH)
g.list &lt;- ggroc(roc.list)
g.list

# You can change the aesthetics as you normally would with ggplot2:
g.list + scale_colour_brewer(palette="RdGy")
g.list + scale_colour_manual(values = c("red", "blue", "black"))

# with additional aesthetics:
g3 &lt;- ggroc(roc.list, linetype=2)
g3
g4 &lt;- ggroc(roc.list, aes="linetype", color="red")
g4
# changing multiple aesthetics:
g5 &lt;- ggroc(roc.list, aes=c("linetype", "color"))
g5

# OR faceting
g.list + facet_grid(.~name) + theme(legend.position="none")
}
</code></pre>

<hr>
<h2 id='groupGeneric'>
pROC Group Generic Functions
</h2><span id='topic+groupGeneric'></span><span id='topic+groupGeneric.pROC'></span><span id='topic+groupGeneric.auc'></span><span id='topic+groupGeneric.ci.coords'></span><span id='topic+groupGeneric.ci.se'></span><span id='topic+groupGeneric.ci.sp'></span><span id='topic+Ops'></span><span id='topic+Math'></span><span id='topic+Ops.auc'></span><span id='topic+Math.auc'></span><span id='topic+Ops.ci.coords'></span><span id='topic+Math.ci.coords'></span><span id='topic+Ops.ci.se'></span><span id='topic+Math.ci.se'></span><span id='topic+Ops.ci.sp'></span><span id='topic+Math.ci.sp'></span><span id='topic+Ops.ci.auc'></span><span id='topic+Math.ci.auc'></span><span id='topic+Ops.ci'></span><span id='topic+Math.ci'></span>

<h3>Description</h3>

<p>Redefine <span class="pkg">base</span> groupGeneric functions to handle <code><a href="#topic+auc">auc</a></code> and <code><a href="#topic+ci">ci</a></code> objects properly on operations and mathematical operations.
Attributes are dropped so that the AUC/CI behaves as a numeric value/matrix, respectively.
In the case of AUC, all attributes are dropped, while in CI only the CI-specific attributes are, keeping those necessary for the matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Math(x, ...)
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupGeneric_+3A_x">x</code>, <code id="groupGeneric_+3A_e1">e1</code>, <code id="groupGeneric_+3A_e2">e2</code></td>
<td>
<p><code><a href="#topic+auc">auc</a></code> objects, or mixed numerics and <code>auc</code> objects.
</p>
</td></tr>
<tr><td><code id="groupGeneric_+3A_...">...</code></td>
<td>
<p>further arguments passed to other Math methods.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+groupGeneric">groupGeneric</a></code>, <code><a href="#topic+auc">auc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

# Create a roc object:
aucobj1 &lt;- auc(roc(aSAH$outcome, aSAH$s100b))
aucobj2 &lt;- auc(roc(aSAH$outcome, aSAH$wfns))

# Math
sqrt(aucobj1)
round(aucobj2, digits=1)

# Ops
aucobj1 * 2
2 * aucobj2
aucobj1 + aucobj2

# With CI
ciaucobj &lt;- ci(aucobj1)
ciaucobj * 2
sqrt(ciaucobj)

</code></pre>

<hr>
<h2 id='has.partial.auc'>
Does the ROC curve have a partial AUC?
</h2><span id='topic+has.partial.auc'></span><span id='topic+has.partial.auc.smooth.roc'></span><span id='topic+has.partial.auc.auc'></span><span id='topic+has.partial.auc.roc'></span>

<h3>Description</h3>

<p>This function determines if the ROC curve has a partial AUC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.partial.auc(roc)
## S3 method for class 'auc'
has.partial.auc(roc)
## S3 method for class 'smooth.roc'
has.partial.auc(roc)
## S3 method for class 'roc'
has.partial.auc(roc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has.partial.auc_+3A_roc">roc</code></td>
<td>
<p>the ROC curve to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the AUC is a partial AUC, <code>FALSE</code> otherwise.
</p>
<p>If the AUC is not defined (i. e. if roc was called with <code>AUC=FALSE</code>), returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

# Full AUC
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)
has.partial.auc(roc1)
has.partial.auc(auc(roc1))
has.partial.auc(smooth(roc1))

# Partial AUC
roc2 &lt;- roc(aSAH$outcome, aSAH$s100b, partial.auc = c(1, 0.9))
has.partial.auc(roc2)
has.partial.auc(smooth(roc2))

# No AUC
roc3 &lt;- roc(aSAH$outcome, aSAH$s100b, auc = FALSE)
has.partial.auc(roc3)
</code></pre>

<hr>
<h2 id='lines.roc'>
Add a ROC line to a ROC plot
</h2><span id='topic+lines.roc'></span><span id='topic+lines.roc.roc'></span><span id='topic+lines.smooth.roc'></span><span id='topic+lines.roc.smooth.roc'></span><span id='topic+lines.roc.default'></span><span id='topic+lines.roc.formula'></span>

<h3>Description</h3>

<p>This convenience function adds a ROC line to a ROC curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
lines(x, ...)
## S3 method for class 'smooth.roc'
lines(x, ...)
## S3 method for class 'roc'
lines.roc(x, lwd=2, ...)
## S3 method for class 'formula'
lines.roc(x, data, subset, na.action, ...)
## Default S3 method:
lines.roc(x, predictor, ...)
## S3 method for class 'smooth.roc'
lines.roc(x, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines.roc_+3A_x">x</code></td>
<td>
<p>a roc object from the <a href="#topic+roc">roc</a> function (for plot.roc.roc),
a formula (for plot.roc.formula) or a response vector (for
plot.roc.default).
</p>
</td></tr>
<tr><td><code id="lines.roc_+3A_predictor">predictor</code>, <code id="lines.roc_+3A_data">data</code></td>
<td>
<p>arguments for the <a href="#topic+roc">roc</a> function.</p>
</td></tr>
<tr><td><code id="lines.roc_+3A_subset">subset</code>, <code id="lines.roc_+3A_na.action">na.action</code></td>
<td>
<p>arguments for <code><a href="stats.html#topic+model.frame">model.frame</a></code></p>
</td></tr>
<tr><td><code id="lines.roc_+3A_lwd">lwd</code></td>
<td>
<p>line width (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="lines.roc_+3A_...">...</code></td>
<td>
<p>graphical parameters for <code><a href="graphics.html#topic+lines">lines</a></code>, and
especially <code>type</code> (see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>) and
arguments for <code><a href="graphics.html#topic+par">par</a></code> such as <code>col</code> (color),
<code>lty</code> (line type) or line characteristics <code>lend</code>,
<code>ljoin</code> and <code>lmitre</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of class &ldquo;roc&rdquo; invisibly. See <code><a href="#topic+roc">roc</a></code> for more details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+plot.roc">plot.roc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a few ROC curves:
data(aSAH)
roc.s100b &lt;- roc(aSAH$outcome, aSAH$s100b)
roc.wfns &lt;- roc(aSAH$outcome, aSAH$wfns)

# We need a plot to be ready
plot(roc.s100b, type = "n") # but don't actually plot the curve

# Add the line
lines(roc.s100b, type="b", pch=21, col="blue", bg="grey")

# Add the line of an other ROC curve
lines(roc.wfns, type="o", pch=19, col="red")


# Without using 'lines':
rocobj &lt;- plot.roc(aSAH$outcome, aSAH$s100b, type="b", pch=21, col="blue", bg="grey")

</code></pre>

<hr>
<h2 id='multiclass.roc'>
Multi-class AUC
</h2><span id='topic+multiclass.roc'></span><span id='topic+multiclass.roc.default'></span><span id='topic+multiclass.roc.formula'></span>

<h3>Description</h3>

<p>This function builds builds multiple ROC curve to compute the
multi-class AUC as defined by Hand and Till.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiclass.roc(...)
## S3 method for class 'formula'
multiclass.roc(formula, data, ...)
## Default S3 method:
multiclass.roc(response, predictor,
levels=base::levels(as.factor(response)), 
percent=FALSE, direction = c("auto", "&lt;", "&gt;"), ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiclass.roc_+3A_response">response</code></td>
<td>
<p>a factor, numeric or character vector of
responses (true class), typically encoded with 0 (controls) and 1 (cases), as in
<code><a href="#topic+roc">roc</a></code>.
</p>
</td></tr>
<tr><td><code id="multiclass.roc_+3A_predictor">predictor</code></td>
<td>
<p>either a numeric vector, containing the value of each
observation, as in <code><a href="#topic+roc">roc</a></code>, or, a matrix giving the decision value
(e.g. probability) for each class.
</p>
</td></tr>
<tr><td><code id="multiclass.roc_+3A_formula">formula</code></td>
<td>
<p>a formula of the type <code>response~predictor</code>.</p>
</td></tr>
<tr><td><code id="multiclass.roc_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame containing the variables in the
formula. See <code><a href="stats.html#topic+model.frame">model.frame</a></code> for more details.</p>
</td></tr>
<tr><td><code id="multiclass.roc_+3A_levels">levels</code></td>
<td>
<p>the value of the response for controls and cases
respectively. In contrast with <code>levels</code> argument to
<code><a href="#topic+roc">roc</a></code>, all the levels are used and
<a href="utils.html#topic+combn">combined</a> to compute the multiclass AUC.
</p>
</td></tr>
<tr><td><code id="multiclass.roc_+3A_percent">percent</code></td>
<td>
<p>if the sensitivities, specificities and AUC must be
given in percent (<code>TRUE</code>) or in fraction (<code>FALSE</code>, default).
</p>
</td></tr>
<tr><td><code id="multiclass.roc_+3A_direction">direction</code></td>
<td>
<p>in which direction to make the comparison?
&ldquo;auto&rdquo; (default for univariate curves):
automatically define in which group the
median is higher and take the direction accordingly. 
Not available for multivariate curves.
&ldquo;&gt;&rdquo; (default for multivariate curves):
if the predictor values for the control group are
higher than the values of the case group (controls &gt; t &gt;= cases).
&ldquo;&lt;&rdquo;: if the predictor values for the control group are lower
or equal than the values of the case group (controls &lt; t &lt;= cases).
</p>
</td></tr>
<tr><td><code id="multiclass.roc_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+roc">roc</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs multiclass AUC as defined by Hand and Till
(2001). A multiclass AUC is a mean of several <code><a href="#topic+auc">auc</a></code> and
cannot be plotted. Only AUCs can be computed for such curves.
Confidence intervals, standard deviation, smoothing and
comparison tests are not implemented.
</p>
<p>The <code>multiclass.roc</code> function can handle two types of datasets: uni- and multi-variate.
In the univariate case, a single <code>predictor</code> vector is passed
and all the combinations of responses are assessed.
I the multivariate case, a <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>
is passed as <code>predictor</code>. The columns must be named according to the
levels of the <code>response</code>.
</p>
<p>This function has been much less tested than the rest of the package and
is more subject to bugs. Please report them if you find one.
</p>


<h3>Value</h3>

<p>If <code>predictor</code> is a vector, a list of class &ldquo;multiclass.roc&rdquo; 
(univariate) or &ldquo;mv.multiclass.roc&rdquo; (multivariate), 
with the following fields: 
</p>
<table role = "presentation">
<tr><td><code>auc</code></td>
<td>
<p>if called with <code>auc=TRUE</code>, a numeric of class &ldquo;auc&rdquo; as
defined in <code><a href="#topic+auc">auc</a></code>. Note that this is not the standard AUC
but the multi-class AUC as defined by Hand and Till.
</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>if called with <code>ci=TRUE</code>, a numeric of class &ldquo;ci&rdquo; as
defined in <code><a href="#topic+ci">ci</a></code>.
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>the response vector as passed in argument. If
<code>NA</code> values were removed, a <code>na.action</code> attribute similar
to <code><a href="stats.html#topic+na.omit">na.omit</a></code> stores the row numbers.
</p>
</td></tr>
<tr><td><code>predictor</code></td>
<td>
<p>the predictor vector as passed in argument. If
<code>NA</code> values were removed, a <code>na.action</code> attribute similar
to <code><a href="stats.html#topic+na.omit">na.omit</a></code> stores the row numbers.
</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>the levels of the response as defined in argument.</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>if the sensitivities, specificities and AUC are
reported in percent, as defined in argument.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>how the function was called. See <code><a href="base.html#topic+match.call">match.call</a></code> for
more details.
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>If <code>response</code> is an ordered factor and one of the levels
specified in <code>levels</code> is missing, a warning is issued and the
level is ignored.
</p>


<h3>References</h3>

<p>David J. Hand and Robert J. Till (2001). A Simple Generalisation of
the Area Under the ROC Curve for Multiple Class Classification
Problems. <em>Machine Learning</em> <b>45</b>(2), p. 171&ndash;186. DOI:
doi: <a href="https://doi.org/10.1023/A:1010920819831">10.1023/A:1010920819831</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####
# Examples for a univariate decision value
####
data(aSAH)

# Basic example
multiclass.roc(aSAH$gos6, aSAH$s100b)
# Produces an innocuous warning because one level has no observation

# Select only 3 of the aSAH$gos6 levels:
multiclass.roc(aSAH$gos6, aSAH$s100b, levels=c(3, 4, 5))

# Give the result in percent
multiclass.roc(aSAH$gos6, aSAH$s100b, percent=TRUE)

####
# Examples for multivariate decision values (e.g. class probabilities)
####

## Not run: 
# Example with a multinomial log-linear model from nnet
# We use the iris dataset and split into a training and test set
requireNamespace("nnet")
data(iris)
iris.sample &lt;- sample(1:150)
iris.train &lt;- iris[iris.sample[1:75],]
iris.test &lt;- iris[iris.sample[76:150],]
mn.net &lt;- nnet::multinom(Species ~ ., iris.train)

# Use predict with type="prob" to get class probabilities
iris.predictions &lt;- predict(mn.net, newdata=iris.test, type="prob")
head(iris.predictions)

# This can be used directly in multiclass.roc:
multiclass.roc(iris.test$Species, iris.predictions)

## End(Not run)


# Let's see an other example with an artificial dataset
n &lt;- c(100, 80, 150)
responses &lt;- factor(c(rep("X1", n[1]), rep("X2", n[2]), rep("X3", n[3])))
# construct prediction matrix: one column per class

preds &lt;- lapply(n, function(x) runif(x, 0.4, 0.6))
predictor &lt;- as.matrix(data.frame(
                "X1" = c(preds[[1]], runif(n[2] + n[3], 0, 0.7)),
                "X2" = c(runif(n[1], 0.1, 0.4), preds[[2]], runif(n[3], 0.2, 0.8)),
                "X3" = c(runif(n[1] + n[2], 0.3, 0.7), preds[[3]])
             ))
multiclass.roc(responses, predictor)

# One can change direction , partial.auc, percent, etc:
multiclass.roc(responses, predictor, direction = "&gt;")
multiclass.roc(responses, predictor, percent = TRUE, 
	partial.auc = c(100, 90), partial.auc.focus = "se")


# Limit set of levels
multiclass.roc(responses, predictor, levels = c("X1", "X2"))
# Use with formula. Here we need a data.frame to store the responses as characters
data &lt;- cbind(as.data.frame(predictor), "response" = responses)
multiclass.roc(response ~ X1+X3, data)

</code></pre>

<hr>
<h2 id='plot.ci'>
Plot confidence intervals
</h2><span id='topic+plot.ci'></span><span id='topic+plot.ci.thresholds'></span><span id='topic+plot.ci.se'></span><span id='topic+plot.ci.sp'></span>

<h3>Description</h3>

<p>This function adds confidence intervals to a ROC curve plot, either as
bars or as a confidence shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ci.thresholds'
plot(x, length=.01*ifelse(attr(x,
  "roc")$percent, 100, 1), col=par("fg"), ...)
## S3 method for class 'ci.sp'
plot(x, type=c("bars", "shape"), length=.01*ifelse(attr(x,
"roc")$percent, 100, 1), col=ifelse(type=="bars", par("fg"),
"gainsboro"), no.roc=FALSE, ...)
## S3 method for class 'ci.se'
plot(x, type=c("bars", "shape"), length=.01*ifelse(attr(x,
"roc")$percent, 100, 1), col=ifelse(type=="bars", par("fg"),
"gainsboro"), no.roc=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ci_+3A_x">x</code></td>
<td>
<p>a confidence interval object from the functions
<code><a href="#topic+ci.thresholds">ci.thresholds</a></code>, <code><a href="#topic+ci.se">ci.se</a></code> or <code><a href="#topic+ci.sp">ci.sp</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.ci_+3A_type">type</code></td>
<td>
<p>type of plot, &ldquo;bars&rdquo; or &ldquo;shape&rdquo;. Can be
shortened to &ldquo;b&rdquo; or &ldquo;s&rdquo;. &ldquo;shape&rdquo; is only available for
<code>ci.se</code> and <code>ci.sp</code>, not for <code>ci.thresholds</code>.
</p>
</td></tr>
<tr><td><code id="plot.ci_+3A_length">length</code></td>
<td>
<p>the length (as plot coordinates) of the bar ticks. Only
if <code>type="bars"</code>.
</p>
</td></tr>
<tr><td><code id="plot.ci_+3A_no.roc">no.roc</code></td>
<td>

<p>if <code>FALSE</code>, the ROC line is re-added over the
shape. Otherwise if <code>TRUE</code>, only the shape is plotted. Ignored
if <code>type="bars"</code>
</p>
</td></tr>
<tr><td><code id="plot.ci_+3A_col">col</code></td>
<td>
<p>color of the bars or shape.</p>
</td></tr>
<tr><td><code id="plot.ci_+3A_...">...</code></td>
<td>
<p>further arguments for <code><a href="graphics.html#topic+segments">segments</a></code> (if
<code>type="bars"</code>) or <code><a href="graphics.html#topic+polygon">polygon</a></code> (if
<code>type="shape"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds confidence intervals to a ROC curve plot, either as
bars or as a confidence shape, depending on the state of the
<code>type</code> argument. The shape is plotted over the ROC curve, so that
the curve is re-plotted unless <code>no.roc=TRUE</code>.
</p>
<p>Graphical functions are called with <a href="base.html#topic+suppressWarnings">suppressWarnings</a>.
</p>


<h3>Value</h3>

<p>This function returns the confidence interval object invisibly.
</p>


<h3>Warnings</h3>

<p>With <code>type="shape"</code>, the warning &ldquo;Low definition shape&rdquo; is
issued when the shape is defined by less than 15 confidence
intervals. In such a case, the shape is not well defined and the ROC
curve could pass outside the shape. To get a better shape, increase
the number of intervals, for example with:
</p>
<pre>plot(ci.sp(rocobj, sensitivities=seq(0, 1, .01)), type="shape")</pre>


<h3>References</h3>

<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.roc">plot.roc</a></code>, <code><a href="#topic+ci.thresholds">ci.thresholds</a></code>, <code><a href="#topic+ci.sp">ci.sp</a></code>, <code><a href="#topic+ci.se">ci.se</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)
## Not run: 
# Start a ROC plot
rocobj &lt;- plot.roc(aSAH$outcome, aSAH$s100b)
plot(rocobj)
# Thresholds
ci.thresolds.obj &lt;- ci.thresholds(rocobj)
plot(ci.thresolds.obj)
# Specificities
plot(rocobj) # restart a new plot
ci.sp.obj &lt;- ci.sp(rocobj, boot.n=500)
plot(ci.sp.obj)
# Sensitivities
plot(rocobj) # restart a new plot
ci.se.obj &lt;- ci(rocobj, of="se", boot.n=500)
plot(ci.se.obj)

# Plotting a shape. We need more
ci.sp.obj &lt;- ci.sp(rocobj, sensitivities=seq(0, 1, .01), boot.n=100)
plot(rocobj) # restart a new plot
plot(ci.sp.obj, type="shape", col="blue")

# Direct syntax (response, predictor):
plot.roc(aSAH$outcome, aSAH$s100b,
         ci=TRUE, of="thresholds")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.roc'>
Plot a ROC curve
</h2><span id='topic+plot'></span><span id='topic+plot.roc'></span><span id='topic+plot.roc.roc'></span><span id='topic+plot.smooth.roc'></span><span id='topic+plot.roc.smooth.roc'></span><span id='topic+plot.roc.default'></span><span id='topic+plot.roc.formula'></span>

<h3>Description</h3>

<p>This function plots a ROC curve. It can accept many arguments to
tweak the appearance of the plot. Two syntaxes are possible: one
object of class &ldquo;<a href="#topic+roc">roc</a>&rdquo;, or either two vectors (response, predictor) or a
formula (response~predictor) as in the <code><a href="#topic+roc">roc</a></code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
plot(x, ...)
## S3 method for class 'smooth.roc'
plot(x, ...)
## S3 method for class 'roc'
plot.roc(x, add=FALSE, reuse.auc=TRUE,
axes=TRUE, legacy.axes=FALSE,
# Generic arguments for par:
xlim=if(x$percent){c(100, 0)} else{c(1, 0)},
ylim=if(x$percent){c(0, 100)} else{c(0, 1)},
xlab=ifelse(x$percent, ifelse(legacy.axes, "100 - Specificity (%)", "Specificity (%)"),
            ifelse(legacy.axes, "1 - Specificity", "Specificity")),
ylab=ifelse(x$percent, "Sensitivity (%)", "Sensitivity"),
asp=1,
mar=c(4, 4, 2, 2)+.1,
mgp=c(2.5, 1, 0),
# col, lty and lwd for the ROC line only
col=par("col"),
lty=par("lty"),
lwd=2,
type="l",
# Identity line
identity=!add,
identity.col="darkgrey",
identity.lty=1,
identity.lwd=1,
# Print the thresholds on the plot
print.thres=FALSE,
print.thres.pch=20,
print.thres.adj=c(-.05,1.25),
print.thres.col="black",
print.thres.pattern=ifelse(x$percent, "%.1f (%.1f%%, %.1f%%)", "%.3f (%.3f, %.3f)"),
print.thres.cex=par("cex"),
print.thres.pattern.cex=print.thres.cex,
print.thres.best.method=NULL,
print.thres.best.weights=c(1, 0.5),
# Print the AUC on the plot
print.auc=FALSE,
print.auc.pattern=NULL,
print.auc.x=ifelse(x$percent, 50, .5),
print.auc.y=ifelse(x$percent, 50, .5),
print.auc.adj=c(0,1),
print.auc.col=col,
print.auc.cex=par("cex"),
# Grid
grid=FALSE,
grid.v={if(is.logical(grid) &amp;&amp; grid[1]==TRUE)
          {seq(0, 1, 0.1) * ifelse(x$percent, 100, 1)}
        else if(is.numeric(grid)) 
          {seq(0, ifelse(x$percent, 100, 1), grid[1])} else {NULL}},
grid.h={if (length(grid) == 1) {grid.v} 
        else if (is.logical(grid) &amp;&amp; grid[2]==TRUE)
          {seq(0, 1, 0.1) * ifelse(x$percent, 100, 1)} 
        else if(is.numeric(grid))
          {seq(0, ifelse(x$percent, 100, 1), grid[2])} else {NULL}},
grid.lty=3,
grid.lwd=1,
grid.col="#DDDDDD",
# Polygon for the AUC
auc.polygon=FALSE,
auc.polygon.col="gainsboro",
auc.polygon.lty=par("lty"),
auc.polygon.density=NULL,
auc.polygon.angle=45,
auc.polygon.border=NULL,
# Polygon for the maximal AUC possible                           
max.auc.polygon=FALSE,
max.auc.polygon.col="#EEEEEE", 
max.auc.polygon.lty=par("lty"),
max.auc.polygon.density=NULL,
max.auc.polygon.angle=45,
max.auc.polygon.border=NULL,
# Confidence interval
ci=!is.null(x$ci),
ci.type=c("bars", "shape", "no"),
ci.col=ifelse(ci.type=="bars", par("fg"), "gainsboro"),
...)
## S3 method for class 'formula'
plot.roc(x, data, subset, na.action, ...)
## Default S3 method:
plot.roc(x, predictor, ...)
## S3 method for class 'smooth.roc'
plot.roc(x, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.roc_+3A_x">x</code></td>
<td>
<p>a roc object from the <a href="#topic+roc">roc</a> function (for plot.roc.roc),
a formula (for plot.roc.formula) or a response vector (for
plot.roc.default).
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_predictor">predictor</code>, <code id="plot.roc_+3A_data">data</code></td>
<td>
<p>arguments for the <a href="#topic+roc">roc</a> function.</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_subset">subset</code>, <code id="plot.roc_+3A_na.action">na.action</code></td>
<td>
<p>arguments for <code><a href="stats.html#topic+model.frame">model.frame</a></code></p>
</td></tr>
<tr><td><code id="plot.roc_+3A_add">add</code></td>
<td>
<p>if TRUE, the ROC curve will be added to an existing
plot. If FALSE (default), a new plot will be created.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_reuse.auc">reuse.auc</code></td>
<td>
<p>if <code>TRUE</code> (default) and the &ldquo;roc&rdquo; object
contains an &ldquo;auc&rdquo; field, re-use these specifications for the
plot (specifically <code>print.auc</code>, <code>auc.polygon</code> and
<code>max.auc.polygon</code> arguments). See details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_axes">axes</code></td>
<td>
<p>a logical indicating if the plot axes must be drawn.</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_legacy.axes">legacy.axes</code></td>
<td>
<p>a logical indicating if the specificity axis (x
axis) must be plotted as as decreasing &ldquo;specificity&rdquo;
(<code>FALSE</code>, the default) or increasing &ldquo;1 - specificity&rdquo;
(<code>TRUE</code>) as in most legacy software. This affects only the
axis, not the plot coordinates.</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_xlim">xlim</code>, <code id="plot.roc_+3A_ylim">ylim</code>, <code id="plot.roc_+3A_xlab">xlab</code>, <code id="plot.roc_+3A_ylab">ylab</code>, <code id="plot.roc_+3A_asp">asp</code>, <code id="plot.roc_+3A_mar">mar</code>, <code id="plot.roc_+3A_mgp">mgp</code></td>
<td>
<p>Generic arguments for the
plot. See <a href="#topic+plot">plot</a> and <a href="graphics.html#topic+plot.window">plot.window</a> for more details. Only
used if <code>add=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_col">col</code>, <code id="plot.roc_+3A_lty">lty</code>, <code id="plot.roc_+3A_lwd">lwd</code></td>
<td>
<p>color, line type and line width for the ROC
curve. See <a href="graphics.html#topic+par">par</a> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_type">type</code></td>
<td>
<p>type of plotting as in <code><a href="#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_identity">identity</code></td>
<td>
<p>logical: whether or not the identity line (no discrimination
line) must be displayed. Default: only on new plots.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_identity.col">identity.col</code>, <code id="plot.roc_+3A_identity.lty">identity.lty</code>, <code id="plot.roc_+3A_identity.lwd">identity.lwd</code></td>
<td>
<p>color, line type and
line width for the identity line. Used only if identity=TRUE. See
<a href="graphics.html#topic+par">par</a> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.thres">print.thres</code></td>
<td>
<p>Should a selected set of thresholds be displayed on
the ROC curve? <code>FALSE</code>, <code>NULL</code> or &ldquo;no&rdquo;: no threshold is
displayed. <code>TRUE</code> or &ldquo;best&rdquo;: the threshold with the
highest sum sensitivity + specificity is plotted (this might be more
than one threshold). &ldquo;all&rdquo;: all the points of the ROC
curve. &ldquo;local maximas&rdquo;: all the local maximas. Numeric
vector: direct definition of the thresholds to display.
Note that on a smoothed ROC curve, only &ldquo;best&rdquo; is supported.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.thres.pch">print.thres.pch</code>, <code id="plot.roc_+3A_print.thres.adj">print.thres.adj</code>, <code id="plot.roc_+3A_print.thres.col">print.thres.col</code>, <code id="plot.roc_+3A_print.thres.cex">print.thres.cex</code></td>
<td>
<p>the plotting character (pch), text string
adjustment (adj), color (col) and character expansion factor (cex)
parameters for the printing of the thresholds. See <a href="graphics.html#topic+points">points</a> and
<a href="graphics.html#topic+par">par</a> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.thres.pattern">print.thres.pattern</code></td>
<td>
<p>the text pattern for the thresholds, as a
<a href="base.html#topic+sprintf">sprintf</a> format. Three numerics are passed to sprintf:
threshold, specificity, sensitivity.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.thres.pattern.cex">print.thres.pattern.cex</code></td>
<td>
<p>the character expansion factor (cex) for the
threshold text pattern. See <a href="graphics.html#topic+par">par</a> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.thres.best.method">print.thres.best.method</code>, <code id="plot.roc_+3A_print.thres.best.weights">print.thres.best.weights</code></td>
<td>
<p>if
<code>print.thres="best"</code> or <code>print.thres=TRUE</code>, what method must be used to determine which
threshold is the best. See argument <code>best.method</code> and <code>best.weights</code> to
<code><a href="#topic+coords">coords</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.auc">print.auc</code></td>
<td>
<p>boolean. Should the numeric value of AUC be printed
on the plot?
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.auc.pattern">print.auc.pattern</code></td>
<td>
<p>the text pattern for the AUC, as a
<a href="base.html#topic+sprintf">sprintf</a> format. If NULL, a reasonable value is computed that
takes partial AUC, CI and percent into account. If the CI
of the AUC was computed, three numerics are passed to
sprintf: AUC, lower CI bound, higher CI bound. Otherwise, only AUC is
passed.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.auc.x">print.auc.x</code>, <code id="plot.roc_+3A_print.auc.y">print.auc.y</code></td>
<td>
<p>x and y position for the printing of
the AUC.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_print.auc.adj">print.auc.adj</code>, <code id="plot.roc_+3A_print.auc.cex">print.auc.cex</code>, <code id="plot.roc_+3A_print.auc.col">print.auc.col</code></td>
<td>
<p>the text
adjustment, character expansion factor and color for the printing of
the AUC. See <a href="graphics.html#topic+par">par</a> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_grid">grid</code></td>
<td>
<p>boolean or numeric vector of length 1 or 2. Should a
background grid be added to the plot? Numeric: show a grid with the
specified interval between each line; Logical: show the grid or
not. Length 1: same values are taken for horizontal and vertical
lines. Length 2: grid value for vertical (grid[1]) and horizontal
(grid[2]). Note that these values are used to compute grid.v and
grid.h. Therefore if you specify a grid.h and grid.v, it will be
ignored. 
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_grid.v">grid.v</code>, <code id="plot.roc_+3A_grid.h">grid.h</code></td>
<td>
<p>numeric. The x and y values at which a vertical
or horizontal line (respectively) must be drawn. NULL if no line
must be added.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_grid.lty">grid.lty</code>, <code id="plot.roc_+3A_grid.lwd">grid.lwd</code>, <code id="plot.roc_+3A_grid.col">grid.col</code></td>
<td>
<p>the line type (lty), line width (lwd) and
color (col) of the lines of the grid. See <a href="graphics.html#topic+par">par</a> for
more details. Note that you can pass vectors of length 2, in which
case it specifies the vertical (1) and horizontal (2) lines.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_auc.polygon">auc.polygon</code></td>
<td>
<p>boolean. Whether or not to display the area as a
polygon.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_auc.polygon.col">auc.polygon.col</code>, <code id="plot.roc_+3A_auc.polygon.lty">auc.polygon.lty</code>, <code id="plot.roc_+3A_auc.polygon.density">auc.polygon.density</code>, <code id="plot.roc_+3A_auc.polygon.angle">auc.polygon.angle</code>, <code id="plot.roc_+3A_auc.polygon.border">auc.polygon.border</code></td>
<td>
<p>color (col), line type
(lty), density, angle and border for the AUC polygon. See
<code><a href="graphics.html#topic+polygon">polygon</a></code> and <code><a href="graphics.html#topic+par">par</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_max.auc.polygon">max.auc.polygon</code></td>
<td>
<p>boolean. Whether or not to display the maximal
possible area as a polygon.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_max.auc.polygon.col">max.auc.polygon.col</code>, <code id="plot.roc_+3A_max.auc.polygon.lty">max.auc.polygon.lty</code>, <code id="plot.roc_+3A_max.auc.polygon.density">max.auc.polygon.density</code>, <code id="plot.roc_+3A_max.auc.polygon.angle">max.auc.polygon.angle</code>, <code id="plot.roc_+3A_max.auc.polygon.border">max.auc.polygon.border</code></td>
<td>
<p>color (col), line type
(lty), density, angle and border for the maximum AUC polygon. See
<code><a href="graphics.html#topic+polygon">polygon</a></code> and <code><a href="graphics.html#topic+par">par</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_ci">ci</code></td>
<td>
<p>boolean. Should we plot the confidence intervals?</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_ci.type">ci.type</code>, <code id="plot.roc_+3A_ci.col">ci.col</code></td>
<td>
<p><code>type</code> and <code>col</code> arguments for
<code><a href="#topic+plot.ci">plot.ci</a></code>. The special value &ldquo;no&rdquo; disables the plotting of confidence intervals.
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> and <code>plot.roc.roc</code> when calling
<code>plot.roc.default</code> or <code>plot.roc.formula</code>. Note that the
<code>plot</code> argument for <code><a href="#topic+roc">roc</a></code> is not allowed.
Arguments for <code><a href="#topic+auc">auc</a></code> and graphical functions
<code><a href="#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+abline">abline</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>,
<code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+text">text</a></code> and <code><a href="#topic+plot.ci">plot.ci</a></code>
if applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically called from <code><a href="#topic+roc">roc</a></code> when plot=TRUE (not by
default). <code>plot.roc.formula</code> and <code>plot.roc.default</code> are convenience methods
that build the ROC curve (with the <code><a href="#topic+roc">roc</a></code> function) before
calling <code>plot.roc.roc</code>. You can pass them arguments for both
<code><a href="#topic+roc">roc</a></code> and <code>plot.roc.roc</code>. Simply use <code>plot.roc</code>
that will dispatch to the correct method.
</p>
<p>The plotting is done in the following order:
</p>

<ol>
<li><p> A new plot is created if <code>add=FALSE</code>.
</p>
</li>
<li><p> The grid is added if <code>grid.v</code> and <code>grid.h</code> are not NULL.
</p>
</li>
<li><p> The maximal AUC polygon is added if <code>max.auc.polygon=TRUE</code>.
</p>
</li>
<li><p> The CI shape is added if <code>ci=TRUE</code>, <code>ci.type="shape"</code> and <code>x$ci</code> isn't a &ldquo;ci.auc&rdquo;.
</p>
</li>
<li><p> The AUC polygon is added if <code>auc.polygon=TRUE</code>.
</p>
</li>
<li><p> The identity line if <code>identity=TRUE</code>.
</p>
</li>
<li><p> The actual ROC line is added.
</p>
</li>
<li><p> The CI bars are added if <code>ci=TRUE</code>, <code>ci.type="bars"</code> and <code>x$ci</code> isn't a &ldquo;ci.auc&rdquo;.
</p>
</li>
<li><p> The selected thresholds are printed if <code>print.thres</code> is <code>TRUE</code> or numeric.
</p>
</li>
<li><p> The AUC is printed if <code>print.auc=TRUE</code>.
</p>
</li></ol>

<p>Graphical functions are called with <a href="base.html#topic+suppressWarnings">suppressWarnings</a>.
</p>


<h3>Value</h3>

<p>This function returns a list of class &ldquo;roc&rdquo; invisibly. See <a href="#topic+roc">roc</a> for more details.
</p>


<h3>AUC specification</h3>

<p>For <code>print.auc</code>, <code>auc.polygon</code> and <code>max.auc.polygon</code>
arguments, an AUC specification is
required. By default, the total AUC is plotted, but you may want a
partial AUCs. The specification is defined by:
</p>

<ol>
<li><p> the &ldquo;auc&rdquo; field in the &ldquo;<a href="#topic+roc">roc</a>&rdquo; object if
<code>reuse.auc</code> is set to <code>TRUE</code> (default). It is naturally
inherited from any call to <code><a href="#topic+roc">roc</a></code> and fits most cases.
</p>
</li>
<li><p> passing the specification to <code><a href="#topic+auc">auc</a></code> with ...
(arguments <code>partial.auc</code>, <code>partial.auc.correct</code> and
<code>partial.auc.focus</code>). In this case, you must ensure either that
the <code><a href="#topic+roc">roc</a></code> object do not contain an <code>auc</code> field (if
you called <code><a href="#topic+roc">roc</a></code> with <code>auc=FALSE</code>), or set
<code>reuse.auc=FALSE</code>.
</p>
</li></ol>

<p>If <code>reuse.auc=FALSE</code> the <code><a href="#topic+auc">auc</a></code> function will always
be called with <code>...</code> to determine the specification, even if
the &ldquo;<a href="#topic+roc">roc</a>&rdquo; object do contain an <code>auc</code> field.
</p>
<p>As well if the &ldquo;<a href="#topic+roc">roc</a>&rdquo; object do not contain an <code>auc</code>
field, the <code><a href="#topic+auc">auc</a></code> function will always be called with
<code>...</code> to determine the specification.
</p>
<p>Warning: if the roc object passed to plot.roc contains an <code>auc</code>
field and <code>reuse.auc=TRUE</code>, <a href="#topic+auc">auc</a> is not called and
arguments such as <code>partial.auc</code> are silently ignored.
</p>


<h3>References</h3>

<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a few ROC curves:
data(aSAH)
roc.s100b &lt;- roc(aSAH$outcome, aSAH$s100b)
roc.wfns &lt;- roc(aSAH$outcome, aSAH$wfns)
roc.ndka &lt;- roc(aSAH$outcome, aSAH$wfns)

# Simple example:
plot(roc.s100b)

# Add a smoothed ROC:
plot(smooth(roc.s100b), add=TRUE, col="blue")
legend("bottomright", legend=c("Empirical", "Smoothed"),
       col=c(par("fg"), "blue"), lwd=2)

# With more options:
plot(roc.s100b, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),
     grid.col=c("green", "red"), max.auc.polygon=TRUE,
     auc.polygon.col="lightblue", print.thres=TRUE)

# To plot a different partial AUC, we need to ignore the existing value
# with reuse.auc=FALSE:
plot(roc.s100b, print.auc=TRUE, auc.polygon=TRUE, partial.auc=c(1, 0.8),
     partial.auc.focus="se", grid=c(0.1, 0.2), grid.col=c("green", "red"),
     max.auc.polygon=TRUE, auc.polygon.col="lightblue", 
     print.thres=TRUE, print.thres.adj = c(1, -1),
     reuse.auc=FALSE)

# Add a second ROC curve to the previous plot:
plot(roc.wfns, add=TRUE)

# Plot some thresholds, add them to the same plot
plot(roc.ndka, print.thres="best", print.thres.best.method="youden")
plot(roc.ndka, print.thres="best", print.thres.best.method="closest.topleft",
                                   add = TRUE)
plot(roc.ndka, print.thres="best", print.thres.best.method="youden",
                                   print.thres.best.weights=c(50, 0.2),
                                   print.thres.adj = c(1.1, 1.25),
                                   add = TRUE)
</code></pre>

<hr>
<h2 id='power.roc.test'>
Sample size and power computation for ROC curves
</h2><span id='topic+power.roc.test'></span><span id='topic+power.roc.test.numeric'></span><span id='topic+power.roc.test.roc'></span><span id='topic+power.roc.test.list'></span>

<h3>Description</h3>

<p>Computes sample size, power, significance level or minimum AUC for ROC curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.roc.test(...)
# One or Two ROC curves test with roc objects:
## S3 method for class 'roc'
power.roc.test(roc1, roc2, sig.level = 0.05, 
power = NULL, kappa = NULL, alternative = c("two.sided", "one.sided"),
reuse.auc=TRUE, method = c("delong", "bootstrap", "obuchowski"), ...)
# One ROC curve with a given AUC:
## S3 method for class 'numeric'
power.roc.test(auc = NULL, ncontrols = NULL, 
ncases = NULL, sig.level = 0.05, power = NULL, kappa = 1, 
alternative = c("two.sided", "one.sided"), ...)
# Two ROC curves with the given parameters:
## S3 method for class 'list'
power.roc.test(parslist, ncontrols = NULL, 
ncases = NULL, sig.level = 0.05, power = NULL,  kappa = 1, 
alternative = c("two.sided", "one.sided"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.roc.test_+3A_roc1">roc1</code>, <code id="power.roc.test_+3A_roc2">roc2</code></td>
<td>
<p>one or two &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function.
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_auc">auc</code></td>
<td>

<p>expected AUC.
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_parslist">parslist</code></td>
<td>

<p>a <code><a href="base.html#topic+list">list</a></code> of parameters for the two ROC curves test with
Obuchowski variance when no empirical ROC curve is known:
</p>

<dl>
<dt>A1</dt><dd><p>binormal A parameter for ROC curve 1</p>
</dd>
<dt>B1</dt><dd><p>binormal B parameter for ROC curve 1</p>
</dd>
<dt>A2</dt><dd><p>binormal A parameter for ROC curve 2</p>
</dd>
<dt>B2</dt><dd><p>binormal B parameter for ROC curve 2</p>
</dd>
<dt>rn</dt><dd><p>correlation between the variables in control patients</p>
</dd>
<dt>ra</dt><dd><p>correlation between the variables in case patients</p>
</dd>
<dt>delta</dt><dd><p>the difference of AUC between the two ROC curves</p>
</dd>
</dl>

<p>For a partial AUC, the following additional parameters must be set:
</p>

<dl>
<dt>FPR11</dt><dd><p>Upper bound of FPR (1 - specificity) of ROC curve 1</p>
</dd>
<dt>FPR12</dt><dd><p>Lower bound of FPR (1 - specificity) of ROC curve 1</p>
</dd>
<dt>FPR21</dt><dd><p>Upper bound of FPR (1 - specificity) of ROC curve 2</p>
</dd>
<dt>FPR22</dt><dd><p>Lower bound of FPR (1 - specificity) of ROC curve 2</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="power.roc.test_+3A_ncontrols">ncontrols</code>, <code id="power.roc.test_+3A_ncases">ncases</code></td>
<td>

<p>number of controls and case observations available.
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_sig.level">sig.level</code></td>
<td>
<p>expected significance level (probability of type I
error).
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_power">power</code></td>
<td>
<p>expected power of the test (1 - probability of type II
error).
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_kappa">kappa</code></td>
<td>

<p>expected balance between control and case observations. Must be
positive. Only for sample size determination, that is to determine
<code>ncontrols</code> and <code>ncases</code>.
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_alternative">alternative</code></td>
<td>
<p>whether a one or two-sided test is performed.</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_reuse.auc">reuse.auc</code></td>
<td>
<p>if <code>TRUE</code> (default) and the &ldquo;roc&rdquo; objects
contain an &ldquo;auc&rdquo; field, re-use these specifications for the
test. See the <em>AUC specification</em> section for more details.
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_method">method</code></td>
<td>
<p>the method to compute <a href="#topic+var.roc">variance</a> and
<a href="#topic+cov.roc">covariance</a>, either &ldquo;delong&rdquo;,
&ldquo;bootstrap&rdquo; or &ldquo;obuchowski&rdquo;. The first letter is
sufficient. Only for Two ROC curves power calculation. See
<code><a href="#topic+var">var</a></code> and <code><a href="#topic+cov">cov</a></code> documentations for more
details. 
</p>
</td></tr>
<tr><td><code id="power.roc.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially <code><a href="#topic+auc">auc</a></code> (with <code>reuse.auc=FALSE</code> or no AUC in
the ROC curve), <code><a href="#topic+cov">cov</a></code> and <code><a href="#topic+var">var</a></code> (especially
arguments <code>method</code>, <code>boot.n</code> and <code>boot.stratified</code>).
Ignored (with a warning) with a <code>parslist</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>power.htest</code> (such as that given by
<code><a href="stats.html#topic+power.t.test">power.t.test</a></code>) with the supplied and computed values.
</p>


<h3>One ROC curve power calculation</h3>

<p>If one or no ROC curves are passed to <code>power.roc.test</code>, a one ROC
curve power calculation is performed. The function expects either
<code>power</code>, <code>sig.level</code> or <code>auc</code>, or both <code>ncontrols</code>
and <code>ncases</code> to be missing, so that the parameter is determined
from the others with the formula by Obuchowski <em>et al.</em>, 2004 (formulas
2 and 3, p. 1123).
</p>
<p>For the sample size, <code>ncases</code> is computed directly from formulas
2 and 3 and ncontrols is deduced with <code>kappa</code> (defaults to the
ratio of controls to cases).
AUC is optimized by <code><a href="stats.html#topic+uniroot">uniroot</a></code> while <code>sig.level</code>
and <code>power</code> are solved as quadratic equations.
</p>
<p><code>power.roc.test</code> can also be passed a <code>roc</code> object from the <code><a href="#topic+roc">roc</a></code>
function, but the empirical ROC will not be used, only the number of
patients and the AUC.
</p>


<h3>Two paired ROC curves power calculation</h3>

<p>If two ROC curves are passed to <code>power.roc.test</code>, the function
will compute either the required sample size (if <code>power</code> is supplied),
the significance level (if <code>sig.level=NULL</code> and <code>power</code> is
supplied) or the power of a test of a difference between to AUCs
according to the formula by Obuchowski and McClish, 1997
(formulas 2 and 3, p. 1530&ndash;1531). The null hypothesis is that the AUC
of <code>roc1</code> is the same than the AUC of <code>roc2</code>, with
<code>roc1</code> taken as the reference ROC curve.
</p>
<p>For the sample size, <code>ncases</code> is computed directly from formula 2
and ncontrols is deduced with <code>kappa</code> (defaults to the
ratio of controls to cases in <code>roc1</code>).
<code>sig.level</code> and <code>power</code> are solved as quadratic equations.
</p>
<p>The variance and covariance of the ROC curve are computed with the
<code><a href="#topic+var">var</a></code> and <code><a href="#topic+cov">cov</a></code> functions. By default, DeLong
method using the algorithm by Sun and Xu (2014) is used for full
AUCs and the bootstrap for partial AUCs. It is
possible to force the use of Obuchowski's variance by specifying
<code>method="obuchowski"</code>.
</p>
<p>Alternatively when no empirical ROC curve is known, or if only one is
available, a list can be passed to <code>power.roc.test</code>, with the
contents defined in the &ldquo;Arguments&rdquo; section. The variance and
covariance are computed from Table 1 and Equation 4 and 5 of
Obuchowski and McClish (1997), p. 1530&ndash;1531.
</p>
<p>Power calculation for unpaired ROC curves is not implemented.
</p>


<h3>AUC specification</h3>

<p>The comparison of the AUC of the ROC curves needs a specification of the
AUC. The specification is defined by:
</p>

<ol>
<li><p> the &ldquo;auc&rdquo; field in the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects if
<code>reuse.auc</code> is set to <code>TRUE</code> (default)
</p>
</li>
<li><p> passing the specification to <code><a href="#topic+auc">auc</a></code> with ...
(arguments <code>partial.auc</code>, <code>partial.auc.correct</code> and
<code>partial.auc.focus</code>). In this case, you must ensure either that
the <code><a href="#topic+roc">roc</a></code> object do not contain an <code>auc</code> field (if
you called <code><a href="#topic+roc">roc</a></code> with <code>auc=FALSE</code>), or set
<code>reuse.auc=FALSE</code>.
</p>
</li></ol>

<p>If <code>reuse.auc=FALSE</code> the <code><a href="#topic+auc">auc</a></code> function will always
be called with <code>...</code> to determine the specification, even if
the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do contain an <code>auc</code> field.
</p>
<p>As well if the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do not contain an <code>auc</code>
field, the <code><a href="#topic+auc">auc</a></code> function will always be called with
<code>...</code> to determine the specification.
</p>
<p>Warning: if the roc object passed to roc.test contains an <code>auc</code>
field and <code>reuse.auc=TRUE</code>, <a href="#topic+auc">auc</a> is not called and
arguments such as <code>partial.auc</code> are silently ignored.
</p>


<h3>Acknowledgements</h3>

<p>The authors would like to thank Christophe Combescure and Anne-Sophie
Jannot for their help with the implementation of this section of the package.
</p>


<h3>References</h3>

<p>Elisabeth R. DeLong, David M. DeLong and Daniel L. Clarke-Pearson
(1988) &ldquo;Comparing the areas under two or more correlated receiver
operating characteristic curves: a nonparametric
approach&rdquo;. <em>Biometrics</em> <b>44</b>, 837&ndash;845.
</p>
<p>Nancy A. Obuchowski, Donna K. McClish (1997). &ldquo;Sample size
determination for diagnostic accurary studies involving binormal ROC
curve indices&rdquo;. <em>Statistics in Medicine</em>, <b>16</b>,
1529&ndash;1542. DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(19970715)16:13%3C1529::AID-SIM565%3E3.0.CO;2-H">10.1002/(SICI)1097-0258(19970715)16:13&lt;1529::AID-SIM565&gt;3.0.CO;2-H</a>.
</p>
<p>Nancy A. Obuchowski, Micharl L. Lieber, Frank H. Wians
Jr. (2004). &ldquo;ROC Curves in Clinical Chemistry: Uses, Misuses, and
Possible Solutions&rdquo;. <em>Clinical Chemistry</em>, <b>50</b>, 1118&ndash;1125. DOI:
doi: <a href="https://doi.org/10.1373/clinchem.2004.031823">10.1373/clinchem.2004.031823</a>.
</p>
<p>Xu Sun and Weichao Xu (2014) &ldquo;Fast Implementation of DeLongs Algorithm for Comparing
the Areas Under Correlated Receiver Operating Characteristic Curves&rdquo;. <em>IEEE Signal
Processing Letters</em>, <b>21</b>, 1389&ndash;1393. 
DOI: doi: <a href="https://doi.org/10.1109/LSP.2014.2337313">10.1109/LSP.2014.2337313</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+roc.test">roc.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

#### One ROC curve ####

# Build a roc object:
rocobj &lt;- roc(aSAH$outcome, aSAH$s100b)

# Determine power of one ROC curve:
power.roc.test(rocobj)
# Same as:
power.roc.test(ncases=41, ncontrols=72, auc=0.73, sig.level=0.05)
# sig.level=0.05 is implicit and can be omitted:
power.roc.test(ncases=41, ncontrols=72, auc=0.73)

# Determine ncases &amp; ncontrols:
power.roc.test(auc=rocobj$auc, sig.level=0.05, power=0.95, kappa=1.7)
power.roc.test(auc=0.73, sig.level=0.05, power=0.95, kappa=1.7)

# Determine sig.level:
power.roc.test(ncases=41, ncontrols=72, auc=0.73, power=0.95, sig.level=NULL)

# Derermine detectable AUC:
power.roc.test(ncases=41, ncontrols=72, sig.level=0.05, power=0.95)


#### Two ROC curves ####

###  Full AUC
roc1 &lt;- roc(aSAH$outcome, aSAH$ndka)
roc2 &lt;- roc(aSAH$outcome, aSAH$wfns)

## Sample size
# With DeLong variance (default)
power.roc.test(roc1, roc2, power=0.9)
# With Obuchowski variance
power.roc.test(roc1, roc2, power=0.9, method="obuchowski")

## Power test
# With DeLong variance (default)
power.roc.test(roc1, roc2)
# With Obuchowski variance
power.roc.test(roc1, roc2, method="obuchowski")

## Significance level
# With DeLong variance (default)
power.roc.test(roc1, roc2, power=0.9, sig.level=NULL)
# With Obuchowski variance
power.roc.test(roc1, roc2, power=0.9, sig.level=NULL, method="obuchowski")

### Partial AUC
roc3 &lt;- roc(aSAH$outcome, aSAH$ndka, partial.auc=c(1, 0.9))
roc4 &lt;- roc(aSAH$outcome, aSAH$wfns, partial.auc=c(1, 0.9))

## Sample size
# With bootstrap variance (default)
## Not run: 
power.roc.test(roc3, roc4, power=0.9)

## End(Not run)
# With Obuchowski variance
power.roc.test(roc3, roc4, power=0.9, method="obuchowski")

## Power test
# With bootstrap variance (default)
## Not run: 
power.roc.test(roc3, roc4)
# This is exactly equivalent:
power.roc.test(roc1, roc2, reuse.auc=FALSE, partial.auc=c(1, 0.9))

## End(Not run)
# With Obuchowski variance
power.roc.test(roc3, roc4, method="obuchowski")

## Significance level
# With bootstrap variance (default)
## Not run: 
power.roc.test(roc3, roc4, power=0.9, sig.level=NULL)

## End(Not run)
# With Obuchowski variance
power.roc.test(roc3, roc4, power=0.9, sig.level=NULL, method="obuchowski")

## With only binormal parameters given
# From example 2 of Obuchowski and McClish, 1997.
ob.params &lt;- list(A1=2.6, B1=1, A2=1.9, B2=1, rn=0.6, ra=0.6, FPR11=0,
FPR12=0.2, FPR21=0, FPR22=0.2, delta=0.037) 

power.roc.test(ob.params, power=0.8, sig.level=0.05)
power.roc.test(ob.params, power=0.8, sig.level=NULL, ncases=107)
power.roc.test(ob.params, power=NULL, sig.level=0.05, ncases=107)

</code></pre>

<hr>
<h2 id='print'>
Print a ROC curve object
</h2><span id='topic+print.roc'></span><span id='topic+print.smooth.roc'></span><span id='topic+print.multiclass.roc'></span><span id='topic+print.mv.multiclass.roc'></span><span id='topic+print.ci.auc'></span><span id='topic+print.ci.thresholds'></span><span id='topic+print.ci.coords'></span><span id='topic+print.ci.se'></span><span id='topic+print.ci.sp'></span><span id='topic+print.auc'></span><span id='topic+print.multiclass.auc'></span>

<h3>Description</h3>

<p>This function prints a ROC curve, AUC or CI object and return it invisibly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
print(x, digits=max(3, getOption("digits") - 3), call=TRUE, ...)
## S3 method for class 'multiclass.roc'
print(x, digits=max(3, getOption("digits") -
  3), call=TRUE, ...) 
## S3 method for class 'mv.multiclass.roc'
print(x, digits=max(3, getOption("digits") -
  3), call=TRUE, ...) 
## S3 method for class 'smooth.roc'
print(x, digits=max(3, getOption("digits") - 3),
call=TRUE, ...)
## S3 method for class 'auc'
print(x, digits=max(3, getOption("digits") - 3), ...)
## S3 method for class 'multiclass.auc'
print(x, digits=max(3, getOption("digits") - 3), ...)
## S3 method for class 'ci.auc'
print(x, digits=max(3, getOption("digits") - 3), ...)
## S3 method for class 'ci.thresholds'
print(x, digits=max(3, getOption("digits") - 3), ...)
## S3 method for class 'ci.se'
print(x, digits=max(3, getOption("digits") - 3), ...)
## S3 method for class 'ci.sp'
print(x, digits=max(3, getOption("digits") - 3), ...)
## S3 method for class 'ci.coords'
print(x, digits=max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a roc, auc or ci object, from the <a href="#topic+roc">roc</a>, <a href="#topic+auc">auc</a> or
<a href="#topic+ci">ci</a> functions respectively.
</p>
</td></tr>
<tr><td><code id="print_+3A_call">call</code></td>
<td>
<p>if the call is printed.</p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p>the number of significant figures to print. See
<a href="base.html#topic+signif">signif</a> for more details.
</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. In
particular, <code>print.roc</code> calls <code>print.auc</code> and the
<code>print.ci</code> variants internally, and a <code>digits</code> argument is
propagated. Not used in print.auc and print.ci variants.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return the object they were passed invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code>, <code><a href="#topic+coords">coords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

# Print a roc object:
rocobj &lt;- roc(aSAH$outcome, aSAH$s100b)
print(rocobj)

# Print a smoothed roc object
print(smooth(rocobj))

# implicit printing
 roc(aSAH$outcome, aSAH$s100b)

# Print an auc and a ci object, from the ROC object or calling
# the dedicated function:
print(rocobj$auc)
print(ci(rocobj))
</code></pre>

<hr>
<h2 id='roc'>
Build a ROC curve
</h2><span id='topic+roc'></span><span id='topic+roc_'></span><span id='topic+roc.formula'></span><span id='topic+roc.data.frame'></span><span id='topic+roc.default'></span>

<h3>Description</h3>

<p>This is the main function of the pROC package. It builds a ROC
curve and returns a &ldquo;roc&rdquo; object, a list of class
&ldquo;roc&rdquo;. This object can be <code>print</code>ed, <code>plot</code>ted, or
passed to the functions <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code>,
<code><a href="#topic+smooth.roc">smooth.roc</a></code> and <code><a href="#topic+coords">coords</a></code>. Additionally, two
<code>roc</code> objects can be compared with <code><a href="#topic+roc.test">roc.test</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc(...)
## S3 method for class 'formula'
roc(formula, data, ...)
## S3 method for class 'data.frame'
roc(data, response, predictor,
ret = c("roc", "coords", "all_coords"), ...)
## Default S3 method:
roc(response, predictor, controls, cases,
density.controls, density.cases,
levels=base::levels(as.factor(response)), percent=FALSE, na.rm=TRUE,
direction=c("auto", "&lt;", "&gt;"), algorithm = 6, quiet = FALSE, 
smooth=FALSE, auc=TRUE, ci=FALSE, plot=FALSE, smooth.method="binormal",
smooth.n=512, ci.method=NULL, density=NULL, ...)
roc_(data, response, predictor, ret = c("roc", "coords", "all_coords"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roc_+3A_response">response</code></td>
<td>
<p>a factor, numeric or character vector of
responses (true class), typically encoded with 0 (controls) and 1 (cases).
Only two classes can be used in a ROC curve. If the vector
contains more than two unique values, or if their order could be
ambiguous, use <code>levels</code> to specify which values must be used as
control and case value.
If the first argument was a <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code>response</code>
should be the name of the column in <code>data</code> containing the
response, quoted for <code>roc_</code>, and optionally quoted for 
<code>roc.data.frame</code> (non-standard evaluation or NSE).
</p>
</td></tr>
<tr><td><code id="roc_+3A_predictor">predictor</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+ordered">ordered</a></code> vector
of the same length than <code>response</code>, containing the predicted
value of each observation.
If the first argument was a <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code>predictor</code>
should be the name of the column in <code>data</code> containing the
predictor, quoted for <code>roc_</code>, and optionally quoted for 
<code>roc.data.frame</code> (non-standard evaluation or NSE).
</p>
</td></tr>
<tr><td><code id="roc_+3A_controls">controls</code>, <code id="roc_+3A_cases">cases</code></td>
<td>
<p>instead of <code>response</code>, <code>predictor</code>,
the data can be supplied as two <code><a href="base.html#topic+numeric">numeric</a></code> or
<code><a href="base.html#topic+ordered">ordered</a></code> vectors containing the predictor
values for control and case observations.
</p>
</td></tr>
<tr><td><code id="roc_+3A_density.controls">density.controls</code>, <code id="roc_+3A_density.cases">density.cases</code></td>
<td>
<p>a smoothed ROC curve can be
built directly from two densities on identical <code>x</code> points, as in
<code><a href="#topic+smooth.roc">smooth</a></code>.
</p>
</td></tr>
<tr><td><code id="roc_+3A_formula">formula</code>, <code id="roc_+3A_data">data</code></td>
<td>
<p>a formula of the type <code>response~predictor</code>. If mulitple predictors 
are passed, a named list of <code>roc</code> objects will be returned. Additional arguments
<code>data</code> and <code>subset</code>, but not <code>na.action</code> are supported, see 
<code><a href="stats.html#topic+model.frame">model.frame</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="roc_+3A_levels">levels</code></td>
<td>
<p>the value of the response for controls and cases
respectively. By default, the first two values of
<code>levels(as.factor(response))</code> are taken, and the remaining levels are ignored.
It usually captures two-class factor data correctly, but will
frequently fail for other data types (response factor with more than 2 levels,
or for example if your response is coded &ldquo;controls&rdquo; and &ldquo;cases&rdquo;,
the levels will be inverted) and must then be specified here.
If your data is coded as <code>0</code> and <code>1</code> with <code>0</code>
being the controls, you can safely omit this argument.
</p>
</td></tr>
<tr><td><code id="roc_+3A_percent">percent</code></td>
<td>
<p>if the sensitivities, specificities and AUC must be
given in percent (<code>TRUE</code>) or in fraction (<code>FALSE</code>, default).
</p>
</td></tr>
<tr><td><code id="roc_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code>, the <code>NA</code> values will be removed
(ignored by <code>roc.formula</code>).
</p>
</td></tr>
<tr><td><code id="roc_+3A_direction">direction</code></td>
<td>
<p>in which direction to make the comparison?
&ldquo;auto&rdquo; (default): automatically define in which group the
median is higher and take the direction accordingly.
&ldquo;&gt;&rdquo;: if the predictor values for the control group are
higher than the values of the case group (controls &gt; t &gt;= cases).
&ldquo;&lt;&rdquo;: if the predictor values for the control group are lower
or equal than the values of the case group (controls &lt; t &lt;= cases).
You should set this explicity to &ldquo;&gt;&rdquo; or &ldquo;&lt;&rdquo; whenever
you are resampling or randomizing the data, otherwise the 
curves will be biased towards higher AUC values.
</p>
</td></tr>
<tr><td><code id="roc_+3A_algorithm">algorithm</code></td>
<td>
<p>the method used to compute sensitivity and specificity, 
an integer of length 1 between <code>0</code> and <code>6</code>.
<code>1</code>: a safe, well-tested, pure-<span class="rlang"><b>R</b></span> code that is efficient when the 
number of thresholds is low. It goes with O(T*N).
<code>2</code>: an alternative pure-<span class="rlang"><b>R</b></span> algorithm that goes in
O(N). Typically faster than <code>1</code> when the number of thresholds of
the ROC curve is above 1000. Less tested than <code>1</code>.
<code>3</code>: a C++ 
implementation of <code>1</code>, about 3-5x faster. Typically the fastest with
ROC curves with less than 50-100 thresholds, but has a very bad worst-case
when that number increases.
<code>4</code> (debug only, slow):
runs algorithms 1 to 3 and makes sure they return the same values.
<code>5</code>: select <code>2</code> or <code>3</code> based on the number of thresholds.
<code>6</code> (default): quickly select the algorithm on the class of the data: <code>2</code>
for <code><a href="base.html#topic+numeric">numeric</a></code> and <code>3</code> for <code><a href="base.html#topic+ordered">ordered</a></code>.
<code>0</code>: use <span class="pkg">microbenchmark</span> to choose between <code>2</code> and <code>3</code>.
</p>
</td></tr>
<tr><td><code id="roc_+3A_ret">ret</code></td>
<td>
<p>for <code>roc.data.frame</code> only, whether to return the
threshold sensitivity and specificity at all thresholds (&ldquo;coords&rdquo;),
all the coordinates at all thresholds (&ldquo;all_coords&rdquo;) or the
<code>roc</code> object (&ldquo;roc&rdquo;).</p>
</td></tr>
<tr><td><code id="roc_+3A_quiet">quiet</code></td>
<td>
<p>set to <code>TRUE</code> to turn off <code><a href="base.html#topic+message">message</a></code>s
when <code>direction</code> and <code>levels</code> are auto-detected.
</p>
</td></tr>
<tr><td><code id="roc_+3A_smooth">smooth</code></td>
<td>
<p>if TRUE, the ROC curve is passed to <code><a href="#topic+smooth">smooth</a></code>
to be smoothed.
</p>
</td></tr>
<tr><td><code id="roc_+3A_auc">auc</code></td>
<td>
<p>compute the area under the curve (AUC)? If <code>TRUE</code>
(default), additional arguments can be passed to <code><a href="#topic+auc">auc</a></code>.
</p>
</td></tr>
<tr><td><code id="roc_+3A_ci">ci</code></td>
<td>
<p>compute the confidence interval (CI)? If set to <code>TRUE</code>, 
additional arguments can be passed to <code><a href="#topic+ci">ci</a></code>.
</p>
</td></tr>
<tr><td><code id="roc_+3A_plot">plot</code></td>
<td>
<p>plot the ROC curve? If <code>TRUE</code>, additional
arguments can be passed to <code><a href="#topic+plot.roc">plot.roc</a></code>.
</p>
</td></tr>
<tr><td><code id="roc_+3A_smooth.method">smooth.method</code>, <code id="roc_+3A_smooth.n">smooth.n</code>, <code id="roc_+3A_ci.method">ci.method</code></td>
<td>
<p>in <code>roc.formula</code> and
<code>roc.default</code>, the <code>method</code> and <code>n</code> arguments to
<code><a href="#topic+smooth.roc">smooth</a></code> (if <code>smooth=TRUE</code>) and
<code>of="auc"</code>) must be passed as
<code>smooth.method</code>, <code>smooth.n</code> and <code>ci.method</code> to avoid confusions.
</p>
</td></tr>
<tr><td><code id="roc_+3A_density">density</code></td>
<td>
<p><code>density</code> argument passed to <code><a href="#topic+smooth.roc">smooth</a></code>.</p>
</td></tr>
<tr><td><code id="roc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods, and
especially:
</p>

<ul>
<li> <p><code><a href="#topic+auc">auc</a></code>: <code>partial.auc</code>, <code>partial.auc.focus</code>, <code>partial.auc.correct</code>.
</p>
</li>
<li> <p><code><a href="#topic+ci">ci</a></code>: <code>of</code>, <code>conf.level</code>, <code>boot.n</code>, <code>boot.stratified</code>, <code>progress</code>
</p>
</li>
<li> <p><code><a href="#topic+ci.auc">ci.auc</a></code>:, <code>reuse.auc</code>, <code>method</code>
</p>
</li>
<li> <p><code><a href="#topic+ci.thresholds">ci.thresholds</a></code>: <code>thresholds</code>
</p>
</li>
<li> <p><code><a href="#topic+ci.se">ci.se</a></code>: <code>sensitivities</code>
</p>
</li>
<li> <p><code><a href="#topic+ci.sp">ci.sp</a></code>: <code>specificities</code>
</p>
</li>
<li> <p><code><a href="#topic+plot.roc">plot.roc</a></code>: <code>add</code>, <code>col</code> and most
other arguments to the <code><a href="#topic+plot.roc">plot.roc</a></code> function. See
<code><a href="#topic+plot.roc">plot.roc</a></code> directly for more details.
</p>
</li>
<li> <p><code><a href="#topic+smooth">smooth</a></code>: <code>method</code>, <code>n</code>, and all other
arguments. See <code><a href="#topic+smooth">smooth</a></code> for more details.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>This function's main job is to build a ROC object. See the
&ldquo;Value&rdquo; section to this page for more details. Before
returning, it will call (in this order) the <code><a href="#topic+smooth.roc">smooth</a></code>,
<code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+plot.roc">plot.roc</a></code>
functions if <code>smooth</code> <code>auc</code>, <code>ci</code> and <code>plot.roc</code>
(respectively) arguments are set to TRUE. By default, only <code>auc</code>
is called.
</p>
<p>Data can be provided as <code>response, predictor</code>, where the
predictor is the numeric (or ordered) level of the evaluated signal, and
the response encodes the observation class (control or case). The
<code>level</code> argument specifies which response level must be taken as
controls (first value of <code>level</code>) or cases (second). It can
safely be ignored when the response is encoded as <code>0</code> and
<code>1</code>, but it will frequently fail otherwise. By default, the first
two values of <code>levels(as.factor(response))</code> are taken, and the
remaining levels are ignored. This means that if your response is
coded &ldquo;control&rdquo; and &ldquo;case&rdquo;, the levels will be
inverted.
</p>
<p>In some cases, it is more convenient to pass the data as
<code>controls, cases</code>, but both arguments are ignored if
<code>response, predictor</code> was specified to non-<code>NULL</code> values.
It is also possible to pass density data with <code>density.controls,
  density.cases</code>, which will result in a smoothed ROC curve even if
<code>smooth=FALSE</code>, but are ignored if <code>response, predictor</code> or
<code>controls, cases</code> are provided.
</p>
<p>Specifications for <code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code> and
<code><a href="#topic+plot.roc">plot.roc</a></code> are not kept if <code>auc</code>, <code>ci</code> or <code>plot</code> are set to
<code>FALSE</code>. Especially, in the following case:
</p>
<pre>
    myRoc &lt;- roc(..., auc.polygon=TRUE, grid=TRUE, plot=FALSE)
    plot(myRoc)
  </pre>
<p>the plot will not have the AUC polygon nor the grid. Similarly, when
comparing &ldquo;roc&rdquo; objects, the following is not possible:
</p>
<pre>
    roc1 &lt;- roc(..., partial.auc=c(1, 0.8), auc=FALSE)
    roc2 &lt;- roc(..., partial.auc=c(1, 0.8), auc=FALSE)
    roc.test(roc1, roc2)
  </pre>
<p>This will produce a test on the full AUC, not the partial AUC. To make
a comparison on the partial AUC, you must repeat the specifications
when calling <code><a href="#topic+roc.test">roc.test</a></code>:
</p>
<pre>
    roc.test(roc1, roc2, partial.auc=c(1, 0.8))
  </pre>
<p>Note that if <code>roc</code> was called with <code>auc=TRUE</code>, the latter syntax will not
allow redefining the AUC specifications. You must use <code>reuse.auc=FALSE</code> for that.
</p>


<h3>Value</h3>

<p>If the data contained any <code>NA</code> value and <code>na.rm=FALSE</code>, <code>NA</code> is
returned. Otherwise, if <code>smooth=FALSE</code>, a list of class
&ldquo;roc&rdquo; with the following fields: 
</p>
<table role = "presentation">
<tr><td><code>auc</code></td>
<td>
<p>if called with <code>auc=TRUE</code>, a numeric of class &ldquo;auc&rdquo; as
defined in <code><a href="#topic+auc">auc</a></code>.
</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>if called with <code>ci=TRUE</code>, a numeric of class &ldquo;ci&rdquo; as
defined in <code><a href="#topic+ci">ci</a></code>.
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>the response vector. Patients whose response is not
<code><a href="base.html#topic++25in+25">%in%</a></code> <code>levels</code> are discarded. If <code>NA</code> values
were removed, a <code>na.action</code> attribute similar
to <code><a href="stats.html#topic+na.omit">na.omit</a></code> stores the row numbers. 
</p>
</td></tr>
<tr><td><code>predictor</code></td>
<td>
<p>the predictor vector converted to numeric as used to build the ROC
curve. Patients whose response is not <code><a href="base.html#topic++25in+25">%in%</a></code> <code>levels</code> are discarded. If
<code>NA</code> values were removed, a <code>na.action</code> attribute similar
to <code><a href="stats.html#topic+na.omit">na.omit</a></code> stores the row numbers.
</p>
</td></tr>
<tr><td><code>original.predictor</code>, <code>original.response</code></td>
<td>
<p>the response and predictor vectors as passed in argument.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>the levels of the response as defined in argument.</p>
</td></tr>
<tr><td><code>controls</code></td>
<td>
<p>the predictor values for the control observations.</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>the predictor values for the cases.</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>if the sensitivities, specificities and AUC are
reported in percent, as defined in argument.
</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>the direction of the comparison, as defined in argument.</p>
</td></tr>
<tr><td><code>fun.sesp</code></td>
<td>
<p>the function used to compute sensitivities and specificities.
Will be re-used in bootstrap operations.</p>
</td></tr>
<tr><td><code>sensitivities</code></td>
<td>
<p>the sensitivities defining the ROC curve.</p>
</td></tr>
<tr><td><code>specificities</code></td>
<td>
<p>the specificities defining the ROC curve.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>the thresholds at which the sensitivities and
specificities were computed. See below for details.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>how the function was called. See <code><a href="base.html#topic+match.call">match.call</a></code> for
more details.
</p>
</td></tr>
</table>
<p>If <code>smooth=TRUE</code> a list of class &ldquo;smooth.roc&rdquo; as returned
by <code><a href="#topic+smooth">smooth</a></code>, with or without additional elements
<code>auc</code> and <code>ci</code> (according to the call).
</p>


<h3>Thresholds</h3>

<p>Thresholds are selected as the means between any two consecutive values 
observed in the data. This choice is aimed to facilitate their interpretation,
as any data point will be unambiguously positive or negative
regardless of whether the comparison operator includes equality
or not.
</p>
<p>In rare cases it might not be possible to represent the
mean between two consecutive values, or one might want to use a custom 
threshold. In those cases, the semantic of the comparison
is as follows: with <code>direction = '&gt;'</code>,
observations are positive when they are smaller than or equal 
(<code>&lt;=</code>) to the threshold.
With <code>direction = '&lt;'</code>, observations are positive when they
are greater than or equal (<code>&gt;=</code>) to the threshold.
</p>
<p>As a corollary, thresholds do not correspond to actual values
in the data.
</p>


<h3>Experimental: pipelines</h3>

<p>Since version 1.15.0, the <code>roc</code> function can be used in pipelines, for instance with <span class="pkg">dplyr</span> or <span class="pkg">magrittr</span>. This is still a highly experimental feature and will change significantly in future versions  (see <a href="https://github.com/xrobin/pROC/issues/54">issue 54</a>).
The <code>roc.data.frame</code> method supports both standard and non-standard evaluation (NSE):
</p>
<pre>
library(dplyr)
# Standard evaluation:
aSAH %&gt;%
    filter(gender == "Female") %&gt;%
    roc("outcome", "s100b")
# Non-Standard Evaluation:
aSAH %&gt;%
    filter(gender == "Female") %&gt;%
    roc(outcome, s100b)
	</pre>
<p>For tasks involving programming and variable column names, the <code>roc_</code> function provides
standard evaluation:
</p>
<pre>
# Standard evaluation:
aSAH %&gt;%
    filter(gender == "Female") %&gt;%
    roc_("outcome", "s100b")
    </pre>
<p>By default it returns the <code><a href="#topic+roc">roc</a></code> object, which can then be piped to
the <code><a href="#topic+coords">coords</a></code> function to extract coordinates that can be used
in further pipelines.
</p>
<pre>
# Returns thresholds, sensitivities and specificities:
aSAH  %&gt;%
    roc(outcome, s100b) %&gt;%
    coords(transpose = FALSE) %&gt;%
    filter(sensitivity &gt; 0.6, 
           specificity &gt; 0.6)

# Returns all existing coordinates, then select precision and recall:
aSAH  %&gt;%
    roc(outcome, s100b) %&gt;%
    coords(ret = "all", transpose = FALSE) %&gt;%
    select(precision, recall)
    </pre>


<h3>Errors</h3>

<p>If no control or case observation exist for the given levels of
response, no ROC curve can be built and an error is triggered with
message &ldquo;No control observation&rdquo; or &ldquo;No case
observation&rdquo;.
</p>
<p>If the predictor is not a numeric or ordered, as defined by
<code><a href="base.html#topic+as.numeric">as.numeric</a></code> or <code><a href="base.html#topic+as.ordered">as.ordered</a></code>, the message
&ldquo;Predictor must be numeric or ordered&rdquo; is returned.
</p>
<p>The message &ldquo;No valid data provided&rdquo; is issued when the data
wasn't properly passed. Remember you need both <code>response</code> and
<code>predictor</code> of the same (not null) length, or both <code>controls</code>
and <code>cases</code>. Combinations such as <code>predictor</code> and
<code>cases</code> are not valid and will trigger this error.
</p>
<p>Infinite values of the predictor cannot always be thresholded by
infinity and can cause ROC curves to not reach 0 or 100% 
specificity or sensitivity. Since version 1.13.0, pROC returns <code>NaN</code>
with a warning message &ldquo;Infinite value(s) in predictor&rdquo; if
<code>predictor</code> contains any <a href="base.html#topic+is.infinite">infinite</a> values.
</p>


<h3>References</h3>

<p>Tom Fawcett (2006) &ldquo;An introduction to ROC analysis&rdquo;. <em>Pattern
Recognition Letters</em> <b>27</b>, 861&ndash;874. DOI:
doi: <a href="https://doi.org/10.1016/j.patrec.2005.10.010">10.1016/j.patrec.2005.10.010</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+ci">ci</a></code>, <code><a href="#topic+plot.roc">plot.roc</a></code>, <code><a href="#topic+print.roc">print.roc</a></code>, <code><a href="#topic+roc.test">roc.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

# Basic example
roc(aSAH$outcome, aSAH$s100b,
    levels=c("Good", "Poor"))
# As levels aSAH$outcome == c("Good", "Poor"),
# this is equivalent to:
roc(aSAH$outcome, aSAH$s100b)
# In some cases, ignoring levels could lead to unexpected results
# Equivalent syntaxes:
roc(outcome ~ s100b, aSAH)
roc(aSAH$outcome ~ aSAH$s100b)
with(aSAH, roc(outcome, s100b))
with(aSAH, roc(outcome ~ s100b))

# With a formula:
roc(outcome ~ s100b, data=aSAH)

## Not run: 
library(dplyr)
aSAH %&gt;%
    filter(gender == "Female") %&gt;%
    roc(outcome, s100b)

## End(Not run)

# Using subset (only with formula)
roc(outcome ~ s100b, data=aSAH, subset=(gender == "Male"))
roc(outcome ~ s100b, data=aSAH, subset=(gender == "Female"))

# With numeric controls/cases
roc(controls=aSAH$s100b[aSAH$outcome=="Good"], cases=aSAH$s100b[aSAH$outcome=="Poor"])
# With ordered controls/cases
roc(controls=aSAH$wfns[aSAH$outcome=="Good"], cases=aSAH$wfns[aSAH$outcome=="Poor"])

# Inverted the levels: "Poor" are now controls and "Good" cases:
roc(aSAH$outcome, aSAH$s100b,
    levels=c("Poor", "Good"))

# The result was exactly the same because of direction="auto".
# The following will give an AUC &lt; 0.5:
roc(aSAH$outcome, aSAH$s100b,
    levels=c("Poor", "Good"), direction="&lt;")

# If we are sure about levels and direction auto-detection,
# we can turn off the messages:
roc(aSAH$outcome, aSAH$s100b, quiet = TRUE)

# If we prefer counting in percent:
roc(aSAH$outcome, aSAH$s100b, percent=TRUE)

# Plot and CI (see plot.roc and ci for more options):
roc(aSAH$outcome, aSAH$s100b,
    percent=TRUE, plot=TRUE, ci=TRUE)

# Smoothed ROC curve
roc(aSAH$outcome, aSAH$s100b, smooth=TRUE)
# this is not identical to
smooth(roc(aSAH$outcome, aSAH$s100b))
# because in the latter case, the returned object contains no AUC
</code></pre>

<hr>
<h2 id='roc.test'>
Compare two ROC curves
</h2><span id='topic+roc.test'></span><span id='topic+roc.test.default'></span><span id='topic+roc.test.roc'></span><span id='topic+roc.test.formula'></span><span id='topic+roc.test.auc'></span><span id='topic+roc.test.smooth.roc'></span>

<h3>Description</h3>

<p>This function compares two correlated (or paired) or uncorrelated (unpaired)
ROC curves. Delong and bootstrap methods test for a difference in the
(partial) AUC of the ROC curves. The Venkatraman method tests if the two
curves are perfectly superposed. The sensitivity and specificity methods
test if the sensitivity (respectively specificity) of the ROC curves are
different at the given level of specificity (respectively sensitivity).
Several syntaxes are available: two object of class roc (which can be AUC
or smoothed ROC), or either three vectors (response, predictor1, predictor2)
or a response vector and a matrix or data.frame with two columns
(predictors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># roc.test(...)
## S3 method for class 'roc'
roc.test(roc1, roc2, method=c("delong", "bootstrap",
"venkatraman", "sensitivity", "specificity"), sensitivity = NULL,
specificity = NULL, alternative = c("two.sided", "less", "greater"),
paired=NULL, reuse.auc=TRUE, boot.n=2000, boot.stratified=TRUE,
ties.method="first", progress=getOption("pROCProgress")$name,
parallel=FALSE, conf.level=0.95, ...)
## S3 method for class 'auc'
roc.test(roc1, roc2, ...)
## S3 method for class 'smooth.roc'
roc.test(roc1, roc2, ...)
## S3 method for class 'formula'
roc.test(formula, data, ...)
## Default S3 method:
roc.test(response, predictor1, predictor2=NULL,
na.rm=TRUE, method=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roc.test_+3A_roc1">roc1</code>, <code id="roc.test_+3A_roc2">roc2</code></td>
<td>
<p>the two ROC curves to compare. Either
&ldquo;<a href="#topic+roc">roc</a>&rdquo;, &ldquo;<a href="#topic+auc">auc</a>&rdquo; or
&ldquo;<a href="#topic+smooth.roc">smooth.roc</a>&rdquo; objects (types can be mixed).
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_response">response</code></td>
<td>
<p>a vector or factor, as for the <a href="#topic+roc">roc</a> function.</p>
</td></tr>
<tr><td><code id="roc.test_+3A_predictor1">predictor1</code></td>
<td>
<p>a numeric or ordered vector as for the <a href="#topic+roc">roc</a> function, or
a matrix or data.frame with predictors two colums.</p>
</td></tr>
<tr><td><code id="roc.test_+3A_predictor2">predictor2</code></td>
<td>
<p>only if predictor1 was a vector, the second
predictor as a numeric vector.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the type response~predictor1+predictor2.
Additional arguments  <code>data</code>, <code>subset</code> and <code>na.action</code>
are supported, see <code><a href="stats.html#topic+model.frame">model.frame</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame containing the variables in the
formula. See <code><a href="stats.html#topic+model.frame">model.frame</a></code> for more details.</p>
</td></tr>
<tr><td><code id="roc.test_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code>, the observations with <code>NA</code> values
will be removed.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_method">method</code></td>
<td>
<p>the method to use, either &ldquo;delong&rdquo;,
&ldquo;bootstrap&rdquo; or &ldquo;venkatraman&rdquo;. The first letter is sufficient. If omitted, the
appropriate method is selected as explained in details.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_sensitivity">sensitivity</code>, <code id="roc.test_+3A_specificity">specificity</code></td>
<td>
<p>if <code>method="sensitivity"</code> or
<code>method="specificity"</code>, the respective level where the test
must be assessed as a numeric of length 1. </p>
</td></tr>
<tr><td><code id="roc.test_+3A_alternative">alternative</code></td>
<td>
<p>specifies the alternative hypothesis. Either of
&ldquo;two.sided&rdquo;, &ldquo;less&rdquo; or &ldquo;greater&rdquo;. The first letter is
sufficient. Default: &ldquo;two.sided&rdquo;. Only &ldquo;two.sided&rdquo; is available
with <code>method="venkatraman"</code>.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired roc.test.
If <code>NULL</code>, the paired status will be auto-detected by <code><a href="#topic+are.paired">are.paired</a></code>.
If <code>TRUE</code> but the paired status cannot be assessed by <code><a href="#topic+are.paired">are.paired</a></code>
will produce an error.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_reuse.auc">reuse.auc</code></td>
<td>
<p>if <code>TRUE</code> (default) and the &ldquo;roc&rdquo; objects
contain an &ldquo;auc&rdquo; field, re-use these specifications for the
test. See the <em>AUC specification</em> section for more details.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_boot.n">boot.n</code></td>
<td>
<p>for <code>method="bootstrap"</code> and <code>method="venkatraman"</code> only: the number of
bootstrap replicates or permutations. Default: <var>2000</var>.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>for <code>method="bootstrap"</code> only:
should the bootstrap be stratified (same number 
of cases/controls in each replicate than in the original sample) or
not. Ignored with <code>method="venkatraman"</code>. Default: <var>TRUE</var>.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_ties.method">ties.method</code></td>
<td>
<p>for <code>method="venkatraman"</code> only: argument for
<code><a href="base.html#topic+rank">rank</a></code> specifying how ties are handled. Defaults to
&ldquo;first&rdquo; as described in the paper.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, the bootstrap is processed in parallel, using 
parallel backend provided by plyr (foreach).
</p>
</td></tr>
<tr><td><code id="roc.test_+3A_conf.level">conf.level</code></td>
<td>
<p>a numeric scalar between 0 and 1 (non-inclusive) which
species the confidence level to use for any calculated CI's.</p>
</td></tr>
<tr><td><code id="roc.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code><a href="#topic+roc">roc</a></code> and <code>roc.test.roc</code>
when calling <code>roc.test.default</code> or <code>roc.test.formula</code>.
Arguments for <code><a href="#topic+auc">auc</a></code>,
and <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only <code>char</code> and <code>style</code>)
if applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compares two ROC curves. It is typically called with the two <a href="#topic+roc">roc</a> objects to
compare. <code>roc.test.default</code> is provided as a convenience
method and creates two <a href="#topic+roc">roc</a> objects before calling
<code>roc.test.roc</code>.
</p>
<p>Three methods are available: &ldquo;delong&rdquo;, &ldquo;bootstrap&rdquo; and &ldquo;venkatraman&rdquo; (see
&ldquo;Computational details&rdquo; section below). &ldquo;delong&rdquo; and
&ldquo;bootstrap&rdquo; are tests over the AUC whereas &ldquo;venkatraman&rdquo;
compares the the ROC curves themselves.
</p>
<p>Default is to use &ldquo;delong&rdquo; method except for comparison of partial AUC, smoothed
curves and curves with different <code>direction</code>, where <code>bootstrap</code>
is used. Using &ldquo;delong&rdquo; for partial AUC and smoothed ROCs is not
supported in pROC and result in an error.
It is spurious to use &ldquo;delong&rdquo; for <code><a href="#topic+roc">roc</a></code> with different
<code>direction</code> (a warning is issued but the spurious comparison is
enforced). &ldquo;venkatraman&rdquo;'s test cannot be employed to compare smoothed
ROC curves, or curves with partial AUC specifications. In addition,
and comparison of ROC curves with different
<code>direction</code> should be used with care (a warning is produced as well).
</p>
<p>If <code>alternative="two.sided"</code>, a two-sided test for difference in AUC is performed. If
<code>alternative="less"</code>, the alternative is that the AUC of roc1 is
smaller than the AUC of roc2. For <code>method="venkatraman"</code>, only
&ldquo;two.sided&rdquo; test is available.
</p>
<p>If the <code>paired</code> argument is not provided, the <code><a href="#topic+are.paired">are.paired</a></code> function is
employed to detect the paired status of the ROC curves. It will test if the original <code>response</code> is
identical between the two ROC curves (this is always the case if the call is made with 
<code>roc.test.default</code>). This detection is unlikely to raise false positives, but
this possibility cannot be excluded entierly. It would require equal sample sizes
and <code>response</code> values and order in both ROC curves. If it happens to you, use <code>paired=FALSE</code>.
If you know the ROC curves are paired you can pass <code>paired=TRUE</code>. However this is
useless as it will be tested anyway.
</p>
<p>For <a href="#topic+smooth.roc">smoothed ROC curves</a>, smoothing is performed again at each
bootstrap replicate with the parameters originally provided.
If a density smoothing was performed with user-provided
<code>density.cases</code> or <code>density.controls</code> the bootstrap cannot
be performed and an error is issued.
</p>


<h3>Value</h3>

<p>A list of class &quot;htest&quot; with following content:
</p>
<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Z (<code>method="delong"</code>) or D
(<code>method="bootstrap"</code>) statistics.
</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>the confidence interval of the test (currently only returned for the paired DeLong's test). Has an attribute <code>conf.level</code> specifiying the level of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &ldquo;DeLong's test for two
correlated ROC curves&rdquo; (if <code>method="delong"</code>) or
&ldquo;Bootstrap test for two correlated ROC curves&rdquo; (if
<code>method="bootstrap"</code>).
</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the expected value of the statistic under the null
hypothesis, that is 0.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the AUC in the two ROC curves.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the names of the data that was used.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>for <code>method="bootstrap"</code> only: the values of the
<code>boot.n</code> and <code>boot.stratified</code> arguments.
</p>
</td></tr>
</table>


<h3>AUC specification</h3>

<p>The comparison of the AUC of the ROC curves needs a specification of the
AUC. The specification is defined by:
</p>

<ol>
<li><p> the &ldquo;auc&rdquo; field in the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects if
<code>reuse.auc</code> is set to <code>TRUE</code> (default)
</p>
</li>
<li><p> passing the specification to <code><a href="#topic+auc">auc</a></code> with ...
(arguments <code>partial.auc</code>, <code>partial.auc.correct</code> and
<code>partial.auc.focus</code>). In this case, you must ensure either that
the <code><a href="#topic+roc">roc</a></code> object do not contain an <code>auc</code> field (if
you called <code><a href="#topic+roc">roc</a></code> with <code>auc=FALSE</code>), or set
<code>reuse.auc=FALSE</code>.
</p>
</li></ol>

<p>If <code>reuse.auc=FALSE</code> the <code><a href="#topic+auc">auc</a></code> function will always
be called with <code>...</code> to determine the specification, even if
the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do contain an <code>auc</code> field.
</p>
<p>As well if the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do not contain an <code>auc</code>
field, the <code><a href="#topic+auc">auc</a></code> function will always be called with
<code>...</code> to determine the specification.
</p>
<p>The AUC specification is ignored in the Venkatraman test.
</p>
<p>Warning: if the roc object passed to roc.test contains an <code>auc</code>
field and <code>reuse.auc=TRUE</code>, <a href="#topic+auc">auc</a> is not called and
arguments such as <code>partial.auc</code> are silently ignored.
</p>


<h3>Computation details</h3>

<p>With <code>method="bootstrap"</code>, the processing is done as follow:
</p>

<ol>
<li> <p><code>boot.n</code> bootstrap replicates are drawn from the
data. If <code>boot.stratified</code> is <var>TRUE</var>, each replicate contains
exactly the same number of controls and cases than the original
sample, otherwise if <var>FALSE</var> the numbers can vary.
</p>
</li>
<li><p> for each bootstrap replicate, the AUC of the two ROC curves
are computed and the difference is stored.
</p>
</li>
<li><p> The following formula is used:
</p>
<p style="text-align: center;"><code class="reqn">D=\frac{AUC1-AUC2}{s}</code>
</p>

<p>where s is the standard deviation of
the bootstrap differences and AUC1 and AUC2 the AUC of the two
(original) ROC curves.
</p>
</li>
<li> <p><var>D</var> is then compared to the normal distribution,
according to the value of <code>alternative</code>.
</p>
</li></ol>

<p>See also the Bootstrap section in
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
<p>With <code>method="delong"</code>, the processing is done as described in
DeLong <em>et al.</em> (1988) for paired ROC curves, using the algorithm
of Sun and Xu (2014). Only comparison of
two ROC curves is implemented. The method has been extended for
unpaired ROC curves where the p-value is computed with an unpaired
t-test with unequal sample size and unequal variance, with 
</p>
<p style="text-align: center;"><code class="reqn">
    D=\frac{V^r(\theta^r) - V^s(\theta^s) }{ \sqrt{S^r + S^s}}
  </code>
</p>

<p>With <code>method="venkatraman"</code>, the processing is done as described
in Venkatraman and Begg (1996) (for paired ROC curves) and Venkatraman
(2000) (for unpaired ROC curves) with <code>boot.n</code> permutation of
sample ranks (with ties breaking). For consistency reasons, the same argument <code>boot.n</code> as
in bootstrap defines the number of permutations to execute,
even though no bootstrap is performed.
</p>
<p>For <code>method="specificity"</code>, the test assesses if the sensitivity of
the ROC curves are different at the level of specificity given by the
<code>specificity</code> argument, which must be a numeric of length 1. Bootstrap is employed as with <code>method="bootstrap"</code>
and <code>boot.n</code> and <code>boot.stratified</code> are available. This is
identical to the test proposed by Pepe <em>et al.</em> (2009).
The <code>method="sensitivity"</code> is very similar, but assesses if the specificity of
the ROC curves are different at the level of sensitivity given by the
<code>sensitivity</code> argument.
</p>


<h3>Warnings</h3>

<p>If &ldquo;auc&rdquo; specifications are different in both roc objects, the
warning &ldquo;Different AUC specifications in the ROC
curves. Enforcing the inconsistency, but unexpected results may be
produced.&rdquo; is issued. Unexpected results may be produced.
</p>
<p>If one or both ROC curves are &ldquo;smooth.roc&rdquo; objects with
different smoothing specifications, the warning 
&ldquo;Different smoothing parameters in the ROC curves. Enforcing
the inconsistency, but unexpected results may be produced.&rdquo; is issued.
This warning can be benign, especially if ROC curves were generated
with <code>roc(..., smooth=TRUE)</code> with different arguments to other
functions (such as plot), or if you really want to compare two ROC
curves smoothed differently.
</p>
<p>If <code>method="venkatraman"</code>, and <code>alternative</code> is
&ldquo;less&rdquo; or &ldquo;greater&rdquo;, the warning &ldquo;Only two-sided
tests are available for Venkatraman. Performing two-sided test instead.&rdquo;
is produced and a two tailed test is performed.
</p>
<p>Both DeLong and Venkatraman's test ignores the direction of the ROC curve so that if two
ROC curves have a different differ in the value of
<code>direction</code>, the warning &ldquo;(DeLong|Venkatraman)'s test should not be
applied to ROC curves with different directions.&rdquo; is
printed. However, the spurious test is enforced.
</p>
<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, or that there are not enough
points for smoothing, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>
<p>When both ROC curves have an <code><a href="#topic+auc">auc</a></code> of 1 (or 100%), their variances and covariance will always be null,
and therefore the p-value will always be 1. This is true for both &ldquo;delong&rdquo;, &ldquo;bootstrap&rdquo; and 
&ldquo;venkatraman&rdquo; methods. This result is misleading, as the variances and covariance are of course not null.
A <code><a href="base.html#topic+warning">warning</a></code> will be displayed to inform of this condition, and of the misleading output.
</p>


<h3>Errors</h3>

<p>An error will also occur if you give a <code>predictor2</code> when
<code>predictor1</code> is a <code><a href="base.html#topic+matrix">matrix</a></code> or a
<code><a href="base.html#topic+data.frame">data.frame</a></code>, if <code>predictor1</code> has more than two
columns, or if you do not give a <code>predictor2</code> when
<code>predictor1</code> is a vector.
</p>
<p>If <code>density.cases</code> and <code>density.controls</code> were provided
for smoothing, the error &ldquo;Cannot compute the statistic on ROC
curves smoothed with density.controls and density.cases.&rdquo; is
issued.
</p>
<p>If <code>method="venkatraman"</code> and one of the ROC curves is smoothed,
the error &ldquo;Using Venkatraman's test for smoothed ROCs is not
supported.&rdquo; is produced.
</p>
<p>With <code>method="specificity"</code>, the error &ldquo;Argument
'specificity' must be numeric of length 1 for a specificity test.&rdquo;
is given unless the specificity argument is specified as a numeric of
length 1. The &ldquo;Argument 'sensitivity' must be numeric of length
1 for a sensitivity test.&rdquo; message is given for
<code>method="sensitivity"</code> under similar conditions.
</p>


<h3>Acknowledgements</h3>

<p>We would like to thank E. S. Venkatraman and Colin B. Begg for their
support in the implementation of their test.
</p>


<h3>References</h3>

<p>Elisabeth R. DeLong, David M. DeLong and Daniel L. Clarke-Pearson
(1988) &ldquo;Comparing the areas under two or more correlated receiver
operating characteristic curves: a nonparametric
approach&rdquo;. <em>Biometrics</em> <b>44</b>, 837&ndash;845.
</p>
<p>James A. Hanley and Barbara J. McNeil (1982) &ldquo;The meaning and use of
the area under a receiver operating characteristic (ROC)
curve&rdquo;. <em>Radiology</em> <b>143</b>, 29&ndash;36.
</p>
<p>Margaret Pepe, Gary Longton and Holly Janes (2009) &ldquo;Estimation and
Comparison of Receiver Operating Characteristic Curves&rdquo;. <em>The
Stata journal</em> <b>9</b>, 1.
</p>
<p>Xavier Robin, Natacha Turck, Jean-Charles Sanchez and Markus Müller
(2009) &ldquo;Combination of protein biomarkers&rdquo;. <em>useR! 2009</em>, Rennes.
<a href="https://www.r-project.org/nosvn/conferences/useR-2009/abstracts/user_author.html">https://www.r-project.org/nosvn/conferences/useR-2009/abstracts/user_author.html</a>
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>Xu Sun and Weichao Xu (2014) &ldquo;Fast Implementation of DeLongs Algorithm for Comparing
the Areas Under Correlated Receiver Operating Characteristic Curves&rdquo;. <em>IEEE Signal
Processing Letters</em>, <b>21</b>, 1389&ndash;1393. 
DOI: doi: <a href="https://doi.org/10.1109/LSP.2014.2337313">10.1109/LSP.2014.2337313</a>.
</p>
<p>E. S. Venkatraman and Colin B. Begg (1996) &ldquo;A distribution-free
procedure for comparing receiver operating characteristic curves from
a paired experiment&rdquo;. <em>Biometrika</em> <b>83</b>, 835&ndash;848.
DOI: doi: <a href="https://doi.org/10.1093/biomet/83.4.835">10.1093/biomet/83.4.835</a>.
</p>
<p>E. S. Venkatraman (2000) &ldquo;A Permutation Test to Compare Receiver
Operating Characteristic Curves&rdquo;. <em>Biometrics</em> <b>56</b>,
1134&ndash;1138. DOI: doi: <a href="https://doi.org/10.1111/j.0006-341X.2000.01134.x">10.1111/j.0006-341X.2000.01134.x</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+power.roc.test">power.roc.test</a></code>
</p>
<p>CRAN package <span class="pkg">plyr</span>, employed in this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

# Basic example with 2 roc objects
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)
roc2 &lt;- roc(aSAH$outcome, aSAH$wfns)
roc.test(roc1, roc2)

## Not run: 
# The latter used Delong's test. To use bootstrap test:
roc.test(roc1, roc2, method="bootstrap")
# Increase boot.n for a more precise p-value:
roc.test(roc1, roc2, method="bootstrap", boot.n=10000)

## End(Not run)

# Alternative syntaxes
roc.test(aSAH$outcome, aSAH$s100b, aSAH$wfns)
roc.test(aSAH$outcome, data.frame(aSAH$s100b, aSAH$wfns))

# If we had a good a priori reason to think that wfns gives a
# better classification than s100b (in other words, AUC of roc1
# should be lower than AUC of roc2):
roc.test(roc1, roc2, alternative="less")

## Not run: 
# Comparison can be done on smoothed ROCs
# Smoothing is re-done at each iteration, and execution is slow
roc.test(smooth(roc1), smooth(roc2))
# or:
roc.test(aSAH$outcome, aSAH$s100b, aSAH$wfns, smooth=TRUE, boot.n=100)

## End(Not run)
# or from an AUC (no smoothing)
roc.test(auc(roc1), roc2)

## Not run: 
# Comparison of partial AUC:
roc3 &lt;- roc(aSAH$outcome, aSAH$s100b, partial.auc=c(1, 0.8), partial.auc.focus="se")
roc4 &lt;- roc(aSAH$outcome, aSAH$wfns, partial.auc=c(1, 0.8), partial.auc.focus="se")
roc.test(roc3, roc4)
# This is strictly equivalent to:
roc.test(roc3, roc4, method="bootstrap")

# Alternatively, we could re-use roc1 and roc2 to get the same result:
roc.test(roc1, roc2, reuse.auc=FALSE, partial.auc=c(1, 0.8), partial.auc.focus="se")

# Comparison on specificity and sensitivity
roc.test(roc1, roc2, method="specificity", specificity=0.9)
roc.test(roc1, roc2, method="sensitivity", sensitivity=0.9)

## End(Not run)

# Spurious use of DeLong's test with different direction:
roc5 &lt;- roc(aSAH$outcome, aSAH$s100b, direction="&lt;")
roc6 &lt;- roc(aSAH$outcome, aSAH$s100b, direction="&gt;")
roc.test(roc5, roc6, method="delong")

## Not run: 
# Comparisons of the ROC curves
roc.test(roc1, roc2, method="venkatraman")

## End(Not run)

# Unpaired tests
roc7 &lt;- roc(aSAH$outcome, aSAH$s100b)
# artificially create an roc8 unpaired with roc7
roc8 &lt;- roc(aSAH$outcome[1:100], aSAH$s100b[1:100])
## Not run: 
roc.test(roc7, roc8, paired=FALSE, method="delong")
roc.test(roc7, roc8, paired=FALSE, method="bootstrap")
roc.test(roc7, roc8, paired=FALSE, method="venkatraman")
roc.test(roc7, roc8, paired=FALSE, method="specificity", specificity=0.9)

## End(Not run)
</code></pre>

<hr>
<h2 id='smooth'>
Smooth a ROC curve
</h2><span id='topic+smooth'></span><span id='topic+smooth.roc'></span><span id='topic+smooth.smooth.roc'></span><span id='topic+smooth.default'></span>

<h3>Description</h3>

<p>This function smoothes a ROC curve of numeric predictor. By default, a
binormal smoothing is performed, but density or custom smoothings are
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth(...)
## Default S3 method:
smooth(...)
## S3 method for class 'roc'
smooth(roc,
method=c("binormal", "density", "fitdistr", "logcondens",
"logcondens.smooth"), n=512, bw = "nrd0", density=NULL,
density.controls=density, density.cases=density,
start=NULL, start.controls=start, start.cases=start, 
reuse.auc=TRUE, reuse.ci=FALSE, ...)
## S3 method for class 'smooth.roc'
smooth(smooth.roc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_+3A_roc">roc</code>, <code id="smooth_+3A_smooth.roc">smooth.roc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, or a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function.
</p>
</td></tr>
<tr><td><code id="smooth_+3A_method">method</code></td>
<td>
<p>&ldquo;binormal&rdquo;, &ldquo;density&rdquo;, &ldquo;fitdistr&rdquo;,
&ldquo;logcondens&rdquo;, &ldquo;&quot;logcondens.smooth&quot;&rdquo;.
</p>
</td></tr>
<tr><td><code id="smooth_+3A_n">n</code></td>
<td>

<p>the number of equally spaced points where the smoothed curve will be
calculated.
</p>
</td></tr>
<tr><td><code id="smooth_+3A_bw">bw</code></td>
<td>

<p>if <code>method="density"</code> and <code>density.controls</code> and
<code>density.cases</code> are not provided, <code>bw</code> is passed to
<code><a href="stats.html#topic+density">density</a></code> to determine the bandwidth of the
density Can be a character string (&ldquo;nrd0&rdquo;, &ldquo;nrd&rdquo;,
&ldquo;ucv&rdquo;, &ldquo;bcv&rdquo; or &ldquo;SJ&rdquo;, but any name
<a href="base.html#topic+match.fun">matching</a> a function prefixed with &ldquo;bw.&rdquo; is
supported) or a numeric value, as described in <code><a href="stats.html#topic+density">density</a></code>.
Defaults to &ldquo;<a href="stats.html#topic+bandwidth">nrd0</a>&rdquo;.
</p>
</td></tr>
<tr><td><code id="smooth_+3A_density">density</code>, <code id="smooth_+3A_density.controls">density.controls</code>, <code id="smooth_+3A_density.cases">density.cases</code></td>
<td>
<p>if
<code>method="density"</code>, a numeric value of density (over the y
axis) or a function returning a density (such as
<code><a href="stats.html#topic+density">density</a></code>. If <code>method="fitdistr"</code>, a <code>densfun</code>
argument for <code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>.
If the value is different for control and case observations,
<code>density.controls</code> and <code>density.cases</code> can be employed
instead, otherwise <code>density</code> will be propagated to both
<code>density.controls</code> and <code>density.cases</code>.
</p>
</td></tr>
<tr><td><code id="smooth_+3A_start">start</code>, <code id="smooth_+3A_start.controls">start.controls</code>, <code id="smooth_+3A_start.cases">start.cases</code></td>
<td>
<p>if
<code>method="fitdistr"</code>, optionnal <code>start</code>
arguments for . <code>start.controls</code>
and <code>start.cases</code> allows to specify different distributions for
controls and cases.
</p>
</td></tr>
<tr><td><code id="smooth_+3A_reuse.auc">reuse.auc</code>, <code id="smooth_+3A_reuse.ci">reuse.ci</code></td>
<td>
<p>if <code>TRUE</code> (default for reuse.auc) and the &ldquo;roc&rdquo; objects
contain &ldquo;auc&rdquo; or &ldquo;ci&rdquo; fields, re-use these
specifications to regenerate <code><a href="#topic+auc">auc</a></code> or <code><a href="#topic+ci">ci</a></code>
on the smoothed ROC curve with the original parameters. If
<code>FALSE</code>, the object returned will not contain
&ldquo;auc&rdquo; or &ldquo;ci&rdquo; fields. It is currently not possible to
redefine <code><a href="#topic+auc">auc</a></code> and <code><a href="#topic+ci">ci</a></code> options directly: you need to call <code><a href="#topic+auc">auc</a></code> or
<code><a href="#topic+ci">ci</a></code> later for that.
</p>
</td></tr>
<tr><td><code id="smooth_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods, and
especially to <code><a href="stats.html#topic+density">density</a></code> (only <code>cut</code>, <code>adjust</code>,
and <code>kernel</code>, plus <code>window</code> for compatibility with S+) and
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method="binormal"</code>, a linear model is fitted to the quantiles of
the sensitivities and specificities. Smoothed sensitivities and
specificities are then generated from this model on <code>n</code> points.
This simple approach was found to work well for most ROC curves, but
it may produce hooked smooths in some situations (see in Hanley (1988)). 
</p>
<p>With <code>method="density"</code>, the <code><a href="stats.html#topic+density">density</a></code>
function is employed to generate a smooth kernel
density of the control and case observations as described by Zhou
<em>et al.</em> (1997), unless
<code>density.controls</code> or <code>density.cases</code> are provided
directly. <code>bw</code> can be given to
specify a bandwidth to use with <code><a href="stats.html#topic+density">density</a></code>. It can be a
numeric value or a character string (&ldquo;nrd0&rdquo;, &ldquo;nrd&rdquo;,
&ldquo;ucv&rdquo;, &ldquo;bcv&rdquo; or &ldquo;SJ&rdquo;, but any name
<a href="base.html#topic+match.fun">matching</a> a function prefixed with &ldquo;bw.&rdquo; is
supported). In the case of a character
string, the whole predictor data is employed to determine the numeric
value to use on both controls and cases.
Depending on your data, it might be a good idea to specify the
<code>kernel</code> argument for <code><a href="stats.html#topic+density">density</a></code>. By default,
&ldquo;gaussian&rdquo; is used, but &ldquo;epanechnikov&rdquo;,
&ldquo;rectangular&rdquo;, &ldquo;triangular&rdquo;, &ldquo;biweight&rdquo;,
&ldquo;cosine&rdquo; and &ldquo;optcosine&rdquo; are supported. As all the
kernels are symetrical, it might help to normalize the data first
(that is, before calling <code><a href="#topic+roc">roc</a></code>), for example with quantile
normalization:
</p>
<pre>
    norm.x &lt;- qnorm(rank(x)/(length(x)+1))
    smooth(roc(response, norm.x, ...), ...)
  </pre>
<p>Additionally, <code>density</code> can be a function which must return
either a numeric vector of densities over the y axis or a <a href="base.html#topic+list">list</a>
with a &ldquo;y&rdquo; item like the <code><a href="stats.html#topic+density">density</a></code> function. It
must accept the following input:
</p>
<pre>
    density.fun(x, n, from, to, bw, kernel, ...)
  </pre>
<p>It is important to honour <code>n</code>, <code>from</code> and <code>to</code> in order
to have the densities evaluated on the same points for controls and
cases. Failing to do so and returning densities of different length
will produce an error. It is also a good idea to use a constant
smoothing parameter (such as <code>bw</code>) especially when controls and
cases have a different number of observations, to avoid producing
smoother or rougher densities.
</p>
<p>If <code>method="fitdistr"</code>, the <code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>
function from the <span class="pkg">MASS</span> package is employed to fit parameters for
the density function <code>density</code> with optionnal start parameters
<code>start</code>. The density function are fitted
separately in control (<code>density.controls</code>, <code>start.controls</code>)
and case observations (<code>density.cases</code>,
<code>start.cases</code>). <code>density</code> can be one of the character values
allowed by <code><a href="MASS.html#topic+fitdistr">fitdistr</a></code> or a density function (such
as <code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dweibull">dweibull</a></code>, ...).
</p>
<p>The <code>method="logcondens"</code> and <code>method="logcondens.smooth"</code> use the
<span class="pkg">logcondens</span> package to generate a non smoothed or smoothed
(respectively) log-concave density estimate of of the control and case
observation with the <a href="logcondens.html#topic+logConROC">logConROC</a> function.
</p>
<p><code>smooth.default</code> forces the usage of the
<code><a href="stats.html#topic+smooth">smooth</a></code> function in the <span class="pkg">stats</span> package, so
that other code relying on <code>smooth</code> should continue to function
normally.
</p>
<p>Smoothed ROC curves can be passed to smooth again. In this case, the
smoothing is not re-applied on the smoothed ROC curve but the
original &ldquo;<a href="#topic+roc">roc</a>&rdquo; object will be re-used.
</p>
<p>Note that a <code>smooth.roc</code> curve has no threshold.
</p>


<h3>Value</h3>

<p>A list of class &ldquo;smooth.roc&rdquo; with the following fields:
</p>
<table role = "presentation">
<tr><td><code>sensitivities</code></td>
<td>
<p>the smoothed sensitivities defining the ROC curve.</p>
</td></tr>
<tr><td><code>specificities</code></td>
<td>
<p>the smoothed specificities defining the ROC curve.</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>if the sensitivities, specificities and AUC are
reported in percent, as defined in argument.
</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>the direction of the comparison, as defined in argument.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>how the function was called. See <code><a href="base.html#topic+match.call">match.call</a></code> for
more details.
</p>
</td></tr>
<tr><td><code>smoothing.args</code></td>
<td>
<p>a list of the arguments used for the
smoothing. Will serve to apply the smoothing again in further
bootstrap operations.
</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>if the original ROC curve contained an AUC, it is computed
again on the smoothed ROC.
</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>if the original ROC curve contained a CI, it is computed
again on the smoothed ROC.
</p>
</td></tr>
<tr><td><code>fit.controls</code>, <code>fit.cases</code></td>
<td>
<p>with  <code>method="fitdistr"</code> only: 
the result of <span class="pkg">MASS</span>'s
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code> function for controls and cases, with an
additional &ldquo;densfun&rdquo; item indicating the density function, if
possible as character.
</p>
</td></tr>
<tr><td><code>logcondens</code></td>
<td>
<p>with <code>method="logcondens"</code> and <code>method="logcondens.smooth"</code> only: 
the result of <span class="pkg">logcondens</span>'s <a href="logcondens.html#topic+logConROC">logConROC</a> function.
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>with <code>method="binormal"</code> only: 
the linear model from <code><a href="stats.html#topic+lm">lm</a></code> used to smooth the ROC curve.
</p>
</td></tr>
</table>


<h4>Attributes</h4>

<p>Additionally, the original <code><a href="#topic+roc">roc</a></code> object is stored as a
&ldquo;roc&rdquo; attribute.
</p>



<h3>Errors</h3>

<p>The message &ldquo;The 'density' function must return a numeric
vector or a list with a 'y' item.&rdquo; will be displayed if the
<code>density</code> function did not return a valid output. The message
&ldquo;Length of 'density.controls' and 'density.cases' differ.&rdquo;
will be displayed if the returned value differ in length.
</p>
<p>Binormal smoothing cannot smooth ROC curve defined by only one
point. Any such attempt will fail with the error &ldquo;ROC curve not
smoothable (not enough points).&rdquo;.
</p>
<p>If the smooth ROC curve was generated by <code><a href="#topic+roc">roc</a></code> with
<code>density.controls</code> and <code>density.cases</code> numeric arguments, it
cannot be smoothed and the error &ldquo;Cannot smooth a ROC curve
generated directly with numeric 'density.controls' and
'density.cases'.&rdquo; is produced.
</p>
<p><code>fitdistr</code> and <code>density</code> smoothing methods require a
<a href="base.html#topic+numeric">numeric</a> <code>predictor</code>. If the ROC curve to smooth was
generated with an ordered factor only binormal smoothing can be
applied and the message &ldquo;ROC curves of ordered predictors can
be smoothed only with binormal smoothing.&rdquo; is displayed otherwise.
</p>
<p><code>fitdistr</code>, <code>logcondens</code> and <code>logcondens.smooth</code> methods
require additional packages. If not available, the following message 
will be displayed with the required command to install the package:
&ldquo;Package ? not available, required with method='?'.
Please install it with 'install.packages(&quot;?&quot;)'. 
&rdquo;
</p>


<h3>References</h3>

<p>James E. Hanley (1988) &ldquo;The robustness of the &ldquo;binormal&rdquo; assumptions
used in fitting ROC curves&rdquo;. <em>Medical Decision Making</em> <b>8</b>, 197&ndash;203.
</p>
<p>Lutz Duembgen, Kaspar Rufibach (2011) &ldquo;logcondens: Computations Related
to Univariate Log-Concave Density Estimation&rdquo;. <em>Journal of Statistical
Software</em>, <b>39</b>, 1&ndash;28. URL: doi: <a href="https://doi.org/10.18637/jss.v039.i06">10.18637/jss.v039.i06</a>.
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) &ldquo;pROC: an open-source package for R and S+ to analyze and
compare ROC curves&rdquo;. <em>BMC Bioinformatics</em>, <b>7</b>, 77.
DOI: doi: <a href="https://doi.org/10.1186/1471-2105-12-77">10.1186/1471-2105-12-77</a>.
</p>
<p>Kaspar Rufibach (2011) &ldquo;A Smooth ROC Curve Estimator Based on Log-Concave Density Estimates&rdquo;.
<em>The International Journal of Biostatistics</em>, <b>8</b>, accepted. DOI: 
doi: <a href="https://doi.org/10.1515/1557-4679.1378">10.1515/1557-4679.1378</a>. arXiv:
<a href="https://arxiv.org/abs/1103.1787">arXiv:1103.1787</a>.
</p>
<p>William N. Venables, Brian D. Ripley (2002). &ldquo;Modern Applied Statistics with S&rdquo;. New York, Springer.
<a href="http://books.google.ch/books?id=974c4vKurNkC">Google books</a>.
</p>
<p>Kelly H. Zou, W. J. Hall and David E. Shapiro (1997) &ldquo;Smooth
non-parametric receiver operating characteristic (ROC) curves for
continuous diagnostic tests&rdquo;. <em>Statistics in Medicine</em>
<b>18</b>, 2143&ndash;2156. DOI: 
doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(19971015)16:19%3C2143::AID-SIM655%3E3.0.CO;2-3">10.1002/(SICI)1097-0258(19971015)16:19&lt;2143::AID-SIM655&gt;3.0.CO;2-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>
</p>
<p>CRAN packages <span class="pkg">MASS</span> and <span class="pkg">logcondens</span> employed in this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

##  Basic example
rocobj &lt;- roc(aSAH$outcome, aSAH$s100b)
smooth(rocobj)
# or directly with roc()
roc(aSAH$outcome, aSAH$s100b, smooth=TRUE)

# plotting
plot(rocobj)
rs &lt;- smooth(rocobj, method="binormal")
plot(rs, add=TRUE, col="green")
rs2 &lt;- smooth(rocobj, method="density")
plot(rs2, add=TRUE, col="blue")
rs3 &lt;- smooth(rocobj, method="fitdistr", density="lognormal")
plot(rs3, add=TRUE, col="magenta")
if (requireNamespace("logcondens")) {
rs4 &lt;- smooth(rocobj, method="logcondens")
plot(rs4, add=TRUE, col="brown")
rs5 &lt;- smooth(rocobj, method="logcondens.smooth")
plot(rs5, add=TRUE, col="orange")
}
legend("bottomright", legend=c("Empirical", "Binormal", "Density", "Log-normal",
                               "Log-concave density", "Smoothed log-concave density"),
       col=c("black", "green", "blue", "magenta", "brown", "orange"), lwd=2)

## Advanced smoothing

# if we know the distributions are normal with sd=0.1 and an unknown mean:
smooth(rocobj, method="fitdistr", density=dnorm, start=list(mean=1), sd=.1)
# different distibutions for controls and cases:
smooth(rocobj, method="fitdistr", density.controls="normal", density.cases="lognormal")

# with densities
bw &lt;- bw.nrd0(rocobj$predictor)
density.controls &lt;- density(rocobj$controls, from=min(rocobj$predictor) - 3 * bw,
                            to=max(rocobj$predictor) + 3*bw, bw=bw, kernel="gaussian")
density.cases &lt;- density(rocobj$cases, from=min(rocobj$predictor) - 3 * bw,
                            to=max(rocobj$predictor) + 3*bw, bw=bw, kernel="gaussian")
smooth(rocobj, method="density", density.controls=density.controls$y, 
       density.cases=density.cases$y)
# which is roughly what is done by a simple:
smooth(rocobj, method="density")

## Not run: 
## Smoothing artificial ROC curves

rand.unif &lt;- runif(1000, -1, 1)
rand.exp &lt;- rexp(1000)
rand.norm &lt;- 
rnorm(1000)

# two normals
roc.norm &lt;- roc(controls=rnorm(1000), cases=rnorm(1000)+1, plot=TRUE)
plot(smooth(roc.norm), col="green", lwd=1, add=TRUE)
plot(smooth(roc.norm, method="density"), col="red", lwd=1, add=TRUE)
plot(smooth(roc.norm, method="fitdistr"), col="blue", lwd=1, add=TRUE)
if (requireNamespace("logcondens")) {
plot(smooth(roc.norm, method="logcondens"), col="brown", lwd=1, add=TRUE)
plot(smooth(roc.norm, method="logcondens.smooth"), col="orange", lwd=1, add=TRUE)
}
legend("bottomright", legend=c("empirical", "binormal", "density", "fitdistr",
                               "logcondens", "logcondens.smooth"), 
       col=c(par("fg"), "green", "red", "blue", "brown", "orange"), lwd=c(2, 1, 1, 1))
       
# deviation from the normality
roc.norm.exp &lt;- roc(controls=rnorm(1000), cases=rexp(1000), plot=TRUE)
plot(smooth(roc.norm.exp), col="green", lwd=1, add=TRUE)
plot(smooth(roc.norm.exp, method="density"), col="red", lwd=1, add=TRUE)
# Wrong fitdistr: normality assumed by default
plot(smooth(roc.norm.exp, method="fitdistr"), col="blue", lwd=1, add=TRUE)
# Correct fitdistr
plot(smooth(roc.norm.exp, method="fitdistr", density.controls="normal",
            density.cases="exponential"), col="purple", lwd=1, add=TRUE)
if (requireNamespace("logcondens")) {
plot(smooth(roc.norm.exp, method="logcondens"), col="brown", lwd=1, add=TRUE)
plot(smooth(roc.norm.exp, method="logcondens.smooth"), col="orange", lwd=1, add=TRUE)
}
legend("bottomright", legend=c("empirical", "binormal", "density",
                               "wrong fitdistr", "correct fitdistr",
                               "logcondens", "logcondens.smooth"),
       col=c(par("fg"), "green", "red", "blue", "purple", "brown", "orange"), lwd=c(2, 1, 1, 1, 1))

# large deviation from the normality
roc.unif.exp &lt;- roc(controls=runif(1000, 2, 3), cases=rexp(1000)+2, plot=TRUE)
plot(smooth(roc.unif.exp), col="green", lwd=1, add=TRUE)
plot(smooth(roc.unif.exp, method="density"), col="red", lwd=1, add=TRUE)
plot(smooth(roc.unif.exp, method="density", bw="ucv"), col="magenta", lwd=1, add=TRUE)
# Wrong fitdistr: normality assumed by default (uniform distributions not handled)
plot(smooth(roc.unif.exp, method="fitdistr"), col="blue", lwd=1, add=TRUE)
if (requireNamespace("logcondens")) {
plot(smooth(roc.unif.exp, method="logcondens"), col="brown", lwd=1, add=TRUE)
plot(smooth(roc.unif.exp, method="logcondens.smooth"), col="orange", lwd=1, add=TRUE)
}
legend("bottomright", legend=c("empirical", "binormal", "density",
                               "density ucv", "wrong fitdistr",
                               "logcondens", "logcondens.smooth"),
       col=c(par("fg"), "green", "red", "magenta", "blue", "brown", "orange"), lwd=c(2, 1, 1, 1, 1))

## End(Not run)

# 2 uniform distributions with a custom density function
unif.density &lt;- function(x, n, from, to, bw, kernel, ...) {
  smooth.x &lt;- seq(from=from, to=to, length.out=n)
  smooth.y &lt;- dunif(smooth.x, min=min(x), max=max(x))
  return(smooth.y)
}
roc.unif &lt;- roc(controls=runif(1000, -1, 1), cases=runif(1000, 0, 2), plot=TRUE)
s &lt;- smooth(roc.unif, method="density", density=unif.density)
plot(roc.unif)
plot(s, add=TRUE, col="grey")

## Not run: 
# you can bootstrap a ROC curve smoothed with a density function:
ci(s, boot.n=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='var.roc'>
Variance of a ROC curve
</h2><span id='topic+var'></span><span id='topic+var.roc'></span><span id='topic+var.auc'></span><span id='topic+var.smooth.roc'></span><span id='topic+var.default'></span>

<h3>Description</h3>

<p>These functions compute the variance of the AUC of a ROC curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var(...)
## Default S3 method:
var(...)
## S3 method for class 'auc'
var(auc, ...)
## S3 method for class 'roc'
var(roc, method=c("delong", "bootstrap", "obuchowski"),
boot.n = 2000, boot.stratified = TRUE, reuse.auc=TRUE, 
progress = getOption("pROCProgress")$name, parallel=FALSE, ...)
## S3 method for class 'smooth.roc'
var(smooth.roc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.roc_+3A_roc">roc</code>, <code id="var.roc_+3A_smooth.roc">smooth.roc</code>, <code id="var.roc_+3A_auc">auc</code></td>
<td>
<p>a &ldquo;roc&rdquo; object from the
<code><a href="#topic+roc">roc</a></code> function, a &ldquo;smooth.roc&rdquo; object from the
<code><a href="#topic+smooth.roc">smooth</a></code> function or an &ldquo;auc&rdquo; object from
the <code><a href="#topic+auc">auc</a></code> function.
</p>
</td></tr>
<tr><td><code id="var.roc_+3A_method">method</code></td>
<td>
<p>the method to use, either &ldquo;delong&rdquo; or
&ldquo;bootstrap&rdquo;. The first letter is
sufficient. If omitted, the appropriate method is selected as
explained in details.
</p>
</td></tr>
<tr><td><code id="var.roc_+3A_reuse.auc">reuse.auc</code></td>
<td>
<p>if <code>TRUE</code> (default) and the &ldquo;roc&rdquo; objects
contain an &ldquo;auc&rdquo; field, re-use these specifications for the
test. See details.
</p>
</td></tr>
<tr><td><code id="var.roc_+3A_boot.n">boot.n</code></td>
<td>
<p>for <code>method="bootstrap"</code> only: the number of
bootstrap replicates or permutations. Default: <var>2000</var>.
</p>
</td></tr>
<tr><td><code id="var.roc_+3A_boot.stratified">boot.stratified</code></td>
<td>
<p>for <code>method="bootstrap"</code> only:
should the bootstrap be stratified (same number 
of cases/controls in each replicate than in the original sample) or
not. Default: <var>TRUE</var>.
</p>
</td></tr>
<tr><td><code id="var.roc_+3A_progress">progress</code></td>
<td>
<p>the name of progress bar to display. Typically
&ldquo;none&rdquo;, &ldquo;win&rdquo;, &ldquo;tk&rdquo; or &ldquo;text&rdquo; (see the
<code>name</code> argument to <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
more information), but a list as returned by <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>
is also accepted. See also the &ldquo;Progress bars&rdquo; section of
<a href="#topic+pROC-package">this package's documentation</a>.
</p>
</td></tr>
<tr><td><code id="var.roc_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, the bootstrap is processed in parallel, using 
parallel backend provided by plyr (foreach).
</p>
</td></tr>
<tr><td><code id="var.roc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods,
especially arguments for <code>var.roc</code> when calling <code>var</code>,
<code>var.auc</code> and <code>var.smooth.roc</code>. Arguments for
<code><a href="#topic+auc">auc</a></code> (if <code>reuse.auc=FALSE</code>) and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (only <code>char</code> and <code>style</code>) if
applicable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>var</code> function computes the variance of the AUC of a ROC
curve. It is typically called with the <a href="#topic+roc">roc</a> object of
interest. Two methods are available: &ldquo;delong&rdquo; and
&ldquo;bootstrap&rdquo; (see &ldquo;Computational
details&rdquo; section below).
</p>
<p>The default is to use &ldquo;delong&rdquo; method except for with
partial AUC and smoothed curves where &ldquo;bootstrap&rdquo; is employed.
Using &ldquo;delong&rdquo; for partial AUC and smoothed ROCs is not
supported.
</p>
<p>For <a href="#topic+smooth.roc">smoothed ROC curves</a>, smoothing is performed again at each
bootstrap replicate with the parameters originally provided.
If a density smoothing was performed with user-provided
<code>density.cases</code> or <code>density.controls</code> the bootstrap cannot
be performed and an error is issued.
</p>
<p><code>var.default</code> forces the usage of the
<code><a href="stats.html#topic+cor">var</a></code> function in the <span class="pkg">stats</span> package, so
that other code relying on <code>var</code> should continue to function
normally.
</p>


<h3>Value</h3>

<p>The numeric value of the variance.
</p>


<h3>AUC specification</h3>

<p><code>var</code> needs a specification of the AUC to compute
the variance of the AUC of the ROC curve.
The specification is defined by:
</p>

<ol>
<li><p> the &ldquo;auc&rdquo; field in the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects if
<code>reuse.auc</code> is set to <code>TRUE</code> (default)
</p>
</li>
<li><p> passing the specification to <code><a href="#topic+auc">auc</a></code> with ...
(arguments <code>partial.auc</code>, <code>partial.auc.correct</code> and
<code>partial.auc.focus</code>). In this case, you must ensure either that
the <code><a href="#topic+roc">roc</a></code> object do not contain an <code>auc</code> field (if
you called <code><a href="#topic+roc">roc</a></code> with <code>auc=FALSE</code>), or set
<code>reuse.auc=FALSE</code>.
</p>
</li></ol>

<p>If <code>reuse.auc=FALSE</code> the <code><a href="#topic+auc">auc</a></code> function will always
be called with <code>...</code> to determine the specification, even if
the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do contain an <code>auc</code> field.
</p>
<p>As well if the &ldquo;<a href="#topic+roc">roc</a>&rdquo; objects do not contain an <code>auc</code>
field, the <code><a href="#topic+auc">auc</a></code> function will always be called with
<code>...</code> to determine the specification.
</p>
<p>Warning: if the roc object passed to roc.test contains an <code>auc</code>
field and <code>reuse.auc=TRUE</code>, <a href="#topic+auc">auc</a> is not called and
arguments such as <code>partial.auc</code> are silently ignored.
</p>


<h3>Computation details</h3>

<p>With <code>method="bootstrap"</code>, the processing is done as follow:
</p>

<ol>
<li> <p><code>boot.n</code> bootstrap replicates are drawn from the
data. If <code>boot.stratified</code> is <var>TRUE</var>, each replicate contains
exactly the same number of controls and cases than the original
sample, otherwise if <var>FALSE</var> the numbers can vary.
</p>
</li>
<li><p> for each bootstrap replicate, the AUC of the ROC curve
is computed and stored.
</p>
</li>
<li><p> the variance of the resampled AUCs are computed and returned.
</p>
</li></ol>

<p>With <code>method="delong"</code>, the processing is done as described in
Hanley and Hajian-Tilaki (1997) using the algorithm by Sun and Xu (2014).
</p>
<p>With <code>method="obuchowski"</code>, the processing is done as described
in Obuchowski and McClish (1997), Table 1 and Equation 4, p. 1530&ndash;1531. The
computation of <code class="reqn">g</code> for partial area under the ROC curve is
modified as: 
</p>
<p style="text-align: center;"><code class="reqn">expr1 * (2 * pi * expr2) ^ {(-1)} * (-expr4) - A * B * expr1 * (2 * pi * expr2^3) ^ {(-1/2)} * expr3</code>
</p>
<p>.
</p>


<h3>Binormality assumption</h3>

<p>The &ldquo;obuchowski&rdquo; method makes the assumption that the data is binormal.
If the data shows a deviation from this assumption, it might help to
normalize the data first (that is, before calling <code><a href="#topic+roc">roc</a></code>),
for example with quantile normalization: 
</p>
<pre>
    norm.x &lt;- qnorm(rank(x)/(length(x)+1))
    var(roc(response, norm.x, ...), ...)
  </pre>
<p>&ldquo;delong&rdquo; and &ldquo;bootstrap&rdquo; methods make no such assumption.
</p>


<h3>Warnings</h3>

  
<p>If <code>method="delong"</code> and the AUC specification specifies a
partial AUC, the warning &ldquo;Using DeLong for partial AUC is
not supported. Using bootstrap test instead.&rdquo; is issued. The
<code>method</code> argument is ignored and &ldquo;bootstrap&rdquo; is used instead.
</p>
<p>If <code>method="delong"</code> and the ROC
curve is smoothed, the warning &ldquo;Using DeLong for
smoothed ROCs is not supported. Using bootstrap test instead.&rdquo; is
issued. The <code>method</code> argument is ignored and &ldquo;bootstrap&rdquo;
is used instead.
</p>
<p>If <code>boot.stratified=FALSE</code> and the sample has a large imbalance between
cases and controls, it could happen that one or more of the replicates
contains no case or control observation, or that there are not enough
points for smoothing, producing a <code>NA</code> area.
The warning &ldquo;NA value(s) produced during bootstrap were ignored.&rdquo;
will be issued and the observation will be ignored. If you have a large
imbalance in your sample, it could be safer to keep
<code>boot.stratified=TRUE</code>.
</p>
<p>When the ROC curve has an <code><a href="#topic+auc">auc</a></code> of 1 (or 100%), the variance will always be null.
This is true for both &ldquo;delong&rdquo; and &ldquo;bootstrap&rdquo; methods that can
not properly assess the variance in this case. This result is misleading, as the variance is of course not null.
A <code><a href="base.html#topic+warning">warning</a></code> will be displayed to inform of this condition, and of the misleading output.
</p>


<h3>Errors</h3>

<p>If <code>density.cases</code> and <code>density.controls</code> were provided
for smoothing, the error &ldquo;Cannot compute the covariance on ROC
curves smoothed with density.controls and density.cases.&rdquo; is
issued.
</p>


<h3>References</h3>

<p>Elisabeth R. DeLong, David M. DeLong and Daniel L. Clarke-Pearson
(1988) &ldquo;Comparing the areas under two or more correlated receiver
operating characteristic curves: a nonparametric
approach&rdquo;. <em>Biometrics</em> <b>44</b>, 837&ndash;845.
</p>
<p>James A. Hanley and Karim O. Hajian-Tilaki (1997) &ldquo;Sampling
variability of nonparametric estimates of the areas under receiver
operating characteristic curves: An update&rdquo;. <em>Academic
Radiology</em> <b>4</b>, 49&ndash;58. DOI:
doi: <a href="https://doi.org/10.1016/S1076-6332(97)80161-4">10.1016/S1076-6332(97)80161-4</a>.
</p>
<p>Nancy A. Obuchowski, Donna K. McClish (1997). &ldquo;Sample size
determination for diagnostic accurary studies involving binormal ROC
curve indices&rdquo;. <em>Statistics in Medicine</em>, <b>16</b>(13),
1529&ndash;1542. DOI: doi: <a href="https://doi.org/10.1002/(SICI)1097-0258(19970715)16:13%3C1529::AID-SIM565%3E3.0.CO;2-H">10.1002/(SICI)1097-0258(19970715)16:13&lt;1529::AID-SIM565&gt;3.0.CO;2-H</a>.
</p>
<p>Xu Sun and Weichao Xu (2014) &ldquo;Fast Implementation of DeLongs Algorithm for Comparing
the Areas Under Correlated Receiver Operating Characteristic Curves&rdquo;. <em>IEEE Signal
Processing Letters</em>, <b>21</b>, 1389&ndash;1393. 
DOI: doi: <a href="https://doi.org/10.1109/LSP.2014.2337313">10.1109/LSP.2014.2337313</a>.
</p>
<p>Hadley Wickham (2011) &ldquo;The Split-Apply-Combine Strategy for Data Analysis&rdquo;. <em>Journal of Statistical Software</em>, <b>40</b>, 1&ndash;29.
URL: doi: <a href="https://doi.org/10.18637/jss.v040.i01">10.18637/jss.v040.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>, <code><a href="#topic+cov.roc">cov.roc</a></code>
</p>
<p>CRAN package <span class="pkg">plyr</span>, employed in this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aSAH)

##  Basic example
roc1 &lt;- roc(aSAH$outcome, aSAH$s100b)
roc2 &lt;- roc(aSAH$outcome, aSAH$wfns)
var(roc1)
var(roc2)

# We could also write it in one line:
var(roc(aSAH$outcome, aSAH$s100b))

## Not run: 
# The latter used Delong. To use bootstrap:
var(roc1, method="bootstrap")
# Decrease boot.n for a faster execution
var(roc1,method="bootstrap", boot.n=1000)

## End(Not run)

# To use obuchowski:
var(roc1, method="obuchowski")

## Not run: 
# Variance of smoothed ROCs:
# Smoothing is re-done at each iteration, and execution is slow
var(smooth(roc1))

## End(Not run)

# or from an AUC (no smoothing)
var(auc(roc1))

## Test data from Hanley and Hajian-Tilaki, 1997
disease.present &lt;- c("Yes", "No", "Yes", "No", "No", "Yes", "Yes", "No",
                     "No", "Yes", "No", "No", "Yes", "No", "No")
field.strength.1 &lt;- c(1, 2, 5, 1, 1, 1, 2, 1, 2, 2, 1, 1, 5, 1, 1)
field.strength.2 &lt;- c(1, 1, 5, 1, 1, 1, 4, 1, 2, 2, 1, 1, 5, 1, 1)
roc3 &lt;- roc(disease.present, field.strength.1)
roc4 &lt;- roc(disease.present, field.strength.2)
# Assess the variance:
var(roc3)
var(roc4)

## Not run: 
# With bootstrap:
var(roc3, method="bootstrap")
var(roc4, method="bootstrap")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
