<!DOCTYPE html><html><head><title>Help for package plsRbeta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plsRbeta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plsRbeta-package'><p>plsRbeta-package</p></a></li>
<li><a href='#bootplsbeta'><p>Non-parametric Bootstrap for PLS beta regression models</p></a></li>
<li><a href='#coefs.plsRbeta'><p>Coefficients function for bootstrap techniques</p></a></li>
<li><a href='#coefs.plsRbeta.raw'><p>Raw coefficients function for bootstrap techniques</p></a></li>
<li><a href='#coefs.plsRbetanp'><p>Coefficients for bootstrap computations of PLSBeta models</p></a></li>
<li><a href='#colon'><p>Tumor rate and spectral data</p></a></li>
<li><a href='#ind_BCa_nt1BC'><p>ind_BCa_nt1BC</p></a></li>
<li><a href='#ind_BCa_nt1BR'><p>ind_BCa_nt1BR</p></a></li>
<li><a href='#ind_BCa_nt2BC'><p>ind_BCa_nt2BC</p></a></li>
<li><a href='#ind_BCa_nt2BR'><p>ind_BCa_nt2BR</p></a></li>
<li><a href='#ind_BCa_nt3'><p>ind_BCa_nt3</p></a></li>
<li><a href='#ind_BCa_nt3BC'><p>ind_BCa_nt3BC</p></a></li>
<li><a href='#ind_BCa_nt3BR'><p>ind_BCa_nt3BR</p></a></li>
<li><a href='#ind_BCa_nt4BC'><p>ind_BCa_nt4BC</p></a></li>
<li><a href='#ind_BCa_nt4BR'><p>ind_BCa_nt4BR</p></a></li>
<li><a href='#ind_BCa_nt5BC'><p>ind_BCa_nt5BC</p></a></li>
<li><a href='#ind_BCa_nt5BR'><p>ind_BCa_nt5BR</p></a></li>
<li><a href='#ind_BCa_nt6BC'><p>ind_BCa_nt6BC</p></a></li>
<li><a href='#ind_BCa_nt6BR'><p>ind_BCa_nt6BR</p></a></li>
<li><a href='#kfolds2Chisq'><p>Computes Predicted Chisquare for kfold cross validated partial least squares</p>
beta regression models.</a></li>
<li><a href='#kfolds2Chisqind'><p>Computes individual Predicted Chisquare for kfold cross validated partial</p>
least squares beta regression models.</a></li>
<li><a href='#kfolds2CVinfos_beta'><p>Extracts and computes information criteria and fits statistics for kfold</p>
cross validated partial least squares beta regression models</a></li>
<li><a href='#modpls_sub4'><p>A plsRbetamodel model on a data subset</p></a></li>
<li><a href='#modpls.boot3'><p>Bootstrap distribution of a 3 components model</p></a></li>
<li><a href='#permcoefs.plsRbeta'><p>Coefficients function for permutation bootstrap techniques</p></a></li>
<li><a href='#permcoefs.plsRbeta.raw'><p>Raw coefficients function for permutation bootstrap techniques</p></a></li>
<li><a href='#permcoefs.plsRbetanp'><p>Coefficients for permutation bootstrap computations of PLSBeta models</p></a></li>
<li><a href='#PLS_beta'><p>Partial least squares beta regression models</p></a></li>
<li><a href='#PLS_beta_formula'><p>Partial least squares beta regression models</p></a></li>
<li><a href='#PLS_beta_kfoldcv'><p>Partial least squares regression beta models with kfold cross validation</p></a></li>
<li><a href='#PLS_beta_kfoldcv_formula'><p>Partial least squares regression beta models with kfold cross validation</p></a></li>
<li><a href='#PLS_beta_wvc'><p>Light version of PLS_beta for cross validation purposes</p></a></li>
<li><a href='#plsRbeta'><p>Partial least squares Regression beta regression models</p></a></li>
<li><a href='#print.plsRbetamodel'><p>Print method for plsRbeta models</p></a></li>
<li><a href='#print.summary.plsRbetamodel'><p>Print method for summaries of plsRbeta models</p></a></li>
<li><a href='#simul_data_UniYX_beta'><p>Data generating function for univariate beta plsR models</p></a></li>
<li><a href='#summary.plsRbetamodel'><p>Summary method for plsRbeta models</p></a></li>
<li><a href='#tilt.bootplsbeta'><p>Non-parametric tilted bootstrap for PLS beta regression models</p></a></li>
<li><a href='#TxTum'><p>Cancer infiltration rates</p></a></li>
<li><a href='#TxTum.mod.bootBC1'><p>Bootstrap distribution TxTum BC1 model</p></a></li>
<li><a href='#TxTum.mod.bootBR6'><p>Bootstrap distribution TxTum BR6 model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-12</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, boot, Formula, MASS, plsRglm, betareg, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bipartite, knitr, markdown, plotrix, pls, plsdof, prettydoc,
rmarkdown</td>
</tr>
<tr>
<td>Title:</td>
<td>Partial Least Squares Regression for Beta Regression Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Myriam Maumy-Bertrand
    <a href="https://orcid.org/0000-0002-4615-1512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides Partial least squares Regression for (weighted) beta regression models (Bertrand 2013,  <a href="http://journal-sfds.fr/article/view/215">http://journal-sfds.fr/article/view/215</a>) and k-fold cross-validation of such models using various criteria. It allows for missing data in the explanatory variables. Bootstrap confidence intervals constructions are also available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62J12, 62J99</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fbertran.github.io/plsRbeta/">https://fbertran.github.io/plsRbeta/</a>,
<a href="https://github.com/fbertran/plsRbeta/">https://github.com/fbertran/plsRbeta/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbertran/plsRbeta/issues/">https://github.com/fbertran/plsRbeta/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-14 00:46:09 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-15 13:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='plsRbeta-package'>plsRbeta-package</h2><span id='topic+plsRbeta-package'></span>

<h3>Description</h3>

<p>Provides Partial least squares Regression for (weighted) beta regression models (Bertrand 2013,  &lt;http://journal-sfds.fr/article/view/215&gt;) and k-fold cross-validation of such models using various criteria. It allows for missing data in the explanatory variables. Bootstrap confidence intervals constructions are also available.
</p>


<h3>References</h3>

<p>Partial least squares Regression for (weighted) beta regression models (Bertrand 2013,  &lt;http://journal-sfds.fr/article/view/215&gt;), <a href="https://github.com/fbertran/plsRbeta/">https://github.com/fbertran/plsRbeta/</a> et <a href="https://fbertran.github.io/plsRbeta/">https://fbertran.github.io/plsRbeta/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
modpls &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
modpls$pp
modpls$Coeffs
modpls$Std.Coeffs
modpls$InfCrit
modpls$PredictY[1,]
rm("modpls")

data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
modpls &lt;- plsRbeta(yGasolineYield,XGasolineYield,nt=3,modele="pls-beta")
modpls$pp
modpls$Coeffs
modpls$Std.Coeffs
modpls$InfCrit
modpls$PredictY[1,]
rm("modpls")

</code></pre>

<hr>
<h2 id='bootplsbeta'>Non-parametric Bootstrap for PLS beta regression models</h2><span id='topic+bootplsbeta'></span>

<h3>Description</h3>

<p>Provides a wrapper for the bootstrap function <code>boot</code> from the
<code>boot</code> R package.<br /> Implements non-parametric bootstrap for PLS beta
regression models by case resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootplsbeta(
  object,
  typeboot = "plsmodel",
  R = 250,
  statistic = NULL,
  sim = "ordinary",
  stype = "i",
  stabvalue = 1e+06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootplsbeta_+3A_object">object</code></td>
<td>
<p>An object of class <code>plsRbetamodel</code> to bootstrap</p>
</td></tr>
<tr><td><code id="bootplsbeta_+3A_typeboot">typeboot</code></td>
<td>
<p>The type of bootstrap. Either (Y,X) boostrap
(<code>typeboot="plsmodel"</code>) or (Y,T) bootstrap
(<code>typeboot="fmodel_np"</code>). Defaults to (Y,T) resampling.</p>
</td></tr>
<tr><td><code id="bootplsbeta_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single
positive integer. For importance resampling, some resamples may use one set
of weights and others use a different set of weights. In this case <code>R</code>
would be a vector of integers where each component gives the number of
resamples from each of the rows of weights.</p>
</td></tr>
<tr><td><code id="bootplsbeta_+3A_statistic">statistic</code></td>
<td>
<p>A function which when applied to data returns a vector
containing the statistic(s) of interest. <code>statistic</code> must take at least
two arguments. The first argument passed will always be the original data.
The second will be a vector of indices, frequencies or weights which define
the bootstrap sample. Further, if predictions are required, then a third
argument is required which would be a vector of the random indices used to
generate the bootstrap predictions. Any further arguments can be passed to
statistic through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="bootplsbeta_+3A_sim">sim</code></td>
<td>
<p>A character string indicating the type of simulation required.
Possible values are <code>"ordinary"</code> (the default), <code>"balanced"</code>,
<code>"permutation"</code>, or <code>"antithetic"</code>.</p>
</td></tr>
<tr><td><code id="bootplsbeta_+3A_stype">stype</code></td>
<td>
<p>A character string indicating what the second argument of
<code>statistic</code> represents. Possible values of stype are <code>"i"</code>
(indices - the default), <code>"f"</code> (frequencies), or <code>"w"</code> (weights).</p>
</td></tr>
<tr><td><code id="bootplsbeta_+3A_stabvalue">stabvalue</code></td>
<td>
<p>A value to hard threshold bootstrap estimates computed from
atypical resamplings.</p>
</td></tr>
<tr><td><code id="bootplsbeta_+3A_...">...</code></td>
<td>
<p>Other named arguments for <code>statistic</code> which are passed
unchanged each time it is called. Any such arguments to <code>statistic</code>
should follow the arguments which <code>statistic</code> is required to have for
the simulation. Beware of partial matching to arguments of <code>boot</code>
listed above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details on bootstrap techniques are available in the help of the
<code><a href="boot.html#topic+boot">boot</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>"boot"</code>. See the Value part of the help of
the function <code><a href="boot.html#topic+boot">boot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")

# Std coefficients
modplsbeta &lt;- plsRbeta(yield~., data=GasolineYield, nt=3, modele="pls-beta")
GazYield.boot &lt;- bootplsbeta(modplsbeta, sim="ordinary", stype="i", R=250)
boot::boot.ci(GazYield.boot, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=1)
boot::boot.ci(GazYield.boot, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=2)
boot::boot.ci(GazYield.boot, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=3)
boot::boot.ci(GazYield.boot, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=4)
boot::boot.ci(GazYield.boot, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=5)
boot::boot.ci(GazYield.boot, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=6)

plsRglm::boxplots.bootpls(GazYield.boot)
plsRglm::confints.bootpls(GazYield.boot)
plsRglm::plots.confints.bootpls(plsRglm::confints.bootpls(GazYield.boot))

#Raw coefficients
modplsbeta &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3, modele="pls-beta")
GazYield.boot.raw &lt;- bootplsbeta(modplsbeta, sim="ordinary", stype="i", 
R=250, statistic=coefs.plsRbeta.raw)
boot::boot.ci(GazYield.boot.raw, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=1)
boot::boot.ci(GazYield.boot.raw, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=2)
boot::boot.ci(GazYield.boot.raw, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=3)
boot::boot.ci(GazYield.boot.raw, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=4)
boot::boot.ci(GazYield.boot.raw, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=5)
boot::boot.ci(GazYield.boot.raw, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=6)

plsRglm::boxplots.bootpls(GazYield.boot.raw)
plsRglm::confints.bootpls(GazYield.boot.raw)
plsRglm::plots.confints.bootpls(plsRglm::confints.bootpls(GazYield.boot.raw))


plot(GazYield.boot.raw,index=2)
boot::jack.after.boot(GazYield.boot.raw, index=2, useJ=TRUE, nt=3)
plot(GazYield.boot.raw, index=2,jack=TRUE)

# PLS bootstrap balanced

GazYield.boot.bal &lt;- bootplsbeta(plsRbeta(yield~.,data=GasolineYield,nt=3,
modele="pls-beta"), sim="balanced", stype="i", R=250)
boot::boot.ci(GazYield.boot.bal, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=1)
boot::boot.ci(GazYield.boot.bal, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=2)
boot::boot.ci(GazYield.boot.bal, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=3)
boot::boot.ci(GazYield.boot.bal, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=4)
boot::boot.ci(GazYield.boot.bal, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=5)
boot::boot.ci(GazYield.boot.bal, conf = c(0.90,0.95), 
type = c("norm","basic","perc","bca"), index=6)


plsRglm::boxplots.bootpls(GazYield.boot.bal)
plsRglm::confints.bootpls(GazYield.boot.bal)
plsRglm::plots.confints.bootpls(plsRglm::confints.bootpls(GazYield.boot.bal))



plot(GazYield.boot.bal)
boot::jack.after.boot(GazYield.boot.bal, index=1, useJ=TRUE, nt=3)
plot(GazYield.boot.bal,jack=TRUE)


# PLS permutation bootstrap

GazYield.boot.perm &lt;- bootplsbeta(plsRbeta(yield~.,data=GasolineYield,nt=3,
modele="pls-beta"), sim="permutation", stype="i", R=250)
boot::boot.ci(GazYield.boot.perm, conf = c(0.90,0.95), 
type = c("norm","basic","perc"), index=1)
boot::boot.ci(GazYield.boot.perm, conf = c(0.90,0.95), 
type = c("norm","basic","perc"), index=2)
boot::boot.ci(GazYield.boot.perm, conf = c(0.90,0.95), 
type = c("norm","basic","perc"), index=3)
boot::boot.ci(GazYield.boot.perm, conf = c(0.90,0.95), 
type = c("norm","basic","perc"), index=4)
boot::boot.ci(GazYield.boot.perm, conf = c(0.90,0.95), 
type = c("norm","basic","perc"), index=5)
boot::boot.ci(GazYield.boot.perm, conf = c(0.90,0.95), 
type = c("norm","basic","perc"), index=6)
plsRglm::boxplots.bootpls(GazYield.boot.perm)
plot(GazYield.boot.perm)


</code></pre>

<hr>
<h2 id='coefs.plsRbeta'>Coefficients function for bootstrap techniques</h2><span id='topic+coefs.plsRbeta'></span>

<h3>Description</h3>

<p>Returns the coefficients of a <code>"plsRbeta"</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsRbeta(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  method = "logistic",
  link = NULL,
  link.phi = NULL,
  type = "ML",
  maxcoefvalues,
  ifbootfail,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsRbeta_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_family">family</code></td>
<td>
<p>family to use if GLM model, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_method">method</code></td>
<td>
<p>method for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_link">link</code></td>
<td>
<p>link for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_link.phi">link.phi</code></td>
<td>
<p>link.phi for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_type">type</code></td>
<td>
<p>type of estimates</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients' Estimates on a sample.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsbeta">bootplsbeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
bootplsbeta(plsRbeta(yield~.,data=GasolineYield,nt=3, modele="pls-beta"), typeboot="plsmodel", 
R=250, statistic=coefs.plsRbeta)


</code></pre>

<hr>
<h2 id='coefs.plsRbeta.raw'>Raw coefficients function for bootstrap techniques</h2><span id='topic+coefs.plsRbeta.raw'></span>

<h3>Description</h3>

<p>Returns the coefficients of a <code>"plsRbeta"</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsRbeta.raw(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  method = "logistic",
  link = NULL,
  link.phi = NULL,
  type = "ML",
  maxcoefvalues,
  ifbootfail,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsRbeta.raw_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_family">family</code></td>
<td>
<p>family to use if GLM model, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_method">method</code></td>
<td>
<p>method for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_link">link</code></td>
<td>
<p>link for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_link.phi">link.phi</code></td>
<td>
<p>link.phi for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_type">type</code></td>
<td>
<p>type of estimates</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="coefs.plsRbeta.raw_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients' Estimates on a sample.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsbeta">bootplsbeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
bootplsbeta(plsRbeta(yield~.,data=GasolineYield,nt=3, modele="pls-beta"), typeboot="fmodel_par", 
R=250, statistic=coefs.plsRbeta.raw)


</code></pre>

<hr>
<h2 id='coefs.plsRbetanp'>Coefficients for bootstrap computations of PLSBeta models</h2><span id='topic+coefs.plsRbetanp'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsRbetanp(
  dataRepYtt,
  ind,
  nt,
  modele,
  family = NULL,
  method = "logistic",
  link = NULL,
  link.phi = NULL,
  type = "ML",
  verbose = TRUE,
  maxcoefvalues,
  wwetoile,
  ifbootfail
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsRbetanp_+3A_datarepytt">dataRepYtt</code></td>
<td>
<p>components' coordinates to bootstrap</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_method">method</code></td>
<td>
<p>method for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_link">link</code></td>
<td>
<p>link for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_link.phi">link.phi</code></td>
<td>
<p>link.phi for beta regression</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_type">type</code></td>
<td>
<p>type of estimates</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_wwetoile">wwetoile</code></td>
<td>
<p>values of the Wstar matrix in the original fit</p>
</td></tr>
<tr><td><code id="coefs.plsRbetanp_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Note</h3>

<p>~~some notes~~
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsbeta">bootplsbeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
bootplsbeta(plsRbeta(yield~.,data=GasolineYield,nt=3, modele="pls-beta"), typeboot="fmodel_np", 
R=250, statistic=coefs.plsRbetanp)

</code></pre>

<hr>
<h2 id='colon'>Tumor rate and spectral data</h2><span id='topic+colon'></span>

<h3>Description</h3>

<p>This dataset feature tumor rate data with spectral data descriptors. It is used as an example in the second vignette of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colon
</code></pre>


<h3>Format</h3>

<p>A data frame with 80 observations on the following 180 variables.
</p>
 <dl>
<dt>X..Tumor.Cells</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.69499969</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.68499947</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.67499971</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.66499949</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.65499973</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.6449995</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.63499975</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.62499952</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.61499977</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.60499954</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.59499979</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.58499956</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.57499981</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.56499958</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.55499983</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.5449996</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.53499985</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.52499962</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.51499987</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.50499964</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.49499989</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.48499966</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.4749999</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.46499968</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.45499992</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.44499969</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.43499947</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.42499971</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.41499949</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.40499973</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.3949995</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.38499975</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.37499952</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.36499977</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.35499954</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.34499979</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.33499956</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.32499981</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.31499958</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.30499983</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.2949996</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.28499985</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.27499962</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.26499987</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.25499964</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.24499989</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.23499966</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.2249999</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.21499968</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.20499992</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.19499969</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.18499994</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.17499971</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.16499949</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.15499973</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.1449995</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.13499975</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.12499952</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.11499977</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.10499954</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.09499979</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.08499956</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.07499981</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.06499958</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.05499983</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.0449996</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.03499985</dt><dd><p>a numeric vector</p>
</dd> <dt>X4.02499962</dt><dd><p>a
numeric vector</p>
</dd> <dt>X4.01499987</dt><dd><p>a numeric vector</p>
</dd>
<dt>X4.00499964</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.99499965</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.98499966</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.97499967</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.96499968</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.95499969</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.94499969</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.9349997</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.92499971</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.91499972</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.90499973</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.89499974</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.88499975</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.87499976</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.86499977</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.85499978</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.84499979</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.8349998</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.82499981</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.81499982</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.80499983</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.7949996</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.78499961</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.77499962</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.76499963</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.75499964</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.74499965</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.73499966</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.72499967</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.71499968</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.70499969</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.69499969</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.6849997</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.67499971</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.66499972</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.65499973</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.64499974</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.63499975</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.62499976</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.61499977</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.60499978</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.59499979</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.5849998</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.57499981</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.56499982</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.55499983</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.54499984</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.53499961</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.52499962</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.51499963</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.50499964</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.49499965</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.48499966</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.47499967</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.46499968</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.45499969</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.44499969</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.4349997</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.42499971</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.41499972</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.40499973</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.39499974</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.38499975</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.37499976</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.36499977</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.35499978</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.34499979</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.3349998</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.32499981</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.31499982</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.30499983</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.29499984</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.28499961</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.27499962</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.26499963</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.25499964</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.24499965</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.23499966</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.22499967</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.21499968</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.20499969</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.19499969</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.1849997</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.17499971</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.16499972</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.15499973</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.14499974</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.13499975</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.12499976</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.11499977</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.10499978</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.09499979</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.0849998</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.07499981</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.06499982</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.05499983</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.04499984</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.03499985</dt><dd><p>a
numeric vector</p>
</dd> <dt>X3.02499962</dt><dd><p>a numeric vector</p>
</dd>
<dt>X3.01499963</dt><dd><p>a numeric vector</p>
</dd> <dt>X3.00499964</dt><dd><p>a
numeric vector</p>
</dd> <dt>X2.99499965</dt><dd><p>a numeric vector</p>
</dd>
<dt>X2.98499966</dt><dd><p>a numeric vector</p>
</dd> <dt>X2.97499967</dt><dd><p>a
numeric vector</p>
</dd> <dt>X2.96499968</dt><dd><p>a numeric vector</p>
</dd>
<dt>X2.95499969</dt><dd><p>a numeric vector</p>
</dd> <dt>X2.94499969</dt><dd><p>a
numeric vector</p>
</dd> <dt>X2.9349997</dt><dd><p>a numeric vector</p>
</dd>
<dt>X2.92499971</dt><dd><p>a numeric vector</p>
</dd> <dt>X2.91499972</dt><dd><p>a
numeric vector</p>
</dd> </dl>



<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(colon)
str(colon)

</code></pre>

<hr>
<h2 id='ind_BCa_nt1BC'>ind_BCa_nt1BC</h2><span id='topic+ind_BCa_nt1BC'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt1BC
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt1BC)
## maybe str(ind_BCa_nt1BC) ; plot(ind_BCa_nt1BC) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt1BR'>ind_BCa_nt1BR</h2><span id='topic+ind_BCa_nt1BR'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt1BR
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt1BR)
## maybe str(ind_BCa_nt1BR) ; plot(ind_BCa_nt1BR) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt2BC'>ind_BCa_nt2BC</h2><span id='topic+ind_BCa_nt2BC'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt2BC
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt2BC)
## maybe str(ind_BCa_nt2BC) ; plot(ind_BCa_nt2BC) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt2BR'>ind_BCa_nt2BR</h2><span id='topic+ind_BCa_nt2BR'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt2BR
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt2BR)
## maybe str(ind_BCa_nt2BR) ; plot(ind_BCa_nt2BR) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt3'>ind_BCa_nt3</h2><span id='topic+ind_BCa_nt3'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt3
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt3)
## maybe str(ind_BCa_nt3) ; plot(ind_BCa_nt3) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt3BC'>ind_BCa_nt3BC</h2><span id='topic+ind_BCa_nt3BC'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt3BC
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt3BC)
## maybe str(ind_BCa_nt3BC) ; plot(ind_BCa_nt3BC) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt3BR'>ind_BCa_nt3BR</h2><span id='topic+ind_BCa_nt3BR'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt3BR
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt3BR)
## maybe str(ind_BCa_nt3BR) ; plot(ind_BCa_nt3BR) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt4BC'>ind_BCa_nt4BC</h2><span id='topic+ind_BCa_nt4BC'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt4BC
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt4BC)
## maybe str(ind_BCa_nt4BC) ; plot(ind_BCa_nt4BC) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt4BR'>ind_BCa_nt4BR</h2><span id='topic+ind_BCa_nt4BR'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt4BR
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt4BR)
## maybe str(ind_BCa_nt4BR) ; plot(ind_BCa_nt4BR) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt5BC'>ind_BCa_nt5BC</h2><span id='topic+ind_BCa_nt5BC'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt5BC
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt5BC)
## maybe str(ind_BCa_nt5BC) ; plot(ind_BCa_nt5BC) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt5BR'>ind_BCa_nt5BR</h2><span id='topic+ind_BCa_nt5BR'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt5BR
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt5BR)
## maybe str(ind_BCa_nt5BR) ; plot(ind_BCa_nt5BR) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt6BC'>ind_BCa_nt6BC</h2><span id='topic+ind_BCa_nt6BC'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt6BC
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt6BC)
## maybe str(ind_BCa_nt6BC) ; plot(ind_BCa_nt6BC) ...

</code></pre>

<hr>
<h2 id='ind_BCa_nt6BR'>ind_BCa_nt6BR</h2><span id='topic+ind_BCa_nt6BR'></span>

<h3>Description</h3>

<p>Variable selection results for the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_BCa_nt6BR
</code></pre>


<h3>Format</h3>

<p>Logical vector of length 60.
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ind_BCa_nt6BR)
## maybe str(ind_BCa_nt6BR) ; plot(ind_BCa_nt6BR) ...

</code></pre>

<hr>
<h2 id='kfolds2Chisq'>Computes Predicted Chisquare for kfold cross validated partial least squares
beta regression models.</h2><span id='topic+kfolds2Chisq'></span>

<h3>Description</h3>

<p>This function computes Predicted Chisquare for kfold cross validated partial
least squares beta regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Chisq(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Chisq_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a kfold cross validated partial least squares regression
glm model</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Total Predicted Chisquare vs number of components for
the first group partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>Total
Predicted Chisquare vs number of components for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+PLS_beta_kfoldcv">PLS_beta_kfoldcv</a></code> to create kfold cross validated
partial least squares regression glm and beta models.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+kfolds2coeff">kfolds2coeff</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Press">kfolds2Press</a></code>, <code><a href="plsRglm.html#topic+kfolds2Pressind">kfolds2Pressind</a></code>,
<code><a href="#topic+kfolds2Chisqind">kfolds2Chisqind</a></code>, <code><a href="plsRglm.html#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and
<code><a href="plsRglm.html#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to extract and transforms results
from kfold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
bbb &lt;- PLS_beta_kfoldcv(yGasolineYield,XGasolineYield,nt=3,modele="pls-beta")
kfolds2Chisq(bbb)

## End(Not run)

</code></pre>

<hr>
<h2 id='kfolds2Chisqind'>Computes individual Predicted Chisquare for kfold cross validated partial
least squares beta regression models.</h2><span id='topic+kfolds2Chisqind'></span>

<h3>Description</h3>

<p>This function computes individual Predicted Chisquare for kfold cross
validated partial least squares beta regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Chisqind(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Chisqind_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a kfold cross validated partial least squares regression
glm model</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Individual PChisq vs number of components for the first
group partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>Individual PChisq vs
number of components for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+PLS_beta_kfoldcv">PLS_beta_kfoldcv</a></code> to create kfold cross validated
partial least squares regression glm models.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+kfolds2coeff">kfolds2coeff</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Press">kfolds2Press</a></code>, <code><a href="plsRglm.html#topic+kfolds2Pressind">kfolds2Pressind</a></code>,
<code><a href="#topic+kfolds2Chisq">kfolds2Chisq</a></code>, <code><a href="plsRglm.html#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and
<code><a href="plsRglm.html#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to extract and transforms results
from kfold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
bbb &lt;- PLS_beta_kfoldcv(yGasolineYield,XGasolineYield,nt=3,modele="pls-beta")
kfolds2Chisqind(bbb)

## End(Not run)

</code></pre>

<hr>
<h2 id='kfolds2CVinfos_beta'>Extracts and computes information criteria and fits statistics for kfold
cross validated partial least squares beta regression models</h2><span id='topic+kfolds2CVinfos_beta'></span>

<h3>Description</h3>

<p>This function extracts and computes information criteria and fits statistics
for kfold cross validated partial least squares beta regression models for
both formula or classic specifications of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2CVinfos_beta(pls_kfolds, MClassed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2CVinfos_beta_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>an object computed using <code><a href="#topic+PLS_beta_kfoldcv">PLS_beta_kfoldcv</a></code></p>
</td></tr>
<tr><td><code id="kfolds2CVinfos_beta_+3A_mclassed">MClassed</code></td>
<td>
<p>should number of miss classed be computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mclassed option should only set to <code>TRUE</code> if the response is
binary.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>table of fit statistics for first group partition</p>
</td></tr>
<tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>table of fit statistics for last group
partition</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+kfolds2coeff">kfolds2coeff</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="plsRglm.html#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and
<code><a href="plsRglm.html#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to extract and transforms results
from kfold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data("GasolineYield",package="betareg")
bbb &lt;- PLS_beta_kfoldcv_formula(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
kfolds2CVinfos_beta(bbb)

## End(Not run)

</code></pre>

<hr>
<h2 id='modpls_sub4'>A plsRbetamodel model on a data subset</h2><span id='topic+modpls_sub4'></span>

<h3>Description</h3>

<p>A precomputed four components plsRbetamodel fitted to a subset of an example dataset and used in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modpls_sub4
</code></pre>


<h3>Format</h3>

<p>a class plsRbetamodel object
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(modpls_sub4)
str(modpls_sub4)

</code></pre>

<hr>
<h2 id='modpls.boot3'>Bootstrap distribution of a 3 components model</h2><span id='topic+modpls.boot3'></span>

<h3>Description</h3>

<p>A precomputed bootstrap distribution of the coefficients of a model used in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modpls.boot3
</code></pre>


<h3>Format</h3>

<p>a class boot object
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(modpls.boot3)
str(modpls.boot3)
plot(modpls.boot3)

</code></pre>

<hr>
<h2 id='permcoefs.plsRbeta'>Coefficients function for permutation bootstrap techniques</h2><span id='topic+permcoefs.plsRbeta'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsRbeta(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  method = "logistic",
  link = "logit",
  link.phi = NULL,
  type = "ML",
  maxcoefvalues,
  ifbootfail,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsRbeta_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_family">family</code></td>
<td>
<p>family to use if GLM model, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_method">method</code></td>
<td>
<p>method for beta regression</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_link">link</code></td>
<td>
<p>link for beta regression</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_link.phi">link.phi</code></td>
<td>
<p>link.phi for beta regression</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_type">type</code></td>
<td>
<p>type of estimates</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates on a bootstrap sample.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsbeta">bootplsbeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")

GazYield.boot &lt;- bootplsbeta(plsRbeta(yield~.,data=GasolineYield,nt=3,
modele="pls-beta", verbose=FALSE), sim="ordinary", stype="i", R=250, statistic=permcoefs.plsRbeta)


</code></pre>

<hr>
<h2 id='permcoefs.plsRbeta.raw'>Raw coefficients function for permutation bootstrap techniques</h2><span id='topic+permcoefs.plsRbeta.raw'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsRbeta.raw(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  method = "logistic",
  link = "logit",
  link.phi = NULL,
  type = "ML",
  maxcoefvalues,
  ifbootfail,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_family">family</code></td>
<td>
<p>family to use if GLM model, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_method">method</code></td>
<td>
<p>method for beta regression</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_link">link</code></td>
<td>
<p>link for beta regression</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_link.phi">link.phi</code></td>
<td>
<p>link.phi for beta regression</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_type">type</code></td>
<td>
<p>type of estimates</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbeta.raw_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates on a bootstrap sample.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsbeta">bootplsbeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
modplsbeta &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3, modele="pls-beta")
GazYield.boot.raw &lt;- bootplsbeta(modplsbeta, sim="permutation", stype="i", 
R=250, statistic=coefs.plsRbeta.raw)


</code></pre>

<hr>
<h2 id='permcoefs.plsRbetanp'>Coefficients for permutation bootstrap computations of PLSBeta models</h2><span id='topic+permcoefs.plsRbetanp'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsRbetanp(
  dataRepYtt,
  ind,
  nt,
  modele,
  family = NULL,
  maxcoefvalues,
  wwetoile,
  ifbootfail
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsRbetanp_+3A_datarepytt">dataRepYtt</code></td>
<td>
<p>components' coordinates to bootstrap</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbetanp_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbetanp_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbetanp_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRbetanp_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRbeta">plsRbeta</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRbetanp_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbetanp_+3A_wwetoile">wwetoile</code></td>
<td>
<p>values of the Wstar matrix in the original fit</p>
</td></tr>
<tr><td><code id="permcoefs.plsRbetanp_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Note</h3>

<p>~~some notes~~
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsbeta">bootplsbeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
modplsbeta &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3, modele="pls-beta")
bootplsbeta(modplsbeta, R=250, statistic=permcoefs.plsRbetanp, typeboot="fmodel_np")

</code></pre>

<hr>
<h2 id='PLS_beta'>Partial least squares beta regression models</h2><span id='topic+PLS_beta'></span>

<h3>Description</h3>

<p>This function implements Partial least squares beta regression models on
complete or incomplete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_beta(
  dataY,
  dataX,
  nt = 2,
  limQ2set = 0.0975,
  dataPredictY = dataX,
  modele = "pls",
  family = NULL,
  typeVC = "none",
  EstimXNA = FALSE,
  scaleX = TRUE,
  scaleY = NULL,
  pvals.expli = FALSE,
  alpha.pvals.expli = 0.05,
  MClassed = FALSE,
  tol_Xi = 10^(-12),
  weights,
  method,
  sparse = FALSE,
  sparseStop = TRUE,
  naive = FALSE,
  link = NULL,
  link.phi = NULL,
  type = "ML",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_beta_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use
the family option, please set <code>modele="pls-glm-family"</code>. User defined
families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_typevc">typeVC</code></td>
<td>
<p>type of leave one out cross validation. For back compatibility
purpose.  </p>
 <dl>
<dt>list(&quot;none&quot;)</dt><dd><p>no cross validation</p>
</dd>
<dt>list(&quot;standard&quot;)</dt><dd><p>no cross validation</p>
</dd> <dt>list(&quot;missingdata&quot;)</dt><dd><p>no
cross validation</p>
</dd> <dt>list(&quot;adaptative&quot;)</dt><dd><p>no cross validation</p>
</dd> </dl>
</td></tr>
<tr><td><code id="PLS_beta_+3A_estimxna">EstimXNA</code></td>
<td>
<p>only for <code>modele="pls"</code>. Set whether the missing X
values have to be estimated.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for
<code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since not always possible
for glm responses.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_pvals.expli">pvals.expli</code></td>
<td>
<p>should individual p-values be reported to tune model
selection ?</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_alpha.pvals.expli">alpha.pvals.expli</code></td>
<td>
<p>level of significance for predictors when
pvals.expli=TRUE</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_mclassed">MClassed</code></td>
<td>
<p>number of missclassified cases, should only be used for
binary responses</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_method">method</code></td>
<td>
<p>the link function for <code>pls-glm-polr</code>, logistic, probit,
complementary log-log or cauchit (corresponding to a Cauchy latent
variable).</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors
(&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant
predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_naive">naive</code></td>
<td>
<p>use the naive estimates for the Degrees of Freedom in plsR?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_link">link</code></td>
<td>
<p>character specification of the link function in the mean model
(mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported.
Alternatively, an object of class &quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in the
precision model (phi). Currently, &quot;<code>identity</code>&quot;, &quot;<code>log</code>&quot;,
&quot;<code>sqrt</code>&quot; are supported. The default is &quot;<code>log</code>&quot; unless
<code>formula</code> is of type <code>y~x</code> where the default is &quot;<code>identity</code>&quot;
(for backward compatibility). Alternatively, an object of class
&quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_type">type</code></td>
<td>
<p>character specification of the type of estimator. Currently,
maximum likelihood (&quot;<code>ML</code>&quot;), ML with bias correction (&quot;<code>BC</code>&quot;), and
ML with bias reduction (&quot;<code>BR</code>&quot;) are supported.</p>
</td></tr>
<tr><td><code id="PLS_beta_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are seven different predefined models with predefined link functions
available : </p>
 <dl>
<dt>list(&quot;\&quot;pls\&quot;&quot;)</dt><dd><p>ordinary pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>glm gaussian with identity link pls
models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-inverse-gamma\&quot;&quot;)</dt><dd><p>glm binomial with square
inverse link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>glm binomial
with logit link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>glm poisson
with log link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-polr\&quot;&quot;)</dt><dd><p>glm polr with
logit link pls models</p>
</dd> </dl>
<p> Using the <code>"family="</code> option and setting
<code>"modele=pls-glm-family"</code> allows changing the family and link function
the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence
user-specified families can also be used.  </p>
 <dl>
<dt>The </dt><dd><p>accepts
the links (as names) <code>identity</code>, <code>log</code> and
<code>inverse</code>.</p>
</dd><dt>list(&quot;gaussian&quot;)</dt><dd><p>accepts the links (as names)
<code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd> <dt>The
</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>,
(corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code>
and <code>cloglog</code> (complementary log-log).</p>
</dd><dt>list(&quot;binomial&quot;)</dt><dd><p>accepts
the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to
logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code>
(complementary log-log).</p>
</dd><dt> family</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy
CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;Gamma&quot;)</dt><dd><p>accepts the links <code>inverse</code>,
<code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the
links <code>log</code>, <code>identity</code>, and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;poisson&quot;)</dt><dd><p>accepts the links <code>log</code>,
<code>identity</code>, and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the links
<code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;inverse.gaussian&quot;)</dt><dd><p>accepts the links <code>1/mu^2</code>,
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>,
<code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;quasi&quot;)</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>,
<code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>,
<code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd> <dt>The
function </dt><dd><p>can be used to create a power link
function.</p>
</dd><dt>list(&quot;power&quot;)</dt><dd><p>can be used to create a power link function.</p>
</dd>
</dl>
<p> The default estimator for Degrees of Freedom is the Kramer and Sugiyama's
one which only works for classical plsR models. For these models,
Information criteria are computed accordingly to these estimations. Naive
Degrees of Freedom and Information Criteria are also provided for comparison
purposes. For more details, see Kraemer, N., Sugiyama M. (2010). &quot;The
Degrees of Freedom of Partial Least Squares Regression&quot;. preprint,
http://arxiv.org/abs/1002.4112.
</p>


<h3>Value</h3>

<p>Depends on the model that was used to fit the model.
</p>


<h3>Note</h3>

<p>Use <code>plsRbeta</code> instead.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLS_beta_wvc">PLS_beta_wvc</a></code> and
<code><a href="#topic+PLS_beta_kfoldcv">PLS_beta_kfoldcv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
modpls &lt;- PLS_beta(yGasolineYield,XGasolineYield,nt=3,modele="pls-beta")
modpls$pp
modpls$Coeffs
modpls$Std.Coeffs
modpls$InfCrit
modpls$PredictY[1,]
rm("modpls")


</code></pre>

<hr>
<h2 id='PLS_beta_formula'>Partial least squares beta regression models</h2><span id='topic+PLS_beta_formula'></span>

<h3>Description</h3>

<p>This function implements Partial least squares beta regression models on
complete or incomplete datasets (formula specification of the model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_beta_formula(
  formula,
  data = NULL,
  nt = 2,
  limQ2set = 0.0975,
  dataPredictY = dataX,
  modele = "pls",
  family = NULL,
  typeVC = "none",
  EstimXNA = FALSE,
  scaleX = TRUE,
  scaleY = NULL,
  pvals.expli = FALSE,
  alpha.pvals.expli = 0.05,
  MClassed = FALSE,
  tol_Xi = 10^(-12),
  weights,
  subset,
  start = NULL,
  etastart,
  mustart,
  offset,
  method,
  control = list(),
  contrasts = NULL,
  sparse = FALSE,
  sparseStop = TRUE,
  naive = FALSE,
  link = NULL,
  link.phi = NULL,
  type = "ML",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_beta_formula_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can
be coerced to that class): a symbolic description of the model to be fitted.
The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in
the model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>plsRbeta</code> is called.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use
the family option, please set <code>modele="pls-glm-family"</code>. User defined
families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_typevc">typeVC</code></td>
<td>
<p>type of leave one out cross validation. For back compatibility
purpose.  </p>
 <dl>
<dt>list(&quot;none&quot;)</dt><dd><p>no cross validation</p>
</dd>
<dt>list(&quot;standard&quot;)</dt><dd><p>no cross validation</p>
</dd> <dt>list(&quot;missingdata&quot;)</dt><dd><p>no
cross validation</p>
</dd> <dt>list(&quot;adaptative&quot;)</dt><dd><p>no cross validation</p>
</dd> </dl>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_estimxna">EstimXNA</code></td>
<td>
<p>only for <code>modele="pls"</code>. Set whether the missing X
values have to be estimated.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for
<code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since not always possible
for glm responses.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_pvals.expli">pvals.expli</code></td>
<td>
<p>should individual p-values be reported to tune model
selection ?</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_alpha.pvals.expli">alpha.pvals.expli</code></td>
<td>
<p>level of significance for predictors when
pvals.expli=TRUE</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_mclassed">MClassed</code></td>
<td>
<p>number of missclassified cases, should only be used for
binary responses</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component
to be included in the linear predictor during fitting. This should be
<code>NULL</code> or a numeric vector of length equal to the number of cases. One
or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or
as well, and if more than one is specified their sum is used. See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_method">method</code></td>
<td>
 <dl>
<dt>for fitting glms with glm (</dt><dd><p>the method to be
used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If <code>"model.frame"</code>, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>the method to be used in fitting
the model. The default method <code>"glm.fit"</code> uses iteratively reweighted
least squares (IWLS). User-supplied fitting functions can be supplied either
as a function or a character string naming a function, with a function which
takes the same arguments as <code>glm.fit</code>. If <code>"model.frame"</code>, the
model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to be used in fitting the
model. The default method <code>"glm.fit"</code> uses iteratively reweighted least
squares (IWLS). User-supplied fitting functions can be supplied either as a
function or a character string naming a function, with a function which
takes the same arguments as <code>glm.fit</code>. If <code>"model.frame"</code>, the
model frame is returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>the method to
be used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If <code>"model.frame"</code>, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method
to be used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If <code>"model.frame"</code>, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-inverse.gaussian\&quot;&quot;)</dt><dd><p>the method to be used
in fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
<code>"model.frame"</code>, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to
be used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If <code>"model.frame"</code>, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>the method to be used in
fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
<code>"model.frame"</code>, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to
be used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If <code>"model.frame"</code>, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>the method to be used in
fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
<code>"model.frame"</code>, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to
be used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If <code>"model.frame"</code>, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;modele=pls-glm-family\&quot;&quot;)</dt><dd><p>the method to be used in
fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
<code>"model.frame"</code>, the model frame is returned.</p>
</dd><dt>)</dt><dd><p>the method to be
used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If <code>"model.frame"</code>, the model frame is returned.</p>
</dd>
<dt>list(&quot;pls-glm-polr&quot;)</dt><dd><p>logistic, probit, complementary log-log or
cauchit (corresponding to a Cauchy latent variable).</p>
</dd></dl>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For
<code>glm.fit</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors
(&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant
predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_naive">naive</code></td>
<td>
<p>Use the naive estimates for the Degrees of Freedom in plsR?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_link">link</code></td>
<td>
<p>character specification of the link function in the mean model
(mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported.
Alternatively, an object of class &quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in the
precision model (phi). Currently, &quot;<code>identity</code>&quot;, &quot;<code>log</code>&quot;,
&quot;<code>sqrt</code>&quot; are supported. The default is &quot;<code>log</code>&quot; unless
<code>formula</code> is of type <code>y~x</code> where the default is &quot;<code>identity</code>&quot;
(for backward compatibility). Alternatively, an object of class
&quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_type">type</code></td>
<td>
<p>character specification of the type of estimator. Currently,
maximum likelihood (&quot;<code>ML</code>&quot;), ML with bias correction (&quot;<code>BC</code>&quot;), and
ML with bias reduction (&quot;<code>BR</code>&quot;) are supported.</p>
</td></tr>
<tr><td><code id="PLS_beta_formula_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are seven different predefined models with predefined link functions
available : </p>
 <dl>
<dt>list(&quot;\&quot;pls\&quot;&quot;)</dt><dd><p>ordinary pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>glm gaussian with identity link pls
models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-inverse-gamma\&quot;&quot;)</dt><dd><p>glm binomial with square
inverse link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>glm binomial
with logit link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>glm poisson
with log link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-polr\&quot;&quot;)</dt><dd><p>glm polr with
logit link pls models</p>
</dd> </dl>
<p> Using the <code>"family="</code> option and setting
<code>"modele=pls-glm-family"</code> allows changing the family and link function
the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence
user-specified families can also be used.  </p>
 <dl>
<dt>The </dt><dd><p>accepts
the links (as names) <code>identity</code>, <code>log</code> and
<code>inverse</code>.</p>
</dd><dt>list(&quot;gaussian&quot;)</dt><dd><p>accepts the links (as names)
<code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd> <dt>The
</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>,
(corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code>
and <code>cloglog</code> (complementary log-log).</p>
</dd><dt>list(&quot;binomial&quot;)</dt><dd><p>accepts
the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to
logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code>
(complementary log-log).</p>
</dd><dt> family</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy
CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;Gamma&quot;)</dt><dd><p>accepts the links <code>inverse</code>,
<code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the
links <code>log</code>, <code>identity</code>, and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;poisson&quot;)</dt><dd><p>accepts the links <code>log</code>,
<code>identity</code>, and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the links
<code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;inverse.gaussian&quot;)</dt><dd><p>accepts the links <code>1/mu^2</code>,
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>,
<code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;quasi&quot;)</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>,
<code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>,
<code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd> <dt>The
function </dt><dd><p>can be used to create a power link
function.</p>
</dd><dt>list(&quot;power&quot;)</dt><dd><p>can be used to create a power link function.</p>
</dd>
</dl>

<p>A typical predictor has the form response ~ terms where response is the
(numeric) response vector and terms is a series of terms which specifies a
linear predictor for response. A terms specification of the form first +
second indicates all the terms in first together with all the terms in
second with any duplicates removed.
</p>
<p>A specification of the form first:second indicates the the set of terms
obtained by taking the interactions of all terms in first with all terms in
second. The specification first*second indicates the cross of first and
second. This is the same as first + second + first:second.
</p>
<p>The terms in the formula will be re-ordered so that main effects come first,
followed by the interactions, all second-order, all third-order and so on:
to avoid this pass a terms object as the formula.
</p>
<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>
<p>The default estimator for Degrees of Freedom is the Kramer and Sugiyama's
one which only works for classical plsR models. For these models,
Information criteria are computed accordingly to these estimations. Naive
Degrees of Freedom and Information Criteria are also provided for comparison
purposes. For more details, see Kraemer, N., Sugiyama M. (2010). &quot;The
Degrees of Freedom of Partial Least Squares Regression&quot;. preprint,
http://arxiv.org/abs/1002.4112.
</p>


<h3>Value</h3>

<p>Depends on the model that was used to fit the model.
</p>


<h3>Note</h3>

<p>Use <code>plsRbeta</code> instead.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLS_beta_wvc">PLS_beta_wvc</a></code> and
<code><a href="#topic+PLS_beta_kfoldcv_formula">PLS_beta_kfoldcv_formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("GasolineYield",package="betareg")
modpls &lt;- PLS_beta_formula(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
modpls$pp
modpls$Coeffs
modpls$Std.Coeffs
modpls$InfCrit
modpls$PredictY[1,]
rm("modpls")


</code></pre>

<hr>
<h2 id='PLS_beta_kfoldcv'>Partial least squares regression beta models with kfold cross validation</h2><span id='topic+PLS_beta_kfoldcv'></span>

<h3>Description</h3>

<p>This function implements kfold cross validation on complete or incomplete
datasets for partial least squares beta regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_beta_kfoldcv(
  dataY,
  dataX,
  nt = 2,
  limQ2set = 0.0975,
  modele = "pls",
  family = NULL,
  K = nrow(dataX),
  NK = 1,
  grouplist = NULL,
  random = FALSE,
  scaleX = TRUE,
  scaleY = NULL,
  keepcoeffs = FALSE,
  keepfolds = FALSE,
  keepdataY = TRUE,
  keepMclassed = FALSE,
  tol_Xi = 10^(-12),
  weights,
  method,
  link = NULL,
  link.phi = NULL,
  type = "ML",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_beta_kfoldcv_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use
the family option, please set <code>modele="pls-glm-family"</code>. User defined
families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_k">K</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_nk">NK</code></td>
<td>
<p>number of times the group division is made</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_grouplist">grouplist</code></td>
<td>
<p>to specify the members of the <code>K</code> groups</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_random">random</code></td>
<td>
<p>should the <code>K</code> groups be made randomly</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for
<code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible
for glm responses.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_keepcoeffs">keepcoeffs</code></td>
<td>
<p>shall the coefficients for each model be returned</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_keepfolds">keepfolds</code></td>
<td>
<p>shall the groups' composition be returned</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_keepdatay">keepdataY</code></td>
<td>
<p>shall the observed value of the response for each one of
the predicted value be returned</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_keepmclassed">keepMclassed</code></td>
<td>
<p>shall the number of miss classed be returned
(unavailable)</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_method">method</code></td>
<td>
<p>logistic, probit, complementary log-log or cauchit
(corresponding to a Cauchy latent variable).</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_link">link</code></td>
<td>
<p>character specification of the link function in the mean model
(mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported.
Alternatively, an object of class &quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in the
precision model (phi). Currently, &quot;<code>identity</code>&quot;, &quot;<code>log</code>&quot;,
&quot;<code>sqrt</code>&quot; are supported. The default is &quot;<code>log</code>&quot; unless
<code>formula</code> is of type <code>y~x</code> where the default is &quot;<code>identity</code>&quot;
(for backward compatibility). Alternatively, an object of class
&quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_type">type</code></td>
<td>
<p>character specification of the type of estimator. Currently,
maximum likelihood (&quot;<code>ML</code>&quot;), ML with bias correction (&quot;<code>BC</code>&quot;), and
ML with bias reduction (&quot;<code>BR</code>&quot;) are supported.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicts 1 group with the <code>K-1</code> other groups. Leave one out cross
validation is thus obtained for <code>K==nrow(dataX)</code>.
</p>
<p>There are seven different predefined models with predefined link functions
available : </p>
 <dl>
<dt>list(&quot;\&quot;pls\&quot;&quot;)</dt><dd><p>ordinary pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>glm gaussian with identity link pls
models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-inverse-gamma\&quot;&quot;)</dt><dd><p>glm binomial with square
inverse link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>glm binomial
with logit link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>glm poisson
with log link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-polr\&quot;&quot;)</dt><dd><p>glm polr with
logit link pls models</p>
</dd> </dl>
<p> Using the <code>"family="</code> option and setting
<code>"modele=pls-glm-family"</code> allows changing the family and link function
the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence
user-specified families can also be used.  </p>
 <dl>
<dt>The </dt><dd><p>accepts
the links (as names) <code>identity</code>, <code>log</code> and
<code>inverse</code>.</p>
</dd><dt>list(&quot;gaussian&quot;)</dt><dd><p>accepts the links (as names)
<code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd> <dt>The
</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>,
(corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code>
and <code>cloglog</code> (complementary log-log).</p>
</dd><dt>list(&quot;binomial&quot;)</dt><dd><p>accepts
the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to
logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code>
(complementary log-log).</p>
</dd><dt> family</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy
CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;Gamma&quot;)</dt><dd><p>accepts the links <code>inverse</code>,
<code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the
links <code>log</code>, <code>identity</code>, and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;poisson&quot;)</dt><dd><p>accepts the links <code>log</code>,
<code>identity</code>, and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the links
<code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;inverse.gaussian&quot;)</dt><dd><p>accepts the links <code>1/mu^2</code>,
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>,
<code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;quasi&quot;)</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>,
<code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>,
<code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd> <dt>The
function </dt><dd><p>can be used to create a power link
function.</p>
</dd><dt>list(&quot;power&quot;)</dt><dd><p>can be used to create a power link function.</p>
</dd>
</dl>

<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>results_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list
sums up the results for a group division: </p>
 <dl>
<dt>list</dt><dd><p> of
<code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted
values for a growing number of components</p>
</dd> <dt>list()</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code>
with the predicted values for a growing number of components</p>
</dd> </dl>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the
informations for a group division: </p>
 <dl>
<dt>list</dt><dd><p> of <code>K</code>
vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of
<code>dataX</code> that were used as a training set</p>
</dd> <dt>list()</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the
numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd> </dl>
 </td></tr>
<tr><td><code>dataY_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the
results for a group division: </p>
 <dl>
<dt>list</dt><dd><p> of <code>K</code> matrices
of size about <code>nrow(dataX)/K * 1</code> with the observed values of the
response</p>
</dd> <dt>list()</dt><dd><p>...</p>
</dd> <dt>list</dt><dd><p> of <code>K</code> matrices of size
about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd> </dl>
 </td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Works for complete and incomplete datasets.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+kfolds2coeff">kfolds2coeff</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="plsRglm.html#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> and
<code><a href="#topic+kfolds2CVinfos_beta">kfolds2CVinfos_beta</a></code> to extract and transform results
from kfold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
bbb &lt;- PLS_beta_kfoldcv(yGasolineYield,XGasolineYield,nt=3,modele="pls-beta")
kfolds2CVinfos_beta(bbb)

## End(Not run)

</code></pre>

<hr>
<h2 id='PLS_beta_kfoldcv_formula'>Partial least squares regression beta models with kfold cross validation</h2><span id='topic+PLS_beta_kfoldcv_formula'></span>

<h3>Description</h3>

<p>This function implements kfold cross validation on complete or incomplete
datasets for partial least squares beta regression models (formula
specification of the model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_beta_kfoldcv_formula(
  formula,
  data = NULL,
  nt = 2,
  limQ2set = 0.0975,
  modele = "pls",
  family = NULL,
  K = nrow(dataX),
  NK = 1,
  grouplist = NULL,
  random = FALSE,
  scaleX = TRUE,
  scaleY = NULL,
  keepcoeffs = FALSE,
  keepfolds = FALSE,
  keepdataY = TRUE,
  keepMclassed = FALSE,
  tol_Xi = 10^(-12),
  weights,
  subset,
  start = NULL,
  etastart,
  mustart,
  offset,
  method,
  control = list(),
  contrasts = NULL,
  sparse = FALSE,
  sparseStop = TRUE,
  naive = FALSE,
  link = NULL,
  link.phi = NULL,
  type = "ML",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can
be coerced to that class): a symbolic description of the model to be fitted.
The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in
the model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>plsRglm</code> is called.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use
the family option, please set <code>modele="pls-glm-family"</code>. User defined
families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_k">K</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_nk">NK</code></td>
<td>
<p>number of times the group division is made</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_grouplist">grouplist</code></td>
<td>
<p>to specify the members of the <code>K</code> groups</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_random">random</code></td>
<td>
<p>should the <code>K</code> groups be made randomly</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for
<code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible
for glm responses.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_keepcoeffs">keepcoeffs</code></td>
<td>
<p>shall the coefficients for each model be returned</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_keepfolds">keepfolds</code></td>
<td>
<p>shall the groups' composition be returned</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_keepdatay">keepdataY</code></td>
<td>
<p>shall the observed value of the response for each one of
the predicted value be returned</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_keepmclassed">keepMclassed</code></td>
<td>
<p>shall the number of miss classed be returned
(unavailable)</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component
to be included in the linear predictor during fitting. This should be
<code>NULL</code> or a numeric vector of length equal to the number of cases. One
or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or
as well, and if more than one is specified their sum is used. See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_method">method</code></td>
<td>
 <dl>
<dt>for fitting glms with glm (</dt><dd><p>the method to be
used in fitting the model. The default method <code>"glm.fit"</code> uses
iteratively reweighted least squares (IWLS). User-supplied fitting functions
can be supplied either as a function or a character string naming a
function, with a function which takes the same arguments as <code>glm.fit</code>.
If &quot;model.frame&quot;, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>the method to be used in fitting
the model. The default method <code>"glm.fit"</code> uses iteratively reweighted
least squares (IWLS). User-supplied fitting functions can be supplied either
as a function or a character string naming a function, with a function which
takes the same arguments as <code>glm.fit</code>. If &quot;model.frame&quot;, the model
frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to be used in fitting the model. The
default method <code>"glm.fit"</code> uses iteratively reweighted least squares
(IWLS). User-supplied fitting functions can be supplied either as a function
or a character string naming a function, with a function which takes the
same arguments as <code>glm.fit</code>. If &quot;model.frame&quot;, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>the method to be used in
fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to be used
in fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-inverse.gaussian\&quot;&quot;)</dt><dd><p>the method to be used
in fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to be used
in fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>the method to be used in
fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to be used
in fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>the method to be used in
fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is returned.</p>
</dd><dt>, </dt><dd><p>the method to be used
in fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is
returned.</p>
</dd><dt>list(&quot;\&quot;modele=pls-glm-family\&quot;&quot;)</dt><dd><p>the method to be used in
fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is returned.</p>
</dd><dt>)</dt><dd><p>the method to be used
in fitting the model. The default method <code>"glm.fit"</code> uses iteratively
reweighted least squares (IWLS). User-supplied fitting functions can be
supplied either as a function or a character string naming a function, with
a function which takes the same arguments as <code>glm.fit</code>. If
&quot;model.frame&quot;, the model frame is returned.</p>
</dd>
<dt>list(&quot;pls-glm-polr&quot;)</dt><dd><p>logistic, probit, complementary log-log or
cauchit (corresponding to a Cauchy latent variable).</p>
</dd></dl>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For
<code>glm.fit</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors
(&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant
predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_naive">naive</code></td>
<td>
<p>Use the naive estimates for the Degrees of Freedom in plsR?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_link">link</code></td>
<td>
<p>character specification of the link function in the mean model
(mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported.
Alternatively, an object of class &quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in the
precision model (phi). Currently, &quot;<code>identity</code>&quot;, &quot;<code>log</code>&quot;,
&quot;<code>sqrt</code>&quot; are supported. The default is &quot;<code>log</code>&quot; unless
<code>formula</code> is of type <code>y~x</code> where the default is &quot;<code>identity</code>&quot;
(for backward compatibility). Alternatively, an object of class
&quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_type">type</code></td>
<td>
<p>character specification of the type of estimator. Currently,
maximum likelihood (&quot;<code>ML</code>&quot;), ML with bias correction (&quot;<code>BC</code>&quot;), and
ML with bias reduction (&quot;<code>BR</code>&quot;) are supported.</p>
</td></tr>
<tr><td><code id="PLS_beta_kfoldcv_formula_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicts 1 group with the <code>K-1</code> other groups. Leave one out cross
validation is thus obtained for <code>K==nrow(dataX)</code>.
</p>
<p>There are seven different predefined models with predefined link functions
available : </p>
 <dl>
<dt>list(&quot;\&quot;pls\&quot;&quot;)</dt><dd><p>ordinary pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>glm gaussian with identity link pls
models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-inverse-gamma\&quot;&quot;)</dt><dd><p>glm binomial with square
inverse link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>glm binomial
with logit link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>glm poisson
with log link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-polr\&quot;&quot;)</dt><dd><p>glm polr with
logit link pls models</p>
</dd> </dl>
<p> Using the <code>"family="</code> option and setting
<code>"modele=pls-glm-family"</code> allows changing the family and link function
the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence
user-specified families can also be used.  </p>
 <dl>
<dt>The </dt><dd><p>accepts
the links (as names) <code>identity</code>, <code>log</code> and
<code>inverse</code>.</p>
</dd><dt>list(&quot;gaussian&quot;)</dt><dd><p>accepts the links (as names)
<code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd> <dt>The
</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>,
(corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code>
and <code>cloglog</code> (complementary log-log).</p>
</dd><dt>list(&quot;binomial&quot;)</dt><dd><p>accepts
the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to
logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code>
(complementary log-log).</p>
</dd><dt> family</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy
CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;Gamma&quot;)</dt><dd><p>accepts the links <code>inverse</code>,
<code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the
links <code>log</code>, <code>identity</code>, and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;poisson&quot;)</dt><dd><p>accepts the links <code>log</code>,
<code>identity</code>, and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the links
<code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;inverse.gaussian&quot;)</dt><dd><p>accepts the links <code>1/mu^2</code>,
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>,
<code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;quasi&quot;)</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>,
<code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>,
<code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd> <dt>The
function </dt><dd><p>can be used to create a power link
function.</p>
</dd><dt>list(&quot;power&quot;)</dt><dd><p>can be used to create a power link function.</p>
</dd>
</dl>

<p>A typical predictor has the form response ~ terms where response is the
(numeric) response vector and terms is a series of terms which specifies a
linear predictor for response. A terms specification of the form first +
second indicates all the terms in first together with all the terms in
second with any duplicates removed.
</p>
<p>A specification of the form first:second indicates the the set of terms
obtained by taking the interactions of all terms in first with all terms in
second. The specification first*second indicates the cross of first and
second. This is the same as first + second + first:second.
</p>
<p>The terms in the formula will be re-ordered so that main effects come first,
followed by the interactions, all second-order, all third-order and so on:
to avoid this pass a terms object as the formula.
</p>
<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>results_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list
sums up the results for a group division: </p>
 <dl>
<dt>list</dt><dd><p> of
<code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted
values for a growing number of components</p>
</dd> <dt>list()</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code>
with the predicted values for a growing number of components</p>
</dd> </dl>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the
informations for a group division: </p>
 <dl>
<dt>list</dt><dd><p> of <code>K</code>
vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of
<code>dataX</code> that were used as a training set</p>
</dd> <dt>list()</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the
numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd> </dl>
 </td></tr>
<tr><td><code>dataY_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the
results for a group division: </p>
 <dl>
<dt>list</dt><dd><p> of <code>K</code> matrices
of size about <code>nrow(dataX)/K * 1</code> with the observed values of the
response</p>
</dd> <dt>list()</dt><dd><p>...</p>
</dd> <dt>list</dt><dd><p> of <code>K</code> matrices of size
about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd> </dl>
 </td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Work for complete and incomplete datasets.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+kfolds2coeff">kfolds2coeff</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="plsRglm.html#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code>,
<code><a href="plsRglm.html#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> and
<code><a href="#topic+kfolds2CVinfos_beta">kfolds2CVinfos_beta</a></code> to extract and transform results
from kfold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data("GasolineYield",package="betareg")
bbb &lt;- PLS_beta_kfoldcv_formula(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
kfolds2CVinfos_beta(bbb)

## End(Not run)

</code></pre>

<hr>
<h2 id='PLS_beta_wvc'>Light version of PLS_beta for cross validation purposes</h2><span id='topic+PLS_beta_wvc'></span>

<h3>Description</h3>

<p>Light version of <code>PLS_beta</code> for cross validation purposes either on
complete or incomplete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_beta_wvc(
  dataY,
  dataX,
  nt = 2,
  dataPredictY = dataX,
  modele = "pls",
  family = NULL,
  scaleX = TRUE,
  scaleY = NULL,
  keepcoeffs = FALSE,
  keepstd.coeffs = FALSE,
  tol_Xi = 10^(-12),
  weights,
  method = "logistic",
  link = NULL,
  link.phi = NULL,
  type = "ML",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_beta_wvc_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted
(<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use
the family option, please set <code>modele="pls-glm-family"</code>. User defined
families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for
<code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible
for glm responses.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_keepcoeffs">keepcoeffs</code></td>
<td>
<p>whether the coefficients of the linear fit on link scale
of unstandardized eXplanatory variables should be returned or not.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_keepstd.coeffs">keepstd.coeffs</code></td>
<td>
<p>whether the coefficients of the linear fit on link
scale of standardized eXplanatory variables should be returned or not.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_method">method</code></td>
<td>
<p>logistic, probit, complementary log-log or cauchit
(corresponding to a Cauchy latent variable).</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_link">link</code></td>
<td>
<p>character specification of the link function in the mean model
(mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported.
Alternatively, an object of class &quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in the
precision model (phi). Currently, &quot;<code>identity</code>&quot;, &quot;<code>log</code>&quot;,
&quot;<code>sqrt</code>&quot; are supported. The default is &quot;<code>log</code>&quot; unless
<code>formula</code> is of type <code>y~x</code> where the default is &quot;<code>identity</code>&quot;
(for backward compatibility). Alternatively, an object of class
&quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_type">type</code></td>
<td>
<p>character specification of the type of estimator. Currently,
maximum likelihood (&quot;<code>ML</code>&quot;), ML with bias correction (&quot;<code>BC</code>&quot;), and
ML with bias reduction (&quot;<code>BR</code>&quot;) are supported.</p>
</td></tr>
<tr><td><code id="PLS_beta_wvc_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code><a href="plsRglm.html#topic+PLS_glm_kfoldcv_formula">PLS_glm_kfoldcv_formula</a></code> in order to
perform cross validation either on complete or incomplete datasets.
</p>
<p>There are seven different predefined models with predefined link functions
available : </p>
 <dl>
<dt>list(&quot;\&quot;pls\&quot;&quot;)</dt><dd><p>ordinary pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>glm gaussian with identity link pls
models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-inverse-gamma\&quot;&quot;)</dt><dd><p>glm binomial with square
inverse link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>glm binomial
with logit link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>glm poisson
with log link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-polr\&quot;&quot;)</dt><dd><p>glm polr with
logit link pls models</p>
</dd> </dl>
<p> Using the <code>"family="</code> option and setting
<code>"modele=pls-glm-family"</code> allows changing the family and link function
the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence
user-specified families can also be used.  </p>
 <dl>
<dt>The </dt><dd><p>accepts
the links (as names) <code>identity</code>, <code>log</code> and
<code>inverse</code>.</p>
</dd><dt>list(&quot;gaussian&quot;)</dt><dd><p>accepts the links (as names)
<code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd> <dt>The
</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>,
(corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code>
and <code>cloglog</code> (complementary log-log).</p>
</dd><dt>list(&quot;binomial&quot;)</dt><dd><p>accepts
the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to
logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code>
(complementary log-log).</p>
</dd><dt> family</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy
CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;Gamma&quot;)</dt><dd><p>accepts the links <code>inverse</code>,
<code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the
links <code>log</code>, <code>identity</code>, and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;poisson&quot;)</dt><dd><p>accepts the links <code>log</code>,
<code>identity</code>, and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the links
<code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;inverse.gaussian&quot;)</dt><dd><p>accepts the links <code>1/mu^2</code>,
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>,
<code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;quasi&quot;)</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>,
<code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>,
<code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd> <dt>The
function </dt><dd><p>can be used to create a power link
function.</p>
</dd><dt>list(&quot;power&quot;)</dt><dd><p>can be used to create a power link function.</p>
</dd>
</dl>

<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>valsPredict</code></td>
<td>
<p><code>nrow(dataPredictY) * nt</code> matrix of the
predicted values</p>
</td></tr> <tr><td><code>list("coeffs")</code></td>
<td>
<p> If the coefficients of the
eXplanatory variables were requested:<br /> i.e. <code>keepcoeffs=TRUE</code>.<br />
<code>ncol(dataX) * 1</code> matrix of the coefficients of the the eXplanatory
variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLS_beta">PLS_beta</a></code> for more detailed results,
<code><a href="#topic+PLS_beta_kfoldcv">PLS_beta_kfoldcv</a></code> for cross validating models and
<code><a href="plsRglm.html#topic+PLS_lm_wvc">PLS_lm_wvc</a></code> for the same function dedicated to plsR models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
modpls &lt;- PLS_beta_wvc(yGasolineYield,XGasolineYield,nt=3,modele="pls-beta")
modpls
rm("modpls")


</code></pre>

<hr>
<h2 id='plsRbeta'>Partial least squares Regression beta regression models</h2><span id='topic+plsRbeta'></span><span id='topic+plsRbetamodel.default'></span><span id='topic+plsRbetamodel.formula'></span>

<h3>Description</h3>

<p>This function implements Partial least squares Regression generalized linear models complete or incomplete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsRbeta(object, ...)
## Default S3 method:
plsRbetamodel(object,dataX,nt=2,limQ2set=.0975,
dataPredictY=dataX,modele="pls",family=NULL,typeVC="none",EstimXNA=FALSE,
scaleX=TRUE,scaleY=NULL,pvals.expli=FALSE,alpha.pvals.expli=.05,
MClassed=FALSE,tol_Xi=10^(-12),weights,method,sparse=FALSE,sparseStop=TRUE,
naive=FALSE,link=NULL,link.phi=NULL,type="ML",verbose=TRUE, ...)
## S3 method for class 'formula'
plsRbetamodel(object,data=NULL,nt=2,limQ2set=.0975,
dataPredictY,modele="pls",family=NULL,typeVC="none",EstimXNA=FALSE,
scaleX=TRUE,scaleY=NULL,pvals.expli=FALSE,alpha.pvals.expli=.05,
MClassed=FALSE,tol_Xi=10^(-12),weights,subset,start=NULL,etastart,
mustart,offset,method="glm.fit",control= list(),contrasts=NULL,
sparse=FALSE,sparseStop=TRUE,naive=FALSE,link=NULL,link.phi=NULL,type="ML",
verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsRbeta_+3A_object">object</code></td>
<td>
<p>a response (training) dataset or an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>plsRbeta</code> is called.</p>
</td></tr>  
<tr><td><code id="plsRbeta_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm or PLS beta model to be fitted (<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>, <code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>, <code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>, <code>"pls-beta"</code>). Use <code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use the family option, please set <code>modele="pls-glm-family"</code>. User defined families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_typevc">typeVC</code></td>
<td>
<p>type of leave one out cross validation. For back compatibility purpose.
</p>

<dl>
<dt><code>none</code></dt><dd><p>no cross validation</p>
</dd>
<dt><code>standard</code></dt><dd><p>no cross validation</p>
</dd>
<dt><code>missingdata</code></dt><dd><p>no cross validation</p>
</dd>
<dt><code>adaptative</code></dt><dd><p>no cross validation</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plsRbeta_+3A_estimxna">EstimXNA</code></td>
<td>
<p>only for <code>modele="pls"</code>. Set whether the missing X values have to be estimated.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for <code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible for glm responses.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_pvals.expli">pvals.expli</code></td>
<td>
<p>should individual p-values be reported to tune model selection ?</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_alpha.pvals.expli">alpha.pvals.expli</code></td>
<td>
<p>level of significance for predictors when pvals.expli=TRUE</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_mclassed">MClassed</code></td>
<td>
<p>number of missclassified cases, should only be used for binary responses</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times pp)</code> if there is any missing value in the <code>dataX</code>. It defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component to be included in the linear predictor during fitting. This should be <code>NULL</code> or a numeric vector of length equal to the number of cases. One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_method">method</code></td>
<td>
<p>the method to be used in fitting the model. The default method <code>"glm.fit"</code> uses iteratively reweighted least squares (IWLS). User-supplied fitting functions can be supplied either as a function or a character string naming a function, with a function which takes the same arguments as <code>glm.fit</code>.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For <code>glm.fit</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors (&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_naive">naive</code></td>
<td>
<p>Use the naive estimates for the Degrees of Freedom in plsR? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_link">link</code></td>
<td>
<p>character specification of the link function in the mean model (mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;, &quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported. Alternatively, an object of class &quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in the precision model (phi). Currently, &quot;<code>identity</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>sqrt</code>&quot; are supported. The default is &quot;<code>log</code>&quot; unless <code>formula</code> is of type <code>y~x</code> where the default is &quot;<code>identity</code>&quot; (for backward compatibility). Alternatively, an object of class &quot;<code>link-glm</code>&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_type">type</code></td>
<td>
<p>character specification of the type of estimator. Currently, maximum likelihood (&quot;<code>ML</code>&quot;), ML with bias correction (&quot;<code>BC</code>&quot;), and ML with bias reduction (&quot;<code>BR</code>&quot;) are supported.</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="plsRbeta_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>plsRmodel.default</code> or to <code>plsRmodel.formula</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are seven different predefined models with predefined link functions available :
</p>

<dl>
<dt><code>"pls"</code></dt><dd><p>ordinary pls models</p>
</dd>
<dt><code>"pls-glm-Gamma"</code></dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt><code>"pls-glm-gaussian"</code></dt><dd><p>glm gaussian with identity link pls models</p>
</dd>
<dt><code>"pls-glm-inverse-gamma"</code></dt><dd><p>glm binomial with square inverse link pls models</p>
</dd>
<dt><code>"pls-glm-logistic"</code></dt><dd><p>glm binomial with logit link pls models</p>
</dd>
<dt><code>"pls-glm-poisson"</code></dt><dd><p>glm poisson with log link pls models</p>
</dd>
<dt><code>"pls-glm-polr"</code></dt><dd><p>glm polr with logit link pls models</p>
</dd>
</dl>

<p>Using the <code>"family="</code> option and setting <code>"modele=pls-glm-family"</code> allows changing the family and link function the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence user-specified families can also be used. 
</p>

<dl>
<dt>The <code>gaussian</code> family</dt><dd><p>accepts the links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd>
<dt>The <code>binomial</code> family</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd> 
<dt>The <code>Gamma</code> family</dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The <code>poisson</code> family</dt><dd><p>accepts the links <code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd>
<dt>The <code>inverse.gaussian</code> family</dt><dd><p>accepts the links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The <code>quasi</code> family</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd>
<dt>The function <code>power</code></dt><dd><p>can be used to create a power link function.</p>
</dd> 
</dl>

<p>A typical predictor has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with any duplicates removed. 
</p>
<p>A specification of the form first:second indicates the the set of terms obtained by taking the interactions of all terms in first with all terms in second. The specification first*second indicates the cross of first and second. This is the same as first + second + first:second. 
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this pass a terms object as the formula. 
</p>
<p>Non-NULL weights can be used to indicate that different observations have different dispersions (with the values in weights being inversely proportional to the dispersions); or equivalently, when the elements of weights are positive integers w_i, that each response y_i is the mean of w_i unit-weight observations. 
</p>
<p>The default estimator for Degrees of Freedom is the Kramer and Sugiyama's one which only works for classical plsR models. For these models, Information criteria are computed accordingly to these estimations. Naive Degrees of Freedom and Information Criteria are also provided for comparison purposes. For more details, see Kraemer, N., Sugiyama M. (2010). &quot;The Degrees of Freedom of Partial Least Squares Regression&quot;. preprint, http://arxiv.org/abs/1002.4112. 
</p>


<h3>Value</h3>

<p>Depends on the model that was used to fit the model.
</p>


<h3>Note</h3>

<p>Use <code>plsRbeta</code> instead.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer, Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer, Myriam Maumy-Bertrand (2013). Régression Bêta PLS. <em>Journal de la Société Française de Statistique</em>, <b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+plsR">plsR</a></code> and <code><a href="plsRglm.html#topic+plsRglm">plsRglm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
modpls &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
modpls$pp
modpls$Coeffs
modpls$Std.Coeffs
modpls$InfCrit
modpls$PredictY[1,]
rm("modpls")

data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
modpls &lt;- plsRbeta(yGasolineYield,XGasolineYield,nt=3,modele="pls-beta")
modpls$pp
modpls$Coeffs
modpls$Std.Coeffs
modpls$InfCrit
modpls$PredictY[1,]
rm("modpls")

</code></pre>

<hr>
<h2 id='print.plsRbetamodel'>Print method for plsRbeta models</h2><span id='topic+print.plsRbetamodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class <code>"plsRbetamodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRbetamodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.plsRbetamodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"plsRbetamodel"</code></p>
</td></tr>
<tr><td><code id="print.plsRbetamodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
modpls &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
print(modpls)

</code></pre>

<hr>
<h2 id='print.summary.plsRbetamodel'>Print method for summaries of plsRbeta models</h2><span id='topic+print.summary.plsRbetamodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class
<code>"summary.plsRbetamodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.plsRbetamodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.plsRbetamodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"summary.plsRbetamodel"</code></p>
</td></tr>
<tr><td><code id="print.summary.plsRbetamodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>language</code></td>
<td>
<p>call of the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
modpls &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
print(summary(modpls))

</code></pre>

<hr>
<h2 id='simul_data_UniYX_beta'>Data generating function for univariate beta plsR models</h2><span id='topic+simul_data_UniYX_beta'></span>

<h3>Description</h3>

<p>This function generates a single univariate rate response value <code class="reqn">Y</code> and
a vector of explanatory variables <code class="reqn">(X_1,\ldots,X_{totdim})</code> drawn from a
model with a given number of latent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul_data_UniYX_beta(
  totdim,
  ncomp,
  disp = 1,
  link = "logit",
  type = "a",
  phi0 = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul_data_UniYX_beta_+3A_totdim">totdim</code></td>
<td>
<p>Number of columns of the X vector (from <code>ncomp</code> to
hardware limits)</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_beta_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of latent components in the model (from 2 to 6)</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_beta_+3A_disp">disp</code></td>
<td>
<p>Tune the shape of the beta distribution (defaults to 1)</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_beta_+3A_link">link</code></td>
<td>
<p>Character specification of the link function in the mean model
(mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported.
Alternatively, an object of class &quot;link-glm&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_beta_+3A_type">type</code></td>
<td>
<p>Simulation scheme</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_beta_+3A_phi0">phi0</code></td>
<td>
<p>Simulation scheme &quot;a&quot; parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be combined with the replicate function to give rise to
a larger dataset. The algorithm used is a modification of a port of the one
described in the article of Li which is a multivariate generalization of the
algorithm of Naes and Martens.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p><code class="reqn">(Y,X_1,\ldots,X_{totdim})</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>
<p>T. Naes, H. Martens (1985). Comparison of prediction methods for
multicollinear data.  <em>Commun. Stat., Simul.</em>, <b>14</b>:545-576.
&lt;doi:10.1080/03610918508812458&gt;
</p>
<p>Baibing Li, Julian Morris, Elaine B. Martin (2002). Model selection for
partial least squares regression, <em>Chemometrics and Intelligent
Laboratory Systems</em>, <b>64</b>:79-89. &lt;doi:110.1016/S0169-7439(02)00051-5&gt;
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+simul_data_UniYX">simul_data_UniYX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# logit link
layout(matrix(1:4,nrow=2))
hist(t(replicate(100,simul_data_UniYX_beta(4,4)))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=3)))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=5)))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=15)))[,1])
layout(1)

# probit link
layout(matrix(1:4,nrow=2))
hist(t(replicate(100,simul_data_UniYX_beta(4,4,link="probit")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=3,link="probit")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=5,link="probit")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=15,link="probit")))[,1])
layout(1)

# cloglog link
layout(matrix(1:4,nrow=2))
hist(t(replicate(100,simul_data_UniYX_beta(4,4,link="cloglog")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=3,link="cloglog")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=5,link="cloglog")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=15,link="cloglog")))[,1])
layout(1)

# cauchit link
layout(matrix(1:4,nrow=2))
hist(t(replicate(100,simul_data_UniYX_beta(4,4,link="cauchit")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=3,link="cauchit")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=5,link="cauchit")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=15,link="cauchit")))[,1])
layout(1)

# loglog link
layout(matrix(1:4,nrow=2))
hist(t(replicate(100,simul_data_UniYX_beta(4,4,link="loglog")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=3,link="loglog")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=5,link="loglog")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=15,link="loglog")))[,1])
layout(1)

# log link
layout(matrix(1:4,nrow=2))
hist(t(replicate(100,simul_data_UniYX_beta(4,4,link="log")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=3,link="log")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=5,link="log")))[,1])
hist(t(replicate(100,simul_data_UniYX_beta(4,4,disp=15,link="log")))[,1])
layout(1)


</code></pre>

<hr>
<h2 id='summary.plsRbetamodel'>Summary method for plsRbeta models</h2><span id='topic+summary.plsRbetamodel'></span>

<h3>Description</h3>

<p>This function provides a summary method for the class <code>"plsRbetamodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRbetamodel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.plsRbetamodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"plsRbetamodel"</code></p>
</td></tr>
<tr><td><code id="summary.plsRbetamodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>function call of plsR beta models</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
modpls &lt;- plsRbeta(yield~.,data=GasolineYield,nt=3,modele="pls-beta")
summary(modpls)

</code></pre>

<hr>
<h2 id='tilt.bootplsbeta'>Non-parametric tilted bootstrap for PLS beta regression models</h2><span id='topic+tilt.bootplsbeta'></span>

<h3>Description</h3>

<p>Provides a wrapper for the bootstrap function <code>tilt.boot</code> from the
<code>boot</code> R package.<br /> Implements non-parametric tilted bootstrap for PLS
beta regression models by case resampling : the <code>tilt.boot</code> function
will run an initial bootstrap with equal resampling probabilities (if
required) and will use the output of the initial run to find resampling
probabilities which put the value of the statistic at required values. It
then runs an importance resampling bootstrap using the calculated
probabilities as the resampling distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tilt.bootplsbeta(
  object,
  typeboot = "plsmodel",
  statistic = coefs.plsRbeta,
  R = c(499, 250, 250),
  alpha = c(0.025, 0.975),
  sim = "ordinary",
  stype = "i",
  index = 1,
  stabvalue = 1e+06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tilt.bootplsbeta_+3A_object">object</code></td>
<td>
<p>An object of class <code>plsRbetamodel</code> to bootstrap</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_typeboot">typeboot</code></td>
<td>
<p>The type of bootstrap. Either (Y,X) boostrap
(<code>typeboot="plsmodel"</code>) or (Y,T) bootstrap
(<code>typeboot="fmodel_np"</code>). Defaults to (Y,T) resampling.</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_statistic">statistic</code></td>
<td>
<p>A function which when applied to data returns a vector
containing the statistic(s) of interest. <code>statistic</code> must take at least
two arguments. The first argument passed will always be the original data.
The second will be a vector of indices, frequencies or weights which define
the bootstrap sample. Further, if predictions are required, then a third
argument is required which would be a vector of the random indices used to
generate the bootstrap predictions. Any further arguments can be passed to
statistic through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single
positive integer. For importance resampling, some resamples may use one set
of weights and others use a different set of weights. In this case <code>R</code>
would be a vector of integers where each component gives the number of
resamples from each of the rows of weights.</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level to which tilting is required. This parameter is
ignored if <code>R[1]</code> is 0 or if <code>theta</code> is supplied, otherwise it is
used to find the values of <code>theta</code> as quantiles of the initial uniform
bootstrap. In this case <code>R[1]</code> should be large enough that
<code>min(c(alpha, 1-alpha))*R[1] &gt; 5</code>, if this is not the case then a
warning is generated to the effect that the <code>theta</code> are extreme values
and so the tilted output may be unreliable.</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_sim">sim</code></td>
<td>
<p>A character string indicating the type of simulation required.
Possible values are <code>"ordinary"</code> (the default), <code>"balanced"</code>,
<code>"permutation"</code>, or <code>"antithetic"</code>.</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_stype">stype</code></td>
<td>
<p>A character string indicating what the second argument of
<code>statistic</code> represents. Possible values of stype are <code>"i"</code>
(indices - the default), <code>"f"</code> (frequencies), or <code>"w"</code> (weights).</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_index">index</code></td>
<td>
<p>The index of the statistic of interest in the output from
<code>statistic</code>. By default the first element of the output of
<code>statistic</code> is used.</p>
</td></tr>
<tr><td><code id="tilt.bootplsbeta_+3A_stabvalue">stabvalue</code></td>
<td>
<p>A value to hard threshold bootstrap estimates computed from
atypical resamplings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;boot&quot;.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Frédéric Bertrand, Nicolas Meyer,
Michèle Beau-Faller, Karim El Bayed, Izzie-Jacques Namer,
Myriam Maumy-Bertrand (2013). Régression Bêta
PLS. <em>Journal de la Société Française de Statistique</em>,
<b>154</b>(3):143-159.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/215</a>
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">tilt.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GasolineYield",package="betareg")
yGasolineYield &lt;- GasolineYield$yield
XGasolineYield &lt;- GasolineYield[,2:5]
modplsRbeta &lt;- plsRbeta(yGasolineYield, XGasolineYield, nt=3, 
modele="pls-beta")
# GazYield.tilt.boot &lt;- tilt.bootplsbeta(modplsRbeta,
# statistic=coefs.plsRbeta, R=c(499, 100, 100), 
# alpha=c(0.025, 0.975), sim="balanced", stype="i", index=1)
# boxplots.bootpls(GazYield.tilt.boot,1:2)


</code></pre>

<hr>
<h2 id='TxTum'>Cancer infiltration rates</h2><span id='topic+TxTum'></span>

<h3>Description</h3>

<p>This dataset features cancer infiltration rates and microsatellites data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TxTum
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 rows and 60 variables.
</p>
 
<dl>
<dt><code>CELTUMCO</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>age</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sexe</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HISTOADK</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>H2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>E1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>R10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C3M</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>RB</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FL7A</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P53</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>W2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>W4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MT1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MT2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MT4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MT3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HLA</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HLD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HLC</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HLB</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EA1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EA3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EA2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EA4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EB1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EB2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EB3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EB4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EGF1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EGF2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EGF3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EGF4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EGF5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>EGF6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FL7B</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>VSFGF7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>F3A</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>F3B</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>VSFGFR3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>F4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Q5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>VSTOP1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>VSTOP2A</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>VSEGFR</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AFRAEGFR</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SRXRA</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SMT</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>QMTAMPN</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>QMTDELN</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SHL</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SEA</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SEB</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>QPCRFGF7</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data
print(TxTum)
summary(TxTum)

</code></pre>

<hr>
<h2 id='TxTum.mod.bootBC1'>Bootstrap distribution TxTum BC1 model</h2><span id='topic+TxTum.mod.bootBC1'></span>

<h3>Description</h3>

<p>A precomputed bootstrap distribution of the coefficients of a model used in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TxTum.mod.bootBC1
</code></pre>


<h3>Format</h3>

<p>a class boot object
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(TxTum.mod.bootBC1)
str(TxTum.mod.bootBC1)
plot(TxTum.mod.bootBC1)

</code></pre>

<hr>
<h2 id='TxTum.mod.bootBR6'>Bootstrap distribution TxTum BR6 model</h2><span id='topic+TxTum.mod.bootBR6'></span>

<h3>Description</h3>

<p>A precomputed bootstrap distribution of the coefficients of a model used in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TxTum.mod.bootBR6
</code></pre>


<h3>Format</h3>

<p>a class boot object
</p>


<h3>References</h3>

<p>Régression Bêta PLS. (French) [PLS Beta regression.], 
F. Bertrand, N. Meyer, M. Beau-Faller, K. El Bayed, N. Izzie-J., 
M. Maumy-Bertrand, (2013), J. SFdS, 154(3):143-159 <br />
</p>
<p>Partial Least Squares Regression for Beta Regression Models. 
F. Bertrand, M. Maumy (2021). useR! 2021, Zurich.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(TxTum.mod.bootBR6)
str(TxTum.mod.bootBR6)
plot(TxTum.mod.bootBR6)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
