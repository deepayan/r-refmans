<!DOCTYPE html><html><head><title>Help for package ergm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ergm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.dyads-ergmConstraint'><p>A meta-constraint indicating handling of arbitrary dyadic constraints</p></a></li>
<li><a href='#absdiff-ergmTerm'><p>Absolute difference in nodal attribute</p></a></li>
<li><a href='#absdiffcat-ergmTerm'><p>Categorical absolute difference in nodal attribute</p></a></li>
<li><a href='#altkstar-ergmTerm'><p>Alternating <code class="reqn">k</code>-star</p></a></li>
<li><a href='#anova.ergm'><p>ANOVA for ERGM Fits</p></a></li>
<li><a href='#approx.hotelling.diff.test'><p>Approximate Hotelling T^2-Test for One or Two Population Means</p></a></li>
<li><a href='#as.network.numeric'><p>Create a Simple Random network of a Given Size</p></a></li>
<li><a href='#as.rlebdm.ergm_conlist'><p>Extract dyad-level ERGM constraint information into an <code>rlebdm</code> object</p></a></li>
<li><a href='#asymmetric-ergmTerm'><p>Asymmetric dyads</p></a></li>
<li><a href='#atleast-ergmTerm'><p>Number of dyads with values greater than or equal to a threshold</p></a></li>
<li><a href='#atmost-ergmTerm'><p>Number of dyads with values less than or equal to a threshold</p></a></li>
<li><a href='#attrcov-ergmTerm'><p>Edge covariate by attribute pairing</p></a></li>
<li><a href='#B-ergmTerm'><p>Wrap binary terms for use in valued models</p></a></li>
<li><a href='#b1concurrent-ergmTerm'><p>Concurrent node count for the first mode in a bipartite network</p></a></li>
<li><a href='#b1cov-ergmTerm'><p>Main effect of a covariate for the first mode in a bipartite network</p></a></li>
<li><a href='#b1degrange-ergmTerm'><p>Degree range for the first mode in a bipartite network</p></a></li>
<li><a href='#b1degree-ergmTerm'><p>Degree for the first mode in a bipartite network</p></a></li>
<li><a href='#b1degrees-ergmConstraint'><p>Preserve the actor degree for bipartite networks</p></a></li>
<li><a href='#b1dsp-ergmTerm'><p>Dyadwise shared partners for dyads in the first bipartition</p></a></li>
<li><a href='#b1factor-ergmTerm'><p>Factor attribute effect for the first mode in a bipartite network</p></a></li>
<li><a href='#b1mindegree-ergmTerm'><p>Minimum degree for the first mode in a bipartite network</p></a></li>
<li><a href='#b1nodematch-ergmTerm'><p>Nodal attribute-based homophily effect for the first mode in a bipartite network</p></a></li>
<li><a href='#b1sociality-ergmTerm'><p>Degree</p></a></li>
<li><a href='#b1star-ergmTerm'><p><code class="reqn">k</code>-stars for the first mode in a bipartite network</p></a></li>
<li><a href='#b1starmix-ergmTerm'><p>Mixing matrix for <code class="reqn">k</code>-stars centered on the first mode of a bipartite network</p></a></li>
<li><a href='#b1twostar-ergmTerm'><p>Two-star census for central nodes centered on the first mode of a bipartite network</p></a></li>
<li><a href='#b2concurrent-ergmTerm'><p>Concurrent node count for the second mode in a bipartite network</p></a></li>
<li><a href='#b2cov-ergmTerm'><p>Main effect of a covariate for the second mode in a bipartite  network</p></a></li>
<li><a href='#b2degrange-ergmTerm'><p>Degree range for the second mode in a bipartite network</p></a></li>
<li><a href='#b2degree-ergmTerm'><p>Degree for the second mode in a bipartite network</p></a></li>
<li><a href='#b2degrees-ergmConstraint'><p>Preserve the receiver degree for bipartite networks</p></a></li>
<li><a href='#b2dsp-ergmTerm'><p>Dyadwise shared partners for dyads in the second bipartition</p></a></li>
<li><a href='#b2factor-ergmTerm'><p>Factor attribute effect for the second mode in a bipartite network</p></a></li>
<li><a href='#b2mindegree-ergmTerm'><p>Minimum degree for the second mode in a bipartite network</p></a></li>
<li><a href='#b2nodematch-ergmTerm'><p>Nodal attribute-based homophily effect for the second mode in a bipartite network</p></a></li>
<li><a href='#b2sociality-ergmTerm'><p>Degree</p></a></li>
<li><a href='#b2star-ergmTerm'><p><code class="reqn">k</code>-stars for the second mode in a bipartite network</p></a></li>
<li><a href='#b2starmix-ergmTerm'><p>Mixing matrix for <code class="reqn">k</code>-stars centered on the second mode of a bipartite network</p></a></li>
<li><a href='#b2twostar-ergmTerm'><p>Two-star census for central nodes centered on the second mode of a bipartite network</p></a></li>
<li><a href='#balance-ergmTerm'><p>Balanced triads</p></a></li>
<li><a href='#bd-ergmConstraint'><p>Constrain maximum and minimum vertex degree</p></a></li>
<li><a href='#BDStratTNT-ergmProposal'><p>TNT proposal with degree bounds, stratification, and a blocks constraint</p></a></li>
<li><a href='#Bernoulli-ergmReference'><p>Bernoulli reference</p></a></li>
<li><a href='#blockdiag-ergmConstraint'><p>Block-diagonal structure constraint</p></a></li>
<li><a href='#blocks-ergmConstraint'><p>Constrain blocks of dyads defined by mixing type on a vertex attribute.</p></a></li>
<li><a href='#call.ErgmTerm'><p>Locate and call an ERGM term initialization function.</p></a></li>
<li><a href='#check.ErgmTerm'><p>Ensures an Ergm Term and its Arguments Meet Appropriate Conditions</p></a></li>
<li><a href='#cohab'><p>Target statistics and model fit to a hypothetical 50,000-node network population with</p>
50,000 nodes based on egocent</a></li>
<li><a href='#coincidence-ergmTerm'><p>Coincident node count for the second mode in a bipartite (aka two-mode) network</p></a></li>
<li><a href='#concurrent-ergmTerm'><p>Concurrent node count</p></a></li>
<li><a href='#concurrentties-ergmTerm'><p>Concurrent tie count</p></a></li>
<li><a href='#CondB1Degree-ergmProposal'><p>MHp for b1degree constraints</p></a></li>
<li><a href='#CondB2Degree-ergmProposal'><p>MHp for b2degree constraints</p></a></li>
<li><a href='#CondDegree-ergmProposal'><p>MHp for degree constraints</p></a></li>
<li><a href='#CondDegreeDist-ergmProposal'><p>MHp for degreedist constraints</p></a></li>
<li><a href='#CondDegreeMix-ergmProposal'><p>MHp for degree mix constraints</p></a></li>
<li><a href='#CondInDegree-ergmProposal'><p>MHp for idegree constraints</p></a></li>
<li><a href='#CondInDegreeDist-ergmProposal'><p>MHp for idegreedist constraints</p></a></li>
<li><a href='#CondOutDegree-ergmProposal'><p>MHp for odegree constraints</p></a></li>
<li><a href='#CondOutDegreeDist-ergmProposal'><p>MHp for odegreedist constraints</p></a></li>
<li><a href='#ConstantEdges-ergmProposal'><p>MHp for edges constraints</p></a></li>
<li><a href='#control.ergm'><p>Auxiliary for Controlling ERGM Fitting</p></a></li>
<li><a href='#control.ergm.bridge'><p>Auxiliaries for Controlling <code>ergm.bridge.llr()</code> and <code>logLik.ergm()</code></p></a></li>
<li><a href='#control.ergm.godfather'><p>Control parameters for <code>ergm.godfather()</code>.</p></a></li>
<li><a href='#control.gof'><p>Auxiliary for Controlling ERGM Goodness-of-Fit Evaluation</p></a></li>
<li><a href='#control.san'><p>Auxiliary for Controlling SAN</p></a></li>
<li><a href='#control.simulate.ergm'><p>Auxiliary for Controlling ERGM Simulation</p></a></li>
<li><a href='#ctriple-ergmTerm'><p>Cyclic triples</p></a></li>
<li><a href='#Curve-ergmTerm'><p>Impose a curved structure on term parameters</p></a></li>
<li><a href='#cycle-ergmTerm'><p>k-Cycle Census</p></a></li>
<li><a href='#cyclicalties-ergmTerm'><p>Cyclical ties</p></a></li>
<li><a href='#cyclicalweights-ergmTerm'><p>Cyclical weights</p></a></li>
<li><a href='#degcor-ergmTerm'><p>Degree Correlation</p></a></li>
<li><a href='#degcrossprod-ergmTerm'><p>Degree Cross-Product</p></a></li>
<li><a href='#degrange-ergmTerm'><p>Degree range</p></a></li>
<li><a href='#degree-ergmTerm'><p>Degree</p></a></li>
<li><a href='#degree1.5-ergmTerm'><p>Degree to the 3/2 power</p></a></li>
<li><a href='#degreedist'><p>Computes and Returns the Degree Distribution Information for a Given Network</p></a></li>
<li><a href='#degreedist-ergmConstraint'><p>Preserve the degree distribution of the given network</p></a></li>
<li><a href='#degrees-ergmConstraint'><p>Preserve the degree of each vertex of the given network</p></a></li>
<li><a href='#density-ergmTerm'><p>Density</p></a></li>
<li><a href='#diff-ergmTerm'><p>Difference</p></a></li>
<li><a href='#DiscUnif-ergmProposal'><p>TODO</p></a></li>
<li><a href='#DiscUnif-ergmReference'><p>Discrete Uniform reference</p></a></li>
<li><a href='#DiscUnif2-ergmProposal'><p>TODO</p></a></li>
<li><a href='#DiscUnifNonObserved-ergmProposal'><p>TODO</p></a></li>
<li><a href='#DistRLE-ergmProposal'><p>TODO</p></a></li>
<li><a href='#dsp-ergmTerm'><p>Directed dyadwise shared partners</p></a></li>
<li><a href='#dyadcov-ergmTerm'><p>Dyadic covariate</p></a></li>
<li><a href='#dyadnoise-ergmConstraint'><p>A soft constraint to adjust the sampled distribution for</p>
dyad-level noise with known perturbation probabilities</a></li>
<li><a href='#dyadnoise-ergmProposal'><p>TODO</p></a></li>
<li><a href='#dyadnoiseTNT-ergmProposal'><p>TODO</p></a></li>
<li><a href='#Dyads-ergmConstraint'><p>Constrain fixed or varying dyad-independent terms</p></a></li>
<li><a href='#ecoli'><p>Two versions of an E. Coli network dataset</p></a></li>
<li><a href='#edgecov-ergmTerm'><p>Edge covariate</p></a></li>
<li><a href='#edges-ergmConstraint'><p>Preserve the edge count of the given network</p></a></li>
<li><a href='#edges-ergmTerm'><p>Number of edges in the network</p></a></li>
<li><a href='#egocentric-ergmConstraint'><p>Preserve values of dyads incident on vertices with given attribute</p></a></li>
<li><a href='#enformulate.curved-deprecated'><p>Convert a curved ERGM into a form suitable as initial values for the same</p>
ergm. Deprecated in 4.0.0.</a></li>
<li><a href='#equalto-ergmTerm'><p>Number of dyads with values equal to a specific value (within tolerance)</p></a></li>
<li><a href='#ergm'><p>Exponential-Family Random Graph Models</p></a></li>
<li><a href='#ergm_bd_init'><p>Initializes the parameters to bound degree during sampling</p></a></li>
<li><a href='#ergm_Cstate_clear'><p>Deallocate the C data structures corresponding to an <code>ergm_state</code> left over from a <code>.Call()</code> run.</p></a></li>
<li><a href='#ergm_cutoff_message'><p>Helper function for constructing <code style="white-space: pre;">&#8288;gw*&#8288;</code> cutoff error messages</p></a></li>
<li><a href='#ergm_dyadgen_select'><p>A helper function to select and construct a dyad generator for C.</p></a></li>
<li><a href='#ergm_edgecov_args'><p>A common pattern for obtaining an edge covariate</p></a></li>
<li><a href='#ergm_GWDECAY'><p>Curved settings for geometric weights for the <code style="white-space: pre;">&#8288;gw*&#8288;</code> terms</p></a></li>
<li><a href='#ergm_keyword'><p>Dynamic ERGM keyword registry</p></a></li>
<li><a href='#ergm_MCMC_sample'><p>Internal Function to Sample Networks and Network Statistics</p></a></li>
<li><a href='#ergm_mk_std_op_namewrap'><p>Combine an operator term's and a subterm's name in a standard fashion.</p></a></li>
<li><a href='#ergm_model'><p>Internal representation of an <code>ergm</code> network model</p></a></li>
<li><a href='#ergm_plot.mcmc.list'><p>Plot MCMC list using <code>lattice</code> package graphics</p></a></li>
<li><a href='#ergm_preprocess_response'><p>Update the network and the response argument.</p></a></li>
<li><a href='#ergm_propagate_ext.encode'><p>Extended states for submodels</p></a></li>
<li><a href='#ergm_proposal'><p>Functions to initialize the ergm_proposal object</p></a></li>
<li><a href='#ergm_proposal_table'><p>Table mapping reference,constraints, etc. to ERGM Metropolis-Hastings proposals</p></a></li>
<li><a href='#ergm_SAN_slave'><p>Internal Function to Perform Simulated Annealing</p></a></li>
<li><a href='#ergm_state'><p>A Representation of ERGM state</p></a></li>
<li><a href='#ergm_state_cache'><p>A rudimentary cache for large objects</p></a></li>
<li><a href='#ergm_symmetrize'><p>Return a symmetrized version of a binary network</p></a></li>
<li><a href='#ergm-defunct'><p>Functions that have been removed from this package</p></a></li>
<li><a href='#ergm-deprecated'><p>Functions that will no longer be supported in future releases of the package</p></a></li>
<li><a href='#ergm-errors'><p>Sensible error and warning messages by <code>ergm</code> initializers</p></a></li>
<li><a href='#ergm-internal'><p>Internal ergm Objects</p></a></li>
<li><a href='#ergm-options'><p>Global options and term options for the <code>ergm</code> package</p></a></li>
<li><a href='#ergm-package'><p>Fit, Simulate and Diagnose Exponential-Family Models for Networks</p></a></li>
<li><a href='#ergm-parallel'><p>Parallel Processing in the <code>ergm</code> Package</p></a></li>
<li><a href='#ergm.allstats'><p>Calculate all possible vectors of statistics on a network for an ERGM</p></a></li>
<li><a href='#ergm.bridge.llr'><p>Bridge sampling to evaluate ERGM log-likelihoods and log-likelihood ratios</p></a></li>
<li><a href='#ergm.design'><p>Obtain the set of informative dyads based on the network structure.</p></a></li>
<li><a href='#ergm.estfun'><p>Compute the Sample Estimating Function Values of an ERGM.</p></a></li>
<li><a href='#ergm.eta'><p>Operations to map curved <code>ergm()</code> parameters onto canonical parameters</p></a></li>
<li><a href='#ergm.exact'><p>Calculate the exact loglikelihood for an ERGM</p></a></li>
<li><a href='#ergm.geodistdist'><p>Calculate geodesic distance distribution for a network or edgelist</p></a></li>
<li><a href='#ergm.getnetwork'><p>Acquire and verify the network from the LHS of an <code>ergm</code> formula</p>
and verify that it is a valid network.</a></li>
<li><a href='#ergm.godfather'><p>A function to apply a given series of changes to a network.</p></a></li>
<li><a href='#ergm.mple'><p>Find a maximizer to the psuedolikelihood function</p></a></li>
<li><a href='#ergmConstraint'><p>Sample Space Constraints for Exponential-Family Random Graph Models</p></a></li>
<li><a href='#ergmHint'><p>MCMC Hints for Exponential-Family Random Graph Models</p></a></li>
<li><a href='#ergmKeyword'><p>Keywords defined for Exponential-Family Random Graph Models</p></a></li>
<li><a href='#ergmlhs'><p>An API for specifying aspects of an <code>ergm</code> model in the</p>
LHS/basis network.</a></li>
<li><a href='#ergmMPLE'><p>ERGM Predictors and response for logistic regression calculation of MPLE</p></a></li>
<li><a href='#ergmProposal'><p>Metropolis-Hastings Proposal Methods for ERGM MCMC</p></a></li>
<li><a href='#ergmReference'><p>Reference Measures for Exponential-Family Random Graph Models</p></a></li>
<li><a href='#ergmTerm'><p>Terms used in Exponential Family Random Graph Models</p></a></li>
<li><a href='#esp-ergmTerm'><p>Directed edgewise shared partners</p></a></li>
<li><a href='#Exp-ergmTerm'><p>Exponentiate a network's statistic</p></a></li>
<li><a href='#F-ergmTerm'><p>Filtering on arbitrary one-term model</p></a></li>
<li><a href='#faux.desert.high'><p>Faux desert High School as a network object</p></a></li>
<li><a href='#faux.dixon.high'><p>Faux dixon High School as a network object</p></a></li>
<li><a href='#faux.magnolia.high'><p>Goodreau's Faux Magnolia High School as a network object</p></a></li>
<li><a href='#faux.mesa.high'><p>Goodreau's Faux Mesa High School as a network object</p></a></li>
<li><a href='#fix.curved'><p>Convert a curved ERGM into a corresponding &quot;fixed&quot; ERGM.</p></a></li>
<li><a href='#fixallbut-ergmConstraint'><p>Preserve the dyad status in all but the given edges</p></a></li>
<li><a href='#fixedas-ergmConstraint'><p>Preserve and preclude edges</p></a></li>
<li><a href='#florentine'><p>Florentine Family Marriage and Business Ties Data as a &quot;network&quot; object</p></a></li>
<li><a href='#For-ergmTerm'><p>A <code>for</code> operator for terms</p></a></li>
<li><a href='#g4'><p>Goodreau's four node network as a &quot;network&quot; object</p></a></li>
<li><a href='#get.node.attr'><p>Retrieve and check assumptions about vertex attributes (nodal covariates) in</p>
a network</a></li>
<li><a href='#geweke.diag.mv'><p>Multivariate version of <code>coda</code>'s <code>coda::geweke.diag()</code>.</p></a></li>
<li><a href='#gof'><p>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph</p>
Model</a></li>
<li><a href='#greaterthan-ergmTerm'><p>Number of dyads with values strictly greater than a threshold</p></a></li>
<li><a href='#gwb1degree-ergmTerm'><p>Geometrically weighted degree distribution for the first mode in a bipartite network</p></a></li>
<li><a href='#gwb1dsp-ergmTerm'><p>Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition</p></a></li>
<li><a href='#gwb2degree-ergmTerm'><p>Geometrically weighted degree distribution for the second mode in a bipartite network</p></a></li>
<li><a href='#gwb2dsp-ergmTerm'><p>Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition</p></a></li>
<li><a href='#gwdegree-ergmTerm'><p>Geometrically weighted degree distribution</p></a></li>
<li><a href='#gwdsp-ergmTerm'><p>Geometrically weighted dyadwise shared partner distribution</p></a></li>
<li><a href='#gwesp-ergmTerm'><p>Geometrically weighted edgewise shared partner distribution</p></a></li>
<li><a href='#gwidegree-ergmTerm'><p>Geometrically weighted in-degree distribution</p></a></li>
<li><a href='#gwnsp-ergmTerm'><p>Geometrically weighted non-edgewise shared partner distribution</p></a></li>
<li><a href='#gwodegree-ergmTerm'><p>Geometrically weighted out-degree distribution</p></a></li>
<li><a href='#hamming-ergmConstraint'><p>Preserve the hamming distance to the given network (BROKEN: Do NOT Use)</p></a></li>
<li><a href='#hamming-ergmTerm'><p>Hamming distance</p></a></li>
<li><a href='#HammingConstantEdges-ergmProposal'><p>TODO</p></a></li>
<li><a href='#HammingTNT-ergmProposal'><p>TODO</p></a></li>
<li><a href='#idegrange-ergmTerm'><p>In-degree range</p></a></li>
<li><a href='#idegree-ergmTerm'><p>In-degree</p></a></li>
<li><a href='#idegree1.5-ergmTerm'><p>In-degree to the 3/2 power</p></a></li>
<li><a href='#idegreedist-ergmConstraint'><p>Preserve the indegree distribution</p></a></li>
<li><a href='#idegrees-ergmConstraint'><p>Preserve indegree for directed networks</p></a></li>
<li><a href='#ininterval-ergmTerm'><p>Number of dyads whose values are in an interval</p></a></li>
<li><a href='#intransitive-ergmTerm'><p>Intransitive triads</p></a></li>
<li><a href='#is.curved'><p>Testing for curved exponential family</p></a></li>
<li><a href='#is.dyad.independent'><p>Testing for dyad-independence</p></a></li>
<li><a href='#is.valued'><p>Function to check whether an ERGM fit or some aspect of it is valued</p></a></li>
<li><a href='#isolatededges-ergmTerm'><p>Isolated edges</p></a></li>
<li><a href='#isolates-ergmTerm'><p>Isolates</p></a></li>
<li><a href='#istar-ergmTerm'><p>In-stars</p></a></li>
<li><a href='#kapferer'><p>Kapferer's tailor shop data</p></a></li>
<li><a href='#kstar-ergmTerm'><p><code class="reqn">k</code>-stars</p></a></li>
<li><a href='#Label-ergmTerm'><p>Modify terms' coefficient names</p></a></li>
<li><a href='#localtriangle-ergmTerm'><p>Triangles within neighborhoods</p></a></li>
<li><a href='#Log-ergmTerm'><p>Take a natural logarithm of a network's statistic</p></a></li>
<li><a href='#logLik.ergm'><p>A <code>logLik</code> method for <code>ergm</code> fits.</p></a></li>
<li><a href='#logLikNull'><p>Calculate the null model likelihood</p></a></li>
<li><a href='#m2star-ergmTerm'><p>Mixed 2-stars, a.k.a 2-paths</p></a></li>
<li><a href='#mcmc.diagnostics'><p>Conduct MCMC diagnostics on a model fit</p></a></li>
<li><a href='#meandeg-ergmTerm'><p>Mean vertex degree</p></a></li>
<li><a href='#mm-ergmTerm'><p>Mixing matrix cells and margins</p></a></li>
<li><a href='#molecule'><p>Synthetic network with 20 nodes and 28 edges</p></a></li>
<li><a href='#mutual-ergmTerm'><p>Mutuality</p></a></li>
<li><a href='#nearsimmelian-ergmTerm'><p>Near simmelian triads</p></a></li>
<li><a href='#network.list'><p>A convenience container for a list of <code>network</code> objects, output</p>
by <code>simulate.ergm</code> among others.</a></li>
<li><a href='#nodal_attributes'><p>Specifying nodal attributes and their levels</p></a></li>
<li><a href='#nodal_attributes-API'><p>Helper functions for specifying nodal attribute levels</p></a></li>
<li><a href='#nodecov-ergmTerm'><p>Main effect of a covariate</p></a></li>
<li><a href='#nodecovar-ergmTerm'><p>Covariance of undirected dyad values incident on each actor</p></a></li>
<li><a href='#nodefactor-ergmTerm'><p>Factor attribute effect</p></a></li>
<li><a href='#nodeicov-ergmTerm'><p>Main effect of a covariate for in-edges</p></a></li>
<li><a href='#nodeicovar-ergmTerm'><p>Covariance of in-dyad values incident on each actor</p></a></li>
<li><a href='#nodeifactor-ergmTerm'><p>Factor attribute effect for in-edges</p></a></li>
<li><a href='#nodematch-ergmTerm'><p>Uniform homophily and differential homophily</p></a></li>
<li><a href='#NodematchFilter-ergmTerm'><p>Filtering on nodematch</p></a></li>
<li><a href='#nodemix-ergmTerm'><p>Nodal attribute mixing</p></a></li>
<li><a href='#nodeocov-ergmTerm'><p>Main effect of a covariate for out-edges</p></a></li>
<li><a href='#nodeocovar-ergmTerm'><p>Covariance of out-dyad values incident on each actor</p></a></li>
<li><a href='#nodeofactor-ergmTerm'><p>Factor attribute effect for out-edges</p></a></li>
<li><a href='#nparam'><p>Length of the parameter vector associated with an object or with its terms.</p></a></li>
<li><a href='#nsp-ergmTerm'><p>Directed non-edgewise shared partners</p></a></li>
<li><a href='#nvattr.copy.network'><p>Copy network- and vertex-level attributes between two network objects</p></a></li>
<li><a href='#observed-ergmConstraint'><p>Preserve the observed dyads of the given network</p></a></li>
<li><a href='#odegrange-ergmTerm'><p>Out-degree range</p></a></li>
<li><a href='#odegree-ergmTerm'><p>Out-degree</p></a></li>
<li><a href='#odegree1.5-ergmTerm'><p>Out-degree to the 3/2 power</p></a></li>
<li><a href='#odegreedist-ergmConstraint'><p>Preserve the outdegree distribution</p></a></li>
<li><a href='#odegrees-ergmConstraint'><p>Preserve outdegree for directed networks</p></a></li>
<li><a href='#Offset-ergmTerm'><p>Terms with fixed coefficients</p></a></li>
<li><a href='#opentriad-ergmTerm'><p>Open triads</p></a></li>
<li><a href='#ostar-ergmTerm'><p>k-Outstars</p></a></li>
<li><a href='#param_names'><p>Names of the parameters associated with an object.</p></a></li>
<li><a href='#predict.formula'><p>ERGM-based tie probabilities</p></a></li>
<li><a href='#Prod-ergmTerm'><p>A product (or an arbitrary power combination) of one or more formulas</p></a></li>
<li><a href='#randomtoggle-ergmProposal'><p>Propose a randomly selected dyad to toggle</p></a></li>
<li><a href='#rank_test.ergm'><p>A lack-of-fit test for ERGMs</p></a></li>
<li><a href='#receiver-ergmTerm'><p>Receiver effect</p></a></li>
<li><a href='#rlebdm'><p>RLE-Compressed Boolean Dyad Matrix</p></a></li>
<li><a href='#S-ergmTerm'><p>Evaluation on an induced subgraph</p></a></li>
<li><a href='#samplk'><p>Longitudinal networks of positive affection within a monastery as a</p>
&quot;network&quot; object</a></li>
<li><a href='#sampson'><p>Cumulative network of positive affection within a monastery as a &quot;network&quot;</p>
object</a></li>
<li><a href='#san'><p>Generate networks with a given set of network statistics</p></a></li>
<li><a href='#search.ergmTerms'><p>Search ERGM terms, constraints, references, hints, and proposals</p></a></li>
<li><a href='#sender-ergmTerm'><p>Sender effect</p></a></li>
<li><a href='#shrink_into_CH'><p>Identify the position of a point relative to the  convex hull of a set of points</p></a></li>
<li><a href='#simmelian-ergmTerm'><p>Simmelian triads</p></a></li>
<li><a href='#simmelianties-ergmTerm'><p>Ties in simmelian triads</p></a></li>
<li><a href='#simulate.ergm'><p>Draw from the distribution of an Exponential Family Random Graph Model</p></a></li>
<li><a href='#simulate.formula'><p>A <code>simulate</code> Method for <code>formula</code> objects that dispatches based on the Left-Hand Side</p></a></li>
<li><a href='#smalldiff-ergmTerm'><p>Number of ties between actors with similar attribute values</p></a></li>
<li><a href='#smallerthan-ergmTerm'><p>Number of dyads with values strictly smaller than a threshold</p></a></li>
<li><a href='#snctrl'><p>Statnet Control</p></a></li>
<li><a href='#sociality-ergmTerm'><p>Undirected degree</p></a></li>
<li><a href='#sparse-ergmHint'><p>Sparse network</p></a></li>
<li><a href='#spectrum0.mvar'><p>Multivariate version of <code>coda</code>'s <code>spectrum0.ar()</code>.</p></a></li>
<li><a href='#StdNormal-ergmProposal'><p>TODO</p></a></li>
<li><a href='#StdNormal-ergmReference'><p>Standard Normal reference</p></a></li>
<li><a href='#strat-ergmHint'><p>Stratify Proposed Toggles by Mixing Type on a Vertex Attribute</p></a></li>
<li><a href='#sum-ergmTerm'><p>Sum of dyad values (optionally taken to a power)</p></a></li>
<li><a href='#Sum-ergmTerm'><p>A sum (or an arbitrary linear combination) of one or more formulas</p></a></li>
<li><a href='#summary_formula'><p>Dispatching a summary function based on the class of the LHS of a</p>
formula.</a></li>
<li><a href='#summary.ergm'><p>Summarizing ERGM Model Fits</p></a></li>
<li><a href='#summary.ergm_model'><p>Evaluate network summary statistics from an initialized ergm model</p></a></li>
<li><a href='#summary.formula'><p>Calculation of network or graph statistics or other attributes</p>
specified on a formula</a></li>
<li><a href='#Symmetrize-ergmTerm'><p>Evaluation on symmetrized (undirected) network</p></a></li>
<li><a href='#threetrail-ergmTerm'><p>Three-trails</p></a></li>
<li><a href='#TNT-ergmProposal'><p>Default MH algorithm</p></a></li>
<li><a href='#to_ergm_Cdouble.network'><p>Methods to serialize objects into numeric vectors for passing to the C side.</p></a></li>
<li><a href='#transitive-ergmTerm'><p>Transitive triads</p></a></li>
<li><a href='#transitiveties-ergmTerm'><p>Transitive ties</p></a></li>
<li><a href='#transitiveweights-ergmTerm'><p>Transitive weights</p></a></li>
<li><a href='#triadcensus-ergmTerm'><p>Triad census</p></a></li>
<li><a href='#triangle-ergmTerm'><p>Triangles</p></a></li>
<li><a href='#tripercent-ergmTerm'><p>Triangle percentage</p></a></li>
<li><a href='#ttriple-ergmTerm'><p>Transitive triples</p></a></li>
<li><a href='#twopath-ergmTerm'><p>2-Paths</p></a></li>
<li><a href='#Unif-ergmProposal'><p>TODO</p></a></li>
<li><a href='#Unif-ergmReference'><p>Continuous Uniform reference</p></a></li>
<li><a href='#UnifNonObserved-ergmProposal'><p>TODO</p></a></li>
<li><a href='#update.network'><p>Update the edges in a network based on a matrix</p></a></li>
<li><a href='#wrap.ergm_model'><p>Wrap a submodel's curved, empty network statistics, and extended</p>
state (read-only) specification (if present) for output from an
<code>InitErgmTerm</code> or <code>InitWtErgmTerm</code>.</a></li>
<li><a href='#wtd.median'><p>Weighted Median</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit, Simulate and Diagnose Exponential-Family Models for
Networks</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1), network (&ge; 1.18.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>robustbase (&ge; 0.93.7), coda (&ge; 0.19.4), trust (&ge; 0.1.8),
Matrix (&ge; 1.3.2), lpSolveAPI (&ge; 5.5.2.0.17.7), MASS (&ge;
7.3.53.1), statnet.common (&ge; 4.9.0), rle (&ge; 0.9.2), purrr (&ge;
0.3.4), rlang (&ge; 0.4.10), memoise (&ge; 2.0.0), tibble (&ge;
3.1.0), magrittr (&ge; 2.0.1), Rdpack (&ge; 2.4), parallel,
methods, knitr, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice (&ge; 0.20.41), latticeExtra (&ge; 0.6.29), sna (&ge; 2.6),
rmarkdown, testthat (&ge; 3.0.2), ergm.count (&ge; 4.0), withr,
covr, Rglpk, slam, networkLite</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenMPI</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/ergm/issues">https://github.com/statnet/ergm/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An integrated set of tools to analyze and simulate networks based on exponential-family random graph models (ERGMs). 'ergm' is a part of the Statnet suite of packages for network analysis. See Hunter, Handcock, Butts, Goodreau, and Morris (2008) &lt;<a href="https://doi.org/10.18637%2Fjss.v024.i03">doi:10.18637/jss.v024.i03</a>&gt; and Krivitsky, Hunter, Morris, and Klumb (2023) &lt;<a href="https://doi.org/10.18637%2Fjss.v105.i06">doi:10.18637/jss.v105.i06</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>License_is_FOSS:</td>
<td>yes</td>
</tr>
<tr>
<td>License_restricts_use:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org">https://statnet.org</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/build/clean-inst-doc:</td>
<td>FALSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'InitErgmConstraint.R' 'InitErgmConstraint.blockdiag.R'
'InitErgmConstraint.hints.R' 'InitErgmProposal.R'
'InitErgmProposal.dyadnoise.R' 'InitErgmReference.R'
'ergm-deprecated.R' 'InitErgmTerm.R' 'InitErgmTerm.auxnet.R'
'InitErgmTerm.bipartite.R' 'InitErgmTerm.bipartite.degree.R'
'InitErgmTerm.blockop.R' 'InitErgmTerm.coincidence.R'
'InitErgmTerm.dgw_sp.R' 'InitErgmTerm.extra.R'
'InitErgmTerm.indices.R' 'InitErgmTerm.interaction.R'
'InitErgmTerm.operator.R' 'InitErgmTerm.spcache.R'
'InitErgmTerm.test.R' 'InitErgmTerm.transitiveties.R'
'InitWtErgmProposal.R' 'InitWtErgmTerm.R'
'InitWtErgmTerm.operator.R' 'InitWtErgmTerm.test.R'
'anova.ergm.R' 'anova.ergmlist.R'
'approx.hotelling.diff.test.R' 'as.network.numeric.R'
'build_term_index.R' 'check.ErgmTerm.R' 'control.ergm.R'
'control.ergm.bridge.R' 'control.gof.R' 'control.logLik.ergm.R'
'control.san.R' 'control.simulate.R' 'data.R' 'ergm-defunct.R'
'ergm-internal.R' 'ergm-options.R' 'ergm-package.R'
'ergm-terms-index.R' 'ergm.CD.fixed.R' 'ergm.Cprepare.R'
'ergm.MCMCse.R' 'ergm.MCMLE.R' 'ergm.R' 'ergm.allstats.R'
'ergm.auxstorage.R' 'ergm.bounddeg.R' 'ergm.bridge.R'
'ergm.design.R' 'ergm.errors.R' 'ergm.estimate.R' 'ergm.eta.R'
'ergm.etagrad.R' 'ergm.etagradmult.R' 'ergm.etamap.R'
'ergm.geodistn.R' 'ergm.getCDsample.R' 'ergm.getMCMCsample.R'
'ergm.getnetwork.R' 'ergm.initialfit.R' 'ergm.llik.R'
'ergm.llik.obs.R' 'ergm.logitreg.R' 'ergm.mple.R'
'ergm.pen.glm.R' 'ergm.phase12.R' 'ergm.pl.R' 'ergm.san.R'
'ergm.stepping.R' 'ergm.stocapprox.R' 'ergm.utility.R'
'ergmMPLE.R' 'ergm_estfun.R' 'ergm_keyword.R' 'ergm_model.R'
'ergm_model.utils.R' 'ergm_mplecov.R' 'ergm_proposal.R'
'ergm_response.R' 'ergm_state.R' 'ergmlhs.R' 'formula.utils.R'
'get.node.attr.R' 'godfather.R' 'gof.ergm.R' 'is.curved.R'
'is.dyad.independent.R' 'is.inCH.R' 'is.na.ergm.R'
'is.valued.R' 'logLik.ergm.R' 'mcmc.diagnostics.ergm.R'
'network.list.R' 'network.update.R' 'nonidentifiability.R'
'nparam.R' 'obs.constraints.R' 'parallel.utils.R'
'param_names.R' 'predict.ergm.R' 'print.ergm.R'
'print.network.list.R' 'print.summary.ergm.R'
'rank_test.ergm.R' 'rlebdm.R' 'simulate.ergm.R'
'simulate.formula.R' 'summary.ergm.R' 'summary.ergm_model.R'
'summary.network.list.R' 'summary.statistics.network.R'
'to_ergm_Cdouble.R' 'vcov.ergm.R' 'wtd.median.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-17 07:09:10 UTC; pavel</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark S. Handcock [aut],
  David R. Hunter [aut],
  Carter T. Butts [aut],
  Steven M. Goodreau [aut],
  Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Martina Morris [aut],
  Li Wang [ctb],
  Kirk Li [ctb],
  Skye Bender-deMoll [ctb],
  Chad Klumb [ctb],
  Michał Bojanowski <a href="https://orcid.org/0000-0001-7503-852X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ben Bolker [ctb],
  Christian Schmid [ctb],
  Joyce Cheng [ctb],
  Arya Karami [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pavel N. Krivitsky &lt;pavel@statnet.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.dyads-ergmConstraint'>A meta-constraint indicating handling of arbitrary dyadic constraints</h2><span id='topic+.dyads-ergmConstraint'></span>

<h3>Description</h3>

<p>This is a flag in the proposal table indicating that the proposal can enforce arbitrary combinations of dyadic constraints. It cannot be invoked directly by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='absdiff-ergmTerm'>Absolute difference in nodal attribute</h2><span id='topic+absdiff-ergmTerm'></span><span id='topic+InitErgmTerm.absdiff'></span><span id='topic+InitWtErgmTerm.absdiff'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equaling
the sum of <code>abs(attr[i]-attr[j])^pow</code> for all edges <code style="white-space: pre;">&#8288;(i,j)&#8288;</code> in
the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: absdiff(attr,
#                 pow=1)

# valued: absdiff(attr,
#                 pow=1,
#                 form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absdiff-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="absdiff-ergmTerm_+3A_pow">pow</code></td>
<td>
<p>power to which to take the absolute difference</p>
</td></tr>
<tr><td><code id="absdiff-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, quantitative nodal attribute, undirected, binary, valued</p>


<hr>
<h2 id='absdiffcat-ergmTerm'>Categorical absolute difference in nodal attribute</h2><span id='topic+absdiffcat-ergmTerm'></span><span id='topic+InitErgmTerm.absdiffcat'></span><span id='topic+InitWtErgmTerm.absdiffcat'></span>

<h3>Description</h3>

<p>This term adds one statistic for every possible nonzero distinct
value of <code>abs(attr[i]-attr[j])</code> in the network. The value of each such
statistic is the number of edges in the network with the corresponding
absolute difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: absdiffcat(attr,
#                 base=NULL,
#                 levels=NULL)

# valued: absdiffcat(attr,
#                 base=NULL,
#                 levels=NULL,
#                 form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absdiffcat-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="absdiffcat-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="absdiffcat-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>specifies which nonzero difference to include in or exclude from the model. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="absdiffcat-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, dyad-independent, undirected, binary, valued</p>


<hr>
<h2 id='altkstar-ergmTerm'>Alternating <code class="reqn">k</code>-star</h2><span id='topic+altkstar-ergmTerm'></span><span id='topic+InitErgmTerm.altkstar'></span>

<h3>Description</h3>

<p>Add one network statistic to the model equal to a weighted alternating
sequence of <code class="reqn">k</code>-star statistics with weight parameter <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: altkstar(lambda,
#                 fixed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="altkstar-ergmTerm_+3A_lambda">lambda</code></td>
<td>
<p>weight parameter to model</p>
</td></tr>
<tr><td><code id="altkstar-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>indicates whether the <code>decay</code> parameter is
fixed at the given value, or is to be fit as a curved exponential family model
(see Hunter and Handcock, 2006).  The default is <code>FALSE</code>, which means the scale
parameter is not fixed and thus the model is a CEF model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the version given in Snijders et al. (2006). The <code>gwdegree</code> and
<code>altkstar</code> produce mathematically equivalent models, as long as they are used
together with the <code>edges</code> (or <code>kstar(1)</code>) term, yet the interpretation of the
<code>gwdegree</code> parameters is slightly more straightforward than the interpretation
of the <code>altkstar</code> parameters. For this reason, we recommend the use of the
<code>gwdegree</code> instead of <code>altkstar</code>. See Section 3 and especially equation (13)
of Hunter (2007) for details.
</p>


<h3>Note</h3>

<p>This term can only be used with undirected networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, curved, undirected, binary</p>


<hr>
<h2 id='anova.ergm'>ANOVA for ERGM Fits</h2><span id='topic+anova.ergm'></span><span id='topic+anova.ergmlist'></span>

<h3>Description</h3>

<p>Compute an analysis of variance table for one or more ERGM fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm'
anova(object, ..., eval.loglik = FALSE)

## S3 method for class 'ergmlist'
anova(object, ..., eval.loglik = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.ergm_+3A_object">object</code>, <code id="anova.ergm_+3A_...">...</code></td>
<td>
<p>objects of class <code><a href="#topic+ergm">ergm</a></code>, usually, a result of a
call to <code><a href="#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="anova.ergm_+3A_eval.loglik">eval.loglik</code></td>
<td>
<p>a logical specifying whether the log-likelihood will be
evaluated if missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying a single object gives a sequential analysis of variance table for
that fit.  That is, the reductions in the residual sum of squares as each
term of the formula is added in turn are given in the rows of a table, plus
the residual sum of squares.
</p>
<p>The table will contain F statistics (and P values) comparing the mean square
for the row to the residual mean square.
</p>
<p>If more than one object is specified, the table has a row for the residual
degrees of freedom and sum of squares for each model.  For all but the first
model, the change in degrees of freedom and sum of squares is also given.
(This only make statistical sense if the models are nested.)  It is
conventional to list the models from smallest to largest, but this is up to
the user.
</p>
<p>If any of the objects do not have estimated log-likelihoods, produces an
error, unless <code>eval.loglik=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class
<code>"data.frame"</code>.
</p>


<h3>Warning</h3>

<p>The comparison between two or more models will only be
valid if they are fitted to the same dataset. This may be a problem if there
are missing values and 's default of <code>na.action = na.omit</code> is used, and
<code><a href="#topic+anova.ergmlist">anova.ergmlist</a></code> will detect this with an error.
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+ergm">ergm</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>,
<code><a href="#topic+logLik.ergm">logLik.ergm</a></code> for adding the log-likelihood to an existing
<code><a href="#topic+ergm.object">ergm</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(molecule)
molecule %v% "atomic type" &lt;- c(1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3)
fit0 &lt;- ergm(molecule ~ edges)
anova(fit0)
fit1 &lt;- ergm(molecule ~ edges + nodefactor("atomic type"))
anova(fit1)

fit2 &lt;- ergm(molecule ~ edges + nodefactor("atomic type") +  gwesp(0.5,
  fixed=TRUE), eval.loglik=TRUE) # Note the eval.loglik argument.
anova(fit0, fit1)
anova(fit0, fit1, fit2)

</code></pre>

<hr>
<h2 id='approx.hotelling.diff.test'>Approximate Hotelling T^2-Test for One or Two Population Means</h2><span id='topic+approx.hotelling.diff.test'></span>

<h3>Description</h3>

<p>A multivariate hypothesis test for a single population mean or a
difference between them. This version attempts to adjust for
multivariate autocorrelation in the samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx.hotelling.diff.test(
  x,
  y = NULL,
  mu0 = 0,
  assume.indep = FALSE,
  var.equal = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx.hotelling.diff.test_+3A_x">x</code></td>
<td>
<p>a numeric matrix of data values with cases in rows and
variables in columns.</p>
</td></tr>
<tr><td><code id="approx.hotelling.diff.test_+3A_y">y</code></td>
<td>
<p>an optinal matrix of data values with cases in rows and
variables in columns for a 2-sample test.</p>
</td></tr>
<tr><td><code id="approx.hotelling.diff.test_+3A_mu0">mu0</code></td>
<td>
<p>an optional numeric vector: for a 1-sample test, the
poulation mean under the null hypothesis; and for a 2-sample
test, the difference between population means under the null
hypothesis; defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="approx.hotelling.diff.test_+3A_assume.indep">assume.indep</code></td>
<td>
<p>if <code>TRUE</code>, performs an ordinary Hotelling's
test without attempting to account for autocorrelation.</p>
</td></tr>
<tr><td><code id="approx.hotelling.diff.test_+3A_var.equal">var.equal</code></td>
<td>
<p>for a 2-sample test, perform the pooled test:
assume population variance-covariance matrices of the two
variables are equal.</p>
</td></tr>
<tr><td><code id="approx.hotelling.diff.test_+3A_...">...</code></td>
<td>
<p>additional arguments, passed on to <code><a href="#topic+spectrum0.mvar">spectrum0.mvar()</a></code>,
etc.; in particular, <code style="white-space: pre;">&#8288;order.max=&#8288;</code> can be used to limit the order
of the AR model used to estimate the effective sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>htest</code> with the following information:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">T^2</code> statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method specifics.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Null hypothesis mean or mean difference.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Always <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Sample difference.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>Estimated variance-covariance matrix of the estimate of the difference.</p>
</td></tr>
<tr><td><code>covariance.x</code></td>
<td>
<p>Estimated variance-covariance matrix of the estimate of the mean of <code>x</code>.</p>
</td></tr>
<tr><td><code>covariance.y</code></td>
<td>
<p>Estimated variance-covariance matrix of the estimate of the mean of <code>y</code>.</p>
</td></tr>
</table>
<p>It has a print method <code><a href="stats.html#topic+print.htest">print.htest()</a></code>.
</p>


<h3>Note</h3>

<p>For <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> input, the variance for this test is
estimated with unpooled means. This is not strictly correct.
</p>


<h3>References</h3>

<p>Hotelling, H. (1947). Multivariate Quality Control. In C. Eisenhart, M. W.
Hastay, and W. A. Wallis, eds. Techniques of Statistical Analysis. New York:
McGraw-Hill.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test()</a></code>
</p>

<hr>
<h2 id='as.network.numeric'>Create a Simple Random network of a Given Size</h2><span id='topic+as.network.numeric'></span>

<h3>Description</h3>

<p><code><a href="#topic+as.network.numeric">as.network.numeric</a></code> creates a random Bernoulli network of the
given size as an object of class <code><a href="network.html#topic+network">network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
as.network(
  x,
  directed = TRUE,
  hyper = FALSE,
  loops = FALSE,
  multiple = FALSE,
  bipartite = FALSE,
  ignore.eval = TRUE,
  names.eval = NULL,
  edge.check = FALSE,
  density = NULL,
  init = NULL,
  numedges = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.network.numeric_+3A_x">x</code></td>
<td>
<p>count; the number of nodes in the network</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_directed">directed</code></td>
<td>
<p>logical; should edges be interpreted as directed?</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_hyper">hyper</code></td>
<td>
<p>logical; are hyperedges allowed? Currently ignored.</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_loops">loops</code></td>
<td>
<p>logical; should loops be allowed? Currently ignored.</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_multiple">multiple</code></td>
<td>
<p>logical; are multiplex edges allowed? Currently ignored.</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_bipartite">bipartite</code></td>
<td>
<p>count; should the network be interpreted as bipartite? If
present (i.e., non-NULL) it is the count of the number of actors in the
bipartite network. In this case, the number of nodes is equal to the number
of actors plus the number of events (with all actors preceding all events).
The edges are then interpreted as nondirected.</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_ignore.eval">ignore.eval</code></td>
<td>
<p>logical; ignore edge values? Currently ignored.</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_names.eval">names.eval</code></td>
<td>
<p>optionally, the name of the attribute in which edge values
should be stored. Currently ignored.</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_edge.check">edge.check</code></td>
<td>
<p>logical; perform consistency checks on new edges?</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_density">density</code></td>
<td>
<p>numeric; the probability of a tie for Bernoulli networks. If
neither density nor <code>init</code> is given, it defaults to the number of nodes
divided by the number of dyads (so the expected number of ties is the same
as the number of nodes.)</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_init">init</code></td>
<td>
<p>numeric; the log-odds of a tie for Bernoulli networks.  It is
only used if density is not specified.</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_numedges">numedges</code></td>
<td>
<p>count; if present, sample the Bernoulli network conditional
on this number of edges (rather than independently with the specified
probability).</p>
</td></tr>
<tr><td><code id="as.network.numeric_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network will not have vertex, edge or network attributes.  These
can be added with operators such as <code>%v%</code>, <code>%n%</code>, <code>%e%</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="network.html#topic+network">network</a></code>
</p>


<h3>References</h3>

<p>Butts, C.T.  2002.  &ldquo;Memory Structures for Relational Data in
R: Classes and Interfaces&rdquo; Working Paper.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw a random directed network with 25 nodes
g &lt;- network(25)

# Draw a random undirected network with density 0.1
g &lt;- network(25, directed=FALSE, density=0.1)

# Draw a random bipartite network with 4 actors and 6 events and density 0.1
g &lt;- network(10, bipartite=4, directed=FALSE, density=0.1)

# Draw a random directed network with 25 nodes and 50 edges
g &lt;- network(25, numedges=50)
</code></pre>

<hr>
<h2 id='as.rlebdm.ergm_conlist'>Extract dyad-level ERGM constraint information into an <code><a href="#topic+rlebdm">rlebdm</a></code> object</h2><span id='topic+as.rlebdm.ergm_conlist'></span>

<h3>Description</h3>

<p>A function to combine the <code>free_dyads</code> attributes of the
constraints appropriately to generate an <code><a href="#topic+rlebdm">rlebdm</a></code> of dyads
toggleable and/or missing and/or informative under that combination
of constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm_conlist'
as.rlebdm(
  x,
  constraints.obs = NULL,
  which = c("free", "missing", "informative"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.rlebdm.ergm_conlist_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ergm_conlist">ergm_conlist</a></code> object: a list of initialised
constraints. <code>NULL</code> is treated as a placeholder for no constraint
(i.e., a constant matrix of <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="as.rlebdm.ergm_conlist_+3A_constraints.obs">constraints.obs</code></td>
<td>
<p>an <code><a href="#topic+ergm_conlist">ergm_conlist</a></code> object specifying the
observation process constraints; defaults to <code>NULL</code> for all dyads
observed (i.e., a constant matrix of <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="as.rlebdm.ergm_conlist_+3A_which">which</code></td>
<td>
<p>which aspect of the constraint to extract: </p>

<dl>
<dt><code>free</code></dt><dd><p>for dyads that <em>may</em> be toggled under the constraints
<code>x</code>; ignores <code>constraints.obs</code>;</p>
</dd>
<dt><code>missing</code></dt><dd><p>for dyads that are free but considered unobserved
under the constraints; and</p>
</dd>
<dt><code>informative</code></dt><dd><p>for dyads that are both free and observed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="as.rlebdm.ergm_conlist_+3A_...">...</code></td>
<td>
<p>additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For <code>which=="free"</code> or <code>"informative"</code>, <code>NULL</code> return value
is a placeholder for a matrix of <code>TRUE</code>, whereas for
<code>which=="missing"</code> it is a placeholder for a matrix of <code>FALSE</code>.
</p>
<p>Each element in the constraint list has a sign, which
determins whether the constraint further restricts (for <code>+</code>) or
potentially relaxes restriction (for <code>-</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code>
</p>

<hr>
<h2 id='asymmetric-ergmTerm'>Asymmetric dyads</h2><span id='topic+asymmetric-ergmTerm'></span><span id='topic+InitErgmTerm.asymmetric'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the
number of pairs of actors for which exactly one of
<code class="reqn">(i{\rightarrow}j)</code> or <code class="reqn">(j{\rightarrow}i)</code> exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: asymmetric(attr=NULL, diff=FALSE, keep=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymmetric-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>quantitative attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.) If specified, only symmetric pairs that match on the vertex attribute are counted.</p>
</td></tr>
<tr><td><code id="asymmetric-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>Used in the same way as for the <code>nodematch</code> term. (See <code>nodematch</code> (<code>ergmTerm?nodematch</code>) for details.)</p>
</td></tr>
<tr><td><code id="asymmetric-ergmTerm_+3A_keep">keep</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="asymmetric-ergmTerm_+3A_level">level</code></td>
<td>
<p>Used in the same way as for the <code>nodematch</code> term. (See <code>nodematch</code> (<code>ergmTerm?nodematch</code>) for details.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>
<p>The argument <code>keep</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>keep</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>keep</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, triad-related, binary</p>


<hr>
<h2 id='atleast-ergmTerm'>Number of dyads with values greater than or equal to a threshold</h2><span id='topic+atleast-ergmTerm'></span><span id='topic+InitWtErgmTerm.atleast'></span>

<h3>Description</h3>

<p>Adds the number of
statistics equal to the length of <code>threshold</code>
equaling to the number of dyads whose values equal or exceed the
corresponding element of <code>threshold</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: atleast(threshold=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atleast-ergmTerm_+3A_threshold">threshold</code></td>
<td>
<p>vector of numerical values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, valued</p>


<hr>
<h2 id='atmost-ergmTerm'>Number of dyads with values less than or equal to a threshold</h2><span id='topic+atmost-ergmTerm'></span><span id='topic+InitWtErgmTerm.atmost'></span>

<h3>Description</h3>

<p>Adds the number of statistics equal to the length of <code>threshold</code>
equaling to the number of dyads whose values equal or are exceeded by the
corresponding element of <code>threshold</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: atmost(threshold=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atmost-ergmTerm_+3A_threshold">threshold</code></td>
<td>
<p>a vector of numerical values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, valued</p>


<hr>
<h2 id='attrcov-ergmTerm'>Edge covariate by attribute pairing</h2><span id='topic+attrcov-ergmTerm'></span><span id='topic+InitErgmTerm.attrcov'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model, equal to the sum of the covariate values
for each edge appearing in the network, where the covariate value for a given edge is determined by its mixing type on
<code>attr</code>. Undirected networks are regarded as having undirected mixing, and it is assumed that <code>mat</code> is symmetric
in that case.
</p>
<p>This term can be useful for simulating large networks with many mixing types, where <code>nodemix</code> would be slow due to
the large number of statistics, and <code>edgecov</code> cannot be used because an adjacency matrix would be too big.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: attrcov(attr, mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attrcov-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="attrcov-ergmTerm_+3A_mat">mat</code></td>
<td>
<p>a matrix of covariates with the same dimensions as a mixing matrix for <code>attr</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, binary</p>


<hr>
<h2 id='B-ergmTerm'>Wrap binary terms for use in valued models</h2><span id='topic+B-ergmTerm'></span><span id='topic+InitWtErgmTerm.B'></span>

<h3>Description</h3>

<p>Wraps binary <code>ergm</code> terms for use in valued models, with <code>formula</code> specifying which terms
are to be wrapped and <code>form</code> specifying how they are to be
used and how the binary network they are evaluated on is to be constructed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: B(formula, form)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula whose RHS contains the
binary ergm terms to be evaluated. Which terms may be used
depends on the argument <code>form</code></p>
</td></tr>
<tr><td><code id="B-ergmTerm_+3A_form">form</code></td>
<td>
<p>One of three values:
</p>

<ul>
<li> <p><code>"sum"</code>: see section &quot;Generalizations of
binary terms&quot; in <code><a href="#topic+ergmTerm">ergmTerm</a></code> help; all terms in <code>formula</code> must
be dyad-independent.
</p>
</li>
<li> <p><code>"nonzero"</code>: section &quot;Generalizations of
binary terms&quot; in <code><a href="#topic+ergmTerm">ergmTerm</a></code> help; any binary <code>ergm</code> terms
may be used in <code>formula</code> .
</p>
</li>
<li><p> a one-sided formula value-dependent
network. <code>form</code> must contain one &quot;valued&quot; <code>ergm</code> term, with
the following properties:
</p>

<ul>
<li><p> dyadic independence;
</p>
</li>
<li><p> dyadwise contribution of either 0 or 1; and
</p>
</li>
<li><p> dyadwise contribution of 0 for a 0-valued dyad.
</p>
</li></ul>

<p>Formally, this means that it is expressable as
</p>
<p style="text-align: center;"><code class="reqn">g(y) = \sum_{i,j} f_{i,j}(y_{i,j}),</code>
</p>

<p>where for all <code class="reqn">i</code>, <code class="reqn">j</code>, and <code class="reqn">y</code>,
<code class="reqn">f_{i,j}(y_{i,j})</code> is either 0 or 1 and, in particular,
<code class="reqn">f_{i,j}(0)=0</code>.
</p>
<p>Examples of such terms include <code>nonzero</code> ,
<code>ininterval()</code> , <code>atleast()</code> , <code>atmost()</code> ,
<code>greaterthan()</code> , <code>lessthen()</code> , and <code>equalto()</code> .
</p>
<p>Then, the value of the statistic will be the value of the
statistics in <code>formula</code> evaluated on a binary network that is
defined to have an edge if and only if the corresponding
dyad of the valued network adds 1 to the valued term in
<code>form</code> .
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, <code>B(~nodecov("a"), form="sum")</code> is equivalent to
<code>nodecov("a", form="sum")</code> and similarly with
<code>form="nonzero"</code> .
</p>
<p>When a valued implementation is available, it should be
preferred, as it is likely to be faster.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, valued</p>


<hr>
<h2 id='b1concurrent-ergmTerm'>Concurrent node count for the first mode in a bipartite network</h2><span id='topic+b1concurrent-ergmTerm'></span><span id='topic+InitErgmTerm.b1concurrent'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model, equal to the number of nodes in the first
mode of the network with degree 2 or higher. The first mode of a bipartite
network object is sometimes known as the &quot;actor&quot; mode.
This term can only be
used with undirected bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1concurrent(by=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1concurrent-ergmTerm_+3A_by">by</code></td>
<td>
<p>optional argument specifying a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
It functions just like the <code>by</code> argument of the <code>b1degree</code> term.
Without the optional argument, this statistic is equivalent to <code>b1mindegree(2)</code> .</p>
</td></tr>
<tr><td><code id="b1concurrent-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='b1cov-ergmTerm'>Main effect of a covariate for the first mode in a bipartite network</h2><span id='topic+b1cov-ergmTerm'></span><span id='topic+InitErgmTerm.b1cov'></span><span id='topic+InitWtErgmTerm.b1cov'></span>

<h3>Description</h3>

<p>This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total
value of <code>attr(i)</code> for all edges <code class="reqn">(i,j)</code> in the network. This
term may only be used with bipartite networks. For categorical attributes,
see <code>b1factor</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1cov(attr)

# valued: b1cov(attr, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1cov-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="b1cov-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, dyad-independent, frequently-used, quantitative nodal attribute, undirected, binary, valued</p>


<hr>
<h2 id='b1degrange-ergmTerm'>Degree range for the first mode in a bipartite network</h2><span id='topic+b1degrange-ergmTerm'></span><span id='topic+InitErgmTerm.b1degrange'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element of <code>from</code> (or <code>to</code> ); the <code class="reqn">i</code>th
such statistic equals the number of nodes of the first mode
(&quot;actors&quot;) in the network of degree greater than or equal to
<code>from[i]</code> but strictly less than <code>to[i]</code> , i.e. with edge count
in semiopen interval <code style="white-space: pre;">&#8288;[from,to)&#8288;</code> .
</p>
<p>This term can only be used with bipartite networks; for directed networks
see <code>idegrange</code> and <code>odegrange</code> . For undirected networks,
see <code>degrange</code> , and see <code>b2degrange</code>
for degrees of the second mode (&quot;events&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1degrange(from, to=`+Inf`, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1degrange-ergmTerm_+3A_from">from</code>, <code id="b1degrange-ergmTerm_+3A_to">to</code></td>
<td>
<p>vectors of distinct integers. If one of the vectors have length 1, it is recycled to the length of the other. Otherwise, it must have the same length.</p>
</td></tr>
<tr><td><code id="b1degrange-ergmTerm_+3A_by">by</code>, <code id="b1degrange-ergmTerm_+3A_levels">levels</code>, <code id="b1degrange-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='b1degree-ergmTerm'>Degree for the first mode in a bipartite network</h2><span id='topic+b1degree-ergmTerm'></span><span id='topic+InitErgmTerm.b1degree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>d</code> ; the <code class="reqn">i</code>th such statistic equals the number of
nodes of degree <code>d[i]</code> in the first mode of a bipartite network, i.e.
with exactly <code>d[i]</code> edges. The first mode of a bipartite network object
is sometimes known as the &quot;actor&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1degree(d, by=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1degree-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers.</p>
</td></tr>
<tr><td><code id="b1degree-ergmTerm_+3A_by">by</code>, <code id="b1degree-ergmTerm_+3A_levels">levels</code>, <code id="b1degree-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, frequently-used, undirected, binary</p>


<hr>
<h2 id='b1degrees-ergmConstraint'>Preserve the actor degree for bipartite networks</h2><span id='topic+b1degrees-ergmConstraint'></span><span id='topic+InitErgmConstraint.b1degrees'></span>

<h3>Description</h3>

<p>For bipartite networks, preserve the degree for the first mode of each vertex of the given
network, while allowing the degree for the second mode to vary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># b1degrees
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite</p>


<hr>
<h2 id='b1dsp-ergmTerm'>Dyadwise shared partners for dyads in the first bipartition</h2><span id='topic+b1dsp-ergmTerm'></span><span id='topic+InitErgmTerm.b1dsp'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element in <code>d</code> ; the <code class="reqn">i</code>th
such statistic equals the number of dyads in the first bipartition with exactly
<code>d[i]</code> shared partners. (Those shared partners, of course, must be members
of the second bipartition.) This term can only be used with bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1dsp(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1dsp-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='b1factor-ergmTerm'>Factor attribute effect for the first mode in a bipartite network</h2><span id='topic+b1factor-ergmTerm'></span><span id='topic+InitErgmTerm.b1factor'></span><span id='topic+InitWtErgmTerm.b1factor'></span>

<h3>Description</h3>

<p>This term adds multiple network statistics to the model, one for each of (a subset of) the
unique values of the <code>attr</code> attribute. Each of these statistics
gives the number of times a node with that attribute in the first mode of
the network appears in an edge. The first mode of a bipartite network object
is sometimes known as the &quot;actor&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1factor(attr, base=1, levels=-1)

# valued: b1factor(attr, base=1, levels=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1factor-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="b1factor-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="b1factor-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>this optional argument controls which levels of the attribute
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="b1factor-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To include all attribute values is usually not a good idea, because
the sum of all such statistics equals the number of edges and hence a linear
dependency would arise in any model also including <code>edges</code>. The default,
<code>levels=-1</code>, is therefore to omit the first (in lexicographic order)
attribute level. To include all levels, pass either <code>levels=TRUE</code>
(i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>
<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, dyad-independent, frequently-used, undirected, binary, valued</p>


<hr>
<h2 id='b1mindegree-ergmTerm'>Minimum degree for the first mode in a bipartite network</h2><span id='topic+b1mindegree-ergmTerm'></span><span id='topic+InitErgmTerm.b1mindegree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals the number of
nodes in the first mode of a bipartite network with at least degree <code>d[i]</code> .
The first mode of a bipartite network object is sometimes known as the &quot;actor&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1mindegree(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1mindegree-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='b1nodematch-ergmTerm'>Nodal attribute-based homophily effect for the first mode in a bipartite network</h2><span id='topic+b1nodematch-ergmTerm'></span><span id='topic+InitErgmTerm.b1nodematch'></span>

<h3>Description</h3>

<p>This term is introduced
in Bomiriya et al (2014). With the default <code>alpha</code> and <code>beta</code> values, this term will
simply be a homophily based two-star statistic. This term adds one statistic to the model
unless <code>diff</code> is set to <code>TRUE</code> , in which case the term adds multiple network
statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code>
attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1nodematch(attr, diff=FALSE, keep=NULL, alpha=1, beta=1, byb2attr=NULL,
#                     levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1nodematch-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="b1nodematch-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>by default, one statistic will be added to the model. If <code>diff</code> is set to <code>TRUE</code>, one statistic will be added for each unique value of the <code>attr</code> attribute</p>
</td></tr>
<tr><td><code id="b1nodematch-ergmTerm_+3A_keep">keep</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="b1nodematch-ergmTerm_+3A_alpha">alpha</code>, <code id="b1nodematch-ergmTerm_+3A_beta">beta</code></td>
<td>
<p>optional discount parameters both of which take values from <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, only one should be
set at one time</p>
</td></tr>
<tr><td><code id="b1nodematch-ergmTerm_+3A_byb2attr">byb2attr</code></td>
<td>
<p>specifies a
second mode categorical attribute. Setting this argument
will separate the orginal statistics based on the values of the set second mode attribute&mdash;
i.e. for example, if <code>diff</code> is <code>FALSE</code> , then the sum of all the statistics for
each level of this second-mode attribute will be equal to the original <code>b1nodematch</code>
statistic where <code>byb2attr</code> set to <code>NULL</code> .</p>
</td></tr>
<tr><td><code id="b1nodematch-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>select a subset of <code>attr</code> values to include. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an <code>alpha</code>
discount parameter is used, each of these statistics gives the sum of
the number of common second-mode nodes raised to the power <code>alpha</code> for each pair of
first-mode nodes with that attribute. If a <code>beta</code> discount parameter is used, each
of these statistics gives half the sum of the number of two-paths with two first-mode nodes
with that attribute as the two ends of the two path raised to the power <code>beta</code> for each
edge in the network.
</p>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>
<p>The argument <code>keep</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>keep</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>keep</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, dyad-independent, frequently-used, undirected, binary</p>


<hr>
<h2 id='b1sociality-ergmTerm'>Degree</h2><span id='topic+b1sociality-ergmTerm'></span><span id='topic+InitErgmTerm.b1sociality'></span><span id='topic+InitWtErgmTerm.b1sociality'></span>

<h3>Description</h3>

<p>This term adds one network statistic for each node in the first bipartition, equal to the number of
ties of that node. This term can only be used with bipartite networks. For directed networks, see <code>sender</code> and
<code>receiver</code>. For unipartite networks, see <code>sociality</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1sociality(nodes=-1)

# valued: b1sociality(nodes=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1sociality-ergmTerm_+3A_nodes">nodes</code></td>
<td>
<p>By default, <code>nodes=-1</code> means that the statistic for the
first node (in the second bipartition) will be omitted, but this argument may be changed to control
which statistics are included. The <code>nodes</code> argument is interpreted using the new UI for level specification
(see Specifying Vertex Attributes and Levels (<code>?nodal_attributes</code>) for details), where both the attribute and the sorted
unique values are the vector of vertex indices <code>(nb1 + 1):n</code> , where
<code>nb1</code> is the size of the first bipartition and <code>n</code> is the total number of nodes in the network. Thus <code>nodes=120</code> will include only the statistic
for the 120th node in the second biparition, while <code>nodes=I(120)</code> will include only the statistic for the 120th node in the entire network.</p>
</td></tr>
<tr><td><code id="b1sociality-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, dyad-independent, undirected, binary, valued</p>


<hr>
<h2 id='b1star-ergmTerm'><code class="reqn">k</code>-stars for the first mode in a bipartite network</h2><span id='topic+b1star-ergmTerm'></span><span id='topic+InitErgmTerm.b1star'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>k</code> . The <code class="reqn">i</code> th such statistic counts the number of
distinct <code>k[i]</code> -stars whose center node is in the first mode of the
network. The first mode of a bipartite network object is sometimes known as
the &quot;actor&quot; mode. A <code class="reqn">k</code> -star is defined to be a center node <code class="reqn">N</code> and
a set of <code class="reqn">k</code> different nodes <code class="reqn">\{O_1, \dots, O_k\}</code> such that the
ties <code class="reqn">\{N, O_i\}</code> exist for <code class="reqn">i=1, \dots, k</code>.
This term can only be used for
undirected bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1star(k, attr=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1star-ergmTerm_+3A_k">k</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="b1star-ergmTerm_+3A_attr">attr</code>, <code id="b1star-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a vertex attribute specification; if <code>attr</code> is
specified, then the count is over the instances where all nodes
involved have the same value of the attribute. <code>levels</code> specified
which values of <code>attr</code> are included in the count. (See Specifying
Vertex attributes and Levels
(<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>b1star(1)</code> is equal to <code>b2star(1)</code> and to <code>edges</code> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='b1starmix-ergmTerm'>Mixing matrix for <code class="reqn">k</code>-stars centered on the first mode of a bipartite network</h2><span id='topic+b1starmix-ergmTerm'></span><span id='topic+InitErgmTerm.b1starmix'></span>

<h3>Description</h3>

<p>This term counts all <code class="reqn">k</code>-stars in which
the b2 nodes (called events in some contexts) are homophilous in the sense
that they all share the same value of <code>attr</code> . However, the b1 node
(in some contexts, the actor) at the center of the <code class="reqn">k</code>-star does NOT have to
have the same value as the b2 nodes; indeed, the values taken by the b1
nodes may be completely distinct from those of the b2 nodes, which allows
for the use of this term in cases where there are two separate nodal
attributes, one for the b1 nodes and another for the b2 nodes (in this case,
however, these two attributes should be combined to form a single nodal
attribute, <code>attr</code>). A different statistic is created for each
value of <code>attr</code> seen in a b1 node, even if no <code class="reqn">k</code>-stars are observed
with this value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1starmix(k, attr, base=NULL, diff=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1starmix-ergmTerm_+3A_k">k</code></td>
<td>
<p>only a single value of <code class="reqn">k</code> is allowed</p>
</td></tr>
<tr><td><code id="b1starmix-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="b1starmix-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="b1starmix-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>whether a different statistic is created for each value seen in a b2 node. When <code>diff=TRUE</code>,
the default, a different statistic is created for each value and thus the behavior of this term is reminiscent of the
<code>nodemix</code> term, from which it takes its name; when <code>diff=FALSE</code> ,
all homophilous <code class="reqn">k</code>-stars are counted together, though these <code class="reqn">k</code>-stars are still
categorized according to the value of the central b1 node.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='b1twostar-ergmTerm'>Two-star census for central nodes centered on the first mode of a bipartite network</h2><span id='topic+b1twostar-ergmTerm'></span><span id='topic+InitErgmTerm.b1twostar'></span>

<h3>Description</h3>

<p>This term takes two nodal attributes. Assuming that there are
<code class="reqn">n_1</code> values of <code>b1attr</code> among the b1 nodes and <code class="reqn">n_2</code>
values of <code>b2attr</code> among the b2 nodes, then the total number of
distinct categories of two stars according to these two attributes is
<code class="reqn">n_1(n_2)(n_2+1)/2</code>. By default, this model term creates a distinct statistic
counting each of these categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1twostar(b1attr, b2attr, base=NULL, b1levels=NULL, b2levels=NULL, levels2=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1twostar-ergmTerm_+3A_b1attr">b1attr</code></td>
<td>
<p>b1 nodes (actors in some contexts) (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
<tr><td><code id="b1twostar-ergmTerm_+3A_b2attr">b2attr</code></td>
<td>
<p>b2 nodes (events in some contexts). If <code>b2attr</code> is not passed, it is assumed to be the same as <code>b1attr</code> .</p>
</td></tr>
<tr><td><code id="b1twostar-ergmTerm_+3A_b1levels">b1levels</code>, <code id="b1twostar-ergmTerm_+3A_b2levels">b2levels</code>, <code id="b1twostar-ergmTerm_+3A_base">base</code>, <code id="b1twostar-ergmTerm_+3A_levels2">levels2</code></td>
<td>
<p>used to leave some of the categories out (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels2</code> are passed,
<code>levels2</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='b2concurrent-ergmTerm'>Concurrent node count for the second mode in a bipartite network</h2><span id='topic+b2concurrent-ergmTerm'></span><span id='topic+InitErgmTerm.b2concurrent'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model, equal to the number of nodes in the second
mode of the network with degree 2 or higher. The second mode of a bipartite
network object is sometimes known as the &quot;event&quot; mode.
Without the optional argument, this statistic is equivalent to <code>b2mindegree(2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2concurrent(by=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2concurrent-ergmTerm_+3A_by">by</code></td>
<td>
<p>This optional argument specifie a vertex attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details);
it functions just like the <code>by</code> argument of the <code>b2degree</code> term.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, frequently-used, undirected, binary</p>


<hr>
<h2 id='b2cov-ergmTerm'>Main effect of a covariate for the second mode in a bipartite  network</h2><span id='topic+b2cov-ergmTerm'></span><span id='topic+InitErgmTerm.b2cov'></span><span id='topic+InitWtErgmTerm.b2cov'></span>

<h3>Description</h3>

<p>This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total
value of <code>attr(j)</code> for all edges <code class="reqn">(i,j)</code> in the network. This
term may only be used with bipartite networks. For categorical attributes, see <code>b2factor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2cov(attr)

# valued: b2cov(attr, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2cov-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="b2cov-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, dyad-independent, frequently-used, quantitative nodal attribute, undirected, binary, valued</p>


<hr>
<h2 id='b2degrange-ergmTerm'>Degree range for the second mode in a bipartite network</h2><span id='topic+b2degrange-ergmTerm'></span><span id='topic+InitErgmTerm.b2degrange'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element of <code>from</code> (or <code>to</code> ); the <code class="reqn">i</code> th
such statistic equals the number of nodes of the second mode
(&quot;events&quot;) in the network of degree greater than or equal to
<code>from[i]</code> but strictly less than <code>to[i]</code> , i.e. with edge count
in semiopen interval <code style="white-space: pre;">&#8288;[from,to)&#8288;</code> .
</p>
<p>This term can only be used with bipartite networks; for directed networks
see <code>idegrange</code> and <code>odegrange</code> . For undirected networks,
see <code>degrange</code> , and see <code>b1degrange</code>
for degrees of the first mode (&quot;actors&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2degrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2degrange-ergmTerm_+3A_from">from</code>, <code id="b2degrange-ergmTerm_+3A_to">to</code></td>
<td>
<p>vectors of distinct integers. If one of the vectors have length 1, it is recycled to the length of the other. Otherwise, it must have the same length.</p>
</td></tr>
<tr><td><code id="b2degrange-ergmTerm_+3A_by">by</code>, <code id="b2degrange-ergmTerm_+3A_levels">levels</code>, <code id="b2degrange-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='b2degree-ergmTerm'>Degree for the second mode in a bipartite network</h2><span id='topic+b2degree-ergmTerm'></span><span id='topic+InitErgmTerm.b2degree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals the number of
nodes of degree <code>d[i]</code> in the second mode of a bipartite network, i.e.
with exactly <code>d[i]</code> edges. The second mode of a bipartite network
object is sometimes known as the &quot;event&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2degree(d, by=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2degree-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="b2degree-ergmTerm_+3A_by">by</code></td>
<td>
<p>this optional term specifies
a vertex attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details). If this is specified
then each node's degree is tabulated only with other nodes having the same
value of the <code>by</code> attribute.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, frequently-used, undirected, binary</p>


<hr>
<h2 id='b2degrees-ergmConstraint'>Preserve the receiver degree for bipartite networks</h2><span id='topic+b2degrees-ergmConstraint'></span><span id='topic+InitErgmConstraint.b2degrees'></span>

<h3>Description</h3>

<p>For bipartite networks, preserve the degree for the second mode of each vertex of the given
network, while allowing the degree for the first mode to vary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># b2degrees
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite</p>


<hr>
<h2 id='b2dsp-ergmTerm'>Dyadwise shared partners for dyads in the second bipartition</h2><span id='topic+b2dsp-ergmTerm'></span><span id='topic+InitErgmTerm.b2dsp'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each element in <code>d</code> ; the <code class="reqn">i</code> th
such statistic equals the number of dyads in the second bipartition with exactly
<code>d[i]</code> shared partners. (Those shared partners, of course, must be members
of the first bipartition.) This term can only be used with bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2dsp(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2dsp-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='b2factor-ergmTerm'>Factor attribute effect for the second mode in a bipartite network</h2><span id='topic+b2factor-ergmTerm'></span><span id='topic+InitErgmTerm.b2factor'></span><span id='topic+InitWtErgmTerm.b2factor'></span>

<h3>Description</h3>

<p>This term adds multiple network statistics to the model, one for each of (a subset of) the
unique values of the <code>attr</code> attribute. Each of these statistics
gives the number of times a node with that attribute in the second mode of
the network appears in an edge. The second mode of a bipartite network
object is sometimes known as the &quot;event&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2factor(attr, base=1, levels=-1)

# valued: b2factor(attr, base=1, levels=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2factor-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="b2factor-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="b2factor-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>this optional argument controls which levels of the attribute
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="b2factor-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To include all attribute values is usually not a good idea, because
the sum of all such statistics equals the number of edges and hence a linear
dependency would arise in any model also including <code>edges</code>. The default,
<code>levels=-1</code>, is therefore to omit the first (in lexicographic order)
attribute level. To include all levels, pass either <code>levels=TRUE</code>
(i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>
<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, dyad-independent, frequently-used, undirected, binary, valued</p>


<hr>
<h2 id='b2mindegree-ergmTerm'>Minimum degree for the second mode in a bipartite network</h2><span id='topic+b2mindegree-ergmTerm'></span><span id='topic+InitErgmTerm.b2mindegree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals the number of
nodes in the second mode of a bipartite network with at least degree <code>d[i]</code> .
The second mode of a bipartite network object is sometimes known as the &quot;event&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2mindegree(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2mindegree-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='b2nodematch-ergmTerm'>Nodal attribute-based homophily effect for the second mode in a bipartite network</h2><span id='topic+b2nodematch-ergmTerm'></span><span id='topic+InitErgmTerm.b2nodematch'></span>

<h3>Description</h3>

<p>This term is introduced in Bomiriya et al (2014).
With the default <code>alpha</code> and <code>beta</code> values, this term will
simply be a homophily based two-star statistic. This term adds one statistic to the model
unless <code>diff</code> is set to <code>TRUE</code> , in which case the term adds multiple network
statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code>
attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2nodematch(attr, diff=FALSE, keep=NULL, alpha=1, beta=1, byb1attr=NULL,
#                     levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2nodematch-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>by default, one statistic will be added to the model. If <code>diff</code> is set to <code>TRUE</code>, one statistic will be added for each unique value of the <code>attr</code> attribute</p>
</td></tr>
<tr><td><code id="b2nodematch-ergmTerm_+3A_keep">keep</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="b2nodematch-ergmTerm_+3A_alpha">alpha</code>, <code id="b2nodematch-ergmTerm_+3A_beta">beta</code></td>
<td>
<p>optional discount parameters both of which take values from <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, only one should be
set at one time</p>
</td></tr>
<tr><td><code id="b2nodematch-ergmTerm_+3A_byb2attr">byb2attr</code></td>
<td>
<p>specifies a
second mode categorical attribute. Setting this argument
will separate the orginal statistics based on the values of the set second mode attribute&mdash;
i.e. for example, if <code>diff</code> is <code>FALSE</code> , then the sum of all the statistics for
each level of this second-mode attribute will be equal to the original <code>b1nodematch</code>
statistic where <code>byb2attr</code> set to <code>NULL</code> .</p>
</td></tr>
<tr><td><code id="b2nodematch-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>select a subset of <code>attr</code> values to include. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="b2nodematch-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an <code>alpha</code>
discount parameter is used, each of these statistics gives the sum of
the number of common first-mode nodes raised to the power <code>alpha</code> for each pair of
second-mode nodes with that attribute. If a <code>beta</code> discount parameter is used, each
of these statistics gives half the sum of the number of two-paths with two second-mode nodes
with that attribute as the two ends of the two path raised to the power <code>beta</code> for each
edge in the network.
</p>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>
<p>The argument <code>keep</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>keep</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>keep</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, dyad-independent, frequently-used, undirected, binary</p>


<hr>
<h2 id='b2sociality-ergmTerm'>Degree</h2><span id='topic+b2sociality-ergmTerm'></span><span id='topic+InitErgmTerm.b2sociality'></span><span id='topic+InitWtErgmTerm.b2sociality'></span>

<h3>Description</h3>

<p>This term adds one network statistic for each node in the second bipartition, equal to the number of
ties of that node. For directed networks, see <code>sender</code> and
<code>receiver</code> . For unipartite networks, see <code>sociality</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2sociality(nodes=-1)

# valued: b2sociality(nodes=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2sociality-ergmTerm_+3A_nodes">nodes</code></td>
<td>
<p>By default, <code>nodes=-1</code> means that the statistic for the
first node (in the second bipartition) will be omitted, but this argument may be changed to control
which statistics are included. The <code>nodes</code> argument is interpreted using the new UI for level specification
(see Specifying Vertex Attributes and Levels (<code>?nodal_attributes</code>) for details), where both the attribute and the sorted
unique values are the vector of vertex indices <code>(nb1 + 1):n</code> , where
<code>nb1</code> is the size of the first bipartition and <code>n</code> is the total number of nodes in the network. Thus <code>nodes=120</code> will include only the statistic
for the 120th node in the second biparition, while <code>nodes=I(120)</code> will include only the statistic for the 120th node in the entire network.</p>
</td></tr>
<tr><td><code id="b2sociality-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with undirected bipartite networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, dyad-independent, undirected, binary, valued</p>


<hr>
<h2 id='b2star-ergmTerm'><code class="reqn">k</code>-stars for the second mode in a bipartite network</h2><span id='topic+b2star-ergmTerm'></span><span id='topic+InitErgmTerm.b2star'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>k</code> . The <code class="reqn">i</code> th such statistic counts the number of
distinct <code>k[i]</code> -stars whose center node is in the second mode of the
network. The second mode of a bipartite network object is sometimes known as
the &quot;event&quot; mode. A <code class="reqn">k</code> -star is defined to be a center node <code class="reqn">N</code> and
a set of <code class="reqn">k</code> different nodes <code class="reqn">\{O_1, \dots, O_k\}</code> such that the
ties <code class="reqn">\{N, O_i\}</code> exist for <code class="reqn">i=1, \dots, k</code> . This term can only be used for
undirected bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2star(k, attr=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2star-ergmTerm_+3A_k">k</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="b2star-ergmTerm_+3A_attr">attr</code>, <code id="b2star-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a vertex attribute specification; if <code>attr</code> is
specified, then the count is over the instances where all nodes
involved have the same value of the attribute. <code>levels</code> specified
which values of <code>attr</code> are included in the count. (See Specifying
Vertex attributes and Levels
(<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>b2star(1)</code> is equal to <code>b1star(1)</code> and to <code>edges</code> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='b2starmix-ergmTerm'>Mixing matrix for <code class="reqn">k</code>-stars centered on the second mode of a bipartite network</h2><span id='topic+b2starmix-ergmTerm'></span><span id='topic+InitErgmTerm.b2starmix'></span>

<h3>Description</h3>

<p>This term is exactly the same as <code>b1starmix</code> except that the roles of
b1 and b2 are reversed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2starmix(k, attr, base=NULL, diff=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2starmix-ergmTerm_+3A_k">k</code></td>
<td>
<p>only a single value of <code class="reqn">k</code> is allowed</p>
</td></tr>
<tr><td><code id="b2starmix-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="b2starmix-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="b2starmix-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>whether a different statistic is created for each value seen in a b1 node. When <code>diff=TRUE</code>,
the default, a different statistic is created for each value and thus the behavior of this term is reminiscent of the
<code>nodemix</code> term, from which it takes its name; when <code>diff=FALSE</code> ,
all homophilous <code class="reqn">k</code>-stars are counted together, though these <code class="reqn">k</code>-stars are still
categorized according to the value of the central b1 node.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='b2twostar-ergmTerm'>Two-star census for central nodes centered on the second mode of a bipartite network</h2><span id='topic+b2twostar-ergmTerm'></span><span id='topic+InitErgmTerm.b2twostar'></span>

<h3>Description</h3>

<p>This term is exactly the same as <code>b1twostar</code> except that the
roles of b1 and b2 are reversed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2twostar(b1attr, b2attr, base=NULL, b1levels=NULL, b2levels=NULL, levels2=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2twostar-ergmTerm_+3A_b1attr">b1attr</code></td>
<td>
<p>b1 nodes (actors in some contexts) (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
<tr><td><code id="b2twostar-ergmTerm_+3A_b2attr">b2attr</code></td>
<td>
<p>b2 nodes (events in some contexts). If <code>b1attr</code> is not passed, it is assumed to be the same as <code>b2attr</code> .</p>
</td></tr>
<tr><td><code id="b2twostar-ergmTerm_+3A_b1levels">b1levels</code>, <code id="b2twostar-ergmTerm_+3A_b2levels">b2levels</code>, <code id="b2twostar-ergmTerm_+3A_base">base</code>, <code id="b2twostar-ergmTerm_+3A_levels2">levels2</code></td>
<td>
<p>used to leave some of the categories out (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels2</code> are passed,
<code>levels2</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='balance-ergmTerm'>Balanced triads</h2><span id='topic+balance-ergmTerm'></span><span id='topic+InitErgmTerm.balance'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the number of
triads in the network that are balanced. The balanced triads are those of
type <code>102</code> or <code>300</code> in the categorization of Davis and Leinhardt (1972). For details on the 16 possible triad types, see
<code>?triad.classify</code> in the <code>{sna}</code> package. For an undirected
network, the balanced triads are those with an odd number of ties (i.e., 1
and 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: balance
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, undirected, binary</p>


<hr>
<h2 id='bd-ergmConstraint'>Constrain maximum and minimum vertex degree</h2><span id='topic+bd-ergmConstraint'></span><span id='topic+InitErgmConstraint.bd'></span>

<h3>Description</h3>

<p>Condition on the number of inedge or outedges posessed by a node.
See Placing Bounds on Degrees section for more information. (<code><a href="#topic+ergmConstraint">?ergmConstraint</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'># bd(attribs, maxout, maxin, minout, minin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bd-ergmConstraint_+3A_attribs">attribs</code></td>
<td>
<p>a matrix of logicals with dimension <code style="white-space: pre;">&#8288;(n_nodes, attrcount)&#8288;</code> for the attributes on which we are
conditioning, where <code>attrcount</code> is the number of distinct attributes values to condition on.</p>
</td></tr>
<tr><td><code id="bd-ergmConstraint_+3A_maxout">maxout</code>, <code id="bd-ergmConstraint_+3A_maxin">maxin</code>, <code id="bd-ergmConstraint_+3A_minout">minout</code>, <code id="bd-ergmConstraint_+3A_minin">minin</code></td>
<td>
<p>matrices of alter attributes with the same dimension as <code>attribs</code> when used
in conjunction with <code>attribs</code>. Otherwise, vectors of integers specifying the relevant limits.
If the vector is of length 1, the limit is applied to all nodes. If an individual entry is <code>NA</code>,
then there is no restriction of that kind is applied. For undirected networks (bipartite and not) use <code>minout</code> and <code>maxout</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected</p>


<hr>
<h2 id='BDStratTNT-ergmProposal'>TNT proposal with degree bounds, stratification, and a blocks constraint</h2><span id='topic+BDStratTNT-ergmProposal'></span><span id='topic+InitErgmProposal.BDStratTNT'></span>

<h3>Description</h3>

<p>Implements a TNT proposal with any subset of the following features:
</p>

<ol>
<li><p> upper bounds on degree, specified via the <code><a href="#topic+bd-ergmConstraint">bd</a></code>
constraint's <code>maxout</code>, <code>maxin</code>, and <code>attribs</code> arguments;
</p>
</li>
<li><p> stratification of proposals according to mixing type on a vertex attribute,
specified via the <code><a href="#topic+strat-ergmHint">strat</a></code> hint;
</p>
</li>
<li><p> fixation of specified mixing types on a(nother) vertex attribute, specified
via the <code><a href="#topic+blocks-ergmConstraint">blocks</a></code> constraint.
</p>
</li></ol>



<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='Bernoulli-ergmReference'>Bernoulli reference</h2><span id='topic+Bernoulli-ergmReference'></span><span id='topic+InitErgmReference.Bernoulli'></span>

<h3>Description</h3>

<p>Specifies each
dyad's baseline distribution to be Bernoulli with probability of
the tie being <code class="reqn">0.5</code> . This is the only reference measure used
in binary mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Bernoulli
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmReference">ergmReference</a></code> for index of reference distributions currently visible to the package.
</p>


<h4>Keywords</h4>

<p>binary, discrete, finite, nonnegative</p>


<hr>
<h2 id='blockdiag-ergmConstraint'>Block-diagonal structure constraint</h2><span id='topic+blockdiag-ergmConstraint'></span><span id='topic+InitErgmConstraint.blockdiag'></span>

<h3>Description</h3>

<p>Force a block-diagonal structure (and its bipartite analogue) on
the network. Only dyads <code class="reqn">(i,j)</code> for which
<code>attr(i)==attr(j)</code> can have edges.
</p>
<p>Note that the current implementation requires that blocks be
contiguous for unipartite graphs, and for bipartite
graphs, they must be contiguous within a partition and must have
the same ordering in both partitions. (They do not, however,
require that all blocks be represented in both partitions, but
those that overlap must have the same order.)
</p>
<p>If multiple block-diagonal constraints are given, or if
<code>attr</code> is a vector with multiple attribute names, blocks
will be constructed on all attributes matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># blockdiag(attr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockdiag-ergmConstraint_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected</p>


<hr>
<h2 id='blocks-ergmConstraint'>Constrain blocks of dyads defined by mixing type on a vertex attribute.</h2><span id='topic+blocks-ergmConstraint'></span><span id='topic+InitErgmConstraint.blocks'></span>

<h3>Description</h3>

<p>Any dyad whose toggle would produce a nonzero change statistic
for a <code>nodemix</code> term with the same arguments will be fixed. Note
that the <code>levels2</code> argument has a different default value for
<code>blocks</code> than it does for <code>nodemix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># blocks(attr=NULL, levels=NULL, levels2=FALSE, b1levels=NULL, b2levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocks-ergmConstraint_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="blocks-ergmConstraint_+3A_b1levels">b1levels</code>, <code id="blocks-ergmConstraint_+3A_b2levels">b2levels</code>, <code id="blocks-ergmConstraint_+3A_levels">levels</code>, <code id="blocks-ergmConstraint_+3A_level2">level2</code></td>
<td>
<p>control what mixing types are fixed.
<code>levels2</code> applies to all networks; <code>levels</code> applies to unipartite networks;
<code>b1levels</code> and <code>b2levels</code> apply to bipartite networks (see Specifying Vertex
attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected</p>


<hr>
<h2 id='call.ErgmTerm'>Locate and call an ERGM term initialization function.</h2><span id='topic+call.ErgmTerm'></span>

<h3>Description</h3>

<p>A helper function that searches attached and loaded packages for a
term with a specifies name, calls it with the specified arguments,
and returns the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call.ErgmTerm(term, env, nw, ..., term.options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call.ErgmTerm_+3A_term">term</code></td>
<td>
<p>A term from an <code><a href="#topic+ergm">ergm()</a></code> formula: typically a <code><a href="base.html#topic+name">name</a></code> or a
<code><a href="base.html#topic+call">call</a></code>.</p>
</td></tr>
<tr><td><code id="call.ErgmTerm_+3A_env">env</code></td>
<td>
<p>Environment in which it is to be evaluated.</p>
</td></tr>
<tr><td><code id="call.ErgmTerm_+3A_nw">nw</code></td>
<td>
<p>A <code><a href="network.html#topic+network">network</a></code> object.</p>
</td></tr>
<tr><td><code id="call.ErgmTerm_+3A_...">...</code></td>
<td>
<p>Additional term options.</p>
</td></tr>
<tr><td><code id="call.ErgmTerm_+3A_term.options">term.options</code></td>
<td>
<p>A list of optional settings such as calculation
tuning options to be passed to the <code>InitErgmTerm</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list returned by the the <code>InitErgmTerm</code> or
<code>InitWtErgmTerm</code> function, with package name autodetected if
neede.
</p>

<hr>
<h2 id='check.ErgmTerm'>Ensures an Ergm Term and its Arguments Meet Appropriate Conditions</h2><span id='topic+check.ErgmTerm'></span>

<h3>Description</h3>

<p>Helper functions for implementing <code><a href="#topic+ergm">ergm()</a></code>
terms, to check whether the term can be used with the specified
network.  For information on ergm terms, see
<a href="#topic+ergmTerm">ergmTerm</a>. <code>ergm.checkargs</code>,
<code>ergm.checkbipartite</code>, and <code>ergm.checkderected</code> are
helper functions for an old API and are deprecated. Use
<code>check.ErgmTerm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.ErgmTerm(
  nw,
  arglist,
  directed = NULL,
  bipartite = NULL,
  nonnegative = FALSE,
  varnames = NULL,
  vartypes = NULL,
  defaultvalues = list(),
  required = NULL,
  dep.inform = rep(FALSE, length(required)),
  dep.warn = rep(FALSE, length(required)),
  argexpr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.ErgmTerm_+3A_nw">nw</code></td>
<td>
<p>the network that term X is being checked against</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_arglist">arglist</code></td>
<td>
<p>the list of arguments for term X</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_directed">directed</code></td>
<td>
<p>logical, whether term X requires a directed
network; default=NULL</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_bipartite">bipartite</code></td>
<td>
<p>whether term X requires a bipartite network (T or
F); default=NULL</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_nonnegative">nonnegative</code></td>
<td>
<p>whether term X requires a network with only
nonnegative weights; default=FALSE</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_varnames">varnames</code></td>
<td>
<p>the vector of names of the possible arguments for
term X; default=NULL</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_vartypes">vartypes</code></td>
<td>
<p>the vector of types of the possible arguments for
term X, separated by commas; an empty string (<code>""</code>) or <code>NA</code>
disables the check for that argument, and also see Details;
default=NULL</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_defaultvalues">defaultvalues</code></td>
<td>
<p>the list of default values for the possible
arguments of term X; default=list()</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_required">required</code></td>
<td>
<p>the logical vector of whether each possible
argument is required; default=NULL</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_dep.inform">dep.inform</code>, <code id="check.ErgmTerm_+3A_dep.warn">dep.warn</code></td>
<td>
<p>a list of length equal to the number of
arguments the term can take; if the corresponding element of the
list is not <code>FALSE</code>, a <code><a href="base.html#topic+message">message()</a></code> or a <code><a href="base.html#topic+warning">warning()</a></code> respectively
will be issued if the user tries to pass it; if the element is a
character string, it will be used as a suggestion for
replacement.</p>
</td></tr>
<tr><td><code id="check.ErgmTerm_+3A_argexpr">argexpr</code></td>
<td>
<p>optional call typically obtained by calling
<code>substitute(arglist)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>check.ErgmTerm</code> function ensures for the
<code><a href="#topic+InitErgmTerm">InitErgmTerm</a>.X</code> function that the term X: </p>

<ul>
<li><p> is applicable given the 'directed' and 'bipartite' attributes
of the given network </p>
</li>
<li><p> is not applied to a directed bipartite
network </p>
</li>
<li><p> has an appropiate number of arguments </p>
</li>
<li><p> has
correct argument types if arguments where provided </p>
</li>
<li><p> has
default values assigned if defaults are available </p>
</li></ul>
<p> by halting
execution if any of the first 3 criteria are not met.
</p>
<p>As a convenience, if an argument is optional <em>and</em> its
default is <code>NULL</code>, then <code>NULL</code> is assumed to be an acceptable
argument type as well.
</p>


<h3>Value</h3>

<p>A list of the values for each possible argument of term X;
user provided values are used when given, default values
otherwise. The list also has an <code>attr(,"missing")</code> attribute
containing a named logical vector indicating whether a particular
argument had been set to its default. If <code style="white-space: pre;">&#8288;argexpr=&#8288;</code> argument is
provided, <code>attr(,"exprs")</code> attribute is also returned, containing
expressions.
</p>

<hr>
<h2 id='cohab'>Target statistics and model fit to a hypothetical 50,000-node network population with
50,000 nodes based on egocent</h2><span id='topic+cohab'></span><span id='topic+cohab_MixMat'></span><span id='topic+cohab_PopWts'></span><span id='topic+cohab_TargetStats'></span>

<h3>Description</h3>

<p>This dataset consists of three objects, each based on data from King County,
Washington, USA (where Seattle is located) derived from the National Survey
of Family Growth (NSFG) (<a href="https://www.cdc.gov/nchs/nsfg/index.htm">https://www.cdc.gov/nchs/nsfg/index.htm</a>).
The full dataset cannot be released publicly, so some aspects of these objects
are simulated based on the real data.
These objects may be used to illustrate that network modeling may be performed
using data that are collected on egos only, i.e., without directly observing
information about alters in a network except for information reported from egos.
The hypothetical population reepresented by this dataset consists of only a subset
of individuals, as categorized by their age, race / ethnicity / immigration status,
and gender and sexual identity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cohab)
</code></pre>


<h3>Details</h3>

<p>The three objects are
</p>

<dl>
<dt>cohab_MixMat</dt><dd><p>Mixing matrix on 'race'.  Based on ego reports of the
race / ethnicity / immigration status
of their cohabiting partners, this matrix gives counts of ego-alter ties by the race of each
individual for a hypothetical population.
These counts are based on the
NSFG mixing matrix.  Only five categories of the 'race' variable are included here:
Black, Black immigrant, Hispanic, Hispanic immigrant, and White. </p>
</dd>
<dt>cohab_PopWts</dt><dd><p>Data frame of demographic characteristics together with relative
counts (weights) in a hypothetical population.
Individuals are classified according to five variables:  age in years,
race (same five categories of race / ethnicity / immigration status as above),
sex (Male or Female),
sexual identity (Female, Male who has sex with Females, or Male who has sex with
Males or Females), and number of model-predicted persistent partnerships with non-cohabiting
partners (0 or 1, where 1 means any nonzero value; the number is capped at 3),
and number of partners (0 or 1).</p>
</dd>
<dt>cohab_TargetStats</dt><dd><p>Vector of target (expected) statistics for a 15-term ERGM applied
to a network of 50,000 nodes in which a tie represents a cohabitation relationship between
two nodes.  It is assumed for the purposes of these statistics that only male-female
cohabitation relationships are allowed and that no individual may have such a relationship
with more than one person.  That is, each node must have degree zero or one.  The ergm formula
is: <code>~ edges + nodefactor("sex.ident", levels = 3) + nodecov("age") + nodecov("agesq") + nodefactor("race", levels = -5) + nodefactor("othr.net.deg", levels = -1) + nodematch("race", diff = TRUE) + absdiff("sqrt.age.adj")</code>
</p>
</dd>
</dl>



<h3>References</h3>

<p>Krivitsky, P.N., Hunter, D.R., Morris, M., and Klumb, C. (2021).
<em>ergm 4.0: New Features and Improvements</em>. arXiv
</p>
<p>National Center for Health Statistics (NCHS). (2020). 2006-2015 National
Survey of Family Growth Public-Use Data and Documentation. Hyattsville, MD:
CDC National Center for Health Statistics.
Retrieved from <a href="https://www.cdc.gov/nchs/nsfg/index.htm">https://www.cdc.gov/nchs/nsfg/index.htm</a>
</p>


<h3>See Also</h3>

<p>ergm
</p>

<hr>
<h2 id='coincidence-ergmTerm'>Coincident node count for the second mode in a bipartite (aka two-mode) network</h2><span id='topic+coincidence-ergmTerm'></span><span id='topic+InitErgmTerm.coincidence'></span>

<h3>Description</h3>

<p>By default this term adds one
network statistic to the model for each pair of nodes of mode two. It is
equal to the number of (first mode) mutual partners of that pair.
The first mode of a bipartite
network object is sometimes known as the &quot;actor&quot; mode and the seconds as the &quot;event&quot; mode. So this is the number of actors going to both events in the pair. This term can only be
used with undirected bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: coincidence(levels=NULL,active=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coincidence-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>specifies which pairs of nodes in mode two to include. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="coincidence-ergmTerm_+3A_active">active</code></td>
<td>
<p>selects pairs for which the observed count is at least <code>active</code> . Ignored if <code>levels</code> is
specified. (Thus, indices passed as <code>levels</code> should correspond to indices when <code>levels</code> = NULL and <code>active</code> = 0.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='concurrent-ergmTerm'>Concurrent node count</h2><span id='topic+concurrent-ergmTerm'></span><span id='topic+InitErgmTerm.concurrent'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model, equal to the number of
nodes in the network with degree 2 or higher.
This term can only be used with undirected
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: concurrent(by=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concurrent-ergmTerm_+3A_by">by</code></td>
<td>
<p>this optional argument specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)
It functions just like the <code>by</code> argument of the <code>degree</code> term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='concurrentties-ergmTerm'>Concurrent tie count</h2><span id='topic+concurrentties-ergmTerm'></span><span id='topic+InitErgmTerm.concurrentties'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model, equal to the number of
ties incident on each actor beyond the first.
This term can only be used with undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: concurrentties(by=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concurrentties-ergmTerm_+3A_by">by</code></td>
<td>
<p>a vertex attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.);
it functions just like the <code>by</code> argument of the <code>degree</code> term</p>
</td></tr>
<tr><td><code id="concurrentties-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='CondB1Degree-ergmProposal'>MHp for b1degree constraints</h2><span id='topic+CondB1Degree-ergmProposal'></span><span id='topic+InitErgmProposal.CondB1Degree'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~b1degrees</code>. For bipartite networks, randomly select an edge <code class="reqn">(B_{1i},B_{2j})</code>
and an empty dyad with the same node B1i, <code class="reqn">(B_{1i},B_{2k})</code>, and propose to toggle both <code class="reqn">(B_{1i},B_{2j})</code> and <code class="reqn">(B_{1i},B_{2k})</code>.
This ensures that the degrees of individual nodes in mode 1 are preserved.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondB2Degree-ergmProposal'>MHp for b2degree constraints</h2><span id='topic+CondB2Degree-ergmProposal'></span><span id='topic+InitErgmProposal.CondB2Degree'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~b2degrees</code>. For bipartite networks, randomly select an edge <code class="reqn">(B_{1j},B_{2i})</code>
and an empty dyad with the same node B2i, <code class="reqn">(B_{1k},B_{2i})</code>, and propose to toggle both <code class="reqn">(B_{1j},B_{2i})</code> and <code class="reqn">(B_{1k},B_{2i})</code>.
This ensures that the degrees of individual nodes in mode 2 are preserved.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondDegree-ergmProposal'>MHp for degree constraints</h2><span id='topic+CondDegree-ergmProposal'></span><span id='topic+InitErgmProposal.CondDegree'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~degree</code>. Propose either 4 toggles (MH_CondDegreeTetrad) or 6 toggles
(MH_CondDegreeHexad) at once. For undirected networks, propose 4 toggles (MH_CondDegreeTetrad).
MH_CondDegreeTetrad selects two edges with no nodes in common, A1-A2 and B1-B2, s.t. A1-B2 and B1-A2 are
not edges, and propose to replace the former two by the latter two. MH_CondDegreeHexad selects three edges
A1-&gt;A2, B1-&gt;B2, C1-&gt;C2 at random and rotate them to A1-&gt;B2, B1-&gt;C2, and C1-&gt;A2.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondDegreeDist-ergmProposal'>MHp for degreedist constraints</h2><span id='topic+CondDegreeDist-ergmProposal'></span><span id='topic+InitErgmProposal.CondDegreeDist'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~degreedist</code>. Randomly select a node (T) and its edge (E).  If the head
node of the edge (H) has 1 degree more than another randomly select node (A), and A is disconnected to both
T and H, then propose to toggle E and the dyad between T and A.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondDegreeMix-ergmProposal'>MHp for degree mix constraints</h2><span id='topic+CondDegreeMix-ergmProposal'></span><span id='topic+InitErgmProposal.CondDegreeMix'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~degreesmix</code>. Similar to <code>InitErgmProposal.CondDegree</code>, except that
the toggle is proposed only if the mixing matrix of degrees is preserved before and after the toggle.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondInDegree-ergmProposal'>MHp for idegree constraints</h2><span id='topic+CondInDegree-ergmProposal'></span><span id='topic+InitErgmProposal.CondInDegree'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~idegrees</code>. For directed networks, randomly select two dyads with a
common head node, one having an edge one not, and propose to swap the tie from one tail to the other.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondInDegreeDist-ergmProposal'>MHp for idegreedist constraints</h2><span id='topic+CondInDegreeDist-ergmProposal'></span><span id='topic+InitErgmProposal.CondInDegreeDist'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~idegreedist</code>. For directed networks, similar to
<code>InitErgmProposal.CondDegreeDist</code>, except for indegree case
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondOutDegree-ergmProposal'>MHp for odegree constraints</h2><span id='topic+CondOutDegree-ergmProposal'></span><span id='topic+InitErgmProposal.CondOutDegree'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~odegrees</code>. For directed networks, randomly select two dyads with a
common tail node, one having an edge and one not, and propose to swap the tie from one head to the other.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CondOutDegreeDist-ergmProposal'>MHp for odegreedist constraints</h2><span id='topic+CondOutDegreeDist-ergmProposal'></span><span id='topic+InitErgmProposal.CondOutDegreeDist'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~odegreedist</code>. For directed networks, similar to
<code>InitErgmProposal.CondDegreeDist</code>, except for outdegree case
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='ConstantEdges-ergmProposal'>MHp for edges constraints</h2><span id='topic+ConstantEdges-ergmProposal'></span><span id='topic+InitErgmProposal.ConstantEdges'></span>

<h3>Description</h3>

<p>MHp for <code>constraints= ~edges</code>. Propose pairs of toggles that keep number of edges the same.
This is done by:
</p>

<ol>
<li><p> choosing an existing edge at random;
</p>
</li>
<li><p> choosing a dyad at random that does not have an edge; and
</p>
</li>
<li><p> proposing toggling both these dyads.
</p>
</li></ol>



<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='control.ergm'>Auxiliary for Controlling ERGM Fitting</h2><span id='topic+control.ergm'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning 'ergm' fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.ergm(
  drop = TRUE,
  init = NULL,
  init.method = NULL,
  main.method = c("MCMLE", "Stochastic-Approximation"),
  force.main = FALSE,
  main.hessian = TRUE,
  checkpoint = NULL,
  resume = NULL,
  MPLE.samplesize = .Machine$integer.max,
  init.MPLE.samplesize = function(d, e) max(sqrt(d), e, 40) * 8,
  MPLE.type = c("glm", "penalized", "logitreg"),
  MPLE.maxit = 10000,
  MPLE.nonvar = c("warning", "message", "error"),
  MPLE.nonident = c("warning", "message", "error"),
  MPLE.nonident.tol = 1e-10,
  MPLE.covariance.samplesize = 500,
  MPLE.covariance.method = "invHess",
  MPLE.covariance.sim.burnin = 1024,
  MPLE.covariance.sim.interval = 1024,
  MPLE.constraints.ignore = FALSE,
  MCMC.prop = trim_env(~sparse),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.interval = NULL,
  MCMC.burnin = EVL(MCMC.interval * 16),
  MCMC.samplesize = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 16,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 32,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.return.stats = 2^12,
  MCMC.runtime.traceplot = FALSE,
  MCMC.maxedges = Inf,
  MCMC.addto.se = TRUE,
  MCMC.packagenames = c(),
  SAN.maxit = 4,
  SAN.nsteps.times = 8,
  SAN = control.san(term.options = term.options, SAN.maxit = SAN.maxit, SAN.prop.weights
    = MCMC.prop.weights, SAN.prop.args = MCMC.prop.args, SAN.nsteps = EVL(MCMC.burnin,
    16384) * SAN.nsteps.times, SAN.samplesize = EVL(MCMC.samplesize, 1024),
    SAN.packagenames = MCMC.packagenames, parallel = parallel, parallel.type =
    parallel.type, parallel.version.check = parallel.version.check),
  MCMLE.termination = c("confidence", "Hummel", "Hotelling", "precision", "none"),
  MCMLE.maxit = 60,
  MCMLE.conv.min.pval = 0.5,
  MCMLE.confidence = 0.99,
  MCMLE.confidence.boost = 2,
  MCMLE.confidence.boost.threshold = 1,
  MCMLE.confidence.boost.lag = 4,
  MCMLE.NR.maxit = 100,
  MCMLE.NR.reltol = sqrt(.Machine$double.eps),
  obs.MCMC.mul = 1/4,
  obs.MCMC.samplesize.mul = sqrt(obs.MCMC.mul),
  obs.MCMC.samplesize = EVL(round(MCMC.samplesize * obs.MCMC.samplesize.mul)),
  obs.MCMC.effectiveSize = NVL3(MCMC.effectiveSize, . * obs.MCMC.mul),
  obs.MCMC.interval.mul = sqrt(obs.MCMC.mul),
  obs.MCMC.interval = EVL(round(MCMC.interval * obs.MCMC.interval.mul)),
  obs.MCMC.burnin.mul = sqrt(obs.MCMC.mul),
  obs.MCMC.burnin = EVL(round(MCMC.burnin * obs.MCMC.burnin.mul)),
  obs.MCMC.prop = MCMC.prop,
  obs.MCMC.prop.weights = MCMC.prop.weights,
  obs.MCMC.prop.args = MCMC.prop.args,
  obs.MCMC.impute.min_informative = function(nw) network.size(nw)/4,
  obs.MCMC.impute.default_density = function(nw) 2/network.size(nw),
  MCMLE.min.depfac = 2,
  MCMLE.sampsize.boost.pow = 0.5,
  MCMLE.MCMC.precision = if (startsWith("confidence", MCMLE.termination[1])) 0.1 else
    0.005,
  MCMLE.MCMC.max.ESS.frac = 0.1,
  MCMLE.metric = c("lognormal", "logtaylor", "Median.Likelihood", "EF.Likelihood",
    "naive"),
  MCMLE.method = c("BFGS", "Nelder-Mead"),
  MCMLE.dampening = FALSE,
  MCMLE.dampening.min.ess = 20,
  MCMLE.dampening.level = 0.1,
  MCMLE.steplength.margin = 0.05,
  MCMLE.steplength = NVL2(MCMLE.steplength.margin, 1, 0.5),
  MCMLE.steplength.parallel = c("observational", "never"),
  MCMLE.sequential = TRUE,
  MCMLE.density.guard.min = 10000,
  MCMLE.density.guard = exp(3),
  MCMLE.effectiveSize = 64,
  obs.MCMLE.effectiveSize = NVL3(MCMLE.effectiveSize, . * obs.MCMC.mul),
  MCMLE.interval = 1024,
  MCMLE.burnin = MCMLE.interval * 16,
  MCMLE.samplesize.per_theta = 32,
  MCMLE.samplesize.min = 256,
  MCMLE.samplesize = NULL,
  obs.MCMLE.samplesize.per_theta = round(MCMLE.samplesize.per_theta *
    obs.MCMC.samplesize.mul),
  obs.MCMLE.samplesize.min = 256,
  obs.MCMLE.samplesize = NULL,
  obs.MCMLE.interval = round(MCMLE.interval * obs.MCMC.interval.mul),
  obs.MCMLE.burnin = round(MCMLE.burnin * obs.MCMC.burnin.mul),
  MCMLE.steplength.solver = c("glpk", "lpsolve"),
  MCMLE.last.boost = 4,
  MCMLE.steplength.esteq = TRUE,
  MCMLE.steplength.miss.sample = function(x1) ceiling(sqrt(ncol(rbind(x1)))),
  MCMLE.steplength.min = 1e-04,
  MCMLE.effectiveSize.interval_drop = 2,
  MCMLE.save_intermediates = NULL,
  MCMLE.nonvar = c("message", "warning", "error"),
  MCMLE.nonident = c("warning", "message", "error"),
  MCMLE.nonident.tol = 1e-10,
  SA.phase1_n = function(q, ...) max(200, 7 + 3 * q),
  SA.initial_gain = 0.1,
  SA.nsubphases = 4,
  SA.min_iterations = function(q, ...) (7 + q),
  SA.max_iterations = function(q, ...) (207 + q),
  SA.phase3_n = 1000,
  SA.interval = 1024,
  SA.burnin = SA.interval * 16,
  SA.samplesize = 1024,
  CD.samplesize.per_theta = 128,
  obs.CD.samplesize.per_theta = 128,
  CD.nsteps = 8,
  CD.multiplicity = 1,
  CD.nsteps.obs = 128,
  CD.multiplicity.obs = 1,
  CD.maxit = 60,
  CD.conv.min.pval = 0.5,
  CD.NR.maxit = 100,
  CD.NR.reltol = sqrt(.Machine$double.eps),
  CD.metric = c("naive", "lognormal", "logtaylor", "Median.Likelihood", "EF.Likelihood"),
  CD.method = c("BFGS", "Nelder-Mead"),
  CD.dampening = FALSE,
  CD.dampening.min.ess = 20,
  CD.dampening.level = 0.1,
  CD.steplength.margin = 0.5,
  CD.steplength = 1,
  CD.adaptive.epsilon = 0.01,
  CD.steplength.esteq = TRUE,
  CD.steplength.miss.sample = function(x1) ceiling(sqrt(ncol(rbind(x1)))),
  CD.steplength.min = 1e-04,
  CD.steplength.parallel = c("observational", "always", "never"),
  CD.steplength.solver = c("glpk", "lpsolve"),
  loglik = control.logLik.ergm(),
  term.options = NULL,
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.ergm_+3A_drop">drop</code></td>
<td>
<p>Logical: If TRUE, terms whose observed statistic values are at
the extremes of their possible ranges are dropped from the fit and their
corresponding parameter estimates are set to plus or minus infinity, as
appropriate.  This is done because maximum likelihood estimates cannot exist
when the vector of observed statistic lies on the boundary of the convex
hull of possible statistic values.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_init">init</code></td>
<td>
<p>numeric or <code>NA</code> vector equal in length to the number of
parameters in the model or <code>NULL</code> (the default); the initial values for
the estimation and coefficient offset terms. If <code>NULL</code> is passed, all
of the initial values are computed using the method specified by
<code><a href="#topic+control.ergm">control$init.method</a></code>.  If a numeric vector is
given, the elements of the vector are interpreted as follows: </p>

<ul>
<li><p> Elements corresponding to terms enclosed in <code>offset()</code> are used as
the fixed offset coefficients. Note that offset coefficients alone can be
more conveniently specified using <code><a href="#topic+ergm">ergm()</a></code> argument
<code>offset.coef</code>. If both <code>offset.coef</code> and <code>init</code> arguments are
given, values in <code>offset.coef</code> will take precedence.
</p>
</li>
<li><p> Elements that do not correspond to offset terms and are not <code>NA</code>
are used as starting values in the estimation.
</p>
</li>
<li><p> Initial values for the elements that are <code>NA</code> are fit using the
method specified by <code><a href="#topic+control.ergm">control$init.method</a></code>.
</p>
</li></ul>
<p> Passing <code>control.ergm(init=coef(prev.fit))</code> can be used to
&ldquo;resume&rdquo; an uncoverged <code><a href="#topic+ergm">ergm()</a></code> run, though <code>checkpoint</code> and
'resume' would be better under most circumstances.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_init.method">init.method</code></td>
<td>
<p>A chatacter vector or <code>NULL</code>. The default
method depends on the reference measure used. For the binary
(<code>"Bernoulli"</code>) ERGMs, with dyad-independent constraints,
it's maximum pseudo-likelihood estimation (MPLE). Other valid
values include <code>"zeros"</code> for a <code>0</code> vector of
appropriate length and <code>"CD"</code> for contrastive divergence. If
passed explicitly, this setting overrides the reference's
limitations.
</p>
<p>Valid initial methods for a given reference are set by the
<code style="white-space: pre;">&#8288;InitErgmReference.*&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_main.method">main.method</code></td>
<td>
<p>One of &quot;MCMLE&quot; (default) or
&quot;Stochastic-Approximation&quot;.  Chooses the estimation method used
to find the MLE.  <code>MCMLE</code> attempts to maximize an
approximation to the log-likelihood function.
<code>Stochastic-Approximation</code> are both stochastic approximation
algorithms that try to solve the method of moments equation that
yields the MLE in the case of an exponential family model. The
direct use of the likelihood function has many theoretical
advantages over stochastic approximation, but the choice will
depend on the model and data being fit. See Handcock (2000) and
Hunter and Handcock (2006) for details.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_force.main">force.main</code></td>
<td>
<p>Logical: If TRUE, then force MCMC-based estimation method,
even if the exact MLE can be computed via maximum pseudolikelihood
estimation.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_main.hessian">main.hessian</code></td>
<td>
<p>Logical: If TRUE, then an approximate Hessian matrix is
used in the MCMC-based estimation method.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_checkpoint">checkpoint</code></td>
<td>
<p>At the start of every iteration, save the state
of the optimizer in a way that will allow it to be resumed. The
name is passed through <code><a href="base.html#topic+sprintf">sprintf()</a></code> with iteration number as the
second argument. (For example, <code>checkpoint="step_%03d.RData"</code>
will save to <code>step_001.RData</code>, <code>step_002.RData</code>, etc.)</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_resume">resume</code></td>
<td>
<p>If given a file name of an <code>RData</code> file produced by
<code>checkpoint</code>, the optimizer will attempt to resume after
restoring the state. Control parameters from the saved state will
be reused, except for those whose value passed via
<code>control.ergm()</code> had change from the saved run. Note that if the
network, the model, or some critical settings differ between
runs, the results may be undefined.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mple.samplesize">MPLE.samplesize</code>, <code id="control.ergm_+3A_init.mple.samplesize">init.MPLE.samplesize</code></td>
<td>
<p>These parameters control the maximum number of dyads (potential
ties) that will be used by the MPLE to construct the predictor
matrix for its logistic regression. In general, the algorithm
visits dyads in a systematic sample that, if it does not hit one
of these limits, will visit every informative dyad. If a limit is
exceeded, case-control approximation to the likelihood,
comprising all edges and those non-edges that have been visited
by the algorithm before the limit was exceeded will be used.
</p>
<p><code>MPLE.samplesize</code> limits the number of dyads visited, unless the
MPLE is being computed for the purpose of being the initial value
for MCMC-based estimation, in which case <code>init.MPLE.samplesize</code>
is used instead, All of these can be specified either as numbers or as
<code style="white-space: pre;">&#8288;function(d,e)&#8288;</code> taking the number of informative dyads and
informative edges. Specifying or returning a larger number than
the number of informative dyads is safe.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mple.type">MPLE.type</code></td>
<td>
<p>One of <code>"glm"</code>, <code>"penalized"</code>, or
<code>"logitreg"</code>.  Chooses method of calculating MPLE.  <code>"glm"</code> is the
usual formal logistic regression called via <code><a href="stats.html#topic+glm">glm</a></code>, whereas
<code>"penalized"</code> uses the bias-reduced method of Firth (1993) as
originally implemented by Meinhard Ploner, Daniela Dunkler, Harry
Southworth, and Georg Heinze in the &quot;logistf&quot; package. <code>"logitreg"</code> is
an &quot;in-house&quot; implementation that is slower and probably less stable but
supports nonlinear logistic regression. It is invoked automatically when the
model has curved terms.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mple.maxit">MPLE.maxit</code></td>
<td>
<p>Maximum number of iterations for <code>"logitreg"</code>
implementation of MPLE.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mple.nonident">MPLE.nonident</code>, <code id="control.ergm_+3A_mple.nonident.tol">MPLE.nonident.tol</code>, <code id="control.ergm_+3A_mple.nonvar">MPLE.nonvar</code>, <code id="control.ergm_+3A_mcmle.nonident">MCMLE.nonident</code>, <code id="control.ergm_+3A_mcmle.nonident.tol">MCMLE.nonident.tol</code>, <code id="control.ergm_+3A_mcmle.nonvar">MCMLE.nonvar</code></td>
<td>
<p>A rudimentary nonidentifiability/multicollinearity diagnostic. If
<code>MPLE.nonident.tol &gt; 0</code>, test the MPLE covariate matrix or the CD
statistics matrix has linearly dependent columns via <a href="Matrix.html#topic+qr">QR decomposition</a> with tolerance <code>MPLE.nonident.tol</code>. This is
often (not always) indicative of a non-identifiable
(multicollinear) model. If nonidentifiable, depending on
<code>MPLE.nonident</code> issue a warning, an error, or a message
specifying the potentially redundant statistics. Before the
diagnostic is performed, covariates that do not vary (i.e.,
all-zero columns) are dropped, with their handling controlled by
<code>MPLE.nonvar</code>. The corresponding <code style="white-space: pre;">&#8288;MCMLE.*&#8288;</code> arguments provide a
similar diagnostic for the unconstrained MCMC sample's estimating
functions.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mple.covariance.method">MPLE.covariance.method</code>, <code id="control.ergm_+3A_mple.covariance.samplesize">MPLE.covariance.samplesize</code>, <code id="control.ergm_+3A_mple.covariance.sim.burnin">MPLE.covariance.sim.burnin</code>, <code id="control.ergm_+3A_mple.covariance.sim.interval">MPLE.covariance.sim.interval</code></td>
<td>
<p>Controls for estimating the MPLE covariance
matrix. <code style="white-space: pre;">&#8288;MPLE.covariance method&#8288;</code> determines the method, with
<code>invHess</code> (the default) returning the covariance estimate
obtained from the <code><a href="stats.html#topic+glm">glm()</a></code>. <code>Godambe</code> estimates the covariance
matrix using the Godambe-matrix (Schmid and Hunter 2023). This
method is recommended for dyad-dependent models. Alternatively,
<code>bootstrap</code> estimates standard deviations using a parametric
bootstrapping approach (see Schmid and Desmarais 2017). The
other parameters control, respectively, the number of networks to
simulate, the MCMC burn-in, and the MCMC interval for <code>Godambe</code>
and <code>bootstrap</code> methods.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mple.constraints.ignore">MPLE.constraints.ignore</code></td>
<td>
<p>If <code>TRUE</code>, MPLE will ignore all
dyad-independent constraints except for those due to attributes
missingness. This can be used to avert evaluating and storing the
<code><a href="#topic+rlebdm">rlebdm</a></code>s for very large networks except where absolutely
necessary. Note that this can be very dangerous unless you know
what you are doing.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.prop">MCMC.prop</code></td>
<td>
<p>Specifies the proposal (directly) and/or
a series of &quot;hints&quot; about the structure of the model being
sampled. The specification is in the form of a one-sided formula
with hints separated by <code>+</code> operations. If the LHS exists and is
a string, the proposal to be used is selected directly.
</p>
<p>A common and default &quot;hint&quot; is <code>~sparse</code>, indicating
that the network is sparse and that the sample should put roughly
equal weight on selecting a dyad with or without a tie as a
candidate for toggling.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.prop.weights">MCMC.prop.weights</code></td>
<td>
<p>Specifies the proposal
distribution used in the MCMC Metropolis-Hastings algorithm.  Possible
choices depending on selected <code>reference</code> and <code>constraints</code>
arguments of the <code><a href="#topic+ergm">ergm()</a></code> function, but often include <code>"TNT"</code>
and <code>"random"</code>, and the <code>"default"</code> is to use the one with the
highest priority available.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.prop.args">MCMC.prop.args</code></td>
<td>
<p>An alternative, direct way of
specifying additional arguments to proposal.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.interval">MCMC.interval</code></td>
<td>
<p>Number of proposals between sampled statistics.
Increasing interval will reduces the autocorrelation in the sample, and may
increase the precision in estimates by reducing MCMC error, at the expense
of time. Set the interval higher for larger networks.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.burnin">MCMC.burnin</code></td>
<td>
<p>Number of proposals before any MCMC sampling is done. It
typically is set to a fairly large number.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.samplesize">MCMC.samplesize</code></td>
<td>
<p>Number of network statistics, randomly drawn from a
given distribution on the set of all networks, returned by the
Metropolis-Hastings algorithm.  Increasing sample size may increase the
precision in the estimates by reducing MCMC error, at the expense of time.
Set it higher for larger networks, or when using parallel functionality.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.effectivesize">MCMC.effectiveSize</code>, <code id="control.ergm_+3A_mcmc.effectivesize.damp">MCMC.effectiveSize.damp</code>, <code id="control.ergm_+3A_mcmc.effectivesize.maxruns">MCMC.effectiveSize.maxruns</code>, <code id="control.ergm_+3A_mcmc.effectivesize.burnin.pval">MCMC.effectiveSize.burnin.pval</code>, <code id="control.ergm_+3A_mcmc.effectivesize.burnin.min">MCMC.effectiveSize.burnin.min</code>, <code id="control.ergm_+3A_mcmc.effectivesize.burnin.max">MCMC.effectiveSize.burnin.max</code>, <code id="control.ergm_+3A_mcmc.effectivesize.burnin.nmin">MCMC.effectiveSize.burnin.nmin</code>, <code id="control.ergm_+3A_mcmc.effectivesize.burnin.nmax">MCMC.effectiveSize.burnin.nmax</code>, <code id="control.ergm_+3A_mcmc.effectivesize.burnin.pc">MCMC.effectiveSize.burnin.PC</code>, <code id="control.ergm_+3A_mcmc.effectivesize.burnin.scl">MCMC.effectiveSize.burnin.scl</code>, <code id="control.ergm_+3A_mcmc.effectivesize.order.max">MCMC.effectiveSize.order.max</code></td>
<td>
<p>Set <code>MCMC.effectiveSize</code> to a non-NULL value to adaptively
determine the burn-in and the MCMC length needed to get the
specified effective size; 50 is a reasonable value. In the
adaptive MCMC mode, MCMC is run forward repeatedly
(<code>MCMC.samplesize*MCMC.interval</code> steps, up to
<code>MCMC.effectiveSize.maxruns</code> times) until the target effective
sample size is reached or exceeded.
</p>
<p>After each run, the returned statistics are mapped to the
estimating function scale, then an exponential decay model is fit
to the scaled statistics to find that burn-in which would reduce
the difference between the initial values of statistics and their
equilibrium values by a factor of <code>MCMC.effectiveSize.burnin.scl</code>
of what it initially was, bounded by <code>MCMC.effectiveSize.min</code> and
<code>MCMC.effectiveSize.max</code> as proportions of sample size. If the
best-fitting decay exceeds <code>MCMC.effectiveSize.max</code>, the
exponential model is considered to be unsuitable and
<code>MCMC.effectiveSize.min</code> is used.
</p>
<p>A Geweke diagnostic is then run, after thinning the sample to
<code>MCMC.effectiveSize.burnin.nmax</code>. If this Geweke diagnostic
produces a <code class="reqn">p</code>-value higher than
<code>MCMC.effectiveSize.burnin.pval</code>, it is accepted.
</p>
<p>If <code>MCMC.effectiveSize.burnin.PC&gt;0</code>, instead of using the full
sample for burn-in estimation, at most this many principal
components are used instead.
</p>
<p>The effective
size of the post-burn-in sample is computed via Vats, Flegal, and
Jones (2015), and compared to the target effective size. If it is
not matched, the MCMC run is resumed, with the additional draws
needed linearly extrapolated but weighted in favor of the
baseline <code>MCMC.samplesize</code> by the weighting factor
<code>MCMC.effectiveSize.damp</code> (higher = less damping). Lastly, if
after an MCMC run, the number of samples equals or exceeds
<code>2*MCMC.samplesize</code>, the chain will be thinned by 2 until it
falls below that, while doubling
<code>MCMC.interval</code>. <code>MCMC.effectiveSize.order.max</code> can be used to
set the order of the AR model used to estimate the effective
sample size and the variance for the Geweke diagnostic.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.return.stats">MCMC.return.stats</code></td>
<td>
<p>Numeric: If positive, include an
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> (two, if observational process was involved) of
MCMC network statistics from the last iteration of network of the
estimation. They will be thinned to have length of at most
<code>MCMC.return.stats</code>. They are used for MCMC diagnostics.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.runtime.traceplot">MCMC.runtime.traceplot</code></td>
<td>
<p>Logical: If <code>TRUE</code>, plot traceplots of the MCMC
sample after every MCMC MLE iteration.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.addto.se">MCMC.addto.se</code></td>
<td>
<p>Whether to add the standard errors induced by the MCMC
algorithm to the estimates' standard errors.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_san.maxit">SAN.maxit</code></td>
<td>
<p>When <code>target.stats</code> argument is passed to
<code><a href="#topic+ergm">ergm()</a></code>, the maximum number of attempts to use <code><a href="#topic+san">san</a></code>
to obtain a network with statistics close to those specified.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_san.nsteps.times">SAN.nsteps.times</code></td>
<td>
<p>Multiplier for <code>SAN.nsteps</code> relative to
<code>MCMC.burnin</code>. This lets one control the amount of SAN burn-in
(arguably, the most important of SAN parameters) without overriding the
other <code>SAN</code> defaults.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_san">SAN</code></td>
<td>
<p>Control arguments to <code><a href="#topic+san">san</a></code>.  See
<code><a href="#topic+control.san">control.san</a></code> for details.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.termination">MCMLE.termination</code></td>
<td>
<p>The criterion used for terminating MCMLE
estimation:
</p>

<ul>
<li> <p><code>"Hummel"</code> Terminate when the Hummel step length is
1 for two consecutive iterations. For the last iteration, the sample size is
boosted by a factor of <code>MCMLE.last.boost</code>. See Hummel et. al. (2012).
</p>
</li></ul>

<p>Note that this criterion is incompatible with <code>MCMLE.steplength</code>
<code class="reqn">\ne</code> 1 or <code>MCMLE.steplength.margin</code> <code class="reqn">=</code> <code>NULL</code>.
</p>

<ul>
<li> <p><code>"Hotelling"</code> After every MCMC sample, an autocorrelation-adjusted
Hotelling's T^2 test for equality of MCMC-simulated network statistics to
observed is conducted, and if its P-value exceeds
<code>MCMLE.conv.min.pval</code>, the estimation is considered to have converged
and finishes. This was the default option in <code>ergm</code> version 3.1.
</p>
</li>
<li> <p><code>"precision"</code> Terminate when the estimated loss in estimating precision
due to using MCMC standard errors is below the precision bound specified by
<code>MCMLE.MCMC.precision</code>, and the Hummel step length is 1 for two
consecutive iterations. See <code>MCMLE.MCMC.precision</code> for details. This
feature is in experimental status until we verify the coverage of the
standard errors.
</p>
</li></ul>

<p>Note that this criterion is incompatible with
<code class="reqn">\code{MCMLE.steplength}\ne 1</code> or
<code class="reqn">\code{MCMLE.steplength.margin}=\code{NULL}</code>.
</p>

<ul>
<li> <p><code>"confidence"</code>: Performs an equivalence test to prove with level
of confidence <code>MCMLE.confidence</code> that the true value of the
deviation of the simulated mean value parameter from the observed
is within an ellipsoid defined by the inverse-variance-covariance
of the sufficient statistics multiplied by a scaling factor
<code>control$MCMLE.MCMC.precision</code> (which has a different default).
</p>
</li>
<li> <p><code>"none"</code> Stop after
<code>MCMLE.maxit</code> iterations.
</p>
</li></ul>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.maxit">MCMLE.maxit</code></td>
<td>
<p>Maximum number of times the parameter for the MCMC should
be updated by maximizing the MCMC likelihood. At each step the parameter is
changed to the values that maximizes the MCMC likelihood based on the
current sample.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.conv.min.pval">MCMLE.conv.min.pval</code></td>
<td>
<p>The P-value used in the Hotelling test for early
termination.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.confidence">MCMLE.confidence</code></td>
<td>
<p>The confidence level for declaring
convergence for <code>"confidence"</code> methods.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.confidence.boost">MCMLE.confidence.boost</code></td>
<td>
<p>The maximum increase factor in sample
size (or target effective size, if enabled) when the
<code>"confidence"</code> termination criterion is either not approaching
the tolerance region or is unable to prove convergence.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.confidence.boost.threshold">MCMLE.confidence.boost.threshold</code>, <code id="control.ergm_+3A_mcmle.confidence.boost.lag">MCMLE.confidence.boost.lag</code></td>
<td>
<p>Sample size or target effective size will be increaed if the distance from the tolerance region fails to decrease more than MCMLE.confidence.boost.threshold in this many successive iterations.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.nr.maxit">MCMLE.NR.maxit</code>, <code id="control.ergm_+3A_mcmle.nr.reltol">MCMLE.NR.reltol</code></td>
<td>
<p>The method, maximum number of
iterations and relative tolerance to use within the <code>optim</code> rountine in
the MLE optimization. Note that by default, ergm uses <code>trust</code>, and
falls back to <code>optim</code> only when <code>trust</code> fails.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_obs.mcmc.prop">obs.MCMC.prop</code>, <code id="control.ergm_+3A_obs.mcmc.prop.weights">obs.MCMC.prop.weights</code>, <code id="control.ergm_+3A_obs.mcmc.prop.args">obs.MCMC.prop.args</code>, <code id="control.ergm_+3A_obs.mcmle.effectivesize">obs.MCMLE.effectiveSize</code>, <code id="control.ergm_+3A_obs.mcmc.samplesize">obs.MCMC.samplesize</code>, <code id="control.ergm_+3A_obs.mcmc.burnin">obs.MCMC.burnin</code>, <code id="control.ergm_+3A_obs.mcmc.interval">obs.MCMC.interval</code>, <code id="control.ergm_+3A_obs.mcmc.mul">obs.MCMC.mul</code>, <code id="control.ergm_+3A_obs.mcmc.samplesize.mul">obs.MCMC.samplesize.mul</code>, <code id="control.ergm_+3A_obs.mcmc.burnin.mul">obs.MCMC.burnin.mul</code>, <code id="control.ergm_+3A_obs.mcmc.interval.mul">obs.MCMC.interval.mul</code>, <code id="control.ergm_+3A_obs.mcmc.effectivesize">obs.MCMC.effectiveSize</code>, <code id="control.ergm_+3A_obs.mcmle.burnin">obs.MCMLE.burnin</code>, <code id="control.ergm_+3A_obs.mcmle.interval">obs.MCMLE.interval</code>, <code id="control.ergm_+3A_obs.mcmle.samplesize">obs.MCMLE.samplesize</code>, <code id="control.ergm_+3A_obs.mcmle.samplesize.per_theta">obs.MCMLE.samplesize.per_theta</code>, <code id="control.ergm_+3A_obs.mcmle.samplesize.min">obs.MCMLE.samplesize.min</code></td>
<td>
<p>Corresponding MCMC parameters and settings used for the constrained sample when
unobserved data are present in the estimation routine. By default, they are controlled by the <code style="white-space: pre;">&#8288;*.mul&#8288;</code>
parameters, as fractions of the corresponding settings for the
unconstrained (standard) MCMC.
</p>
<p>These can, in turn, be controlled by <code>obs.MCMC.mul</code>, which can be
used to set the overal multiplier for the number of MCMC steps in
the constrained sample; one half of its effect applies to the
burn-in and interval and the other half to the total sample
size. For example, for <code>obs.MCMC.mul=1/4</code> (the default),
<code>obs.MCMC.samplesize</code> is set to <code class="reqn">\sqrt{1/4}=1/2</code> that of
<code>obs.MCMC.samplesize</code>, and <code>obs.MCMC.burnin</code> and
<code>obs.MCMC.interval</code> are set to <code class="reqn">\sqrt{1/4}=1/2</code> of their
respective unconstrained sampling parameters. When
<code>MCMC.effectiveSize</code> or <code>MCMLE.effectiveSize</code> are given, their
corresponding <code>obs</code> parameters are set to them multiplied by
<code>obs.MCMC.mul</code>.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_obs.mcmc.impute.min_informative">obs.MCMC.impute.min_informative</code>, <code id="control.ergm_+3A_obs.mcmc.impute.default_density">obs.MCMC.impute.default_density</code></td>
<td>
<p>Controls for imputation of missing dyads for initializing MCMC
sampling. If numeric, <code>obs.MCMC.impute.min_informative</code> specifies
the minimum number dyads that need to be non-missing before
sample network density is used as the imputation density. It can
also be specified as a function that returns this
value. <code>obs.MCMC.impute.default_density</code> similarly controls the
imputation density when number of non-missing dyads is too low.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.min.depfac">MCMLE.min.depfac</code>, <code id="control.ergm_+3A_mcmle.sampsize.boost.pow">MCMLE.sampsize.boost.pow</code></td>
<td>
<p>When using adaptive MCMC effective size, and methods that increase the MCMC sample size, use <code>MCMLE.sampsize.boost.pow</code> as the power of the boost amount (relative to the boost of the target effective size), but ensure that sample size is no less than <code>MCMLE.min.depfac</code> times the target effective size.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.mcmc.precision">MCMLE.MCMC.precision</code>, <code id="control.ergm_+3A_mcmle.mcmc.max.ess.frac">MCMLE.MCMC.max.ESS.frac</code></td>
<td>
<p><code>MCMLE.MCMC.precision</code> is a vector of upper bounds on the standard
errors induced by the MCMC algorithm, expressed as a percentage of the total
standard error. The MCMLE algorithm will terminate when the MCMC standard
errors are below the precision bound, and the Hummel step length is 1 for
two consecutive iterations. This is an experimental feature.
</p>
<p>If effective sample size is used (see <code>MCMC.effectiveSize</code>), then ergm
may increase the target ESS to reduce the MCMC standard error.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.metric">MCMLE.metric</code></td>
<td>
<p>Method to calculate the loglikelihood approximation.
See Hummel et al (2010) for an explanation of &quot;lognormal&quot; and &quot;naive&quot;.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.method">MCMLE.method</code></td>
<td>
<p>Deprecated. By default, ergm uses <code>trust</code>, and
falls back to <code>optim</code> with Nelder-Mead method when <code>trust</code> fails.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.dampening">MCMLE.dampening</code></td>
<td>
<p>(logical) Should likelihood dampening be used?</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.dampening.min.ess">MCMLE.dampening.min.ess</code></td>
<td>
<p>The effective sample size below which
dampening is used.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.dampening.level">MCMLE.dampening.level</code></td>
<td>
<p>The proportional distance from boundary of the
convex hull move.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.steplength.margin">MCMLE.steplength.margin</code></td>
<td>
<p>The extra margin required for a Hummel step
to count as being inside the convex hull of the sample.  Set this to 0 if
the step length gets stuck at the same value over several iteraions. Set it
to <code>NULL</code> to use fixed step length. Note that this parameter is
required to be non-<code>NULL</code> for MCMLE termination using Hummel or
precision criteria.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.steplength">MCMLE.steplength</code></td>
<td>
<p>Multiplier for step length (on the
mean-value parameter scale), which may (for values less than one)
make fitting more stable at the cost of computational efficiency.
</p>
<p>If <code>MCMLE.steplength.margin</code> is not <code>NULL</code>, the step
length will be set using the algorithm of Hummel et
al. (2010). In that case, it will serve as the maximum step
length considered. However, setting it to anything other than 1
will preclude using Hummel or precision as termination criteria.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.steplength.parallel">MCMLE.steplength.parallel</code></td>
<td>
<p>Whether parallel multisection
search (as opposed to a bisection search) for the Hummel step
length should be used if running in multiple threads. Possible
values (partially matched) are <code>"never"</code>, and
(default) <code>"observational"</code> (i.e., when missing data MLE is
used).</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.sequential">MCMLE.sequential</code></td>
<td>
<p>Logical: If TRUE, the next iteration of the fit uses
the last network sampled as the starting network.  If FALSE, always use the
initially passed network.  The results should be similar (stochastically),
but the TRUE option may help if the <code>target.stats</code> in the
<code><a href="#topic+ergm">ergm()</a></code> function are far from the initial network.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.density.guard.min">MCMLE.density.guard.min</code>, <code id="control.ergm_+3A_mcmle.density.guard">MCMLE.density.guard</code></td>
<td>
<p>A simple heuristic to
stop optimization if it finds itself in an overly dense region, which
usually indicates ERGM degeneracy: if the sampler encounters a network
configuration that has more than <code>MCMLE.density.guard.min</code> edges and
whose number of edges is exceeds the observed network by more than
<code>MCMLE.density.guard</code>, the optimization process will be stopped with an
error.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.effectivesize">MCMLE.effectiveSize</code>, <code id="control.ergm_+3A_mcmle.effectivesize.interval_drop">MCMLE.effectiveSize.interval_drop</code>, <code id="control.ergm_+3A_mcmle.burnin">MCMLE.burnin</code>, <code id="control.ergm_+3A_mcmle.interval">MCMLE.interval</code>, <code id="control.ergm_+3A_mcmle.samplesize">MCMLE.samplesize</code>, <code id="control.ergm_+3A_mcmle.samplesize.per_theta">MCMLE.samplesize.per_theta</code>, <code id="control.ergm_+3A_mcmle.samplesize.min">MCMLE.samplesize.min</code></td>
<td>
<p>Sets the corresponding <code style="white-space: pre;">&#8288;MCMC.*&#8288;</code> parameters when
<code>main.method="MCMLE"</code> (the default). Used because defaults may be
different for different methods. <code>MCMLE.samplesize.per_theta</code>
controls the MCMC sample size (not target effective size) as a
function of the number of (curved) parameters in the model, and
<code>MCMLE.samplesize.min</code> sets the minimum sample size regardless of
their number.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.steplength.solver">MCMLE.steplength.solver</code></td>
<td>
<p>The linear program solver to use for
MCMLE step length calculation. Can be either <code>"glpk"</code> to use
<a href="https://CRAN.R-project.org/package=Rglpk"><span class="pkg">Rglpk</span></a> or <code>"lpsolve"</code> to use <a href="https://CRAN.R-project.org/package=lpSolveAPI"><span class="pkg">lpSolveAPI</span></a>.
<a href="https://CRAN.R-project.org/package=Rglpk"><span class="pkg">Rglpk</span></a> can be orders of magnitude faster, particularly
for models with many parameters and with large sample sizes, so
it is used where available; but it requires an external library
to install under some operating systems, so fallback to
<a href="https://CRAN.R-project.org/package=lpSolveAPI"><span class="pkg">lpSolveAPI</span></a> provided.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.last.boost">MCMLE.last.boost</code></td>
<td>
<p>For the Hummel termination criterion, increase the
MCMC sample size of the last iteration by this factor.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.steplength.esteq">MCMLE.steplength.esteq</code></td>
<td>
<p>For curved ERGMs, should the estimating function
values be used to compute the Hummel step length? This allows the Hummel
stepping algorithm converge when some sufficient statistics are at 0.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.steplength.miss.sample">MCMLE.steplength.miss.sample</code></td>
<td>
<p>In fitting the missing data
MLE, the rules for step length become more complicated. In short,
it is necessary for <em>all</em> points in the constrained sample
to be in the convex hull of the unconstrained (though they may be
on the border); and it is necessary for their centroid to be in
its interior. This requires checking a large number of points
against whether they are in the convex hull, so to speed up the
procedure, a sample is taken of the points most likely to be
outside it.  This parameter specifies the sample size or a
function of the unconstrained sample matrix to determine the
sample size.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.steplength.min">MCMLE.steplength.min</code></td>
<td>
<p>Stops MCMLE estimation when the step length gets
stuck below this minimum value.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_mcmle.save_intermediates">MCMLE.save_intermediates</code></td>
<td>
<p>Every iteration, after MCMC
sampling, save the MCMC sample and some miscellaneous information
to a file with this name. This is mainly useful for diagnostics
and debugging. The name is passed through <code><a href="base.html#topic+sprintf">sprintf()</a></code> with
iteration number as the second argument. (For example,
<code>MCMLE.save_intermediates="step_%03d.RData"</code> will save to
<code>step_001.RData</code>, <code>step_002.RData</code>, etc.)</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_sa.phase1_n">SA.phase1_n</code></td>
<td>
<p>A constant or a function of number of free
parameters <code>q</code>, number of free canonical statistic <code>p</code>, and
network size <code>n</code>, giving the number of MCMC samples to draw in
Phase 1 of the stochastic approximation algorithm.  Defaults to
<code class="reqn">\max(200, 7+3p)</code>.  See Snijders (2002) for details.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_sa.initial_gain">SA.initial_gain</code></td>
<td>
<p>Initial gain to Phase 2 of the stochastic
approximation algorithm. Defaults to 0.1. See Snijders (2002) for
details.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_sa.nsubphases">SA.nsubphases</code></td>
<td>
<p>Number of sub-phases in Phase 2 of the
stochastic approximation algorithm.  Defaults to
<code>MCMLE.maxit</code>.  See Snijders (2002) for details.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_sa.min_iterations">SA.min_iterations</code>, <code id="control.ergm_+3A_sa.max_iterations">SA.max_iterations</code></td>
<td>
<p>A constant or a function
of number of free parameters <code>q</code>, number of free canonical
statistic <code>p</code>, and network size <code>n</code>, giving the baseline numbers
of iterations within each subphase of Phase 2 of the stochastic
approximation algorithm. Default to <code class="reqn">7+p</code> and <code class="reqn">207+p</code>,
respectively.  See Snijders (2002) for details.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_sa.phase3_n">SA.phase3_n</code></td>
<td>
<p>Sample size for the MCMC sample in Phase 3 of
the stochastic approximation algorithm.  See Snijders (2002) for
details.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_sa.burnin">SA.burnin</code>, <code id="control.ergm_+3A_sa.interval">SA.interval</code>, <code id="control.ergm_+3A_sa.samplesize">SA.samplesize</code></td>
<td>
<p>Sets the corresponding
<code style="white-space: pre;">&#8288;MCMC.*&#8288;</code> parameters when <code>main.method="Stochastic-Approximation"</code>.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_cd.samplesize.per_theta">CD.samplesize.per_theta</code>, <code id="control.ergm_+3A_obs.cd.samplesize.per_theta">obs.CD.samplesize.per_theta</code>, <code id="control.ergm_+3A_cd.maxit">CD.maxit</code>, <code id="control.ergm_+3A_cd.conv.min.pval">CD.conv.min.pval</code>, <code id="control.ergm_+3A_cd.nr.maxit">CD.NR.maxit</code>, <code id="control.ergm_+3A_cd.nr.reltol">CD.NR.reltol</code>, <code id="control.ergm_+3A_cd.metric">CD.metric</code>, <code id="control.ergm_+3A_cd.method">CD.method</code>, <code id="control.ergm_+3A_cd.dampening">CD.dampening</code>, <code id="control.ergm_+3A_cd.dampening.min.ess">CD.dampening.min.ess</code>, <code id="control.ergm_+3A_cd.dampening.level">CD.dampening.level</code>, <code id="control.ergm_+3A_cd.steplength.margin">CD.steplength.margin</code>, <code id="control.ergm_+3A_cd.steplength">CD.steplength</code>, <code id="control.ergm_+3A_cd.steplength.parallel">CD.steplength.parallel</code>, <code id="control.ergm_+3A_cd.adaptive.epsilon">CD.adaptive.epsilon</code>, <code id="control.ergm_+3A_cd.steplength.esteq">CD.steplength.esteq</code>, <code id="control.ergm_+3A_cd.steplength.miss.sample">CD.steplength.miss.sample</code>, <code id="control.ergm_+3A_cd.steplength.min">CD.steplength.min</code>, <code id="control.ergm_+3A_cd.steplength.solver">CD.steplength.solver</code></td>
<td>
<p>Miscellaneous tuning parameters of the CD sampler and
optimizer. These have the same meaning as their <code style="white-space: pre;">&#8288;MCMLE.*&#8288;</code> and
<code style="white-space: pre;">&#8288;MCMC.*&#8288;</code> counterparts.
</p>
<p>Note that only the Hotelling's stopping criterion is implemented
for CD.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_cd.nsteps">CD.nsteps</code>, <code id="control.ergm_+3A_cd.multiplicity">CD.multiplicity</code></td>
<td>
<p>Main settings for contrastive
divergence to obtain initial values for the estimation:
respectively, the number of Metropolis&ndash;Hastings steps to take
before reverting to the starting value and the number of
tentative proposals per step. Computational experiments indicate
that increasing <code>CD.multiplicity</code> improves the estimate
faster than increasing <code>CD.nsteps</code> &mdash; up to a point &mdash; but
it also samples from the wrong distribution, in the sense that
while as <code>CD.nsteps</code><code class="reqn">\rightarrow\infty</code>, the CD estimate
approaches the MLE, this is not the case for
<code>CD.multiplicity</code>.
</p>
<p>In practice, MPLE, when available, usually outperforms CD for
even a very high <code>CD.nsteps</code> (which is, in turn, not very
stable), so CD is useful primarily when MPLE is not
available. This feature is to be considered experimental and in
flux.
</p>
<p>The default values have been set experimentally, providing a
reasonably stable, if not great, starting values.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_cd.nsteps.obs">CD.nsteps.obs</code>, <code id="control.ergm_+3A_cd.multiplicity.obs">CD.multiplicity.obs</code></td>
<td>
<p>When there are missing dyads,
<code>CD.nsteps</code> and <code>CD.multiplicity</code> must be set to a relatively high
value, as the network passed is not necessarily a good start for CD.
Therefore, these settings are in effect if there are missing dyads in the
observed network, using a higher default number of steps.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_loglik">loglik</code></td>
<td>
<p>See <code><a href="#topic+control.ergm.bridge">control.ergm.bridge</a></code></p>
</td></tr>
<tr><td><code id="control.ergm_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.ergm_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
<tr><td><code id="control.ergm_+3A_...">...</code></td>
<td>
<p>A dummy argument to catch deprecated or mistyped control parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="#topic+ergm">ergm()</a></code> function.
See the <code>usage</code> section in <code><a href="#topic+ergm">ergm()</a></code> for details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>References</h3>

<p>Schmid CS, Desmarais BA (2017).
&ldquo;Exponential random graph models with big networks: Maximum pseudolikelihood estimation and the parametric bootstrap.&rdquo;
In <em>2017 IEEE international conference on big data (Big Data)</em>, 116&ndash;121.
IEEE.<br /><br /> Schmid CS, Hunter DR (2023).
&ldquo;Computing Pseudolikelihood Estimators for Exponential-Family Random Graph Models.&rdquo;
<em>Journal of Data Science</em>.
</p>

<ul>
<li><p> Snijders, T.A.B. (2002), Markov Chain Monte
Carlo Estimation of Exponential Random Graph Models.  Journal of Social
Structure.  Available from
<a href="https://www.cmu.edu/joss/content/articles/volume3/Snijders.pdf">https://www.cmu.edu/joss/content/articles/volume3/Snijders.pdf</a>.
</p>
</li>
<li><p> Firth (1993), Bias Reduction in Maximum Likelihood Estimates.
Biometrika, 80: 27-38.
</p>
</li>
<li><p> Hunter, D. R. and M. S. Handcock (2006), Inference in curved
exponential family models for networks. Journal of Computational and
Graphical Statistics, 15: 565-583.
</p>
</li>
<li><p> Hummel, R. M., Hunter, D. R., and Handcock, M. S. (2012), Improving
Simulation-Based Algorithms for Fitting ERGMs, Journal of Computational and
Graphical Statistics, 21: 920-939.
</p>
</li>
<li><p> Kristoffer Sahlin. Estimating convergence of Markov chain Monte Carlo
simulations. Master's Thesis. Stockholm University, 2011.
<a href="https://www2.math.su.se/matstat/reports/master/2011/rep2/report.pdf">https://www2.math.su.se/matstat/reports/master/2011/rep2/report.pdf</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm()</a></code>. The <code><a href="#topic+control.simulate">control.simulate</a></code> function
performs a similar function for <code><a href="#topic+simulate.ergm">simulate.ergm</a></code>;
<code><a href="#topic+control.gof">control.gof</a></code> performs a similar function for <code><a href="#topic+gof">gof</a></code>.
</p>

<hr>
<h2 id='control.ergm.bridge'>Auxiliaries for Controlling <code><a href="#topic+ergm.bridge.llr">ergm.bridge.llr()</a></code> and <code><a href="#topic+logLik.ergm">logLik.ergm()</a></code></h2><span id='topic+control.ergm.bridge'></span><span id='topic+control.logLik.ergm'></span>

<h3>Description</h3>

<p>Auxiliary functions as user interfaces for fine-tuning the
<code><a href="#topic+ergm.bridge.llr">ergm.bridge.llr()</a></code> algorithm, which approximates log likelihood
ratios using bridge sampling.
</p>
<p>By default, the bridge sampler inherits its control
parameters from the <code><a href="#topic+ergm">ergm()</a></code> fit; <code>control.logLik.ergm()</code> allows
the user to selectively override them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.ergm.bridge(
  bridge.nsteps = 16,
  bridge.target.se = NULL,
  bridge.bidirectional = TRUE,
  MCMC.burnin = MCMC.interval * 128,
  MCMC.burnin.between = max(ceiling(MCMC.burnin/sqrt(bridge.nsteps)), MCMC.interval * 16),
  MCMC.interval = 128,
  MCMC.samplesize = 16384,
  obs.MCMC.burnin = obs.MCMC.interval * 128,
  obs.MCMC.burnin.between = max(ceiling(obs.MCMC.burnin/sqrt(bridge.nsteps)),
    obs.MCMC.interval * 16),
  obs.MCMC.interval = MCMC.interval,
  obs.MCMC.samplesize = MCMC.samplesize,
  MCMC.prop = trim_env(~sparse),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  obs.MCMC.prop = MCMC.prop,
  obs.MCMC.prop.weights = MCMC.prop.weights,
  obs.MCMC.prop.args = MCMC.prop.args,
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  term.options = list(),
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)

control.logLik.ergm(
  bridge.nsteps = 16,
  bridge.target.se = NULL,
  bridge.bidirectional = TRUE,
  MCMC.burnin = NULL,
  MCMC.interval = NULL,
  MCMC.samplesize = NULL,
  obs.MCMC.samplesize = MCMC.samplesize,
  obs.MCMC.interval = MCMC.interval,
  obs.MCMC.burnin = MCMC.burnin,
  MCMC.prop = NULL,
  MCMC.prop.weights = NULL,
  MCMC.prop.args = NULL,
  obs.MCMC.prop = MCMC.prop,
  obs.MCMC.prop.weights = MCMC.prop.weights,
  obs.MCMC.prop.args = MCMC.prop.args,
  MCMC.maxedges = Inf,
  MCMC.packagenames = NULL,
  term.options = NULL,
  seed = NULL,
  parallel = NULL,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.ergm.bridge_+3A_bridge.nsteps">bridge.nsteps</code></td>
<td>
<p>Number of geometric bridges to use.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_bridge.target.se">bridge.target.se</code></td>
<td>
<p>If not <code>NULL</code>, if the estimated MCMC standard error of the likelihood estimate exceeds this, repeat the bridge sampling, accumulating samples.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_bridge.bidirectional">bridge.bidirectional</code></td>
<td>
<p>Whether the bridge sampler first bridges from <code>from</code> to <code>to</code>, then from <code>to</code> to <code>from</code> (skipping the first burn-in), etc. if multiple attempts are required.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.burnin">MCMC.burnin</code></td>
<td>
<p>Number of proposals before any MCMC sampling is done. It
typically is set to a fairly large number.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.burnin.between">MCMC.burnin.between</code></td>
<td>
<p>Number of proposals between the bridges; typically, less and less is needed as the number of steps decreases.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.interval">MCMC.interval</code></td>
<td>
<p>Number of proposals between sampled statistics.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.samplesize">MCMC.samplesize</code></td>
<td>
<p>Number of network statistics, randomly drawn from a
given distribution on the set of all networks, returned by the
Metropolis-Hastings algorithm.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_obs.mcmc.burnin">obs.MCMC.burnin</code>, <code id="control.ergm.bridge_+3A_obs.mcmc.burnin.between">obs.MCMC.burnin.between</code>, <code id="control.ergm.bridge_+3A_obs.mcmc.interval">obs.MCMC.interval</code>, <code id="control.ergm.bridge_+3A_obs.mcmc.samplesize">obs.MCMC.samplesize</code></td>
<td>
<p>The <code>obs</code>
versions of these arguments are for the unobserved data simulation
algorithm.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.prop">MCMC.prop</code></td>
<td>
<p>Specifies the proposal (directly) and/or
a series of &quot;hints&quot; about the structure of the model being
sampled. The specification is in the form of a one-sided formula
with hints separated by <code>+</code> operations. If the LHS exists and is
a string, the proposal to be used is selected directly.
</p>
<p>A common and default &quot;hint&quot; is <code>~sparse</code>, indicating
that the network is sparse and that the sample should put roughly
equal weight on selecting a dyad with or without a tie as a
candidate for toggling.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.prop.weights">MCMC.prop.weights</code></td>
<td>
<p>Specifies the proposal
distribution used in the MCMC Metropolis-Hastings algorithm.  Possible
choices depending on selected <code>reference</code> and <code>constraints</code>
arguments of the <code><a href="#topic+ergm">ergm()</a></code> function, but often include <code>"TNT"</code>
and <code>"random"</code>, and the <code>"default"</code> is to use the one with the
highest priority available.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.prop.args">MCMC.prop.args</code></td>
<td>
<p>An alternative, direct way of
specifying additional arguments to proposal.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_obs.mcmc.prop">obs.MCMC.prop</code>, <code id="control.ergm.bridge_+3A_obs.mcmc.prop.weights">obs.MCMC.prop.weights</code>, <code id="control.ergm.bridge_+3A_obs.mcmc.prop.args">obs.MCMC.prop.args</code></td>
<td>
<p>The <code>obs</code> versions of these arguments are for the unobserved data simulation algorithm.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
<tr><td><code id="control.ergm.bridge_+3A_...">...</code></td>
<td>
<p>A dummy argument to catch deprecated or mistyped control parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>control.ergm.bridge()</code> is only used within a call to the
<code><a href="#topic+ergm.bridge.llr">ergm.bridge.llr()</a></code>, <code><a href="#topic+ergm.bridge.dindstart.llk">ergm.bridge.dindstart.llk()</a></code>, or
<code><a href="#topic+ergm.bridge.0.llk">ergm.bridge.0.llk()</a></code> functions.
</p>
<p><code>control.logLik.ergm()</code> is only used within a call to the
<code><a href="#topic+logLik.ergm">logLik.ergm()</a></code>.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm.bridge.llr">ergm.bridge.llr()</a></code>
</p>
<p><code><a href="#topic+logLik.ergm">logLik.ergm</a></code>
</p>

<hr>
<h2 id='control.ergm.godfather'>Control parameters for <code><a href="#topic+ergm.godfather">ergm.godfather()</a></code>.</h2><span id='topic+control.ergm.godfather'></span>

<h3>Description</h3>

<p>Returns a list of its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.ergm.godfather(term.options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.ergm.godfather_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="#topic+term.options">? term.options</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='control.gof'>Auxiliary for Controlling ERGM Goodness-of-Fit Evaluation</h2><span id='topic+control.gof'></span><span id='topic+control.gof.formula'></span><span id='topic+control.gof.ergm'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning ERGM Goodness-of-Fit
Evaluation.
</p>
<p>The <code>control.gof.ergm</code> version is intended to be used
with <code><a href="#topic+gof.ergm">gof.ergm()</a></code> specifically and will &quot;inherit&quot; as many control
parameters from <code><a href="#topic+ergm">ergm</a></code> fit as possible().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.gof.formula(
  nsim = 100,
  MCMC.burnin = 10000,
  MCMC.interval = 1000,
  MCMC.batch = 0,
  MCMC.prop = trim_env(~sparse),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE
)

control.gof.ergm(
  nsim = 100,
  MCMC.burnin = NULL,
  MCMC.interval = NULL,
  MCMC.batch = NULL,
  MCMC.prop = NULL,
  MCMC.prop.weights = NULL,
  MCMC.prop.args = NULL,
  MCMC.maxedges = NULL,
  MCMC.packagenames = NULL,
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.gof_+3A_nsim">nsim</code></td>
<td>
<p>Number of networks to be randomly drawn using Markov chain Monte
Carlo.  This sample of networks provides the basis for comparing the model
to the observed network.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.burnin">MCMC.burnin</code></td>
<td>
<p>Number of proposals before any MCMC sampling is done. It
typically is set to a fairly large number.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.interval">MCMC.interval</code></td>
<td>
<p>Number of proposals between sampled statistics.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.batch">MCMC.batch</code></td>
<td>
<p>if not 0 or <code>NULL</code>, sample about this many
networks per call to the lower-level code; this can be useful if
<code style="white-space: pre;">&#8288;output=&#8288;</code> is a function, where it can be used to limit the number
of networks held in memory at any given time.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.prop">MCMC.prop</code></td>
<td>
<p>Specifies the proposal (directly) and/or
a series of &quot;hints&quot; about the structure of the model being
sampled. The specification is in the form of a one-sided formula
with hints separated by <code>+</code> operations. If the LHS exists and is
a string, the proposal to be used is selected directly.
</p>
<p>A common and default &quot;hint&quot; is <code>~sparse</code>, indicating
that the network is sparse and that the sample should put roughly
equal weight on selecting a dyad with or without a tie as a
candidate for toggling.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.prop.weights">MCMC.prop.weights</code></td>
<td>
<p>Specifies the proposal
distribution used in the MCMC Metropolis-Hastings algorithm.  Possible
choices depending on selected <code>reference</code> and <code>constraints</code>
arguments of the <code><a href="#topic+ergm">ergm()</a></code> function, but often include <code>"TNT"</code>
and <code>"random"</code>, and the <code>"default"</code> is to use the one with the
highest priority available.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.prop.args">MCMC.prop.args</code></td>
<td>
<p>An alternative, direct way of
specifying additional arguments to proposal.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_mcmc.runtime.traceplot">MCMC.runtime.traceplot</code></td>
<td>
<p>Logical: If <code>TRUE</code>, plot traceplots of the MCMC
sample.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_network.output">network.output</code></td>
<td>
<p>R class with which to output networks. The options are
&quot;network&quot; (default) and &quot;edgelist.compressed&quot; (which saves space but only
supports networks without vertex attributes)</p>
</td></tr>
<tr><td><code id="control.gof_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.gof_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.gof_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="#topic+gof">gof</a></code> function.
See the <code>usage</code> section in <code><a href="#topic+gof">gof</a></code> for details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gof">gof</a></code>. The <code><a href="#topic+control.simulate">control.simulate</a></code> function
performs a similar function for <code><a href="#topic+simulate.ergm">simulate.ergm</a></code>;
<code><a href="#topic+control.ergm">control.ergm</a></code> performs a similar function for
<code><a href="#topic+ergm">ergm</a></code>.
</p>

<hr>
<h2 id='control.san'>Auxiliary for Controlling SAN</h2><span id='topic+control.san'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning simulated annealing
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.san(
  SAN.maxit = 4,
  SAN.tau = 1,
  SAN.invcov = NULL,
  SAN.invcov.diag = FALSE,
  SAN.nsteps.alloc = function(nsim) 2^seq_len(nsim),
  SAN.nsteps = 2^19,
  SAN.samplesize = 2^12,
  SAN.prop = trim_env(~sparse),
  SAN.prop.weights = "default",
  SAN.prop.args = list(),
  SAN.packagenames = c(),
  SAN.ignore.finite.offsets = TRUE,
  term.options = list(),
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.san_+3A_san.maxit">SAN.maxit</code></td>
<td>
<p>Number of temperature levels to use.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.tau">SAN.tau</code></td>
<td>
<p>Tuning parameter, specifying the temperature of the
process during the <em>penultimate</em> iteration. (During the last
iteration, the temperature is set to 0, resulting in a greedy
search, and during the previous iterations, the temperature is
set to <code style="white-space: pre;">&#8288;SAN.tau*(iterations left after this one)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.invcov">SAN.invcov</code></td>
<td>
<p>Initial inverse covariance matrix used to
calculate Mahalanobis distance in determining how far a proposed
MCMC move is from the <code>target.stats</code> vector.  If <code>NULL</code>,
initially set to the identity matrix. In either case, during
subsequent runs, it is estimated empirically.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.invcov.diag">SAN.invcov.diag</code></td>
<td>
<p>Whether to only use the diagonal of the
covariance matrix. It seems to work better in practice.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.nsteps.alloc">SAN.nsteps.alloc</code></td>
<td>
<p>Either a numeric vector or a function of
the number of runs giving a sequence of relative lengths of
simulated annealing runs.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.nsteps">SAN.nsteps</code></td>
<td>
<p>Number of MCMC proposals for all the annealing runs combined.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.samplesize">SAN.samplesize</code></td>
<td>
<p>Number of realisations' statistics to obtain for tuning purposes.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.prop">SAN.prop</code></td>
<td>
<p>Specifies the proposal (directly) and/or
a series of &quot;hints&quot; about the structure of the model being
sampled. The specification is in the form of a one-sided formula
with hints separated by <code>+</code> operations. If the LHS exists and is
a string, the proposal to be used is selected directly.
</p>
<p>A common and default &quot;hint&quot; is <code>~sparse</code>, indicating
that the network is sparse and that the sample should put roughly
equal weight on selecting a dyad with or without a tie as a
candidate for toggling.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.prop.weights">SAN.prop.weights</code></td>
<td>
<p>Specifies the proposal
distribution used in the SAN Metropolis-Hastings algorithm.  Possible
choices depending on selected <code>reference</code> and <code>constraints</code>
arguments of the <code><a href="#topic+ergm">ergm()</a></code> function, but often include <code>"TNT"</code>
and <code>"random"</code>, and the <code>"default"</code> is to use the one with the
highest priority available.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.prop.args">SAN.prop.args</code></td>
<td>
<p>An alternative, direct way of
specifying additional arguments to proposal.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.packagenames">SAN.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
<tr><td><code id="control.san_+3A_san.ignore.finite.offsets">SAN.ignore.finite.offsets</code></td>
<td>
<p>Whether SAN should ignore (treat as 0) finite offsets.</p>
</td></tr>
<tr><td><code id="control.san_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.san_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="control.san_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.san_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.san_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.san_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="#topic+san">san</a></code> function.
See the <code>usage</code> section in <code><a href="#topic+san">san</a></code> for details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+san">san</a></code>
</p>

<hr>
<h2 id='control.simulate.ergm'>Auxiliary for Controlling ERGM Simulation</h2><span id='topic+control.simulate.ergm'></span><span id='topic+control.simulate.formula.ergm'></span><span id='topic+control.simulate'></span><span id='topic+control.simulate.formula'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning ERGM
simulation. <code>control.simulate</code>, <code>control.simulate.formula</code>, and
<code>control.simulate.formula.ergm</code> are all aliases for the same
function.
</p>
<p>While the others supply a full set of simulation
settings, <code>control.simulate.ergm</code> when passed as a control
parameter to <code><a href="#topic+simulate.ergm">simulate.ergm()</a></code> allows some settings to be
inherited from the ERGM stimation while overriding others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.simulate.formula.ergm(
  MCMC.burnin = MCMC.interval * 16,
  MCMC.interval = 1024,
  MCMC.prop = trim_env(~sparse),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)

control.simulate(
  MCMC.burnin = MCMC.interval * 16,
  MCMC.interval = 1024,
  MCMC.prop = trim_env(~sparse),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)

control.simulate.formula(
  MCMC.burnin = MCMC.interval * 16,
  MCMC.interval = 1024,
  MCMC.prop = trim_env(~sparse),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)

control.simulate.ergm(
  MCMC.burnin = NULL,
  MCMC.interval = NULL,
  MCMC.scale = 1,
  MCMC.prop = NULL,
  MCMC.prop.weights = NULL,
  MCMC.prop.args = NULL,
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = NULL,
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.burnin">MCMC.burnin</code></td>
<td>
<p>Number of proposals before any MCMC sampling is done. It
typically is set to a fairly large number.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.interval">MCMC.interval</code></td>
<td>
<p>Number of proposals between sampled statistics.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.prop">MCMC.prop</code></td>
<td>
<p>Specifies the proposal (directly) and/or
a series of &quot;hints&quot; about the structure of the model being
sampled. The specification is in the form of a one-sided formula
with hints separated by <code>+</code> operations. If the LHS exists and is
a string, the proposal to be used is selected directly.
</p>
<p>A common and default &quot;hint&quot; is <code>~sparse</code>, indicating
that the network is sparse and that the sample should put roughly
equal weight on selecting a dyad with or without a tie as a
candidate for toggling.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.prop.weights">MCMC.prop.weights</code></td>
<td>
<p>Specifies the proposal
distribution used in the MCMC Metropolis-Hastings algorithm.  Possible
choices depending on selected <code>reference</code> and <code>constraints</code>
arguments of the <code><a href="#topic+ergm">ergm()</a></code> function, but often include <code>"TNT"</code>
and <code>"random"</code>, and the <code>"default"</code> is to use the one with the
highest priority available.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.prop.args">MCMC.prop.args</code></td>
<td>
<p>An alternative, direct way of
specifying additional arguments to proposal.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.batch">MCMC.batch</code></td>
<td>
<p>if not 0 or <code>NULL</code>, sample about this many
networks per call to the lower-level code; this can be useful if
<code style="white-space: pre;">&#8288;output=&#8288;</code> is a function, where it can be used to limit the number
of networks held in memory at any given time.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.effectivesize">MCMC.effectiveSize</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.damp">MCMC.effectiveSize.damp</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.maxruns">MCMC.effectiveSize.maxruns</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.burnin.pval">MCMC.effectiveSize.burnin.pval</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.burnin.min">MCMC.effectiveSize.burnin.min</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.burnin.max">MCMC.effectiveSize.burnin.max</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.burnin.nmin">MCMC.effectiveSize.burnin.nmin</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.burnin.nmax">MCMC.effectiveSize.burnin.nmax</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.burnin.pc">MCMC.effectiveSize.burnin.PC</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.burnin.scl">MCMC.effectiveSize.burnin.scl</code>, <code id="control.simulate.ergm_+3A_mcmc.effectivesize.order.max">MCMC.effectiveSize.order.max</code></td>
<td>
<p>Set <code>MCMC.effectiveSize</code> to a non-NULL value to adaptively
determine the burn-in and the MCMC length needed to get the
specified effective size; 50 is a reasonable value. In the
adaptive MCMC mode, MCMC is run forward repeatedly
(<code>MCMC.samplesize*MCMC.interval</code> steps, up to
<code>MCMC.effectiveSize.maxruns</code> times) until the target effective
sample size is reached or exceeded.
</p>
<p>After each run, the returned statistics are mapped to the
estimating function scale, then an exponential decay model is fit
to the scaled statistics to find that burn-in which would reduce
the difference between the initial values of statistics and their
equilibrium values by a factor of <code>MCMC.effectiveSize.burnin.scl</code>
of what it initially was, bounded by <code>MCMC.effectiveSize.min</code> and
<code>MCMC.effectiveSize.max</code> as proportions of sample size. If the
best-fitting decay exceeds <code>MCMC.effectiveSize.max</code>, the
exponential model is considered to be unsuitable and
<code>MCMC.effectiveSize.min</code> is used.
</p>
<p>A Geweke diagnostic is then run, after thinning the sample to
<code>MCMC.effectiveSize.burnin.nmax</code>. If this Geweke diagnostic
produces a <code class="reqn">p</code>-value higher than
<code>MCMC.effectiveSize.burnin.pval</code>, it is accepted.
</p>
<p>If <code>MCMC.effectiveSize.burnin.PC&gt;0</code>, instead of using the full
sample for burn-in estimation, at most this many principal
components are used instead.
</p>
<p>The effective
size of the post-burn-in sample is computed via Vats, Flegal, and
Jones (2015), and compared to the target effective size. If it is
not matched, the MCMC run is resumed, with the additional draws
needed linearly extrapolated but weighted in favor of the
baseline <code>MCMC.samplesize</code> by the weighting factor
<code>MCMC.effectiveSize.damp</code> (higher = less damping). Lastly, if
after an MCMC run, the number of samples equals or exceeds
<code>2*MCMC.samplesize</code>, the chain will be thinned by 2 until it
falls below that, while doubling
<code>MCMC.interval</code>. <code>MCMC.effectiveSize.order.max</code> can be used to
set the order of the AR model used to estimate the effective
sample size and the variance for the Geweke diagnostic.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.runtime.traceplot">MCMC.runtime.traceplot</code></td>
<td>
<p>Logical: If <code>TRUE</code>, plot traceplots of the MCMC
sample.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_network.output">network.output</code></td>
<td>
<p>R class with which to output networks. The options are
&quot;network&quot; (default) and &quot;edgelist.compressed&quot; (which saves space but only
supports networks without vertex attributes)</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_...">...</code></td>
<td>
<p>A dummy argument to catch deprecated or mistyped control parameters.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm_+3A_mcmc.scale">MCMC.scale</code></td>
<td>
<p>For <code>control.simulate.ergm()</code> inheriting
<code>MCMC.burnin</code> and <code>MCMC.interval</code> from the <code><a href="#topic+ergm">ergm</a></code> fit, the
multiplier for the inherited values. This can be useful because
MCMC parameters used in the fit are tuned to generate a specific
effective sample size for the sufficient statistic in a large
MCMC sample, so the inherited values might not generate
independent realisations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="stats.html#topic+simulate">simulate</a></code>
function.  See the <code>usage</code> section in <code><a href="#topic+simulate.ergm">simulate.ergm</a></code> for
details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.ergm">simulate.ergm</a></code>, <code><a href="#topic+simulate.formula">simulate.formula</a></code>.
<code><a href="#topic+control.ergm">control.ergm</a></code> performs a similar function for
<code><a href="#topic+ergm">ergm</a></code>; <code><a href="#topic+control.gof">control.gof</a></code> performs a similar function
for <code><a href="#topic+gof">gof</a></code>.
</p>

<hr>
<h2 id='ctriple-ergmTerm'>Cyclic triples</h2><span id='topic+ctriple-ergmTerm'></span><span id='topic+InitErgmTerm.ctriple'></span><span id='topic+InitErgmTerm.ctriad'></span><span id='topic+ctriad-ergmTerm'></span>

<h3>Description</h3>

<p>By default, this term adds one
statistic to the model, equal to the number of cyclic triples in the
network, defined as a set of edges of the form <code class="reqn">\{(i{\rightarrow}j), (j{\rightarrow}k), (k{\rightarrow}i)\}</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: ctriple(attr=NULL, diff=FALSE, levels=NULL)

# binary: ctriad
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctriple-ergmTerm_+3A_attr">attr</code>, <code id="ctriple-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>quantitative attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.) If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code> , then the statistic is the number of cyclic triples where all
three nodes have the same value of the attribute. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code> , then one statistic is added to the model for each value of <code>attr</code>, equal to the number of cyclic triples where all
three nodes have that value of the attribute.</p>
</td></tr>
<tr><td><code id="ctriple-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>specifies the value of <code>attr</code> to consider if <code>attr</code> is passed and <code>diff=TRUE</code>. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>
<p>for all directed networks, <code>triangle</code> is equal to
<code>ttriple+ctriple</code> , so at most two of these three terms can be in a
model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, triad-related, binary</p>


<hr>
<h2 id='Curve-ergmTerm'>Impose a curved structure on term parameters</h2><span id='topic+Curve-ergmTerm'></span><span id='topic+InitErgmTerm.Curve'></span><span id='topic+InitErgmTerm.Parametrise'></span><span id='topic+Parametrise-ergmTerm'></span><span id='topic+InitErgmTerm.Parametrize'></span><span id='topic+Parametrize-ergmTerm'></span><span id='topic+InitWtErgmTerm.Curve'></span><span id='topic+InitWtErgmTerm.Parametrise'></span><span id='topic+InitWtErgmTerm.Parametrize'></span>

<h3>Description</h3>

<p>Arguments may have the same forms as in the API, but for convenience, alternative forms are accepted.
</p>
<p>If the model in <code>formula</code> is curved, then the outputs of this operator term's <code>map</code> argument will be used as inputs to the curved terms of the <code>formula</code> model.
</p>
<p><code>Curve</code> is an obsolete alias and may be deprecated and removed in a future release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Curve(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)

# binary: Parametrise(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf,
#           cov=NULL)

# binary: Parametrize(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf,
#           cov=NULL)

# valued: Curve(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)

# valued: Parametrise(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf,
#           cov=NULL)

# valued: Parametrize(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf,
#           cov=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Curve-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Curve-ergmTerm_+3A_params">params</code></td>
<td>
<p>a named list whose names are the curved parameter names, may also be a character vector with names.</p>
</td></tr>
<tr><td><code id="Curve-ergmTerm_+3A_map">map</code></td>
<td>
<p>the mapping from curved to canonical. May have the following forms:
</p>

<ul>
<li><p> a <code style="white-space: pre;">&#8288;function(x, n, ...)&#8288;</code> treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code> , if present, passed in <code>...</code> . The function must return a numeric vector of length <code>n</code> .
</p>
</li>
<li><p> a numeric vector to fix the output coefficients, like in an offset.
</p>
</li>
<li><p> a character string to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>

<ul>
<li> <p><code>"rep"</code> recycle the input vector to the length of the output vector as a <code>rep</code> function would.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="Curve-ergmTerm_+3A_gradient">gradient</code></td>
<td>
<p>its gradient function. It is optional if <code>map</code> is constant or one of the predefined forms; otherwise it must have one of the following forms:
</p>

<ul>
<li><p> a <code style="white-space: pre;">&#8288;function(x, n, ...)&#8288;</code> treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code> , if present, passed in <code>...</code> . The function must return a numeric matrix with <code>length(params)</code> rows and <code>n</code> columns.
</p>
</li>
<li><p> a numeric matrix to fix the gradient; this is useful when map is linear.
</p>
</li>
<li><p> a character string to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>

<ul>
<li> <p><code>"linear"</code> calculate the (constant) gradient matrix using finite differences. Note that this will be done only once at the initialization stage, so use only if you are certain <code>map</code> is, in fact, linear.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="Curve-ergmTerm_+3A_minpar">minpar</code>, <code id="Curve-ergmTerm_+3A_maxpar">maxpar</code></td>
<td>
<p>the minimum and maximum allowed curved parameter values. The parameters will be recycled to the appropriate length.</p>
</td></tr>
<tr><td><code id="Curve-ergmTerm_+3A_cov">cov</code></td>
<td>
<p>optional</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary, valued</p>


<hr>
<h2 id='cycle-ergmTerm'>k-Cycle Census</h2><span id='topic+cycle-ergmTerm'></span><span id='topic+InitErgmTerm.cycle'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each value of <code>k</code> ,
corresponding to the number of <code>k</code> -cycles (or, alternately, semicycles)
in the graph.
</p>
<p>This term can be used with either directed or undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: cycle(k, semi=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycle-ergmTerm_+3A_k">k</code></td>
<td>
<p>a vector of integers giving the cycle lengths to count.
Directed cycle lengths may range from <code>2</code> to <code>N</code> (the network size); undirected
cycle lengths and semicycle lengths may range from <code>3</code> to <code>N</code> ; length 2 semicycles
are not currently supported.</p>
</td></tr>
<tr><td><code id="cycle-ergmTerm_+3A_semi">semi</code></td>
<td>
<p>an optional logical indicating whether semicycles
(rather than directed cycles) should be counted; this is ignored in the
undirected case.</p>
</td></tr>
<tr><td><code id="cycle-ergmTerm_+3A_directed">directed</code></td>
<td>
<p>2-cycles are equivalent to mutual dyads.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected, binary</p>


<hr>
<h2 id='cyclicalties-ergmTerm'>Cyclical ties</h2><span id='topic+cyclicalties-ergmTerm'></span><span id='topic+InitErgmTerm.cyclicalties'></span><span id='topic+InitWtErgmTerm.cyclicalties'></span>

<h3>Description</h3>

<p>This term adds one statistic, equal to the number of ties
<code class="reqn">i\rightarrow j</code> such that there exists a two-path from
<code class="reqn">j</code> to <code class="reqn">i</code> . (Related to the <code>ttriple</code> term.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: cyclicalties(attr=NULL, levels=NULL)

# valued: cyclicalties(threshold=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyclicalties-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>quantitative attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.) If set, all three nodes involved ( <code class="reqn">i</code> , <code class="reqn">j</code> , and the node on the two-path) must match
on this attribute in order for <code class="reqn">i\rightarrow j</code> to be counted.</p>
</td></tr>
<tr><td><code id="cyclicalties-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected, binary, valued</p>


<hr>
<h2 id='cyclicalweights-ergmTerm'>Cyclical weights</h2><span id='topic+cyclicalweights-ergmTerm'></span><span id='topic+InitWtErgmTerm.cyclicalweights'></span>

<h3>Description</h3>

<p>This statistic implements the cyclical weights
statistic, like that defined by Krivitsky (2012), Equation 13,
but with the focus dyad being <code class="reqn">y_{j,i}</code> rather than
<code class="reqn">y_{i,j}</code> . For each option,
the first (and the default) is more stable but also more
conservative, while the second is more sensitive but more likely
to induce a multimodal distribution of networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: cyclicalweights(twopath="min", combine="max", affect="min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyclicalweights-ergmTerm_+3A_twopath">twopath</code></td>
<td>
<p>the minimum of the constituent dyads ( <code>"min"</code> ) or their geometric mean
( <code>"geomean"</code> )</p>
</td></tr>
<tr><td><code id="cyclicalweights-ergmTerm_+3A_combine">combine</code></td>
<td>
<p>the maximum of the
2-path strengths ( <code>"max"</code> ) or their sum ( <code>"sum"</code> )</p>
</td></tr>
<tr><td><code id="cyclicalweights-ergmTerm_+3A_affected">affected</code></td>
<td>
<p>the minimum of the focus dyad and the
combined strength of the two paths ( <code>"min"</code> ) or their
geometric mean ( <code>"geomean"</code> )</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, nonnegative, undirected, valued</p>


<hr>
<h2 id='degcor-ergmTerm'>Degree Correlation</h2><span id='topic+degcor-ergmTerm'></span><span id='topic+InitErgmTerm.degcor'></span>

<h3>Description</h3>

<p>This term adds one network statistic equal to the correlation
of the degrees of all pairs of nodes in the network which are tied.
Only coded for undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degcor
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>undirected, binary</p>


<hr>
<h2 id='degcrossprod-ergmTerm'>Degree Cross-Product</h2><span id='topic+degcrossprod-ergmTerm'></span><span id='topic+InitErgmTerm.degcrossprod'></span>

<h3>Description</h3>

<p>This term adds one network statistic equal to the mean of the cross-products
of the degrees of all pairs of nodes in the network which are tied.
Only coded for undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degcrossprod
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>undirected, binary</p>


<hr>
<h2 id='degrange-ergmTerm'>Degree range</h2><span id='topic+degrange-ergmTerm'></span><span id='topic+InitErgmTerm.degrange'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element of <code>from</code> (or <code>to</code> ); the <code class="reqn">i</code> th
such statistic equals the number of nodes in the network of degree
greater than or equal to
<code>from[i]</code> but strictly less than <code>to[i]</code> , i.e. with edges
in semiopen interval <code style="white-space: pre;">&#8288;[from,to)&#8288;</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degrange-ergmTerm_+3A_from">from</code>, <code id="degrange-ergmTerm_+3A_to">to</code></td>
<td>
<p>vectors of distinct integers. If one of the vectors have length 1, it is recycled to the length of the other. Otherwise, it must have the same length.</p>
</td></tr>
<tr><td><code id="degrange-ergmTerm_+3A_by">by</code>, <code id="degrange-ergmTerm_+3A_levels">levels</code>, <code id="degrange-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term can only be used with undirected networks; for directed networks
see <code>idegrange</code> and <code>odegrange</code> . This term can be used
with bipartite networks, and will count nodes of both first and second mode in
the specified degree range. To count only nodes of the first mode (&quot;actors&quot;), use <code>b1degrange</code>
and to count only those fo the second mode (&quot;events&quot;), use <code>b2degrange</code> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='degree-ergmTerm'>Degree</h2><span id='topic+degree-ergmTerm'></span><span id='topic+InitErgmTerm.degree'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element in <code>d</code> ; the <code class="reqn">i</code> th
such statistic equals the number of nodes in the network of degree
<code>d[i]</code> , i.e. with exactly <code>d[i]</code> edges.
This term can only be used with undirected networks; for directed networks
see <code>idegree</code> and <code>odegree</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degree(d, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree-ergmTerm_+3A_d">d</code></td>
<td>
<p>vector of distinct integers</p>
</td></tr>
<tr><td><code id="degree-ergmTerm_+3A_by">by</code>, <code id="degree-ergmTerm_+3A_levels">levels</code>, <code id="degree-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, frequently-used, undirected, binary</p>


<hr>
<h2 id='degree1.5-ergmTerm'>Degree to the 3/2 power</h2><span id='topic+degree1.5-ergmTerm'></span><span id='topic+InitErgmTerm.degree1.5'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equaling the sum over
the actors of each actor's degree taken to the 3/2 power (or,
equivalently, multiplied by its square root). This term is an
undirected analog to the terms of Snijders et al. (2010), equations
(11) and (12). This term can only be used with undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degree1.5
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>undirected, binary</p>


<hr>
<h2 id='degreedist'>Computes and Returns the Degree Distribution Information for a Given Network</h2><span id='topic+degreedist'></span><span id='topic+degreedist.network'></span>

<h3>Description</h3>

<p>The <code>degreedist</code> generic computes and returns the degree
distribution (number of vertices in the network with each degree
value) for a given network. This help page documents the
function. For help about <a href="#topic+degreedist-ergmConstraint">the ERGM sample space constraint with that name</a>, try
<code>help("degreedist-constraint")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degreedist(object, ...)

## S3 method for class 'network'
degreedist(object, print = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degreedist_+3A_object">object</code></td>
<td>
<p>a <code>network</code> object or some other object for
which degree distribution is meaningful.</p>
</td></tr>
<tr><td><code id="degreedist_+3A_...">...</code></td>
<td>
<p>Additional arguments to functions.</p>
</td></tr>
<tr><td><code id="degreedist_+3A_print">print</code></td>
<td>
<p>logical, whether to print the degree distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If directed, a matrix of the distributions of in and out
degrees; this is row bound and only contains degrees for which
one of the in or out distributions has a positive count.  If
bipartite, a list containing the degree distributions of b1 and
b2.  Otherwise, a vector of the positive values in the degree
distribution
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>degreedist(network)</code>: Method for <code><a href="network.html#topic+network">network</a></code> objects.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
degreedist(faux.mesa.high)

</code></pre>

<hr>
<h2 id='degreedist-ergmConstraint'>Preserve the degree distribution of the given network</h2><span id='topic+degreedist-ergmConstraint'></span><span id='topic+InitErgmConstraint.degreedist'></span>

<h3>Description</h3>

<p>Only networks
whose degree distributions are the same as those in the network passed
in the model formula have non-zero probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># degreedist
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected</p>


<hr>
<h2 id='degrees-ergmConstraint'>Preserve the degree of each vertex of the given network</h2><span id='topic+degrees-ergmConstraint'></span><span id='topic+InitErgmConstraint.degrees'></span><span id='topic+InitErgmConstraint.nodedegrees'></span><span id='topic+nodedegrees-ergmConstraint'></span>

<h3>Description</h3>

<p>Only networks
whose vertex degrees are the same as those in the network passed
in the model formula have non-zero probability. If the network is
directed, both indegree and outdegree are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># degrees

# nodedegrees
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected</p>


<hr>
<h2 id='density-ergmTerm'>Density</h2><span id='topic+density-ergmTerm'></span><span id='topic+InitErgmTerm.density'></span>

<h3>Description</h3>

<p>This term adds one network statistic equal to the density of the network.
For undirected networks, <code>density</code> equals <code>kstar(1)</code> or
<code>edges</code> divided by <code class="reqn">n(n-1)/2</code> ; for directed networks,
<code>density</code> equals <code>edges</code> or <code>istar(1)</code> or <code>ostar(1)</code>
divided by <code class="reqn">n(n-1)</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: density
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, binary</p>


<hr>
<h2 id='diff-ergmTerm'>Difference</h2><span id='topic+diff-ergmTerm'></span><span id='topic+InitErgmTerm.diff'></span><span id='topic+InitWtErgmTerm.diff'></span>

<h3>Description</h3>

<p>For values of <code>pow</code> other than
<code>0</code> , this term adds one network statistic to the model,
equaling the sum, over directed edges <code class="reqn">(i,j)</code> , of
<code>sign.action(attr[i]-attr[j])^pow</code> if <code>dir</code> is
<code>"t-h"</code> and of <code>sign.action(attr[j]-attr[i])^pow</code> if
<code>"h-t"</code> . That is, the
argument <code>dir</code> determines which vertex's attribute is
subtracted from which, with tail being the origin of a directed edge
and head being its destination, and bipartite networks' edges being
treated as going from the first part (b1) to the second (b2).
</p>
<p>If <code>pow==0</code> , the exponentiation is replaced by the signum
function: <code>+1</code> if the difference is positive, <code>0</code> if there
is no difference, and <code>-1</code> if the difference is negative. Note
that this function is applied after the
<code>sign.action</code> . The comparison is exact, so when using
calculated values of <code>attr</code> , ensure that values that you
want to be considered equal are, in fact, equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: diff(attr, pow=1, dir="t-h", sign.action="identity")

# valued: diff(attr, pow=1, dir="t-h", sign.action="identity", form ="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="diff-ergmTerm_+3A_pow">pow</code></td>
<td>
<p>exponent for the node difference</p>
</td></tr>
<tr><td><code id="diff-ergmTerm_+3A_dir">dir</code></td>
<td>
<p>determines which vertix's attribute is subtracted from which. Accepts: <code>"t-h"</code> (the default), <code>"tail-head"</code> , <code>"b1-b2"</code>, <code>"h-t"</code> , <code>"head-tail"</code> , and <code>"b2-b1"</code> .</p>
</td></tr>
<tr><td><code id="diff-ergmTerm_+3A_sign.action">sign.action</code></td>
<td>
<p>one of <code>"identity"</code>, <code>"abs"</code>, <code>"posonly"</code>, <code>"negonly"</code>. The following <code>sign.actions</code> are possible:
</p>

<ul>
<li> <p><code>"identity"</code> (the default) no transformation of the
difference regardless of sign
</p>
</li>
<li> <p><code>"abs"</code> absolute value of the difference: equivalent
to the absdiff term
</p>
</li>
<li> <p><code>"posonly"</code> positive differences are kept, negative
differences are replaced by 0
</p>
</li>
<li> <p><code>"negonly"</code> negative differences are kept, positive
differences are replaced by 0
</p>
</li></ul>
</td></tr>
<tr><td><code id="diff-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this term may not be meaningful for unipartite undirected
networks unless <code>sign.action=="abs"</code> . When used on such a
network, it behaves as if all edges were directed, going from the
lower-indexed vertex to the higher-indexed vertex.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, directed, dyad-independent, frequently-used, quantitative nodal attribute, undirected, binary, valued</p>


<hr>
<h2 id='DiscUnif-ergmProposal'>TODO</h2><span id='topic+DiscUnif-ergmProposal'></span><span id='topic+InitWtErgmProposal.DiscUnif'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='DiscUnif-ergmReference'>Discrete Uniform reference</h2><span id='topic+DiscUnif-ergmReference'></span><span id='topic+InitErgmReference.DiscUnif'></span>

<h3>Description</h3>

<p>Specifies each dyad's baseline distribution to be discrete uniform
between <code>a</code> and <code>b</code> (both inclusive): <code class="reqn">h(y)=1</code> , with
the support being
<code>a</code>, <code>a+1</code>, ..., <code>b-1</code>, <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># DiscUnif(a,b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscUnif-ergmReference_+3A_a">a</code>, <code id="DiscUnif-ergmReference_+3A_b">b</code></td>
<td>
<p>minimum and maximum to the baseline discrete uniform distribution, both inclusive. Both values must be finite.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmReference">ergmReference</a></code> for index of reference distributions currently visible to the package.
</p>


<h4>Keywords</h4>

<p>discrete, finite</p>


<hr>
<h2 id='DiscUnif2-ergmProposal'>TODO</h2><span id='topic+DiscUnif2-ergmProposal'></span><span id='topic+InitWtErgmProposal.DiscUnif2'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='DiscUnifNonObserved-ergmProposal'>TODO</h2><span id='topic+DiscUnifNonObserved-ergmProposal'></span><span id='topic+InitWtErgmProposal.DiscUnifNonObserved'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='DistRLE-ergmProposal'>TODO</h2><span id='topic+DistRLE-ergmProposal'></span><span id='topic+InitWtErgmProposal.DistRLE'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='dsp-ergmTerm'>Directed dyadwise shared partners</h2><span id='topic+dsp-ergmTerm'></span><span id='topic+InitErgmTerm.ddsp'></span><span id='topic+ddsp-ergmTerm'></span><span id='topic+InitErgmTerm.dsp'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code> th such statistic equals the number of dyads in the network with exactly <code>d[i]</code> shared partners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: ddsp(d, type="OTP")

# binary: dsp(d, type="OTP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsp-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="dsp-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>
<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='dyadcov-ergmTerm'>Dyadic covariate</h2><span id='topic+dyadcov-ergmTerm'></span><span id='topic+InitErgmTerm.dyadcov'></span>

<h3>Description</h3>

<p>This term adds three statistics to the model, each equal to the sum of the
covariate values for all dyads occupying one of the three possible non-empty
dyad states (mutual, upper-triangular asymmetric, and lower-triangular
asymmetric dyads, respectively), with the empty or null state serving as a
reference category. If the network is undirected, <code>x</code> is either a
matrix of edgewise covariates, or a network; if the latter, optional
argument <code>attrname</code> provides the name of the edge attribute to use for
edge values. This term adds one statistic to the model, equal to the sum of
the covariate values for each edge appearing in the network. The
<code>edgecov</code> and <code>dyadcov</code> terms are equivalent for undirected
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dyadcov(x, attrname=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyadcov-ergmTerm_+3A_x">x</code>, <code id="dyadcov-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>either a square matrix of covariates, one for
each possible edge in the network, the name of a network
attribute of covariates, or a network; if the latter, or if the
network attribute named by <code>x</code> is itself a network, optional
argument <code>attrname</code> provides the name of the quantitative edge
attribute to use for covariate values (in this case, missing
edges in <code>x</code> are assigned a covariate value of zero).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, quantitative dyadic attribute, undirected, binary</p>


<hr>
<h2 id='dyadnoise-ergmConstraint'>A soft constraint to adjust the sampled distribution for
dyad-level noise with known perturbation probabilities</h2><span id='topic+dyadnoise-ergmConstraint'></span><span id='topic+InitErgmConstraint.dyadnoise'></span>

<h3>Description</h3>

<p>It is assumed that the observed LHS network is a noisy observation of
some unobserved true network, with <code>p01</code> giving the dyadwise
probability of erroneously observing a tie where the true network
had a non-tie and <code>p10</code> giving the dyadwise probability of
erroneously observing a nontie where the true network had a tie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># dyadnoise(p01, p10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyadnoise-ergmConstraint_+3A_p01">p01</code>, <code id="dyadnoise-ergmConstraint_+3A_p10">p10</code></td>
<td>
<p>can both be scalars or both be adjacency matrices of the same dimension as that of the
LHS network giving these probabilities.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See Karwa et al. (2016) for an application.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, soft, undirected</p>


<hr>
<h2 id='dyadnoise-ergmProposal'>TODO</h2><span id='topic+dyadnoise-ergmProposal'></span><span id='topic+InitErgmProposal.dyadnoise'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='dyadnoiseTNT-ergmProposal'>TODO</h2><span id='topic+dyadnoiseTNT-ergmProposal'></span><span id='topic+InitErgmProposal.dyadnoiseTNT'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='Dyads-ergmConstraint'>Constrain fixed or varying dyad-independent terms</h2><span id='topic+Dyads-ergmConstraint'></span><span id='topic+InitErgmConstraint.Dyads'></span>

<h3>Description</h3>

<p>This is an &quot;operator&quot; constraint that takes one or two <code><a href="#topic+ergmTerm">ergmTerm</a></code> dyad-independent formulas. For the terms in the <code style="white-space: pre;">&#8288;vary=&#8288;</code> formula, only those that change at least one of the terms will be allowed to vary, and all others will be fixed. If both formulas are given, the dyads that vary either for one or for the other will be allowed to vary. Note that a formula passed to <code>Dyads</code> without an argument name will default to <code style="white-space: pre;">&#8288;fix=&#8288;</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Dyads(fix=NULL, vary=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dyads-ergmConstraint_+3A_fix">fix</code>, <code id="Dyads-ergmConstraint_+3A_vary">vary</code></td>
<td>
<p>formula with only dyad-independent terms</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, operator, undirected</p>


<hr>
<h2 id='ecoli'>Two versions of an E. Coli network dataset</h2><span id='topic+ecoli'></span><span id='topic+ecoli1'></span><span id='topic+ecoli2'></span>

<h3>Description</h3>

<p>This network data set comprises two versions of a biological network in
which the nodes are operons in <em>Escherichia Coli</em> and a directed edge
from one node to another indicates that the first encodes the transcription
factor that regulates the second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecoli)
</code></pre>


<h3>Details</h3>

<p>The network object <code>ecoli1</code> is directed, with 423 nodes and 519 arcs.
The object <code>ecoli2</code> is an undirected version of the same network, in
which all arcs are treated as edges and the five isolated nodes (which
exhibit only self-regulation in <code>ecoli1</code>) are removed, leaving 418
nodes.
</p>


<h3>Licenses and Citation</h3>

<p>When publishing results obtained using this
data set, the original authors (Salgado et al, 2001; Shen-Orr et al, 2002)
should be cited, along with this <code>R</code> package.
</p>


<h3>Source</h3>

<p>The data set is based on the RegulonDB network (Salgado et al, 2001)
and was modified by Shen-Orr et al (2002).
</p>


<h3>References</h3>

<p>Salgado et al (2001), Regulondb (version 3.2): Transcriptional Regulation
and Operon Organization in Escherichia Coli K-12, <em>Nucleic Acids
Research</em>, 29(1): 72-74.
</p>
<p>Shen-Orr et al (2002), Network Motifs in the Transcriptional Regulation
Network of Escerichia Coli, <em>Nature Genetics</em>, 31(1): 64-68.
</p>
<p>%Saul and Filkov (2007)
</p>
<p>%Hummel et al (2010)
</p>

<hr>
<h2 id='edgecov-ergmTerm'>Edge covariate</h2><span id='topic+edgecov-ergmTerm'></span><span id='topic+InitErgmTerm.edgecov'></span><span id='topic+InitWtErgmTerm.edgecov'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model, equal to the sum
of the covariate values for each edge appearing in the network. The
<code>edgecov</code> term applies to both directed and undirected networks. For
undirected networks the covariates are also assumed to be undirected. The
<code>edgecov</code> and <code>dyadcov</code> terms are equivalent for undirected
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: edgecov(x, attrname=NULL)

# valued: edgecov(x, attrname=NULL, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgecov-ergmTerm_+3A_x">x</code>, <code id="edgecov-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>either a square matrix of covariates, one for
each possible edge in the network, the name of a network
attribute of covariates, or a network; if the latter, or if the
network attribute named by <code>x</code> is itself a network, optional
argument <code>attrname</code> provides the name of the quantitative edge
attribute to use for covariate values (in this case, missing
edges in <code>x</code> are assigned a covariate value of zero).</p>
</td></tr>
<tr><td><code id="edgecov-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, frequently-used, quantitative dyadic attribute, undirected, binary, valued</p>


<hr>
<h2 id='edges-ergmConstraint'>Preserve the edge count of the given network</h2><span id='topic+edges-ergmConstraint'></span><span id='topic+InitErgmConstraint.edges'></span>

<h3>Description</h3>

<p>Only networks
having the same number of edges as the network passed
in the model formula have non-zero probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># edges
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='edges-ergmTerm'>Number of edges in the network</h2><span id='topic+edges-ergmTerm'></span><span id='topic+InitErgmTerm.edges'></span><span id='topic+InitWtErgmTerm.nonzero'></span><span id='topic+nonzero-ergmTerm'></span><span id='topic+InitWtErgmTerm.edges'></span>

<h3>Description</h3>

<p>This term adds one network statistic equal to the number of
edges (i.e. nonzero values) in the network. For undirected networks, <code>edges</code>
is equal to <code>kstar(1)</code>; for directed networks, edges is equal to both
<code>ostar(1)</code> and <code>istar(1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: edges

# valued: nonzero

# valued: edges
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, binary, valued</p>


<hr>
<h2 id='egocentric-ergmConstraint'>Preserve values of dyads incident on vertices with given attribute</h2><span id='topic+egocentric-ergmConstraint'></span><span id='topic+InitErgmConstraint.egocentric'></span>

<h3>Description</h3>

<p>Preserve values of dyads incident on vertices with attribute <code>attr</code> being <code>TRUE</code> or if <code>attrname</code> is <code>NULL</code> , the vertex attribute <code>"na"</code> being <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># egocentric(attr=NULL, direction="both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egocentric-ergmConstraint_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="egocentric-ergmConstraint_+3A_direction">direction</code></td>
<td>
<p>one of <code>"both"</code>, <code>"out"</code> and <code>"in"</code>, only applies to directed networks. <code>"out"</code> only preserves the out-dyads of those actors and <code>"in"</code> preserves their in-dyads.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected</p>


<hr>
<h2 id='enformulate.curved-deprecated'>Convert a curved ERGM into a form suitable as initial values for the same
ergm. Deprecated in 4.0.0.</h2><span id='topic+enformulate.curved-deprecated'></span><span id='topic+enformulate.curved'></span><span id='topic+enformulate.curved.ergm'></span><span id='topic+enformulate.curved.formula'></span>

<h3>Description</h3>

<p>The generic <code>enformulate.curved</code> converts an <code><a href="#topic+ergm">ergm</a></code> object
or formula of a model with curved terms to the variant in which the curved
parameters embedded into the formula and are removed from the parameter
vector. This is the form that used to be required by <code><a href="#topic+ergm">ergm</a></code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enformulate.curved(object, ...)

## S3 method for class 'ergm'
enformulate.curved(object, ...)

## S3 method for class 'formula'
enformulate.curved(object, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enformulate.curved-deprecated_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ergm">ergm</a></code> object or an ERGM formula. The curved
terms of the given formula (or the formula used in the fit) must have all of
their arguments passed by name.</p>
</td></tr>
<tr><td><code id="enformulate.curved-deprecated_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
<tr><td><code id="enformulate.curved-deprecated_+3A_theta">theta</code></td>
<td>
<p>Curved model parameter configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of a current kludge in <code><a href="#topic+ergm">ergm</a></code>, output from one run
cannot be directly passed as initial values (<code>control.ergm(init=)</code>) for
the next run if any of the terms are curved. One workaround is to embed the
curved parameters into the formula (while keeping <code>fixed=FALSE</code>) and
remove them from <code>control.ergm(init=)</code>.
</p>
<p>This function automates this process for curved ERGM terms included with the
<code><a href="#topic+ergm-package">ergm</a></code> package. It does not work with curved
terms not included in ergm.
</p>


<h3>Value</h3>

<p>A list with the following components: </p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>The formula
with curved parameter estimates incorporated.</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>The coefficient
vector with curved parameter estimates removed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm</a></code>, <code><a href="#topic+simulate.ergm">simulate.ergm</a></code>
</p>

<hr>
<h2 id='equalto-ergmTerm'>Number of dyads with values equal to a specific value (within tolerance)</h2><span id='topic+equalto-ergmTerm'></span><span id='topic+InitWtErgmTerm.equalto'></span>

<h3>Description</h3>

<p>Adds one statistic equal to the number of dyads whose values
are within <code>tolerance</code> of <code>value</code> , i.e., between
<code>value-tolerance</code> and <code>value+tolerance</code> , inclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: equalto(value=0, tolerance=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equalto-ergmTerm_+3A_value">value</code></td>
<td>
<p>numerical threshold</p>
</td></tr>
<tr><td><code id="equalto-ergmTerm_+3A_tolerance">tolerance</code></td>
<td>
<p>numerical threshold</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, valued</p>


<hr>
<h2 id='ergm'>Exponential-Family Random Graph Models</h2><span id='topic+ergm'></span><span id='topic+is.ergm'></span><span id='topic+ergm.object'></span><span id='topic+is.na.ergm'></span><span id='topic+anyNA.ergm'></span><span id='topic+nobs.ergm'></span><span id='topic+print.ergm'></span><span id='topic+vcov.ergm'></span>

<h3>Description</h3>

<p><code><a href="#topic+ergm">ergm</a></code> is used to fit exponential-family random graph
models (ERGMs), in which
the probability of a given network, <code class="reqn">y</code>, on a set of nodes is
<code class="reqn">h(y) \exp\{\eta(\theta) \cdot
g(y)\}/c(\theta)</code>, where
<code class="reqn">h(y)</code> is the reference measure (usually <code class="reqn">h(y)=1</code>),
<code class="reqn">g(y)</code> is a vector of network statistics for <code class="reqn">y</code>,
<code class="reqn">\eta(\theta)</code> is a natural parameter vector of the same
length (with <code class="reqn">\eta(\theta)=\theta</code> for most terms), and <code class="reqn">c(\theta)</code> is the
normalizing constant for the distribution.
<code><a href="#topic+ergm">ergm</a></code> can return a maximum pseudo-likelihood
estimate, an approximate maximum likelihood estimate based on a Monte
Carlo scheme, or an approximate contrastive divergence estimate based
on a similar scheme.
(For an overview of the package (Hunter et al. 2008; Krivitsky et al. 2023), see <code><a href="#topic+ergm-package">ergm-package</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm(
  formula,
  response = NULL,
  reference = ~Bernoulli,
  constraints = ~.,
  obs.constraints = ~. - observed,
  offset.coef = NULL,
  target.stats = NULL,
  eval.loglik = getOption("ergm.eval.loglik"),
  estimate = c("MLE", "MPLE", "CD"),
  control = control.ergm(),
  verbose = FALSE,
  ...,
  basis = ergm.getnetwork(formula),
  newnetwork = c("one", "all", "none")
)

is.ergm(object)

## S3 method for class 'ergm'
is.na(x)

## S3 method for class 'ergm'
anyNA(x, ...)

## S3 method for class 'ergm'
nobs(object, ...)

## S3 method for class 'ergm'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'ergm'
vcov(object, sources = c("all", "model", "estimation"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_+3A_formula">formula</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+formula">formula</a></code> object, of the form
<code>y ~ &lt;model terms&gt;</code>, where <code>y</code> is a
<code><a href="network.html#topic+network">network</a></code> object or a matrix that can be
coerced to a <code><a href="network.html#topic+network">network</a></code> object.  For the
details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="#topic+ergmTerm">ergmTerm</a></code> and Morris, Handcock and Hunter (2008)
for binary ERGM terms and Krivitsky (2012) for valued ERGM terms
(terms for weighted edges).  To create a
<code><a href="network.html#topic+network">network</a></code> object in <span class="rlang"><b>R</b></span>, use the
<code>network()</code> function, then add nodal attributes to it using
the <code>%v%</code> operator if necessary. Enclosing a model term in
<code>offset()</code> fixes its value to one specified in
<code>offset.coef</code>.  (A second argument&mdash;a logical or numeric
index vector&mdash;can be used to select <em>which</em> of the parameters
within the term are offsets.)</p>
</td></tr>
<tr><td><code id="ergm_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ergm_+3A_reference">reference</code></td>
<td>
<p>A one-sided formula specifying
the reference measure (<code class="reqn">h(y)</code>) to be used.
See help for <a href="#topic+ergm-references">ERGM reference measures</a> implemented in the
<strong><a href="#topic+ergm-package">ergm</a></strong> package.</p>
</td></tr>
<tr><td><code id="ergm_+3A_constraints">constraints</code></td>
<td>
<p>A formula specifying one or more constraints
on the support of the distribution of the networks being modeled. Multiple constraints
may be given, separated by &ldquo;+&rdquo; and &ldquo;-&rdquo; operators. See
<code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for the detailed explanation of
their semantics and also for an indexed list of the constraints visible to the <span class="pkg">ergm</span> package.
</p>
<p>The default is to have no constraints except those provided through
the <code><a href="#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>Together with the model terms in the formula and the reference measure, the constraints
define the distribution of networks being modeled.
</p>
<p>It is also possible to specify a proposal function directly either
by passing a string with the function's name (in which case,
arguments to the proposal should be specified through the
<code>MCMC.prop.args</code> argument to the relevant control function, or
by giving it on the LHS of the hints formula to <code>MCMC.prop</code>
argument to the control function. This will override
the one chosen automatically.
</p>
<p>Note that not all possible combinations of constraints and reference
measures are supported. However, for relatively simple constraints
(i.e., those that simply permit or forbid specific dyads or sets of
dyads from changing), arbitrary combinations should be possible.</p>
</td></tr>
<tr><td><code id="ergm_+3A_obs.constraints">obs.constraints</code></td>
<td>
<p>A one-sided formula specifying one or more
constraints or other modification <em>in addition</em> to those
specified by <code>constraints</code>, following the same syntax as the
<code>constraints</code> argument.
</p>
<p>This allows the domain of the integral in the numerator of the
partially obseved network face-value likelihoods of Handcock and
Gile (2010) and Karwa et al. (2017) to be specified explicitly.
</p>
<p>The default is to constrain the integral to only integrate over
the missing dyads (if present), after incorporating constraints
provided through the <code><a href="#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>It is also possible to specify a proposal function directly by
passing a string with the function's name of the <code>obs.MCMC.prop</code>
argument to the relevant control function. In that case,
arguments to the proposal should be specified through the
<code>obs.prop.args</code> argument to the relevant control function.</p>
</td></tr>
<tr><td><code id="ergm_+3A_offset.coef">offset.coef</code></td>
<td>
<p>A vector of coefficients for the offset terms.</p>
</td></tr>
<tr><td><code id="ergm_+3A_target.stats">target.stats</code></td>
<td>
<p>vector of &quot;observed network statistics,&quot;
if these statistics are for some reason different than the
actual statistics of the network on the left-hand side of
<code>formula</code>.
Equivalently, this vector is the mean-value parameter values for the
model.  If this is given, the algorithm finds the natural
parameter values corresponding to these mean-value parameters.
If <code>NULL</code>, the mean-value parameters used are the observed
statistics of the network in the formula.
</p>
</td></tr>
<tr><td><code id="ergm_+3A_eval.loglik">eval.loglik</code></td>
<td>
<p>Logical:  For dyad-dependent models, if TRUE, use bridge
sampling to evaluate the log-likelihoood associated with the
fit. Has no effect for dyad-independent models.
Since bridge sampling takes additional time, setting to FALSE may
speed performance if likelihood values (and likelihood-based
values like AIC and BIC) are not needed. Can be set globally via <code>option(ergm.eval.loglik=...)</code>, which is set to <code>TRUE</code> when the package is loaded. (See <code><a href="#topic+ergm-options">options?ergm</a></code>.)
</p>
</td></tr>
<tr><td><code id="ergm_+3A_estimate">estimate</code></td>
<td>
<p>If &quot;MPLE,&quot; then the maximum pseudolikelihood estimator
is returned.  If &quot;MLE&quot; (the default), then an approximate maximum likelihood
estimator is returned.  For certain models, the MPLE and MLE are equivalent,
in which case this argument is ignored.  (To force MCMC-based approximate
likelihood calculation even when the MLE and MPLE are the same, see the
<code>force.main</code> argument of <code><a href="#topic+control.ergm">control.ergm</a></code>. If &quot;CD&quot; (<em>EXPERIMENTAL</em>),
the Monte-Carlo contrastive divergence estimate is returned. )
</p>
</td></tr>
<tr><td><code id="ergm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.ergm">control.ergm()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
<tr><td><code id="ergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergm_+3A_...">...</code></td>
<td>
<p>Additional
arguments, to be passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="ergm_+3A_basis">basis</code></td>
<td>
<p>a value (usually a <code><a href="network.html#topic+network">network</a></code>) to override the LHS of the formula.</p>
</td></tr>
<tr><td><code id="ergm_+3A_newnetwork">newnetwork</code></td>
<td>
<p>One of <code>"one"</code> (the default), <code>"all"</code>, or
<code>"none"</code> (or, equivalently, <code>FALSE</code>), specifying whether the
network(s) from the last iteration of the MCMC sampling should be
returned as a part of the fit as a elements <code>newnetwork</code> and
<code>newnetworks</code>. (See their entries in section Value below for
details.) Partial matching is supported.</p>
</td></tr>
<tr><td><code id="ergm_+3A_object">object</code></td>
<td>
<p>an <code>ergm</code> object.</p>
</td></tr>
<tr><td><code id="ergm_+3A_x">x</code>, <code id="ergm_+3A_digits">digits</code></td>
<td>
<p>See <code><a href="base.html#topic+print">print()</a></code>.</p>
</td></tr>
<tr><td><code id="ergm_+3A_sources">sources</code></td>
<td>
<p>For the <code>vcov</code> method, specify whether to return
the covariance matrix from the ERGM model, the estimation
process, or both combined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+ergm">ergm</a></code> returns an object of class <code><a href="#topic+ergm">ergm</a></code> that is a list
consisting of the following elements:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>The Monte Carlo maximum likelihood estimate
of <code class="reqn">\theta</code>, the vector of coefficients for the model
parameters.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>The <code class="reqn">n\times p</code> matrix of network statistics,
where <code class="reqn">n</code> is the
sample size and <code class="reqn">p</code> is the number of network statistics specified in the
model, generated by the last iteration of the MCMC-based likelihood maximization routine. These statistics are centered with respect to the observed statistics or <code>target.stats</code>, unless missing data MLE is used.</p>
</td></tr>
<tr><td><code>sample.obs</code></td>
<td>
<p>As <code>sample</code>, but for the constrained sample.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of Newton-Raphson iterations required
before convergence.</p>
</td></tr>
<tr><td><code>MCMCtheta</code></td>
<td>
<p>The value of <code class="reqn">\theta</code> used to produce the Markov chain
Monte Carlo sample.  As long as the Markov chain mixes sufficiently
well, <code>sample</code> is roughly a random sample from the distribution
of network statistics specified by the model with the parameter equal
to <code>MCMCtheta</code>.  If <code>estimate="MPLE"</code> then
<code>MCMCtheta</code> equals the MPLE.</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>
<p>The approximate change in log-likelihood
in the last iteration.
The value is only approximate because it is estimated based
on the MCMC random sample.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>The value of the gradient vector of the approximated
loglikelihood function, evaluated at the maximizer.  This vector
should be very close to zero.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>Approximate covariance matrix for the MLE, based on the inverse
Hessian of the approximated loglikelihood evaluated at the maximizer.</p>
</td></tr>
<tr><td><code>failure</code></td>
<td>
<p>Logical:  Did the MCMC estimation fail?</p>
</td></tr>
<tr><td><code>network</code></td>
<td>
<p>Network passed on the left-hand side of <code>formula</code>. If <code>target.stats</code> are passed, it is replaced by the network returned by <code><a href="#topic+san">san()</a></code>.</p>
</td></tr>
<tr><td><code>newnetworks</code></td>
<td>
<p>If argument <code>newnetwork</code> is <code>"all"</code>, a list of the final networks at the end of the MCMC
simulation, one for each thread.</p>
</td></tr>
<tr><td><code>newnetwork</code></td>
<td>
<p>If argument <code>newnetwork</code> is <code>"one"</code> or <code>"all"</code>, the first (possibly only) element of <code>newnetworks</code>.</p>
</td></tr>
<tr><td><code>coef.init</code></td>
<td>
<p>The initial value of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>est.cov</code></td>
<td>
<p>The covariance matrix of the model statistics in the final MCMC sample.</p>
</td></tr>
<tr><td><code>coef.hist</code>, <code>steplen.hist</code>, <code>stats.hist</code>, <code>stats.obs.hist</code></td>
<td>

<p>For the MCMLE method, the history of coefficients, Hummel step lengths, and average model statistics for each iteration..
</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>The control list passed to the call.</p>
</td></tr>
<tr><td><code>etamap</code></td>
<td>
<p>The set of functions mapping the true parameter theta
to the canonical parameter eta (irrelevant except in a curved exponential
family model)</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The original <code><a href="stats.html#topic+formula">formula</a></code> entered into the <code><a href="#topic+ergm">ergm</a></code> function.</p>
</td></tr>
<tr><td><code>target.stats</code></td>
<td>
<p>The target.stats used during estimation (passed through from the Arguments)</p>
</td></tr>
<tr><td><code>target.esteq</code></td>
<td>
<p>Used for curved models to preserve the target mean values of the curved terms. It is identical to target.stats for non-curved models.</p>
</td></tr>
<tr><td><code>constraints</code></td>
<td>
<p>Constraints used during estimation (passed through from the Arguments)</p>
</td></tr>
<tr><td><code>reference</code></td>
<td>
<p>The reference measure used during estimation (passed through from the Arguments)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimation method used (passed through from the Arguments).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>vector of logical telling which model parameters are to be set
at a fixed value (i.e., not estimated).</p>
</td></tr>
<tr><td><code>drop</code></td>
<td>
<p>If <code><a href="#topic+control.ergm">control$drop</a>=TRUE</code>, a numeric vector indicating which terms were dropped due to to extreme values of the
corresponding statistics on the observed network, and how:
</p>

<dl>
<dt><code>0</code></dt><dd><p>The term was not dropped.</p>
</dd>
<dt><code>-1</code></dt><dd><p>The term was at its minimum and the coefficient was fixed at
<code>-Inf</code>.</p>
</dd>
<dt><code>+1</code></dt><dd><p>The term was at its maximum and the coefficient was fixed at
<code>+Inf</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>estimable</code></td>
<td>
<p>A logical vector indicating which terms could not be
estimated due to a <code>constraints</code> constraint fixing that term at a
constant value.
</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>A list with miscellaneous information that would typically be accessed by the user via methods; in general, it should not be accessed directly. Current elements include: </p>

<dl>
<dt><code>terms_dind</code></dt><dd><p>Logical indicator of whether the model terms are all dyad-independent.</p>
</dd>
<dt><code>space_dind</code></dt><dd><p>Logical indicator of whether the sample space (constraints) are all dyad-independent.</p>
</dd>
<dt><code>n_info_dyads</code></dt><dd><p>Number of &ldquo;informative&rdquo; dyads: those that are observed (not missing) <em>and</em> not constrained by sample space constraints; one of the measures of sample size.</p>
</dd>
<dt><code>obs</code></dt><dd><p>Logical indicator of whether an observational (missing data) process was involved in estimation.</p>
</dd>
<dt><code>valued</code></dt><dd><p>Logical indicator of whether the model is valued.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>null.lik</code></td>
<td>
<p>Log-likelihood of the null model. Valid only for
unconstrained models.</p>
</td></tr>
<tr><td><code>mle.lik</code></td>
<td>
<p>The approximate log-likelihood for the MLE.
The value is only approximate because it is estimated based
on the MCMC random sample.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>is.na(ergm)</code>: Return <code>TRUE</code> if the ERGM was fit to a partially observed network and/or an observational process, such as missing (<code>NA</code>) dyads.
</p>
</li>
<li> <p><code>anyNA(ergm)</code>: Alias to the <code>is.na()</code> method.
</p>
</li>
<li> <p><code>nobs(ergm)</code>: Return the number of informative dyads of a model fit.
</p>
</li>
<li> <p><code>print(ergm)</code>: Print the call, the estimate, and the method used to obtain it.
</p>
</li>
<li> <p><code>vcov(ergm)</code>: extracts the variance-covariance matrix of
parameter estimates.
</p>
</li></ul>


<h3>Notes on model specification</h3>

<p>Although each of the statistics in a given model is a summary
statistic for the entire network, it is rarely necessary to
calculate statistics for an entire network
in a proposed Metropolis-Hastings step.
Thus, for example, if the triangle term is included in the model,
a census of all triangles in the observed network is never
taken; instead, only the change in the number of triangles
is recorded for each edge toggle.
</p>
<p>In the implementation of <code><a href="#topic+ergm">ergm</a></code>, the model is
initialized in <span class="rlang"><b>R</b></span>, then all the model information is passed to a C
program that generates the sample of network statistics using MCMC.
This sample is then returned to <span class="rlang"><b>R</b></span>, which then uses one of several
algorithms, selected by <code style="white-space: pre;">&#8288;main.method=&#8288;</code> <code><a href="#topic+control.ergm">control.ergm()</a></code> parameter
to update the estimate.
</p>
<p>The mechanism for proposing new networks for the MCMC sampling
scheme, which is a Metropolis-Hastings algorithm, depends on
two things:  The <code>constraints</code>, which define the set of possible
networks that could be proposed in a particular Markov chain step,
and the weights placed on these possible steps by the
proposal distribution.  The former may be controlled using the
<code>constraints</code> argument described above.  The latter may
be controlled using the <code>prop.weights</code> argument to the
<code><a href="#topic+control.ergm">control.ergm</a></code> function.
</p>
<p>The package is designed so that the user could conceivably add additional
proposal types.
</p>


<h3>References</h3>

<p>Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008).
&ldquo;ergm: A Package to Fit, Simulate and Diagnose Exponential-Family Models for Networks.&rdquo;
<em>Journal of Statistical Software</em>, <b>24</b>(3), 1&ndash;29.
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>.<br /><br /> Krivitsky PN, Hunter DR, Morris M, Klumb C (2023).
&ldquo;ergm 4: New Features for Analyzing Exponential-Family Random Graph Models.&rdquo;
<em>Journal of Statistical Software</em>, <b>105</b>(6), 1&ndash;44.
<a href="https://doi.org/10.18637/jss.v105.i06">doi:10.18637/jss.v105.i06</a>.
</p>
<p>Admiraal R, Handcock MS (2007).
<span class="pkg">networksis</span>: Simulate bipartite graphs with fixed
marginals through sequential importance sampling.
Statnet Project, Seattle, WA.
Version 1. <a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Bender-deMoll S, Morris M, Moody J (2008).
Prototype Packages for Managing and Animating Longitudinal
Network Data: <span class="pkg">dynamicnetwork</span> and <span class="pkg">rSoNIA</span>.
<em>Journal of Statistical Software</em>, 24(7).
<a href="https://doi.org/10.18637/jss.v024.i07">doi:10.18637/jss.v024.i07</a>
</p>
<p>Butts CT (2007).
<span class="pkg">sna</span>: Tools for Social Network Analysis.
R package version 2.3-2. <a href="https://cran.r-project.org/package=sna">https://cran.r-project.org/package=sna</a>.
</p>
<p>Butts CT (2008).
<span class="pkg">network</span>: A Package for Managing Relational Data in <span class="rlang"><b>R</b></span>.
<em>Journal of Statistical Software</em>, 24(2).
<a href="https://doi.org/10.18637/jss.v024.i02">doi:10.18637/jss.v024.i02</a>
</p>
<p>Butts C (2015).
<span class="pkg">network</span>: The Statnet Project (https://statnet.org). R package version 1.12.0, <a href="https://cran.r-project.org/package=network">https://cran.r-project.org/package=network</a>.
</p>
<p>Goodreau SM, Handcock MS, Hunter DR, Butts CT, Morris M (2008a).
A <span class="pkg">statnet</span> Tutorial.
<em>Journal of Statistical Software</em>, 24(8).
<a href="https://doi.org/10.18637/jss.v024.i08">doi:10.18637/jss.v024.i08</a>
</p>
<p>Goodreau SM, Kitts J, Morris M (2008b).
Birds of a Feather, or Friend of a Friend? Using Exponential
Random Graph Models to Investigate Adolescent Social Networks.
<em>Demography</em>, 45, in press.
</p>
<p>Handcock, M. S. (2003)
<em>Assessing Degeneracy in Statistical Models of Social Networks</em>,
Working Paper #39,
Center for Statistics and the Social Sciences,
University of Washington.
<a href="https://csss.uw.edu/research/working-papers/assessing-degeneracy-statistical-models-social-networks">https://csss.uw.edu/research/working-papers/assessing-degeneracy-statistical-models-social-networks</a>
</p>
<p>Handcock MS (2003b).
<span class="pkg">degreenet</span>: Models for Skewed Count Distributions Relevant
to Networks.
Statnet Project, Seattle, WA.
Version 1.0, <a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Handcock MS and Gile KJ (2010). Modeling Social Networks from Sampled Data. <em>Annals of Applied Statistics</em>, 4(1), 5-25. <a href="https://doi.org/10.1214/08-AOAS221">doi:10.1214/08-AOAS221</a>
</p>
<p>Handcock MS, Hunter DR, Butts CT, Goodreau SM, Morris M (2003a).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose
Exponential-Family Models for Networks.
Statnet Project, Seattle, WA.
Version 2, <a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Handcock MS, Hunter DR, Butts CT, Goodreau SM, Morris M (2003b).
<span class="pkg">statnet</span>: Software Tools for the Statistical Modeling of
Network Data.
Statnet Project, Seattle, WA.
Version 2, <a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Hunter, D. R. and Handcock, M. S. (2006)
<em>Inference in curved exponential family models for networks</em>,
Journal of Computational and Graphical Statistics.
</p>
<p>Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose
Exponential-Family Models for Networks.
<em>Journal of Statistical Software</em>, 24(3).
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>
</p>
<p>Karwa V, Krivitsky PN, and Slavkovi\'c AB (2017). Sharing Social Network
Data: Differentially Private Estimation of Exponential-Family Random
Graph Models. <em>Journal of the Royal Statistical Society, Series
C</em>, 66(3):481&ndash;500. <a href="https://doi.org/10.1111/rssc.12185">doi:10.1111/rssc.12185</a>
</p>
<p>Krivitsky PN (2012). Exponential-Family Random Graph Models for Valued
Networks. <em>Electronic Journal of Statistics</em>, 2012, 6,
1100-1128. <a href="https://doi.org/10.1214/12-EJS696">doi:10.1214/12-EJS696</a>
</p>
<p>Morris M, Handcock MS, Hunter DR (2008).
Specification of Exponential-Family Random Graph Models:
Terms and Computational Aspects.
<em>Journal of Statistical Software</em>, 24(4).
<a href="https://doi.org/10.18637/jss.v024.i04">doi:10.18637/jss.v024.i04</a>
</p>
<p>Snijders, T.A.B. (2002),
Markov Chain Monte Carlo Estimation of Exponential Random Graph Models.
Journal of Social Structure.
Available from
<a href="https://www.cmu.edu/joss/content/articles/volume3/Snijders.pdf">https://www.cmu.edu/joss/content/articles/volume3/Snijders.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>, <code><a href="network.html#topic++25v+25">%v%</a></code>, <code><a href="network.html#topic++25n+25">%n%</a></code>, <code><a href="#topic+ergmTerm">ergmTerm</a></code>, <code><a href="#topic+ergmMPLE">ergmMPLE</a></code>,
<code><a href="#topic+summary.ergm">summary.ergm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# load the Florentine marriage data matrix
#
data(flo)
#
# attach the sociomatrix for the Florentine marriage data
# This is not yet a network object.
#
flo
#
# Create a network object out of the adjacency matrix
#
flomarriage &lt;- network(flo,directed=FALSE)
flomarriage
#
# print out the sociomatrix for the Florentine marriage data
#
flomarriage[,]
#
# create a vector indicating the wealth of each family (in thousands of lira) 
# and add it as a covariate to the network object
#
flomarriage %v% "wealth" &lt;- c(10,36,27,146,55,44,20,8,42,103,48,49,10,48,32,3)
flomarriage
#
# create a plot of the social network
#
plot(flomarriage)
#
# now make the vertex size proportional to their wealth
#
plot(flomarriage, vertex.cex=flomarriage %v% "wealth" / 20, main="Marriage Ties")
#
# Use 'data(package = "ergm")' to list the data sets in a
#
data(package="ergm")
#
# Load a network object of the Florentine data
#
data(florentine)
#
# Fit a model where the propensity to form ties between
# families depends on the absolute difference in wealth
#
gest &lt;- ergm(flomarriage ~ edges + absdiff("wealth"))
summary(gest)
#
# add terms for the propensity to form 2-stars and triangles
# of families 
#
gest &lt;- ergm(flomarriage ~ kstar(1:2) + absdiff("wealth") + triangle)
summary(gest)

# import synthetic network that looks like a molecule
data(molecule)
# Add a attribute to it to mimic the atomic type
molecule %v% "atomic type" &lt;- c(1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3)
#
# create a plot of the social network
# colored by atomic type
#
plot(molecule, vertex.col="atomic type",vertex.cex=3)

# measure tendency to match within each atomic type
gest &lt;- ergm(molecule ~ edges + kstar(2) + triangle + nodematch("atomic type"))
summary(gest)

# compare it to differential homophily by atomic type
gest &lt;- ergm(molecule ~ edges + kstar(2) + triangle
                        + nodematch("atomic type",diff=TRUE))
summary(gest)


# Extract parameter estimates as a numeric vector:
coef(gest)
# Sources of variation in parameter estimates:
vcov(gest, sources="model")
vcov(gest, sources="estimation")
vcov(gest, sources="all") # the default

</code></pre>

<hr>
<h2 id='ergm_bd_init'>Initializes the parameters to bound degree during sampling</h2><span id='topic+ergm_bd_init'></span>

<h3>Description</h3>

<p>Not normally called directly by user, <code>ergm.bounddeg</code> initializes the
list of parameters used to bound the degree during the Metropolis Hastings
sampling process, and issues warnings if the original network doesn't meet
the constraints specified by 'bounddeg'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_bd_init(arguments, nw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_bd_init_+3A_arguments">arguments</code></td>
<td>
<p>the <code>arguments</code> argument passed to the <code style="white-space: pre;">&#8288;InitErgmProposal.*()&#8288;</code> function; the sub-sublist <code>arguments$constraints$bd</code> should be a list of parameters which may contain the following for a
network of size n nodes: </p>
 <ul>
<li><p> attribs: an nxp matrix, where entry
ij is TRUE if node i has attribute j, and FALSE otherwise; default=an nx1
matrix of 1's </p>
</li>
<li><p> maxout : an nxp matrix, where entry ij is the maximum
number of out degrees for node i to nodes with attribute j; default=an nxp
matrix of the value (n-1) </p>
</li>
<li><p> maxin : defined similarly to maxout, but
ignored for undirected networks; default=an nxp matrix of the value (n-1)
</p>
</li>
<li><p> minout : defined similarly to maxout; default=an nxp matrix of 0's
</p>
</li>
<li><p> minin : defined similarly to maxout, but ignored for undirected
networks; default=an nxp matrix of 0's </p>
</li></ul>
</td></tr>
<tr><td><code id="ergm_bd_init_+3A_nw">nw</code></td>
<td>
<p>the orginal <code>network</code> specified to <code>ergm</code> in 'formula'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some modeling situations, the degree of certain nodes are constrained to
lie in a certain range (rather than their theoretically possible range of 0
to n-1).  Such sample space constraints may be incorporated into the ergm
modeling process, and if so then the MCMC routine is prevented from visiting
network states that violate any of these bounds.
</p>
<p>In case there are categories of nodes and degree bounds for each set of
categories, such constraints may be incorporated as well.  For instance, if
the nodes are girls and boys, and there is a maximum of 5 out-ties to boys
and a maximum of 5 out-ties to girls for each node, we would define p to be
2, and the nxp matrix attribs would have TRUE in the first column (say) for
exactly those nodes that are boys and TRUE in the second column for only the
girls.  The maxout matrix would consist of all 5s in this case, and the
other arguments would be left as their default values.
</p>
<p>Since the observed network is generally the beginning of the Markov chain,
it must satisfy all of the degree constraints itself; thus, this function
returns an error message if any bound is violated by the observed network.
</p>


<h3>Value</h3>

<p>a list of parameters used to bound degree during sampling
</p>
<table>
<tr><td><code>condAllDegExact</code></td>
<td>
<p> always <code>FALSE</code></p>
</td></tr>
<tr><td><code>attribs</code></td>
<td>
<p> as defined above</p>
</td></tr>
<tr><td><code>maxout</code></td>
<td>
<p> as defined above</p>
</td></tr>
<tr><td><code>maxin</code></td>
<td>
<p> as defined above</p>
</td></tr>
<tr><td><code>minout</code></td>
<td>
<p> as defined above</p>
</td></tr>
<tr><td><code>minin</code></td>
<td>
<p> as defined above</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergm-proposals">ergm-proposals</a></code>
</p>

<hr>
<h2 id='ergm_Cstate_clear'>Deallocate the C data structures corresponding to an <code><a href="#topic+ergm_state">ergm_state</a></code> left over from a <code><a href="base.html#topic+.Call">.Call()</a></code> run.</h2><span id='topic+ergm_Cstate_clear'></span>

<h3>Description</h3>

<p>This function is exported for use by other packages that use the <code>ErgmState</code> C API. It should be used as a part of an <code><a href="base.html#topic+on.exit">on.exit()</a></code> call in the function that calls the C routine if the C routine contains <code>R_CheckUserInterrupt()</code> calls, in order to ensure that memory is freed if the routine is interrupted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_Cstate_clear()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergm_state">ergm_state</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
long_run &lt;- function(...){
  on.exit(ergm_Cstate_clear())
  .Call("long_run",...)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='ergm_cutoff_message'>Helper function for constructing <code style="white-space: pre;">&#8288;gw*&#8288;</code> cutoff error messages</h2><span id='topic+ergm_cutoff_message'></span>

<h3>Description</h3>

<p>Helper function for constructing <code style="white-space: pre;">&#8288;gw*&#8288;</code> cutoff error messages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_cutoff_message(cutoff, term, stat, arg = NULL, opt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_cutoff_message_+3A_cutoff">cutoff</code></td>
<td>
<p>the maximum value for the statistic of interest.</p>
</td></tr>
<tr><td><code id="ergm_cutoff_message_+3A_term">term</code></td>
<td>
<p>the name of the term.</p>
</td></tr>
<tr><td><code id="ergm_cutoff_message_+3A_stat">stat</code></td>
<td>
<p>the name of the statistic of interest.</p>
</td></tr>
<tr><td><code id="ergm_cutoff_message_+3A_arg">arg</code></td>
<td>
<p>the name of the term argument (if any) that controls the cutoff.</p>
</td></tr>
<tr><td><code id="ergm_cutoff_message_+3A_opt">opt</code></td>
<td>
<p>the name of the term option (if any) that controls the cutoff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the error message.
</p>

<hr>
<h2 id='ergm_dyadgen_select'>A helper function to select and construct a dyad generator for C.</h2><span id='topic+ergm_dyadgen_select'></span>

<h3>Description</h3>

<p>A helper function to select and construct a dyad generator for C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_dyadgen_select(arguments, nw, extra_rlebdm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_dyadgen_select_+3A_arguments">arguments</code></td>
<td>
<p>argumements passed to the <code><a href="#topic+ergm_proposal">ergm_proposal</a></code>.</p>
</td></tr>
<tr><td><code id="ergm_dyadgen_select_+3A_nw">nw</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="ergm_dyadgen_select_+3A_extra_rlebdm">extra_rlebdm</code></td>
<td>
<p>an <code><a href="#topic+rlebdm">rlebdm</a></code> representing any additional constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list understood by the C <code>DyadGen</code> API.
</p>

<hr>
<h2 id='ergm_edgecov_args'>A common pattern for obtaining an edge covariate</h2><span id='topic+ergm_edgecov_args'></span>

<h3>Description</h3>

<p>A common pattern for obtaining an edge covariate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_edgecov_args(name, nw, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_edgecov_args_+3A_name">name</code></td>
<td>
<p>a string containing the name of the calling term.</p>
</td></tr>
<tr><td><code id="ergm_edgecov_args_+3A_nw">nw</code></td>
<td>
<p>the LHS network.</p>
</td></tr>
<tr><td><code id="ergm_edgecov_args_+3A_a">a</code></td>
<td>
<p>list returned by <code><a href="#topic+check.ErgmTerm">check.ErgmTerm()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: <code>xm</code> for the obtained predictor
matrix and <code>cn</code> for the standard coefficient name.
</p>

<hr>
<h2 id='ergm_GWDECAY'>Curved settings for geometric weights for the <code style="white-space: pre;">&#8288;gw*&#8288;</code> terms</h2><span id='topic+ergm_GWDECAY'></span>

<h3>Description</h3>

<p>This is a list containing <code>map</code> and <code>gradient</code> for the weights described by Hunter (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_GWDECAY
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>References</h3>

<p>David R. Hunter (2007) Curved Exponential Family Models for Social Networks. <em>Social Networks</em>, 29: 216-230. <a href="https://doi.org/10.1016/j.socnet.2006.08.005">doi:10.1016/j.socnet.2006.08.005</a>
</p>

<hr>
<h2 id='ergm_keyword'>Dynamic ERGM keyword registry</h2><span id='topic+ergm_keyword'></span>

<h3>Description</h3>

<p>A function to manage dynamic ERGM keywords. To register a keyword, call the function with all parameters
provided. To fetch all registered keywords, call the function with no parameters specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_keyword(
  name = NULL,
  short = NULL,
  description = NULL,
  popular = NULL,
  package = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_keyword_+3A_name">name</code></td>
<td>
<p>full name of the keyword</p>
</td></tr>
<tr><td><code id="ergm_keyword_+3A_short">short</code></td>
<td>
<p>abbreviation of the keyword name</p>
</td></tr>
<tr><td><code id="ergm_keyword_+3A_description">description</code></td>
<td>
<p>description of the keyword</p>
</td></tr>
<tr><td><code id="ergm_keyword_+3A_popular">popular</code></td>
<td>
<p>logical to indicate if a keyword is popular</p>
</td></tr>
<tr><td><code id="ergm_keyword_+3A_package">package</code></td>
<td>
<p>package the keyword is first defined in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with the following columns:
</p>

<ul>
<li><p> name
</p>
</li>
<li><p> short
</p>
</li>
<li><p> description
</p>
</li>
<li><p> popular
</p>
</li>
<li><p> package
</p>
</li></ul>


<hr>
<h2 id='ergm_MCMC_sample'>Internal Function to Sample Networks and Network Statistics</h2><span id='topic+ergm_MCMC_sample'></span><span id='topic+ergm_MCMC_slave'></span>

<h3>Description</h3>

<p>This is an internal function, not normally called directly by the
user. The <code>ergm_MCMC_sample</code> function samples networks and
network statistics using an MCMC algorithm via <code>MCMC_wrapper</code>
and is capable of running in multiple threads using
<code>ergm_MCMC_slave</code>.
</p>
<p>The <code>ergm_MCMC_slave</code> function calls the actual C
routine and does minimal preprocessing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_MCMC_sample(
  state,
  control,
  theta = NULL,
  verbose = FALSE,
  ...,
  eta = ergm.eta(theta, (if (is.ergm_state(state)) as.ergm_model(state) else
    as.ergm_model(state[[1]]))$etamap)
)

ergm_MCMC_slave(
  state,
  eta,
  control,
  verbose,
  ...,
  burnin = NULL,
  samplesize = NULL,
  interval = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_MCMC_sample_+3A_state">state</code></td>
<td>
<p>an <code><a href="#topic+ergm_state">ergm_state</a></code> representing the sampler state, containing information about the network, the model, the proposal, and (optionally) initial statistics, or a list thereof.</p>
</td></tr>
<tr><td><code id="ergm_MCMC_sample_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.ergm">control.ergm()</a></code>, <code><a href="#topic+control.simulate.ergm">control.simulate.ergm()</a></code>, etc., which have different
defaults. Their documentation gives the the list of recognized
control parameters and their meaning. The more generic utility
<code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL) also provides argument completion
for the available control functions and limited argument name
checking.</p>
</td></tr>
<tr><td><code id="ergm_MCMC_sample_+3A_theta">theta</code></td>
<td>
<p>the (possibly curved) parameters of the model.</p>
</td></tr>
<tr><td><code id="ergm_MCMC_sample_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergm_MCMC_sample_+3A_...">...</code></td>
<td>
<p>additional arugments.</p>
</td></tr>
<tr><td><code id="ergm_MCMC_sample_+3A_eta">eta</code></td>
<td>
<p>the natural parameters of the model; by default constructed from <code>theta</code>.</p>
</td></tr>
<tr><td><code id="ergm_MCMC_sample_+3A_burnin">burnin</code>, <code id="ergm_MCMC_sample_+3A_samplesize">samplesize</code>, <code id="ergm_MCMC_sample_+3A_interval">interval</code></td>
<td>
<p>MCMC paramters that can be used
to temporarily override those in the <code>control</code> list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ergm_MCMC_sample</code> returns a list
containing:
</p>
<table>
<tr><td><code>stats</code></td>
<td>
<p>an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> with sampled statistics.</p>
</td></tr>
<tr><td><code>networks</code></td>
<td>
<p>a list of final sampled networks, one for each thread.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>status code, propagated from <code>ergm_MCMC_slave()</code>.</p>
</td></tr>
<tr><td><code>final.interval</code></td>
<td>
<p>adaptively determined MCMC interval.</p>
</td></tr>
<tr><td><code>sampnetworks</code></td>
<td>
<p>If <code>control$MCMC.save_networks</code> is set and is
<code>TRUE</code>, a list of lists of <code>ergm_state</code>s corresponding to the
sampled networks.</p>
</td></tr>
</table>
<p><code>ergm_MCMC_slave</code> returns the MCMC sample as a list of
the following: </p>
<table>
<tr><td><code>s</code></td>
<td>
<p>the matrix of statistics.</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>an <code><a href="#topic+ergm_state">ergm_state</a></code> object for the new network.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>success or failure code: <code>0</code> is success, <code>1</code> for
too many edges, and <code>2</code> for a Metropolis-Hastings proposal failing,
<code>-1</code> for <code><a href="#topic+ergm_model">ergm_model</a></code> or <code><a href="#topic+ergm_proposal">ergm_proposal</a></code> not passed and
missing from the cache.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>ergm_MCMC_sample</code> and <code>ergm_MCMC_slave</code> replace
<code>ergm.getMCMCsample</code> and <code>ergm.mcmcslave</code> respectively. They
differ slightly in their argument names and in their return
formats. For example, <code>ergm_MCMC_sample</code> expects <code>ergm_state</code>
rather than network/model/proposal, and <code>theta</code> or <code>eta</code> rather than <code>eta0</code>;
and it does not return <code>statsmatrix</code> or <code>newnetwork</code>
elements. Rather, if parallel processing is not in effect,
<code>stats</code> is an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> with one chain and <code>networks</code> is a
list with one element.
</p>
<p>Note that unless <code>stats</code> is a part of the <code>ergm_state</code>, the
returned stats will be relative to the original network, i.e.,
the calling function must shift the statistics if required.
</p>
<p>At this time, repeated calls to <code>ergm_MCMC_sample</code> will not
produce the same sequence of networks as a single long call, even
with the same starting seeds. This is because the network
sampling algorithms rely on the internal state of the network
representation in C, which may not be reconstructed exactly the
same way when &quot;resuming&quot;. This behaviour may change in the
future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example illustrates constructing "ingredients" for calling
# ergm_MCMC_sample() from calls to simulate.ergm(). One can also
# construct an ergm_state object directly from ergm_model(),
# ergm_proposal(), etc., but the approach shown here is likely to
# be the least error-prone and the most robust to future API
# changes.
#
# The regular simulate() call hierarchy is
#
# simulate_formula.network(formula) -&gt;
#   simulate.ergm_model(ergm_model) -&gt;
#     simulate.ergm_state_full(ergm_state)
#
# They take an argument, return.args=, that will interrupt the call
# and have it return its arguments. We can use it to obtain
# low-level inputs robustly.

data(florentine)
control &lt;- control.simulate(MCMC.burnin = 2, MCMC.interval = 1)


# FYI: Obtain input for simulate.ergm_model():
sim.mod &lt;- simulate(flomarriage~absdiff("wealth"), constraints=~edges,
                    coef = NULL, nsim=3, control=control,
                    return.args="ergm_model")
names(sim.mod)
str(sim.mod$object,1) # ergm_model

# Obtain input for simulate.ergm_state_full():
sim.state &lt;- simulate(flomarriage~absdiff("wealth"), constraints=~edges,
                      coef = NULL, nsim=3, control=control,
                      return.args="ergm_state")
names(sim.state)
str(sim.state$object, 1) # ergm_state

# This control parameter would be set by nsim in the regular
# simulate() call:
control$MCMC.samplesize &lt;- 3

# Capture intermediate networks; can also be left NULL for just the
# statistics:
control$MCMC.save_networks &lt;- TRUE

# Simulate starting from this state:
out &lt;- ergm_MCMC_sample(sim.state$object, control, theta = -1, verbose=6)
names(out)
out$stats # Sampled statistics
str(out$networks, 1) # Updated ergm_state (one per thread)
# List (an element per thread) of lists of captured ergm_states,
# one for each sampled network:
str(out$sampnetworks, 2)
lapply(out$sampnetworks[[1]], as.network) # Converted to networks.

# One more, picking up where the previous sampler left off, but see Note:
control$MCMC.samplesize &lt;- 1
str(ergm_MCMC_sample(out$networks, control, theta = -1, verbose=6), 2)

</code></pre>

<hr>
<h2 id='ergm_mk_std_op_namewrap'>Combine an operator term's and a subterm's name in a standard fashion.</h2><span id='topic+ergm_mk_std_op_namewrap'></span>

<h3>Description</h3>

<p>Combine an operator term's and a subterm's name in a standard fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_mk_std_op_namewrap(opname, opargs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_mk_std_op_namewrap_+3A_opname">opname</code></td>
<td>
<p>Name of the operator (or an abbreviation thereof).</p>
</td></tr>
<tr><td><code id="ergm_mk_std_op_namewrap_+3A_opargs">opargs</code></td>
<td>
<p>A character vector describing arguments passed to the operator (excluding the model); if lengths exceeds one, will be concatenated with commas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function with 1 required argument, <code>subterms</code> and one optional argument, <code>subargs</code>, returning a character vector of length equal to the length of <code>subterms</code> wrapped in the operator's name and arguments appropriately.
</p>

<hr>
<h2 id='ergm_model'>Internal representation of an <code>ergm</code> network model</h2><span id='topic+ergm_model'></span><span id='topic+c.ergm_model'></span><span id='topic+as.ergm_model'></span><span id='topic+as.ergm_model.ergm_model'></span><span id='topic+as.ergm_model.formula'></span><span id='topic+is.curved.ergm_model'></span><span id='topic+is.dyad.independent.ergm_model'></span><span id='topic+nparam.ergm_model'></span><span id='topic+param_names.ergm_model'></span>

<h3>Description</h3>

<p>These methods are generally not called directly by users, but may
be employed by other depending packages.
<code>ergm_model</code> constructs it from a formula or a term list. Each term is
initialized via the <code>InitErgmTerm</code> functions to create a
<code>ergm_model</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_model(
  formula,
  nw = NULL,
  silent = FALSE,
  ...,
  term.options = list(),
  extra.aux = list(),
  env = globalenv(),
  offset.decorate = TRUE,
  terms.only = FALSE
)

## S3 method for class 'ergm_model'
c(...)

as.ergm_model(x, ...)

## S3 method for class 'ergm_model'
as.ergm_model(x, ...)

## S3 method for class 'formula'
as.ergm_model(x, ...)

## S3 method for class 'ergm_model'
is.curved(object, ...)

## S3 method for class 'ergm_model'
is.dyad.independent(object, ...)

## S3 method for class 'ergm_model'
nparam(object, canonical = FALSE, offset = NA, byterm = FALSE, ...)

## S3 method for class 'ergm_model'
param_names(object, canonical = FALSE, offset = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_model_+3A_formula">formula</code></td>
<td>
<p>An <code><a href="#topic+ergm">ergm()</a></code>
formula of the form <code>network ~ model.term(s)</code> or <code>~
model.term(s)</code> or a <code><a href="statnet.common.html#topic+term_list">term_list</a></code> object, typically constructed from a formula's LHS.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_nw">nw</code></td>
<td>
<p>The network of interest, optionally instrumented with <code><a href="#topic+ergm_preprocess_response">ergm_preprocess_response()</a></code> to have a response attribute specification; if passed, the LHS of <code>formula</code> is ignored. This is the recommended usage.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_silent">silent</code></td>
<td>
<p>logical, whether to print the warning messages from the
initialization of each model term.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_...">...</code></td>
<td>
<p>additional parameters for model formulation</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_extra.aux">extra.aux</code></td>
<td>
<p>a list of auxiliary request formulas required elsewhere; if named, the resulting <code>slots.extra.aux</code> will also be named.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_env">env</code></td>
<td>
<p>a throwaway argument needed to prevent conflicts with some usages of <code>ergm_model</code>. The initialization environment is <em>always</em> taken from the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_offset.decorate">offset.decorate</code></td>
<td>
<p>logical; whether offset coefficient and parameter names should be enclosed in <code>"offset()"</code>.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_terms.only">terms.only</code></td>
<td>
<p>logical; whether auxiliaries, eta map, and UID constructions should be skipped. This is useful for submodels.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_x">x</code></td>
<td>
<p>object to be converted to an <code>ergm_model</code>.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_object">object</code></td>
<td>
<p>An <code>ergm_model</code> object.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_canonical">canonical</code></td>
<td>
<p>Whether the canonical (eta) parameters or the curved (theta) parameters are used.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_offset">offset</code></td>
<td>
<p>If <code>NA</code> (the default), all model terms are counted;
if <code>TRUE</code>, only offset terms are counted; and if
<code>FALSE</code>, offset terms are skipped.</p>
</td></tr>
<tr><td><code id="ergm_model_+3A_byterm">byterm</code></td>
<td>
<p>Whether to return a vector of the numbers of
coefficients for each term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ergm_model</code> returns an  <code>ergm_model</code> object as a list
containing:
</p>
<table>
<tr><td><code>terms</code></td>
<td>
<p>a list of terms and 'term components' initialized by the
appropriate <code>InitErgmTerm.X</code> function.</p>
</td></tr>
<tr><td><code>etamap</code></td>
<td>
<p>the theta -&gt; eta mapping as a list returned from
&lt;ergm.etamap&gt;</p>
</td></tr>
<tr><td><code>uid</code></td>
<td>
<p>a string generated with the model, concatenating the UNIX time (<code><a href="base.html#topic+Sys.time">Sys.time</a>()</code>) to maximum available precision, process ID (<code><a href="base.html#topic+Sys.getpid">Sys.getpid</a>()</code>), and a counter that starts at <code>-<a href="base.html#topic+.Machine">.Machine</a>$integer.max</code> and increments by 1 with every call; different models are, generally, guaranteed to have different strings, but identical models are not guaranteed to have the same string</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>c(ergm_model)</code>: A method for concatenating terms of two or more initialized models.
</p>
</li>
<li> <p><code>is.curved(ergm_model)</code>: Tests whether the model is curved.
</p>
</li>
<li> <p><code>is.dyad.independent(ergm_model)</code>: Tests whether the model is dyad-independent.
</p>
</li>
<li> <p><code>nparam(ergm_model)</code>: Number of parameters of the model.
</p>
</li>
<li> <p><code>param_names(ergm_model)</code>: Parameter names of the model.
</p>
</li></ul>


<h3>Note</h3>

<p>This API is not to be considered fixed and may change between versions. However, an effort will be made to ensure that the methods of this class remain stable.
</p>
<p>Earlier versions also had an optional <code style="white-space: pre;">&#8288;response=&#8288;</code> parameter that, if not <code>NULL</code>, switched to valued mode and used the edge attribute named in <code style="white-space: pre;">&#8288;response=&#8288;</code> as the response. This is no longer used; instead, the response is to be set on <code>nw</code> via <code>ergm_preprocess_response(nw, response)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ergm_model">summary.ergm_model()</a></code>, <code><a href="#topic+ergm_preprocess_response">ergm_preprocess_response()</a></code>
</p>

<hr>
<h2 id='ergm_plot.mcmc.list'>Plot MCMC list using <code>lattice</code> package graphics</h2><span id='topic+ergm_plot.mcmc.list'></span>

<h3>Description</h3>

<p>Plot MCMC list using <code>lattice</code> package graphics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_plot.mcmc.list(x, main = NULL, vars.per.page = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_plot.mcmc.list_+3A_x">x</code></td>
<td>
<p>an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object containing the mcmc diagnostic
samples.</p>
</td></tr>
<tr><td><code id="ergm_plot.mcmc.list_+3A_main">main</code></td>
<td>
<p>character, main plot heading title.</p>
</td></tr>
<tr><td><code id="ergm_plot.mcmc.list_+3A_vars.per.page">vars.per.page</code></td>
<td>
<p>Number of rows (one variable per row) per
plotting page.  Ignored if <code>latticeExtra</code> package is not
installed.</p>
</td></tr>
<tr><td><code id="ergm_plot.mcmc.list_+3A_...">...</code></td>
<td>
<p>additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is not a method at this time.
</p>

<hr>
<h2 id='ergm_preprocess_response'>Update the network and the response argument.</h2><span id='topic+ergm_preprocess_response'></span>

<h3>Description</h3>

<p>Update the network and the response argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_preprocess_response(nw, response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_preprocess_response_+3A_nw">nw</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object.</p>
</td></tr>
<tr><td><code id="ergm_preprocess_response_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> If <code>response</code> is <code>NULL</code> or <code>logical</code>, drop all edge attributes except for <code>na</code> and return the network and the response as they are.
</p>
</li>
<li><p> If <code>response</code> is a character vector of length 1, drop all edge attributes in <code>nw</code> except for the one corresponding to <code>response</code>.
</p>
</li>
<li><p> If <code>response</code> is a formula, construct a name for it and assign to that name (as an edge attribute) the result of evaluating the formula environment; drop all other edge attributes. Return as response the name (possibly with the attribute for the formula attached). If the formula's RHS is of the form a|b use the logicalness of b in Step 4.
</p>
</li>
<li><p> Test if the resulting edge attribute is of mode <code><a href="base.html#topic+logical">logical</a></code>. If so set <code>attr(response,'valued')</code> to <code>FALSE</code>, otherwise to <code>TRUE</code>.
</p>
</li></ol>

<p>If both <code>nw</code> and <code>response</code> are ordinary variables (i.e., not expressions) in the parent frame, <code>nw</code> (whatever it was named) is overwritten with the updated network and <code>response</code> (again, whatever it was named) is deleted. This is for convenience and for making outdated code that relies on <code>response</code> fail immediately rather than introduce subtle bugs. Otherwise, the updated network is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
preproc_check_print &lt;- function(nw, response){
  ergm_preprocess_response(nw, response) 
  str(list(
       valued = is.valued(nw),
       el = head(as.edgelist(nw, attrname=nw%ergmlhs%"response", output="tibble"),3)
  ))
}

data(florentine)
preproc_check_print(flomarriage, NULL)

flomarriage %e% "w" &lt;- runif(network.edgecount(flomarriage))
flomarriage %e% "s" &lt;- rep(c(-1,1), length.out=network.edgecount(flomarriage))

# Edge attribute expression
preproc_check_print(flomarriage, ~w*s)

# Named
preproc_check_print(flomarriage, wsprod~w*s)

# Binary from valued
preproc_check_print(flomarriage, ~s&gt;0)

# Default edge attribute mode is valued
flomarriage[,] &lt;- 0 # Empty network
preproc_check_print(flomarriage, ~w*s)

# Force default edge attribute mode to binary
preproc_check_print(flomarriage, ~w|TRUE)

</code></pre>

<hr>
<h2 id='ergm_propagate_ext.encode'>Extended states for submodels</h2><span id='topic+ergm_propagate_ext.encode'></span><span id='topic+ergm_no_ext.encode'></span>

<h3>Description</h3>

<p><code>ergm_propagate_ext.encode()</code> is a convenience
function to propagate the extended state encoder to submodels if
they have any.
</p>
<p><code>ergm_no_ext.encode()</code> checks if a submodel contains
terms that use extended states and stops with an informative
error message if any do.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_propagate_ext.encode(submodel)

ergm_no_ext.encode(submodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_propagate_ext.encode_+3A_submodel">submodel</code></td>
<td>
<p>the <code><a href="#topic+ergm_model">ergm_model</a></code> to which the encoders should be
propagated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ergm_propagate_ext.encode</code> returns a list with one
element, <code>ext.encode</code> containing a function that follows the
extended state encoder API and simply returns a list of the
subterms extended state encodings.
</p>


<h3>Note</h3>

<p><code>ergm_propagate_ext.encode</code> should only be used when the
operator term does not modify the network and provides an
<code>x_function</code> on the C level that does appropriate propagation and
handles any return values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Typical usage:
InitErgmTerm.ABC &lt;- function(nw, arglist, ...){
  [... implementation ...]
  m &lt;- ergm_model([... etc. ...])
  c(list(name = "abc", inputs=1:3, submodel=m),
    ergm_propagate_ext.encode(m),
    wrap.ergm_model(nw, m)
  )
}

## End(Not run)

</code></pre>

<hr>
<h2 id='ergm_proposal'>Functions to initialize the ergm_proposal object</h2><span id='topic+ergm_proposal'></span><span id='topic+ergm_proposal.NULL'></span><span id='topic+ergm_proposal.ergm_proposal'></span><span id='topic+ergm_proposal.character'></span><span id='topic+ergm_proposal.formula'></span><span id='topic+ergm_proposal.term_list'></span><span id='topic+ergm_proposal.ergm_conlist'></span><span id='topic+ergm_proposal.ergm'></span>

<h3>Description</h3>

<p>S3 Functions that initialize the Metropolis-Hastings Proposal (ergm_proposal)
object using the <code style="white-space: pre;">&#8288;InitErgmProposal.*&#8288;</code> function that corresponds to the name given in
'object'.  These functions are not generally called directly by the user.
See <a href="#topic+ergm-proposals">ergm-proposals</a> for general explanation and lists of available
Metropolis-Hastings proposal types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_proposal(object, ...)

## S3 method for class 'character'
ergm_proposal(
  object,
  arguments,
  nw,
  ...,
  reference = ergm_reference(trim_env(~Bernoulli), nw, term.options = term.options, ...),
  term.options = list()
)

## S3 method for class 'formula'
ergm_proposal(
  object,
  arguments,
  nw,
  hints = trim_env(~sparse),
  ...,
  term.options = list()
)

## S3 method for class 'term_list'
ergm_proposal(
  object,
  arguments,
  nw,
  hints = trim_env(~sparse),
  ...,
  term.options = list()
)

## S3 method for class 'ergm_conlist'
ergm_proposal(
  object,
  arguments,
  nw,
  weights = "default",
  class = "c",
  reference = trim_env(~Bernoulli),
  ...,
  term.options = list()
)

## S3 method for class 'ergm'
ergm_proposal(
  object,
  ...,
  constraints = NULL,
  arguments = NULL,
  nw = NULL,
  weights = NULL,
  class = "c",
  reference = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_proposal_+3A_object">object</code></td>
<td>
<p>Either a character, a <code><a href="stats.html#topic+formula">formula</a></code> or an
<code><a href="#topic+ergm">ergm</a></code> object.  The <code><a href="stats.html#topic+formula">formula</a></code> should be of the format documented in the <code>constraints</code> argument of <code><a href="#topic+ergm">ergm()</a></code> and in the <a href="#topic+ergmConstraint">ERGM constraints</a> documentation.</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other functions.</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_arguments">arguments</code></td>
<td>
<p>A list of parameters used by the InitErgmProposal routines</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_nw">nw</code></td>
<td>
<p>The network object originally given to <code><a href="#topic+ergm">ergm</a></code>
via 'formula'</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_reference">reference</code></td>
<td>
<p>A one-sided formula specifying
the reference measure (<code class="reqn">h(y)</code>) to be used.
See help for <a href="#topic+ergm-references">ERGM reference measures</a> implemented in the
<strong><a href="#topic+ergm-package">ergm</a></strong> package.</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_weights">weights</code></td>
<td>
<p>Specifies the method used to allocate probabilities
of being proposed to dyads, providing an intermediate method
(between hints and specifying the proposal name directly) for
specifying the proposal; options include &quot;TNT&quot;, &quot;StratTNT&quot;,
&quot;TNT10&quot;, &quot;random&quot;, &quot;nonobserved&quot; and &quot;default&quot;; default=&quot;default&quot;</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_class">class</code></td>
<td>
<p>The class of the proposal; choices include &quot;c&quot;, &quot;f&quot;,
and &quot;d&quot; default=&quot;c&quot;.</p>
</td></tr>
<tr><td><code id="ergm_proposal_+3A_constraints">constraints</code></td>
<td>
<p>A one-sided formula specifying one or more constraints on
the support of the distribution of the networks being simulated. See the
documentation for a similar argument for <code><a href="#topic+ergm">ergm</a></code> and see
<code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an ergm_proposal object: a list with class <code>ergm_proposal</code>
containing the following named elements:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>the C name of the proposal</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>inputs to be passed to C</p>
</td></tr>
<tr><td><code>pkgname</code></td>
<td>
<p>shared library name where the proposal
can be found (usually <code>"ergm"</code>)</p>
</td></tr>
<tr><td><code>reference</code></td>
<td>
<p>the reference distribution</p>
</td></tr>
<tr><td><code>arguments</code></td>
<td>
<p>list of arguments passed to
the <code>InitErgmProposal</code> function; in particular,
</p>

<dl>
<dt><code>constraints</code></dt><dd><p>list of constraints</p>
</dd>
<dt>uid</dt><dd><p>a string generated with the proposal, concatenating the UNIX time (<code><a href="base.html#topic+Sys.time">Sys.time</a>()</code>) to maximum available precision, process ID (<code><a href="base.html#topic+Sys.getpid">Sys.getpid</a>()</code>), and a counter that starts at <code>-<a href="base.html#topic+.Machine">.Machine</a>$integer.max</code> and increments by 1 with every call; different proposals are, generally, guaranteed to have different strings, but identical proposals are not guaranteed to have the same string</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ergm_proposal(character)</code>: <code>object</code> argument is a character string
giving the <span class="rlang"><b>R</b></span> name of the proposal.
</p>
</li>
<li> <p><code>ergm_proposal(formula)</code>: <code>object</code> argument is an ERGM constraint formula; constructs the <code><a href="#topic+ergm_conlist">ergm_conlist</a></code> object and hands off to <code>ergm_proposal.ergm_conlist()</code>.
</p>
</li>
<li> <p><code>ergm_proposal(term_list)</code>: <code>object</code> argument is a <code><a href="statnet.common.html#topic+term_list">term_list</a></code>;
same implementation as the <code>formula</code> method.
</p>
</li>
<li> <p><code>ergm_proposal(ergm_conlist)</code>: <code>object</code> argument is an ERGM constraint
list; constructs the internal <code>ergm_reference</code> object, looks up the
proposal, and hands off to <code>ergm_proposal.character()</code>.
</p>
</li>
<li> <p><code>ergm_proposal(ergm)</code>: <code>object</code> argument is an <code><a href="#topic+ergm">ergm</a></code> fit whose proposals are extracted which is reproduced as best as possible.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+InitErgmProposal">InitErgmProposal</a></code>
</p>

<hr>
<h2 id='ergm_proposal_table'>Table mapping reference,constraints, etc. to ERGM Metropolis-Hastings proposals</h2><span id='topic+ergm_proposal_table'></span>

<h3>Description</h3>

<p>This is a low-level function not intended to be called directly by
end users. For information on Metropolis-Hastings proposal methods,
<a href="#topic+ergm-proposals">ergm-proposals</a>. This function sets up the table mapping
constraints, references, etc. to <code>ergm_proposals</code>. Calling it with
arguments adds a new row to this table. Calling it without
arguments returns the table so far.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_proposal_table(
  Class,
  Reference,
  Constraints,
  Priority,
  Weights,
  Proposal,
  Package = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_proposal_table_+3A_class">Class</code></td>
<td>
<p>default to &quot;c&quot;</p>
</td></tr>
<tr><td><code id="ergm_proposal_table_+3A_reference">Reference</code></td>
<td>
<p>The reference measure used in the model. For the list of
reference measures, see <code><a href="#topic+ergmReference">ergmReference</a></code></p>
</td></tr>
<tr><td><code id="ergm_proposal_table_+3A_constraints">Constraints</code></td>
<td>
<p>The constraints used in the model. For the list
of constraints, see <code><a href="#topic+ergmConstraint">ergmConstraint</a></code>. They are
specified as a single string of text, with each contrast prefixed
by either <code>&amp;</code> for constraints that the proposal <em>always</em> enforces
or <code>|</code> for constraints that the proposal <em>can</em> enforce if needed.</p>
</td></tr>
<tr><td><code id="ergm_proposal_table_+3A_priority">Priority</code></td>
<td>
<p>On existence of multiple qualifying proposals, specifies the
priority (<code>-1</code>,<code>0</code>,<code>1</code>, etc.) of proposals to be used.</p>
</td></tr>
<tr><td><code id="ergm_proposal_table_+3A_weights">Weights</code></td>
<td>
<p>The sampling weights on selecting toggles (random, TNT, etc).</p>
</td></tr>
<tr><td><code id="ergm_proposal_table_+3A_proposal">Proposal</code></td>
<td>
<p>The matching proposal from the previous arguments.</p>
</td></tr>
<tr><td><code id="ergm_proposal_table_+3A_package">Package</code></td>
<td>
<p>The package in which the proposal is implemented;
it's normally autodetected based on the package to which the
calling function belongs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time a particular package calls
<code>ergm_proposal_table()</code>, it also sets a call-back to remove all
of its proposals from the table should the package be unloaded.
</p>


<h3>Note</h3>

<p>The arguments <code>Class</code>, <code>Reference</code>, and <code>Constraints</code> can
have length greater than 1. If this is the case, the rows added
to the table are a <em>Cartesian product</em> of their elements.
</p>

<hr>
<h2 id='ergm_SAN_slave'>Internal Function to Perform Simulated Annealing</h2><span id='topic+ergm_SAN_slave'></span>

<h3>Description</h3>

<p>This is an internal function, not normally called directly by the
user. The <code>ergm_SAN_slave</code> function samples networks and
network statistics using a simulated annealing (SAN) algorithm via
<code>SAN_wrapper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_SAN_slave(
  state,
  tau,
  control,
  verbose,
  ...,
  nsteps = NULL,
  samplesize = NULL,
  statindices = NULL,
  offsetindices = NULL,
  offsets = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_SAN_slave_+3A_state">state</code></td>
<td>
<p>an <code><a href="#topic+ergm_state">ergm_state</a></code> representing the sampler state, containing information about the network, the model, the proposal, and current statistics.</p>
</td></tr>
<tr><td><code id="ergm_SAN_slave_+3A_tau">tau</code></td>
<td>
<p>a scalar; temperature to use; higher temperature means more proposals that &quot;worsen&quot; the statistics are accepted.</p>
</td></tr>
<tr><td><code id="ergm_SAN_slave_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.san">control.san()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
<tr><td><code id="ergm_SAN_slave_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergm_SAN_slave_+3A_...">...</code></td>
<td>
<p>additional arguments, currently unused.</p>
</td></tr>
<tr><td><code id="ergm_SAN_slave_+3A_nsteps">nsteps</code></td>
<td>
<p>an integer; number of SAN proposals.</p>
</td></tr>
<tr><td><code id="ergm_SAN_slave_+3A_samplesize">samplesize</code></td>
<td>
<p>an integer; number of network statistics to return.</p>
</td></tr>
<tr><td><code id="ergm_SAN_slave_+3A_statindices">statindices</code>, <code id="ergm_SAN_slave_+3A_offsetindices">offsetindices</code>, <code id="ergm_SAN_slave_+3A_offsets">offsets</code></td>
<td>
<p>specification for offset handling; see <code><a href="#topic+san.formula">san.formula()</a></code> implementation.</p>
</td></tr>
</table>

<hr>
<h2 id='ergm_state'>A Representation of ERGM state</h2><span id='topic+ergm_state'></span><span id='topic+ergm_state.edgelist'></span><span id='topic+ergm_state.matrix'></span><span id='topic+ergm_state.network'></span><span id='topic+is.ergm_state'></span><span id='topic+as.edgelist.ergm_state'></span><span id='topic+as.matrix.ergm_state'></span><span id='topic+as.network.ergm_state_full'></span><span id='topic+network.edgecount.ergm_state'></span><span id='topic+network.dyadcount.ergm_state_full'></span><span id='topic+network.size.ergm_state_full'></span><span id='topic+network.naedgecount.ergm_state'></span><span id='topic++25ergmlhs+25.ergm_state_full'></span><span id='topic++25ergmlhs+25+3C-.ergm_state_full'></span><span id='topic+as.rlebdm.ergm_state'></span><span id='topic+as.ergm_model.ergm_state_send'></span><span id='topic+is.curved.ergm_state_send'></span><span id='topic+param_names.ergm_state_send'></span><span id='topic+nparam.ergm_state_send'></span><span id='topic+update.ergm_state_full'></span><span id='topic+ergm_state.ergm_state'></span><span id='topic+ERGM_STATE_R_CHANGED'></span><span id='topic+ERGM_STATE_C_CHANGED'></span><span id='topic+ERGM_STATE_RECONCILED'></span><span id='topic+ergm_state_send'></span><span id='topic+ergm_state_send.ergm_state_send'></span><span id='topic+ergm_state_send.ergm_state_full'></span><span id='topic+ergm_state_send.ergm_state_receive'></span><span id='topic+update.ergm_state_send'></span><span id='topic+ergm_state_receive'></span><span id='topic+ergm_state_receive.ergm_state'></span><span id='topic+ergm_state_receive.ergm_state_full'></span><span id='topic+summary.ergm_state'></span>

<h3>Description</h3>

<p><code>ergm_state</code> is a family of semi-internal classes for passing
around results of MCMC sampling, particularly when the result is
used to start another MCMC sampler. It is deliberately loosely
specified, and its structure and even name are subject to change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_state(x, ...)

## S3 method for class 'edgelist'
ergm_state(
  x,
  nw0,
  model = NULL,
  proposal = NULL,
  stats = NULL,
  ext.state = NULL,
  ...
)

## S3 method for class 'matrix'
ergm_state(
  x,
  nw0,
  model = NULL,
  proposal = NULL,
  stats = NULL,
  ext.state = NULL,
  ...
)

## S3 method for class 'network'
ergm_state(x, ...)

is.ergm_state(x)

## S3 method for class 'ergm_state'
as.edgelist(x, ...)

## S3 method for class 'ergm_state'
as.matrix(x, matrix.type = NULL, ...)

## S3 method for class 'ergm_state_full'
as.network(x, ..., populate = TRUE)

## S3 method for class 'ergm_state'
network.edgecount(x, na.omit = TRUE, ...)

## S3 method for class 'ergm_state_full'
network.dyadcount(x, na.omit = TRUE, ...)

## S3 method for class 'ergm_state_full'
network.size(x, ...)

## S3 method for class 'ergm_state'
network.naedgecount(x, ...)

## S3 method for class 'ergm_state_full'
lhs %ergmlhs% setting

## S3 method for class 'ergm_state_full'
lhs %ergmlhs% setting &lt;- value

## S3 method for class 'ergm_state'
as.rlebdm(x, ...)

## S3 method for class 'ergm_state_send'
as.ergm_model(x, ...)

## S3 method for class 'ergm_state_send'
is.curved(object, ...)

## S3 method for class 'ergm_state_send'
param_names(object, ...)

## S3 method for class 'ergm_state_send'
nparam(object, ...)

## S3 method for class 'ergm_state_full'
update(
  object,
  el = NULL,
  nw0 = NULL,
  model = NULL,
  proposal = NULL,
  stats = NULL,
  ext.state = NULL,
  state = NULL,
  ...
)

## S3 method for class 'ergm_state'
ergm_state(x, model = NULL, proposal = NULL, stats = NULL, ...)

ERGM_STATE_R_CHANGED

ERGM_STATE_C_CHANGED

ERGM_STATE_RECONCILED

ergm_state_send(x, ...)

## S3 method for class 'ergm_state_send'
ergm_state_send(x, ...)

## S3 method for class 'ergm_state_full'
ergm_state_send(x, ...)

## S3 method for class 'ergm_state_receive'
ergm_state_send(x, ...)

## S3 method for class 'ergm_state_send'
update(object, state, ...)

ergm_state_receive(x, ...)

## S3 method for class 'ergm_state'
ergm_state_receive(x, ...)

## S3 method for class 'ergm_state_full'
ergm_state_receive(x, ...)

## S3 method for class 'ergm_state'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_state_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to further methods.</p>
</td></tr>
<tr><td><code id="ergm_state_+3A_nw0">nw0</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object, whose edges are absent or ignored.</p>
</td></tr>
<tr><td><code id="ergm_state_+3A_model">model</code></td>
<td>
<p>an <code><a href="#topic+ergm_model">ergm_model</a></code> object.</p>
</td></tr>
<tr><td><code id="ergm_state_+3A_ext.state">ext.state</code></td>
<td>
<p>a list equal to the number of terms in the model,
providing the encoded extended state. This vector is usually
generated by <code>ext.encode()</code> function of an <code>ergm</code> term, but it
can be specified directly.</p>
</td></tr>
<tr><td><code id="ergm_state_+3A_na.omit">na.omit</code></td>
<td>
<p>Whether missing edges should be counted. Note that
missing edge information is not stored.</p>
</td></tr>
<tr><td><code id="ergm_state_+3A_state">state</code></td>
<td>
<p>An <code>ergm_state</code> to replace the state with.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>integer</code> of length 1.
</p>
<p>An object of class <code>integer</code> of length 1.
</p>
<p>An object of class <code>integer</code> of length 1.
</p>


<h3>Details</h3>

<p><code>ergm_state</code> is actually a hierarchy of classes, defined by what
they can be used for. Specifically,
</p>

<dl>
<dt>c(<code>ergm_state_receive</code>,<code>ergm_state</code>)</dt><dd><p> needs to contain only <code>el</code>, <code>ext.state</code>, and <code>ext.flag</code>: it is the information that can change in the process of MCMC sampling; it is the one returned by the <code style="white-space: pre;">&#8288;*_slave&#8288;</code> functions, to minimize the amount of data being sent between nodes in parallel computing.</p>
</dd>
<dt>c(<code>ergm_state_send</code>,<code>ergm_state_receive</code>,<code>ergm_state</code>)</dt><dd><p> needs the above but also the <code>model</code> and the <code>proposal</code>: is needed to initiate MCMC sampling; it is the information required by the <code style="white-space: pre;">&#8288;*_slave&#8288;</code> functions, again, to minimize the amount of data being sent between nodes in parallel computing.</p>
</dd>
<dt>c(<code>ergm_state_full</code>, <code>ergm_state_send</code>,<code>ergm_state_receive</code>,<code>ergm_state</code>)</dt><dd><p> needs the above but also the <code>nw0</code>: is needed to reconstruct the original network.</p>
</dd>
</dl>



<h3>Value</h3>

<p>At this time, an <code>ergm_state</code> object is (subject to change)
a list containing some subset of the following elements, with
<code>el</code>, <code>ext.state</code>, and <code>ext.flag</code> mandatory and others depending
on how it is used:
</p>

<dl>
<dt>el</dt><dd><p>a <code><a href="tibble.html#topic+tibble">tibble</a></code> <code><a href="network.html#topic+edgelist">edgelist</a></code> representing the edge state of the network</p>
</dd>
<dt>nw0</dt><dd><p>a <code><a href="network.html#topic+network">network</a></code> object with all edges removed.</p>
</dd>
<dt>model</dt><dd><p>an <code><a href="#topic+ergm_model">ergm_model</a></code> object.</p>
</dd>
<dt>proposal</dt><dd><p>an <code><a href="#topic+ergm_proposal">ergm_proposal</a></code> object.</p>
</dd>
<dt>ext.state</dt><dd><p>a list of length equalling to the number of terms in the model.</p>
</dd>
<dt>ext.flag</dt><dd><p>one of <code>ERGM_STATE_R_CHANGED</code>, <code>ERGM_STATE_C_CHANGED</code>, and <code>ERGM_STATE_R_RECONCILED</code>.</p>
</dd>
<dt>stats</dt><dd><p>a numeric vector of network statistics or some other
statistics used to resume.</p>
</dd>
<dt>uids</dt><dd><p>a named list of globally unique ID strings associated with a <code>model</code> and/or <code>proposal</code>; for the <code>ergm_state_send</code> and <code>ergm_state_receive</code>, these strings may be retained even if these values are set to <code>NULL</code></p>
</dd>
</dl>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ergm_state(edgelist)</code>: a method for constructing an ergm_state from an <code><a href="network.html#topic+edgelist">edgelist</a></code> object and an empty <code><a href="network.html#topic+network">network</a></code>.
</p>
</li>
<li> <p><code>ergm_state(matrix)</code>: a method for constructing an ergm_state from a matrix object and an empty <code><a href="network.html#topic+network">network</a></code>.
</p>
</li>
<li> <p><code>ergm_state(network)</code>: a method for constructing an ergm_state from
a <code><a href="network.html#topic+network">network</a></code> object. Note that <code>...</code> arguments will be passed
directly to the <code><a href="network.html#topic+edgelist">edgelist</a></code> method.
</p>
</li>
<li> <p><code>ergm_state(ergm_state)</code>: a method for constructing an <code>ergm_state</code>.
</p>
</li></ul>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>network.edgecount(ergm_state)</code>: Note that this method fails when
<code>na.omit=FALSE</code>, since missing edges are not stored.
</p>
</li>
<li> <p><code>network.naedgecount(ergm_state)</code>: A stub that returns 0.
</p>
</li>
<li> <p><code>summary(ergm_state)</code>: a very low-level function that calculates summary statistics associated with an <code><a href="#topic+ergm_state">ergm_state</a></code> object.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>network.dyadcount(ergm_state_full)</code>: Note that this method fails with
its default argument, since missing edges are not stored.
</p>
</li>
<li> <p><code>update(ergm_state_full)</code>: a method for updating an <code>ergm_state</code> and reconciling extended state.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+ergm_MCMC_sample">ergm_MCMC_sample()</a></code> for an example of manually
constructing and manipulating an <code>ergm_state</code>.
</p>

<hr>
<h2 id='ergm_state_cache'>A rudimentary cache for large objects</h2><span id='topic+ergm_state_cache'></span>

<h3>Description</h3>

<p>This cache is intended to store large, infrequently changing data
structures such as <code><a href="#topic+ergm_model">ergm_model</a></code>s and <code><a href="#topic+ergm_proposal">ergm_proposal</a></code>s on worker
nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_state_cache(
  comm = c("pass", "all", "clear", "insert", "get", "check", "list"),
  key,
  object
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_state_cache_+3A_comm">comm</code></td>
<td>
<p>a character string giving the desired function; see the
default argument above for permitted values and Details for
meanings; partial matching is supported.</p>
</td></tr>
<tr><td><code id="ergm_state_cache_+3A_key">key</code></td>
<td>
<p>a character string, typically a <code>digest::digest()</code> of
the object or a random string.</p>
</td></tr>
<tr><td><code id="ergm_state_cache_+3A_object">object</code></td>
<td>
<p>the object to be stored.
</p>
<p>Supported tasks are, respectively, to do nothing (the default),
return all entries (mainly useful for testing), clear the cache,
insert into cache, retrieve an object by key, check if a key is
present, or list keys defined.
</p>
<p>Deleting an entry can be accomplished by inserting a <code>NULL</code> for
that key.
</p>
<p>Cache is limited to a hard-coded size (currently 4). This should
accommodate an <code><a href="#topic+ergm_model">ergm_model</a></code> and an <code><a href="#topic+ergm_proposal">ergm_proposal</a></code> for
unconstrained and constrained MCMC. When additional objects are
stored, the oldest object is purged and garbage-collected.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If called via, say, <code>clusterMap(cl, ergm_state_cache, ...)</code>
the function will not accomplish anything. This is because
<code>parallel</code> package will serialise the <code>ergm_state_cache()</code>
function object, send it to the remote node, evaluate it there,
and fetch the return value. This will leave the environment of
the worker's <code>ergm_state_cache()</code> unchanged. To actually
evaluate it on the worker nodes, it is recommended to wrap it in
an empty function whose environment is set to <code><a href="base.html#topic+globalenv">globalenv()</a></code>. See
Examples below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Wrap ergm_state_cache() and call it explicitly from ergm:
call_ergm_state_cache &lt;- function(...) ergm::ergm_state_cache(...)

# Reset the function's environment so that it does not get sent to
# worker nodes (who have their own instance of ergm namespace
# loaded).
environment(call_ergm_state_cache) &lt;- globalenv()

# Now, call the the wrapper function, with ... below replaced by
# lists of desired arguments.
clusterMap(cl, call_ergm_state_cache, ...)

## End(Not run)

</code></pre>

<hr>
<h2 id='ergm_symmetrize'>Return a symmetrized version of a binary network</h2><span id='topic+ergm_symmetrize'></span><span id='topic+ergm_symmetrize.default'></span><span id='topic+ergm_symmetrize.network'></span>

<h3>Description</h3>

<p>Return a symmetrized version of a binary network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_symmetrize(x, rule = c("weak", "strong", "upper", "lower"), ...)

## Default S3 method:
ergm_symmetrize(x, rule = c("weak", "strong", "upper", "lower"), ...)

## S3 method for class 'network'
ergm_symmetrize(x, rule = c("weak", "strong", "upper", "lower"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_symmetrize_+3A_x">x</code></td>
<td>
<p>an object representing a network.</p>
</td></tr>
<tr><td><code id="ergm_symmetrize_+3A_rule">rule</code></td>
<td>
<p>a string specifying how the network is to be
symmetrized; see <code><a href="sna.html#topic+symmetrize">sna::symmetrize()</a></code> for details; for the
<code><a href="network.html#topic+network">network</a></code> method, it can also be a function or a list; see
Details.</p>
</td></tr>
<tr><td><code id="ergm_symmetrize_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="sna.html#topic+symmetrize">sna::symmetrize()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="network.html#topic+network">network</a></code> method requires more flexibility, in order
to specify how the edge attributes are handled. Therefore, <code>rule</code>
can be one of the following types: </p>

<dl>
<dt>a character vector</dt><dd><p>The string is interpreted as in
<code><a href="sna.html#topic+symmetrize">sna::symmetrize()</a></code>. For edge attributes, <code>"weak"</code> takes the
maximum value and <code>"strong"</code> takes the minimum
value&quot; for ordered attributes, and drops the unordered.</p>
</dd>
<dt>a function</dt><dd><p> The function is evaluated on a <code><a href="base.html#topic+data.frame">data.frame</a></code>
constructed by joining (via <code><a href="base.html#topic+merge">merge()</a></code>) the edge <code><a href="tibble.html#topic+tibble">tibble</a></code> with all
attributes and <code>NA</code> indicators with itself reversing tail and head
columns, and appending original columns with <code>".th"</code> and the
reversed columns with <code>".ht"</code>. It is then evaluated for each
attribute in turn, given two arguments: the data frame and the name
of the attribute.</p>
</dd>
<dt>a list</dt><dd><p>The list must have exactly one unnamed element, and
the remaining elements must be named with the names of edge
attributes. The elements of the list are interpreted as above,
allowing each edge attribute to be handled differently. Unnamed
arguments are dropped. </p>
</dd>
</dl>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ergm_symmetrize(default)</code>: The default method, passing the input on to <code><a href="sna.html#topic+symmetrize">sna::symmetrize()</a></code>.
</p>
</li>
<li> <p><code>ergm_symmetrize(network)</code>: A method for <code><a href="network.html#topic+network">network</a></code> objects, which preserves network and vertex attributes, and handles edge attributes.
</p>
</li></ul>


<h3>Note</h3>

<p>This was originally exported as a generic to overwrite
<code><a href="sna.html#topic+symmetrize">sna::symmetrize()</a></code>. By developer's request, it has been renamed;
eventually, <a href="https://CRAN.R-project.org/package=sna"><span class="pkg">sna</span></a> or <code>network</code> packages will export the generic
instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sampson)
samplike[1,2] &lt;- NA
samplike[4.1] &lt;- NA
sm &lt;- as.matrix(samplike)

tst &lt;- function(x,y){
  mapply(identical, x, y)
}

stopifnot(all(tst(as.logical(as.matrix(ergm_symmetrize(samplike, "weak"))), sm | t(sm))),
          all(tst(as.logical(as.matrix(ergm_symmetrize(samplike, "strong"))), sm &amp; t(sm))),
          all(tst(c(as.matrix(ergm_symmetrize(samplike, "upper"))),
                  sm[cbind(c(pmin(row(sm),col(sm))),c(pmax(row(sm),col(sm))))])),
          all(tst(c(as.matrix(ergm_symmetrize(samplike, "lower"))),
                  sm[cbind(c(pmax(row(sm),col(sm))),c(pmin(row(sm),col(sm))))])))
</code></pre>

<hr>
<h2 id='ergm-defunct'>Functions that have been removed from this package</h2><span id='topic+ergm-defunct'></span><span id='topic+robust.inverse'></span><span id='topic+plot.network.ergm'></span><span id='topic+ergm.getterms'></span><span id='topic+plot.mcmc.list.ergm'></span><span id='topic+plot.ergm'></span><span id='topic+summary.statistics'></span><span id='topic+ergm.checkargs'></span><span id='topic+ergm.checkbipartite'></span><span id='topic+ergm.checkdirected'></span><span id='topic+summary.gof'></span><span id='topic+ergm.getMCMCsample'></span><span id='topic+ergm.MHP.table'></span><span id='topic+MHproposal'></span><span id='topic+MHproposal.character'></span><span id='topic+MHproposal.ergm'></span><span id='topic+MHproposal.formula'></span><span id='topic+ergm.init.methods'></span><span id='topic+ergm.ConstraintImplications'></span><span id='topic+ergm.mcmcslave'></span><span id='topic+ergm.update.formula'></span><span id='topic+remove.offset.formula'></span><span id='topic+network.update'></span><span id='topic+ergm.getmodel'></span><span id='topic+ergm.getglobalstats'></span><span id='topic+as.edgelist.compressed'></span><span id='topic+as.network.uncompressed'></span><span id='topic+standardize.network'></span><span id='topic+newnw.extract'></span><span id='topic+san.ergm'></span><span id='topic+is.inCH'></span><span id='topic+as.rlebdm.ergm'></span>

<h3>Description</h3>

<p>Functions that have been removed after a period of deprecation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust.inverse(...)

plot.network.ergm(...)

ergm.getterms(...)

plot.mcmc.list.ergm(...)

plot.ergm(...)

summary.statistics(...)

ergm.checkargs(...)

ergm.checkbipartite(...)

ergm.checkdirected(...)

summary.gof(...)

ergm.getMCMCsample(...)

ergm.MHP.table(...)

MHproposal(...)

MHproposal.character(...)

MHproposal.ergm(...)

MHproposal.formula(...)

ergm.init.methods(...)

ergm.ConstraintImplications(...)

ergm.mcmcslave(...)

ergm.update.formula(...)

remove.offset.formula(...)

network.update(...)

ergm.getmodel(...)

ergm.getglobalstats(...)

as.edgelist.compressed(...)

as.network.uncompressed(...)

standardize.network(...)

newnw.extract(...)

san.ergm(...)

is.inCH(...)

as.rlebdm.ergm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm-defunct_+3A_...">...</code></td>
<td>
<p>Arguments to defunct functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>robust.inverse()</code>: use <code>MASS::ginv()</code>.
</p>
<p><code>plot.network.ergm()</code>: use <code>latentnet::plot.ergmm()</code>.
</p>
<p><code>ergm.getterms()</code>: use <code>statnet.common::list_rhs.formula()</code> and <code>statnet.common::eval_lhs.formula()</code>.
</p>
<p><code>plot.mcmc.list.ergm()</code>: use <code>ergm_plot.mcmc.list()</code>.
</p>
<p><code>plot.ergm()</code>: use <code>mcmc.diagnostics()</code>.
</p>
<p><code>summary.statistics()</code>: use <code>summary_formula()</code>.
</p>
<p><code>ergm.checkargs()</code>: use <code>check.ErgmTerm()</code>.
</p>
<p><code>ergm.checkbipartite()</code>: use <code>check.ErgmTerm()</code>.
</p>
<p><code>ergm.checkdirected()</code>: use <code>check.ErgmTerm()</code>.
</p>
<p><code>summary.gof()</code>: use <code>print.gof()</code>.
</p>
<p><code>ergm.getMCMCsample()</code>: use <code>ergm_MCMC_sample()</code>.
</p>
<p><code>ergm.MHP.table()</code>: use <code>ergm_proposal_table()</code>.
</p>
<p><code>MHproposal()</code>: use <code>ergm_proposal()</code>.
</p>
<p><code>MHproposal.character()</code>: use <code>ergm_proposal()</code>.
</p>
<p><code>MHproposal.ergm()</code>: use <code>ergm_proposal()</code>.
</p>
<p><code>MHproposal.formula()</code>: use <code>ergm_proposal()</code>.
</p>
<p><code>ergm.init.methods()</code>: Initial methods are now specified in <code style="white-space: pre;">&#8288;InitErgmReference.*()&#8288;</code> functions.
</p>
<p><code>ergm.ConstraintImplications()</code>: Implications are now specified in the <code style="white-space: pre;">&#8288;InitErgmConstraint.*()&#8288;</code> functions.
</p>
<p><code>ergm.mcmcslave()</code>: use <code>ergm_MCMC_slave()</code>.
</p>
<p><code>ergm.update.formula()</code>: use <code>statnet.common::nonsimp_update.formula()</code>.
</p>
<p><code>remove.offset.formula()</code>: use <code>statnet.common::filter_rhs.formula()</code>.
</p>
<p><code>network.update()</code>: use <code>update.network()</code>.
</p>
<p><code>ergm.getmodel()</code>: use <code>ergm_model()</code>.
</p>
<p><code>ergm.getglobalstats()</code>: use <code>summary.ergm_model()</code>.
</p>
<p><code>as.edgelist.compressed()</code>: no longer used
</p>
<p><code>as.network.uncompressed()</code>: no longer used
</p>
<p><code>standardize.network()</code>: obviated by improvements to <code>network</code> package.
</p>
<p><code>newnw.extract()</code>: use <code>ergm_state</code> &quot;API&quot;
</p>
<p><code>san.ergm()</code>: removed due to no meaningful use case
</p>
<p><code>is.inCH()</code>: use <code>shrink_into_CH()</code>.
</p>
<p><code>as.rlebdm.ergm()</code>: no longer used
</p>

<hr>
<h2 id='ergm-deprecated'>Functions that will no longer be supported in future releases of the package</h2><span id='topic+ergm-deprecated'></span><span id='topic+coef.ergm'></span><span id='topic++24.ergm'></span><span id='topic+InitErgmTerm.degreepopularity'></span><span id='topic+InitErgmTerm.hammingmix'></span><span id='topic+hammingmix'></span><span id='topic+InitErgmTerm.idegreepopularity'></span><span id='topic+InitErgmTerm.odegreepopularity'></span><span id='topic+offset.info.formula'></span>

<h3>Description</h3>

<p>Functions that have been superceed, were never documented, or will be removed from the package for other reasons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm'
coef(object, ...)

## S3 method for class 'ergm'
x$name

InitErgmTerm.degreepopularity(nw, arglist, ...)

InitErgmTerm.hammingmix(nw, arglist, ..., version = packageVersion("ergm"))

InitErgmTerm.idegreepopularity(nw, arglist, ...)

InitErgmTerm.odegreepopularity(nw, arglist, ...)

offset.info.formula(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm-deprecated_+3A_name">name</code></td>
<td>
<p>See <a href="base.html#topic+Extract">Extract</a>.</p>
</td></tr>
<tr><td><code id="ergm-deprecated_+3A_nw">nw</code>, <code id="ergm-deprecated_+3A_arglist">arglist</code>, <code id="ergm-deprecated_+3A_...">...</code>, <code id="ergm-deprecated_+3A_formula">formula</code>, <code id="ergm-deprecated_+3A_object">object</code>, <code id="ergm-deprecated_+3A_x">x</code></td>
<td>
<p>Arguments to deprecated functions.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>coef(ergm)</code>: extracts the <code>ergm</code> parameters; may be
removed in favour of the default method once the number of <code>ergm</code>
objects with <code style="white-space: pre;">&#8288;$coef&#8288;</code> elements in the wild is sufficiently low.
</p>
</li>
<li> <p><code>$</code>: accesses elements of <code>ergm</code> objects;
needed for backwards compatibility when components get renamed.
</p>
</li>
<li> <p><code>InitErgmTerm.degreepopularity()</code>: Use <code><a href="#topic+degree1.5-ergmTerm">degree1.5</a></code> instead.
</p>
</li>
<li> <p><code>InitErgmTerm.idegreepopularity()</code>: Use <code><a href="#topic+idegree1.5-ergmTerm">idegree1.5</a></code> instead.
</p>
</li>
<li> <p><code>InitErgmTerm.odegreepopularity()</code>: Use <code><a href="#topic+odegree1.5-ergmTerm">odegree1.5</a></code> instead.
</p>
</li>
<li> <p><code>offset.info.formula()</code>: <code>offset.info.formula</code> returns the offset
vectors associated with a formula.
</p>
</li></ul>

<hr>
<h2 id='ergm-errors'>Sensible error and warning messages by <code>ergm</code> initializers</h2><span id='topic+ergm-errors'></span><span id='topic+ergm_Init_abort'></span><span id='topic+ergm_Init_warn'></span><span id='topic+ergm_Init_inform'></span><span id='topic+ergm_Init_try'></span>

<h3>Description</h3>

<p>These functions use traceback and pattern matching to find which
<code>ergm</code> initializer caused the problem, and prepend this information
to the specified message. They are not meant to be used by
end-users, but may be useful to developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_Init_abort(..., default.loc = NULL)

ergm_Init_warn(..., default.loc = NULL)

ergm_Init_inform(..., default.loc = NULL)

ergm_Init_try(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm-errors_+3A_...">...</code></td>
<td>
<p>Objects that can be coerced (via <code><a href="base.html#topic+paste0">paste0()</a></code>) into a
character vector, concatenated into the message.</p>
</td></tr>
<tr><td><code id="ergm-errors_+3A_default.loc">default.loc</code></td>
<td>
<p>Optional name for the source of the error, to be
used if an initializer cannot be autodetected.</p>
</td></tr>
<tr><td><code id="ergm-errors_+3A_expr">expr</code></td>
<td>
<p>Expression to be evaluated (in the caller's
environment).</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>ergm_Init_try()</code>: A helper function that evaluates the
specified expression in the caller's environment, passing any
errors to <code><a href="#topic+ergm_Init_abort">ergm_Init_abort()</a></code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="base.html#topic+stop">stop()</a></code>, <code><a href="rlang.html#topic+abort">abort()</a></code>
</p>
<p><code><a href="base.html#topic+warning">warning()</a></code>, <code><a href="rlang.html#topic+warn">warn()</a></code>
</p>
<p><code><a href="base.html#topic+message">message()</a></code>, <code><a href="rlang.html#topic+inform">inform()</a></code>
</p>
<p><code><a href="base.html#topic+try">try()</a></code>, <code><a href="base.html#topic+tryCatch">tryCatch()</a></code>
</p>

<hr>
<h2 id='ergm-internal'>Internal ergm Objects</h2><span id='topic+ergm-internal'></span><span id='topic+ergm.logitreg'></span><span id='topic+ergm_conlist'></span>

<h3>Description</h3>

<p>Internal <code><a href="#topic+ergm-package">ergm</a></code> functions.
</p>


<h3>Details</h3>

<p>Most of these are not to be called by the user (or in some cases are just
waiting for proper documentation to be written.
</p>


<h3>See Also</h3>

<p>ergm-package
</p>

<hr>
<h2 id='ergm-options'>Global options and term options for the <code>ergm</code> package</h2><span id='topic+ergm-options'></span><span id='topic+term.options'></span><span id='topic+ergmTerm-options'></span>

<h3>Description</h3>

<p>Options set via the built-in <code><a href="base.html#topic+options">options()</a></code> functions that affect <code>ergm</code> estimation and options that control the behavior of some terms.
</p>


<h3>Global options and defaults</h3>


<dl>
<dt>ergm.eval.loglik = TRUE</dt><dd><p>Whether <code><a href="#topic+ergm">ergm()</a></code> and similar functions will evaluate the likelihood of the fitted model. Can be overridden for a specific call by passing <code>eval.loglik</code> argument directly.</p>
</dd>
<dt><code>ergm.loglik.warn_dyads = TRUE</code></dt><dd><p>Whether log-likelihood evaluation should issue a warning when the effective number of dyads that can vary in the sample space is poorly defined, such as if the degree sequence is constrained.</p>
</dd>
<dt><code>ergm.cluster.retries = 5</code></dt><dd><p><span class="pkg">ergm</span>'s parallel routines implement rudimentary fault-tolerance. This option controls the number of retries for a cluster call before giving up.</p>
</dd>
<dt><code>ergm.term = list()</code></dt><dd><p>The default term options below.</p>
</dd>
</dl>



<h3>Term options</h3>

<p>Term options can be set in three places, in the order of precedence from high to low:
</p>

<ol>
<li><p> As a term argument (not always). For example, <code>gw.cutoff</code> below can be set in a <code><a href="#topic+gwesp-ergmTerm">gwesp</a></code> term by <code>gwesp(..., cutoff=X)</code>.
</p>
</li>
<li><p> For functions such as <code><a href="#topic+summary_formula.network">summary</a></code> that take <code>ergm</code> formulas but do not take a control list, the named arguments passed in as <code>...</code>. E.g, <code>summary(nw~gwesp(.5,fix=TRUE), gw.cutoff=60)</code> will evaluate the GWESP statistic with its cutoff set to 60.
</p>
</li>
<li><p> As an element in a <code style="white-space: pre;">&#8288;term.options=&#8288;</code> list passed via a control function such as <code><a href="#topic+control.ergm">control.ergm()</a></code> or, for functions that do not, in a list with that argument name. E.g., <code>summary(nw~gwesp(.5,fix=TRUE), term.options=list(gw.cutoff=60))</code> has the same effect.
</p>
</li>
<li><p> As an element in a global option list <code>ergm.term</code> above.
</p>
</li></ol>

<p>The following options are in use by terms in the <code>ergm</code> package:
</p>

<dl>
<dt><code>version</code></dt><dd><p>A string that can be interpreted as an <span class="rlang"><b>R</b></span> package version. If set, the term will attempt to emulate its behavior as it was that version of <code>ergm</code>. Not all past version behaviors are available.</p>
</dd>
<dt><code>gw.cutoff</code></dt><dd><p>In geometrically weighted terms (<code>gwesp</code>, <code>gwdegree</code>, etc.) the highest number of shared partners, degrees, etc. for which to compute the statistic. This usually defaults to 30.</p>
</dd>
<dt><code>cache.sp</code></dt><dd><p>Whether the <code><a href="#topic+gwesp-ergmTerm">gwesp</a></code>, <code><a href="#topic+dgwesp-ergmTerm">dgwesp</a></code>, and similar terms need should use a cache for the dyadwise number of shared partners. This usually improves performance significantly at a modest memory cost, and therefore defaults to <code>TRUE</code>, but it can be disabled.</p>
</dd>
<dt><code>interact.dependent</code></dt><dd><p>Whether to allow and how to handle the user attempting to interact dyad-dependent terms (e.g., <code>absdiff("age"):triangles</code> or <code>absdiff("age")*triangles</code> as opposed to <code>absdiff("age"):nodefactor("sex")</code>). Possible values are <code>"error"</code> (the default), <code>"message"</code>, and <code>"warning"</code>, for their respective actions, and <code>"silent"</code> for simply processing the term.</p>
</dd>
</dl>


<hr>
<h2 id='ergm-package'>Fit, Simulate and Diagnose Exponential-Family Models for Networks</h2><span id='topic+ergm-package'></span>

<h3>Description</h3>

<p><code><a href="#topic+ergm-package">ergm</a></code> (Hunter et al. 2008; Krivitsky et al. 2023) is a collection of functions to plot, fit,
diagnose, and simulate from exponential-family random graph models (ERGMs).
For a list of functions type: <code>help(package='ergm')</code>
</p>


<h3>Details</h3>

<p>For a complete list of the functions, use <code>library(help="ergm")</code> or
read the rest of the manual. For a simple demonstration, use
<code>demo(packages="ergm")</code>.
</p>
<p>When publishing results obtained using this package, please cite the
original authors as described in <code>citation(package="ergm")</code>.
</p>
<p>All programs derived from this package must cite it. Please see the
file <code>LICENSE</code> and <a href="https://statnet.org/attribution">https://statnet.org/attribution</a>.
</p>
<p>Recent advances in the statistical modeling of random networks have had an
impact on the empirical study of social networks. Statistical exponential
family models (Strauss and Ikeda 1990) are a generalization of the Markov
random network models introduced by Frank and Strauss (1986), which in turn
derived from developments in spatial statistics (Besag, 1974). These models
recognize the complex dependencies within relational data structures.  To
date, the use of stochastic network models for networks has been limited by
three interrelated factors: the complexity of realistic models, the lack of
simulation tools for inference and validation, and a poor understanding of
the inferential properties of nontrivial models.
</p>
<p>This manual introduces software tools for the representation, visualization,
and analysis of network data that address each of these previous
shortcomings.  The package relies on the <code><a href="network.html#topic+network">network</a></code>
package which allows networks to be represented in . The
<code><a href="#topic+ergm-package">ergm</a></code> package implements maximum likelihood
estimates of ERGMs to be calculated using Markov Chain Monte Carlo (via
<code><a href="#topic+ergm">ergm</a></code>). The package also provides tools for simulating networks
(via <code><a href="#topic+simulate.ergm">simulate.ergm</a></code>) and assessing model goodness-of-fit (see
<code><a href="#topic+mcmc.diagnostics">mcmc.diagnostics</a></code> and <code><a href="#topic+gof.ergm">gof.ergm</a></code>).
</p>
<p>A number of Statnet Project packages extend and enhance
<span class="pkg"><a href="#topic+ergm-package">ergm</a></span>. These include
<a href="https://CRAN.R-project.org/package=tergm"><span class="pkg">tergm</span></a> (Temporal ERGM), which provides
extensions for modeling evolution of networks over time;
<a href="https://CRAN.R-project.org/package=ergm.count"><span class="pkg">ergm.count</span></a>, which facilitates
exponential family modeling for networks whose dyadic measurements are
counts; and
<span class="pkg">ergm.userterms</span>, available on GitHub at <a href="https://github.com/statnet/ergm.userterms">https://github.com/statnet/ergm.userterms</a>, which
allows users to implement their own ERGM terms.
</p>
<p>For detailed information on how to download and install the software, go to
the <code><a href="#topic+ergm-package">ergm</a></code> website: <a href="https://statnet.org">https://statnet.org</a>. A
tutorial, support newsgroup, references and links to further resources are
provided there.
</p>


<h3>Author(s)</h3>

<p>Mark S. Handcock <a href="mailto:handcock@stat.ucla.edu">handcock@stat.ucla.edu</a>,<br /> David R. Hunter
<a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>,<br /> Carter T. Butts
<a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>,<br /> Steven M. Goodreau
<a href="mailto:goodreau@u.washington.edu">goodreau@u.washington.edu</a>,<br /> Pavel N. Krivitsky
<a href="mailto:pavel@statnet.org">pavel@statnet.org</a>, and<br /> Martina Morris
<a href="mailto:morrism@u.washington.edu">morrism@u.washington.edu</a>
</p>
<p>Maintainer: Pavel N. Krivitsky <a href="mailto:pavel@statnet.org">pavel@statnet.org</a>
</p>


<h3>References</h3>

<p>Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008).
&ldquo;ergm: A Package to Fit, Simulate and Diagnose Exponential-Family Models for Networks.&rdquo;
<em>Journal of Statistical Software</em>, <b>24</b>(3), 1&ndash;29.
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>.<br /><br /> Krivitsky PN, Hunter DR, Morris M, Klumb C (2023).
&ldquo;ergm 4: New Features for Analyzing Exponential-Family Random Graph Models.&rdquo;
<em>Journal of Statistical Software</em>, <b>105</b>(6), 1&ndash;44.
<a href="https://doi.org/10.18637/jss.v105.i06">doi:10.18637/jss.v105.i06</a>.
</p>
<p>Admiraal R, Handcock MS (2007).  <span class="pkg">networksis</span>: Simulate
bipartite graphs with fixed marginals through sequential importance
sampling.  Statnet Project, Seattle, WA.  Version 1,
<a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Bender-deMoll S, Morris M, Moody J (2008).  Prototype Packages for Managing
and Animating Longitudinal Network Data: <span class="pkg">dynamicnetwork</span> and
<span class="pkg">rSoNIA</span>.  <em>Journal of Statistical Software</em>, 24(7).
<a href="https://doi.org/10.18637/jss.v024.i07">doi:10.18637/jss.v024.i07</a>
</p>
<p>Besag, J., 1974, Spatial interaction and the statistical analysis of lattice
systems (with discussion), <em>Journal of the Royal Statistical Society,
B</em>, 36, 192-236.
</p>
<p>Boer P, Huisman M, Snijders T, Zeggelink E (2003).  StOCNET: an open
software system for the advanced statistical analysis of social networks.
Groningen: ProGAMMA / ICS, version 1.4 edition.
</p>
<p>Butts CT (2007).  <span class="pkg">sna</span>: Tools for Social Network Analysis.  R package
version 2.3-2. <a href="https://cran.r-project.org/package=sna">https://cran.r-project.org/package=sna</a>
</p>
<p>Butts CT (2008).  <span class="pkg">network</span>: A Package for Managing Relational Data in .
<em>Journal of Statistical Software</em>, 24(2).
<a href="https://doi.org/10.18637/jss.v024.i02">doi:10.18637/jss.v024.i02</a>
</p>
<p>Butts C (2015). <span class="pkg">network</span>: Classes for Relational Data. The Statnet
Project (<a href="https://statnet.org">https://statnet.org</a>). R package version 1.12.0,
<a href="https://cran.r-project.org/package=network">https://cran.r-project.org/package=network</a>.
</p>
<p>Frank, O., and Strauss, D.(1986). Markov graphs. <em>Journal of the
American Statistical Association</em>, 81, 832-842.
</p>
<p>Goodreau SM, Handcock MS, Hunter DR, Butts CT, Morris M (2008a).  A
<span class="pkg">statnet</span> Tutorial.  <em>Journal of Statistical Software</em>, 24(8).
<a href="https://doi.org/10.18637/jss.v024.i08">doi:10.18637/jss.v024.i08</a>
</p>
<p>Goodreau SM, Kitts J, Morris M (2008b).  Birds of a Feather, or Friend of a
Friend? Using Exponential Random Graph Models to Investigate Adolescent
Social Networks.  <em>Demography</em>, 45, in press.
</p>
<p>Handcock, M. S. (2003) Assessing Degeneracy in Statistical Models of Social
Networks, Working Paper #39, Center for Statistics and the Social Sciences,
University of Washington.
<a href="https://csss.uw.edu/research/working-papers/assessing-degeneracy-statistical-models-social-networks">https://csss.uw.edu/research/working-papers/assessing-degeneracy-statistical-models-social-networks</a>
</p>
<p>Handcock MS (2003b).  <span class="pkg">degreenet</span>: Models for Skewed Count Distributions
Relevant to Networks.  Statnet Project, Seattle, WA.  Version 1.0,
<a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Handcock MS, Hunter DR, Butts CT, Goodreau SM, Morris M (2003a).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose Exponential-Family
Models for Networks.  Statnet Project, Seattle, WA.  Version 3,
<a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Handcock MS, Hunter DR, Butts CT, Goodreau SM, Morris M (2003b).
<span class="pkg">statnet</span>: Software Tools for the Statistical Modeling of Network Data.
Statnet Project, Seattle, WA.  Version 3, <a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Hunter, D. R. and Handcock, M. S. (2006) Inference in curved exponential
family models for networks, <em>Journal of Computational and Graphical
Statistics</em>, 15: 565-583
</p>
<p>Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose Exponential-Family
Models for Networks.  <em>Journal of Statistical Software</em>, 24(3).
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>
</p>
<p>Krivitsky PN, Handcock MS (2007).  <span class="pkg">latentnet</span>: Latent position and
cluster models for statistical networks.  Seattle, WA.  Version 2,
<a href="https://statnet.org">https://statnet.org</a>.
</p>
<p>Krivitsky PN (2012). Exponential-Family Random Graph Models for Valued
Networks. <em>Electronic Journal of Statistics</em>, 2012, 6, 1100-1128.
<a href="https://doi.org/10.1214/12-EJS696">doi:10.1214/12-EJS696</a>
</p>
<p>Morris M, Handcock MS, Hunter DR (2008).  Specification of
Exponential-Family Random Graph Models: Terms and Computational Aspects.
<em>Journal of Statistical Software</em>, 24(4).
<a href="https://doi.org/10.18637/jss.v024.i04">doi:10.18637/jss.v024.i04</a>
</p>
<p>Strauss, D., and Ikeda, M.(1990). Pseudolikelihood estimation for social
networks. <em>Journal of the American Statistical Association</em>, 85,
204-212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code>, <code><a href="#topic+ergmConstraint">ergmConstraint</a></code>, <code><a href="#topic+ergmReference">ergmReference</a></code>,
<code><a href="#topic+ergmHint">ergmHint</a></code>, and <code><a href="#topic+ergmProposal">ergmProposal</a></code> for indices of model
specification and estimation components visible to the <a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a>'s API at any given time.
</p>

<hr>
<h2 id='ergm-parallel'>Parallel Processing in the <code>ergm</code> Package</h2><span id='topic+ergm-parallel'></span><span id='topic+parallel'></span><span id='topic+ergm.parallel'></span><span id='topic+parallel.ergm'></span><span id='topic+parallel-ergm'></span><span id='topic+ergm.getCluster'></span><span id='topic+ergm.stopCluster'></span><span id='topic+ergm.restartCluster'></span><span id='topic+set.MT_terms'></span><span id='topic+get.MT_terms'></span><span id='topic+nthreads'></span><span id='topic+nthreads.cluster'></span><span id='topic+nthreads.NULL'></span><span id='topic+nthreads.control.list'></span>

<h3>Description</h3>

<p>Using clusters multiple CPUs or CPU cores to speed up ERGM
estimation and simulation.
</p>
<p>The <code>ergm.getCluster</code> function is usually called
internally by the ergm process (in
<code><a href="#topic+ergm_MCMC_sample">ergm_MCMC_sample</a></code>) and will attempt to start the
appropriate type of cluster indicated by the
<code><a href="#topic+control.ergm">control.ergm</a></code> settings. It will also check that the
same version of <code>ergm</code> is installed on each node.
</p>
<p>The <code>ergm.stopCluster</code> shuts down a
cluster, but only if <code>ergm.getCluster</code> was responsible for
starting it.
</p>
<p>The <code>ergm.restartCluster</code> restarts and returns a cluster,
but only if <code>ergm.getCluster</code> was responsible for starting it.
</p>
<p><code>nthreads</code> is a simple generic to obtain the number of
parallel processes represented by its argument, keeping in mind
that having no cluster (e.g., <code>NULL</code>) represents one thread.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.getCluster(control = NULL, verbose = FALSE, stop_on_exit = parent.frame())

ergm.stopCluster(..., verbose = FALSE)

ergm.restartCluster(control = NULL, verbose = FALSE)

set.MT_terms(n)

get.MT_terms()

nthreads(clinfo = NULL, ...)

## S3 method for class 'cluster'
nthreads(clinfo = NULL, ...)

## S3 method for class ''NULL''
nthreads(clinfo = NULL, ...)

## S3 method for class 'control.list'
nthreads(clinfo = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm-parallel_+3A_control">control</code></td>
<td>
<p>a <code><a href="#topic+control.ergm">control.ergm</a></code> (or similar) list of
parameter values from which the parallel settings should be read;
can also be <code><a href="base.html#topic+NULL">NULL</a></code>, in which case an existing cluster is used
if started, or no cluster otherwise.</p>
</td></tr>
<tr><td><code id="ergm-parallel_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergm-parallel_+3A_stop_on_exit">stop_on_exit</code></td>
<td>
<p>An <code><a href="base.html#topic+environment">environment</a></code> or <code>NULL</code>. If an
<code>environment</code>, defaulting to that of the calling function, the
cluster will be stopped when the calling the frame in question
exits.</p>
</td></tr>
<tr><td><code id="ergm-parallel_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
<tr><td><code id="ergm-parallel_+3A_n">n</code></td>
<td>
<p>an integer specifying the number of threads to use; 0 (the
starting value) disables multithreading, and <code class="reqn">-1</code> or
<code>NA</code> sets it to the number of CPUs detected.</p>
</td></tr>
<tr><td><code id="ergm-parallel_+3A_clinfo">clinfo</code></td>
<td>
<p>a <code><a href="parallel.html#topic+makeCluster">cluster</a></code> or another object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For estimation that require MCMC, <a href="#topic+ergm-package">ergm</a> can take
advantage of multiple CPUs or CPU cores on the system on which it
runs, as well as computing clusters through one of two mechanisms:
</p>
<dl>
<dt>Running MCMC chains in parallel</dt><dd><p> Packages
<code>parallel</code> and <code>snow</code> are used to to facilitate this, all cluster
types that they support are supported.
</p>
<p>The number of nodes used and the parallel API are controlled using
the <code>parallel</code> and <code>parallel.type</code> arguments passed to the control
functions, such as <code><a href="#topic+control.ergm">control.ergm()</a></code>.
</p>
<p>The <code><a href="#topic+ergm.getCluster">ergm.getCluster()</a></code> function is usually called internally by
the ergm process (in <code><a href="#topic+ergm_MCMC_sample">ergm_MCMC_sample()</a></code>) and will attempt to
start the appropriate type of cluster indicated by the
<code><a href="#topic+control.ergm">control.ergm()</a></code> settings. The <code><a href="#topic+ergm.stopCluster">ergm.stopCluster()</a></code> is helpful if
the user has directly created a cluster.
</p>
<p>Further details on the various cluster types are included below.</p>
</dd>
<dt>Multithreaded evaluation of model terms</dt><dd><p> Rather than running
multiple MCMC chains, it is possible to attempt to accelerate
sampling by evaluating qualified terms' change statistics in
multiple threads run in parallel. This is done using the
<a href="https://www.openmp.org/">OpenMP</a> API.
</p>
<p>However, this introduces a nontrivial amont of computational
overhead. See below for a list of the major factors affecting
whether it is worthwhile.</p>
</dd></dl>

<p>Generally, the two approaches should not be used at the same time
without caution. In particular, by default, cluster slave nodes
will not &ldquo;inherit&rdquo; the multithreading setting; but
<code style="white-space: pre;">&#8288;parallel.inherit.MT=&#8288;</code> control parameter can override that. Their
relative advantages and disadvantages are as follows:
</p>

<ul>
<li><p> Multithreading terms cannot take advantage of clusters but only
of CPUs and cores.
</p>
</li>
<li><p> Parallel MCMC chains produce several independent chains;
multithreading still only produces one.
</p>
</li>
<li><p> Multithreading terms actually accellerates sampling, including
the burn-in phase; parallel MCMC's multiple burn-in runs are
effectively &ldquo;wasted&rdquo;.
</p>
</li></ul>



<h3>Value</h3>

<p><code><a href="#topic+set.MT_terms">set.MT_terms()</a></code> returns the previous setting, invisibly.
</p>
<p><code><a href="#topic+get.MT_terms">get.MT_terms()</a></code> returns the current setting.
</p>


<h3>Different types of clusters</h3>

<dl>
<dt>PSOCK clusters</dt><dd><p> The <code>parallel</code> package is used with PSOCK clusters
by default, to utilize multiple cores on a system. The number of
cores on a system can be determined with the <code><a href="parallel.html#topic+detectCores">detectCores()</a></code>
function.
</p>
<p>This method works with the base installation of R on all platforms,
and does not require additional software.
</p>
<p>For more advanced applications, such as clusters that span multiple
machines on a network, the clusters can be initialized manually,
and passed into <code><a href="#topic+ergm">ergm()</a></code> and others using the <code>parallel</code> control
argument. See the second example below.</p>
</dd>
<dt>MPI clusters</dt><dd><p> To use MPI to accelerate ERGM sampling,
pass the control parameter <code>parallel.type="MPI"</code>.
<a href="#topic+ergm-package">ergm</a> requires the <a href="https://CRAN.R-project.org/package=snow"><span class="pkg">snow</span></a> and <a href="https://CRAN.R-project.org/package=Rmpi"><span class="pkg">Rmpi</span></a> packages to
communicate with an MPI cluster.
</p>
<p>Using MPI clusters requires the system to have an existing MPI
installation.  See the MPI documentation for your particular
platform for instructions.
</p>
<p>To use <code><a href="#topic+ergm">ergm()</a></code> across multiple machines in a high performance
computing environment, see the section &quot;User initiated clusters&quot;
below.</p>
</dd>
<dt>User initiated clusters</dt><dd><p> A cluster can be passed into <code><a href="#topic+ergm">ergm()</a></code>
with the <code>parallel</code> control parameter. <code><a href="#topic+ergm">ergm()</a></code> will detect the
number of nodes in the cluster, and use all of them for MCMC
sampling. This method is flexible: it will accept any cluster type
that is compatible with <code>snow</code> or <code>parallel</code> packages.
</p>
</dd></dl>



<h3>When is multithreading terms worthwhile?</h3>


<ul>
<li><p> The more terms with statistics the model has, the more
benefit from parallel execution.
</p>
</li>
<li><p> The more expensive the terms in the model are, the more benefit
from parallel execution. For example, models with terms like
<code><a href="#topic+gwdsp-ergmTerm">gwdsp</a></code> will generally get more benefit than models where all
terms are dyad-independent.
</p>
</li>
<li><p> Sampling more dense networks will generally get more benefit than
sparse networks. Network size has little, if any, effect.
</p>
</li>
<li><p> More CPUs/cores usually give greater speed-up, but only up to a
point, because the amount of overhead grows with the number of
threads; it is often better to &ldquo;batch&rdquo; the terms into a smaller
number of threads than possible.
</p>
</li>
<li><p> Any other workload on the system will have a more severe effect
on multithreaded execution. In particular, do not run more
threads than CPUs/cores that you want to allocate to the tasks.
</p>
</li>
<li><p> Under Windows, even compiling with OpenMP appears to introduce
unacceptable amounts of overhead, so it is disabled for Windows
at compile time. To enable, <em>delete</em> <code>src/Makevars.win</code> and
recompile from scratch.
</p>
</li></ul>



<h3>Note</h3>

<p>The this is a setting global to the <code>ergm</code> package and all of
its C functions, including when called from other packages via
the <code>Linking-To</code> mechanism.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Uses 2 SOCK clusters for MCMLE estimation
data(faux.mesa.high)
nw &lt;- faux.mesa.high
fauxmodel.01 &lt;- ergm(nw ~ edges + isolates + gwesp(0.2, fixed=TRUE), 
                     control=control.ergm(parallel=2, parallel.type="PSOCK"))
summary(fauxmodel.01)



</code></pre>

<hr>
<h2 id='ergm.allstats'>Calculate all possible vectors of statistics on a network for an ERGM</h2><span id='topic+ergm.allstats'></span>

<h3>Description</h3>

<p><code>ergm.allstats</code> produces a matrix of network statistics for an
arbitrary <code>statnet</code> exponential-family random graph model.  One
possible use for this function is to calculate the exact loglikelihood
function for a small network via the <code><a href="#topic+ergm.exact">ergm.exact</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.allstats(
  formula,
  zeroobs = TRUE,
  force = FALSE,
  maxNumChangeStatVectors = 2^16,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.allstats_+3A_formula">formula</code></td>
<td>
<p>an <code><a href="stats.html#topic+formula">formula</a></code> object of the form <code>y ~ &lt;model
terms&gt;</code>, where <code>y</code> is a network object or a matrix that can be coerced
to a <code><a href="network.html#topic+network">network</a></code> object.  For the details on the possible
<code>&lt;model terms&gt;</code>, see <code><a href="#topic+ergmTerm">ergmTerm</a></code>.  To create a
<code><a href="network.html#topic+network">network</a></code> object in , use the <code>network()</code>
function, then add nodal attributes to it using the <code>%v%</code> operator if
necessary.</p>
</td></tr>
<tr><td><code id="ergm.allstats_+3A_zeroobs">zeroobs</code></td>
<td>
<p>Logical: Should the vectors be centered so that the network
passed in the <code>formula</code> has the zero vector as its statistics?</p>
</td></tr>
<tr><td><code id="ergm.allstats_+3A_force">force</code></td>
<td>
<p>Logical: Should the algorithm be run even if it is determined
that the problem may be very large, thus bypassing the warning message that
normally terminates the function in such cases?</p>
</td></tr>
<tr><td><code id="ergm.allstats_+3A_maxnumchangestatvectors">maxNumChangeStatVectors</code></td>
<td>
<p>Maximum possible number of distinct values of
the vector of statistics.  It's good to use a power of 2 for this.</p>
</td></tr>
<tr><td><code id="ergm.allstats_+3A_...">...</code></td>
<td>
<p>further arguments; not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mechanism for doing this is a recursive algorithm, where the number of
levels of recursion is equal to the number of possible dyads that can be
changed from 0 to 1 and back again.  The algorithm starts with the network
passed in <code>formula</code>, then recursively toggles each edge twice so that
every possible network is visited.
</p>
<p><code>ergm.allstats</code> should only be used for small networks, since the
number of possible networks grows extremely fast with the number of nodes.
An error results if it is used on a directed network of more than 6 nodes or
an undirected network of more than 8 nodes; use <code>force=TRUE</code> to
override this error.
</p>


<h3>Value</h3>

<p>Returns a list object with these two elements:
</p>
<table>
<tr><td><code>weights</code></td>
<td>
<p>integer of counts, one for each row of <code>statmat</code> telling
how many networks share the corresponding vector of statistics.</p>
</td></tr>
<tr><td><code>statmat</code></td>
<td>
<p>matrix in which each row is a unique vector of statistics.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergm.exact">ergm.exact</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Count by brute force all the edge statistics possible for a 7-node 
# undirected network
mynw &lt;- network(matrix(0,7,7),dir=FALSE)
system.time(a &lt;- ergm.allstats(mynw~edges))

# Summarize results
rbind(t(a$statmat),a$weights)

# Each value of a$weights is equal to 21-choose-k, 
# where k is the corresponding statistic (and 21 is 
# the number of dyads in an 7-node undirected network).  
# Here's a check of that fact:
as.vector(a$weights - choose(21, t(a$statmat)))

# Simple ergm.exact outpuf for this network.  
# We know that the loglikelihood for my empty 7-node network
# should simply be -21*log(1+exp(eta)), so we may check that
# the following two values agree:
-21*log(1+exp(.1234)) 
ergm.exact(.1234, mynw~edges, statmat=a$statmat, weights=a$weights)

</code></pre>

<hr>
<h2 id='ergm.bridge.llr'>Bridge sampling to evaluate ERGM log-likelihoods and log-likelihood ratios</h2><span id='topic+ergm.bridge.llr'></span><span id='topic+ergm.bridge.0.llk'></span><span id='topic+ergm.bridge.dindstart.llk'></span>

<h3>Description</h3>

<p><code>ergm.bridge.llr</code> uses bridge sampling with geometric spacing to
estimate the difference between the log-likelihoods of two parameter vectors
for an ERGM via repeated calls to <code><a href="#topic+simulate.formula.ergm">simulate.formula.ergm</a></code>.
</p>
<p><code>ergm.bridge.0.llk</code> is a convenience wrapper that
returns the log-likelihood of configuration <code class="reqn">\theta</code>
<em>relative to the reference measure</em>. That is, the
configuration with <code class="reqn">\theta=0</code> is defined as having log-likelihood of
0.
</p>
<p><code>ergm.bridge.dindstart.llk</code> is a wrapper that uses a
dyad-independent ERGM as a starting point for bridge sampling to
estimate the log-likelihood for a given dyad-dependent model and
parameter configuration.  Note that it only handles binary ERGMs
(<code>response=NULL</code>) and with constraints (<code style="white-space: pre;">&#8288;constraints=&#8288;</code>) that that
do not induce dyadic dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.bridge.llr(
  object,
  response = NULL,
  reference = ~Bernoulli,
  constraints = ~.,
  from,
  to,
  obs.constraints = ~. - observed,
  target.stats = NULL,
  basis = ergm.getnetwork(object),
  verbose = FALSE,
  ...,
  llronly = FALSE,
  control = control.ergm.bridge()
)

ergm.bridge.0.llk(
  object,
  response = NULL,
  reference = ~Bernoulli,
  coef,
  ...,
  llkonly = TRUE,
  control = control.ergm.bridge(),
  basis = ergm.getnetwork(object)
)

ergm.bridge.dindstart.llk(
  object,
  response = NULL,
  constraints = ~.,
  coef,
  obs.constraints = ~. - observed,
  target.stats = NULL,
  dind = NULL,
  coef.dind = NULL,
  basis = ergm.getnetwork(object),
  ...,
  llkonly = TRUE,
  control = control.ergm.bridge(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.bridge.llr_+3A_object">object</code></td>
<td>
<p>A model formula. See <code><a href="#topic+ergm">ergm</a></code> for details.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_reference">reference</code></td>
<td>
<p>A one-sided formula specifying the reference
measure (<code class="reqn">h(y)</code>) to be used.  (Defaults to
<code>~Bernoulli</code>.)</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_constraints">constraints</code>, <code id="ergm.bridge.llr_+3A_obs.constraints">obs.constraints</code></td>
<td>
<p>One-sided formulas specifying
one or more constraints on the support of the distribution of the
networks being simulated and on the observation process
respectively. See the documentation for similar arguments for
<code><a href="#topic+ergm">ergm</a></code> for more information.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_from">from</code>, <code id="ergm.bridge.llr_+3A_to">to</code></td>
<td>
<p>The initial and final parameter vectors.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_target.stats">target.stats</code></td>
<td>
<p>A vector of sufficient statistics to be used
in place of those of the network in the formula.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_basis">basis</code></td>
<td>
<p>An optional <code><a href="network.html#topic+network">network</a></code> object to
start the Markov chain.  If omitted, the default is the
left-hand-side of the <code>object</code>.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>ergm.bridge.llr</code> and
<code><a href="#topic+simulate.formula.ergm">simulate.formula.ergm</a></code>.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_llronly">llronly</code></td>
<td>
<p>Logical: If TRUE, only the estiamted log-ratio will
be returned by <code>ergm.bridge.llr</code>.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.ergm.bridge">control.ergm.bridge()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_coef">coef</code></td>
<td>
<p>A vector of coefficients for the configuration of
interest.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_llkonly">llkonly</code></td>
<td>
<p>Whether only the estiamted log-likelihood should be
returned by the <code>ergm.bridge.0.llk</code> and
<code>ergm.bridge.dindstart.llk</code>.  (Defaults to TRUE.)</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_dind">dind</code></td>
<td>
<p>A one-sided formula with the dyad-independent model to use as a
starting point. Defaults to the dyad-independent terms found in the formula
<code>object</code> with an overal density term (<code>edges</code>) added if not
redundant.</p>
</td></tr>
<tr><td><code id="ergm.bridge.llr_+3A_coef.dind">coef.dind</code></td>
<td>
<p>Parameter configuration for the dyad-independent starting
point. Defaults to the MLE of <code>dind</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>llronly=TRUE</code> or <code>llkonly=TRUE</code>, these functions return
the scalar log-likelihood-ratio or the log-likelihood.
Otherwise, they return a list with the following components:
</p>
<table>
<tr><td><code>llr</code></td>
<td>
<p>The estimated log-ratio.</p>
</td></tr>
<tr><td><code>llr.vcov</code></td>
<td>
<p>The estimated variance of the log-ratio due to
MCMC approximation.</p>
</td></tr>
<tr><td><code>llrs</code></td>
<td>
<p>A list of lists (1 per attempt) of the estimated
log-ratios for each of the <code>bridge.nsteps</code> bridges.</p>
</td></tr>
<tr><td><code>llrs.vcov</code></td>
<td>
<p>A list of lists (1 per attempt) of the estimated
variances of the estimated log-ratios for each of the
<code>bridge.nsteps</code> bridges.</p>
</td></tr>
<tr><td><code>paths</code></td>
<td>
<p>A list of lists (1 per attempt) with two elements:
<code>theta</code>, a numeric matrix with <code>bridge.nsteps</code> rows, with each
row being the respective bridge's parameter configuration; and
<code>weight</code>, a vector of length <code>bridge.nsteps</code> containing its
weight.</p>
</td></tr>
<tr><td><code>Dtheta.Du</code></td>
<td>
<p>The gradient vector of the parameter values with
respect to position of the bridge.</p>
</td></tr>
</table>
<p><code>ergm.bridge.0.llk</code> result list also includes an <code>llk</code>
element, with the log-likelihood itself (with the reference
distribution assumed to have likelihood 0).
</p>
<p><code>ergm.bridge.dindstart.llk</code> result list also includes
an <code>llk</code> element, with the log-likelihood itself and an
<code>llk.dind</code> element, with the log-likelihood of the nearest
dyad-independent model.
</p>


<h3>References</h3>

<p>Hunter, D. R. and Handcock, M. S. (2006)
<em>Inference in curved exponential family models for
networks</em>, Journal of Computational and Graphical Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.formula.ergm">simulate.formula.ergm</a></code>
</p>

<hr>
<h2 id='ergm.design'>Obtain the set of informative dyads based on the network structure.</h2><span id='topic+ergm.design'></span>

<h3>Description</h3>

<p>Note that this function is not recommended for general use, since
it only supports only one way of specifying observational
structure&mdash;through <code>NA</code> edges. It is likely to be deprecated in
the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.design(nw, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.design_+3A_nw">nw</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object.</p>
</td></tr>
<tr><td><code id="ergm.design_+3A_...">...</code></td>
<td>
<p>term options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ergm.design</code> returns a <code><a href="#topic+rlebdm">rlebdm</a></code> of
informative (non-missing, non fixed) dyads.
</p>

<hr>
<h2 id='ergm.estfun'>Compute the Sample Estimating Function Values of an ERGM.</h2><span id='topic+ergm.estfun'></span><span id='topic+ergm.estfun.numeric'></span><span id='topic+ergm.estfun.matrix'></span><span id='topic+ergm.estfun.mcmc'></span><span id='topic+ergm.estfun.mcmc.list'></span>

<h3>Description</h3>

<p>The estimating function for an ERGM is the score function: the
gradient of the log-likelihood, equalling <code class="reqn">\eta'(\theta)^\top
\{g(y)-\mu(\theta)\}</code>, where <code class="reqn">g(y)</code> is a <code class="reqn">p</code>-vector of
observed network sufficient statistic, <code class="reqn">\mu(\theta)</code> is the
expected value of the sufficient statistic under the model for
parameter value <code class="reqn">\theta</code>, and <code class="reqn">\eta'(\theta)</code> is the
<code class="reqn">p</code> by <code class="reqn">q</code> Jacobian matrix of the mapping from curved
parameters to natural parmeters.  If the model is linear, all
non-offset statistics are passed. If the model is curved, the score
estimating equations (3.1) by Hunter and Handcock (2006) are given
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.estfun(stats, theta, model, ...)

## S3 method for class 'numeric'
ergm.estfun(stats, theta, model, ...)

## S3 method for class 'matrix'
ergm.estfun(stats, theta, model, ...)

## S3 method for class 'mcmc'
ergm.estfun(stats, theta, model, ...)

## S3 method for class 'mcmc.list'
ergm.estfun(stats, theta, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.estfun_+3A_stats">stats</code></td>
<td>
<p>An object representing sample statistics with observed values subtracted out.</p>
</td></tr>
<tr><td><code id="ergm.estfun_+3A_theta">theta</code></td>
<td>
<p>Model parameter <code class="reqn">q</code>-vector.</p>
</td></tr>
<tr><td><code id="ergm.estfun_+3A_model">model</code></td>
<td>
<p>An <code><a href="#topic+ergm_model">ergm_model</a></code> object or its <code>etamap</code> element.</p>
</td></tr>
<tr><td><code id="ergm.estfun_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>stats</code> containing
<code class="reqn">q</code>-vectors of estimating function values.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ergm.estfun(numeric)</code>: Method for numeric vectors of length <code class="reqn">p</code>.
</p>
</li>
<li> <p><code>ergm.estfun(matrix)</code>: Method for matrices with <code class="reqn">p</code> columns.
</p>
</li>
<li> <p><code>ergm.estfun(mcmc)</code>: Method for <code><a href="coda.html#topic+mcmc">mcmc</a></code> objects with <code class="reqn">p</code> variables.
</p>
</li>
<li> <p><code>ergm.estfun(mcmc.list)</code>: Method for  <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects with <code class="reqn">p</code> variables.
</p>
</li></ul>

<hr>
<h2 id='ergm.eta'>Operations to map curved <code><a href="#topic+ergm">ergm()</a></code> parameters onto canonical parameters</h2><span id='topic+ergm.eta'></span><span id='topic+ergm.etagrad'></span><span id='topic+ergm.etagradmult'></span>

<h3>Description</h3>

<p>The <code>ergm.eta</code> function calculates and returns eta, mapped
from theta using the <code>etamap</code> object, usually attached as the
<code style="white-space: pre;">&#8288;$etamap&#8288;</code> element of an <code><a href="#topic+ergm_model">ergm_model</a></code> object.
</p>
<p>The <code>ergm.etagrad</code> function caculates and returns
the gradient of eta mapped from theta using the etamap object
created by <code>ergm.etamap</code>. If the gradient is only intended
to be a multiplier for some vector, the more efficient
<code>ergm.etagradmult</code> is recommended.
</p>
<p>The <code>ergm.etagradmult</code> function calculates and
returns the product of the gradient of eta with a vector <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.eta(theta, etamap)

ergm.etagrad(theta, etamap)

ergm.etagradmult(theta, v, etamap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.eta_+3A_theta">theta</code></td>
<td>
<p>the curved model parameters</p>
</td></tr>
<tr><td><code id="ergm.eta_+3A_etamap">etamap</code></td>
<td>
<p>the list of values that describes the theta -&gt; eta
mapping, usually attached as <code style="white-space: pre;">&#8288;$etamap&#8288;</code> element of an <code><a href="#topic+ergm_model">ergm_model</a></code>
object. At this time, it is a list with the following elements:
</p>

<dl>
<dt><code>canonical</code></dt><dd><p> a numeric vector whose <code>i</code>th entry specifies whether the <code>i</code>th component of theta is canonical (via non-negative integers) or curved (via zeroes)</p>
</dd>
<dt><code>offsetmap</code></dt><dd><p> a logical vector whose <code>i</code>th entry tells whether the ith coefficient of the canonical parameterization was &quot;offset&quot;, i.e fixed</p>
</dd>
<dt><code>offset</code></dt><dd><p> a logical vector whose ith entry tells whether the ith model term was offset/fixed</p>
</dd>
<dt><code>offsettheta</code></dt><dd><p> a logical vector whose ith entry tells whether the ith curved theta coeffient was offset/fixed;</p>
</dd>
<dt><code>curved</code></dt><dd><p> a list with one component per curved EF term in
the model containing </p>

<dl>
<dt><code>from</code></dt><dd><p> the indices of the curved theta parameter that are to be mapped from</p>
</dd>
<dt><code>to</code></dt><dd><p> the indices of the canonical eta parameters to be mapped to</p>
</dd>
<dt><code>map</code></dt><dd><p> the map provided by <code><a href="#topic+InitErgmTerm">InitErgmTerm</a></code></p>
</dd>
<dt><code>gradient</code></dt><dd><p> the gradient function provided by <code><a href="#topic+InitErgmTerm">InitErgmTerm</a></code></p>
</dd>
<dt><code>cov</code></dt><dd><p> optional additional covariates to be passed to the map and the gradient functions </p>
</dd>
<dt><code>etalength</code></dt><dd><p> the length of the eta vector</p>
</dd>
</dl>

</dd>
</dl>
</td></tr>
<tr><td><code id="ergm.eta_+3A_v">v</code></td>
<td>
<p>a vector of the same length as the vector of mapped eta
parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are mainly important in the case of curved exponential family
models, i.e., those in which the parameter of interest (theta) is not a
linear function of the natural parameters (eta) in the exponential-family
model. In non-curved models, we may assume without loss of generality that
eta(theta)=theta.
</p>
<p>A succinct description of how eta(theta) is incorporated into an ERGM is
given by equation (5) of Hunter (2007).  See Hunter and Handcock (2006) and
Hunter (2007) for further details about how eta and its derivatives are used
in the estimation process.
</p>


<h3>Value</h3>

<p>For <code>ergm.eta</code>, the canonical eta parameters as mapped
from theta.
</p>
<p>For <code>ergm.etagrad</code>, a matrix of the gradient of eta
with respect to theta.
</p>
<p>For <code>ergm.etagradmult</code>, the vector that is the product
of the gradient of eta and <code>v</code>.
</p>


<h3>References</h3>

 <ul>
<li><p> Hunter, D. R. and M. S. Handcock
(2006).  Inference in curved exponential family models for
networks. <em>Journal of Computational and Graphical
Statistics</em>, 15: 565&ndash;583.
</p>
</li>
<li><p> Hunter, D. R. (2007). Curved exponential family models for social
networks. <em>Social Networks</em>, 29: 216&ndash;230.  </p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code>
</p>

<hr>
<h2 id='ergm.exact'>Calculate the exact loglikelihood for an ERGM</h2><span id='topic+ergm.exact'></span>

<h3>Description</h3>

<p><code>ergm.exact</code> calculates the exact loglikelihood, evaluated at
<code>eta</code>, for the <code>statnet</code> exponential-family random graph model
represented by <code>formula</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.exact(eta, formula, statmat = NULL, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.exact_+3A_eta">eta</code></td>
<td>
<p>vector of canonical parameter values at which the loglikelihood
should be evaluated.</p>
</td></tr>
<tr><td><code id="ergm.exact_+3A_formula">formula</code></td>
<td>
<p>an <code>link{formula}</code> object of the form <code>y ~ &lt;model
terms&gt;</code>, where <code>y</code> is a network object or a matrix that can be coerced
to a <code><a href="network.html#topic+network">network</a></code> object.  For the details on the possible
<code>&lt;model terms&gt;</code>, see <code><a href="#topic+ergmTerm">ergmTerm</a></code>.  To create a
<code><a href="network.html#topic+network">network</a></code> object in , use the <code>network()</code>
function, then add nodal attributes to it using the <code>%v%</code> operator if
necessary.</p>
</td></tr>
<tr><td><code id="ergm.exact_+3A_statmat">statmat</code></td>
<td>
<p>if NULL, call <code><a href="#topic+ergm.allstats">ergm.allstats</a></code> to generate all
possible graph statistics for the networks in this model.</p>
</td></tr>
<tr><td><code id="ergm.exact_+3A_weights">weights</code></td>
<td>
<p>In case <code>statmat</code> is not <code>NULL</code>, this should be the
vector of counts corresponding to the rows of <code>statmat</code>. If
<code>statmat</code> is <code>NULL</code>, this is generated by the call to
<code><a href="#topic+ergm.allstats">ergm.allstats</a></code>.</p>
</td></tr>
<tr><td><code id="ergm.exact_+3A_...">...</code></td>
<td>
<p>further arguments; not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ergm.exact</code> should only be used for small networks, since the number
of possible networks grows extremely fast with the number of nodes.  An
error results if it is used on a directed network of more than 6 nodes or an
undirected network of more than 8 nodes; use <code>force=TRUE</code> to override
this error.
</p>
<p>In case this function is to be called repeatedly, for instance by an
optimization routine, it is preferable to call <code><a href="#topic+ergm.allstats">ergm.allstats</a></code>
first, then pass <code>statmat</code> and <code>weights</code> explicitly to avoid
repeatedly calculating these objects.
</p>


<h3>Value</h3>

<p>Returns the value of the exact loglikelihood, evaluated at
<code>eta</code>, for the <code>statnet</code> exponential-family random graph model
represented by <code>formula</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm.allstats">ergm.allstats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Count by brute force all the edge statistics possible for a 7-node 
# undirected network
mynw &lt;- network(matrix(0,7,7),dir=FALSE)
system.time(a &lt;- ergm.allstats(mynw~edges))

# Summarize results
rbind(t(a$statmat),a$weights)

# Each value of a$weights is equal to 21-choose-k, 
# where k is the corresponding statistic (and 21 is 
# the number of dyads in an 7-node undirected network).  
# Here's a check of that fact:
as.vector(a$weights - choose(21, t(a$statmat)))

# Simple ergm.exact outpuf for this network.  
# We know that the loglikelihood for my empty 7-node network
# should simply be -21*log(1+exp(eta)), so we may check that
# the following two values agree:
-21*log(1+exp(.1234)) 
ergm.exact(.1234, mynw~edges, statmat=a$statmat, weights=a$weights)

</code></pre>

<hr>
<h2 id='ergm.geodistdist'>Calculate geodesic distance distribution for a network or edgelist</h2><span id='topic+ergm.geodistdist'></span><span id='topic+ergm.geodistn'></span>

<h3>Description</h3>

<p><code>ergm.geodistdist</code> calculates geodesic distance distribution for a
given <code><a href="network.html#topic+network">network</a></code> and returns it as a vector.
</p>
<p><code>ergm.geodistn</code> calculates geodesic deistance
distribution based on an input edgelist, and has very little
error checking so should not normally be called by users. The C
code requires the edgelist to be directed and sorted correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.geodistdist(nw, directed = is.directed(nw))

ergm.geodistn(edgelist, n = max(edgelist), directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.geodistdist_+3A_nw">nw</code></td>
<td>
<p><code><a href="network.html#topic+network">network</a></code> object over which distances should be
calculated</p>
</td></tr>
<tr><td><code id="ergm.geodistdist_+3A_directed">directed</code></td>
<td>
<p>logical, should the network be treated as directed</p>
</td></tr>
<tr><td><code id="ergm.geodistdist_+3A_edgelist">edgelist</code></td>
<td>
<p>an edgelist representation of a network as an mx2 matrix</p>
</td></tr>
<tr><td><code id="ergm.geodistdist_+3A_n">n</code></td>
<td>
<p>integer, size of the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ergm.geodistdist</code> is a network wrapper for <code>ergm.geodistn</code>, which
calculates and returns the geodesic distance distribution for a given
network via full_geodesic_distribution.C
</p>


<h3>Value</h3>

<p>a vector <code>ans</code> with length equal to the size of the network
where </p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;ans[i], i=1, ..., n-1&#8288;</code> is the number of pairs of
geodesic length <code>i</code>
</p>
</li>
<li> <p><code>ans[n]</code> is the number of pairs of geodesic length
infinity.  </p>
</li></ul>



<h3>See Also</h3>

<p>See also the sna package <code><a href="sna.html#topic+geodist">geodist</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
ergm.geodistdist(faux.mesa.high)

</code></pre>

<hr>
<h2 id='ergm.getnetwork'>Acquire and verify the network from the LHS of an <code>ergm</code> formula
and verify that it is a valid network.</h2><span id='topic+ergm.getnetwork'></span>

<h3>Description</h3>

<p>The function function ensures that the network in a given formula
is valid; if so, the network is returned; if not, execution is
halted with warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.getnetwork(formula, loopswarning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.getnetwork_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula whose LHS is a <code><a href="network.html#topic+network">network</a></code>, an object that can be coerced to a <code><a href="network.html#topic+network">network</a></code>, or an expression that evaluates to one.</p>
</td></tr>
<tr><td><code id="ergm.getnetwork_+3A_loopswarning">loopswarning</code></td>
<td>
<p>whether warnings about loops should be printed
(<code>TRUE</code> or <code>FALSE</code>); defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="network.html#topic+network">network</a></code> object constructed by evaluating the LHS of
the model formula in the formula's environment.
</p>

<hr>
<h2 id='ergm.godfather'>A function to apply a given series of changes to a network.</h2><span id='topic+ergm.godfather'></span>

<h3>Description</h3>

<p>Gives the network a series of proposals it can't refuse. Returns the
statistics of the network, and, optionally, the final network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.godfather(
  formula,
  changes = NULL,
  response = NULL,
  end.network = FALSE,
  stats.start = FALSE,
  changes.only = FALSE,
  verbose = FALSE,
  control = control.ergm.godfather()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.godfather_+3A_formula">formula</code></td>
<td>
<p>An <code><a href="#topic+ergm">ergm</a></code>-style formula, with a
<code><a href="network.html#topic+network">network</a></code> on its LHS.</p>
</td></tr>
<tr><td><code id="ergm.godfather_+3A_changes">changes</code></td>
<td>
<p>Either a matrix with three columns: tail, head, and
new value, describing the changes to be made; or a list of such
matrices to apply these changes in a sequence. For binary network
models, the third column may be omitted. In that case, the
changes are treated as toggles. Note that if a list is passed, it
must either be all of changes or all of toggles.</p>
</td></tr>
<tr><td><code id="ergm.godfather_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ergm.godfather_+3A_end.network">end.network</code></td>
<td>
<p>Whether to return a network that
results. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ergm.godfather_+3A_stats.start">stats.start</code></td>
<td>
<p>Whether to return the network statistics at
<code>start</code> (before any changes are applied) as the first row of
the statistics matrix.  Defaults to <code>FALSE</code>, to produce
output similar to that of <code><a href="#topic+simulate.ergm">simulate</a></code>
for ERGMs when <code>output="stats"</code>, where initial network's
statistics are not returned.</p>
</td></tr>
<tr><td><code id="ergm.godfather_+3A_changes.only">changes.only</code></td>
<td>
<p>Whether to return network statistics or only
their changes relative to the initial network.</p>
</td></tr>
<tr><td><code id="ergm.godfather_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergm.godfather_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.ergm.godfather">control.ergm.godfather()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>end.network==FALSE</code> (the default), an
<code><a href="coda.html#topic+mcmc">mcmc</a></code> object with the requested network statistics
associed with the network series produced by applying the
specified changes. Its <code><a href="coda.html#topic+mcmc">mcmc</a></code> attributes encode the
timing information: so <code><a href="stats.html#topic+start">start</a>(out)</code> gives the time
point associated with the first row returned, and
<code><a href="stats.html#topic+end">end</a>(out)</code> out the last. The &quot;thinning interval&quot; is
always 1.
</p>
<p>If <code>end.network==TRUE</code>, return a <code><a href="network.html#topic+network">network</a></code> object,
representing the final network, with a matrix of statistics
described in the previous paragraph attached to it as an
<code>attr</code>-style attribute <code>"stats"</code>.
</p>


<h3>See Also</h3>

<p><code>tergm.godfather()</code> in <a href="https://CRAN.R-project.org/package=tergm"><span class="pkg">tergm</span></a>, <code><a href="#topic+simulate.ergm">simulate.ergm()</a></code>,
<code><a href="#topic+simulate.formula">simulate.formula()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(florentine)
ergm.godfather(flomarriage~edges+absdiff("wealth")+triangles,
               changes=list(cbind(1:2,2:3),
                            cbind(3,5),
                            cbind(3,5),
                            cbind(1:2,2:3)),
               stats.start=TRUE)
</code></pre>

<hr>
<h2 id='ergm.mple'>Find a maximizer to the psuedolikelihood function</h2><span id='topic+ergm.mple'></span><span id='topic+ergm.pl'></span>

<h3>Description</h3>

<p>The <code>ergm.mple</code> function finds a maximizer to the psuedolikelihood
function (MPLE). It is the default method for finding the ERGM starting
coefficient values. It is normally called internally the ergm process and
not directly by the user. Generally <code><a href="#topic+ergmMPLE">ergmMPLE</a></code> would be called
by users instead.
</p>
<p><code>ergm.pl</code> is an even more internal workhorse
function that prepares many of the components needed by
<code>ergm.mple</code> for the regression routines that are used to
find the MPLE estimated ergm. It should not be called directly by
the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.mple(
  s,
  s.obs,
  init = NULL,
  family = "binomial",
  control = NULL,
  verbose = FALSE,
  ...
)

ergm.pl(
  state,
  state.obs,
  dummy,
  theta.offset = NULL,
  control,
  ignore.offset = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.mple_+3A_init">init</code></td>
<td>
<p>a vector of initial theta coefficients</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_family">family</code></td>
<td>
<p>the family to use in the R native routine
<code><a href="stats.html#topic+glm">glm</a></code>; only applicable if &quot;glm&quot; is the 'MPLEtype';
default=&quot;binomial&quot;</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.ergm">control.ergm()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_...">...</code></td>
<td>
<p>additional parameters passed from within; all will be
ignored</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_state">state</code>, <code id="ergm.mple_+3A_state.obs">state.obs</code></td>
<td>
<p><code><a href="#topic+ergm_state">ergm_state</a></code> objects.</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_dummy">dummy</code></td>
<td>
<p>A dummy parameter for backwards compatibility. It will
be removed in a future version.</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_theta.offset">theta.offset</code></td>
<td>
<p>a numeric vector of length equal to the number
of statistics of the model, specifying (positionally) the
coefficients of the offset statistics; elements corresponding to
free parameters are ignored.</p>
</td></tr>
<tr><td><code id="ergm.mple_+3A_ignore.offset">ignore.offset</code></td>
<td>
<p>If <code>FALSE</code> (the default), columns
corresponding to terms enclosed in <code>offset()</code> are not
returned with others but are instead processed by multiplying
them by their corresponding coefficients (which are fixed, by
virtue of being offsets) and the results stored in a separate
column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to Hunter et al. (2008): &quot;The maximizer of the pseudolikelihood
may thus easily be found (at least in principle) by using logistic
regression as a computational device.&quot; In order for this to work, the
predictors of the logistic regression model must be calculated.  These are
the change statistics as described in Section 3.2 of Hunter et al. (2008),
put into matrix form so that each pair of nodes is one row whose values are
the vector of change statistics for that node pair.  The ergm.pl function
computes these change statistics and the ergm.mple function implements the
logistic regression using <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+glm">glm()</a></code> function.  Generally, neither ergm.mple
nor ergm.pl should be called by users if the logistic regression output is
desired; instead, use the <code><a href="#topic+ergmMPLE">ergmMPLE</a></code> function.
</p>
<p>In the case where the ERGM is a dyadic independence model, the MPLE is the
same as the MLE.  However, in general this is not the case and, as van Duijn et al. (2009)
warn, the statistical properties of MPLEs in general are
somewhat mysterious.
</p>
<p>MPLE values are used even in the case of dyadic dependence models as
starting points for the MCMC algorithm.
</p>


<h3>Value</h3>

<p><code>ergm.mple</code> returns an ergm object as a list
containing several items; for details see the return list in the
<code><a href="#topic+ergm">ergm</a></code>
</p>
<p><code>ergm.pl</code> returns a list containing:
</p>
<table>
<tr><td><code>xmat</code></td>
<td>
<p>the compressed and possibly sampled matrix of change
statistics</p>
</td></tr>
<tr><td><code>xmat.full</code></td>
<td>
<p>as <code>xmat</code> but with offset terms</p>
</td></tr>
<tr><td><code>zy</code></td>
<td>
<p>the corresponding vector of responses, i.e. tie values</p>
</td></tr>
<tr><td><code>foffset</code></td>
<td>
<p>if <code>ignore.offset==FALSE</code>, the combined offset statistics multiplied by their parameter values</p>
</td></tr>
<tr><td><code>wend</code></td>
<td>
<p>the vector of weights for <code>xmat</code>
and <code>zy</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008).
&ldquo;ergm: A Package to Fit, Simulate and Diagnose Exponential-Family Models for Networks.&rdquo;
<em>Journal of Statistical Software</em>, <b>24</b>(3), 1&ndash;29.
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>.<br /><br /> van Duijn MAJ, Gile KJ, Handcock MS (2009).
&ldquo;A Framework for the Comparison of Maximum Pseudo-likelihood and Maximum Likelihood Estimation of Exponential Family Random Graph Models.&rdquo;
<em>Social Networks</em>, <b>31</b>(1), 52&ndash;62.
<a href="https://doi.org/10.1016/j.socnet.2008.10.003">doi:10.1016/j.socnet.2008.10.003</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmMPLE">ergmMPLE</a></code>,
<code><a href="#topic+ergm">ergm</a></code>,<code><a href="#topic+control.ergm">control.ergm</a></code>
</p>

<hr>
<h2 id='ergmConstraint'>Sample Space Constraints for Exponential-Family Random Graph Models</h2><span id='topic+ergmConstraint'></span><span id='topic+ergm-constraints'></span><span id='topic+constraints-ergm'></span><span id='topic+ergm.constraints'></span><span id='topic+constraints.ergm'></span>

<h3>Description</h3>

<p>This page describes how to specify the constraints on the network sample space (the set of possible networks <code class="reqn">Y</code>, the set of networks <code class="reqn">y</code> for which <code class="reqn">h(y)&gt;0</code>) and sometimes the baseline weights <code class="reqn">h(y)</code> to functions in the <code><a href="#topic+ergm-package">ergm</a></code>
package. It also provides an indexed list of the constraints visible to the <a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a>'s API. Constraints can also be searched via <code><a href="#topic+search.ergmConstraints">search.ergmConstraints</a></code>, and help for an individual constraint can be obtained with <code style="white-space: pre;">&#8288;ergmConstraint?&lt;constraint&gt;&#8288;</code> or <code>help("&lt;constraint&gt;-ergmConstraint")</code>.
</p>


<h3>Specifying constraints</h3>

<p>In an exponential-family random graph model (ERGM), the probability or density of a given network, <code class="reqn">y \in Y</code>, on a set of nodes is </p>
<p style="text-align: center;"><code class="reqn">h(y) \exp[\eta(\theta) \cdot g(y)] / \kappa(\theta),</code>
</p>
<p> where <code class="reqn">h(y)</code> is the reference distribution (particularly for valued network models), <code class="reqn">g(y)</code> is a vector of network statistics for <code class="reqn">y</code>, <code class="reqn">\eta(\theta)</code> is a natural parameter vector of the same length (with <code class="reqn">\eta(\theta)\equiv\theta</code> for most terms), <code class="reqn">\cdot</code> is the dot product, and <code class="reqn">\kappa(\theta)</code> is the normalizing constant for the distribution. A complete ERGM specification requires a list of network statistics <code class="reqn">g(y)</code> and (if applicable) their <code class="reqn">\eta(\theta)</code> mappings provided by a formula of <code><a href="#topic+ergmTerm">ergmTerm</a></code>s; and, optionally, sample space <code class="reqn">\mathcal{Y}</code> and reference distribution <code class="reqn">h(y)</code> information provided by <code><a href="#topic+ergmConstraint">ergmConstraint</a></code>s and, for valued ERGMs, by <code><a href="#topic+ergmReference">ergmReference</a></code>s.
Constraints typically affect <code class="reqn">Y</code>, or, equivalently, set <code class="reqn">h(y)=0</code> for some <code class="reqn">y</code>, but some (&ldquo;soft&rdquo; constraints) set
<code class="reqn">h(y)</code> to values other than 0 and 1.
</p>
<p>A constraints formula is a one- or two-sided formula whose left-hand side is
an optional direct selection of the <code>InitErgmProposal</code> function and
whose right-hand side is a series of one or more terms separated by
<code>"+"</code> and <code>"-"</code> operators, specifying the constraint.
</p>
<p>The sample space (over and above the reference distribution) is determined
by iterating over the constraints terms from left to right, each term
updating it as follows:
</p>

<ul>
<li><p> If the constraint introduces complex
dependence structure (e.g., constrains degree or number of edges in the
network), then this constraint always restricts the sample space. It may
only have a <code>"+"</code> sign.
</p>
</li>
<li><p> If the constraint only restricts the set of dyads that may vary in the
sample space (e.g., block-diagonal structure or fixing specific dyads at
specific values) and has a <code>"+"</code> sign, the set of dyads that may
vary is restricted to those that may vary according to this constraint
<em>and</em> all the constraints to date.
</p>
</li>
<li><p> If the constraint only restricts the set of dyads that may vary in the
sample space but has a <code>"-"</code> sign, the set of dyads that may
vary is expanded to those that may vary according to this constraint
<em>or</em> all the constraints up to date.
</p>
</li></ul>

<p>For example, a constraints formula <code>~a-b+c-d</code> with all constraints
dyadic will allow dyads permitted by either <code>a</code> or <code>b</code> but only if they are
also permitted by <code>c</code>; as well as all dyads permitted by <code>d</code>. If <code>A</code>, <code>B</code>,
<code>C</code>, and <code>D</code> were logical matrices, the matrix of variable dyads would be
equal to <code>((A|B)&amp;C)|D</code>.
</p>
<p>Terms with a positive sign can be viewed as &quot;adding&quot; a constraint
while those with a negative sign can be viewed as &quot;relaxing&quot; a constraint.
</p>


<h4>Inheriting constraints from LHS <code><a href="network.html#topic+network">network</a></code></h4>

<p>By default, <code><a href="#topic++25ergmlhs+25">%ergmlhs%</a></code> attributes <code>constraints</code> or
<code>constraints.obs</code> (depending on which constraint) attached to the
LHS of the model formula or the <code style="white-space: pre;">&#8288;basis=&#8288;</code> argument will be added in
front of the specified constraints formula. This is the desired
behaviour most of the time, since those constraints are usually
determined by how the network was constructed (e.g., structural
zeros in a block-diagonal network).
</p>
<p>For those situations in which this is not the desired behavior, a
<code>.</code> term (with a positive sign or no sign at all) can be used to
manually set the position of the inherited constraints in the
formula, and a <code>-.</code> (minus-dot) term anywhere in the constraints
formula will suppress the inherited formula altogether.
</p>



<h3>Constraints visible to the package</h3>

<link rel="stylesheet" type="text/css" href="../doc/ergm.css">


<table class="termtable">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Description </th>
   <th style="text-align:left;"> Concepts </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <div id="Dyads-ergmConstraint-3aee3115"><span class="code"><a href="../help/Dyads-ergmConstraint-3aee3115">Dyads(fix=NULL, vary=NULL)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Constrain fixed or varying dyad-independent terms </td>
   <td style="text-align:left;"> directed
dyad-independent
operator
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1degrees-ergmConstraint-34a58d68"><span class="code"><a href="../help/b1degrees-ergmConstraint-34a58d68">b1degrees</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the actor degree for bipartite networks </td>
   <td style="text-align:left;"> bipartite </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2degrees-ergmConstraint-2b170be6"><span class="code"><a href="../help/b2degrees-ergmConstraint-2b170be6">b2degrees</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the receiver degree for bipartite networks </td>
   <td style="text-align:left;"> bipartite </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="bd-ergmConstraint-54194cbb"><span class="code"><a href="../help/bd-ergmConstraint-54194cbb">bd(attribs, maxout, maxin, minout, minin)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Constrain maximum and minimum vertex degree </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="blockdiag-ergmConstraint-140bec05"><span class="code"><a href="../help/blockdiag-ergmConstraint-140bec05">blockdiag(attr)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Block-diagonal structure constraint </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="blocks-ergmConstraint-6ef7822c"><span class="code"><a href="../help/blocks-ergmConstraint-6ef7822c">blocks(attr=NULL, levels=NULL, levels2=FALSE, b1levels=NULL, b2levels=NULL)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Constrain blocks of dyads defined by mixing type on a vertex attribute. </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="degreedist-ergmConstraint-9d661be6"><span class="code"><a href="../help/degreedist-ergmConstraint-9d661be6">degreedist</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the degree distribution of the given network </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="degrees-ergmConstraint-602e0f0d"><span class="code"><a href="../help/degrees-ergmConstraint-602e0f0d">degrees</a></span><br />
<span class="code"><a href="../help/degrees-ergmConstraint-602e0f0d">nodedegrees</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the degree of each vertex of the given network </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="dyadnoise-ergmConstraint-03418976"><span class="code"><a href="../help/dyadnoise-ergmConstraint-03418976">dyadnoise(p01, p10)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> A soft constraint to adjust the sampled distribution for
dyad-level noise with known perturbation probabilities </td>
   <td style="text-align:left;"> directed
dyad-independent
soft
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="edges-ergmConstraint-dc999be9"><span class="code"><a href="../help/edges-ergmConstraint-dc999be9">edges</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the edge count of the given network </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="egocentric-ergmConstraint-60aa4e0b"><span class="code"><a href="../help/egocentric-ergmConstraint-60aa4e0b">egocentric(attr=NULL, direction="both")</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve values of dyads incident on vertices with given attribute </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="fixallbut-ergmConstraint-ea96b2e0"><span class="code"><a href="../help/fixallbut-ergmConstraint-ea96b2e0">fixallbut(free.dyads)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the dyad status in all but the given edges </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="fixedas-ergmConstraint-3f69c25b"><span class="code"><a href="../help/fixedas-ergmConstraint-3f69c25b">fixedas(present, absent)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve and preclude edges </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="hamming-ergmConstraint-82ea89b9"><span class="code"><a href="../help/hamming-ergmConstraint-82ea89b9">hamming</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the hamming distance to the given network (BROKEN: Do NOT Use) </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="idegreedist-ergmConstraint-98f28449"><span class="code"><a href="../help/idegreedist-ergmConstraint-98f28449">idegreedist</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the indegree distribution </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="idegrees-ergmConstraint-04ab7684"><span class="code"><a href="../help/idegrees-ergmConstraint-04ab7684">idegrees</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve indegree for directed networks </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="observed-ergmConstraint-40f366ed"><span class="code"><a href="../help/observed-ergmConstraint-40f366ed">observed</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the observed dyads of the given network </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="odegreedist-ergmConstraint-692ae020"><span class="code"><a href="../help/odegreedist-ergmConstraint-692ae020">odegreedist</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve the outdegree distribution </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="odegrees-ergmConstraint-43961eb5"><span class="code"><a href="../help/odegrees-ergmConstraint-43961eb5">odegrees</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Preserve outdegree for directed networks </td>
   <td style="text-align:left;"> directed </td>
  </tr>
</tbody>
</table>


<h4>All constraints</h4>



<table class="termmatrix">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> dir </th>
   <th style="text-align:left;"> dyad-indep </th>
   <th style="text-align:left;"> op </th>
   <th style="text-align:left;"> undir </th>
   <th style="text-align:left;"> bip </th>
   <th style="text-align:left;"> soft </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <a href="#Dyads-ergmConstraint-3aee3115">Dyads</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1degrees-ergmConstraint-34a58d68">b1degrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2degrees-ergmConstraint-2b170be6">b2degrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#bd-ergmConstraint-54194cbb">bd</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#blockdiag-ergmConstraint-140bec05">blockdiag</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#blocks-ergmConstraint-6ef7822c">blocks</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degreedist-ergmConstraint-9d661be6">degreedist</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degrees-ergmConstraint-602e0f0d">degrees</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#dyadnoise-ergmConstraint-03418976">dyadnoise</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#edges-ergmConstraint-dc999be9">edges</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#egocentric-ergmConstraint-60aa4e0b">egocentric</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#fixallbut-ergmConstraint-ea96b2e0">fixallbut</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#fixedas-ergmConstraint-3f69c25b">fixedas</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#hamming-ergmConstraint-82ea89b9">hamming</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#idegreedist-ergmConstraint-98f28449">idegreedist</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#idegrees-ergmConstraint-04ab7684">idegrees</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#observed-ergmConstraint-40f366ed">observed</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#odegreedist-ergmConstraint-692ae020">odegreedist</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#odegrees-ergmConstraint-43961eb5">odegrees</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
</tbody>
</table>



<h4>Constraints by keywords</h4>



Jump to keyword: <a href="#cat_directed">directed</a> <a href="#cat_dyad-independent">dyad-independent</a> <a href="#cat_operator">operator</a> <a href="#cat_undirected">undirected</a> <a href="#cat_bipartite">bipartite</a> <a href="#cat_soft">soft</a><h3><a id="cat_directed">directed</a></h3><a href="#Dyads-ergmConstraint-3aee3115">Dyads</a> <a href="#bd-ergmConstraint-54194cbb">bd</a> <a href="#blockdiag-ergmConstraint-140bec05">blockdiag</a> <a href="#blocks-ergmConstraint-6ef7822c">blocks</a> <a href="#degreedist-ergmConstraint-9d661be6">degreedist</a> <a href="#degrees-ergmConstraint-602e0f0d">degrees</a> <a href="#dyadnoise-ergmConstraint-03418976">dyadnoise</a> <a href="#egocentric-ergmConstraint-60aa4e0b">egocentric</a> <a href="#fixallbut-ergmConstraint-ea96b2e0">fixallbut</a> <a href="#fixedas-ergmConstraint-3f69c25b">fixedas</a> <a href="#hamming-ergmConstraint-82ea89b9">hamming</a> <a href="#idegreedist-ergmConstraint-98f28449">idegreedist</a> <a href="#idegrees-ergmConstraint-04ab7684">idegrees</a> <a href="#observed-ergmConstraint-40f366ed">observed</a> <a href="#odegreedist-ergmConstraint-692ae020">odegreedist</a> <a href="#odegrees-ergmConstraint-43961eb5">odegrees</a><h3><a id="cat_dyad-independent">dyad-independent</a></h3><a href="#Dyads-ergmConstraint-3aee3115">Dyads</a> <a href="#blockdiag-ergmConstraint-140bec05">blockdiag</a> <a href="#blocks-ergmConstraint-6ef7822c">blocks</a> <a href="#dyadnoise-ergmConstraint-03418976">dyadnoise</a> <a href="#egocentric-ergmConstraint-60aa4e0b">egocentric</a> <a href="#fixallbut-ergmConstraint-ea96b2e0">fixallbut</a> <a href="#fixedas-ergmConstraint-3f69c25b">fixedas</a> <a href="#observed-ergmConstraint-40f366ed">observed</a><h3><a id="cat_operator">operator</a></h3><a href="#Dyads-ergmConstraint-3aee3115">Dyads</a><h3><a id="cat_undirected">undirected</a></h3><a href="#Dyads-ergmConstraint-3aee3115">Dyads</a> <a href="#bd-ergmConstraint-54194cbb">bd</a> <a href="#blockdiag-ergmConstraint-140bec05">blockdiag</a> <a href="#blocks-ergmConstraint-6ef7822c">blocks</a> <a href="#degreedist-ergmConstraint-9d661be6">degreedist</a> <a href="#degrees-ergmConstraint-602e0f0d">degrees</a> <a href="#dyadnoise-ergmConstraint-03418976">dyadnoise</a> <a href="#egocentric-ergmConstraint-60aa4e0b">egocentric</a> <a href="#fixallbut-ergmConstraint-ea96b2e0">fixallbut</a> <a href="#fixedas-ergmConstraint-3f69c25b">fixedas</a> <a href="#hamming-ergmConstraint-82ea89b9">hamming</a> <a href="#observed-ergmConstraint-40f366ed">observed</a><h3><a id="cat_bipartite">bipartite</a></h3><a href="#b1degrees-ergmConstraint-34a58d68">b1degrees</a> <a href="#b2degrees-ergmConstraint-2b170be6">b2degrees</a><h3><a id="cat_soft">soft</a></h3><a href="#dyadnoise-ergmConstraint-03418976">dyadnoise</a>



<h3>References</h3>


<ul>
<li><p> Goodreau SM, Handcock MS, Hunter DR, Butts CT, Morris M (2008a).  A
<span class="pkg">statnet</span> Tutorial. <em>Journal of Statistical Software</em>, 24(8).
<a href="https://doi.org/10.18637/jss.v024.i08">doi:10.18637/jss.v024.i08</a>
</p>
</li>
<li><p> Hunter, D. R. and Handcock, M. S. (2006) <em>Inference in curved
exponential family models for networks</em>, Journal of Computational and
Graphical Statistics.
</p>
</li>
<li><p> Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose Exponential-Family
Models for Networks.  <em>Journal of Statistical Software</em>, 24(3).
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>
</p>
</li>
<li><p> Karwa V, Krivitsky PN, and Slavkovi\'c AB (2016). Sharing Social Network
Data: Differentially Private Estimation of Exponential-Family Random Graph
Models. <em>Journal of the Royal Statistical Society, Series C</em>, 66(3):
481-500. <a href="https://doi.org/10.1111/rssc.12185">doi:10.1111/rssc.12185</a>
</p>
</li>
<li><p> Krivitsky PN (2012). Exponential-Family Random Graph Models for Valued
Networks. <em>Electronic Journal of Statistics</em>, 6, 1100-1128.
<a href="https://doi.org/10.1214/12-EJS696">doi:10.1214/12-EJS696</a>
</p>
</li>
<li><p> Morris M, Handcock MS, Hunter DR (2008).  Specification of
Exponential-Family Random Graph Models: Terms and Computational Aspects.
<em>Journal of Statistical Software</em>, 24(4). <a href="https://doi.org/10.18637/jss.v024.i04">doi:10.18637/jss.v024.i04</a>
</p>
</li></ul>


<hr>
<h2 id='ergmHint'>MCMC Hints for Exponential-Family Random Graph Models</h2><span id='topic+ergmHint'></span><span id='topic+ergm-hints'></span><span id='topic+hints-ergm'></span><span id='topic+ergm.hints'></span><span id='topic+hints.ergm'></span><span id='topic+hints'></span>

<h3>Description</h3>

<p>This page describes how to provide to the
<a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a>'s MCMC algorithms information about the sample space. Hints can also be searched via <code><a href="#topic+search.ergmHints">search.ergmHints</a></code>, and help for an individual hint can be obtained with <code style="white-space: pre;">&#8288;ergmHint?&lt;hint&gt;&#8288;</code> or <code>help("&lt;hint&gt;-ergmHint")</code>.
</p>


<h3>&ldquo;Hints&rdquo; for MCMC</h3>

<p>In an exponential-family random graph model (ERGM), the probability or density of a given network, <code class="reqn">y \in Y</code>, on a set of nodes is </p>
<p style="text-align: center;"><code class="reqn">h(y) \exp[\eta(\theta) \cdot g(y)] / \kappa(\theta),</code>
</p>
<p> where <code class="reqn">h(y)</code> is the reference distribution (particularly for valued network models), <code class="reqn">g(y)</code> is a vector of network statistics for <code class="reqn">y</code>, <code class="reqn">\eta(\theta)</code> is a natural parameter vector of the same length (with <code class="reqn">\eta(\theta)\equiv\theta</code> for most terms), <code class="reqn">\cdot</code> is the dot product, and <code class="reqn">\kappa(\theta)</code> is the normalizing constant for the distribution. A complete ERGM specification requires a list of network statistics <code class="reqn">g(y)</code> and (if applicable) their <code class="reqn">\eta(\theta)</code> mappings provided by a formula of <code><a href="#topic+ergmTerm">ergmTerm</a></code>s; and, optionally, sample space <code class="reqn">\mathcal{Y}</code> and reference distribution <code class="reqn">h(y)</code> information provided by <code><a href="#topic+ergmConstraint">ergmConstraint</a></code>s and, for valued ERGMs, by <code><a href="#topic+ergmReference">ergmReference</a></code>s.
</p>




<p>It is often the case that there is additional information available
about the distribution of networks being modelled. For example, you
may be aware that the network is sparse or that there are strata
among the dyads. &ldquo;Hints&rdquo;, typically passed on the right-hand side of <code>MCMC.prop</code>
and <code>obs.MCMC.prop</code> arguments to <code><a href="#topic+control.ergm">control.ergm()</a></code>,
<code><a href="#topic+control.simulate.ergm">control.simulate.ergm()</a></code>, and others, allow this information to be
provided. By default, hint <code><a href="#topic+sparse-ergmHint">sparse</a></code> is in
effect.
</p>
<p>Unlike constraints, model terms, and reference distributions,
&ldquo;hints&rdquo; do not affect the specification of the model. That is,
regardless of what &ldquo;hints&rdquo; may or may not be in effect, the sample
space and the probabilities within it are the same. However,
&ldquo;hints&rdquo; may affect the MCMC proposal distribution used by the
samplers.
</p>
<p>Note that not all proposals support all &ldquo;hints&rdquo;: and if the most
suitable proposal available cannot incorporate a particular &ldquo;hint&rdquo;,
a warning message will be printed.
</p>
<p>&ldquo;Hints&rdquo; use the same underlying API as constraints, and, if present,
<code><a href="#topic++25ergmlhs+25">%ergmlhs%</a></code> attributes <code>constraints</code> and <code>constraints.obs</code> will
be substituted in its place.
</p>


<h3>Hints available to the package</h3>

<p>The following hints are known to <a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a> at this time:
</p>
<link rel="stylesheet" type="text/css" href="../doc/ergm.css">


<table class="termtable">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Description </th>
   <th style="text-align:left;"> Concepts </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <div id="sparse-ergmHint-ebcaba30"><span class="code"><a href="../help/sparse-ergmHint-ebcaba30">sparse</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Sparse network </td>
   <td style="text-align:left;"> dyad-independent </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="strat-ergmHint-468d7d5e"><span class="code"><a href="../help/strat-ergmHint-468d7d5e">strat(attr=NULL, pmat=NULL, empirical=FALSE)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Stratify Proposed Toggles by Mixing Type on a Vertex Attribute </td>
   <td style="text-align:left;"> dyad-independent </td>
  </tr>
</tbody>
</table>


<h3>References</h3>


<ul>
<li><p> Goodreau SM, Handcock MS, Hunter DR, Butts CT, Morris M (2008a).  A
<span class="pkg">statnet</span> Tutorial. <em>Journal of Statistical Software</em>, 24(8).
<a href="https://doi.org/10.18637/jss.v024.i08">doi:10.18637/jss.v024.i08</a>
</p>
</li>
<li><p> Hunter, D. R. and Handcock, M. S. (2006) <em>Inference in curved
exponential family models for networks</em>, Journal of Computational and
Graphical Statistics.
</p>
</li>
<li><p> Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose Exponential-Family
Models for Networks.  <em>Journal of Statistical Software</em>, 24(3).
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>
</p>
</li>
<li><p> Karwa V, Krivitsky PN, and Slavkovi\'c AB (2016). Sharing Social Network
Data: Differentially Private Estimation of Exponential-Family Random Graph
Models. <em>Journal of the Royal Statistical Society, Series C</em>, 66(3):
481-500. <a href="https://doi.org/10.1111/rssc.12185">doi:10.1111/rssc.12185</a>
</p>
</li>
<li><p> Krivitsky PN (2012). Exponential-Family Random Graph Models for Valued
Networks. <em>Electronic Journal of Statistics</em>, 6, 1100-1128.
<a href="https://doi.org/10.1214/12-EJS696">doi:10.1214/12-EJS696</a>
</p>
</li>
<li><p> Morris M, Handcock MS, Hunter DR (2008).  Specification of
Exponential-Family Random Graph Models: Terms and Computational Aspects.
<em>Journal of Statistical Software</em>, 24(4). <a href="https://doi.org/10.18637/jss.v024.i04">doi:10.18637/jss.v024.i04</a>
</p>
</li></ul>


<hr>
<h2 id='ergmKeyword'>Keywords defined for Exponential-Family Random Graph Models</h2><span id='topic+ergmKeyword'></span><span id='topic+ergm-keywords'></span><span id='topic+keywords-ergm'></span><span id='topic+ergm.keywords'></span><span id='topic+keywords.ergm'></span>

<h3>Description</h3>

<p>This collects all defined keywords defined for the ERGM and derived packages
</p>


<h3>Possible keywords defined by the ERGM and derived packages</h3>

<link rel="stylesheet" type="text/css" href="../doc/ergm.css">


<table class="termtable">
 <thead>
  <tr>
   <th style="text-align:left;"> name </th>
   <th style="text-align:left;"> short </th>
   <th style="text-align:left;"> description </th>
   <th style="text-align:left;"> popular </th>
   <th style="text-align:left;"> package </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> binary </td>
   <td style="text-align:left;"> bin </td>
   <td style="text-align:left;"> suitable for binary ERGMs </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> bipartite </td>
   <td style="text-align:left;"> bip </td>
   <td style="text-align:left;"> suitable for bipartite networks </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> categorical nodal attribute </td>
   <td style="text-align:left;"> cat nodal attr </td>
   <td style="text-align:left;"> involves a categorical nodal attribute </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> categorical dyadic attribute </td>
   <td style="text-align:left;"> cat dyad attr </td>
   <td style="text-align:left;"> involves a categorical dyadic attribute </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> categorical triadic attribute </td>
   <td style="text-align:left;"> cat triad attr </td>
   <td style="text-align:left;"> involves a categorical triadic attribute </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> continuous </td>
   <td style="text-align:left;"> cont </td>
   <td style="text-align:left;"> a continuous distribution for edge values </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> curved </td>
   <td style="text-align:left;"> curved </td>
   <td style="text-align:left;"> is a curved term </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> directed </td>
   <td style="text-align:left;"> dir </td>
   <td style="text-align:left;"> suitable for directed networks </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> discrete </td>
   <td style="text-align:left;"> discrete </td>
   <td style="text-align:left;"> a discrete distribution for edge values </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> dyad-independent </td>
   <td style="text-align:left;"> dyad-indep </td>
   <td style="text-align:left;"> does not induce dyadic dependence </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> finite </td>
   <td style="text-align:left;"> fin </td>
   <td style="text-align:left;"> finite edge values only </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> frequently-used </td>
   <td style="text-align:left;"> freq </td>
   <td style="text-align:left;"> is frequently used </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> nonnegative </td>
   <td style="text-align:left;"> nneg </td>
   <td style="text-align:left;"> only meaningful for nonnegative edge values </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> operator </td>
   <td style="text-align:left;"> op </td>
   <td style="text-align:left;"> a term operator </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> positive </td>
   <td style="text-align:left;"> pos </td>
   <td style="text-align:left;"> only meaningful for positive edge values </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> quantitative nodal attribute </td>
   <td style="text-align:left;"> quant nodal attr </td>
   <td style="text-align:left;"> involves a quantitative nodal attribute </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> quantitative dyadic attribute </td>
   <td style="text-align:left;"> quant dyad attr </td>
   <td style="text-align:left;"> involves a quantitative dyadic attribute </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> quantitative triadic attribute </td>
   <td style="text-align:left;"> quant triad attr </td>
   <td style="text-align:left;"> involves a quantitative triadic attribute </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> soft </td>
   <td style="text-align:left;"> soft </td>
   <td style="text-align:left;"> a constraint that does not necessarily forbid specific networks outright but reweights their probabilities </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> triad-related </td>
   <td style="text-align:left;"> triad rel </td>
   <td style="text-align:left;"> involves triangles, two-paths, and other triadic structures </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> valued </td>
   <td style="text-align:left;"> val </td>
   <td style="text-align:left;"> suitable for valued ERGMs </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
  <tr>
   <td style="text-align:left;"> undirected </td>
   <td style="text-align:left;"> undir </td>
   <td style="text-align:left;"> suitable for undirected networks </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> ergm </td>
  </tr>
</tbody>
</table>

<hr>
<h2 id='ergmlhs'>An API for specifying aspects of an <code><a href="#topic+ergm">ergm</a></code> model in the
LHS/basis network.</h2><span id='topic+ergmlhs'></span><span id='topic++25ergmlhs+25'></span><span id='topic++25ergmlhs+25.network'></span><span id='topic++25ergmlhs+25+3C-'></span><span id='topic++25ergmlhs+25+3C-.network'></span><span id='topic+convert_ergmlhs'></span><span id='topic+print.ergm_lhs'></span><span id='topic+summary.ergm_lhs'></span><span id='topic+print.summary.ergm_lhs'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;%ergmlhs%&#8288;</code> extracts the setting, while assigning to
it sets or updates it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %ergmlhs% setting

## S3 method for class 'network'
lhs %ergmlhs% setting

lhs %ergmlhs% setting &lt;- value

## S3 method for class 'network'
lhs %ergmlhs% setting &lt;- value

convert_ergmlhs(lhs)

## S3 method for class 'ergm_lhs'
print(x, ...)

## S3 method for class 'ergm_lhs'
summary(object, ...)

## S3 method for class 'summary.ergm_lhs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergmlhs_+3A_lhs">lhs</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> intended to serve as LHS of a <code><a href="#topic+ergm">ergm</a></code>
call.</p>
</td></tr>
<tr><td><code id="ergmlhs_+3A_setting">setting</code></td>
<td>
<p>a character string holding a setting's name.</p>
</td></tr>
<tr><td><code id="ergmlhs_+3A_value">value</code></td>
<td>
<p>value with which to overwrite the setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The settings are stored in a named list in an <code>"ergm"</code>
network attribute attached to the LHS network. Currently
understood settings include: </p>

<dl>
<dt><code>response</code></dt><dd><p>Edge attribute to be used as the response
variable, constructed from the <code style="white-space: pre;">&#8288;response=&#8288;</code> argument of <code><a href="#topic+ergm">ergm()</a></code>.</p>
</dd>
<dt><code>constraints</code></dt><dd><p>Structural constraints of the network:
inherited by the <code style="white-space: pre;">&#8288;constraints=&#8288;</code> argument of <code><a href="#topic+ergm">ergm()</a></code>,
<code><a href="#topic+simulate.formula">simulate.formula()</a></code>, etc..</p>
</dd>
<dt><code>obs.constraints</code></dt><dd><p>Structural constraints of the
observation process: inherited by the <code style="white-space: pre;">&#8288;obs.constraints=&#8288;</code> argument
of <code><a href="#topic+ergm">ergm()</a></code>, <code><a href="#topic+simulate.formula">simulate.formula()</a></code>, etc..</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>convert_ergmlhs()</code>: <code>convert_ergmlhs</code> converts old-style settings to new-style settings.
</p>
</li>
<li> <p><code>print(ergm_lhs)</code>: a print method.
</p>
</li>
<li> <p><code>summary(ergm_lhs)</code>: helper method for printing summary.
</p>
</li>
<li> <p><code>print(summary.ergm_lhs)</code>: helper method for printing summary.
</p>
</li></ul>

<hr>
<h2 id='ergmMPLE'>ERGM Predictors and response for logistic regression calculation of MPLE</h2><span id='topic+ergmMPLE'></span>

<h3>Description</h3>

<p>Return the predictor matrix, response vector, and vector of weights that can
be used to calculate the MPLE for an ERGM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergmMPLE(
  formula,
  constraints = ~.,
  obs.constraints = ~-observed,
  output = c("matrix", "array", "dyadlist", "fit"),
  expand.bipartite = FALSE,
  control = control.ergm(),
  verbose = FALSE,
  ...,
  basis = ergm.getnetwork(formula)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergmMPLE_+3A_formula">formula</code>, <code id="ergmMPLE_+3A_constraints">constraints</code>, <code id="ergmMPLE_+3A_obs.constraints">obs.constraints</code></td>
<td>
<p>An ERGM formula and
(optional) constraint specification formulas. See <code><a href="#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="ergmMPLE_+3A_output">output</code></td>
<td>
<p>Character, partially matched. See Value.</p>
</td></tr>
<tr><td><code id="ergmMPLE_+3A_expand.bipartite">expand.bipartite</code></td>
<td>
<p>Logical. Specifies whether the output matrices (or array slices) representing dyads for bipartite networks are represented as rectangular matrices with first mode vertices in rows and second mode in columns, or as square matrices with dimension equalling the total number of vertices, containing with structural <code>NA</code>s or 0s within each mode.</p>
</td></tr>
<tr><td><code id="ergmMPLE_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.ergm">control.ergm()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
<tr><td><code id="ergmMPLE_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="ergmMPLE_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="ergmMPLE_+3A_basis">basis</code></td>
<td>
<p>a value (usually a <code><a href="network.html#topic+network">network</a></code>) to override the LHS of the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MPLE for an ERGM is calculated by first finding the matrix of change
statistics.  Each row of this matrix is associated with a particular pair
(ordered or unordered, depending on whether the network is directed or
undirected) of nodes, and the row equals the change in the vector of network
statistics (as defined in <code>formula</code>) when that pair is toggled from a 0
(no edge) to a 1 (edge), holding all the rest of the network fixed.  The
MPLE results if we perform a logistic regression in which the predictor
matrix is the matrix of change statistics and the response vector is the
observed network (i.e., each entry is either 0 or 1, depending on whether
the corresponding edge exists or not).
</p>
<p>Using <code>output="matrix"</code>, note that the result of the fit may be
obtained from the <code><a href="stats.html#topic+glm">glm</a></code> function, as shown in the examples
below.
</p>


<h3>Value</h3>

<p>If <code>output=="matrix"</code> (the default), then only the response, predictor,
and weights are returned; thus, the MPLE may be found by hand or the vector
of change statistics may be used in some other way. To save space, the
algorithm will automatically search for any duplicated rows in the predictor
matrix (and corresponding response values). <code>ergmMPLE</code> function will
return a list with three elements, <code>response</code>, <code>predictor</code>, and
<code>weights</code>, respectively the response vector, the predictor matrix, and
a vector of weights, which are really counts that tell how many times each
corresponding response, predictor pair is repeated.
</p>
<p>If <code>output=="dyadlist"</code>, as <code>"matrix"</code>, but rather than
coalescing the duplicated rows, every relation in the network that
is not fixed and is observed will have its own row in <code>predictor</code>
and element in <code>response</code> and <code>weights</code>, and <code>predictor</code> matrix
will have two additional rows at the start, <code>tail</code> and <code>head</code>,
indicating to which dyad the row and the corresponding elements
pertain.
</p>
<p>If <code>output=="array"</code>, a list with similarly named three elements is
returned, but <code>response</code> is formatted into a sociomatrix;
<code>predictor</code> is a 3-dimensional array of with cell
<code>predictor[t,h,k]</code> containing the change score of term <code>k</code> for
dyad (<code>t</code>,<code>h</code>); and <code>weights</code> is also formatted into a
sociomatrix, with an element being 1 if it is to be added into the
pseudolikelihood and 0 if it is not.
</p>
<p>In particular, for a unipartite network, cells corresponding to self-loops,
i.e., <code>predictor[i,i,k]</code> will be <code>NA</code> and <code>weights[i,i]</code> will
be 0; and for a unipartite undirected network, lower triangle of each
<code>predictor[,,k]</code> matrix will be set to <code>NA</code>, with the lower
triangle of <code>weights</code> being set to 0.
</p>
<p>To all of the above output types, <code>attr(., "etamap")</code> is attached
containing the <a href="#topic+ergm.eta">mapping and offset information</a>.
</p>
<p>If <code>output=="fit"</code>, then <code>ergmMPLE</code> simply calls the
<code><a href="#topic+ergm">ergm</a></code> function with the <code>estimate="MPLE"</code> option set,
returning an object of class <code>ergm</code> that gives the fitted
pseudolikelihood model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
formula &lt;- faux.mesa.high ~ edges + nodematch("Sex") + nodefactor("Grade")
mplesetup &lt;- ergmMPLE(formula)

# Obtain MPLE coefficients "by hand":
coef(glm(mplesetup$response ~ . - 1, data = data.frame(mplesetup$predictor),
         weights = mplesetup$weights, family="binomial"))

# Check that the coefficients agree with the output of the ergm function:
coef(ergmMPLE(formula, output="fit"))

# We can also format the predictor matrix into an array:
mplearray &lt;- ergmMPLE(formula, output="array")

# The resulting matrices are big, so only print the first 8 actors:
mplearray$response[1:8,1:8]
mplearray$predictor[1:8,1:8,]
mplearray$weights[1:8,1:8]

# Constraints are handled:
faux.mesa.high%v%"block" &lt;- seq_len(network.size(faux.mesa.high)) %/% 4
mplearray &lt;- ergmMPLE(faux.mesa.high~edges, constraints=~blockdiag("block"), output="array")
mplearray$response[1:8,1:8]
mplearray$predictor[1:8,1:8,]
mplearray$weights[1:8,1:8]

# Or, a dyad list:
faux.mesa.high%v%"block" &lt;- seq_len(network.size(faux.mesa.high)) %/% 4
mplearray &lt;- ergmMPLE(faux.mesa.high~edges, constraints=~blockdiag("block"), output="dyadlist")
mplearray$response[1:8]
mplearray$predictor[1:8,]
mplearray$weights[1:8]

# Curved terms produce predictors on the canonical scale:
formula2 &lt;- faux.mesa.high ~ gwesp
mplearray &lt;- ergmMPLE(formula2, output="array")
# The resulting matrices are big, so only print the first 5 actors:
mplearray$response[1:5,1:5]
mplearray$predictor[1:5,1:5,1:3]
mplearray$weights[1:5,1:5]
</code></pre>

<hr>
<h2 id='ergmProposal'>Metropolis-Hastings Proposal Methods for ERGM MCMC</h2><span id='topic+ergmProposal'></span><span id='topic+ergm-proposals'></span><span id='topic+proposals-ergm'></span><span id='topic+ergm.proposals'></span><span id='topic+proposals.ergm'></span><span id='topic+InitErgmProposal'></span><span id='topic+InitWtErgmProposal'></span>

<h3>Description</h3>

<p><code><a href="#topic+ergm">ergm</a></code>  uses a Metropolis-Hastings (MH) algorithm to control the behavior of the Markov Chain
Monte Carlo (MCMC) for sampling networks.  The MCMC chain is intended to step around the sample space of
possible networks, selecting a network at regular intervals to evaluate the statistics in the model.  For
each MCMC step, <code class="reqn">n</code> (<code class="reqn">n=1</code> in the simple case) toggles are proposed to change the dyad(s) to the
opposite value. The probability of accepting the proposed change is determined by the MH acceptance ratio.
The role of the different MH methods implemented in <code><a href="#topic+ergm">ergm</a></code> is to vary how the sets of dyads are
selected for toggle proposals.  This is used in some cases to improve the performance (speed and mixing) of
the algorithm, and in other cases to constrain the sample space. Proposals can also be searched via <code><a href="#topic+search.ergmProposals">search.ergmProposals</a></code>, and help for an individual proposal can be obtained with <code style="white-space: pre;">&#8288;ergmProposal?&lt;proposal&gt;&#8288;</code> or <code>help("&lt;proposal&gt;-ergmProposal")</code>.
</p>


<h3>Implemented proposals for ergm models</h3>

<link rel="stylesheet" type="text/css" href="../doc/ergm.css">
<table class="proptable">
 <thead>
  <tr>
   <th style="text-align:left;"> Proposal </th>
   <th style="text-align:left;"> Reference </th>
   <th style="text-align:left;"> Enforces </th>
   <th style="text-align:left;"> May_Enforce </th>
   <th style="text-align:right;"> Priority </th>
   <th style="text-align:left;"> Weight </th>
   <th style="text-align:left;"> Class </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <a href="../help/BDStratTNT-ergmProposal">BDStratTNT</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/sparse-ergmConstraint">sparse</a> </td>
   <td style="text-align:left;"> <a href="../help/bdmax-ergmConstraint">bdmax</a> <a href="../help/blocks-ergmConstraint">blocks</a> <a href="../help/strat-ergmConstraint">strat</a> </td>
   <td style="text-align:right;"> -3 </td>
   <td style="text-align:left;"> BDStratTNT </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/BDStratTNT-ergmProposal">BDStratTNT</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/bdmax-ergmConstraint">bdmax</a> <a href="../help/sparse-ergmConstraint">sparse</a> </td>
   <td style="text-align:left;"> <a href="../help/blocks-ergmConstraint">blocks</a> <a href="../help/strat-ergmConstraint">strat</a> </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> BDStratTNT </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/BDStratTNT-ergmProposal">BDStratTNT</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/blocks-ergmConstraint">blocks</a> <a href="../help/sparse-ergmConstraint">sparse</a> </td>
   <td style="text-align:left;"> <a href="../help/bdmax-ergmConstraint">bdmax</a> <a href="../help/strat-ergmConstraint">strat</a> </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> BDStratTNT </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/BDStratTNT-ergmProposal">BDStratTNT</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/strat-ergmConstraint">strat</a> <a href="../help/sparse-ergmConstraint">sparse</a> </td>
   <td style="text-align:left;"> <a href="../help/bdmax-ergmConstraint">bdmax</a> <a href="../help/blocks-ergmConstraint">blocks</a> </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> BDStratTNT </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondB1Degree-ergmProposal">CondB1Degree</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/b1degrees-ergmConstraint">b1degrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondB2Degree-ergmProposal">CondB2Degree</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/b2degrees-ergmConstraint">b2degrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondDegree-ergmProposal">CondDegree</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/degrees-ergmConstraint">degrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondDegree-ergmProposal">CondDegree</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/idegrees-ergmConstraint">idegrees</a> <a href="../help/odegrees-ergmConstraint">odegrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondDegree-ergmProposal">CondDegree</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/b1degrees-ergmConstraint">b1degrees</a> <a href="../help/b2degrees-ergmConstraint">b2degrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondDegreeDist-ergmProposal">CondDegreeDist</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/degreedist-ergmConstraint">degreedist</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondDegreeMix-ergmProposal">CondDegreeMix</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/degreesmix-ergmConstraint">degreesmix</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondInDegree-ergmProposal">CondInDegree</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/idegrees-ergmConstraint">idegrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondInDegreeDist-ergmProposal">CondInDegreeDist</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/idegreedist-ergmConstraint">idegreedist</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondOutDegree-ergmProposal">CondOutDegree</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/odegrees-ergmConstraint">odegrees</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/CondOutDegreeDist-ergmProposal">CondOutDegreeDist</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/odegreedist-ergmConstraint">odegreedist</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/ConstantEdges-ergmProposal">ConstantEdges</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/edges-ergmConstraint">edges</a> </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> <a href="../help/bd-ergmConstraint">bd</a> </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DiscUnif-ergmProposal">DiscUnif</a> </td>
   <td style="text-align:left;"> <a href="../help/DiscUnif-ergmReference">DiscUnif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DiscUnif2-ergmProposal">DiscUnif2</a> </td>
   <td style="text-align:left;"> <a href="../help/DiscUnif-ergmReference">DiscUnif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> -1 </td>
   <td style="text-align:left;"> random2 </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DiscUnifNonObserved-ergmProposal">DiscUnifNonObserved</a> </td>
   <td style="text-align:left;"> <a href="../help/DiscUnif-ergmReference">DiscUnif</a> </td>
   <td style="text-align:left;"> <a href="../help/observed-ergmConstraint">observed</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DistRLE-ergmProposal">DistRLE</a> </td>
   <td style="text-align:left;"> <a href="../help/StdNormal-ergmReference">StdNormal</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DistRLE-ergmProposal">DistRLE</a> </td>
   <td style="text-align:left;"> <a href="../help/Unif-ergmReference">Unif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DistRLE-ergmProposal">DistRLE</a> </td>
   <td style="text-align:left;"> <a href="../help/Unif-ergmReference">Unif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> </td>
   <td style="text-align:right;"> -3 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DistRLE-ergmProposal">DistRLE</a> </td>
   <td style="text-align:left;"> <a href="../help/DiscUnif-ergmReference">DiscUnif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> </td>
   <td style="text-align:right;"> -3 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DistRLE-ergmProposal">DistRLE</a> </td>
   <td style="text-align:left;"> <a href="../help/StdNormal-ergmReference">StdNormal</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> </td>
   <td style="text-align:right;"> -3 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DistRLE-ergmProposal">DistRLE</a> </td>
   <td style="text-align:left;"> <a href="../help/Poisson-ergmReference">Poisson</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> </td>
   <td style="text-align:right;"> -3 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/DistRLE-ergmProposal">DistRLE</a> </td>
   <td style="text-align:left;"> <a href="../help/Binomial-ergmReference">Binomial</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> </td>
   <td style="text-align:right;"> -3 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/HammingConstantEdges-ergmProposal">HammingConstantEdges</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/edges-ergmConstraint">edges</a> <a href="../help/hamming-ergmConstraint">hamming</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/HammingTNT-ergmProposal">HammingTNT</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/hamming-ergmConstraint">hamming</a> <a href="../help/sparse-ergmConstraint">sparse</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/StdNormal-ergmProposal">StdNormal</a> </td>
   <td style="text-align:left;"> <a href="../help/StdNormal-ergmReference">StdNormal</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/TNT-ergmProposal">TNT</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/sparse-ergmConstraint">sparse</a> </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> <a href="../help/bd-ergmConstraint">bd</a> </td>
   <td style="text-align:right;"> -1 </td>
   <td style="text-align:left;"> TNT </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/Unif-ergmProposal">Unif</a> </td>
   <td style="text-align:left;"> <a href="../help/Unif-ergmReference">Unif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/UnifNonObserved-ergmProposal">UnifNonObserved</a> </td>
   <td style="text-align:left;"> <a href="../help/Unif-ergmReference">Unif</a> </td>
   <td style="text-align:left;"> <a href="../help/observed-ergmConstraint">observed</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/dyadnoise-ergmProposal">dyadnoise</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/dyadnoise-ergmConstraint">dyadnoise</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 0 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/dyadnoiseTNT-ergmProposal">dyadnoiseTNT</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;"> <a href="../help/dyadnoise-ergmConstraint">dyadnoise</a> <a href="../help/sparse-ergmConstraint">sparse</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:left;"> TNT </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="../help/randomtoggle-ergmProposal">randomtoggle</a> </td>
   <td style="text-align:left;"> <a href="../help/Bernoulli-ergmReference">Bernoulli</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> <a href="../help/.dyads-ergmConstraint">.dyads</a> <a href="../help/bd-ergmConstraint">bd</a> </td>
   <td style="text-align:right;"> -2 </td>
   <td style="text-align:left;"> random </td>
   <td style="text-align:left;"> cross-sectional </td>
  </tr>
</tbody>
</table>




<h3>References</h3>


<ul>
<li><p> Goodreau SM, Handcock MS, Hunter DR, Butts CT, Morris M (2008a).  A <span class="pkg">statnet</span> Tutorial.
<em>Journal of Statistical Software</em>, 24(8). <a href="https://doi.org/10.18637/jss.v024.i08">doi:10.18637/jss.v024.i08</a>
</p>
</li>
<li><p> Hunter, D. R. and Handcock, M. S. (2006) Inference in curved exponential family models for networks.
<em>Journal of Computational and Graphical Statistics</em>.
</p>
</li>
<li><p> Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b). <span class="pkg">ergm</span>:
A Package to Fit, Simulate and Diagnose Exponential-Family Models for
Networks. <em>Journal of Statistical Software</em>, 24(3).
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>
</p>
</li>
<li><p> Krivitsky PN (2012). Exponential-Family Random Graph Models for Valued
Networks. <em>Electronic Journal of Statistics</em>, 2012, 6, 1100-1128.
<a href="https://doi.org/10.1214/12-EJS696">doi:10.1214/12-EJS696</a>
</p>
</li>
<li><p> Morris M, Handcock MS, Hunter DR (2008). Specification of Exponential-Family Random Graph Models:
Terms and Computational Aspects. <em>Journal of Statistical Software</em>, 24(4).
<a href="https://doi.org/10.18637/jss.v024.i04">doi:10.18637/jss.v024.i04</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ergm-package">ergm</a></code> package, <code><a href="#topic+ergm">ergm</a></code>, <code><a href="#topic+ergmConstraint">ergmConstraint</a></code>, <code><a href="#topic+ergm_proposal">ergm_proposal</a></code>
</p>

<hr>
<h2 id='ergmReference'>Reference Measures for Exponential-Family Random Graph Models</h2><span id='topic+ergmReference'></span><span id='topic+ergm-references'></span><span id='topic+references-ergm'></span><span id='topic+ergm.references'></span><span id='topic+references.ergm'></span>

<h3>Description</h3>

<p>This page describes how to specify the reference measures (baseline distributions)
(the set of possible networks <code class="reqn">Y</code> and the baseline weights <code class="reqn">h(y)</code> to functions in the <code><a href="#topic+ergm-package">ergm</a></code>
package. It also provides an indexed list of the references visible to the <a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a>'s API. References can also be searched via <code><a href="#topic+search.ergmReferences">search.ergmReferences()</a></code>, and help for an individual reference can be obtained with <code style="white-space: pre;">&#8288;ergmReference?&lt;reference&gt;&#8288;</code> or <code>help("&lt;reference&gt;-ergmReference")</code>.
</p>


<h3>Specifying reference measures</h3>

<p>In an exponential-family random graph model (ERGM), the probability or density of a given network, <code class="reqn">y \in Y</code>, on a set of nodes is </p>
<p style="text-align: center;"><code class="reqn">h(y) \exp[\eta(\theta) \cdot g(y)] / \kappa(\theta),</code>
</p>
<p> where <code class="reqn">h(y)</code> is the reference distribution (particularly for valued network models), <code class="reqn">g(y)</code> is a vector of network statistics for <code class="reqn">y</code>, <code class="reqn">\eta(\theta)</code> is a natural parameter vector of the same length (with <code class="reqn">\eta(\theta)\equiv\theta</code> for most terms), <code class="reqn">\cdot</code> is the dot product, and <code class="reqn">\kappa(\theta)</code> is the normalizing constant for the distribution. A complete ERGM specification requires a list of network statistics <code class="reqn">g(y)</code> and (if applicable) their <code class="reqn">\eta(\theta)</code> mappings provided by a formula of <code><a href="#topic+ergmTerm">ergmTerm</a></code>s; and, optionally, sample space <code class="reqn">\mathcal{Y}</code> and reference distribution <code class="reqn">h(y)</code> information provided by <code><a href="#topic+ergmConstraint">ergmConstraint</a></code>s and, for valued ERGMs, by <code><a href="#topic+ergmReference">ergmReference</a></code>s.
</p>
<p>The reference measure <code class="reqn">(Y,h(y))</code> is specified on the right-hand side of a one-sided formula passed
typically as the <code>reference</code> argument.
</p>


<h3>Reference measures visible to the package</h3>

<link rel="stylesheet" type="text/css" href="../doc/ergm.css">


<table class="termtable">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Description </th>
   <th style="text-align:left;"> Concepts </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <div id="Bernoulli-ergmReference-d4c68fcc"><span class="code"><a href="../help/Bernoulli-ergmReference-d4c68fcc">Bernoulli</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Bernoulli reference </td>
   <td style="text-align:left;"> discrete
finite
nonnegative </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="DiscUnif-ergmReference-94b67a89"><span class="code"><a href="../help/DiscUnif-ergmReference-94b67a89">DiscUnif(a,b)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Discrete Uniform reference </td>
   <td style="text-align:left;"> discrete
finite </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="StdNormal-ergmReference-e2f0c57c"><span class="code"><a href="../help/StdNormal-ergmReference-e2f0c57c">StdNormal</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Standard Normal reference </td>
   <td style="text-align:left;"> continuous </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Unif-ergmReference-2d53092d"><span class="code"><a href="../help/Unif-ergmReference-2d53092d">Unif(a,b)</a></span></div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Continuous Uniform reference </td>
   <td style="text-align:left;"> continuous </td>
  </tr>
</tbody>
</table>


<h4>All references</h4>



<table class="termmatrix">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> bin </th>
   <th style="text-align:left;"> discrete </th>
   <th style="text-align:left;"> fin </th>
   <th style="text-align:left;"> nneg </th>
   <th style="text-align:left;"> cont </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <a href="#Bernoulli-ergmReference-d4c68fcc">Bernoulli</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#DiscUnif-ergmReference-94b67a89">DiscUnif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#StdNormal-ergmReference-e2f0c57c">StdNormal</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Unif-ergmReference-2d53092d">Unif</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
</tbody>
</table>



<h4>References by keywords</h4>



Jump to keyword: <a href="#cat_binary">binary</a> <a href="#cat_discrete">discrete</a> <a href="#cat_finite">finite</a> <a href="#cat_nonnegative">nonnegative</a> <a href="#cat_continuous">continuous</a><h3><a id="cat_binary">binary</a></h3><a href="#Bernoulli-ergmReference-d4c68fcc">Bernoulli</a><h3><a id="cat_discrete">discrete</a></h3><a href="#Bernoulli-ergmReference-d4c68fcc">Bernoulli</a> <a href="#DiscUnif-ergmReference-94b67a89">DiscUnif</a><h3><a id="cat_finite">finite</a></h3><a href="#Bernoulli-ergmReference-d4c68fcc">Bernoulli</a> <a href="#DiscUnif-ergmReference-94b67a89">DiscUnif</a><h3><a id="cat_nonnegative">nonnegative</a></h3><a href="#Bernoulli-ergmReference-d4c68fcc">Bernoulli</a><h3><a id="cat_continuous">continuous</a></h3><a href="#StdNormal-ergmReference-e2f0c57c">StdNormal</a> <a href="#Unif-ergmReference-2d53092d">Unif</a>



<h3>References</h3>


<ul>
<li><p> Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b). <span class="pkg">ergm</span>:
A Package to Fit, Simulate and Diagnose Exponential-Family Models for
Networks. <em>Journal of Statistical Software</em>, 24(3).
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>
</p>
</li>
<li><p> Krivitsky PN (2012). Exponential-Family Random Graph Models for Valued
Networks. <em>Electronic Journal of Statistics</em>, 2012, 6, 1100-1128.
<a href="https://doi.org/10.1214/12-EJS696">doi:10.1214/12-EJS696</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ergm-package">ergm</a></code>, <code><a href="network.html#topic+network">network</a></code>, <a href="https://CRAN.R-project.org/package=sna"><span class="pkg">sna</span></a>, <code><a href="#topic+summary.ergm">summary.ergm</a></code>, <code><a href="#topic+print.ergm">print.ergm</a></code>, <code style="white-space: pre;">&#8288;\%v\%&#8288;</code>, <code style="white-space: pre;">&#8288;\%n\%&#8288;</code>
</p>

<hr>
<h2 id='ergmTerm'>Terms used in Exponential Family Random Graph Models</h2><span id='topic+ergmTerm'></span><span id='topic+ergm-terms'></span><span id='topic+ergm.terms'></span><span id='topic+terms-ergm'></span><span id='topic+terms.ergm'></span><span id='topic+InitErgmTerm'></span><span id='topic+InitErgmWtTerm'></span>

<h3>Description</h3>

<p>This page explains how to specify the network statistics <code class="reqn">g(y)</code> to functions in the <code><a href="#topic+ergm-package">ergm</a></code> package and packages that extend it. It also provides an indexed list of the possible terms (and hence network statistics) visible to the <a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a> API. Terms can also be searched via <code><a href="#topic+search.ergmTerms">search.ergmTerms</a></code>, and help for an individual term can be obtained with <code style="white-space: pre;">&#8288;ergmTerm?&lt;term&gt;&#8288;</code> or <code>help("&lt;term&gt;-ergmTerm")</code>.
</p>


<h3>Specifying models</h3>

<p>In an exponential-family random graph model (ERGM), the probability or density of a given network, <code class="reqn">y \in Y</code>, on a set of nodes is </p>
<p style="text-align: center;"><code class="reqn">h(y) \exp[\eta(\theta) \cdot g(y)] / \kappa(\theta),</code>
</p>
<p> where <code class="reqn">h(y)</code> is the reference distribution (particularly for valued network models), <code class="reqn">g(y)</code> is a vector of network statistics for <code class="reqn">y</code>, <code class="reqn">\eta(\theta)</code> is a natural parameter vector of the same length (with <code class="reqn">\eta(\theta)\equiv\theta</code> for most terms), <code class="reqn">\cdot</code> is the dot product, and <code class="reqn">\kappa(\theta)</code> is the normalizing constant for the distribution. A complete ERGM specification requires a list of network statistics <code class="reqn">g(y)</code> and (if applicable) their <code class="reqn">\eta(\theta)</code> mappings provided by a formula of <code><a href="#topic+ergmTerm">ergmTerm</a></code>s; and, optionally, sample space <code class="reqn">\mathcal{Y}</code> and reference distribution <code class="reqn">h(y)</code> information provided by <code><a href="#topic+ergmConstraint">ergmConstraint</a></code>s and, for valued ERGMs, by <code><a href="#topic+ergmReference">ergmReference</a></code>s.
</p>
<p>Network statistics <code class="reqn">g(y)</code> and mappings <code class="reqn">\eta(\theta)</code> are specified by a formula object, of the form <code style="white-space: pre;">&#8288;y ~ &lt;term 1&gt; + &lt;term 2&gt; ...&#8288;</code>, where
<code>y</code> is a network object or a matrix that can be coerced to a network
object, and <code style="white-space: pre;">&#8288;&lt;term 1&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;&lt;term 2&gt;&#8288;</code>, etc, are each terms chosen
from the list given below.  To create a network object in , use the
<code><a href="network.html#topic+network">network</a></code> function, then add nodal attributes to it
using the <code style="white-space: pre;">&#8288;%v%&#8288;</code> operator if necessary.
</p>


<h4>Term operators</h4>

<p>Operator terms like <code>B</code> and <code>F</code> take
formulas with other <code>ergm</code> terms as their arguments and transform them
by modifying their inputs (e.g., the network they evaluate) and/or their
outputs.
</p>
<p>By convention, their names are capitalized and CamelCased.
</p>



<h4>Interactions</h4>

<p>For binary ERGMs, interactions between <code><a href="#topic+ergm">ergm</a></code> terms can be
specified in a manner similar to <code><a href="stats.html#topic+lm">lm</a></code> and others, as using the
<code>:</code> and <code>*</code> operators. However, they must be interpreted
carefully, especially for dyad-dependent terms. (Interactions involving
curved terms are not supported at this time.)
</p>
<p>Generally, if term <code>a</code> has <code class="reqn">p_a</code> statistics and <code>b</code> has
<code class="reqn">p_b</code>, <code>a:b</code> will add <code class="reqn">p_a \times p_b</code>
statistics to the model, corresponding to each element of
<code class="reqn">g_a(y)</code> interacted with each element of <code class="reqn">g_b(y)</code>.
</p>
<p>The interaction is defined as follows. Dyad-independent terms can be
expressed in the general form <code class="reqn">g(y;x)=\sum_{i,j} </code><code class="reqn"> x_{i,j}y_{i,j}</code> for some edge
covariate matrix <code class="reqn">x</code>, </p>
<p style="text-align: center;"><code class="reqn">g_{a:b}(y)=\sum_{i,j}
x_{a,i,j}x_{b,i,j}y_{i,j}.</code>
</p>

<p>In other words, rather than being a product of their sufficient statistics
(<code class="reqn">g_{a}(y)g_{b}(y)</code>), it is a dyadwise product of their
dyad-level effects.
</p>
<p>This means that an interaction between two dyad-independent terms can be
interpreted the same way as it would be in the corresponding logistic
regression for each potential edge. However, for undirected networks in
particular, this may lead to somewhat counterintuitive results. For example,
given two nodal covariates <code>"a"</code> and <code>"b"</code> (whose values for node
<code class="reqn">i</code> are denoted <code class="reqn">a_i</code> and <code class="reqn">b_i</code>, respectively),
<code>nodecov("a")</code> adds one statistic of the form <code class="reqn">\sum_{i,j}
(a_{i}+a_{j}) y_{i,j}</code> and analogously for
<code>nodecov("b")</code>, so <code>nodecov("a"):nodecov("b")</code> produces
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i,j} (a_{i}+a_{j}) (b_{i}+b_{j}) y_{i,j}.</code>
</p>




<h4>Binary and valued ERGM terms</h4>

<p><code><a href="#topic+ergm-package">ergm</a></code> functions such as <code><a href="#topic+ergm">ergm</a></code> and
<code><a href="#topic+simulate.formula">simulate</a></code> (for ERGMs) may operate in two
modes: binary and weighted/valued, with the latter activated by passing a
non-NULL value as the <code>response</code> argument, giving the edge attribute
name to be modeled/simulated.
</p>


<h5>Generalizations of binary terms</h5>

<p>Binary ERGM statistics cannot be
used directly in valued mode and vice versa. However, a substantial number
of binary ERGM statistics &mdash; particularly the ones with dyadic independence
&mdash; have simple generalizations to valued ERGMs, and have been adapted in
<code><a href="#topic+ergm-package">ergm</a></code>. They have the same form as their binary
ERGM counterparts, with an additional argument: <code>form</code>, which, at this
time, has two possible values: <code>"sum"</code> (the default) and
<code>"nonzero"</code>. The former creates a statistic of the form <code class="reqn">\sum_{i,j}
x_{i,j} y_{i,j}</code>, where <code class="reqn">y_{i,j}</code> is the
value of dyad <code class="reqn">(i,j)</code> and <code class="reqn">x_{i,j}</code> is the term's covariate
associated with it. The latter computes the binary version, with the edge
considered to be present if its value is not 0.  Valued version of some
binary ERGM terms have an argument <code>threshold</code>, which sets the value
above which a dyad is conidered to have a tie. (Value less than or equal to
<code>threshold</code> is considered a nontie.)
</p>
<p>The <code>B()</code> operator term documented below can be used to pass other
binary terms to valued models, and is more flexible, at the cost of being
somewhat slower.
</p>




<h4>Nodal attribute levels and indices</h4>

<p>Terms taking a categorical nodal covariate also take the <code>levels</code>
argument.  (There are analogous <code>b1levels</code> and <code>b2levels</code>
arguments for some terms that apply to bipartite networks, and the
<code>levels2</code> argument for mixing terms.)  The <code>levels</code> argument can
be used to control the set and the ordering of attribute levels.
</p>
<p>Terms that allow the selection of nodes do so with the <code>nodes</code>
argument, which is interpreted in the same way as the <code>levels</code>
argument, where the categories are the relevant nodal indices themselves.
</p>
<p>Both <code>levels</code> and <code>nodes</code> use the new level selection UI. (See
<a href="#topic+nodal_attributes">Specifying Vertex attributes and Levels</a> (<code style="white-space: pre;">&#8288;?
nodal_attributes&#8288;</code>) for details.)
</p>


<h5>Legacy arguments</h5>

<p>The legacy <code>base</code> and <code>keep</code> arguments are deprecated as of
version 3.10, and replaced by the <code>levels</code> UI. The <code>levels</code>
argument provides consistent and flexible mechanisms for specifying which
attribute levels to exclude (previously handled by <code>base</code>) and include
(previously handled by <code>keep</code>).  If <code>levels</code> or <code>nodes</code>
argument is given, then <code>base</code> and <code>keep</code> arguments are ignored.
The legacy arguments will most likely be removed in a future version.
</p>
<p>Note that this exact behavior is new in version 3.10, and it differs
slightly from older versions: previously if both <code>levels</code> and
<code>base</code>/<code>keep</code> were given, <code>levels</code> argument was applied first
and then applied the <code>base</code>/<code>keep</code> argument. Since version 3.10,
<code>base</code>/<code>keep</code> would be ignored, even if old term behavior is
invoked (as described in the next section).
</p>




<h4>Term versioning</h4>

<p>When a term's behavior has changed from prior version, it is often possible
to invoke the old behavior by setting and/or passing a <code>version</code> term
option, giving the verison (constructed by <code><a href="base.html#topic+as.package_version">as.package_version</a></code>)
desired.
</p>



<h4>Custom <code>ergm</code> terms</h4>

<p>Users and other packages may build custom terms, and package
<span class="pkg">ergm.userterms</span> (<a href="https://github.com/statnet/ergm.userterms">https://github.com/statnet/ergm.userterms</a>) provides
tools for implementing them.
</p>
<p>The current recommendation for any package implementing additional terms is
to document the term with Roxygen comments and a name in the form
<code>termName-ergmTerm</code>. This ensures that <code>help("ergmTerm")</code> will list ERGM
terms available from all loaded packages.
</p>



<h3>Terms included in the <code><a href="#topic+ergm-package">ergm</a></code> package</h3>

<p>As noted above, a cross-referenced HTML version of the term documentation is
also available via <code>vignette('ergm-term-crossRef')</code> and terms
can also be searched via <code><a href="#topic+search.ergmTerms">search.ergmTerms</a></code>.
</p>
<link rel="stylesheet" type="text/css" href="../doc/ergm.css">


<h4>Term index (plain)</h4>



<table class="termtable">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Description </th>
   <th style="text-align:left;"> Concepts </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <div id="absdiff-ergmTerm-9fc8de5a"><span class="code"><a href="../help/absdiff-ergmTerm-9fc8de5a">absdiff(attr, pow)</a></span> (bin)<br />
<span class="code"><a href="../help/absdiff-ergmTerm-9fc8de5a">absdiff(attr, pow, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Absolute difference in nodal attribute </td>
   <td style="text-align:left;"> directed
dyad-independent
quantitative nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="absdiffcat-ergmTerm-5b2a4b77"><span class="code"><a href="../help/absdiffcat-ergmTerm-5b2a4b77">absdiffcat(attr, base, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/absdiffcat-ergmTerm-5b2a4b77">absdiffcat(attr, base, levels, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Categorical absolute difference in nodal attribute </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="altkstar-ergmTerm-201bf7a6"><span class="code"><a href="../help/altkstar-ergmTerm-201bf7a6">altkstar(lambda, fixed)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Alternating k-star </td>
   <td style="text-align:left;"> categorical nodal attribute
curved
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="asymmetric-ergmTerm-da585369"><span class="code"><a href="../help/asymmetric-ergmTerm-da585369">asymmetric(attr, diff, keep, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Asymmetric dyads </td>
   <td style="text-align:left;"> directed
dyad-independent
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="atleast-ergmTerm-1b0585b0"><span class="code"><a href="../help/atleast-ergmTerm-1b0585b0">atleast(threshold)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of dyads with values greater than or equal to a threshold </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="atmost-ergmTerm-145d3def"><span class="code"><a href="../help/atmost-ergmTerm-145d3def">atmost(threshold)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of dyads with values less than or equal to a threshold </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="attrcov-ergmTerm-a2d6aeef"><span class="code"><a href="../help/attrcov-ergmTerm-a2d6aeef">attrcov(attr, mat)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Edge covariate by attribute pairing </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1concurrent-ergmTerm-b6d8305e"><span class="code"><a href="../help/b1concurrent-ergmTerm-b6d8305e">b1concurrent(by, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Concurrent node count for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1cov-ergmTerm-a16e8340"><span class="code"><a href="../help/b1cov-ergmTerm-a16e8340">b1cov(attr)</a></span> (bin)<br />
<span class="code"><a href="../help/b1cov-ergmTerm-a16e8340">b1cov(attr, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Main effect of a covariate for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
dyad-independent
frequently-used
quantitative nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1degrange-ergmTerm-ae4dbc10"><span class="code"><a href="../help/b1degrange-ergmTerm-ae4dbc10">b1degrange(from, to, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree range for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1degree-ergmTerm-b23eca4d"><span class="code"><a href="../help/b1degree-ergmTerm-b23eca4d">b1degree(d, by, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1dsp-ergmTerm-f3ebeba1"><span class="code"><a href="../help/b1dsp-ergmTerm-f3ebeba1">b1dsp(d)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Dyadwise shared partners for dyads in the first bipartition </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1factor-ergmTerm-ad0d3a93"><span class="code"><a href="../help/b1factor-ergmTerm-ad0d3a93">b1factor(attr, base, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/b1factor-ergmTerm-ad0d3a93">b1factor(attr, base, levels, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Factor attribute effect for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1mindegree-ergmTerm-f69f807c"><span class="code"><a href="../help/b1mindegree-ergmTerm-f69f807c">b1mindegree(d)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Minimum degree for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1nodematch-ergmTerm-110b470e"><span class="code"><a href="../help/b1nodematch-ergmTerm-110b470e">b1nodematch(attr, diff, keep, alpha, beta, byb2attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Nodal attribute-based homophily effect for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1sociality-ergmTerm-4c85e6e8"><span class="code"><a href="../help/b1sociality-ergmTerm-4c85e6e8">b1sociality(nodes)</a></span> (bin)<br />
<span class="code"><a href="../help/b1sociality-ergmTerm-4c85e6e8">b1sociality(nodes, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree </td>
   <td style="text-align:left;"> bipartite
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1star-ergmTerm-24b65fe7"><span class="code"><a href="../help/b1star-ergmTerm-24b65fe7">b1star(k, attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> k-stars for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1starmix-ergmTerm-e8fb79b6"><span class="code"><a href="../help/b1starmix-ergmTerm-e8fb79b6">b1starmix(k, attr, base, diff)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Mixing matrix for k-stars centered on the first mode of a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b1twostar-ergmTerm-3ca58d12"><span class="code"><a href="../help/b1twostar-ergmTerm-3ca58d12">b1twostar(b1attr, b2attr, base, b1levels, b2levels, levels2)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Two-star census for central nodes centered on the first mode of a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2concurrent-ergmTerm-c72bf19a"><span class="code"><a href="../help/b2concurrent-ergmTerm-c72bf19a">b2concurrent(by)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Concurrent node count for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2cov-ergmTerm-abbfac55"><span class="code"><a href="../help/b2cov-ergmTerm-abbfac55">b2cov(attr)</a></span> (bin)<br />
<span class="code"><a href="../help/b2cov-ergmTerm-abbfac55">b2cov(attr, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Main effect of a covariate for the second mode in a bipartite  network </td>
   <td style="text-align:left;"> bipartite
dyad-independent
frequently-used
quantitative nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2degrange-ergmTerm-d16c3697"><span class="code"><a href="../help/b2degrange-ergmTerm-d16c3697">b2degrange(from, to, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree range for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2degree-ergmTerm-20b6a8ee"><span class="code"><a href="../help/b2degree-ergmTerm-20b6a8ee">b2degree(d, by)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2dsp-ergmTerm-e9e03312"><span class="code"><a href="../help/b2dsp-ergmTerm-e9e03312">b2dsp(d)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Dyadwise shared partners for dyads in the second bipartition </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2factor-ergmTerm-bed2c507"><span class="code"><a href="../help/b2factor-ergmTerm-bed2c507">b2factor(attr, base, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/b2factor-ergmTerm-bed2c507">b2factor(attr, base, levels, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Factor attribute effect for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2mindegree-ergmTerm-3b15466d"><span class="code"><a href="../help/b2mindegree-ergmTerm-3b15466d">b2mindegree(d)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Minimum degree for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2nodematch-ergmTerm-126ff8a2"><span class="code"><a href="../help/b2nodematch-ergmTerm-126ff8a2">b2nodematch(attr, diff, keep, alpha, beta, byb1attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Nodal attribute-based homophily effect for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2sociality-ergmTerm-ae7e4336"><span class="code"><a href="../help/b2sociality-ergmTerm-ae7e4336">b2sociality(nodes)</a></span> (bin)<br />
<span class="code"><a href="../help/b2sociality-ergmTerm-ae7e4336">b2sociality(nodes, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree </td>
   <td style="text-align:left;"> bipartite
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2star-ergmTerm-76adb9af"><span class="code"><a href="../help/b2star-ergmTerm-76adb9af">b2star(k, attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> k-stars for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2starmix-ergmTerm-391186eb"><span class="code"><a href="../help/b2starmix-ergmTerm-391186eb">b2starmix(k, attr, base, diff)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Mixing matrix for k-stars centered on the second mode of a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="b2twostar-ergmTerm-ca7ec3bb"><span class="code"><a href="../help/b2twostar-ergmTerm-ca7ec3bb">b2twostar(b1attr, b2attr, base, b1levels, b2levels, levels2)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Two-star census for central nodes centered on the second mode of a bipartite network </td>
   <td style="text-align:left;"> bipartite
categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="balance-ergmTerm-9111bd77"><span class="code"><a href="../help/balance-ergmTerm-9111bd77">balance</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Balanced triads </td>
   <td style="text-align:left;"> directed
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="coincidence-ergmTerm-58ca78cc"><span class="code"><a href="../help/coincidence-ergmTerm-58ca78cc">coincidence(levels, active)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Coincident node count for the second mode in a bipartite (aka two-mode) network </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="concurrent-ergmTerm-a0121891"><span class="code"><a href="../help/concurrent-ergmTerm-a0121891">concurrent(by, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Concurrent node count </td>
   <td style="text-align:left;"> categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="concurrentties-ergmTerm-8ccb08e6"><span class="code"><a href="../help/concurrentties-ergmTerm-8ccb08e6">concurrentties(by, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Concurrent tie count </td>
   <td style="text-align:left;"> categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="ctriple-ergmTerm-9ad4f7cd"><span class="code"><a href="../help/ctriple-ergmTerm-9ad4f7cd">ctriple(attr, diff, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/ctriple-ergmTerm-9ad4f7cd">ctriad</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Cyclic triples </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="cycle-ergmTerm-20398683"><span class="code"><a href="../help/cycle-ergmTerm-20398683">cycle(k, semi)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> k-Cycle Census </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="cyclicalties-ergmTerm-636eecc3"><span class="code"><a href="../help/cyclicalties-ergmTerm-636eecc3">cyclicalties(attr, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/cyclicalties-ergmTerm-636eecc3">cyclicalties(threshold)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Cyclical ties </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="cyclicalweights-ergmTerm-994a6687"><span class="code"><a href="../help/cyclicalweights-ergmTerm-994a6687">cyclicalweights(twopath, combine, affect)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Cyclical weights </td>
   <td style="text-align:left;"> directed
nonnegative
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="degcor-ergmTerm-b501a3c7"><span class="code"><a href="../help/degcor-ergmTerm-b501a3c7">degcor</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree Correlation </td>
   <td style="text-align:left;"> undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="degcrossprod-ergmTerm-fb36e593"><span class="code"><a href="../help/degcrossprod-ergmTerm-fb36e593">degcrossprod</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree Cross-Product </td>
   <td style="text-align:left;"> undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="degrange-ergmTerm-e31fe592"><span class="code"><a href="../help/degrange-ergmTerm-e31fe592">degrange(from, to, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree range </td>
   <td style="text-align:left;"> categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="degree-ergmTerm-64bfdc89"><span class="code"><a href="../help/degree-ergmTerm-64bfdc89">degree(d, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree </td>
   <td style="text-align:left;"> categorical nodal attribute
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="degree15-ergmTerm-ea15bf13"><span class="code"><a href="../help/degree15-ergmTerm-ea15bf13">degree1.5</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Degree to the 3/2 power </td>
   <td style="text-align:left;"> undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="density-ergmTerm-9f4752d0"><span class="code"><a href="../help/density-ergmTerm-9f4752d0">density</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Density </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="diff-ergmTerm-0b65ee46"><span class="code"><a href="../help/diff-ergmTerm-0b65ee46">diff(attr, pow, dir, sign.action)</a></span> (bin)<br />
<span class="code"><a href="../help/diff-ergmTerm-0b65ee46">diff(attr, pow, dir, sign.action, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Difference </td>
   <td style="text-align:left;"> bipartite
directed
dyad-independent
frequently-used
quantitative nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="dsp-ergmTerm-1a10473d"><span class="code"><a href="../help/dsp-ergmTerm-1a10473d">ddsp(d, type)</a></span> (bin)<br />
<span class="code"><a href="../help/dsp-ergmTerm-1a10473d">dsp(d, type)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Directed dyadwise shared partners </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="dyadcov-ergmTerm-5fba5404"><span class="code"><a href="../help/dyadcov-ergmTerm-5fba5404">dyadcov(x, attrname)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Dyadic covariate </td>
   <td style="text-align:left;"> directed
dyad-independent
quantitative dyadic attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="edgecov-ergmTerm-1fb5ef19"><span class="code"><a href="../help/edgecov-ergmTerm-1fb5ef19">edgecov(x, attrname)</a></span> (bin)<br />
<span class="code"><a href="../help/edgecov-ergmTerm-1fb5ef19">edgecov(x, attrname, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Edge covariate </td>
   <td style="text-align:left;"> directed
dyad-independent
frequently-used
quantitative dyadic attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="edges-ergmTerm-dc999be9"><span class="code"><a href="../help/edges-ergmTerm-dc999be9">edges</a></span> (bin)<br />
<span class="code"><a href="../help/edges-ergmTerm-dc999be9">nonzero</a></span> (val)<br />
<span class="code"><a href="../help/edges-ergmTerm-dc999be9">edges</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of edges in the network </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="equalto-ergmTerm-c31f7686"><span class="code"><a href="../help/equalto-ergmTerm-c31f7686">equalto(value, tolerance)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of dyads with values equal to a specific value (within tolerance) </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="esp-ergmTerm-d2e07fc8"><span class="code"><a href="../help/esp-ergmTerm-d2e07fc8">desp(d, type)</a></span> (bin)<br />
<span class="code"><a href="../help/esp-ergmTerm-d2e07fc8">esp(d, type)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Directed edgewise shared partners </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="greaterthan-ergmTerm-6b8cc380"><span class="code"><a href="../help/greaterthan-ergmTerm-6b8cc380">greaterthan(threshold)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of dyads with values strictly greater than a threshold </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwb1degree-ergmTerm-847064c5"><span class="code"><a href="../help/gwb1degree-ergmTerm-847064c5">gwb1degree(decay, fixed, attr, cutoff, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted degree distribution for the first mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
curved
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwb1dsp-ergmTerm-0bf628f4"><span class="code"><a href="../help/gwb1dsp-ergmTerm-0bf628f4">gwb1dsp(decay, fixed, cutoff)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition </td>
   <td style="text-align:left;"> bipartite
curved
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwb2degree-ergmTerm-584e787c"><span class="code"><a href="../help/gwb2degree-ergmTerm-584e787c">gwb2degree(decay, fixed, attr, cutoff, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted degree distribution for the second mode in a bipartite network </td>
   <td style="text-align:left;"> bipartite
curved
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwb2dsp-ergmTerm-2d408a5d"><span class="code"><a href="../help/gwb2dsp-ergmTerm-2d408a5d">gwb2dsp(decay, fixed, cutoff)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition </td>
   <td style="text-align:left;"> bipartite
curved
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwdegree-ergmTerm-b4e39ca9"><span class="code"><a href="../help/gwdegree-ergmTerm-b4e39ca9">gwdegree(decay, fixed, attr, cutoff, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted degree distribution </td>
   <td style="text-align:left;"> curved
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwdsp-ergmTerm-4e3dfd97"><span class="code"><a href="../help/gwdsp-ergmTerm-4e3dfd97">dgwdsp(decay, fixed, cutoff, type)</a></span> (bin)<br />
<span class="code"><a href="../help/gwdsp-ergmTerm-4e3dfd97">gwdsp(decay, fixed, cutoff, type)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted dyadwise shared partner distribution </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwesp-ergmTerm-3d6fb5a8"><span class="code"><a href="../help/gwesp-ergmTerm-3d6fb5a8">dgwesp(decay, fixed, cutoff, type)</a></span> (bin)<br />
<span class="code"><a href="../help/gwesp-ergmTerm-3d6fb5a8">gwesp(decay, fixed, cutoff, type)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted edgewise shared partner distribution </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwidegree-ergmTerm-b37ed894"><span class="code"><a href="../help/gwidegree-ergmTerm-b37ed894">gwidegree(decay, fixed, attr, cutoff, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted in-degree distribution </td>
   <td style="text-align:left;"> curved
directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwnsp-ergmTerm-6def2a32"><span class="code"><a href="../help/gwnsp-ergmTerm-6def2a32">dgwnsp(decay, fixed, cutoff, type)</a></span> (bin)<br />
<span class="code"><a href="../help/gwnsp-ergmTerm-6def2a32">gwnsp(decay, fixed, cutoff, type)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted non-edgewise shared partner distribution </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="gwodegree-ergmTerm-276e606c"><span class="code"><a href="../help/gwodegree-ergmTerm-276e606c">gwodegree(decay, fixed, attr, cutoff, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Geometrically weighted out-degree distribution </td>
   <td style="text-align:left;"> curved
directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="hamming-ergmTerm-82ea89b9"><span class="code"><a href="../help/hamming-ergmTerm-82ea89b9">hamming(x, cov, attrname)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Hamming distance </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="idegrange-ergmTerm-03001d90"><span class="code"><a href="../help/idegrange-ergmTerm-03001d90">idegrange(from, to, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> In-degree range </td>
   <td style="text-align:left;"> categorical nodal attribute
directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="idegree-ergmTerm-036b6e10"><span class="code"><a href="../help/idegree-ergmTerm-036b6e10">idegree(d, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> In-degree </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
frequently-used </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="idegree15-ergmTerm-b83b1a3a"><span class="code"><a href="../help/idegree15-ergmTerm-b83b1a3a">idegree1.5</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> In-degree to the 3/2 power </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="ininterval-ergmTerm-e9384dcc"><span class="code"><a href="../help/ininterval-ergmTerm-e9384dcc">ininterval(lower, upper, open)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of dyads whose values are in an interval </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="intransitive-ergmTerm-4a599cad"><span class="code"><a href="../help/intransitive-ergmTerm-4a599cad">intransitive</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Intransitive triads </td>
   <td style="text-align:left;"> directed
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="isolatededges-ergmTerm-78b32353"><span class="code"><a href="../help/isolatededges-ergmTerm-78b32353">isolatededges</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Isolated edges </td>
   <td style="text-align:left;"> bipartite
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="isolates-ergmTerm-55ae8770"><span class="code"><a href="../help/isolates-ergmTerm-55ae8770">isolates</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Isolates </td>
   <td style="text-align:left;"> directed
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="istar-ergmTerm-686da871"><span class="code"><a href="../help/istar-ergmTerm-686da871">istar(k, attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> In-stars </td>
   <td style="text-align:left;"> categorical nodal attribute
directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="kstar-ergmTerm-9ffb742c"><span class="code"><a href="../help/kstar-ergmTerm-9ffb742c">kstar(k, attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> k-stars </td>
   <td style="text-align:left;"> categorical nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="localtriangle-ergmTerm-8ca12415"><span class="code"><a href="../help/localtriangle-ergmTerm-8ca12415">localtriangle(x)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Triangles within neighborhoods </td>
   <td style="text-align:left;"> categorical dyadic attribute
directed
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="m2star-ergmTerm-bff0f16e"><span class="code"><a href="../help/m2star-ergmTerm-bff0f16e">m2star</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Mixed 2-stars, a.k.a 2-paths </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="meandeg-ergmTerm-f81357a5"><span class="code"><a href="../help/meandeg-ergmTerm-f81357a5">meandeg</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Mean vertex degree </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="mm-ergmTerm-0264ed3f"><span class="code"><a href="../help/mm-ergmTerm-0264ed3f">mm(attrs, levels, levels2)</a></span> (bin)<br />
<span class="code"><a href="../help/mm-ergmTerm-0264ed3f">mm(attrs, levels, levels2, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Mixing matrix cells and margins </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="mutual-ergmTerm-22863009"><span class="code"><a href="../help/mutual-ergmTerm-22863009">mutual(same, by, diff, keep, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/mutual-ergmTerm-22863009">mutual(form, threshold)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Mutuality </td>
   <td style="text-align:left;"> directed
frequently-used </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nearsimmelian-ergmTerm-ba85787e"><span class="code"><a href="../help/nearsimmelian-ergmTerm-ba85787e">nearsimmelian</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Near simmelian triads </td>
   <td style="text-align:left;"> directed
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodecov-ergmTerm-e6fb5c28"><span class="code"><a href="../help/nodecov-ergmTerm-e6fb5c28">nodecov(attr)</a></span> (bin)<br />
<span class="code"><a href="../help/nodecov-ergmTerm-e6fb5c28">nodemain</a></span> (bin)<br />
<span class="code"><a href="../help/nodecov-ergmTerm-e6fb5c28">nodecov(attr, form)</a></span> (val)<br />
<span class="code"><a href="../help/nodecov-ergmTerm-e6fb5c28">nodemain(attr, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Main effect of a covariate </td>
   <td style="text-align:left;"> directed
dyad-independent
frequently-used
quantitative nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodecovar-ergmTerm-35c93a8b"><span class="code"><a href="../help/nodecovar-ergmTerm-35c93a8b">nodecovar(center, transform)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Covariance of undirected dyad values incident on each actor </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodefactor-ergmTerm-6bea11f2"><span class="code"><a href="../help/nodefactor-ergmTerm-6bea11f2">nodefactor(attr, base, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/nodefactor-ergmTerm-6bea11f2">nodefactor(attr, base, levels, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Factor attribute effect </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodeicov-ergmTerm-02d64b5b"><span class="code"><a href="../help/nodeicov-ergmTerm-02d64b5b">nodeicov(attr)</a></span> (bin)<br />
<span class="code"><a href="../help/nodeicov-ergmTerm-02d64b5b">nodeicov(attr, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Main effect of a covariate for in-edges </td>
   <td style="text-align:left;"> directed
frequently-used
quantitative nodal attribute </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodeicovar-ergmTerm-06cfbce0"><span class="code"><a href="../help/nodeicovar-ergmTerm-06cfbce0">nodeicovar(center, transform)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Covariance of in-dyad values incident on each actor </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodeifactor-ergmTerm-7604a73e"><span class="code"><a href="../help/nodeifactor-ergmTerm-7604a73e">nodeifactor(attr, base, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/nodeifactor-ergmTerm-7604a73e">nodeifactor(attr, base, levels, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Factor attribute effect for in-edges </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
dyad-independent
frequently-used </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodematch-ergmTerm-b316dba4"><span class="code"><a href="../help/nodematch-ergmTerm-b316dba4">nodematch(attr, diff, keep, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/nodematch-ergmTerm-b316dba4">nodematch(attr, diff, keep, levels, form)</a></span> (val)<br />
<span class="code"><a href="../help/nodematch-ergmTerm-b316dba4">match(attr, diff, keep, levels, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Uniform homophily and differential homophily </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodemix-ergmTerm-4723046c"><span class="code"><a href="../help/nodemix-ergmTerm-4723046c">nodemix(attr, base, b1levels, b2levels, levels, levels2)</a></span> (bin)<br />
<span class="code"><a href="../help/nodemix-ergmTerm-4723046c">nodemix(attr, base, b1levels, b2levels, levels, levels2, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Nodal attribute mixing </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
dyad-independent
frequently-used
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodeocov-ergmTerm-3b42993a"><span class="code"><a href="../help/nodeocov-ergmTerm-3b42993a">nodeocov(attr)</a></span> (bin)<br />
<span class="code"><a href="../help/nodeocov-ergmTerm-3b42993a">nodeocov(attr, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Main effect of a covariate for out-edges </td>
   <td style="text-align:left;"> directed
dyad-independent
quantitative nodal attribute </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodeocovar-ergmTerm-1fd42ee5"><span class="code"><a href="../help/nodeocovar-ergmTerm-1fd42ee5">nodeocovar(center, transform)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Covariance of out-dyad values incident on each actor </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nodeofactor-ergmTerm-8944a896"><span class="code"><a href="../help/nodeofactor-ergmTerm-8944a896">nodeofactor(attr, base, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/nodeofactor-ergmTerm-8944a896">nodeofactor(attr, base, levels, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Factor attribute effect for out-edges </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
dyad-independent </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="nsp-ergmTerm-4586ea4f"><span class="code"><a href="../help/nsp-ergmTerm-4586ea4f">dnsp(d, type)</a></span> (bin)<br />
<span class="code"><a href="../help/nsp-ergmTerm-4586ea4f">nsp(d, type)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Directed non-edgewise shared partners </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="odegrange-ergmTerm-a29a08d0"><span class="code"><a href="../help/odegrange-ergmTerm-a29a08d0">odegrange(from, to, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Out-degree range </td>
   <td style="text-align:left;"> categorical nodal attribute
directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="odegree-ergmTerm-12c180fc"><span class="code"><a href="../help/odegree-ergmTerm-12c180fc">odegree(d, by, homophily, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Out-degree </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
frequently-used </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="odegree15-ergmTerm-8ee8801b"><span class="code"><a href="../help/odegree15-ergmTerm-8ee8801b">odegree1.5</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Out-degree to the 3/2 power </td>
   <td style="text-align:left;"> directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="opentriad-ergmTerm-f67c1cac"><span class="code"><a href="../help/opentriad-ergmTerm-f67c1cac">opentriad</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Open triads </td>
   <td style="text-align:left;"> triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="ostar-ergmTerm-88787ec2"><span class="code"><a href="../help/ostar-ergmTerm-88787ec2">ostar(k, attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> k-Outstars </td>
   <td style="text-align:left;"> categorical nodal attribute
directed </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="receiver-ergmTerm-1f82207a"><span class="code"><a href="../help/receiver-ergmTerm-1f82207a">receiver(base, nodes)</a></span> (bin)<br />
<span class="code"><a href="../help/receiver-ergmTerm-1f82207a">receiver(base, nodes, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Receiver effect </td>
   <td style="text-align:left;"> directed
dyad-independent </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="sender-ergmTerm-e4dff00f"><span class="code"><a href="../help/sender-ergmTerm-e4dff00f">sender(base, nodes)</a></span> (bin)<br />
<span class="code"><a href="../help/sender-ergmTerm-e4dff00f">sender(base, nodes, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Sender effect </td>
   <td style="text-align:left;"> directed
dyad-independent </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="simmelian-ergmTerm-15e60325"><span class="code"><a href="../help/simmelian-ergmTerm-15e60325">simmelian</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Simmelian triads </td>
   <td style="text-align:left;"> directed
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="simmelianties-ergmTerm-3361aef9"><span class="code"><a href="../help/simmelianties-ergmTerm-3361aef9">simmelianties</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Ties in simmelian triads </td>
   <td style="text-align:left;"> directed
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="smalldiff-ergmTerm-11cc89ad"><span class="code"><a href="../help/smalldiff-ergmTerm-11cc89ad">smalldiff(attr, cutoff)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of ties between actors with similar attribute values </td>
   <td style="text-align:left;"> directed
dyad-independent
quantitative nodal attribute
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="smallerthan-ergmTerm-33549cdd"><span class="code"><a href="../help/smallerthan-ergmTerm-33549cdd">smallerthan(threshold)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Number of dyads with values strictly smaller than a threshold </td>
   <td style="text-align:left;"> directed
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="sociality-ergmTerm-ecb55eaa"><span class="code"><a href="../help/sociality-ergmTerm-ecb55eaa">sociality(attr, base, levels, nodes)</a></span> (bin)<br />
<span class="code"><a href="../help/sociality-ergmTerm-ecb55eaa">sociality(attr, base, levels, nodes, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Undirected degree </td>
   <td style="text-align:left;"> categorical nodal attribute
dyad-independent
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="sum-ergmTerm-304f882f"><span class="code"><a href="../help/sum-ergmTerm-304f882f">sum(pow)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Sum of dyad values (optionally taken to a power) </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="threetrail-ergmTerm-2ad16d45"><span class="code"><a href="../help/threetrail-ergmTerm-2ad16d45">threetrail(keep, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/threetrail-ergmTerm-2ad16d45">threepath(keep, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Three-trails </td>
   <td style="text-align:left;"> directed
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="transitive-ergmTerm-838987d1"><span class="code"><a href="../help/transitive-ergmTerm-838987d1">transitive</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Transitive triads </td>
   <td style="text-align:left;"> directed
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="transitiveties-ergmTerm-3382c137"><span class="code"><a href="../help/transitiveties-ergmTerm-3382c137">transitiveties(attr, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Transitive ties </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="transitiveweights-ergmTerm-7797c57b"><span class="code"><a href="../help/transitiveweights-ergmTerm-7797c57b">transitiveweights(twopath, combine, affect)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Transitive weights </td>
   <td style="text-align:left;"> directed
nonnegative
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="triadcensus-ergmTerm-6a6bbd87"><span class="code"><a href="../help/triadcensus-ergmTerm-6a6bbd87">triadcensus(levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Triad census </td>
   <td style="text-align:left;"> directed
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="triangle-ergmTerm-9b49a585"><span class="code"><a href="../help/triangle-ergmTerm-9b49a585">triangle(attr, diff, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/triangle-ergmTerm-9b49a585">triangles(attr, diff, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Triangles </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
frequently-used
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="tripercent-ergmTerm-a932d91a"><span class="code"><a href="../help/tripercent-ergmTerm-a932d91a">tripercent(attr, diff, levels)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Triangle percentage </td>
   <td style="text-align:left;"> categorical nodal attribute
triad-related
undirected </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="ttriple-ergmTerm-db2252b3"><span class="code"><a href="../help/ttriple-ergmTerm-db2252b3">ttriple(attr, diff, levels)</a></span> (bin)<br />
<span class="code"><a href="../help/ttriple-ergmTerm-db2252b3">ttriad</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Transitive triples </td>
   <td style="text-align:left;"> categorical nodal attribute
directed
triad-related </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="twopath-ergmTerm-930ae8af"><span class="code"><a href="../help/twopath-ergmTerm-930ae8af">twopath</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> 2-Paths </td>
   <td style="text-align:left;"> directed
undirected </td>
  </tr>
</tbody>
</table>



<h4>Term index (operator)</h4>



<table class="termtable">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Description </th>
   <th style="text-align:left;"> Concepts </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <div id="B-ergmTerm-1e2e5333"><span class="code"><a href="../help/B-ergmTerm-1e2e5333">B(formula, form)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Wrap binary terms for use in valued models </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Curve-ergmTerm-a37fe1f0"><span class="code"><a href="../help/Curve-ergmTerm-a37fe1f0">Curve(formula, params, map, gradient, minpar, maxpar, cov)</a></span> (bin)<br />
<span class="code"><a href="../help/Curve-ergmTerm-a37fe1f0">Parametrise(formula, params, map, gradient, minpar, maxpar, cov)</a></span> (bin)<br />
<span class="code"><a href="../help/Curve-ergmTerm-a37fe1f0">Parametrize(formula, params, map, gradient, minpar, maxpar, cov)</a></span> (bin)<br />
<span class="code"><a href="../help/Curve-ergmTerm-a37fe1f0">Curve(formula, params, map, gradient, minpar, maxpar, cov)</a></span> (val)<br />
<span class="code"><a href="../help/Curve-ergmTerm-a37fe1f0">Parametrise(formula, params, map, gradient, minpar, maxpar, cov)</a></span> (val)<br />
<span class="code"><a href="../help/Curve-ergmTerm-a37fe1f0">Parametrize(formula, params, map, gradient, minpar, maxpar, cov)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Impose a curved structure on term parameters </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Exp-ergmTerm-2a7372d1"><span class="code"><a href="../help/Exp-ergmTerm-2a7372d1">Exp(formula)</a></span> (bin)<br />
<span class="code"><a href="../help/Exp-ergmTerm-2a7372d1">Exp(formula)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Exponentiate a network's statistic </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="F-ergmTerm-1029798a"><span class="code"><a href="../help/F-ergmTerm-1029798a">F(formula, filter)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Filtering on arbitrary one-term model </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="For-ergmTerm-f403b433"><span class="code"><a href="../help/For-ergmTerm-f403b433">For(...)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> A for operator for terms </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Label-ergmTerm-6de33f4e"><span class="code"><a href="../help/Label-ergmTerm-6de33f4e">Label(formula, label, pos)</a></span> (bin)<br />
<span class="code"><a href="../help/Label-ergmTerm-6de33f4e">Label(formula, label, pos)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Modify terms' coefficient names </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Log-ergmTerm-f1bed869"><span class="code"><a href="../help/Log-ergmTerm-f1bed869">Log(formula, log0)</a></span> (bin)<br />
<span class="code"><a href="../help/Log-ergmTerm-f1bed869">Log(formula, log0)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Take a natural logarithm of a network's statistic </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="NodematchFilter-ergmTerm-8bd022b9"><span class="code"><a href="../help/NodematchFilter-ergmTerm-8bd022b9">NodematchFilter(formula, attrname)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Filtering on nodematch </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Offset-ergmTerm-b7b3ddc4"><span class="code"><a href="../help/Offset-ergmTerm-b7b3ddc4">Offset(formula, coef, which)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Terms with fixed coefficients </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Prod-ergmTerm-1bd03b4f"><span class="code"><a href="../help/Prod-ergmTerm-1bd03b4f">Prod(formulas, label)</a></span> (bin)<br />
<span class="code"><a href="../help/Prod-ergmTerm-1bd03b4f">Prod(formulas, label)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> A product (or an arbitrary power combination) of one or more formulas </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="S-ergmTerm-28cff48d"><span class="code"><a href="../help/S-ergmTerm-28cff48d">S(formula, attrs)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Evaluation on an induced subgraph </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Sum-ergmTerm-fe08cb7f"><span class="code"><a href="../help/Sum-ergmTerm-fe08cb7f">Sum(formulas, label)</a></span> (bin)<br />
<span class="code"><a href="../help/Sum-ergmTerm-fe08cb7f">Sum(formulas, label)</a></span> (val)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> A sum (or an arbitrary linear combination) of one or more formulas </td>
   <td style="text-align:left;"> operator </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <div id="Symmetrize-ergmTerm-61cab8ac"><span class="code"><a href="../help/Symmetrize-ergmTerm-61cab8ac">Symmetrize(formula, rule)</a></span> (bin)</div> </td>
   <td style="text-align:left;"> ergm </td>
   <td style="text-align:left;"> Evaluation on symmetrized (undirected) network </td>
   <td style="text-align:left;"> directed
operator </td>
  </tr>
</tbody>
</table>



<h4>Frequently-used terms</h4>



<table class="termmatrix">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> bin </th>
   <th style="text-align:left;"> bip </th>
   <th style="text-align:left;"> dir </th>
   <th style="text-align:left;"> dyad-indep </th>
   <th style="text-align:left;"> op </th>
   <th style="text-align:left;"> val </th>
   <th style="text-align:left;"> undir </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1degree-ergmTerm-b23eca4d">b1degree</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2concurrent-ergmTerm-c72bf19a">b2concurrent</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2degree-ergmTerm-20b6a8ee">b2degree</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degree-ergmTerm-64bfdc89">degree</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#diff-ergmTerm-0b65ee46">diff</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwdegree-ergmTerm-b4e39ca9">gwdegree</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#idegree-ergmTerm-036b6e10">idegree</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#isolates-ergmTerm-55ae8770">isolates</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#mm-ergmTerm-0264ed3f">mm</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#mutual-ergmTerm-22863009">mutual</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeicov-ergmTerm-02d64b5b">nodeicov</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#odegree-ergmTerm-12c180fc">odegree</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#triangle-ergmTerm-9b49a585">triangle</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
</tbody>
</table>



<h4>Operator terms</h4>



<table class="termmatrix">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> bin </th>
   <th style="text-align:left;"> bip </th>
   <th style="text-align:left;"> dir </th>
   <th style="text-align:left;"> dyad-indep </th>
   <th style="text-align:left;"> val </th>
   <th style="text-align:left;"> undir </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <a href="#B-ergmTerm-1e2e5333">B</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Curve-ergmTerm-a37fe1f0">Curve</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Exp-ergmTerm-2a7372d1">Exp</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#F-ergmTerm-1029798a">F</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#For-ergmTerm-f403b433">For</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Label-ergmTerm-6de33f4e">Label</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Log-ergmTerm-f1bed869">Log</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#NodematchFilter-ergmTerm-8bd022b9">NodematchFilter</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Offset-ergmTerm-b7b3ddc4">Offset</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Prod-ergmTerm-1bd03b4f">Prod</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#S-ergmTerm-28cff48d">S</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Sum-ergmTerm-fe08cb7f">Sum</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Symmetrize-ergmTerm-61cab8ac">Symmetrize</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
</tbody>
</table>



<h4>All terms</h4>



<table class="termmatrix">
 <thead>
  <tr>
   <th style="text-align:left;"> Term </th>
   <th style="text-align:left;"> op </th>
   <th style="text-align:left;"> val </th>
   <th style="text-align:left;"> bin </th>
   <th style="text-align:left;"> dir </th>
   <th style="text-align:left;"> dyad-indep </th>
   <th style="text-align:left;"> quant nodal attr </th>
   <th style="text-align:left;"> undir </th>
   <th style="text-align:left;"> cat nodal attr </th>
   <th style="text-align:left;"> curved </th>
   <th style="text-align:left;"> triad rel </th>
   <th style="text-align:left;"> bip </th>
   <th style="text-align:left;"> freq </th>
   <th style="text-align:left;"> nneg </th>
   <th style="text-align:left;"> quant dyad attr </th>
   <th style="text-align:left;"> cat dyad attr </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> <a href="#B-ergmTerm-1e2e5333">B</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Curve-ergmTerm-a37fe1f0">Curve</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Exp-ergmTerm-2a7372d1">Exp</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#F-ergmTerm-1029798a">F</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#For-ergmTerm-f403b433">For</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Label-ergmTerm-6de33f4e">Label</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Log-ergmTerm-f1bed869">Log</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#NodematchFilter-ergmTerm-8bd022b9">NodematchFilter</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Offset-ergmTerm-b7b3ddc4">Offset</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Prod-ergmTerm-1bd03b4f">Prod</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#S-ergmTerm-28cff48d">S</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Sum-ergmTerm-fe08cb7f">Sum</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#Symmetrize-ergmTerm-61cab8ac">Symmetrize</a> </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#absdiff-ergmTerm-9fc8de5a">absdiff</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#absdiffcat-ergmTerm-5b2a4b77">absdiffcat</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#altkstar-ergmTerm-201bf7a6">altkstar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#asymmetric-ergmTerm-da585369">asymmetric</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#atleast-ergmTerm-1b0585b0">atleast</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#atmost-ergmTerm-145d3def">atmost</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#attrcov-ergmTerm-a2d6aeef">attrcov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1concurrent-ergmTerm-b6d8305e">b1concurrent</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1degrange-ergmTerm-ae4dbc10">b1degrange</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1degree-ergmTerm-b23eca4d">b1degree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1dsp-ergmTerm-f3ebeba1">b1dsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1mindegree-ergmTerm-f69f807c">b1mindegree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1sociality-ergmTerm-4c85e6e8">b1sociality</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1star-ergmTerm-24b65fe7">b1star</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1starmix-ergmTerm-e8fb79b6">b1starmix</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b1twostar-ergmTerm-3ca58d12">b1twostar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2concurrent-ergmTerm-c72bf19a">b2concurrent</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2degrange-ergmTerm-d16c3697">b2degrange</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2degree-ergmTerm-20b6a8ee">b2degree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2dsp-ergmTerm-e9e03312">b2dsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2mindegree-ergmTerm-3b15466d">b2mindegree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2sociality-ergmTerm-ae7e4336">b2sociality</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2star-ergmTerm-76adb9af">b2star</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2starmix-ergmTerm-391186eb">b2starmix</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#b2twostar-ergmTerm-ca7ec3bb">b2twostar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#balance-ergmTerm-9111bd77">balance</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#coincidence-ergmTerm-58ca78cc">coincidence</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#concurrent-ergmTerm-a0121891">concurrent</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#concurrentties-ergmTerm-8ccb08e6">concurrentties</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#ctriple-ergmTerm-9ad4f7cd">ctriple</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#cycle-ergmTerm-20398683">cycle</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#cyclicalties-ergmTerm-636eecc3">cyclicalties</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#cyclicalweights-ergmTerm-994a6687">cyclicalweights</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degcor-ergmTerm-b501a3c7">degcor</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degcrossprod-ergmTerm-fb36e593">degcrossprod</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degrange-ergmTerm-e31fe592">degrange</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degree-ergmTerm-64bfdc89">degree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#degree15-ergmTerm-ea15bf13">degree1.5</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#density-ergmTerm-9f4752d0">density</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#diff-ergmTerm-0b65ee46">diff</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#dsp-ergmTerm-1a10473d">dsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#dyadcov-ergmTerm-5fba5404">dyadcov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#edges-ergmTerm-dc999be9">edges</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#equalto-ergmTerm-c31f7686">equalto</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#esp-ergmTerm-d2e07fc8">esp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#greaterthan-ergmTerm-6b8cc380">greaterthan</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwb1degree-ergmTerm-847064c5">gwb1degree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwb1dsp-ergmTerm-0bf628f4">gwb1dsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwb2degree-ergmTerm-584e787c">gwb2degree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwb2dsp-ergmTerm-2d408a5d">gwb2dsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwdegree-ergmTerm-b4e39ca9">gwdegree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwdsp-ergmTerm-4e3dfd97">gwdsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwesp-ergmTerm-3d6fb5a8">gwesp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwidegree-ergmTerm-b37ed894">gwidegree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwnsp-ergmTerm-6def2a32">gwnsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#gwodegree-ergmTerm-276e606c">gwodegree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#hamming-ergmTerm-82ea89b9">hamming</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#idegrange-ergmTerm-03001d90">idegrange</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#idegree-ergmTerm-036b6e10">idegree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#idegree15-ergmTerm-b83b1a3a">idegree1.5</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#ininterval-ergmTerm-e9384dcc">ininterval</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#intransitive-ergmTerm-4a599cad">intransitive</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#isolatededges-ergmTerm-78b32353">isolatededges</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#isolates-ergmTerm-55ae8770">isolates</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#istar-ergmTerm-686da871">istar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#kstar-ergmTerm-9ffb742c">kstar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#localtriangle-ergmTerm-8ca12415">localtriangle</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#m2star-ergmTerm-bff0f16e">m2star</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#meandeg-ergmTerm-f81357a5">meandeg</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#mm-ergmTerm-0264ed3f">mm</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#mutual-ergmTerm-22863009">mutual</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nearsimmelian-ergmTerm-ba85787e">nearsimmelian</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodecovar-ergmTerm-35c93a8b">nodecovar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeicov-ergmTerm-02d64b5b">nodeicov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeicovar-ergmTerm-06cfbce0">nodeicovar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeocov-ergmTerm-3b42993a">nodeocov</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeocovar-ergmTerm-1fd42ee5">nodeocovar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nodeofactor-ergmTerm-8944a896">nodeofactor</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#nsp-ergmTerm-4586ea4f">nsp</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#odegrange-ergmTerm-a29a08d0">odegrange</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#odegree-ergmTerm-12c180fc">odegree</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#odegree15-ergmTerm-8ee8801b">odegree1.5</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#opentriad-ergmTerm-f67c1cac">opentriad</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#ostar-ergmTerm-88787ec2">ostar</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#receiver-ergmTerm-1f82207a">receiver</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#sender-ergmTerm-e4dff00f">sender</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#simmelian-ergmTerm-15e60325">simmelian</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#simmelianties-ergmTerm-3361aef9">simmelianties</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#smalldiff-ergmTerm-11cc89ad">smalldiff</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#smallerthan-ergmTerm-33549cdd">smallerthan</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#sociality-ergmTerm-ecb55eaa">sociality</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#sum-ergmTerm-304f882f">sum</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#threetrail-ergmTerm-2ad16d45">threetrail</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#transitive-ergmTerm-838987d1">transitive</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#transitiveties-ergmTerm-3382c137">transitiveties</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#transitiveweights-ergmTerm-7797c57b">transitiveweights</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#triadcensus-ergmTerm-6a6bbd87">triadcensus</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#triangle-ergmTerm-9b49a585">triangle</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#tripercent-ergmTerm-a932d91a">tripercent</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#ttriple-ergmTerm-db2252b3">ttriple</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
  <tr>
   <td style="text-align:left;"> <a href="#twopath-ergmTerm-930ae8af">twopath</a> </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;"> &#10004; </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
   <td style="text-align:left;">  </td>
  </tr>
</tbody>
</table>



<h4>Terms by keywords</h4>



Jump to keyword: <a href="#cat_operator">operator</a> <a href="#cat_valued">valued</a> <a href="#cat_binary">binary</a> <a href="#cat_directed">directed</a> <a href="#cat_dyad-independent">dyad-independent</a> <a href="#cat_quantitative_nodal_attribute">quantitative nodal attribute</a> <a href="#cat_undirected">undirected</a> <a href="#cat_categorical_nodal_attribute">categorical nodal attribute</a> <a href="#cat_curved">curved</a> <a href="#cat_triad-related">triad-related</a> <a href="#cat_bipartite">bipartite</a> <a href="#cat_frequently-used">frequently-used</a> <a href="#cat_nonnegative">nonnegative</a> <a href="#cat_quantitative_dyadic_attribute">quantitative dyadic attribute</a> <a href="#cat_categorical_dyadic_attribute">categorical dyadic attribute</a><h3><a id="cat_operator">operator</a></h3><a href="#B-ergmTerm-1e2e5333">B</a> <a href="#Curve-ergmTerm-a37fe1f0">Curve</a> <a href="#Exp-ergmTerm-2a7372d1">Exp</a> <a href="#F-ergmTerm-1029798a">F</a> <a href="#For-ergmTerm-f403b433">For</a> <a href="#Label-ergmTerm-6de33f4e">Label</a> <a href="#Log-ergmTerm-f1bed869">Log</a> <a href="#NodematchFilter-ergmTerm-8bd022b9">NodematchFilter</a> <a href="#Offset-ergmTerm-b7b3ddc4">Offset</a> <a href="#Prod-ergmTerm-1bd03b4f">Prod</a> <a href="#S-ergmTerm-28cff48d">S</a> <a href="#Sum-ergmTerm-fe08cb7f">Sum</a> <a href="#Symmetrize-ergmTerm-61cab8ac">Symmetrize</a><h3><a id="cat_valued">valued</a></h3><a href="#B-ergmTerm-1e2e5333">B</a> <a href="#Curve-ergmTerm-a37fe1f0">Curve</a> <a href="#Exp-ergmTerm-2a7372d1">Exp</a> <a href="#Label-ergmTerm-6de33f4e">Label</a> <a href="#Log-ergmTerm-f1bed869">Log</a> <a href="#Prod-ergmTerm-1bd03b4f">Prod</a> <a href="#Sum-ergmTerm-fe08cb7f">Sum</a> <a href="#absdiff-ergmTerm-9fc8de5a">absdiff</a> <a href="#absdiffcat-ergmTerm-5b2a4b77">absdiffcat</a> <a href="#atleast-ergmTerm-1b0585b0">atleast</a> <a href="#atmost-ergmTerm-145d3def">atmost</a> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> <a href="#b1sociality-ergmTerm-4c85e6e8">b1sociality</a> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> <a href="#b2sociality-ergmTerm-ae7e4336">b2sociality</a> <a href="#cyclicalties-ergmTerm-636eecc3">cyclicalties</a> <a href="#cyclicalweights-ergmTerm-994a6687">cyclicalweights</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> <a href="#edges-ergmTerm-dc999be9">edges</a> <a href="#equalto-ergmTerm-c31f7686">equalto</a> <a href="#greaterthan-ergmTerm-6b8cc380">greaterthan</a> <a href="#ininterval-ergmTerm-e9384dcc">ininterval</a> <a href="#mm-ergmTerm-0264ed3f">mm</a> <a href="#mutual-ergmTerm-22863009">mutual</a> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> <a href="#nodecovar-ergmTerm-35c93a8b">nodecovar</a> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> <a href="#nodeicov-ergmTerm-02d64b5b">nodeicov</a> <a href="#nodeicovar-ergmTerm-06cfbce0">nodeicovar</a> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> <a href="#nodeocov-ergmTerm-3b42993a">nodeocov</a> <a href="#nodeocovar-ergmTerm-1fd42ee5">nodeocovar</a> <a href="#nodeofactor-ergmTerm-8944a896">nodeofactor</a> <a href="#receiver-ergmTerm-1f82207a">receiver</a> <a href="#sender-ergmTerm-e4dff00f">sender</a> <a href="#smallerthan-ergmTerm-33549cdd">smallerthan</a> <a href="#sociality-ergmTerm-ecb55eaa">sociality</a> <a href="#sum-ergmTerm-304f882f">sum</a> <a href="#transitiveweights-ergmTerm-7797c57b">transitiveweights</a><h3><a id="cat_binary">binary</a></h3><a href="#Curve-ergmTerm-a37fe1f0">Curve</a> <a href="#Exp-ergmTerm-2a7372d1">Exp</a> <a href="#F-ergmTerm-1029798a">F</a> <a href="#For-ergmTerm-f403b433">For</a> <a href="#Label-ergmTerm-6de33f4e">Label</a> <a href="#Log-ergmTerm-f1bed869">Log</a> <a href="#NodematchFilter-ergmTerm-8bd022b9">NodematchFilter</a> <a href="#Offset-ergmTerm-b7b3ddc4">Offset</a> <a href="#Prod-ergmTerm-1bd03b4f">Prod</a> <a href="#S-ergmTerm-28cff48d">S</a> <a href="#Sum-ergmTerm-fe08cb7f">Sum</a> <a href="#Symmetrize-ergmTerm-61cab8ac">Symmetrize</a> <a href="#absdiff-ergmTerm-9fc8de5a">absdiff</a> <a href="#absdiffcat-ergmTerm-5b2a4b77">absdiffcat</a> <a href="#altkstar-ergmTerm-201bf7a6">altkstar</a> <a href="#asymmetric-ergmTerm-da585369">asymmetric</a> <a href="#attrcov-ergmTerm-a2d6aeef">attrcov</a> <a href="#b1concurrent-ergmTerm-b6d8305e">b1concurrent</a> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> <a href="#b1degrange-ergmTerm-ae4dbc10">b1degrange</a> <a href="#b1degree-ergmTerm-b23eca4d">b1degree</a> <a href="#b1dsp-ergmTerm-f3ebeba1">b1dsp</a> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> <a href="#b1mindegree-ergmTerm-f69f807c">b1mindegree</a> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> <a href="#b1sociality-ergmTerm-4c85e6e8">b1sociality</a> <a href="#b1star-ergmTerm-24b65fe7">b1star</a> <a href="#b1starmix-ergmTerm-e8fb79b6">b1starmix</a> <a href="#b1twostar-ergmTerm-3ca58d12">b1twostar</a> <a href="#b2concurrent-ergmTerm-c72bf19a">b2concurrent</a> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> <a href="#b2degrange-ergmTerm-d16c3697">b2degrange</a> <a href="#b2degree-ergmTerm-20b6a8ee">b2degree</a> <a href="#b2dsp-ergmTerm-e9e03312">b2dsp</a> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> <a href="#b2mindegree-ergmTerm-3b15466d">b2mindegree</a> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> <a href="#b2sociality-ergmTerm-ae7e4336">b2sociality</a> <a href="#b2star-ergmTerm-76adb9af">b2star</a> <a href="#b2starmix-ergmTerm-391186eb">b2starmix</a> <a href="#b2twostar-ergmTerm-ca7ec3bb">b2twostar</a> <a href="#balance-ergmTerm-9111bd77">balance</a> <a href="#coincidence-ergmTerm-58ca78cc">coincidence</a> <a href="#concurrent-ergmTerm-a0121891">concurrent</a> <a href="#concurrentties-ergmTerm-8ccb08e6">concurrentties</a> <a href="#ctriple-ergmTerm-9ad4f7cd">ctriple</a> <a href="#cycle-ergmTerm-20398683">cycle</a> <a href="#cyclicalties-ergmTerm-636eecc3">cyclicalties</a> <a href="#degcor-ergmTerm-b501a3c7">degcor</a> <a href="#degcrossprod-ergmTerm-fb36e593">degcrossprod</a> <a href="#degrange-ergmTerm-e31fe592">degrange</a> <a href="#degree-ergmTerm-64bfdc89">degree</a> <a href="#degree15-ergmTerm-ea15bf13">degree1.5</a> <a href="#density-ergmTerm-9f4752d0">density</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#dsp-ergmTerm-1a10473d">dsp</a> <a href="#dyadcov-ergmTerm-5fba5404">dyadcov</a> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> <a href="#edges-ergmTerm-dc999be9">edges</a> <a href="#esp-ergmTerm-d2e07fc8">esp</a> <a href="#gwb1degree-ergmTerm-847064c5">gwb1degree</a> <a href="#gwb1dsp-ergmTerm-0bf628f4">gwb1dsp</a> <a href="#gwb2degree-ergmTerm-584e787c">gwb2degree</a> <a href="#gwb2dsp-ergmTerm-2d408a5d">gwb2dsp</a> <a href="#gwdegree-ergmTerm-b4e39ca9">gwdegree</a> <a href="#gwdsp-ergmTerm-4e3dfd97">gwdsp</a> <a href="#gwesp-ergmTerm-3d6fb5a8">gwesp</a> <a href="#gwidegree-ergmTerm-b37ed894">gwidegree</a> <a href="#gwnsp-ergmTerm-6def2a32">gwnsp</a> <a href="#gwodegree-ergmTerm-276e606c">gwodegree</a> <a href="#hamming-ergmTerm-82ea89b9">hamming</a> <a href="#idegrange-ergmTerm-03001d90">idegrange</a> <a href="#idegree-ergmTerm-036b6e10">idegree</a> <a href="#idegree15-ergmTerm-b83b1a3a">idegree1.5</a> <a href="#intransitive-ergmTerm-4a599cad">intransitive</a> <a href="#isolatededges-ergmTerm-78b32353">isolatededges</a> <a href="#isolates-ergmTerm-55ae8770">isolates</a> <a href="#istar-ergmTerm-686da871">istar</a> <a href="#kstar-ergmTerm-9ffb742c">kstar</a> <a href="#localtriangle-ergmTerm-8ca12415">localtriangle</a> <a href="#m2star-ergmTerm-bff0f16e">m2star</a> <a href="#meandeg-ergmTerm-f81357a5">meandeg</a> <a href="#mm-ergmTerm-0264ed3f">mm</a> <a href="#mutual-ergmTerm-22863009">mutual</a> <a href="#nearsimmelian-ergmTerm-ba85787e">nearsimmelian</a> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> <a href="#nodeicov-ergmTerm-02d64b5b">nodeicov</a> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> <a href="#nodeocov-ergmTerm-3b42993a">nodeocov</a> <a href="#nodeofactor-ergmTerm-8944a896">nodeofactor</a> <a href="#nsp-ergmTerm-4586ea4f">nsp</a> <a href="#odegrange-ergmTerm-a29a08d0">odegrange</a> <a href="#odegree-ergmTerm-12c180fc">odegree</a> <a href="#odegree15-ergmTerm-8ee8801b">odegree1.5</a> <a href="#opentriad-ergmTerm-f67c1cac">opentriad</a> <a href="#ostar-ergmTerm-88787ec2">ostar</a> <a href="#receiver-ergmTerm-1f82207a">receiver</a> <a href="#sender-ergmTerm-e4dff00f">sender</a> <a href="#simmelian-ergmTerm-15e60325">simmelian</a> <a href="#simmelianties-ergmTerm-3361aef9">simmelianties</a> <a href="#smalldiff-ergmTerm-11cc89ad">smalldiff</a> <a href="#sociality-ergmTerm-ecb55eaa">sociality</a> <a href="#threetrail-ergmTerm-2ad16d45">threetrail</a> <a href="#transitive-ergmTerm-838987d1">transitive</a> <a href="#transitiveties-ergmTerm-3382c137">transitiveties</a> <a href="#triadcensus-ergmTerm-6a6bbd87">triadcensus</a> <a href="#triangle-ergmTerm-9b49a585">triangle</a> <a href="#tripercent-ergmTerm-a932d91a">tripercent</a> <a href="#ttriple-ergmTerm-db2252b3">ttriple</a> <a href="#twopath-ergmTerm-930ae8af">twopath</a><h3><a id="cat_directed">directed</a></h3><a href="#Symmetrize-ergmTerm-61cab8ac">Symmetrize</a> <a href="#absdiff-ergmTerm-9fc8de5a">absdiff</a> <a href="#absdiffcat-ergmTerm-5b2a4b77">absdiffcat</a> <a href="#asymmetric-ergmTerm-da585369">asymmetric</a> <a href="#atleast-ergmTerm-1b0585b0">atleast</a> <a href="#atmost-ergmTerm-145d3def">atmost</a> <a href="#attrcov-ergmTerm-a2d6aeef">attrcov</a> <a href="#balance-ergmTerm-9111bd77">balance</a> <a href="#ctriple-ergmTerm-9ad4f7cd">ctriple</a> <a href="#cycle-ergmTerm-20398683">cycle</a> <a href="#cyclicalties-ergmTerm-636eecc3">cyclicalties</a> <a href="#cyclicalweights-ergmTerm-994a6687">cyclicalweights</a> <a href="#density-ergmTerm-9f4752d0">density</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#dsp-ergmTerm-1a10473d">dsp</a> <a href="#dyadcov-ergmTerm-5fba5404">dyadcov</a> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> <a href="#edges-ergmTerm-dc999be9">edges</a> <a href="#equalto-ergmTerm-c31f7686">equalto</a> <a href="#esp-ergmTerm-d2e07fc8">esp</a> <a href="#greaterthan-ergmTerm-6b8cc380">greaterthan</a> <a href="#gwdsp-ergmTerm-4e3dfd97">gwdsp</a> <a href="#gwesp-ergmTerm-3d6fb5a8">gwesp</a> <a href="#gwidegree-ergmTerm-b37ed894">gwidegree</a> <a href="#gwnsp-ergmTerm-6def2a32">gwnsp</a> <a href="#gwodegree-ergmTerm-276e606c">gwodegree</a> <a href="#hamming-ergmTerm-82ea89b9">hamming</a> <a href="#idegrange-ergmTerm-03001d90">idegrange</a> <a href="#idegree-ergmTerm-036b6e10">idegree</a> <a href="#idegree15-ergmTerm-b83b1a3a">idegree1.5</a> <a href="#ininterval-ergmTerm-e9384dcc">ininterval</a> <a href="#intransitive-ergmTerm-4a599cad">intransitive</a> <a href="#isolates-ergmTerm-55ae8770">isolates</a> <a href="#istar-ergmTerm-686da871">istar</a> <a href="#localtriangle-ergmTerm-8ca12415">localtriangle</a> <a href="#m2star-ergmTerm-bff0f16e">m2star</a> <a href="#meandeg-ergmTerm-f81357a5">meandeg</a> <a href="#mm-ergmTerm-0264ed3f">mm</a> <a href="#mutual-ergmTerm-22863009">mutual</a> <a href="#nearsimmelian-ergmTerm-ba85787e">nearsimmelian</a> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> <a href="#nodecovar-ergmTerm-35c93a8b">nodecovar</a> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> <a href="#nodeicov-ergmTerm-02d64b5b">nodeicov</a> <a href="#nodeicovar-ergmTerm-06cfbce0">nodeicovar</a> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> <a href="#nodeocov-ergmTerm-3b42993a">nodeocov</a> <a href="#nodeocovar-ergmTerm-1fd42ee5">nodeocovar</a> <a href="#nodeofactor-ergmTerm-8944a896">nodeofactor</a> <a href="#nsp-ergmTerm-4586ea4f">nsp</a> <a href="#odegrange-ergmTerm-a29a08d0">odegrange</a> <a href="#odegree-ergmTerm-12c180fc">odegree</a> <a href="#odegree15-ergmTerm-8ee8801b">odegree1.5</a> <a href="#ostar-ergmTerm-88787ec2">ostar</a> <a href="#receiver-ergmTerm-1f82207a">receiver</a> <a href="#sender-ergmTerm-e4dff00f">sender</a> <a href="#simmelian-ergmTerm-15e60325">simmelian</a> <a href="#simmelianties-ergmTerm-3361aef9">simmelianties</a> <a href="#smalldiff-ergmTerm-11cc89ad">smalldiff</a> <a href="#smallerthan-ergmTerm-33549cdd">smallerthan</a> <a href="#sum-ergmTerm-304f882f">sum</a> <a href="#threetrail-ergmTerm-2ad16d45">threetrail</a> <a href="#transitive-ergmTerm-838987d1">transitive</a> <a href="#transitiveties-ergmTerm-3382c137">transitiveties</a> <a href="#transitiveweights-ergmTerm-7797c57b">transitiveweights</a> <a href="#triadcensus-ergmTerm-6a6bbd87">triadcensus</a> <a href="#triangle-ergmTerm-9b49a585">triangle</a> <a href="#ttriple-ergmTerm-db2252b3">ttriple</a> <a href="#twopath-ergmTerm-930ae8af">twopath</a><h3><a id="cat_dyad-independent">dyad-independent</a></h3><a href="#absdiff-ergmTerm-9fc8de5a">absdiff</a> <a href="#absdiffcat-ergmTerm-5b2a4b77">absdiffcat</a> <a href="#asymmetric-ergmTerm-da585369">asymmetric</a> <a href="#atleast-ergmTerm-1b0585b0">atleast</a> <a href="#atmost-ergmTerm-145d3def">atmost</a> <a href="#attrcov-ergmTerm-a2d6aeef">attrcov</a> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> <a href="#b1sociality-ergmTerm-4c85e6e8">b1sociality</a> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> <a href="#b2sociality-ergmTerm-ae7e4336">b2sociality</a> <a href="#density-ergmTerm-9f4752d0">density</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#dyadcov-ergmTerm-5fba5404">dyadcov</a> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> <a href="#edges-ergmTerm-dc999be9">edges</a> <a href="#equalto-ergmTerm-c31f7686">equalto</a> <a href="#greaterthan-ergmTerm-6b8cc380">greaterthan</a> <a href="#hamming-ergmTerm-82ea89b9">hamming</a> <a href="#ininterval-ergmTerm-e9384dcc">ininterval</a> <a href="#meandeg-ergmTerm-f81357a5">meandeg</a> <a href="#mm-ergmTerm-0264ed3f">mm</a> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> <a href="#nodeocov-ergmTerm-3b42993a">nodeocov</a> <a href="#nodeofactor-ergmTerm-8944a896">nodeofactor</a> <a href="#receiver-ergmTerm-1f82207a">receiver</a> <a href="#sender-ergmTerm-e4dff00f">sender</a> <a href="#smalldiff-ergmTerm-11cc89ad">smalldiff</a> <a href="#smallerthan-ergmTerm-33549cdd">smallerthan</a> <a href="#sociality-ergmTerm-ecb55eaa">sociality</a><h3><a id="cat_quantitative_nodal_attribute">quantitative nodal attribute</a></h3><a href="#absdiff-ergmTerm-9fc8de5a">absdiff</a> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> <a href="#nodeicov-ergmTerm-02d64b5b">nodeicov</a> <a href="#nodeocov-ergmTerm-3b42993a">nodeocov</a> <a href="#smalldiff-ergmTerm-11cc89ad">smalldiff</a><h3><a id="cat_undirected">undirected</a></h3><a href="#absdiff-ergmTerm-9fc8de5a">absdiff</a> <a href="#absdiffcat-ergmTerm-5b2a4b77">absdiffcat</a> <a href="#altkstar-ergmTerm-201bf7a6">altkstar</a> <a href="#atleast-ergmTerm-1b0585b0">atleast</a> <a href="#atmost-ergmTerm-145d3def">atmost</a> <a href="#attrcov-ergmTerm-a2d6aeef">attrcov</a> <a href="#b1concurrent-ergmTerm-b6d8305e">b1concurrent</a> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> <a href="#b1degrange-ergmTerm-ae4dbc10">b1degrange</a> <a href="#b1degree-ergmTerm-b23eca4d">b1degree</a> <a href="#b1dsp-ergmTerm-f3ebeba1">b1dsp</a> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> <a href="#b1mindegree-ergmTerm-f69f807c">b1mindegree</a> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> <a href="#b1sociality-ergmTerm-4c85e6e8">b1sociality</a> <a href="#b1star-ergmTerm-24b65fe7">b1star</a> <a href="#b1starmix-ergmTerm-e8fb79b6">b1starmix</a> <a href="#b1twostar-ergmTerm-3ca58d12">b1twostar</a> <a href="#b2concurrent-ergmTerm-c72bf19a">b2concurrent</a> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> <a href="#b2degrange-ergmTerm-d16c3697">b2degrange</a> <a href="#b2degree-ergmTerm-20b6a8ee">b2degree</a> <a href="#b2dsp-ergmTerm-e9e03312">b2dsp</a> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> <a href="#b2mindegree-ergmTerm-3b15466d">b2mindegree</a> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> <a href="#b2sociality-ergmTerm-ae7e4336">b2sociality</a> <a href="#b2star-ergmTerm-76adb9af">b2star</a> <a href="#b2starmix-ergmTerm-391186eb">b2starmix</a> <a href="#b2twostar-ergmTerm-ca7ec3bb">b2twostar</a> <a href="#balance-ergmTerm-9111bd77">balance</a> <a href="#coincidence-ergmTerm-58ca78cc">coincidence</a> <a href="#concurrent-ergmTerm-a0121891">concurrent</a> <a href="#concurrentties-ergmTerm-8ccb08e6">concurrentties</a> <a href="#cycle-ergmTerm-20398683">cycle</a> <a href="#cyclicalties-ergmTerm-636eecc3">cyclicalties</a> <a href="#cyclicalweights-ergmTerm-994a6687">cyclicalweights</a> <a href="#degcor-ergmTerm-b501a3c7">degcor</a> <a href="#degcrossprod-ergmTerm-fb36e593">degcrossprod</a> <a href="#degrange-ergmTerm-e31fe592">degrange</a> <a href="#degree-ergmTerm-64bfdc89">degree</a> <a href="#degree15-ergmTerm-ea15bf13">degree1.5</a> <a href="#density-ergmTerm-9f4752d0">density</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#dyadcov-ergmTerm-5fba5404">dyadcov</a> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> <a href="#edges-ergmTerm-dc999be9">edges</a> <a href="#equalto-ergmTerm-c31f7686">equalto</a> <a href="#greaterthan-ergmTerm-6b8cc380">greaterthan</a> <a href="#gwb1degree-ergmTerm-847064c5">gwb1degree</a> <a href="#gwb1dsp-ergmTerm-0bf628f4">gwb1dsp</a> <a href="#gwb2degree-ergmTerm-584e787c">gwb2degree</a> <a href="#gwb2dsp-ergmTerm-2d408a5d">gwb2dsp</a> <a href="#gwdegree-ergmTerm-b4e39ca9">gwdegree</a> <a href="#hamming-ergmTerm-82ea89b9">hamming</a> <a href="#ininterval-ergmTerm-e9384dcc">ininterval</a> <a href="#isolatededges-ergmTerm-78b32353">isolatededges</a> <a href="#isolates-ergmTerm-55ae8770">isolates</a> <a href="#kstar-ergmTerm-9ffb742c">kstar</a> <a href="#localtriangle-ergmTerm-8ca12415">localtriangle</a> <a href="#meandeg-ergmTerm-f81357a5">meandeg</a> <a href="#mm-ergmTerm-0264ed3f">mm</a> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> <a href="#opentriad-ergmTerm-f67c1cac">opentriad</a> <a href="#smalldiff-ergmTerm-11cc89ad">smalldiff</a> <a href="#smallerthan-ergmTerm-33549cdd">smallerthan</a> <a href="#sociality-ergmTerm-ecb55eaa">sociality</a> <a href="#sum-ergmTerm-304f882f">sum</a> <a href="#threetrail-ergmTerm-2ad16d45">threetrail</a> <a href="#transitiveties-ergmTerm-3382c137">transitiveties</a> <a href="#transitiveweights-ergmTerm-7797c57b">transitiveweights</a> <a href="#triadcensus-ergmTerm-6a6bbd87">triadcensus</a> <a href="#triangle-ergmTerm-9b49a585">triangle</a> <a href="#tripercent-ergmTerm-a932d91a">tripercent</a> <a href="#twopath-ergmTerm-930ae8af">twopath</a><h3><a id="cat_categorical_nodal_attribute">categorical nodal attribute</a></h3><a href="#absdiffcat-ergmTerm-5b2a4b77">absdiffcat</a> <a href="#altkstar-ergmTerm-201bf7a6">altkstar</a> <a href="#b1concurrent-ergmTerm-b6d8305e">b1concurrent</a> <a href="#b1degree-ergmTerm-b23eca4d">b1degree</a> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> <a href="#b1star-ergmTerm-24b65fe7">b1star</a> <a href="#b1starmix-ergmTerm-e8fb79b6">b1starmix</a> <a href="#b1twostar-ergmTerm-3ca58d12">b1twostar</a> <a href="#b2degree-ergmTerm-20b6a8ee">b2degree</a> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> <a href="#b2star-ergmTerm-76adb9af">b2star</a> <a href="#b2starmix-ergmTerm-391186eb">b2starmix</a> <a href="#b2twostar-ergmTerm-ca7ec3bb">b2twostar</a> <a href="#concurrent-ergmTerm-a0121891">concurrent</a> <a href="#concurrentties-ergmTerm-8ccb08e6">concurrentties</a> <a href="#ctriple-ergmTerm-9ad4f7cd">ctriple</a> <a href="#degrange-ergmTerm-e31fe592">degrange</a> <a href="#degree-ergmTerm-64bfdc89">degree</a> <a href="#idegrange-ergmTerm-03001d90">idegrange</a> <a href="#idegree-ergmTerm-036b6e10">idegree</a> <a href="#istar-ergmTerm-686da871">istar</a> <a href="#kstar-ergmTerm-9ffb742c">kstar</a> <a href="#mm-ergmTerm-0264ed3f">mm</a> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> <a href="#nodeofactor-ergmTerm-8944a896">nodeofactor</a> <a href="#odegrange-ergmTerm-a29a08d0">odegrange</a> <a href="#odegree-ergmTerm-12c180fc">odegree</a> <a href="#ostar-ergmTerm-88787ec2">ostar</a> <a href="#sociality-ergmTerm-ecb55eaa">sociality</a> <a href="#transitiveties-ergmTerm-3382c137">transitiveties</a> <a href="#triangle-ergmTerm-9b49a585">triangle</a> <a href="#tripercent-ergmTerm-a932d91a">tripercent</a> <a href="#ttriple-ergmTerm-db2252b3">ttriple</a><h3><a id="cat_curved">curved</a></h3><a href="#altkstar-ergmTerm-201bf7a6">altkstar</a> <a href="#gwb1degree-ergmTerm-847064c5">gwb1degree</a> <a href="#gwb1dsp-ergmTerm-0bf628f4">gwb1dsp</a> <a href="#gwb2degree-ergmTerm-584e787c">gwb2degree</a> <a href="#gwb2dsp-ergmTerm-2d408a5d">gwb2dsp</a> <a href="#gwdegree-ergmTerm-b4e39ca9">gwdegree</a> <a href="#gwidegree-ergmTerm-b37ed894">gwidegree</a> <a href="#gwodegree-ergmTerm-276e606c">gwodegree</a><h3><a id="cat_triad-related">triad-related</a></h3><a href="#asymmetric-ergmTerm-da585369">asymmetric</a> <a href="#balance-ergmTerm-9111bd77">balance</a> <a href="#ctriple-ergmTerm-9ad4f7cd">ctriple</a> <a href="#intransitive-ergmTerm-4a599cad">intransitive</a> <a href="#localtriangle-ergmTerm-8ca12415">localtriangle</a> <a href="#nearsimmelian-ergmTerm-ba85787e">nearsimmelian</a> <a href="#opentriad-ergmTerm-f67c1cac">opentriad</a> <a href="#simmelian-ergmTerm-15e60325">simmelian</a> <a href="#simmelianties-ergmTerm-3361aef9">simmelianties</a> <a href="#threetrail-ergmTerm-2ad16d45">threetrail</a> <a href="#transitive-ergmTerm-838987d1">transitive</a> <a href="#transitiveties-ergmTerm-3382c137">transitiveties</a> <a href="#transitiveweights-ergmTerm-7797c57b">transitiveweights</a> <a href="#triadcensus-ergmTerm-6a6bbd87">triadcensus</a> <a href="#triangle-ergmTerm-9b49a585">triangle</a> <a href="#tripercent-ergmTerm-a932d91a">tripercent</a> <a href="#ttriple-ergmTerm-db2252b3">ttriple</a><h3><a id="cat_bipartite">bipartite</a></h3><a href="#b1concurrent-ergmTerm-b6d8305e">b1concurrent</a> <a href="#b1cov-ergmTerm-a16e8340">b1cov</a> <a href="#b1degrange-ergmTerm-ae4dbc10">b1degrange</a> <a href="#b1degree-ergmTerm-b23eca4d">b1degree</a> <a href="#b1dsp-ergmTerm-f3ebeba1">b1dsp</a> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> <a href="#b1mindegree-ergmTerm-f69f807c">b1mindegree</a> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> <a href="#b1sociality-ergmTerm-4c85e6e8">b1sociality</a> <a href="#b1star-ergmTerm-24b65fe7">b1star</a> <a href="#b1starmix-ergmTerm-e8fb79b6">b1starmix</a> <a href="#b1twostar-ergmTerm-3ca58d12">b1twostar</a> <a href="#b2concurrent-ergmTerm-c72bf19a">b2concurrent</a> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> <a href="#b2degrange-ergmTerm-d16c3697">b2degrange</a> <a href="#b2degree-ergmTerm-20b6a8ee">b2degree</a> <a href="#b2dsp-ergmTerm-e9e03312">b2dsp</a> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> <a href="#b2mindegree-ergmTerm-3b15466d">b2mindegree</a> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> <a href="#b2sociality-ergmTerm-ae7e4336">b2sociality</a> <a href="#b2star-ergmTerm-76adb9af">b2star</a> <a href="#b2starmix-ergmTerm-391186eb">b2starmix</a> <a href="#b2twostar-ergmTerm-ca7ec3bb">b2twostar</a> <a href="#coincidence-ergmTerm-58ca78cc">coincidence</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#gwb1degree-ergmTerm-847064c5">gwb1degree</a> <a href="#gwb1dsp-ergmTerm-0bf628f4">gwb1dsp</a> <a href="#gwb2degree-ergmTerm-584e787c">gwb2degree</a> <a href="#gwb2dsp-ergmTerm-2d408a5d">gwb2dsp</a> <a href="#isolatededges-ergmTerm-78b32353">isolatededges</a><h3><a id="cat_frequently-used">frequently-used</a></h3><a href="#b1cov-ergmTerm-a16e8340">b1cov</a> <a href="#b1degree-ergmTerm-b23eca4d">b1degree</a> <a href="#b1factor-ergmTerm-ad0d3a93">b1factor</a> <a href="#b1nodematch-ergmTerm-110b470e">b1nodematch</a> <a href="#b2concurrent-ergmTerm-c72bf19a">b2concurrent</a> <a href="#b2cov-ergmTerm-abbfac55">b2cov</a> <a href="#b2degree-ergmTerm-20b6a8ee">b2degree</a> <a href="#b2factor-ergmTerm-bed2c507">b2factor</a> <a href="#b2nodematch-ergmTerm-126ff8a2">b2nodematch</a> <a href="#degree-ergmTerm-64bfdc89">degree</a> <a href="#diff-ergmTerm-0b65ee46">diff</a> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a> <a href="#gwdegree-ergmTerm-b4e39ca9">gwdegree</a> <a href="#idegree-ergmTerm-036b6e10">idegree</a> <a href="#isolates-ergmTerm-55ae8770">isolates</a> <a href="#mm-ergmTerm-0264ed3f">mm</a> <a href="#mutual-ergmTerm-22863009">mutual</a> <a href="#nodecov-ergmTerm-e6fb5c28">nodecov</a> <a href="#nodefactor-ergmTerm-6bea11f2">nodefactor</a> <a href="#nodeicov-ergmTerm-02d64b5b">nodeicov</a> <a href="#nodeifactor-ergmTerm-7604a73e">nodeifactor</a> <a href="#nodematch-ergmTerm-b316dba4">nodematch</a> <a href="#nodemix-ergmTerm-4723046c">nodemix</a> <a href="#odegree-ergmTerm-12c180fc">odegree</a> <a href="#triangle-ergmTerm-9b49a585">triangle</a><h3><a id="cat_nonnegative">nonnegative</a></h3><a href="#cyclicalweights-ergmTerm-994a6687">cyclicalweights</a> <a href="#transitiveweights-ergmTerm-7797c57b">transitiveweights</a><h3><a id="cat_quantitative_dyadic_attribute">quantitative dyadic attribute</a></h3><a href="#dyadcov-ergmTerm-5fba5404">dyadcov</a> <a href="#edgecov-ergmTerm-1fb5ef19">edgecov</a><h3><a id="cat_categorical_dyadic_attribute">categorical dyadic attribute</a></h3><a href="#localtriangle-ergmTerm-8ca12415">localtriangle</a>



<h3>References</h3>


<ul>
<li><p> Krivitsky P. N., Hunter D. R., Morris M., Klumb
C. (2021). &quot;ergm 4.0: New features and improvements.&quot;
arXiv:2106.04997. <a href="https://arxiv.org/abs/2106.04997">https://arxiv.org/abs/2106.04997</a>
</p>
</li>
<li><p> Bomiriya, R. P, Bansal, S., and Hunter, D. R. (2014).  Modeling
Homophily in ERGMs for Bipartite Networks.  Submitted.
</p>
</li>
<li><p> Butts, CT.  (2008).  &quot;A Relational Event Framework for Social
Action.&quot; <em>Sociological Methodology,</em> 38(1).
</p>
</li>
<li><p> Davis, J.A. and Leinhardt, S.  (1972).  The Structure of Positive
Interpersonal Relations in Small Groups.  In J. Berger (Ed.),
<em>Sociological Theories in Progress, Volume 2</em>, 218&ndash;251.  Boston:
Houghton Mifflin.
</p>
</li>
<li><p> Holland, P. W. and S. Leinhardt (1981). An exponential family of
probability distributions for directed graphs.  <em>Journal of the
American Statistical Association</em>, 76: 33&ndash;50.
</p>
</li>
<li><p> Hunter, D. R. and M. S. Handcock (2006). Inference in curved
exponential family models for networks. <em>Journal of Computational and
Graphical Statistics</em>, 15: 565&ndash;583.
</p>
</li>
<li><p> Hunter, D. R. (2007). Curved exponential family models for social
networks. <em>Social Networks</em>, 29: 216&ndash;230.
</p>
</li>
<li><p> Krackhardt, D. and Handcock, M. S. (2007).  Heider versus Simmel:
Emergent Features in Dynamic Structures. <em>Lecture Notes in Computer
Science</em>, 4503, 14&ndash;27.
</p>
</li>
<li><p> Krivitsky P. N. (2012). Exponential-Family Random Graph Models for
Valued Networks. <em>Electronic Journal of Statistics</em>, 2012, 6,
1100-1128. <a href="https://doi.org/10.1214/12-EJS696">doi:10.1214/12-EJS696</a>
</p>
</li>
<li><p> Robins, G; Pattison, P; and Wang, P.  (2009).  &quot;Closure,
Connectivity, and Degree Distributions: Exponential Random Graph (p*) Models
for Directed Social Networks.&quot; <em>Social Networks,</em> 31:105-117.
</p>
</li>
<li><p> Snijders T. A. B., G. G. van de Bunt, and C. E. G. Steglich.
Introduction to Stochastic Actor-Based Models for Network Dynamics.
<em>Social Networks</em>, 2010, 32(1), 44-60. <a href="https://doi.org/10.1016/j.socnet.2009.02.004">doi:10.1016/j.socnet.2009.02.004</a>
</p>
</li>
<li><p> Morris M, Handcock MS, and Hunter DR. Specification of
Exponential-Family Random Graph Models: Terms and Computational Aspects.
<em>Journal of Statistical Software</em>, 2008, 24(4), 1-24.
<a href="https://doi.org/10.18637/jss.v024.i04">doi:10.18637/jss.v024.i04</a>
</p>
</li>
<li><p> Snijders, T. A. B., P. E. Pattison, G. L. Robins, and M. S. Handcock
(2006). New specifications for exponential random graph models,
<em>Sociological Methodology</em>, 36(1): 99-153.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ergm-package">ergm</a></code> package, <code><a href="#topic+search.ergmTerms">search.ergmTerms</a></code>, <code><a href="#topic+ergm">ergm</a></code>, <code><a href="network.html#topic+network">network</a></code>, <code><a href="network.html#topic++25v+25">%v%</a></code>, <code><a href="network.html#topic++25n+25">%n%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ergm(flomarriage ~ kstar(1:2) + absdiff("wealth") + triangle)

ergm(molecule ~ edges + kstar(2:3) + triangle
                      + nodematch("atomic type",diff=TRUE)
                      + triangle + absdiff("atomic type"))

## End(Not run)
</code></pre>

<hr>
<h2 id='esp-ergmTerm'>Directed edgewise shared partners</h2><span id='topic+esp-ergmTerm'></span><span id='topic+InitErgmTerm.desp'></span><span id='topic+desp-ergmTerm'></span><span id='topic+InitErgmTerm.esp'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code> th such statistic equals the number of edges in the network with exactly <code>d[i]</code> shared partners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: desp(d, type="OTP")

# binary: esp(d, type="OTP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="esp-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="esp-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>
<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='Exp-ergmTerm'>Exponentiate a network's statistic</h2><span id='topic+Exp-ergmTerm'></span><span id='topic+InitErgmTerm.Exp'></span><span id='topic+InitWtErgmTerm.Exp'></span>

<h3>Description</h3>

<p>Evaluate the terms specified in <code>formula</code> and exponentiates them with base <code class="reqn">e</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Exp(formula)

# valued: Exp(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exp-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary, valued</p>


<hr>
<h2 id='F-ergmTerm'>Filtering on arbitrary one-term model</h2><span id='topic+F-ergmTerm'></span><span id='topic+InitErgmTerm.F'></span>

<h3>Description</h3>

<p>Evaluates the given <code>formula</code> on a network constructed by
taking <code class="reqn">y</code> and removing any edges for which
<code class="reqn">f_{i,j}(y_{i,j}) = 0</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: F(formula, filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="F-ergmTerm_+3A_filter">filter</code></td>
<td>
<p>must contain one binary <code>ergm</code> term, with
the following properties:
</p>

<ul>
<li><p> dyadic independence;
</p>
</li>
<li><p> dyadwise contribution of 0 for a 0-valued dyad.
</p>
</li></ul>

<p>Formally, this means that it is expressable as
</p>
<p style="text-align: center;"><code class="reqn">g(y) = \sum_{i,j} f_{i,j}(y_{i,j}),</code>
</p>
<p> where for all <code class="reqn">i</code>, <code class="reqn">j</code>, and <code class="reqn">y</code>,
<code class="reqn">f_{i,j}(y_{i,j})</code> for which <code class="reqn">f_{i,j}(0)=0</code>.
For convenience, the term in specified can be a part of a simple logical or comparison operation: (e.g., <code>~!nodematch("A")</code> or <code>~abs("X")&gt;3</code>),
which filters on <code class="reqn">f_{i,j}(y_{i,j}) \bigcirc 0</code> instead.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary</p>


<hr>
<h2 id='faux.desert.high'>Faux desert High School as a network object</h2><span id='topic+faux.desert.high'></span>

<h3>Description</h3>

<p>This data set represents a simulation of a directed in-school friendship
network.  The network is named faux.desert.high.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(faux.desert.high)
</code></pre>


<h3>Format</h3>

<p><code>faux.desert.high</code> is a <code><a href="network.html#topic+network">network</a></code> object
with 107 vertices (students, in this case) and 439 directed edges
(friendship nominations). To obtain additional summary information about it,
type <code>summary(faux.desert.high)</code>.
</p>
<p>The vertex attributes are <code>Grade</code>, <code>Sex</code>, and <code>Race</code>. The
<code>Grade</code> attribute has values 7 through 12, indicating each student's
grade in school.  The <code>Race</code> attribute is based on the answers to two
questions, one on Hispanic identity and one on race, and takes six possible
values: White (non-Hisp.), Black (non-Hisp.), Hispanic, Asian (non-Hisp.),
Native American, and Other (non-Hisp.)
</p>


<h3>Licenses and Citation</h3>

<p>If the source of the data set does not
specified otherwise, this data set is protected by the Creative Commons
License <a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a>.
</p>
<p>When publishing results obtained using this data set, the original authors
(Resnick et al, 1997) should be cited. In addition this package should be
cited as:
</p>
<p>Mark S. Handcock, David R. Hunter, Carter T. Butts, Steven M. Goodreau, and
Martina Morris. 2003 <em>statnet: Software tools for the Statistical
Modeling of Network Data</em> <br /> <a href="https://statnet.org">https://statnet.org</a>.
</p>


<h3>Source</h3>

<p>The data set is simulation based upon an ergm model fit to data from
one school community from the AddHealth Study, Wave I (Resnick et al.,
1997). It was constructed as follows:
</p>
<p>The school in question (a single school with 7th through 12th grades) was
selected from the Add Health &quot;structure files.&quot;  Documentation on these
files can be found here:
<a href="https://addhealth.cpc.unc.edu/documentation/codebooks/">https://addhealth.cpc.unc.edu/documentation/codebooks/</a>.
</p>
<p>The stucture file contains directed out-ties representing each instance of a
student who named another student as a friend.  Students could nominate up
to 5 male and 5 female friends. Note that registered students who did not
take the AddHealth survey or who were not listed by name on the schools'
student roster are not included in the stucture files.  In addition, we
removed any students with missing values for race, grade or sex.
</p>
<p>The following <code><a href="#topic+ergm">ergm</a></code> model was fit to the original data
(with code updated for modern syntax):
</p>
<pre> desert.fit &lt;- ergm(original.net ~ edges + mutual +
absdiff("grade") + nodefactor("race", base=5) + nodefactor("grade", base=3)
+ nodefactor("sex") + nodematch("race", diff = TRUE) + nodematch("grade",
diff = TRUE) + nodematch("sex", diff = FALSE) + idegree(0:1) + odegree(0:1)
+ gwesp(0.1,fixed=T), constraints = ~bd(maxout=10), control =
control.ergm(MCMLE.steplength = .25, MCMC.burnin = 100000, MCMC.interval =
10000, MCMC.samplesize = 2500, MCMLE.maxit = 100), verbose=T) </pre>
<p>Then the faux.desert.high dataset was created by simulating a single network
from the above model fit:
</p>
<pre> faux.desert.high &lt;- simulate(desert.fit, nsim=1,
                 control=snctrl(MCMC.burnin=1e+8),
                 constraints = ~edges) </pre>


<h3>References</h3>

<p>Resnick M.D., Bearman, P.S., Blum R.W. et al. (1997). <em>Protecting
adolescents from harm. Findings from the National Longitudinal Study on
Adolescent Health</em>, <em>Journal of the American Medical Association</em>, 278:
823-32.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>,
<code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="#topic+ergm">ergm</a></code>,
<code><a href="#topic+faux.desert.high">faux.desert.high</a></code>, <code><a href="#topic+faux.mesa.high">faux.mesa.high</a></code>,
<code><a href="#topic+faux.magnolia.high">faux.magnolia.high</a></code>
</p>

<hr>
<h2 id='faux.dixon.high'>Faux dixon High School as a network object</h2><span id='topic+faux.dixon.high'></span>

<h3>Description</h3>

<p>This data set represents a simulation of a directed in-school friendship
network.  The network is named faux.dixon.high.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(faux.dixon.high)
</code></pre>


<h3>Format</h3>

<p><code>faux.dixon.high</code> is a <code><a href="network.html#topic+network">network</a></code> object
with 248 vertices (students, in this case) and 1197 directed edges
(friendship nominations). To obtain additional summary information about it,
type <code>summary(faux.dixon.high)</code>.
</p>
<p>The vertex attributes are <code>Grade</code>, <code>Sex</code>, and <code>Race</code>. The
<code>Grade</code> attribute has values 7 through 12, indicating each student's
grade in school.  The <code>Race</code> attribute is based on the answers to two
questions, one on Hispanic identity and one on race, and takes six possible
values: White (non-Hisp.), Black (non-Hisp.), Hispanic, Asian (non-Hisp.),
Native American, and Other (non-Hisp.)
</p>


<h3>Licenses and Citation</h3>

<p>If the source of the data set does not
specified otherwise, this data set is protected by the Creative Commons
License <a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a>.
</p>
<p>When publishing results obtained using this data set, the original authors
(Resnick et al, 1997) should be cited. In addition this package should be
cited as:
</p>
<p>Mark S. Handcock, David R. Hunter, Carter T. Butts, Steven M. Goodreau, and
Martina Morris. 2003 <em>statnet: Software tools for the Statistical
Modeling of Network Data</em> <br /> <a href="https://statnet.org">https://statnet.org</a>.
</p>


<h3>Source</h3>

<p>The data set is simulation based upon an ergm model fit to data from
one school community from the AddHealth Study, Wave I (Resnick et al.,
1997). It was constructed as follows:
</p>
<p>The school in question (a single school with 7th through 12th grades) was
selected from the Add Health &quot;structure files.&quot;  Documentation on these
files can be found here:
<a href="https://addhealth.cpc.unc.edu/documentation/codebooks/">https://addhealth.cpc.unc.edu/documentation/codebooks/</a>.
</p>
<p>The stucture file contains directed out-ties representing each instance of a
student who named another student as a friend.  Students could nominate up
to 5 male and 5 female friends. Note that registered students who did not
take the AddHealth survey or who were not listed by name on the schools'
student roster are not included in the stucture files.  In addition, we
removed any students with missing values for race, grade or sex.
</p>
<p>The following <code><a href="#topic+ergm">ergm</a></code> model was fit to the original data
(with code updated for modern syntax):
</p>
<pre> dixon.fit &lt;- ergm(original.net ~ edges + mutual +
absdiff("grade") + nodefactor("race", base=5) + nodefactor("grade", base=3)
+ nodefactor("sex") + nodematch("race", diff = TRUE) + nodematch("grade",
diff = TRUE) + nodematch("sex", diff = FALSE) + idegree(0:1) + odegree(0:1)
+ gwesp(0.1,fixed=T), constraints = ~bd(maxout=10), control =
control.ergm(MCMLE.steplength = .25, MCMC.burnin = 100000, MCMC.interval =
10000, MCMC.samplesize = 2500, MCMLE.maxit = 100), verbose=T) </pre>
<p>Then the faux.dixon.high dataset was created by simulating a single network
from the above model fit:
</p>
<pre> faux.dixon.high &lt;- simulate(dixon.fit, nsim=1, burnin=1e+8,
constraint = "edges") </pre>


<h3>References</h3>

<p>Resnick M.D., Bearman, P.S., Blum R.W. et al. (1997). <em>Protecting
adolescents from harm. Findings from the National Longitudinal Study on
Adolescent Health</em>, <em>Journal of the American Medical Association</em>, 278:
823-32.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>,
<code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="#topic+ergm">ergm</a></code>,
<code><a href="#topic+faux.desert.high">faux.desert.high</a></code>, <code><a href="#topic+faux.mesa.high">faux.mesa.high</a></code>,
<code><a href="#topic+faux.magnolia.high">faux.magnolia.high</a></code>
</p>

<hr>
<h2 id='faux.magnolia.high'>Goodreau's Faux Magnolia High School as a network object</h2><span id='topic+faux.magnolia.high'></span>

<h3>Description</h3>

<p>This data set represents a simulation of an in-school friendship network.
The network is named faux.magnolia.high because the school commnunities on
which it is based are large and located in the southern US.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(faux.magnolia.high)
</code></pre>


<h3>Format</h3>

<p><code>faux.magnolia.high</code> is a <code><a href="network.html#topic+network">network</a></code> object
with 1461 vertices (students, in this case) and 974 undirected edges (mutual
friendships). To obtain additional summary information about it, type
<code>summary(faux.magnolia.high)</code>.
</p>
<p>The vertex attributes are <code>Grade</code>, <code>Sex</code>, and <code>Race</code>. The
<code>Grade</code> attribute has values 7 through 12, indicating each student's
grade in school.  The <code>Race</code> attribute is based on the answers to two
questions, one on Hispanic identity and one on race, and takes six possible
values: White (non-Hisp.), Black (non-Hisp.), Hispanic, Asian (non-Hisp.),
Native American, and Other (non-Hisp.)
</p>


<h3>Licenses and Citation</h3>

<p>If the source of the data set does not
specified otherwise, this data set is protected by the Creative Commons
License <a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a>.
</p>
<p>When publishing results obtained using this data set, the original authors
(Resnick et al, 1997) should be cited. In addition this package should be
cited as:
</p>
<p>Mark S. Handcock, David R. Hunter, Carter T. Butts, Steven M. Goodreau, and
Martina Morris. 2003 <em>statnet: Software tools for the Statistical
Modeling of Network Data</em> <br /> <a href="https://statnet.org">https://statnet.org</a>.
</p>


<h3>Source</h3>

<p>The data set is based upon a model fit to data from two school
communities from the AddHealth Study, Wave I (Resnick et al., 1997). It was
constructed as follows:
</p>
<p>The two schools in question (a junior and senior high school in the same
community) were combined into a single network dataset.  Students who did
not take the AddHealth survey or who were not listed on the schools' student
rosters were eliminated, then an undirected link was established between any
two individuals who both named each other as a friend.  All missing race,
grade, and sex values were replaced by a random draw with weights determined
by the size of the attribute classes in the school.
</p>
<p>The following <code><a href="#topic+ergm">ergm</a></code> model was fit to the original data:
</p>
<pre> magnolia.fit &lt;- ergm (magnolia ~ edges +
nodematch("Grade",diff=T) + nodematch("Race",diff=T) +
nodematch("Sex",diff=F) + absdiff("Grade") + gwesp(0.25,fixed=T),
control=control.ergm(MCMC.burnin=10000, MCMC.interval=1000, MCMLE.maxit=25,
                     MCMC.samplesize=2500, MCMLE.steplength=0.25)) </pre>
<p>Then the faux.magnolia.high dataset was created by simulating a single
network from the above model fit:
</p>
<pre> faux.magnolia.high &lt;- simulate (magnolia.fit, nsim=1,
                 control = snctrl(MCMC.burnin=100000000), constraints = ~edges) </pre>


<h3>References</h3>

<p>Resnick M.D., Bearman, P.S., Blum R.W. et al. (1997). <em>Protecting
adolescents from harm. Findings from the National Longitudinal Study on
Adolescent Health</em>, <em>Journal of the American Medical Association</em>, 278:
823-32.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>,
<code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="#topic+ergm">ergm</a></code>,
<code><a href="#topic+faux.mesa.high">faux.mesa.high</a></code>
</p>

<hr>
<h2 id='faux.mesa.high'>Goodreau's Faux Mesa High School as a network object</h2><span id='topic+faux.mesa.high'></span><span id='topic+fauxhigh'></span>

<h3>Description</h3>

<p>This data set (formerly called &ldquo;fauxhigh&rdquo;) represents a simulation of
an in-school friendship network.  The network is named <code>faux.mesa.high</code>
because the school commnunity on which it is based is in the rural western
US, with a student body that is largely Hispanic and Native American.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(faux.mesa.high)
</code></pre>


<h3>Format</h3>

<p><code>faux.mesa.high</code> is a <code><a href="network.html#topic+network">network</a></code> object
with 205 vertices (students, in this case) and 203 undirected edges (mutual
friendships).  To obtain additional summary information about it, type
<code>summary(faux.mesa.high)</code>.
</p>
<p>The vertex attributes are <code>Grade</code>, <code>Sex</code>, and <code>Race</code>. The
<code>Grade</code> attribute has values 7 through 12, indicating each student's
grade in school.  The <code>Race</code> attribute is based on the answers to two
questions, one on Hispanic identity and one on race, and takes six possible
values: White (non-Hisp.), Black (non-Hisp.), Hispanic, Asian (non-Hisp.),
Native American, and Other (non-Hisp.)
</p>


<h3>Licenses and Citation</h3>

<p>If the source of the data set does not
specified otherwise, this data set is protected by the Creative Commons
License <a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a>.
</p>
<p>When publishing results obtained using this data set, the original authors
(Resnick et al, 1997) should be cited. In addition this package should be
cited as:
</p>
<p>Mark S. Handcock, David R. Hunter, Carter T. Butts, Steven M. Goodreau, and
Martina Morris. 2003 <em>statnet: Software tools for the Statistical
Modeling of Network Data</em> <br /> <a href="https://statnet.org">https://statnet.org</a>.
</p>


<h3>Source</h3>

<p>The data set is based upon a model fit to data from one school
community from the AddHealth Study, Wave I (Resnick et al., 1997). It was
constructed as follows:
</p>
<p>A vector representing the sex of each student in the school was randomly
re-ordered.  The same was done with the students' response to questions on
race and grade.  These three attribute vectors were permuted independently.
Missing values for each were randomly assigned with weights determined by
the size of the attribute classes in the school.
</p>
<p>The following <code><a href="#topic+ergm">ergm</a></code> formula was used to fit a model to the
original data:
</p>
<pre> ~ edges + nodefactor("Grade") + nodefactor("Race") +
nodefactor("Sex") + nodematch("Grade",diff=TRUE) +
nodematch("Race",diff=TRUE) + nodematch("Sex",diff=FALSE) +
gwdegree(1.0,fixed=TRUE) + gwesp(1.0,fixed=TRUE) + gwdsp(1.0,fixed=TRUE) </pre>
<p>The resulting model fit was then applied to a network with actors possessing
the permuted attributes and with the same number of edges as in the original
data.
</p>
<p>The processes for handling missing data and defining the race attribute are
described in Hunter, Goodreau &amp; Handcock (2008).
</p>


<h3>References</h3>

<p>Hunter D.R., Goodreau S.M. and Handcock M.S. (2008). <em>Goodness of Fit
of Social Network Models</em>, <em>Journal of the American Statistical
Association</em>.
</p>
<p>Resnick M.D., Bearman, P.S., Blum R.W. et al. (1997). <em>Protecting
adolescents from harm. Findings from the National Longitudinal Study on
Adolescent Health</em>, <em>Journal of the American Medical Association</em>, 278:
823-32.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>,
<code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="#topic+ergm">ergm</a></code>,
<code><a href="#topic+faux.magnolia.high">faux.magnolia.high</a></code>
</p>

<hr>
<h2 id='fix.curved'>Convert a curved ERGM into a corresponding &quot;fixed&quot; ERGM.</h2><span id='topic+fix.curved'></span><span id='topic+fix.curved.ergm'></span><span id='topic+fix.curved.formula'></span>

<h3>Description</h3>

<p>The generic <code>fix.curved</code> converts an <code><a href="#topic+ergm">ergm</a></code> object or
formula of a model with curved terms to the variant in which the curved
parameters are fixed. Note that each term has to be treated as a special
case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.curved(object, ...)

## S3 method for class 'ergm'
fix.curved(object, ...)

## S3 method for class 'formula'
fix.curved(object, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.curved_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ergm">ergm</a></code> object or an ERGM formula. The curved
terms of the given formula (or the formula used in the fit) must have all of
their arguments passed by name.</p>
</td></tr>
<tr><td><code id="fix.curved_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
<tr><td><code id="fix.curved_+3A_theta">theta</code></td>
<td>
<p>Curved model parameter configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some ERGM terms such as <code><a href="#topic+gwesp-ergmTerm">gwesp</a></code> and <code><a href="#topic+gwdegree-ergmTerm">gwdegree</a></code> have
two forms: a curved form, for which their decay or similar parameters are to
be estimated, and whose canonical statistics is a vector of the term's
components (<code><a href="#topic+esp-ergmTerm">esp(1)</a></code>, <code><a href="#topic+esp-ergmTerm">esp(2)</a></code>, ... and
<code><a href="#topic+degree-ergmTerm">degree(1)</a></code>, <code><a href="#topic+degree-ergmTerm">degree(2)</a></code>, ..., respectively) and
a &quot;fixed&quot; form where the decay or similar parameters are fixed, and whose
canonical statistic is just the term itself. It is often desirable to fit a
model estimating the curved parameters but simulate the &quot;fixed&quot; statistic.
</p>
<p>This function thus takes in a fit or a formula and performs this mapping,
returning a &quot;fixed&quot; model and parameter specification.  It only works for
curved ERGM terms included with the <code><a href="#topic+ergm-package">ergm</a></code>
package. It does not work with curved terms not included in ergm.
</p>


<h3>Value</h3>

<p>A list with the following components: </p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>The &quot;fixed&quot;
formula.</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>The &quot;fixed&quot; parameter vector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm</a></code>, <code><a href="#topic+simulate.ergm">simulate.ergm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


data(sampson)
gest&lt;-ergm(samplike~edges+gwesp(),
           control=control.ergm(MCMLE.maxit=2))
summary(gest)
# A statistic for esp(1),...,esp(16)
simulate(gest,output="stats")

tmp&lt;-fix.curved(gest)
tmp
# A gwesp() statistic only
simulate(tmp$formula, coef=tmp$theta, output="stats") 


</code></pre>

<hr>
<h2 id='fixallbut-ergmConstraint'>Preserve the dyad status in all but the given edges</h2><span id='topic+fixallbut-ergmConstraint'></span><span id='topic+InitErgmConstraint.fixallbut'></span>

<h3>Description</h3>

<p>Preserve the dyad status in all but <code>free.dyads</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># fixallbut(free.dyads)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixallbut-ergmConstraint_+3A_free.dyads">free.dyads</code></td>
<td>
<p>edgelist or network. Networks will be converted to the corresponding edgelist.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected</p>


<hr>
<h2 id='fixedas-ergmConstraint'>Preserve and preclude edges</h2><span id='topic+fixedas-ergmConstraint'></span><span id='topic+InitErgmConstraint.fixedas'></span>

<h3>Description</h3>

<p>Preserve the edges in 'present' and preclude the edges in 'absent'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># fixedas(present, absent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedas-ergmConstraint_+3A_present">present</code>, <code id="fixedas-ergmConstraint_+3A_absent">absent</code></td>
<td>
<p>edgelist or network</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected</p>


<hr>
<h2 id='florentine'>Florentine Family Marriage and Business Ties Data as a &quot;network&quot; object</h2><span id='topic+florentine'></span><span id='topic+flobusiness'></span><span id='topic+flomarriage'></span>

<h3>Description</h3>

<p>This is a data set of marriage and business ties among Renaissance
Florentine families. The data is originally from Padgett (1994) via
<code>UCINET</code> and stored as a <code><a href="network.html#topic+network">network</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(florentine)
</code></pre>


<h3>Details</h3>

<p>Breiger &amp; Pattison (1986), in their discussion of local role analysis, use
a subset of data on the social relations among Renaissance Florentine
families (person aggregates) collected by John Padgett from historical
documents. The two relations are business ties (<code>flobusiness</code> -
specifically, recorded financial ties such as loans, credits and joint
partnerships) and marriage alliances (<code>flomarriage</code>).
</p>
<p>As Breiger &amp; Pattison point out, the original data are symmetrically coded.
This is acceptable perhaps for marital ties, but is unfortunate for the
financial ties (which are almost certainly directed). To remedy this, the
financial ties can be recoded as directed relations using some external
measure of power - for instance, a measure of wealth. Both graphs provide
vertex information on (1) <code>wealth</code> each family's net wealth in 1427 (in
thousands of lira); (2) <code>priorates</code> the number of priorates (seats on
the civic council) held between 1282- 1344; and (3) <code>totalties</code> the
total number of business or marriage ties in the total dataset of 116
families (see Breiger &amp; Pattison (1986), p 239).
</p>
<p>Substantively, the data include families who were locked in a struggle for
political control of the city of Florence around 1430. Two factions were
dominant in this struggle: one revolved around the infamous Medicis (9), the
other around the powerful Strozzis (15).
</p>


<h3>Source</h3>

<p>Padgett, John F. 1994. Marriage and Elite Structure in Renaissance
Florence, 1282-1500. Paper delivered to the Social Science History
Association.
</p>


<h3>References</h3>

<p>Wasserman, S. and Faust, K. (1994) <em>Social Network
Analysis: Methods and Applications</em>, Cambridge University Press, Cambridge,
England.
</p>
<p>Breiger R. and Pattison P. (1986). <em>Cumulated social roles: The duality
of persons and their algebras</em>, Social Networks, 8, 215-256.
</p>


<h3>See Also</h3>

<p>flo, network, plot.network, ergm
</p>

<hr>
<h2 id='For-ergmTerm'>A <code><a href="base.html#topic+for">for</a></code> operator for terms</h2><span id='topic+For-ergmTerm'></span><span id='topic+InitErgmTerm.For'></span>

<h3>Description</h3>

<p>This operator evaluates the formula given to it,
substituting the specified loop counter variable with each
element in a sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: For(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="For-ergmTerm_+3A_...">...</code></td>
<td>
<p>in any order, </p>

<ul>
<li><p> one <em>unnamed</em> one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the
terms to be evaluated, containing one or more placeholders
<var>VAR</var> <em>and</em>
</p>
</li>
<li><p> one or more <em>named</em> expressions of the form <code><var>VAR</var>
  = <var>SEQ</var></code> specifying the placeholder and its range. See
Details below.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Placeholders are specified in the style of
<code>foreach::foreach()</code>, as <code><var>VAR</var> = <var>SEQ</var></code>. <var>VAR</var>
can be any valid <span class="rlang"><b>R</b></span> variable name, and <var>SEQ</var> can be a vector,
a list, a function of one argument, or a one-sided formula.  The
vector or list will be used directly, whereas a function will be
called with the network as its argument to produce the list, and
the formula will be used analogously to <code><a href="purrr.html#topic+as_mapper">purrr::as_mapper()</a></code>, its
RHS evaluated in an environment in which the network itself will
be accessible as <code>.</code> or <code>.nw</code>.
</p>
<p>If more than one named expression is given, they will be expanded
as one would expect in a nested <code><a href="base.html#topic+for">for</a></code> loop: earlier expressions
will form the outer loops and later expressions the inner loops.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary</p>



<h3>Examples</h3>

<pre><code class='language-R'>#
# The following are equivalent ways to compute differential
# homophily.
#

data(sampson)
(groups &lt;- sort(unique(samplike%v%"group"))) # Sorted list of groups.

# The "normal" way:
summary(samplike ~ nodematch("group", diff=TRUE))

# One element at a time, specifying a list:
summary(samplike ~ For(~nodematch("group", levels=., diff=TRUE),
                       . = groups))

# One element at a time, specifying a function that returns a list:
summary(samplike ~ For(~nodematch("group", levels=., diff=TRUE),
                       . = function(nw) sort(unique(nw%v%"group"))))

# One element at a time, specifying a formula whose RHS expression
# returns a list:
summary(samplike ~ For(~nodematch("group", levels=., diff=TRUE),
                       . = ~sort(unique(.%v%"group"))))

#
# Multiple iterators are possible, in any order. Here, absdiff() is
# being computed for each combination of attribute and power.
#

data(florentine)

# The "normal" way:
summary(flomarriage ~ absdiff("wealth", pow=1) + absdiff("priorates", pow=1) +
                      absdiff("wealth", pow=2) + absdiff("priorates", pow=2) +
                      absdiff("wealth", pow=3) + absdiff("priorates", pow=3))

# With a loop; note that the attribute (a) is being iterated within
# power (.):
summary(flomarriage ~ For(. = 1:3, a = c("wealth", "priorates"), ~absdiff(a, pow=.)))

</code></pre>

<hr>
<h2 id='g4'>Goodreau's four node network as a &quot;network&quot; object</h2><span id='topic+g4'></span>

<h3>Description</h3>

<p>This is an example thought of by Steve Goodreau. It is a directed network of
four nodes and five ties stored as a <code><a href="network.html#topic+network">network</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(g4)
</code></pre>


<h3>Details</h3>

<p>It is interesting because the maximum likelihood estimator of the model with
out degree 3 in it exists, but the maximum psuedolikelihood estimator does
not.
</p>


<h3>Source</h3>

<p>Steve Goodreau
</p>


<h3>See Also</h3>

<p>florentine, network, plot.network, ergm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(g4)
summary(ergm(g4 ~ odegree(3), estimate="MPLE"))
summary(ergm(g4 ~ odegree(3), control=control.ergm(init=0)))

</code></pre>

<hr>
<h2 id='get.node.attr'>Retrieve and check assumptions about vertex attributes (nodal covariates) in
a network</h2><span id='topic+get.node.attr'></span>

<h3>Description</h3>

<p>The <code>get.node.attr</code> function returns the vector of nodal covariates for
the given network and specified attribute if the attribute exists -
execution will halt if the attribute is not correctly given as a single
string or is not found in the vertex attribute list; optionally
<code>get.node.attr</code> will also check that return vector is numeric, halting
execution if not. The purpose is to validate assumptions before passing
attribute data into an ergm term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.node.attr(nw, attrname, functionname = NULL, numeric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.node.attr_+3A_nw">nw</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object</p>
</td></tr>
<tr><td><code id="get.node.attr_+3A_attrname">attrname</code></td>
<td>
<p>the name of a nodal attribute, as a character string</p>
</td></tr>
<tr><td><code id="get.node.attr_+3A_functionname">functionname</code></td>
<td>
<p>the name of the calling function a character string;
this is only used for the warning messages that accompany a halt</p>
</td></tr>
<tr><td><code id="get.node.attr_+3A_numeric">numeric</code></td>
<td>
<p>logical, whether to halt execution if the return vector is
not numeric; default=FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the vector of 'attrname' covariates for the vertices in the
network
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+get.vertex.attribute">get.vertex.attribute</a></code> for a version without
the checking functionality
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
get.node.attr(faux.mesa.high,'Grade')
</code></pre>

<hr>
<h2 id='geweke.diag.mv'>Multivariate version of <code>coda</code>'s <code><a href="coda.html#topic+geweke.diag">coda::geweke.diag()</a></code>.</h2><span id='topic+geweke.diag.mv'></span>

<h3>Description</h3>

<p>Rather than comparing each mean independently, compares them
jointly. Note that it returns an <code>htest</code> object, not a <code>geweke.diag</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geweke.diag.mv(x, frac1 = 0.1, frac2 = 0.5, split.mcmc.list = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geweke.diag.mv_+3A_x">x</code></td>
<td>
<p>an <code><a href="coda.html#topic+mcmc">mcmc</a></code>, <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, or just a matrix with
observations in rows and variables in columns.</p>
</td></tr>
<tr><td><code id="geweke.diag.mv_+3A_frac1">frac1</code>, <code id="geweke.diag.mv_+3A_frac2">frac2</code></td>
<td>
<p>the fraction at the start and, respectively, at
the end of the sample to compare.</p>
</td></tr>
<tr><td><code id="geweke.diag.mv_+3A_split.mcmc.list">split.mcmc.list</code></td>
<td>
<p>when given an <code>mcmc.list</code>, whether to test
each chain individually.</p>
</td></tr>
<tr><td><code id="geweke.diag.mv_+3A_...">...</code></td>
<td>
<p>additional arguments, passed on to
<code><a href="#topic+approx.hotelling.diff.test">approx.hotelling.diff.test()</a></code>, which passes them to
<code><a href="#topic+spectrum0.mvar">spectrum0.mvar()</a></code>, etc.; in particular, <code style="white-space: pre;">&#8288;order.max=&#8288;</code> can be used
to limit the order of the AR model used to estimate the effective
sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>htest</code>, inheriting from that returned
by <code><a href="#topic+approx.hotelling.diff.test">approx.hotelling.diff.test()</a></code>, but with p-value considered to
be 0 on insufficient sample size.
</p>


<h3>Note</h3>

<p>If <code><a href="#topic+approx.hotelling.diff.test">approx.hotelling.diff.test()</a></code> returns an error, then
assume that burn-in is insufficient.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+geweke.diag">coda::geweke.diag()</a></code>, <code><a href="#topic+approx.hotelling.diff.test">approx.hotelling.diff.test()</a></code>
</p>

<hr>
<h2 id='gof'>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph
Model</h2><span id='topic+gof'></span><span id='topic+gof.default'></span><span id='topic+gof.ergm'></span><span id='topic+gof.formula'></span><span id='topic+print.gof'></span><span id='topic+plot.gof'></span>

<h3>Description</h3>

<p><code><a href="#topic+gof">gof</a></code> calculates <code class="reqn">p</code>-values for geodesic distance, degree,
and reachability summaries to diagnose the goodness-of-fit of exponential
family random graph models.  See <code><a href="#topic+ergm">ergm</a></code> for more information on
these models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object, ...)

## S3 method for class 'ergm'
gof(
  object,
  ...,
  coef = coefficients(object),
  GOF = NULL,
  constraints = object$constraints,
  control = control.gof.ergm(),
  verbose = FALSE
)

## S3 method for class 'formula'
gof(
  object,
  ...,
  coef = NULL,
  GOF = NULL,
  constraints = ~.,
  basis = eval_lhs.formula(object),
  control = NULL,
  unconditional = TRUE,
  verbose = FALSE
)

## S3 method for class 'gof'
print(x, ...)

## S3 method for class 'gof'
plot(
  x,
  ...,
  cex.axis = 0.7,
  plotlogodds = FALSE,
  main = "Goodness-of-fit diagnostics",
  normalize.reachability = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p>Either a formula or an <code><a href="#topic+ergm">ergm</a></code> object.
See documentation for <code><a href="#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="gof_+3A_coef">coef</code></td>
<td>
<p>When given either a formula or an object of class ergm,
<code>coef</code> are the parameters from which the sample is drawn. By default
set to a vector of 0.</p>
</td></tr>
<tr><td><code id="gof_+3A_gof">GOF</code></td>
<td>
<p>formula; an formula object, of the form <code>~ &lt;model terms&gt;</code>
specifying the statistics to use to diagnosis the goodness-of-fit of the
model.  They do not need to be in the model formula specified in
<code>formula</code>, and typically are not.  Currently supported terms are the
degree distribution (&ldquo;degree&rdquo; for undirected graphs,
&ldquo;idegree&rdquo; and/or &ldquo;odegree&rdquo; for directed graphs, and &ldquo;b1degree&rdquo; and &ldquo;b2degree&rdquo; for bipartite undirected graphs), geodesic
distances (&ldquo;distance&rdquo;), shared partner distributions
(&ldquo;espartners&rdquo; and &ldquo;dspartners&rdquo;), the triad census
(&ldquo;triadcensus&rdquo;), and the terms of the original model
(&ldquo;model&rdquo;). The default formula for undirected networks is <code>~
degree + espartners + distance + model</code>, and the default formula for
directed networks is <code>~ idegree + odegree + espartners + distance +
model</code>.  By default a &ldquo;model&rdquo; term is added to the formula.  It is a
very useful overall validity check and a reminder of the statistical
variation in the estimates of the mean value parameters.  To omit the
&ldquo;model&rdquo; term, add &ldquo;- model&rdquo; to the formula.</p>
</td></tr>
<tr><td><code id="gof_+3A_constraints">constraints</code></td>
<td>
<p>A one-sided formula specifying one or more constraints on
the support of the distribution of the networks being modeled. See the help
for similarly-named argument in <code><a href="#topic+ergm">ergm</a></code> for more information. For
<code>gof.formula</code>, defaults to unconstrained. For <code>gof.ergm</code>, defaults
to the constraints with which <code>object</code> was fitted.</p>
</td></tr>
<tr><td><code id="gof_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.gof.formula">control.gof.formula()</a></code> or <code><a href="#topic+control.gof.ergm">control.gof.ergm()</a></code>, which have different
defaults. Their documentation gives the the list of recognized
control parameters and their meaning. The more generic utility
<code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL) also provides argument completion
for the available control functions and limited argument name
checking.</p>
</td></tr>
<tr><td><code id="gof_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="gof_+3A_basis">basis</code></td>
<td>
<p>a value (usually a <code><a href="network.html#topic+network">network</a></code>) to override the LHS of the formula.</p>
</td></tr>
<tr><td><code id="gof_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code>, the simulation is
unconditional on the observed dyads.  if not <code>TRUE</code>, the simulation is
conditional on the observed dyads. This is primarily used internally when
the network has missing data and a conditional GoF is produced.</p>
</td></tr>
<tr><td><code id="gof_+3A_x">x</code></td>
<td>
<p>an object of class <code>gof</code> for printing or plotting.</p>
</td></tr>
<tr><td><code id="gof_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Character expansion of the axis labels relative to that for
the plot.</p>
</td></tr>
<tr><td><code id="gof_+3A_plotlogodds">plotlogodds</code></td>
<td>
<p>Plot the odds of a dyad having given characteristics
(e.g., reachability, minimum geodesic distance, shared partners). This is an
alternative to the probability of a dyad having the same property.</p>
</td></tr>
<tr><td><code id="gof_+3A_main">main</code></td>
<td>
<p>Title for the goodness-of-fit plots.</p>
</td></tr>
<tr><td><code id="gof_+3A_normalize.reachability">normalize.reachability</code></td>
<td>
<p>Should the reachability proportion be
normalized to make it more comparable with the other geodesic distance
proportions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sample of graphs is randomly drawn from the specified model.  The first
argument is typically the output of a call to <code><a href="#topic+ergm">ergm</a></code> and the
model used for that call is the one fit.
</p>
<p>For <code>GOF = ~model</code>, the model's observed sufficient statistics are
plotted as quantiles of the simulated sample. In a good fit, the observed
statistics should be near the sample median (0.5).
</p>
<p>By default, the sample consists of 100 simulated networks, but this sample
size (and many other settings) can be changed using the <code>control</code>
argument described above.
</p>


<h3>Value</h3>

<p><code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+gof.ergm">gof.ergm</a></code>, and
<code><a href="#topic+gof.formula">gof.formula</a></code> return an object of class <code>gof.ergm</code>, which inherits from class <code>gof</code>.  This
is a list of the tables of statistics and <code class="reqn">p</code>-values.  This is typically
plotted using <code><a href="#topic+plot.gof">plot.gof</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gof(ergm)</code>: Perform simulation to evaluate goodness-of-fit for
a specific <code><a href="#topic+ergm">ergm()</a></code> fit.
</p>
</li>
<li> <p><code>gof(formula)</code>: Perform simulation to evaluate goodness-of-fit for
a model configuration specified by a <code><a href="stats.html#topic+formula">formula</a></code>, coefficient,
constraints, and other settings.
</p>
</li></ul>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(gof)</code>: <code><a href="#topic+print.gof">print.gof</a></code> summaries the diagnostics such as the
degree distribution, geodesic distances, shared partner
distributions, and reachability for the goodness-of-fit of
exponential family random graph models.  See <code><a href="#topic+ergm">ergm</a></code> for
more information on these models. (<code>summary.gof</code> is a deprecated
alias that may be repurposed in the future.)
</p>
</li>
<li> <p><code>plot(gof)</code>: <code><a href="#topic+plot.gof">plot.gof</a></code> plots diagnostics such as the degree
distribution, geodesic distances, shared partner distributions, and
reachability for the goodness-of-fit of exponential family random graph
models.  See <code><a href="#topic+ergm">ergm</a></code> for more information on these models.
</p>
</li></ul>


<h3>Note</h3>

<p>For <code>gof.ergm</code> and <code>gof.formula</code>, default behavior depends on the
directedness of the network involved; if undirected then degree, espartners,
and distance are used as default properties to examine.  If the network in
question is directed, &ldquo;degree&rdquo; in the above is replaced by idegree
and odegree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm()</a></code>, <code><a href="network.html#topic+network">network()</a></code>, <code><a href="#topic+simulate.ergm">simulate.ergm()</a></code>, <code><a href="#topic+summary.ergm">summary.ergm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(florentine)
gest &lt;- ergm(flomarriage ~ edges + kstar(2))
gest
summary(gest)

# test the gof.ergm function
gofflo &lt;- gof(gest)
gofflo

# Plot all three on the same page
# with nice margins
par(mfrow=c(1,3))
par(oma=c(0.5,2,1,0.5))
plot(gofflo)

# And now the log-odds
plot(gofflo, plotlogodds=TRUE)

# Use the formula version of gof
gofflo2 &lt;-gof(flomarriage ~ edges + kstar(2), coef=c(-1.6339, 0.0049))
plot(gofflo2)


</code></pre>

<hr>
<h2 id='greaterthan-ergmTerm'>Number of dyads with values strictly greater than a threshold</h2><span id='topic+greaterthan-ergmTerm'></span><span id='topic+InitWtErgmTerm.greaterthan'></span>

<h3>Description</h3>

<p>Adds the number of statistics equal to the length of <code>threshold</code>
equaling to the number of dyads whose values exceed the
corresponding element of <code>threshold</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: greaterthan(threshold=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greaterthan-ergmTerm_+3A_threshold">threshold</code></td>
<td>
<p>a vector of numerical values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, valued</p>


<hr>
<h2 id='gwb1degree-ergmTerm'>Geometrically weighted degree distribution for the first mode in a bipartite network</h2><span id='topic+gwb1degree-ergmTerm'></span><span id='topic+InitErgmTerm.gwb1degree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the <code>decay</code> parameter, which should be non-negative,
for nodes in the first mode of a bipartite network. The first mode of a bipartite network
object is sometimes known as the &quot;actor&quot; mode.
</p>
<p>This term can only be used with undirected bipartite
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwb1degree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwb1degree-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the first mode degree frequencies; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwb1degree-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwb1degree-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="gwb1degree-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying degree terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwb1degree-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, curved, undirected, binary</p>


<hr>
<h2 id='gwb1dsp-ergmTerm'>Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition</h2><span id='topic+gwb1dsp-ergmTerm'></span><span id='topic+InitErgmTerm.gwb1dsp'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the geometrically
weighted dyadwise shared partner distribution for dyads in the first bipartition with decay parameter
<code>decay</code> parameter, which should be non-negative. This term can only be used with bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwb1dsp(decay=0, fixed=FALSE, cutoff=30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwb1dsp-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner counts; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwb1dsp-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwb1dsp-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying b1dsp terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, curved, undirected, binary</p>


<hr>
<h2 id='gwb2degree-ergmTerm'>Geometrically weighted degree distribution for the second mode in a bipartite network</h2><span id='topic+gwb2degree-ergmTerm'></span><span id='topic+InitErgmTerm.gwb2degree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the which should be non-negative,
for nodes in the
second mode of a bipartite network. The second mode of a bipartite network
object is sometimes known as the &quot;event&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwb2degree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwb2degree-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the second mode degree frequencies; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwb2degree-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwb2degree-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="gwb2degree-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying degree terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwb2degree-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, curved, undirected, binary</p>


<hr>
<h2 id='gwb2dsp-ergmTerm'>Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition</h2><span id='topic+gwb2dsp-ergmTerm'></span><span id='topic+InitErgmTerm.gwb2dsp'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the geometrically
weighted dyadwise shared partner distribution for dyads in the second bipartition with decay parameter
<code>decay</code> parameter, which should be non-negative. This term can only be used with bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwb2dsp(decay=0, fixed=FALSE, cutoff=30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwb2dsp-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner counts; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwb2dsp-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwb2dsp-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying b2dsp terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, curved, undirected, binary</p>


<hr>
<h2 id='gwdegree-ergmTerm'>Geometrically weighted degree distribution</h2><span id='topic+gwdegree-ergmTerm'></span><span id='topic+InitErgmTerm.gwdegree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the <code>decay</code> parameter, which should be non-negative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwdegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwdegree-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the degree frequencies; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwdegree-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwdegree-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="gwdegree-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying degree terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwdegree-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>curved, frequently-used, undirected, binary</p>


<hr>
<h2 id='gwdsp-ergmTerm'>Geometrically weighted dyadwise shared partner distribution</h2><span id='topic+gwdsp-ergmTerm'></span><span id='topic+InitErgmTerm.dgwdsp'></span><span id='topic+dgwdsp-ergmTerm'></span><span id='topic+InitErgmTerm.gwdsp'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the geometrically weighted dyadwise shared partner distribution with decay parameter <code>decay</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dgwdsp(decay, fixed=FALSE, cutoff=30, type="OTP")

# binary: gwdsp(decay, fixed=FALSE, cutoff=30, type="OTP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwdsp-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner or selected directed analogue count; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwdsp-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwdsp-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying DSP terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwdsp-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>
<p>The GWDSP statistic is equal to the sum of GWNSP plus GWESP.
</p>
<p>The <code>decay</code> parameter was called <code>alpha</code> prior to <code>ergm</code> 3.7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='gwesp-ergmTerm'>Geometrically weighted edgewise shared partner distribution</h2><span id='topic+gwesp-ergmTerm'></span><span id='topic+InitErgmTerm.dgwesp'></span><span id='topic+dgwesp-ergmTerm'></span><span id='topic+InitErgmTerm.gwesp'></span>

<h3>Description</h3>

<p>This term adds a statistic equal to the geometrically weighted edgewise (not dyadwise) shared partner distribution with decay parameter <code>decay</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dgwesp(decay, fixed=FALSE, cutoff=30, type="OTP")

# binary: gwesp(decay, fixed=FALSE, cutoff=30, type="OTP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwesp-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner or selected directed analogue count; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwesp-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwesp-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying ESP terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwesp-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>
<p>The <code>decay</code> parameter was called <code>alpha</code> prior to <code>ergm</code> 3.7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='gwidegree-ergmTerm'>Geometrically weighted in-degree distribution</h2><span id='topic+gwidegree-ergmTerm'></span><span id='topic+InitErgmTerm.gwidegree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model
equal to the weighted in-degree distribution with decay parameter
<code>decay</code> parameter, which should be non-negative. This
term can only be used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwidegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwidegree-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the indegree frequencies; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwidegree-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwidegree-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="gwidegree-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying degree terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwidegree-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>curved, directed, binary</p>


<hr>
<h2 id='gwnsp-ergmTerm'>Geometrically weighted non-edgewise shared partner distribution</h2><span id='topic+gwnsp-ergmTerm'></span><span id='topic+InitErgmTerm.dgwnsp'></span><span id='topic+dgwnsp-ergmTerm'></span><span id='topic+InitErgmTerm.gwnsp'></span>

<h3>Description</h3>

<p>This term is just like gwesp and gwdsp except it adds a statistic equal to the geometrically weighted nonedgewise (that is, over dyads that do not have an edge) shared partner distribution with decay parameter <code>decay</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dgwnsp(decay, fixed=FALSE, cutoff=30, type="OTP")

# binary: gwnsp(decay, fixed=FALSE, cutoff=30, type="OTP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwnsp-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner or selected directed analogue count; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwnsp-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwnsp-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying NSP terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwnsp-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>
<p>The <code>decay</code> parameter was called <code>alpha</code> prior to <code>ergm</code> 3.7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='gwodegree-ergmTerm'>Geometrically weighted out-degree distribution</h2><span id='topic+gwodegree-ergmTerm'></span><span id='topic+InitErgmTerm.gwodegree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model
equal to the weighted out-degree distribution with decay parameter
<code>decay</code> parameter, which should be non-negative. This
term can only be used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwodegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwodegree-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the outdegree frequencies; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="gwodegree-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="gwodegree-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="gwodegree-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying degree terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="gwodegree-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>curved, directed, binary</p>


<hr>
<h2 id='hamming-ergmConstraint'>Preserve the hamming distance to the given network (BROKEN: Do NOT Use)</h2><span id='topic+hamming-ergmConstraint'></span><span id='topic+InitErgmConstraint.hamming'></span>

<h3>Description</h3>

<p>This constraint is currently broken. Do not use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># hamming
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected</p>


<hr>
<h2 id='hamming-ergmTerm'>Hamming distance</h2><span id='topic+hamming-ergmTerm'></span><span id='topic+InitErgmTerm.hamming'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model equal to the weighted or
unweighted Hamming distance of the network from the network specified by
<code>x</code> . Unweighted Hamming distance is defined as the total
number of pairs <code class="reqn">(i,j)</code> (ordered or unordered, depending on whether the
network is directed or undirected) on which the two networks differ. If the
optional argument <code>cov</code> is specified, then the weighted Hamming
distance is computed instead, where each pair <code class="reqn">(i,j)</code> contributes a
pre-specified weight toward the distance when the two networks differ on
that pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: hamming(x, cov, attrname=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hamming-ergmTerm_+3A_x">x</code></td>
<td>
<p>defaults to be the observed
network, i.e., the network on the left side of the <code class="reqn">\sim</code> in the formula
that defines the ERGM.</p>
</td></tr>
<tr><td><code id="hamming-ergmTerm_+3A_cov">cov</code></td>
<td>
<p>either a matrix of edgewise weights or a network</p>
</td></tr>
<tr><td><code id="hamming-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>option argument that provides the name of the edge attribute
to use for weight values when a network is specified in <code>cov</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, binary</p>


<hr>
<h2 id='HammingConstantEdges-ergmProposal'>TODO</h2><span id='topic+HammingConstantEdges-ergmProposal'></span><span id='topic+InitErgmProposal.HammingConstantEdges'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='HammingTNT-ergmProposal'>TODO</h2><span id='topic+HammingTNT-ergmProposal'></span><span id='topic+InitErgmProposal.HammingTNT'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='idegrange-ergmTerm'>In-degree range</h2><span id='topic+idegrange-ergmTerm'></span><span id='topic+InitErgmTerm.idegrange'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element of <code>from</code> (or <code>to</code> ); the <code class="reqn">i</code> th
such statistic equals the number of nodes in the network of in-degree
greater than or equal to <code>from[i]</code> but strictly less than <code>to[i]</code> , i.e. with
in-edge count in semiopen interval <code style="white-space: pre;">&#8288;[from,to)&#8288;</code> .
</p>
<p>This term can only be used with directed networks; for undirected
networks (bipartite and not)
see <code>degrange</code> . For degrees of specific modes of bipartite
networks, see <code>b1degrange</code> and <code>b2degrange</code> . For
in-degrees, see <code>idegrange</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: idegrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idegrange-ergmTerm_+3A_from">from</code>, <code id="idegrange-ergmTerm_+3A_to">to</code></td>
<td>
<p>vectors of distinct integers. If one of the vectors have length 1, it is recycled to the length of the other. Otherwise, it must have the same length.</p>
</td></tr>
<tr><td><code id="idegrange-ergmTerm_+3A_by">by</code>, <code id="idegrange-ergmTerm_+3A_levels">levels</code>, <code id="idegrange-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, binary</p>


<hr>
<h2 id='idegree-ergmTerm'>In-degree</h2><span id='topic+idegree-ergmTerm'></span><span id='topic+InitErgmTerm.idegree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to
the model for each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals
the number of nodes in the network of in-degree <code>d[i]</code> , i.e. the number
of nodes with exactly <code>d[i]</code> in-edges.
This term can only be used with directed networks; for undirected networks
see <code>degree</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: idegree(d, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idegree-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="idegree-ergmTerm_+3A_by">by</code>, <code id="idegree-ergmTerm_+3A_levels">levels</code>, <code id="idegree-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, frequently-used, binary</p>


<hr>
<h2 id='idegree1.5-ergmTerm'>In-degree to the 3/2 power</h2><span id='topic+idegree1.5-ergmTerm'></span><span id='topic+InitErgmTerm.idegree1.5'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equaling the sum
over the actors of each actor's indegree taken to the 3/2 power
(or, equivalently, multiplied by its square root). This term is
analogous to the term of Snijders et al. (2010), equation (12). This
term can only be used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: idegree1.5
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='idegreedist-ergmConstraint'>Preserve the indegree distribution</h2><span id='topic+idegreedist-ergmConstraint'></span><span id='topic+InitErgmConstraint.idegreedist'></span>

<h3>Description</h3>

<p>Preserve the indegree distribution of the given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># idegreedist
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed</p>


<hr>
<h2 id='idegrees-ergmConstraint'>Preserve indegree for directed networks</h2><span id='topic+idegrees-ergmConstraint'></span><span id='topic+InitErgmConstraint.idegrees'></span>

<h3>Description</h3>

<p>For directed networks, preserve the indegree of each vertex of the given
network, while allowing outdegree to vary
</p>


<h3>Usage</h3>

<pre><code class='language-R'># idegrees
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed</p>


<hr>
<h2 id='ininterval-ergmTerm'>Number of dyads whose values are in an interval</h2><span id='topic+ininterval-ergmTerm'></span><span id='topic+InitWtErgmTerm.ininterval'></span>

<h3>Description</h3>

<p>Adds one statistic equaling to the number of dyads whose values
are between <code>lower</code> and <code>upper</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: ininterval(lower=-Inf, upper=+Inf, open=c(TRUE,TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ininterval-ergmTerm_+3A_lower">lower</code></td>
<td>
<p>defaults to -Inf</p>
</td></tr>
<tr><td><code id="ininterval-ergmTerm_+3A_upper">upper</code></td>
<td>
<p>defaults to +Inf</p>
</td></tr>
<tr><td><code id="ininterval-ergmTerm_+3A_open">open</code></td>
<td>
<p>a <code>logical</code> vector of length 2 that controls whether
the interval is open (exclusive) on the lower and on the upper
end, respectively. <code>open</code> can also be specified as one of
<code>"[]"</code> , <code>"(]"</code> , <code>"[)"</code> , and <code>"()"</code> .</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, valued</p>


<hr>
<h2 id='intransitive-ergmTerm'>Intransitive triads</h2><span id='topic+intransitive-ergmTerm'></span><span id='topic+InitErgmTerm.intransitive'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model, equal to the number of triads in
the network that are intransitive. The intransitive triads are those of type
<code style="white-space: pre;">&#8288;111D&#8288;</code> , <code>201</code> , <code style="white-space: pre;">&#8288;111U&#8288;</code> , <code style="white-space: pre;">&#8288;021C&#8288;</code> , or <code style="white-space: pre;">&#8288;030C&#8288;</code> in the
categorization of Davis and Leinhardt (1972). For details on the 16 possible
triad types, see <code>triad.classify</code> in the
<a href="https://CRAN.R-project.org/package=sna"><span class="pkg">sna</span></a> package. Note the distinction from the <code>ctriple</code>
term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: intransitive
</code></pre>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, binary</p>


<hr>
<h2 id='is.curved'>Testing for curved exponential family</h2><span id='topic+is.curved'></span><span id='topic+is.curved.NULL'></span><span id='topic+is.curved.formula'></span><span id='topic+is.curved.ergm'></span>

<h3>Description</h3>

<p>These functions test whether an ERGM fit, formula, or some other
object represents a curved exponential family.
</p>
<p>The method for <code>NULL</code> always returns <code>FALSE</code> by
convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.curved(object, ...)

## S3 method for class ''NULL''
is.curved(object, ...)

## S3 method for class 'formula'
is.curved(object, response = NULL, basis = NULL, ...)

## S3 method for class 'ergm'
is.curved(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.curved_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ergm">ergm</a></code> object or an ERGM formula.</p>
</td></tr>
<tr><td><code id="is.curved_+3A_...">...</code></td>
<td>
<p>Arguments passed on to lower-level functions.</p>
</td></tr>
<tr><td><code id="is.curved_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="is.curved_+3A_basis">basis</code></td>
<td>
<p>See <code><a href="#topic+ergm">ergm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Curvature is checked by testing if all model parameters are canonical.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the object represents a
curved exponential family; <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.dyad.independent'>Testing for dyad-independence</h2><span id='topic+is.dyad.independent'></span><span id='topic+is.dyad.independent.NULL'></span><span id='topic+is.dyad.independent.formula'></span><span id='topic+is.dyad.independent.ergm_conlist'></span><span id='topic+is.dyad.independent.ergm'></span>

<h3>Description</h3>

<p>These functions test whether an ERGM fit, a formula, or some other
object represents a dyad-independent model.
</p>
<p>The method for <code>NULL</code> always returns <code>TRUE</code> by
convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dyad.independent(object, ...)

## S3 method for class ''NULL''
is.dyad.independent(object, ...)

## S3 method for class 'formula'
is.dyad.independent(object, response = NULL, basis = NULL, ...)

## S3 method for class 'ergm_conlist'
is.dyad.independent(object, object.obs = NULL, ...)

## S3 method for class 'ergm'
is.dyad.independent(object, how = c("overall", "terms", "space"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dyad.independent_+3A_object">object</code></td>
<td>
<p>The object to be tested for dyadic independence.</p>
</td></tr>
<tr><td><code id="is.dyad.independent_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
<tr><td><code id="is.dyad.independent_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="is.dyad.independent_+3A_basis">basis</code></td>
<td>
<p>See <code><a href="#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="is.dyad.independent_+3A_object.obs">object.obs</code></td>
<td>
<p>For the <code><a href="#topic+ergm_conlist">ergm_conlist</a></code> method, the observed data constraint.</p>
</td></tr>
<tr><td><code id="is.dyad.independent_+3A_how">how</code></td>
<td>
<p>one of <code>"overall"</code> (the default), <code>"terms"</code>, or
&quot;<code>space</code>&quot;, to specify which aspect of the ERGM is to be tested
for dyadic independence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dyad independence is determined by checking if all of the
constituent parts of the object (formula, ergm terms, constraints,
etc.) are flagged as dyad-independent.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the model implied by the object is
dyad-independent; <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.valued'>Function to check whether an ERGM fit or some aspect of it is valued</h2><span id='topic+is.valued'></span><span id='topic+is.valued.ergm_state'></span><span id='topic+is.valued.edgelist'></span><span id='topic+is.valued.ergm'></span><span id='topic+is.valued.network'></span>

<h3>Description</h3>

<p>Function to check whether an ERGM fit or some aspect of it is valued
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.valued(object, ...)

## S3 method for class 'ergm_state'
is.valued(object, ...)

## S3 method for class 'edgelist'
is.valued(object, ...)

## S3 method for class 'ergm'
is.valued(object, ...)

## S3 method for class 'network'
is.valued(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.valued_+3A_object">object</code></td>
<td>
<p>the object to be tested.</p>
</td></tr>
<tr><td><code id="is.valued_+3A_...">...</code></td>
<td>
<p>additional arguments for methods, currently unused.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>is.valued(ergm_state)</code>: a method for <code><a href="#topic+ergm_state">ergm_state</a></code> objects.
</p>
</li>
<li> <p><code>is.valued(edgelist)</code>: a method for <code><a href="network.html#topic+edgelist">edgelist</a></code> objects.
</p>
</li>
<li> <p><code>is.valued(ergm)</code>: a method for <code><a href="#topic+ergm">ergm</a></code> objects.
</p>
</li>
<li> <p><code>is.valued(network)</code>: a method for <code><a href="network.html#topic+network">network</a></code> objects that tests whether the network has been instrumented with a valued <code><a href="#topic++25ergmlhs+25">%ergmlhs%</a></code> <code>"response"</code> specification, typically by <code><a href="#topic+ergm_preprocess_response">ergm_preprocess_response()</a></code>. Note that it is <em>not</em> a test for whether a network has edge attributes. This method is primarily for internal use.
</p>
</li></ul>

<hr>
<h2 id='isolatededges-ergmTerm'>Isolated edges</h2><span id='topic+isolatededges-ergmTerm'></span><span id='topic+InitErgmTerm.isolatededges'></span>

<h3>Description</h3>

<p>This term adds one statistic to the
model equal to the number of isolated edges in the network, i.e., the number
of edges each of whose endpoints has degree 1. This term can only be used
with undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: isolatededges
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, undirected, binary</p>


<hr>
<h2 id='isolates-ergmTerm'>Isolates</h2><span id='topic+isolates-ergmTerm'></span><span id='topic+InitErgmTerm.isolates'></span>

<h3>Description</h3>

<p>This term adds one statistic to the
model equal to the number of isolates in the network. For an undirected
network, an isolate is defined to be any node with degree zero. For a
directed network, an isolate is any node with both in-degree and out-degree
equal to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: isolates
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, frequently-used, undirected, binary</p>


<hr>
<h2 id='istar-ergmTerm'>In-stars</h2><span id='topic+istar-ergmTerm'></span><span id='topic+InitErgmTerm.istar'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the
model for each element in <code>k</code> . The <code class="reqn">i</code> th such statistic counts the
number of distinct <code>k[i]</code> -instars in the network, where a
<code class="reqn">k</code> -instar is defined to be a node <code class="reqn">N</code> and a set of <code class="reqn">k</code>
different nodes <code class="reqn">\{O_1, \dots, O_k\}</code> such that the ties
<code class="reqn">(O_j{\rightarrow}N)</code> exist for <code class="reqn">j=1, \dots, k</code> .
This term can only be used for directed
networks; for undirected networks see <code>kstar</code> . Note that
<code>istar(1)</code> is equal to both <code>ostar(1)</code> and <code>edges</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: istar(k, attr=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="istar-ergmTerm_+3A_k">k</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="istar-ergmTerm_+3A_attr">attr</code>, <code id="istar-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a vertex attribute specification; if <code>attr</code> is
specified, then the count is over the instances where all nodes
involved have the same value of the attribute. <code>levels</code> specified
which values of <code>attr</code> are included in the count. (See Specifying
Vertex attributes and Levels
(<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, binary</p>


<hr>
<h2 id='kapferer'>Kapferer's tailor shop data</h2><span id='topic+kapferer'></span><span id='topic+kapferer2'></span><span id='topic+tailor'></span>

<h3>Description</h3>

<p>This well-known social network dataset, collected by Bruce Kapferer in
Zambia from June 1965 to August 1965, involves interactions among workers in
a tailor shop as observed by Kapferer himself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kapferer)
</code></pre>


<h3>Format</h3>

<p>Two <code>network</code> objects, <code>kapferer</code> and <code>kapferer2</code>.
The <code>kapferer</code> dataset contains only the 39 individuals who were
present at both data-collection time periods.  However, these data only
reflect data collected during the first period.  The individuals' names are
included as a nodal covariate called <code>names</code>.
</p>


<h3>Details</h3>

<p>An interaction is
defined by Kapferer as &quot;continuous uninterrupted social activity involving
the participation of at least two persons&quot;; only transactions that were
relatively frequent are recorded. All of the interactions in this particular
dataset are &quot;sociational&quot;, as opposed to &quot;instrumental&quot;.  Kapferer explains
the difference (p. 164) as follows:
</p>
<p>&quot;I have classed as transactions which were sociational in content those
where the activity was markedly convivial such as general conversation, the
sharing of gossip and the enjoyment of a drink together.  Examples of
instrumental transactions are the lending or giving of money, assistance at
times of personal crisis and help at work.&quot;
</p>
<p>Kapferer also observed and recorded instrumental transactions, many of which
are unilateral (directed) rather than reciprocal (undirected), though those
transactions are not recorded here.  In addition, there was a second period
of data collection, from September 1965 to January 1966, but these data are
also not recorded here.  All data are given in Kapferer's 1972 book on pp.
176-179.
</p>
<p>During the first time period, there were 43 individuals working in this
particular tailor shop; however, the better-known dataset includes only
those 39 individuals who were present during both time collection periods.
(Missing are the workers named Lenard, Peter, Lazarus, and Laurent.) Thus,
we give two separate network datasets here: <code>kapferer</code> is the
well-known 39-individual dataset, whereas <code>kapferer2</code> is the full
43-individual dataset.
</p>


<h3>Source</h3>

<p>Original source: Kapferer, Bruce (1972), Strategy and Transaction in
an African Factory, Manchester University Press.
</p>

<hr>
<h2 id='kstar-ergmTerm'><code class="reqn">k</code>-stars</h2><span id='topic+kstar-ergmTerm'></span><span id='topic+InitErgmTerm.kstar'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element in <code>k</code> . The <code class="reqn">i</code> th
such statistic counts the number of distinct <code>k[i]</code> -stars in the
network, where a <code class="reqn">k</code> -star is defined to be a node <code class="reqn">N</code> and a set of
<code class="reqn">k</code> different nodes <code class="reqn">\{O_1, \dots, O_k\}</code> such that the ties
<code class="reqn">\{N, O_i\}</code> exist for <code class="reqn">i=1, \dots, k</code> .
This term can only be used for undirected networks; for directed
networks, see <code>istar</code> , <code>ostar</code> , <code>twopath</code> and <code>m2star</code> .
Note that <code>kstar(1)</code> is equal to <code>edges</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: kstar(k, attr=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kstar-ergmTerm_+3A_k">k</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="kstar-ergmTerm_+3A_attr">attr</code>, <code id="kstar-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a vertex attribute specification; if <code>attr</code> is
specified, then the count is over the instances where all nodes
involved have the same value of the attribute. <code>levels</code> specified
which values of <code>attr</code> are included in the count. (See Specifying
Vertex attributes and Levels
(<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, undirected, binary</p>


<hr>
<h2 id='Label-ergmTerm'>Modify terms' coefficient names</h2><span id='topic+Label-ergmTerm'></span><span id='topic+InitErgmTerm.Label'></span><span id='topic+InitWtErgmTerm.Label'></span>

<h3>Description</h3>

<p>This operator evaluates <code>formula</code> without modification, but modifies its coefficient and/or parameter names based on <code>label</code> and <code>pos</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Label(formula, label, pos)

# valued: Label(formula, label, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Label-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Label-ergmTerm_+3A_label">label</code></td>
<td>
<p>either a character vector specifying the label for the terms or a function through which term names are mapped (or a <code>as_mapper</code> -style formula).</p>
</td></tr>
<tr><td><code id="Label-ergmTerm_+3A_pos">pos</code></td>
<td>
<p>controls how <code>label</code> modifies the term names: one of <code>"prepend"</code> , <code>"replace"</code> , <code>"append"</code> , or <code>"("</code> , with the latter wrapping the term names in parentheses like a function call with name specified by <code>label</code> .</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary, valued</p>


<hr>
<h2 id='localtriangle-ergmTerm'>Triangles within neighborhoods</h2><span id='topic+localtriangle-ergmTerm'></span><span id='topic+InitErgmTerm.localtriangle'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model equal to the number of triangles
in the network between nodes &quot;close to&quot; each other. For an undirected
network, a local triangle is defined to be any set of three edges between
nodal pairs <code class="reqn">\{(i,j), (j,k), (k,i)\}</code> that are in the same neighborhood.
For a directed network, a triangle is defined as any set of three edges
<code class="reqn">(i{\rightarrow}j), (j{\rightarrow}k)</code> and either
<code class="reqn">(k{\rightarrow}i)</code> or <code class="reqn">(k{\leftarrow}i)</code> where again all nodes are
within the same neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: localtriangle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localtriangle-ergmTerm_+3A_x">x</code></td>
<td>
<p>an undirected
network or an symmetric adjacency matrix that specifies whether the two nodes
are in the same neighborhood. Note that <code>triangle</code> , with or without an argument, is a
special case of <code>localtriangle</code> .</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical dyadic attribute, directed, triad-related, undirected, binary</p>


<hr>
<h2 id='Log-ergmTerm'>Take a natural logarithm of a network's statistic</h2><span id='topic+Log-ergmTerm'></span><span id='topic+InitErgmTerm.Log'></span><span id='topic+InitWtErgmTerm.Log'></span>

<h3>Description</h3>

<p>Evaluate the terms specified in <code>formula</code> and takes a natural (base <code class="reqn">e</code> ) logarithm of them. Since an ERGM statistic must be finite, <code>log0</code> specifies the value to be substituted for <code>log(0)</code> . The default value seems reasonable for most purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Log(formula, log0=-1/sqrt(.Machine$double.eps))

# valued: Log(formula, log0=-1/sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Log-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Log-ergmTerm_+3A_log0">log0</code></td>
<td>
<p>the value to be substituted for <code>log(0)</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary, valued</p>


<hr>
<h2 id='logLik.ergm'>A <code><a href="stats.html#topic+logLik">logLik</a></code> method for <code><a href="#topic+ergm">ergm</a></code> fits.</h2><span id='topic+logLik.ergm'></span><span id='topic+deviance.ergm'></span><span id='topic+AIC.ergm'></span><span id='topic+BIC.ergm'></span>

<h3>Description</h3>

<p>A function to return the log-likelihood associated with an
<code><a href="#topic+ergm.object">ergm</a></code> fit, evaluating it if
necessary. If the log-likelihood was not computed for
<code>object</code>, produces an error unless <code>eval.loglik=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm'
logLik(
  object,
  add = FALSE,
  force.reeval = FALSE,
  eval.loglik = add || force.reeval,
  control = control.logLik.ergm(),
  ...,
  verbose = FALSE
)

## S3 method for class 'ergm'
deviance(object, ...)

## S3 method for class 'ergm'
AIC(object, ..., k = 2)

## S3 method for class 'ergm'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.ergm_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ergm.object">ergm</a></code> fit, returned by
<code><a href="#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.ergm_+3A_add">add</code></td>
<td>
<p>Logical: If <code>TRUE</code>, instead of returning the
log-likelihood, return <code>object</code> with log-likelihood value
(and the null likelihood value) set.</p>
</td></tr>
<tr><td><code id="logLik.ergm_+3A_force.reeval">force.reeval</code></td>
<td>
<p>Logical: If <code>TRUE</code>, reestimate the
log-likelihood even if <code>object</code> already has an estiamte.</p>
</td></tr>
<tr><td><code id="logLik.ergm_+3A_eval.loglik">eval.loglik</code></td>
<td>
<p>Logical: If <code>TRUE</code>, evaluate the log-likelihood
if not set on <code>object</code>.</p>
</td></tr>
<tr><td><code id="logLik.ergm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.logLik.ergm">control.logLik.ergm()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
<tr><td><code id="logLik.ergm_+3A_...">...</code></td>
<td>
<p>Other arguments to the likelihood functions.</p>
</td></tr>
<tr><td><code id="logLik.ergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="logLik.ergm_+3A_k">k</code></td>
<td>
<p>see help for <code><a href="stats.html#topic+AIC">AIC()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the output of <code>logLik.ergm</code> depends on
<code>add</code>: <code>add=FALSE</code> (the default), a
<code><a href="stats.html#topic+logLik">logLik</a></code> object. If <code>add=TRUE</code> (the default), an
<code><a href="#topic+ergm.object">ergm</a></code> object with the log-likelihood
set.
</p>
<p>As of version 3.1, all likelihoods for which <code>logLikNull</code> is
not implemented are computed relative to the reference
measure. (I.e., a null model, with no terms, is defined to have
likelihood of 0, and all other models are defined relative to
that.)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>deviance(ergm)</code>: A <code><a href="stats.html#topic+deviance">deviance()</a></code> method.
</p>
</li>
<li> <p><code>AIC(ergm)</code>: An <code><a href="stats.html#topic+AIC">AIC()</a></code> method.
</p>
</li>
<li> <p><code>BIC(ergm)</code>: A <code><a href="stats.html#topic+BIC">BIC()</a></code> method.
</p>
</li></ul>


<h3>References</h3>

<p>Hunter, D. R. and Handcock, M. S. (2006)
<em>Inference in curved exponential family models for
networks</em>, Journal of Computational and Graphical Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="#topic+logLikNull">logLikNull</a></code>, <code><a href="#topic+ergm.bridge.llr">ergm.bridge.llr</a></code>,
<code><a href="#topic+ergm.bridge.dindstart.llk">ergm.bridge.dindstart.llk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See help(ergm) for a description of this model. The likelihood will
# not be evaluated.
data(florentine)
## Not run: 
# The default maximum number of iterations is currently 20. We'll only
# use 2 here for speed's sake.
gest &lt;- ergm(flomarriage ~ kstar(1:2) + absdiff("wealth") + triangle, eval.loglik=FALSE)

gest &lt;- ergm(flomarriage ~ kstar(1:2) + absdiff("wealth") + triangle, eval.loglik=FALSE,
             control=control.ergm(MCMLE.maxit=2))
# Log-likelihood is not evaluated, so no deviance, AIC, or BIC:
summary(gest)
# Evaluate the log-likelihood and attach it to the object.

# The default number of bridges is currently 20. We'll only use 3 here
# for speed's sake.
gest.logLik &lt;- logLik(gest, add=TRUE)

gest.logLik &lt;- logLik(gest, add=TRUE, control=control.logLik.ergm(bridge.nsteps=3))
# Deviances, AIC, and BIC are now shown:
summary(gest.logLik)
# Null model likelihood can also be evaluated, but not for all constraints:
logLikNull(gest) # == network.dyadcount(flomarriage)*log(1/2)

## End(Not run)

</code></pre>

<hr>
<h2 id='logLikNull'>Calculate the null model likelihood</h2><span id='topic+logLikNull'></span><span id='topic+logLikNull.ergm'></span>

<h3>Description</h3>

<p>Calculate the null model likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikNull(object, ...)

## S3 method for class 'ergm'
logLikNull(object, control = control.logLik.ergm(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikNull_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="logLikNull_+3A_...">...</code></td>
<td>
<p>further arguments to lower-level functions.
</p>
<p><code>logLikNull</code> computes, when possible the log-probability of
the data under the null model (reference distribution).</p>
</td></tr>
<tr><td><code id="logLikNull_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.logLik.ergm">control.logLik.ergm()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logLikNull</code> returns an object of type <code><a href="stats.html#topic+logLik">logLik</a></code> if it is
able to compute the null model probability, and <code>NA</code> otherwise.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>logLikNull(ergm)</code>: A method for <code><a href="#topic+ergm">ergm</a></code> fits; currently only
implemented for binary ERGMs with dyad-independent sample-space
constraints.
</p>
</li></ul>

<hr>
<h2 id='m2star-ergmTerm'>Mixed 2-stars, a.k.a 2-paths</h2><span id='topic+m2star-ergmTerm'></span><span id='topic+InitErgmTerm.m2star'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model, equal to the number of mixed
2-stars in the network, where a mixed 2-star is a pair of distinct edges
<code class="reqn">(i{\rightarrow}j), (j{\rightarrow}k)</code> . A mixed 2-star is
sometimes called a 2-path because it is a directed path of length 2 from
<code class="reqn">i</code> to <code class="reqn">k</code> via <code class="reqn">j</code> . However, in the case of a 2-path the focus
is usually on the endpoints <code class="reqn">i</code> and <code class="reqn">k</code> , whereas for a mixed 2-star
the focus is usually on the midpoint <code class="reqn">j</code> . This term can only be used
with directed networks; for undirected networks see <code>kstar(2)</code> . See
also <code>twopath</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: m2star
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='mcmc.diagnostics'>Conduct MCMC diagnostics on a model fit</h2><span id='topic+mcmc.diagnostics'></span><span id='topic+mcmc.diagnostics.default'></span><span id='topic+mcmc.diagnostics.ergm'></span>

<h3>Description</h3>

<p>This function prints diagnistic information and creates simple diagnostic
plots for MCMC sampled statistics produced from a fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.diagnostics(object, ...)

## S3 method for class 'ergm'
mcmc.diagnostics(
  object,
  center = TRUE,
  esteq = TRUE,
  vars.per.page = 3,
  which = c("plots", "texts", "summary", "autocorrelation", "crosscorrelation", "burnin"),
  compact = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.diagnostics_+3A_object">object</code></td>
<td>
<p>A model fit object to be diagnosed.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to plotting functions.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics_+3A_center">center</code></td>
<td>
<p>Logical: If TRUE, center the samples on the observed
statistics.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics_+3A_esteq">esteq</code></td>
<td>
<p>Logical: If TRUE, for statistics corresponding to
curved ERGM terms, summarize the curved statistics by their
negated estimating function values (evaluated at the MLE of any curved
parameters) (i.e., <code class="reqn">\eta'_{I}(\hat{\theta})\cdot (g_{I}(Y)-g_{I}(y))</code>
for <code class="reqn">I</code> being indices of the canonical parameters in
question), rather than the canonical (sufficient) vectors of the
curved statistics relative to the observed (<code class="reqn">g_{I}(Y)-g_{I}(y)</code>).</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics_+3A_vars.per.page">vars.per.page</code></td>
<td>
<p>Number of rows (one variable per row) per
plotting page.  Ignored if <code>latticeExtra</code> package is not
installed.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics_+3A_which">which</code></td>
<td>
<p>A character vector specifying which diagnostics to
plot and/or print. Defaults to all of the below if meaningful:
</p>

<dl>
<dt><code>"plots"</code></dt><dd><p>Traceplots and density plots of sample values for all statistic or estimating function elements.</p>
</dd>
<dt><code>"texts"</code></dt><dd><p>Shorthand for the following text diagnostics.</p>
</dd>
<dt><code>"summary"</code></dt><dd><p>Summary of network statistic or estimating function elements as produced by <code><a href="coda.html#topic+summary.mcmc">coda::summary.mcmc.list()</a></code>.</p>
</dd>
<dt><code>"autocorrelation"</code></dt><dd><p>Autocorrelation of each of the network statistic or estimating function elements.</p>
</dd>
<dt><code>"crosscorrelation"</code></dt><dd><p>Cross-correlations between each pair of the network statistic or estimating function elements.</p>
</dd>
<dt><code>"burnin"</code></dt><dd><p>Burn-in diagnostics, in particular, the Geweke test.</p>
</dd>
</dl>
<p> Partial matching is supported. (E.g., <code>which=c("auto","cross")</code>
will print autocorrelation and cross-correlations.)</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics_+3A_compact">compact</code></td>
<td>
<p>Numeric: For diagnostics that print variables in
columns (e.g. correlations, hypothesis test p-values), try to
abbreviate variable names to this many characters and round the
numbers to <code>compact - 2</code> digits after the decimal point; 0 or
<code>FALSE</code> for no abbreviation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pair of plots are produced for each statistic:a trace of the sampled
output statistic values on the left and density estimate for each variable
in the MCMC chain on the right.  Diagnostics printed to the console include
correlations and convergence diagnostics.
</p>
<p>For <code><a href="#topic+ergm">ergm()</a></code> specifically, recent changes in the
estimation algorithm mean that these plots can no longer be used
to ensure that the mean statistics from the model match the
observed network statistics. For that functionality, please use
the GOF command: <code>gof(object, GOF=~model)</code>.
</p>
<p>In fact, an ergm output <code>object</code> contains the matrix of
statistics from the MCMC run as component <code>$sample</code>.  This
matrix is actually an object of class <code>mcmc</code> and can be used
directly in the <code>coda</code> package to assess MCMC
convergence. <em>Hence all MCMC diagnostic methods available in
<code>coda</code> are available directly.</em> See the examples and
<a href="https://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-winbugs/coda-readme/">https://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-winbugs/coda-readme/</a>.
</p>
<p>More information can be found by looking at the documentation of
<code><a href="#topic+ergm">ergm</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>mcmc.diagnostics(ergm)</code>: 
</p>
</li></ul>


<h3>References</h3>

<p>Raftery, A.E. and Lewis, S.M. (1995).  The number of iterations, convergence
diagnostics and generic Metropolis algorithms.  In Practical Markov Chain
Monte Carlo (W.R. Gilks, D.J. Spiegelhalter and S. Richardson, eds.).
London, U.K.: Chapman and Hall.
</p>
<p>This function is based on the <code>coda</code> package It is based on the the R
function <code>raftery.diag</code> in <code>coda</code>.  <code>raftery.diag</code>, in turn,
is based on the FORTRAN program <code>gibbsit</code> written by Steven Lewis which
is available from the Statlib archive.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm</a></code>, <code>network</code> package, <code>coda</code> package,
<code><a href="#topic+summary.ergm">summary.ergm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#
data(florentine)
#
# test the mcmc.diagnostics function
#
gest &lt;- ergm(flomarriage ~ edges + kstar(2))
summary(gest)

#
# Plot the probabilities first
#
mcmc.diagnostics(gest)
#
# Use coda directly
#
library(coda)
#
plot(gest$sample, ask=FALSE)
#
# A full range of diagnostics is available
# using codamenu()
#

## End(Not run)

</code></pre>

<hr>
<h2 id='meandeg-ergmTerm'>Mean vertex degree</h2><span id='topic+meandeg-ergmTerm'></span><span id='topic+InitErgmTerm.meandeg'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the
average degree of a node. Note that this term is a constant multiple of
both <code>edges</code> and <code>density</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: meandeg
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, binary</p>


<hr>
<h2 id='mm-ergmTerm'>Mixing matrix cells and margins</h2><span id='topic+mm-ergmTerm'></span><span id='topic+InitErgmTerm.mm'></span><span id='topic+InitWtErgmTerm.mm'></span>

<h3>Description</h3>

<p><code>attrs</code> is the rows of the mixing matrix and whose RHS gives
that for its columns. A one-sided formula (e.g.,
<code>~A</code> ) is symmetrized (e.g., <code>A~A</code> ). A two-sided formula with a dot on one side
calculates the margins of the mixing matrix, analogously to <code>nodefactor</code> , with
<code>A~.</code> calculating the row/sender/b1 margins and <code>.~A</code>
calculating the column/receiver/b2 margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: mm(attrs, levels=NULL, levels2=-1)

# valued: mm(attrs, levels=NULL, levels2=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mm-ergmTerm_+3A_attrs">attrs</code></td>
<td>
<p>a two-sided formula whose LHS gives the attribute or
attribute function (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.) for the rows of the mixing matrix and whose RHS gives
for its columns. A one-sided formula (e.g., <code>~A</code>) is symmetrized (e.g., <code>A~A</code>)</p>
</td></tr>
<tr><td><code id="mm-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>subset of rows and columns to be used. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="mm-ergmTerm_+3A_levels2">levels2</code></td>
<td>
<p>which specific cells of the matrix to include</p>
</td></tr>
<tr><td><code id="mm-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, dyad-independent, frequently-used, undirected, binary, valued</p>


<hr>
<h2 id='molecule'>Synthetic network with 20 nodes and 28 edges</h2><span id='topic+molecule'></span>

<h3>Description</h3>

<p>This is a synthetic network of 20 nodes that is used as an example within
the <code><a href="#topic+ergm">ergm</a></code> documentation. It has an interesting elongated shape
</p>

<ul>
<li><p> reminencent of a chemical molecule.  It is stored as a
<code><a href="network.html#topic+network">network</a></code> object.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(molecule)
</code></pre>


<h3>See Also</h3>

<p>florentine, sampson, network, plot.network, ergm
</p>

<hr>
<h2 id='mutual-ergmTerm'>Mutuality</h2><span id='topic+mutual-ergmTerm'></span><span id='topic+InitErgmTerm.mutual'></span><span id='topic+InitWtErgmTerm.mutual'></span>

<h3>Description</h3>

<p>In binary ERGMs, equal to the number of
pairs of actors <code class="reqn">i</code> and <code class="reqn">j</code> for which <code class="reqn">(i{\rightarrow}j)</code>
and <code class="reqn">(j{\rightarrow}i)</code> both exist. For valued ERGMs, equal to <code class="reqn">\sum_{i&lt;j} m(y_{i,j},y_{j,i})</code> ,
where <code class="reqn">m</code> is determined by <code>form</code> argument: <code>"min"</code>
for <code class="reqn">\min(y_{i,j},y_{j,i})</code> , <code>"nabsdiff"</code> for
<code class="reqn">-|y_{i,j},y_{j,i}|</code> , <code>"product"</code> for
<code class="reqn">y_{i,j}y_{j,i}</code> , and <code>"geometric"</code> for
<code class="reqn">\sqrt{y_{i,j}}\sqrt{y_{j,i}}</code> . See Krivitsky (2012) for a
discussion of these statistics. <code>form="threshold"</code> simply
computes the binary <code>mutuality</code> after
thresholding at <code>threshold</code> .
</p>
<p>This term can only be used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: mutual(same=NULL, by=NULL, diff=FALSE, keep=NULL, levels=NULL)

# valued: mutual(form="min",threshold=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual-ergmTerm_+3A_same">same</code></td>
<td>
<p>if the optional argument is passed
(see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details),
only mutual pairs that match on the attribute are counted;
separate counts for each unique matching value can be obtained by using
<code>diff=TRUE</code> with <code>same</code>. Only one of <code>same</code> or <code>by</code> may be used. If both parameters are used, <code>by</code> is
ignored. This paramer is affected by <code>diff</code>.</p>
</td></tr>
<tr><td><code id="mutual-ergmTerm_+3A_by">by</code></td>
<td>
<p>if the optional argument is passed (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details),
then each node is counted separately for each mutual pair in which it
occurs and the counts are tabulated by unique values of the attribute.
This means that the sum of the mutual statistics when <code>by</code> is used
will equal twice the standard mutual statistic. Only one of <code>same</code> or <code>by</code> may be used. If both parameters are used, <code>by</code> is
ignored. This paramer is not affected by <code>diff</code>.</p>
</td></tr>
<tr><td><code id="mutual-ergmTerm_+3A_keep">keep</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="mutual-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>which statistics should be kept whenever the <code>mutual</code> term would ordinarily result in multiple statistics. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="mutual-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>keep</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>keep</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>keep</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, frequently-used, binary, valued</p>


<hr>
<h2 id='nearsimmelian-ergmTerm'>Near simmelian triads</h2><span id='topic+nearsimmelian-ergmTerm'></span><span id='topic+InitErgmTerm.nearsimmelian'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model equal to the number of near
Simmelian triads, as defined by Krackhardt and Handcock (2007). This is a
sub-graph of size three which is exactly one tie short of being complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nearsimmelian
</code></pre>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, binary</p>


<hr>
<h2 id='network.list'>A convenience container for a list of <code><a href="network.html#topic+network">network</a></code> objects, output
by <code><a href="#topic+simulate.ergm">simulate.ergm</a></code> among others.</h2><span id='topic+network.list'></span><span id='topic+print.network.list'></span><span id='topic+summary.network.list'></span>

<h3>Description</h3>

<p>A convenience container for a list of <code><a href="network.html#topic+network">network</a></code> objects, output
by <code><a href="#topic+simulate.ergm">simulate.ergm</a></code> among others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.list(object, ...)

## S3 method for class 'network.list'
print(x, stats.print = FALSE, ...)

## S3 method for class 'network.list'
summary(
  object,
  stats.print = TRUE,
  net.print = FALSE,
  net.summary = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.list_+3A_object">object</code>, <code id="network.list_+3A_x">x</code></td>
<td>
<p>a <code>list</code> of networks or a <code>network.list</code> object.</p>
</td></tr>
<tr><td><code id="network.list_+3A_...">...</code></td>
<td>
<p>for <code>network.list</code>, additional attributes to be set on
the network list; for others, arguments passed down to
lower-level functions.</p>
</td></tr>
<tr><td><code id="network.list_+3A_stats.print">stats.print</code></td>
<td>
<p>Logical: If TRUE, print network statistics.</p>
</td></tr>
<tr><td><code id="network.list_+3A_net.print">net.print</code></td>
<td>
<p>Logical: If TRUE, print network overviews.</p>
</td></tr>
<tr><td><code id="network.list_+3A_net.summary">net.summary</code></td>
<td>
<p>Logical: If TRUE, print network summaries.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(network.list)</code>: A <code><a href="base.html#topic+print">print()</a></code> method for network lists.
</p>
</li>
<li> <p><code>summary(network.list)</code>: A <code><a href="#topic+summary">summary()</a></code> method for network lists.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.ergm">simulate.ergm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Draw from a Bernoulli model with 16 nodes
# and tie probability 0.1
#
g.use &lt;- network(16, density=0.1, directed=FALSE)
#
# Starting from this network let's draw 3 realizations
# of a model with edges and 2-star terms
#
g.sim &lt;- simulate(~edges+kstar(2), nsim=3, coef=c(-1.8, 0.03),
               basis=g.use, control=control.simulate(
                 MCMC.burnin=100000,
                 MCMC.interval=1000))
print(g.sim)
summary(g.sim)

</code></pre>

<hr>
<h2 id='nodal_attributes'>Specifying nodal attributes and their levels</h2><span id='topic+nodal_attributes'></span><span id='topic+attr'></span><span id='topic+attrname'></span><span id='topic+on'></span><span id='topic+by'></span><span id='topic+attrs'></span><span id='topic+node.attr'></span><span id='topic+nodal.attr'></span><span id='topic+vertex.attr'></span><span id='topic+node.attribute'></span><span id='topic+nodal.attribute'></span><span id='topic+vertex.attribute'></span><span id='topic+LARGEST'></span><span id='topic+SMALLEST'></span><span id='topic+COLLAPSE_SMALLEST'></span>

<h3>Description</h3>

<p>This document describes the ways to specify nodal
attributes or functions of nodal attributes and which levels for
categorical factors to include. For the helper functions to
facilitate this, see <code><a href="#topic+nodal_attributes-API">nodal_attributes-API</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LARGEST(l, a)

SMALLEST(l, a)

COLLAPSE_SMALLEST(object, n, into)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodal_attributes_+3A_object">object</code>, <code id="nodal_attributes_+3A_l">l</code>, <code id="nodal_attributes_+3A_a">a</code>, <code id="nodal_attributes_+3A_n">n</code>, <code id="nodal_attributes_+3A_into">into</code></td>
<td>
<p><code>COLLAPSE_SMALLEST</code>, <code>LARGEST</code>, and
<code>SMALLEST</code> are technically functions but they are generally not
called in a standard fashion but rather as a part of an vertex
attribute specification or a level specification as described
below. The above usage examples are needed to pass <span class="rlang"><b>R</b></span>'s package
checking without warnings; please disregard them, and refer to the
sections and examples below instead.</p>
</td></tr>
</table>


<h3>Specifying nodal attributes</h3>

<p>Term nodal attribute arguments, typically called <code>attr</code>, <code>attrs</code>, <code>by</code>, or
<code>on</code> are interpreted as follows: </p>

<dl>
<dt>a character string</dt><dd><p>Extract the vertex attribute with
this name.</p>
</dd>
<dt>a character vector of length &gt; 1</dt><dd><p>Extract the vertex
attributes and paste them together, separated by dots if the term
expects categorical attributes and (typically) combine into a
covariate matrix if it expects quantitative attributes.</p>
</dd>
<dt>a function</dt><dd><p>The function is called on the LHS network and
additional arguments to <code><a href="#topic+ergm_get_vattr">ergm_get_vattr()</a></code>, expected to return a
vector or matrix of appropriate dimension. (Shorter vectors and
matrix columns will be recycled as needed.)</p>
</dd>
<dt>a formula</dt><dd><p>The expression on the RHS of the formula is
evaluated in an environment of the vertex attributes of the
network, expected to return a vector or matrix of appropriate
dimension. (Shorter vectors and matrix columns will be recycled as
needed.) Within this expression, the network itself accessible as
either <code>.</code> or <code>.nw</code>. For example,
<code>nodecov(~abs(Grade-mean(Grade))/network.size(.))</code> would return the
absolute difference of each actor's &quot;Grade&quot; attribute from its
network-wide mean, divided by the network size.</p>
</dd>
<dt>an <code>AsIs</code> object created by <code>I()</code></dt><dd><p>Use as is, checking only
for correct length and type.</p>
</dd>
</dl>

<p>Any of these arguments may also be wrapped in or piped through
<code>COLLAPSE_SMALLEST(attr, n, into)</code> or, <code>attr %&gt;% COLLAPSE_SMALLEST(n, into)</code>, a convenience function that will
transform the attribute by collapsing the smallest <code>n</code> categories
into one, naming it <code>into</code>. Note that <code>into</code> must be of the same
type (numeric, character, etc.) as the vertex attribute in
question.
</p>
<p>The name the nodal attribute receives in the statistic can be
overridden by setting a an <code><a href="#topic+attr">attr()</a></code>-style attribute <code>"name"</code>.
</p>


<h3>Specifying categorical attribute levels and their ordering</h3>

<p>For categorical attributes, to select which levels are of interest
and their ordering, use the argument <code>levels</code>.  Selection of nodes (from
the appropriate vector of nodal indices) is likewise handled as the
selection of levels, using the argument <code>nodes</code>.  These arguments are interpreted
as follows: </p>

<dl>
<dt>an expression wrapped in <code><a href="base.html#topic+I">I()</a></code></dt><dd><p>Use the given list of levels
as is.</p>
</dd>
<dt>a numeric or logical vector</dt><dd><p>Used for indexing of a list of
all possible levels (typically, unique values of the attribute) in
default older (typically lexicographic), i.e.,
<code>sort(unique(attr))[levels]</code>. In particular, <code>levels=TRUE</code> will
retain all levels. Negative values exclude. Another special value
is <code>LARGEST</code>, which will refer to the most frequent category, so,
say, to set such a category as the baseline, pass
<code>levels=-LARGEST</code>. In addition, <code>LARGEST(n)</code> will refer to the <code>n</code>
largest categories. <code>SMALLEST</code> works analogously. Note that if there
are ties in frequencies, they will be broken arbitrarily. To
specify numeric or logical levels literally, wrap in <code><a href="base.html#topic+I">I()</a></code>.</p>
</dd>
<dt><code><a href="base.html#topic+NULL">NULL</a></code></dt><dd><p>Retain all possible levels; usually equivalent to
passing <code>TRUE</code>.</p>
</dd>
<dt>a character vector</dt><dd><p>Use as is.</p>
</dd>
<dt>a function</dt><dd><p>The function is called on the list of unique
values of the attribute, the values of the attribute themselves,
and the network itself, depending on its arity. Its return value is
interpreted as above.</p>
</dd>
<dt>a formula</dt><dd><p>The expression on the RHS of the formula is
evaluated in an environment in which the network itself is
accessible as <code>.nw</code>, the list of unique values of the attribute as
<code>.</code> or as <code>.levels</code>, and the attribute vector itself as
<code>.attr</code>. Its return value is interpreted as above.</p>
</dd>
<dt>a matrix</dt><dd><p>For mixing effects (i.e., <code style="white-space: pre;">&#8288;level2=&#8288;</code> arguments), a
matrix can be used to select elements of the mixing matrix, either
by specifying a logical (<code>TRUE</code> and <code>FALSE</code>) matrix of the same
dimension as the mixing matrix to select the corresponding cells or
a two-column numeric matrix indicating giving the coordinates of
cells to be used.</p>
</dd>
</dl>

<p>Note that <code>levels</code>, <code>nodes</code>, and others often have a default that is sensible for the
term in question.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr) # for %&gt;%

data(faux.mesa.high)

# Activity by grade with a baseline grade excluded:
summary(faux.mesa.high~nodefactor(~Grade))
# Name overrides:
summary(faux.mesa.high~nodefactor("Form"~Grade)) # Only for terms that don't use the LHS.
summary(faux.mesa.high~nodefactor(~structure(Grade,name="Form")))
# Retain all levels:
summary(faux.mesa.high~nodefactor(~Grade, levels=TRUE)) # or levels=NULL
# Use the largest grade as baseline (also Grade 7):
summary(faux.mesa.high~nodefactor(~Grade, levels=-LARGEST))
# Activity by grade with no baseline smallest two grades (11 and
# 12) collapsed into a new category, labelled 0:
table(faux.mesa.high %v% "Grade")
summary(faux.mesa.high~nodefactor((~Grade) %&gt;% COLLAPSE_SMALLEST(2, 0),
                                  levels=TRUE))

# Mixing between lower and upper grades:
summary(faux.mesa.high~mm(~Grade&gt;=10))
# Mixing between grades 7 and 8 only:
summary(faux.mesa.high~mm("Grade", levels=I(c(7,8))))
# or
summary(faux.mesa.high~mm("Grade", levels=1:2))
# or using levels2 (see ? mm) to filter the combinations of levels,
summary(faux.mesa.high~mm("Grade",
        levels2=~sapply(.levels,
                        function(l)
                          l[[1]]%in%c(7,8) &amp;&amp; l[[2]]%in%c(7,8))))

# Here are some less complex ways to specify levels2. This is the
# full list of combinations of sexes in an undirected network:
summary(faux.mesa.high~mm("Sex", levels2=TRUE))
# Select only the second combination:
summary(faux.mesa.high~mm("Sex", levels2=2))
# Equivalently,
summary(faux.mesa.high~mm("Sex", levels2=-c(1,3)))
# or
summary(faux.mesa.high~mm("Sex", levels2=c(FALSE,TRUE,FALSE)))
# Select all *but* the second one:
summary(faux.mesa.high~mm("Sex", levels2=-2))
# Select via a mixing matrix: (Network is undirected and
# attributes are the same on both sides, so we can use either M or
# its transpose.)
(M &lt;- matrix(c(FALSE,TRUE,FALSE,FALSE),2,2))
summary(faux.mesa.high~mm("Sex", levels2=M)+mm("Sex", levels2=t(M)))
# Select via an index of a cell:
idx &lt;- cbind(1,2)
summary(faux.mesa.high~mm("Sex", levels2=idx))

# mm() term allows two-sided attribute formulas with different attributes:
summary(faux.mesa.high~mm(Grade~Race, levels2=TRUE))
# It is possible to have collapsing functions in the formula; note
# the parentheses around "~Race": this is because a formula
# operator (~) has lower precedence than pipe (|&gt;):
summary(faux.mesa.high~mm(Grade~(~Race) %&gt;% COLLAPSE_SMALLEST(3,"BWO"), levels2=TRUE))

# Some terms, such as nodecov(), accept matrices of nodal
# covariates. An certain R quirk means that columns whose
# expressions are not typical variable names have their names
# dropped and need to be adjusted. Consider, for example, the
# linear and quadratic effects of grade:
Grade &lt;- faux.mesa.high %v% "Grade"
colnames(cbind(Grade, Grade^2)) # Second column name missing.
colnames(cbind(Grade, Grade2=Grade^2)) # Can be set manually,
colnames(cbind(Grade, `Grade^2`=Grade^2)) # even to non-variable-names.
colnames(cbind(Grade, Grade^2, deparse.level=2)) # Alternatively, deparse.level=2 forces naming.
rm(Grade)

# Therefore, the nodal attribute names are set as follows:
summary(faux.mesa.high~nodecov(~cbind(Grade, Grade^2))) # column names dropped with a warning
summary(faux.mesa.high~nodecov(~cbind(Grade, Grade2=Grade^2))) # column names set manually
summary(faux.mesa.high~nodecov(~cbind(Grade, Grade^2, deparse.level=2))) # using deparse.level=2

# Activity by grade with a random covariate. Note that setting an attribute "name" gives it a name:
randomcov &lt;- structure(I(rbinom(network.size(faux.mesa.high),1,0.5)), name="random")
summary(faux.mesa.high~nodefactor(I(randomcov)))
</code></pre>

<hr>
<h2 id='nodal_attributes-API'>Helper functions for specifying nodal attribute levels</h2><span id='topic+nodal_attributes-API'></span><span id='topic+ERGM_GET_VATTR_MULTIPLE_TYPES'></span><span id='topic+ergm_get_vattr'></span><span id='topic+ergm_get_vattr.AsIs'></span><span id='topic+ergm_get_vattr.character'></span><span id='topic+ergm_get_vattr.function'></span><span id='topic+ergm_get_vattr.formula'></span><span id='topic+ergm_attr_levels'></span><span id='topic+ergm_attr_levels.numeric'></span><span id='topic+ergm_attr_levels.logical'></span><span id='topic+ergm_attr_levels.AsIs'></span><span id='topic+ergm_attr_levels.character'></span><span id='topic+ergm_attr_levels.NULL'></span><span id='topic+ergm_attr_levels.matrix'></span><span id='topic+ergm_attr_levels.function'></span><span id='topic+ergm_attr_levels.formula'></span><span id='topic+ERGM_VATTR_SPEC'></span><span id='topic+ERGM_VATTR_SPEC_NULL'></span><span id='topic+ERGM_LEVELS_SPEC'></span>

<h3>Description</h3>

<p>These functions are meant to be used in <code>InitErgmTerm</code> and other
implementations to provide the user with a way to extract nodal
attributes and select their levels in standardized and flexible
ways described under <code><a href="#topic+nodal_attributes">nodal_attributes</a></code>.
</p>
<p><code>ergm_get_vattr</code> extracts and processes the specified
nodal attribute vector. It is strongly recommended that
<code><a href="#topic+check.ErgmTerm">check.ErgmTerm()</a></code>'s corresponding
<code>vartype="function,formula,character"</code> (using the
<code>ERGM_VATTR_SPEC</code> constant).
</p>
<p><code>ergm_attr_levels</code> filters the levels of the
attribute.  It is strongly recommended that <code><a href="#topic+check.ErgmTerm">check.ErgmTerm()</a></code>'s
corresponding
<code>vartype="function,formula,character,numeric,logical,AsIs,NULL"</code> (using the
<code>ERGM_LEVELS_SPEC</code> constant).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ERGM_GET_VATTR_MULTIPLE_TYPES

ergm_get_vattr(
  object,
  nw,
  accept = "character",
  bip = c("n", "b1", "b2", "a"),
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

## S3 method for class 'AsIs'
ergm_get_vattr(
  object,
  nw,
  accept = "character",
  bip = c("n", "b1", "b2", "a"),
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

## S3 method for class 'character'
ergm_get_vattr(
  object,
  nw,
  accept = "character",
  bip = c("n", "b1", "b2", "a"),
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

## S3 method for class ''function''
ergm_get_vattr(
  object,
  nw,
  accept = "character",
  bip = c("n", "b1", "b2", "a"),
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

## S3 method for class 'formula'
ergm_get_vattr(
  object,
  nw,
  accept = "character",
  bip = c("n", "b1", "b2", "a"),
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class 'numeric'
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class 'logical'
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class 'AsIs'
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class 'character'
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class ''NULL''
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class 'matrix'
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class ''function''
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

## S3 method for class 'formula'
ergm_attr_levels(object, attr, nw, levels = sort(unique(attr)), ...)

ERGM_VATTR_SPEC

ERGM_VATTR_SPEC_NULL

ERGM_LEVELS_SPEC
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodal_attributes-API_+3A_object">object</code></td>
<td>
<p>An argument specifying the nodal attribute to select
or which levels to include.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_nw">nw</code></td>
<td>
<p>Network on the LHS of the formula.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_accept">accept</code></td>
<td>
<p>A character vector listing permitted data types for
the output. See the Details section for the specification.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_bip">bip</code></td>
<td>
<p>Bipartedness mode: affects either length of attribute
vector returned or the length permited: <code>"n"</code> for full network,
<code>"b1"</code> for first mode of a bipartite network, <code>"b2"</code> for the
second, and <code>"a"</code> for not adjusting.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_multiple">multiple</code></td>
<td>
<p>Handling of multiple attributes or matrix or data
frame output. See the Details section for the specification.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_...">...</code></td>
<td>
<p>Additional argument to the functions of network or to
the formula's environment.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_attr">attr</code></td>
<td>
<p>A vector of length equal to the number of nodes,
specifying the attribute vector.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_levels">levels</code></td>
<td>
<p>Starting set of levels to use; defaults to the sorted
list of unique attributes.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_a">a</code></td>
<td>
<p>arguments to <code>LARGEST</code>, which is actually a function
that gets processed as a function level spec does.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.
</p>
<p>An object of class <code>character</code> of length 1.
</p>
<p>An object of class <code>character</code> of length 1.
</p>
<p>An object of class <code>character</code> of length 1.
</p>


<h3>Details</h3>

<p>The <code>accept</code> argument is meant to allow the user to
quickly check whether the output is of an <em>acceptable</em> class or
mode. Typically, if a term accepts a character (i.e.,
categorical) attribute, it will also accept a numeric one,
treating each number as a category label. For this reason, the
following outputs are defined:
</p>

<dl>
<dt><code>"character"</code></dt><dd><p>Accept any mode or class (since it can
be converted to character).</p>
</dd>
<dt><code>"numeric"</code></dt><dd><p>Accept real, integer, or logical.</p>
</dd>
<dt><code>"logical"</code></dt><dd><p>Accept logical.</p>
</dd>
<dt><code>"integer"</code></dt><dd><p>Accept integer or logical.</p>
</dd>
<dt><code>"natural"</code></dt><dd><p>Accept a strictly positive integer.</p>
</dd>
<dt><code>"0natural"</code></dt><dd><p>Accept a nonnegative integer or logical.</p>
</dd>
<dt><code>"nonnegative"</code></dt><dd><p>Accept a nonnegative number or logical.</p>
</dd>
<dt><code>"positive"</code></dt><dd><p>Accept a strictly positive number or logical.</p>
</dd>
<dt><code>"index"</code></dt><dd><p>Accept input appropriate for selecting from an unnamed vector: an integer or a logical; positive integers are returned as they are (<code>bip</code> ignored), logicals are right-sized, and negative integers reverse the selection (as with vector indexing).</p>
</dd>
</dl>

<p>Given that, the <code>multiple</code> argument controls how passing multiple
attributes or functions that result in vectors of appropriate
dimension are handled: </p>

<dl>
<dt><code>"paste"</code></dt><dd><p>Paste together with dot as the separator.</p>
</dd>
<dt><code>"stop"</code></dt><dd><p>Fail with an error message.</p>
</dd>
<dt><code>"matrix"</code></dt><dd><p>Construct and/or return a matrix whose rows correspond to vertices.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>ergm_get_vattr</code> returns a vector of length equal to the
number of nodes giving the selected attribute function or, if
<code>multiple="matrix"</code>, a matrix whose number of row equals the
number of nodes. Either may also have an attribute <code>"name"</code>, which
controls the suggested name of the attribute combination.
</p>
<p><code>ergm_attr_levels</code> returns a vector of levels to use and their order.
</p>


<h3>Note</h3>

<p><code>ergm_attr_levels.matrix()</code> expects <code style="white-space: pre;">&#8288;levels=&#8288;</code> to be a
<code><a href="base.html#topic+list">list</a></code> with each element having length 2 and containing the
values of the two categorical attributes being crossed. It also
assumes that they are in the same order as the user would like
them in the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(florentine)
ergm_get_vattr("priorates", flomarriage)
ergm_get_vattr(~priorates, flomarriage)
ergm_get_vattr(~cbind(priorates, priorates^2), flomarriage, multiple="matrix")
ergm_get_vattr(c("wealth","priorates"), flomarriage)
ergm_get_vattr(c("wealth","priorates"), flomarriage, multiple="matrix")
ergm_get_vattr(~priorates&gt;30, flomarriage)
ergm_get_vattr(~TRUE, flomarriage, accept="index")
ergm_get_vattr(~-(2:12), flomarriage, accept="index")
(a &lt;- ergm_get_vattr(~cut(priorates,c(-Inf,0,20,40,60,Inf),label=FALSE)-1, flomarriage))
ergm_attr_levels(NULL, a, flomarriage)
ergm_attr_levels(-1, a, flomarriage)
ergm_attr_levels(1:2, a, flomarriage)
ergm_attr_levels(I(1:2), a, flomarriage)
</code></pre>

<hr>
<h2 id='nodecov-ergmTerm'>Main effect of a covariate</h2><span id='topic+nodecov-ergmTerm'></span><span id='topic+InitErgmTerm.nodecov'></span><span id='topic+InitErgmTerm.nodemain'></span><span id='topic+nodemain-ergmTerm'></span><span id='topic+InitWtErgmTerm.nodecov'></span><span id='topic+InitWtErgmTerm.nodemain'></span>

<h3>Description</h3>

<p>This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the sum of
<code>attr(i)</code> and <code>attr(j)</code> for all edges <code class="reqn">(i,j)</code> in the
network. For categorical attributes, see <code>nodefactor</code> . Note that for
directed networks, <code>nodecov</code> equals <code>nodeicov</code> plus
<code>nodeocov</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodecov(attr)

# binary: nodemain

# valued: nodecov(attr, form="sum")

# valued: nodemain(attr, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodecov-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodecov-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, frequently-used, quantitative nodal attribute, undirected, binary, valued</p>


<hr>
<h2 id='nodecovar-ergmTerm'>Covariance of undirected dyad values incident on each actor</h2><span id='topic+nodecovar-ergmTerm'></span><span id='topic+InitWtErgmTerm.nodecovar'></span><span id='topic+nodesqrtcovar-ergmTerm'></span>

<h3>Description</h3>

<p>This term adds one statistic equal to
<code class="reqn">\sum_{i,j&lt;k} y_{i,j}y_{i,k}/(n-2)</code> . This can be
viewed as a valued analog of the <code>star(2)</code> statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: nodecovar(center, transform)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodecovar-ergmTerm_+3A_center">center</code></td>
<td>
<p>If <code>center=TRUE</code> , the <code class="reqn">y_{\cdot,\cdot}</code> s are
centered by their mean over the whole network before the
calculation. Note that this makes the model non-local, but it may
alleviate multimodailty.</p>
</td></tr>
<tr><td><code id="nodecovar-ergmTerm_+3A_transform">transform</code></td>
<td>
<p>If <code>transform="sqrt"</code> ,
<code class="reqn">y_{\cdot,\cdot}</code> s are repaced by their square roots before the
calculation. This makes sense for counts in particular. If
<code>center=TRUE</code> as well, they are centered by the mean of the
square roots.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that this term replaces <code>nodesqrtcovar</code> , which has been
deprecated in favor of <code>nodecovar(transform="sqrt")</code> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, valued</p>


<hr>
<h2 id='nodefactor-ergmTerm'>Factor attribute effect</h2><span id='topic+nodefactor-ergmTerm'></span><span id='topic+InitErgmTerm.nodefactor'></span><span id='topic+InitWtErgmTerm.nodefactor'></span>

<h3>Description</h3>

<p>This term adds multiple network statistics to the
model, one for each of (a subset of) the unique values of the
<code>attr</code> attribute (or each combination of the attributes
given). Each of these statistics gives the number of times a node
with that attribute or those attributes appears in an edge in the
network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodefactor(attr, base=1, levels=-1)

# valued: nodefactor(attr, base=1, levels=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodefactor-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodefactor-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="nodefactor-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>this optional argument controls which levels of the attribute
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="nodefactor-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To include all attribute values is usually not a good idea, because
the sum of all such statistics equals the number of edges and hence a linear
dependency would arise in any model also including <code>edges</code>. The default,
<code>levels=-1</code>, is therefore to omit the first (in lexicographic order)
attribute level. To include all levels, pass either <code>levels=TRUE</code>
(i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, dyad-independent, frequently-used, undirected, binary, valued</p>


<hr>
<h2 id='nodeicov-ergmTerm'>Main effect of a covariate for in-edges</h2><span id='topic+nodeicov-ergmTerm'></span><span id='topic+InitErgmTerm.nodeicov'></span><span id='topic+InitWtErgmTerm.nodeicov'></span>

<h3>Description</h3>

<p>This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total
value of <code>attr(j)</code> for all edges <code class="reqn">(i,j)</code> in the network. This
term may only be used with directed networks. For categorical attributes,
see <code>nodeifactor</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodeicov(attr)

# valued: nodeicov(attr, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeicov-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodeicov-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, frequently-used, quantitative nodal attribute, binary, valued</p>


<hr>
<h2 id='nodeicovar-ergmTerm'>Covariance of in-dyad values incident on each actor</h2><span id='topic+nodeicovar-ergmTerm'></span><span id='topic+InitWtErgmTerm.nodeicovar'></span><span id='topic+nodeisqrtcovar-ergmTerm'></span>

<h3>Description</h3>

<p>This term adds one statistic equal to
<code class="reqn">\sum_{i,j,k} y_{j,i}y_{k,i}/(n-2)</code> . This can be
viewed as a valued analog of the <code>istar(2)</code> statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: nodeicovar(center, transform)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeicovar-ergmTerm_+3A_center">center</code></td>
<td>
<p>If <code>center=TRUE</code> , the <code class="reqn">y_{\cdot,\cdot}</code> s are
centered by their mean over the whole network before the
calculation. Note that this makes the model non-local, but it may
alleviate multimodailty.</p>
</td></tr>
<tr><td><code id="nodeicovar-ergmTerm_+3A_transform">transform</code></td>
<td>
<p>If <code>transform="sqrt"</code> ,
<code class="reqn">y_{\cdot,\cdot}</code> s are repaced by their square roots before the
calculation. This makes sense for counts in particular. If
<code>center=TRUE</code> as well, they are centered by the mean of the
square roots.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that this term replaces <code>nodeisqrtcovar</code> , which has been
deprecated in favor of <code>nodeicovar(transform="sqrt")</code> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, valued</p>


<hr>
<h2 id='nodeifactor-ergmTerm'>Factor attribute effect for in-edges</h2><span id='topic+nodeifactor-ergmTerm'></span><span id='topic+InitErgmTerm.nodeifactor'></span><span id='topic+InitWtErgmTerm.nodeifactor'></span>

<h3>Description</h3>

<p>This term adds multiple network
statistics to the model, one for each of (a subset of) the unique
values of the <code>attr</code> attribute (or each combination of the
attributes given). Each of these statistics gives the number of
times a node with that attribute or those attributes appears as the
terminal node of a directed tie.
</p>
<p>For an analogous term for quantitative vertex attributes, see <code>nodeicov</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodeifactor(attr, base=1, levels=-1)

# valued: nodeifactor(attr, base=1, levels=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeifactor-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodeifactor-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="nodeifactor-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>this optional argument controls which levels of the attribute
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="nodeifactor-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To include all attribute values is usually not a good idea, because
the sum of all such statistics equals the number of edges and hence a linear
dependency would arise in any model also including <code>edges</code>. The default,
<code>levels=-1</code>, is therefore to omit the first (in lexicographic order)
attribute level. To include all levels, pass either <code>levels=TRUE</code>
(i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, dyad-independent, frequently-used, binary, valued</p>


<hr>
<h2 id='nodematch-ergmTerm'>Uniform homophily and differential homophily</h2><span id='topic+nodematch-ergmTerm'></span><span id='topic+InitErgmTerm.nodematch'></span><span id='topic+InitWtErgmTerm.nodematch'></span><span id='topic+InitWtErgmTerm.match'></span><span id='topic+match-ergmTerm'></span>

<h3>Description</h3>

<p>When <code>diff=FALSE</code> , this term adds one network statistic
to the model, which counts the number of edges <code class="reqn">(i,j)</code> for which
<code>attr(i)==attr(j)</code> . This is also called &ldquo;uniform homophily&rdquo;, because each group is assumed to have the same propensity for within-group ties. When multiple attribute names are given, the
statistic counts only ties for which all of the attributes
match. When <code>diff=TRUE</code> , <code class="reqn">p</code> network statistics are added
to the model, where <code class="reqn">p</code> is the number of unique values of the
<code>attr</code> attribute. The <code class="reqn">k</code> th such statistic counts the
number of edges <code class="reqn">(i,j)</code> for which <code style="white-space: pre;">&#8288;attr(i) == attr(j) == value(k)&#8288;</code> , where <code>value(k)</code> is the <code class="reqn">k</code> th
smallest unique value of the <code>attr</code> attribute. This is also called &ldquo;differential homophily&rdquo;, because each group is allowed to have a unique propensity for within-group ties. Note that a statistical test of uniform vs. differential homophily should be conducted using the ANOVA function.
</p>
<p>By default, matches on all levels <code class="reqn">k</code> are
counted. This works for both
<code>diff=TRUE</code> and <code>diff=FALSE</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodematch(attr, diff=FALSE, keep=NULL, levels=NULL)

# valued: nodematch(attr, diff=FALSE, keep=NULL, levels=NULL, form="sum")

# valued: match(attr, diff=FALSE, keep=NULL, levels=NULL, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodematch-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodematch-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>specify if the term has uniform or differential homophily</p>
</td></tr>
<tr><td><code id="nodematch-ergmTerm_+3A_keep">keep</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="nodematch-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>this optional argument controls which levels of the attribute
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="nodematch-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>keep</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>keep</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>keep</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, dyad-independent, frequently-used, undirected, binary, valued</p>


<hr>
<h2 id='NodematchFilter-ergmTerm'>Filtering on nodematch</h2><span id='topic+NodematchFilter-ergmTerm'></span><span id='topic+InitErgmTerm.NodematchFilter'></span>

<h3>Description</h3>

<p>Evaluates the terms specified in <code>formula</code> on a network
constructed by taking <code class="reqn">y</code> and removing any edges for which
<code>attrname(i)!=attrname(j)</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: NodematchFilter(formula, attrname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NodematchFilter-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>formula to be evaluated</p>
</td></tr>
<tr><td><code id="NodematchFilter-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>a character vector giving one or more names of attributes in the network's vertex attribute list.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary</p>


<hr>
<h2 id='nodemix-ergmTerm'>Nodal attribute mixing</h2><span id='topic+nodemix-ergmTerm'></span><span id='topic+InitErgmTerm.nodemix'></span><span id='topic+InitWtErgmTerm.nodemix'></span>

<h3>Description</h3>

<p>By default, this term adds one network statistic to
the model for each possible pairing of attribute values. The
statistic equals the number of edges in the network in which the
nodes have that pairing of values. (When multiple attributes are specified, a
statistic is added for each combination of attribute values for
those attributes.) In other words, this term produces one statistic for
every entry in the mixing matrix for the attribute(s). By default, the ordering of
the attribute values is lexicographic: alphabetical (for nominal categories) or
numerical (for ordered categories).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodemix(attr, base=NULL, b1levels=NULL, b2levels=NULL, levels=NULL, levels2=-1)

# valued: nodemix(attr, base=NULL, b1levels=NULL, b2levels=NULL, levels=NULL,
#                 levels2=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodemix-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodemix-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="nodemix-ergmTerm_+3A_b1levels">b1levels</code>, <code id="nodemix-ergmTerm_+3A_b2levels">b2levels</code>, <code id="nodemix-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>control what statistics are included in the model and the order in which they appear. <code>levels</code> applies to unipartite networks; <code>b1levels</code> and <code>b2levels</code> apply to bipartite networks (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
<tr><td><code id="nodemix-ergmTerm_+3A_levels2">levels2</code></td>
<td>
<p>similar to the other levels arguments above and applies to all networks. Optionally allows a factor or character matrix to be specified to group certain levels. Level combinations corresponding to <code>NA</code> are excluded. Combinations specified by the same character or level will be grouped together and summarised by the same statistic. If an empty string is specified, the level combinations will be ungrouped. Only the upper triangle needs to be specified for undirected networks. For example, <code>levels2=matrix(c('A', '', NA, 'A'), 2, 2, byrow=TRUE)</code> on an undirected matrix will group homophilous ties while leaving ties between 1 and 2 ungrouped.</p>
</td></tr>
<tr><td><code id="nodemix-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels2</code> are passed,
<code>levels2</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, dyad-independent, frequently-used, undirected, binary, valued</p>


<hr>
<h2 id='nodeocov-ergmTerm'>Main effect of a covariate for out-edges</h2><span id='topic+nodeocov-ergmTerm'></span><span id='topic+InitErgmTerm.nodeocov'></span><span id='topic+InitWtErgmTerm.nodeocov'></span>

<h3>Description</h3>

<p>This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total
value of <code>attr(i)</code> for all edges <code class="reqn">(i,j)</code> in the network. This
term may only be used with directed networks. For categorical attributes,
see <code>nodeofactor</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodeocov(attr)

# valued: nodeocov(attr, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeocov-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodeocov-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p><span class="pkg">ergm</span> versions 3.9.4 and earlier used different arguments for this
term. See <code><a href="#topic+ergm-options">ergm-options</a></code> for how to invoke the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, quantitative nodal attribute, binary, valued</p>


<hr>
<h2 id='nodeocovar-ergmTerm'>Covariance of out-dyad values incident on each actor</h2><span id='topic+nodeocovar-ergmTerm'></span><span id='topic+InitWtErgmTerm.nodeocovar'></span>

<h3>Description</h3>

<p>This term adds one statistic equal to
<code class="reqn">\sum_{i,j,k} y_{i,j}y_{i,k}/(n-2)</code> . This can be
viewed as a valued analog of the <code>ostar(2)</code> statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: nodeocovar(center, transform)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeocovar-ergmTerm_+3A_center">center</code></td>
<td>
<p>whether the <code class="reqn">y_{\cdot,\cdot}</code> s are
centered by their mean over the whole network before the
calculation. Note that this makes the model non-local, but it may
alleviate multimodailty.</p>
</td></tr>
<tr><td><code id="nodeocovar-ergmTerm_+3A_transform">transform</code></td>
<td>
<p>if <code>transform="sqrt"</code> ,
<code class="reqn">y_{\cdot,\cdot}</code> s are repaced by their square roots before the
calculation. This makes sense for counts in particular. If
<code>center=TRUE</code> as well, they are centered by the mean of the
square roots.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that this term replaces <code>nodeosqrtcovar</code> , which has been
deprecated in favor of <code>nodeocovar(transform="sqrt")</code> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, valued</p>


<hr>
<h2 id='nodeofactor-ergmTerm'>Factor attribute effect for out-edges</h2><span id='topic+nodeofactor-ergmTerm'></span><span id='topic+InitErgmTerm.nodeofactor'></span><span id='topic+InitWtErgmTerm.nodeofactor'></span>

<h3>Description</h3>

<p>This term adds multiple network
statistics to the model, one for each of (a subset of) the unique
values of the <code>attr</code> attribute (or each combination of the
attributes given). Each of these statistics gives the number of
times a node with that attribute or those attributes appears as the
node of origin of a directed tie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodeofactor(attr, base=1, levels=-1)

# valued: nodeofactor(attr, base=1, levels=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeofactor-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodeofactor-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="nodeofactor-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>this optional argument controls which levels of the attribute
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
<tr><td><code id="nodeofactor-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>
<p>To include all attribute values is usually not a good idea, because
the sum of all such statistics equals the number of edges and hence a linear
dependency would arise in any model also including <code>edges</code>. The default,
<code>levels=-1</code>, is therefore to omit the first (in lexicographic order)
attribute level. To include all levels, pass either <code>levels=TRUE</code>
(i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, dyad-independent, binary, valued</p>


<hr>
<h2 id='nparam'>Length of the parameter vector associated with an object or with its terms.</h2><span id='topic+nparam'></span><span id='topic+nparam.default'></span><span id='topic+nparam.ergm'></span>

<h3>Description</h3>

<p>This is a generic that returns the number of parameters associated with a model or a model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nparam(object, ...)

## Default S3 method:
nparam(object, ...)

## S3 method for class 'ergm'
nparam(object, offset = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nparam_+3A_object">object</code></td>
<td>
<p>An object for which number of parameters is defined.</p>
</td></tr>
<tr><td><code id="nparam_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
<tr><td><code id="nparam_+3A_offset">offset</code></td>
<td>
<p>If <code>NA</code> (the default), all model terms are counted;
if <code>TRUE</code>, only offset terms are counted; and if
<code>FALSE</code>, offset terms are skipped.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>nparam(default)</code>: By default, the length of the <code><a href="stats.html#topic+coef">coef()</a></code> vector is returned.
</p>
</li>
<li> <p><code>nparam(ergm)</code>: A method to return the number of parameters of an <code><a href="#topic+ergm">ergm</a></code> fit.
</p>
</li></ul>

<hr>
<h2 id='nsp-ergmTerm'>Directed non-edgewise shared partners</h2><span id='topic+nsp-ergmTerm'></span><span id='topic+InitErgmTerm.dnsp'></span><span id='topic+dnsp-ergmTerm'></span><span id='topic+InitErgmTerm.nsp'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code> th such statistic equals the number of non-edges in the network with exactly <code>d[i]</code> shared partners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dnsp(d, type="OTP")

# binary: nsp(d, type="OTP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsp-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="nsp-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>
<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='nvattr.copy.network'>Copy network- and vertex-level attributes between two network objects</h2><span id='topic+nvattr.copy.network'></span>

<h3>Description</h3>

<p>An internal ergm utility function to copy the network-level attributes and
vertex-level attributes from one <code><a href="network.html#topic+network">network</a></code> object to another,
ignoring some standard properties by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvattr.copy.network(
  to,
  from,
  ignore = c("bipartite", "directed", "hyper", "loops", "mnext", "multiple", "n")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvattr.copy.network_+3A_to">to</code></td>
<td>
<p>the <code><a href="network.html#topic+network">network</a></code> that attributes should be copied to</p>
</td></tr>
<tr><td><code id="nvattr.copy.network_+3A_from">from</code></td>
<td>
<p>the <code><a href="network.html#topic+network">network</a></code> that attributes should be copied to</p>
</td></tr>
<tr><td><code id="nvattr.copy.network_+3A_ignore">ignore</code></td>
<td>
<p>vector of charcter names of network attributes that should not
be copied. Default is the standard list of network properties created by
<code><a href="network.html#topic+network.initialize">network.initialize</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>to</code> network, with attributes copied from
<code>from</code>
</p>


<h3>Note</h3>

<p>does not check that networks are of the same size, etc
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+set.vertex.attribute">set.vertex.attribute</a></code>,
<code><a href="network.html#topic+set.network.attribute">set.network.attribute</a></code>
</p>

<hr>
<h2 id='observed-ergmConstraint'>Preserve the observed dyads of the given network</h2><span id='topic+observed-ergmConstraint'></span><span id='topic+InitErgmConstraint.observed'></span>

<h3>Description</h3>

<p>Preserve the observed dyads of the given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># observed
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected</p>


<hr>
<h2 id='odegrange-ergmTerm'>Out-degree range</h2><span id='topic+odegrange-ergmTerm'></span><span id='topic+InitErgmTerm.odegrange'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element of <code>from</code> (or <code>to</code> ); the <code class="reqn">i</code> th
such statistic equals the number of nodes in the network of out-degree
greater than or equal to
<code>from[i]</code> but strictly less than <code>to[i]</code> , i.e. with
out-edge count
in semiopen interval <code style="white-space: pre;">&#8288;[from,to)&#8288;</code> .
</p>
<p>This term can only be used with directed networks; for undirected
networks (bipartite and not)
see <code>degrange</code> . For degrees of specific modes of bipartite
networks, see <code>b1degrange</code> and <code>b2degrange</code> . For
in-degrees, see <code>idegrange</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: odegrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odegrange-ergmTerm_+3A_from">from</code>, <code id="odegrange-ergmTerm_+3A_to">to</code></td>
<td>
<p>vectors of distinct integers. If one of the vectors have length 1, it is recycled to the length of the other. Otherwise, it must have the same length.</p>
</td></tr>
<tr><td><code id="odegrange-ergmTerm_+3A_by">by</code>, <code id="odegrange-ergmTerm_+3A_levels">levels</code>, <code id="odegrange-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
<tr><td><code id="odegrange-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, binary</p>


<hr>
<h2 id='odegree-ergmTerm'>Out-degree</h2><span id='topic+odegree-ergmTerm'></span><span id='topic+InitErgmTerm.odegree'></span>

<h3>Description</h3>

<p>This term adds one network statistic to
the model for each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals
the number of nodes in the network of out-degree <code>d[i]</code> , i.e. the
number of nodes with exactly <code>d[i]</code> out-edges.
This term can only be used with directed networks; for undirected networks
see <code>degree</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: odegree(d, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odegree-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="odegree-ergmTerm_+3A_by">by</code>, <code id="odegree-ergmTerm_+3A_levels">levels</code>, <code id="odegree-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>the optional argument <code>by</code> specifies a vertex attribute (see Specifying
Vertex attributes and Levels (<code>?nodal_attributes</code>) for details).
If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree range
statistics are calculated for nodes having each separate
value of the attribute. <code>levels</code> selects which levels of by' to include.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, frequently-used, binary</p>


<hr>
<h2 id='odegree1.5-ergmTerm'>Out-degree to the 3/2 power</h2><span id='topic+odegree1.5-ergmTerm'></span><span id='topic+InitErgmTerm.odegree1.5'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equaling the sum
over the actors of each actor's outdegree taken to the 3/2 power
(or, equivalently, multiplied by its square root). This term is
analogous to the term of Snijders et al. (2010), equation (12). This
term can only be used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: odegree1.5
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, binary</p>


<hr>
<h2 id='odegreedist-ergmConstraint'>Preserve the outdegree distribution</h2><span id='topic+odegreedist-ergmConstraint'></span><span id='topic+InitErgmConstraint.odegreedist'></span>

<h3>Description</h3>

<p>Preserve the outdegree distribution of the given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># odegreedist
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed</p>


<hr>
<h2 id='odegrees-ergmConstraint'>Preserve outdegree for directed networks</h2><span id='topic+odegrees-ergmConstraint'></span><span id='topic+InitErgmConstraint.odegrees'></span>

<h3>Description</h3>

<p>For directed networks, preserve the outdegree of each vertex of the given
network, while allowing indegree to vary
</p>


<h3>Usage</h3>

<pre><code class='language-R'># odegrees
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed</p>


<hr>
<h2 id='Offset-ergmTerm'>Terms with fixed coefficients</h2><span id='topic+Offset-ergmTerm'></span><span id='topic+InitErgmTerm.Offset'></span>

<h3>Description</h3>

<p>This operator is analogous to the <code>offset()</code> wrapper, but the
coefficients are specified within the term and the curved ERGM
mechanism is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Offset(formula, coef, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Offset-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Offset-ergmTerm_+3A_coef">coef</code></td>
<td>
<p>coefficients to the formula</p>
</td></tr>
<tr><td><code id="Offset-ergmTerm_+3A_which">which</code></td>
<td>
<p>used to specify which of the parameters in the formula are fixed. It can be a logical vector (recycled as needed), a numeric vector of indices of parameters to be fixed, or a character vector of parameter names.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary</p>


<hr>
<h2 id='opentriad-ergmTerm'>Open triads</h2><span id='topic+opentriad-ergmTerm'></span><span id='topic+InitErgmTerm.opentriad'></span>

<h3>Description</h3>

<p>This term
adds one statistic to the model equal to the number of 2-stars minus
three times the number of triangles in the network. It is currently
only implemented for undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: opentriad
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>triad-related, undirected, binary</p>


<hr>
<h2 id='ostar-ergmTerm'>k-Outstars</h2><span id='topic+ostar-ergmTerm'></span><span id='topic+InitErgmTerm.ostar'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the
model for each element in <code>k</code> . The <code class="reqn">i</code> th such statistic counts the
number of distinct <code>k[i]</code> -outstars in the network, where a
<code class="reqn">k</code> -outstar is defined to be a node <code class="reqn">N</code> and a set of <code class="reqn">k</code>
different nodes <code class="reqn">\{O_1, \dots, O_k\}</code> such that the ties
<code class="reqn">(N{\rightarrow}O_j)</code> exist for <code class="reqn">j=1, \dots, k</code> .
This term can only be used with directed
networks; for undirected networks see <code>kstar</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: ostar(k, attr=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ostar-ergmTerm_+3A_k">k</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="ostar-ergmTerm_+3A_attr">attr</code>, <code id="ostar-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a vertex attribute specification; if <code>attr</code> is
specified, then the count is over the instances where all nodes
involved have the same value of the attribute. <code>levels</code> specified
which values of <code>attr</code> are included in the count. (See Specifying
Vertex attributes and Levels
(<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>ostar(1)</code> is equal to both <code>istar(1)</code> and <code>edges</code> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, binary</p>


<hr>
<h2 id='param_names'>Names of the parameters associated with an object.</h2><span id='topic+param_names'></span><span id='topic+param_names.default'></span>

<h3>Description</h3>

<p>This is a generic that returns a vector giving the names of the parameters associated with a model or a model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_names(object, ...)

## Default S3 method:
param_names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_names_+3A_object">object</code></td>
<td>
<p>An object for which parameter names are defined.</p>
</td></tr>
<tr><td><code id="param_names_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>param_names(default)</code>: By default, the names of the <code><a href="stats.html#topic+coef">coef()</a></code> vector is returned.
</p>
</li></ul>

<hr>
<h2 id='predict.formula'>ERGM-based tie probabilities</h2><span id='topic+predict.formula'></span><span id='topic+predict.ergm'></span>

<h3>Description</h3>

<p>Calculate model-predicted <strong>conditional</strong> and <strong>unconditional</strong> tie
probabilities for dyads in the given network. Conditional probabilities of a
dyad given the state of all the remaining dyads in the graph are computed
exactly. Unconditional probabilities are computed through simulating networks
using the given model. Currently there are two methods implemented:
</p>

<ul>
<li><p> Method for formula objects requires (1) an ERGM model formula with an existing
network object on the left hand side and model terms on the right hand side, and
(2) a vector of corresponding parameter values.
</p>
</li>
<li><p> Method for <code>ergm</code> objects, as returned by <code><a href="#topic+ergm">ergm()</a></code>, takes both the formula
and parameter values from the fitted model object.
</p>
</li></ul>

<p>Both methods can limit calculations to specific set of dyads of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
predict(
  object,
  theta,
  conditional = TRUE,
  type = c("response", "link"),
  nsim = 100,
  output = c("data.frame", "matrix"),
  ...
)

## S3 method for class 'ergm'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.formula_+3A_object">object</code></td>
<td>
<p>a formula or a fitted ERGM model object</p>
</td></tr>
<tr><td><code id="predict.formula_+3A_theta">theta</code></td>
<td>
<p>numeric vector of ERGM model parameter values</p>
</td></tr>
<tr><td><code id="predict.formula_+3A_conditional">conditional</code></td>
<td>
<p>logical whether to compute conditional or unconditional
predicted probabilities</p>
</td></tr>
<tr><td><code id="predict.formula_+3A_type">type</code></td>
<td>
<p>character element, one of <code>"response"</code> (default) or <code>"link"</code> -
whether the returned predictions are on the probability scale or on the
scale of linear predictor. This is similar to <code>type</code> argument of <code><a href="stats.html#topic+predict.glm">predict.glm()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.formula_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of simulated networks used for computing
unconditional probabilities. Defaults to 100.</p>
</td></tr>
<tr><td><code id="predict.formula_+3A_output">output</code></td>
<td>
<p>character, type of object returned. Defaults to <code>"data.frame"</code>.
See section Value below.</p>
</td></tr>
<tr><td><code id="predict.formula_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods. For the <code>predict.formula</code> method, if
<code>conditional=TRUE</code> arguments are passed to <code><a href="#topic+ergmMPLE">ergmMPLE()</a></code>. If <code>conditional=FALSE</code> arguments
are passed to <code><a href="#topic+simulate_formula">simulate_formula()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Type of object returned depends on the argument <code>output</code>. If
<code>output="data.frame"</code> the function will return a data frame with columns:
</p>

<ul>
<li> <p><code>tail</code>, <code>head</code> &ndash; indices of nodes identifying a dyad
</p>
</li>
<li> <p><code>p</code> &ndash; predicted conditional tie probability
</p>
</li></ul>

<p>If <code>output="matrix"</code> the function will return an &quot;adjacency matrix&quot; with the
predicted probabilities. Diagonal values are 0s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A three-node empty directed network
net &lt;- network.initialize(3, directed=TRUE)

# In homogeneous Bernoulli model with odds of a tie of 1/5 all ties are
# equally likely
predict(net ~ edges, log(1/5))

# Let's add a tie so that `net` has 1 tie out of possible 6 (so odds of 1/5)
net[1,2] &lt;- 1

# Fit the model
fit &lt;- ergm(net ~ edges)

# The p's should be identical
predict(fit)
</code></pre>

<hr>
<h2 id='Prod-ergmTerm'>A product (or an arbitrary power combination) of one or more formulas</h2><span id='topic+Prod-ergmTerm'></span><span id='topic+InitErgmTerm.Prod'></span><span id='topic+InitWtErgmTerm.Prod'></span>

<h3>Description</h3>

<p>This operator evaluates a list of formulas whose corresponnding RHS
statistics will be multiplied elementwise. They are required to be nonnegative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Prod(formulas, label)

# valued: Prod(formulas, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prod-ergmTerm_+3A_formulas">formulas</code></td>
<td>
<p>a list (constructed using <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>) of <code><a href="#topic+ergm">ergm()</a></code>-style formulas whose RHS gives the statistics to be evaluated, or a single formula.
</p>
<p>If a formula in the list has an LHS, it is interpreted as follows:
</p>

<ul>
<li><p> a numeric scalar: Network statistics of this formula will be exponentiated by this.
</p>
</li>
<li><p> a numeric vector: Corresponding network statistics of this formula will be exponentiated by this.
</p>
</li>
<li><p> a numeric matrix: Vector of network statistics will be exponentiated by this using the same pattern as matrix multiplication.
</p>
</li>
<li><p> a character string: One of several predefined multiplicative combinations. Currently supported presets are as follows:
</p>

<ul>
<li> <p><code>"prod"</code>: Network statistics of this formula will be multiplied together; equivalent to <code>matrix(1,1,p)</code> , where <code>p</code> is the length of the network statistic vector.
</p>
</li>
<li> <p><code>"geomean"</code>: Network statistics of this formula will be geometrically averaged; equivalent to <code>matrix(1/p,1,p)</code> , where <code>p</code> is the length of the network statistic vector.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="Prod-ergmTerm_+3A_label">label</code></td>
<td>
<p>used to specify the names of the elements of the resulting term product vector. If <code>label</code> is a character vector of length 1,
it will be recycled with indices appended. If a function is specified, <code>formulas</code> parameter names are extracted and their list of character vectors is passed <code>label</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that each formula must either produce the same number of
statistics or be mapped through a matrix to produce the same
number of statistics.
</p>
<p>A single formula is also permitted. This can be useful if one
wishes to, say, scale or multiply together the statistics returned by a formula.
</p>
<p>Offsets are ignored unless there is only one formula and the transformation only scales the statistics (i.e., the effective transformation matrix is diagonal).
</p>
<p>Curved models are supported, subject to some limitations. In particular, the first model's etamap will be used, overwriting the others. If <code>label</code> is not of length 1, it should have an <code>attr</code> -style attribute <code>"curved"</code> specifying the names for the curved parameters.
</p>


<h3>Note</h3>

<p>The current implementation piggybacks on the <code>Log</code> , <code>Exp</code> , and <code>Sum</code> operators, essentially <code>Exp(~Sum(~Log(formula), label))</code> . This may result in loss of precision, particularly for extremely large or small statistics. The implementation may change in the future.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary, valued</p>


<hr>
<h2 id='randomtoggle-ergmProposal'>Propose a randomly selected dyad to toggle</h2><span id='topic+randomtoggle-ergmProposal'></span><span id='topic+InitErgmProposal.randomtoggle'></span>

<h3>Description</h3>

<p>Propose a randomly selected dyad to toggle
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='rank_test.ergm'>A lack-of-fit test for ERGMs</h2><span id='topic+rank_test.ergm'></span>

<h3>Description</h3>

<p>A simple test reporting the sample quantile of the observed
network's probability in the distribution under the MLE. This is a
conservative p-value for the null hypothesis of the observed
network being a draw from the distribution of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_test.ergm(x, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_test.ergm_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ergm">ergm()</a></code> object.</p>
</td></tr>
<tr><td><code id="rank_test.ergm_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code>, plot the empirical distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sample quantile of the observed network's probability
among the predicted.
</p>

<hr>
<h2 id='receiver-ergmTerm'>Receiver effect</h2><span id='topic+receiver-ergmTerm'></span><span id='topic+InitErgmTerm.receiver'></span><span id='topic+InitWtErgmTerm.receiver'></span>

<h3>Description</h3>

<p>This term adds one network statistic for each node equal to the number of
in-ties for that node. This measures the popularity of the node. The term
for the first node is omitted by default because of linear dependence that
arises if this term is used together with <code>edges</code> , but its coefficient
can be computed as the negative of the sum of the coefficients of all the
other actors. That is, the average coefficient is zero, following the
Holland-Leinhardt parametrization of the $p_1$ model (Holland and Leinhardt,
1981).  This
term can only be used with directed networks. For undirected networks, see
<code>sociality</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: receiver(base=1, nodes=-1)

# valued: receiver(base=1, nodes=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="receiver-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="receiver-ergmTerm_+3A_nodes">nodes</code></td>
<td>
<p>specify which nodes' statistics should be included or excluded (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
<tr><td><code id="receiver-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>nodes</code> are passed,
<code>nodes</code> overrides <code>base</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, binary, valued</p>


<hr>
<h2 id='rlebdm'>RLE-Compressed Boolean Dyad Matrix</h2><span id='topic+rlebdm'></span><span id='topic+as.rlebdm'></span><span id='topic+as.rlebdm.matrix'></span><span id='topic+as.rlebdm.edgelist'></span><span id='topic+as.rlebdm.network'></span><span id='topic+as.matrix.rlebdm'></span><span id='topic+dim.rlebdm'></span><span id='topic+print.rlebdm'></span><span id='topic+Ops.rlebdm'></span><span id='topic+Math.rlebdm'></span><span id='topic+compress.rlebdm'></span><span id='topic+as.edgelist.rlebdm'></span>

<h3>Description</h3>

<p>A simple class representing boolean (logical) square matrix
run-length encoded in a column-major order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlebdm(x, n)

as.rlebdm(x, ...)

## S3 method for class 'matrix'
as.rlebdm(x, ...)

## S3 method for class 'edgelist'
as.rlebdm(x, ...)

## S3 method for class 'network'
as.rlebdm(x, ...)

## S3 method for class 'rlebdm'
as.matrix(x, ...)

## S3 method for class 'rlebdm'
dim(x)

## S3 method for class 'rlebdm'
print(x, compact = TRUE, ...)

## S3 method for class 'rlebdm'
Ops(e1, e2)

## S3 method for class 'rlebdm'
Math(x, ...)

## S3 method for class 'rlebdm'
compress(x, ...)

## S3 method for class 'rlebdm'
as.edgelist(x, prototype = NULL, ..., output = c("matrix", "tibble"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlebdm_+3A_x">x</code></td>
<td>
<p>for <code><a href="#topic+rlebdm">rlebdm()</a></code>, an <code><a href="base.html#topic+rle">rle()</a></code> object or a vector that is converted to one; it will be coerced to <code><a href="base.html#topic+logical">logical()</a></code> before processing; for <code><a href="#topic+as.rlebdm.matrix">as.rlebdm.matrix()</a></code>, a matrix.</p>
</td></tr>
<tr><td><code id="rlebdm_+3A_n">n</code></td>
<td>
<p>the dimensions of the square matrix represented.</p>
</td></tr>
<tr><td><code id="rlebdm_+3A_...">...</code></td>
<td>
<p>additional arguments, currently unused.</p>
</td></tr>
<tr><td><code id="rlebdm_+3A_compact">compact</code></td>
<td>
<p>whether to print the matrix compactly (dots and stars) or to print it as a logical matrix.</p>
</td></tr>
<tr><td><code id="rlebdm_+3A_e1">e1</code>, <code id="rlebdm_+3A_e2">e2</code></td>
<td>
<p>arguments to the unary (<code>e1</code>) or the binary (<code>e1</code> and <code>e2</code>) operators.</p>
</td></tr>
<tr><td><code id="rlebdm_+3A_prototype">prototype</code></td>
<td>
<p>an optional network with network attributes that
are transferred to the edgelist and will filter it (e.g., if the
prototype network is given and does not allow self-loops, the
edgelist will not have self-loops either,e ven if the dyad matrix
has non-<code>FALSE</code> diagonal).</p>
</td></tr>
<tr><td><code id="rlebdm_+3A_output">output</code></td>
<td>
<p>a string specifying whether the result should be a
matrix or a <code><a href="tibble.html#topic+tibble">tibble</a></code>.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>compress(rlebdm)</code>: Compress the <code>rle</code> data structure in the
<code>rlebdm</code> by merging successive runs with identical values.
</p>
</li>
<li> <p><code>as.edgelist(rlebdm)</code>: Convert an <code><a href="#topic+rlebdm">rlebdm</a></code> object to an <code><a href="network.html#topic+edgelist">edgelist</a></code>: a two-column
integer matrix or <code><a href="tibble.html#topic+tibble">tibble</a></code> giving the cells with <code>TRUE</code> values.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>as.rlebdm(matrix)</code>: Convert a square matrix of mode coercible to <code><a href="base.html#topic+logical">logical</a></code> to an
<code><a href="#topic+rlebdm">rlebdm</a></code>.
</p>
</li>
<li> <p><code>as.rlebdm(edgelist)</code>: Convert an object of class <code><a href="network.html#topic+edgelist">edgelist</a></code> to an <code><a href="#topic+rlebdm">rlebdm</a></code> object
whose cells in the edge list are set to <code>TRUE</code> and whose other
cells are set to <code>FALSE</code>.
</p>
</li>
<li> <p><code>as.rlebdm(network)</code>: Convert an object of class <code><a href="network.html#topic+network">network</a></code> to an <code><a href="#topic+rlebdm">rlebdm</a></code> object
whose cells corresponding to extant edges are set to <code>TRUE</code> and
whose other cells are set to <code>FALSE</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>The arithmetic operators are mathematical functions are
implemented for the <code><a href="methods.html#topic+Ops">Ops</a></code> and the <code><a href="methods.html#topic+Math">Math</a></code> group generics and
therefore work for almost all of them automatically. To preserve
the integrity of the data structure, the results are cast to
logical before return.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.rlebdm.ergm_conlist">as.rlebdm.ergm_conlist()</a></code>
</p>
<p><code><a href="network.html#topic+as.edgelist">as.edgelist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From a vector
rlebdm(rep(rep(c(0,1),each=3),14)[seq_len(81)], 9)

# From a constant
rlebdm(1, 3)

# Large matrix (overflowing .Machine$integer.max)
big &lt;- rlebdm(1, 50000)
unclass(big) # Represented as two runs
stopifnot(length(big)==50000^2)

</code></pre>

<hr>
<h2 id='S-ergmTerm'>Evaluation on an induced subgraph</h2><span id='topic+S-ergmTerm'></span><span id='topic+InitErgmTerm.S'></span>

<h3>Description</h3>

<p>This operator takes a two-sided forumla <code>attrs</code> whose LHS gives the attribute or attribute function for which tails and heads will be used to construct the induced subgraph. They must evaluate either to a logical vector equal in length to the number of tails (for LHS) and heads (for RHS) indicating which nodes are to be used to induce the subgraph or a numeric vector giving their indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: S(formula, attrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="S-ergmTerm_+3A_attrs">attrs</code></td>
<td>
<p>a two-sided formula to be used. A one-sided formula (e.g., <code>~A</code> ) is symmetrized (e.g., <code>A~A</code> ).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with indexing vectors, the logical vector will be recycled to the size of the network or the size of the appropriate bipartition, and negative indices will deselect vertices.
</p>
<p>When the two sets are identical, the induced subgraph retains the directedness of the original graph. Otherwise, an undirected bipartite graph is induced.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary</p>


<hr>
<h2 id='samplk'>Longitudinal networks of positive affection within a monastery as a
&quot;network&quot; object</h2><span id='topic+samplk'></span><span id='topic+samplk1'></span><span id='topic+samplk2'></span><span id='topic+samplk3'></span>

<h3>Description</h3>

<p>Three <code><a href="network.html#topic+network">network</a></code> objects containing the &quot;liking&quot; nominations of
Sampson's (1969) monks at the three time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(samplk)
</code></pre>


<h3>Details</h3>

<p>Sampson (1969) recorded the social interactions among a group of monks while
he was a resident as an experimenter at the cloister.  During his stay, a
political &quot;crisis in the cloister&quot; resulted in the expulsion of four
monks&ndash; namely, the three &quot;outcasts,&quot; Brothers Elias, Simplicius, Basil, and
the leader of the &quot;young Turks,&quot; Brother Gregory.  Not long after Brother
Gregory departed, all but one of the &quot;young Turks&quot; left voluntarily:
Brothers John Bosco, Albert, Boniface, Hugh, and Mark.  Then, all three of
the &quot;waverers&quot; also left: First, Brothers Amand and Victor, then later
Brother Romuald.  Eventually, Brother Peter and Brother Winfrid also left,
leaving only four of the original group.
</p>
<p>Of particular interest are the data on positive affect relations
(&quot;liking,&quot; using the terminology later adopted by White et al. (1976)), in
which each monk was asked if he had positive relations to each of the other
monks. Each monk ranked only his top three choices (or four, in the case of
ties) on &quot;liking&quot;.  Here, we consider a directed edge from monk A to monk
B to exist if A nominated B among these top choices.
</p>
<p>The data were gathered at three times to capture changes in group sentiment
over time. They represent three time points in the period during which a new
cohort had entered the monastery near the end of the study but before the
major conflict began.  These three time points are labeled T2, T3, and T4 in
Tables D5 through D16 in the appendices of Sampson's 1969 dissertation.  and
the corresponding network data sets are named <code>samplk1</code>,
<code>samplk2</code>, and <code>samplk3</code>, respectively.
</p>
<p>See also the data set <code><a href="#topic+sampson">sampson</a></code> containing the time-aggregated
graph <code>samplike</code>.
</p>
<p><code>samplk3</code> is a data set of Hoff, Raftery and Handcock (2002).
</p>
<p>The data sets are stored as <code><a href="network.html#topic+network">network</a></code> objects with
three vertex attributes:
</p>
 <dl>
<dt>group</dt><dd><p>Groups of novices as classified by Sampson, that is,
&quot;Loyal&quot;, &quot;Outcasts&quot;, and &quot;Turks&quot;, but with a fourth group called the
&quot;Waverers&quot; by White et al. (1975) that comprises two of the original Loyal
opposition and one of the original Outcasts. See the <code><a href="#topic+samplike">samplike</a></code>
data set for the original classifications of these three waverers.</p>
</dd>
<dt>cloisterville</dt><dd><p>An indicator of attendance in the minor seminary of
&quot;Cloisterville&quot; before coming to the monastery.</p>
</dd> <dt>vertex.names</dt><dd><p>The
given names of the novices. NB: These names have been corrected as of
<code>ergm</code> version 3.6.1.</p>
</dd> </dl>
<p> This data set is standard in the social
network analysis literature, having been modeled by Holland and Leinhardt
(1981), Reitz (1982), Holland, Laskey and Leinhardt (1983), Fienberg, Meyer,
and Wasserman (1981), and Hoff, Raftery, and Handcock (2002), among others.
This is only a small piece of the data collected by Sampson.
</p>
<p>This data set was updated for version 2.5 (March 2012) to add the
<code>cloisterville</code> variable and refine the names. This information is from
de Nooy, Mrvar, and Batagelj (2005). The original vertex names were:
Romul_10, Bonaven_5, Ambrose_9, Berth_6, Peter_4, Louis_11, Victor_8,
Winf_12, John_1, Greg_2, Hugh_14, Boni_15, Mark_7, Albert_16, Amand_13,
Basil_3, Elias_17, Simp_18. The numbers indicate the ordering used in the
original dissertation of Sampson (1969).
</p>


<h3>Mislabeling in Versions Prior to 3.6.1</h3>

<p>In <code>ergm</code> versions
3.6.0 and earlier, The adjacency matrices of the <code><a href="#topic+samplike">samplike</a></code>,
<code><a href="#topic+samplk1">samplk1</a></code>, <code><a href="#topic+samplk2">samplk2</a></code>, and <code><a href="#topic+samplk3">samplk3</a></code>
networks reflected the original Sampson (1969) ordering of the names even
though the vertex labels used the name order of de Nooy, Mrvar, and Batagelj
(2005). That is, in <code>ergm</code> version 3.6.0 and earlier, the vertices were
mislabeled. The correct order is the same one given in Tables D5, D9, and
D13 of Sampson (1969): John Bosco, Gregory, Basil, Peter, Bonaventure,
Berthold, Mark, Victor, Ambrose, Romauld (Sampson uses both spellings
&quot;Romauld&quot; and &quot;Ramauld&quot; in the dissertation), Louis, Winfrid, Amand, Hugh,
Boniface, Albert, Elias, Simplicius. By contrast, the order given in
<code>ergm</code> version 3.6.0 and earlier is: Ramuald, Bonaventure, Ambrose,
Berthold, Peter, Louis, Victor, Winfrid, John Bosco, Gregory, Hugh,
Boniface, Mark, Albert, Amand, Basil, Elias, Simplicius.
</p>


<h3>Source</h3>

<p>Sampson, S.~F. (1968), <em>A novitiate in a period of change: An
experimental and case study of relationships,</em> Unpublished Ph.D.
dissertation, Department of Sociology, Cornell University.
</p>
<p><a href="http://vlado.fmf.uni-lj.si/pub/networks/data/esna/sampson.htm">http://vlado.fmf.uni-lj.si/pub/networks/data/esna/sampson.htm</a>
</p>


<h3>References</h3>

<p>White, H.C., Boorman, S.A. and Breiger, R.L. (1976).
<em>Social structure from multiple networks. I. Blockmodels of roles and
positions.</em> American Journal of Sociology, 81(4), 730-780.
</p>
<p>Wouter de Nooy, Andrej Mrvar, Vladimir Batagelj (2005) <em>Exploratory
Social Network Analysis with Pajek</em>, Cambridge: Cambridge University Press
</p>


<h3>See Also</h3>

<p>sampson, florentine, network, plot.network, ergm
</p>

<hr>
<h2 id='sampson'>Cumulative network of positive affection within a monastery as a &quot;network&quot;
object</h2><span id='topic+sampson'></span><span id='topic+samplike'></span>

<h3>Description</h3>

<p>A <code><a href="network.html#topic+network">network</a></code> object containing the cumulative &quot;liking&quot;
nominations of Sampson's (1969) monks over the three time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sampson)
</code></pre>


<h3>Details</h3>

<p>Sampson (1969) recorded the social interactions among a group of monks while
he was a resident as an experimenter at the cloister.  During his stay, a
political &quot;crisis in the cloister&quot; resulted in the expulsion of four
monks&ndash; namely, the three &quot;outcasts,&quot; Brothers Elias, Simplicius, Basil, and
the leader of the &quot;young Turks,&quot; Brother Gregory.  Not long after Brother
Gregory departed, all but one of the &quot;young Turks&quot; left voluntarily:
Brothers John Bosco, Albert, Boniface, Hugh, and Mark.  Then, all three of
the &quot;waverers&quot; also left: First, Brothers Amand and Victor, then later
Brother Romuald.  Eventually, Brother Peter and Brother Winfrid also left,
leaving only four of the original group.
</p>
<p>Of particular interest are the data on positive affect relations
(&quot;liking,&quot; using the terminology later adopted by White et al. (1976)), in
which each monk was asked if he had positive relations to each of the other
monks. Each monk ranked only his top three choices (or four, in the case of
ties) on &quot;liking&quot;.  Here, we consider a directed edge from monk A to monk
B to exist if A nominated B among these top choices.
</p>
<p>The data were gathered at three times to capture changes in group sentiment
over time. They represent three time points in the period during which a new
cohort had entered the monastery near the end of the study but before the
major conflict began.  These three time points are labeled T2, T3, and T4 in
Tables D5 through D16 in the appendices of Sampson's 1969 dissertation.  The
<code>samplike</code> data set is the time-aggregated network.  Thus, a tie from
monk A to monk B exists if A nominated B as one of his three (or four, in
case of ties) best friends at any of the three time points.
</p>
<p>See also the data sets <code><a href="#topic+samplk1">samplk1</a></code>, <code><a href="#topic+samplk2">samplk2</a></code>, and
<code><a href="#topic+samplk3">samplk3</a></code>, containing the networks at each of the three
individual time points.
</p>
<p>The data set is stored as a <code><a href="network.html#topic+network">network</a></code> object with three
vertex attributes:
</p>
 <dl>
<dt>group</dt><dd><p>Groups of novices as classified by Sampson:
&quot;Loyal&quot;, &quot;Outcasts&quot;, and &quot;Turks&quot;.</p>
</dd> <dt>cloisterville</dt><dd><p>An indicator
of attendance in the minor seminary of &quot;Cloisterville&quot; before coming to
the monastery.</p>
</dd> <dt>vertex.names</dt><dd><p>The given names of the novices.  NB:
These names have been corrected as of <code>ergm</code> version 3.6.1; see details
below.</p>
</dd> </dl>
<p> In addition, the data set has an edge attribute,
<code>nominations</code>, giving the number of times (out of 3) that monk A
nominated monk B.
</p>
<p>This data set is standard in the social network analysis literature, having
been modeled by Holland and Leinhardt (1981), Reitz (1982), Holland, Laskey
and Leinhardt (1983), Fienberg, Meyer, and Wasserman (1981), and Hoff,
Raftery, and Handcock (2002), among others. This is only a small piece of
the data collected by Sampson.
</p>
<p>This data set was updated for version 2.5 (March 2012) to add the
<code>cloisterville</code> variable and refine the names. This information is from
de Nooy, Mrvar, and Batagelj (2005). The original vertex names were:
Romul_10, Bonaven_5, Ambrose_9, Berth_6, Peter_4, Louis_11, Victor_8,
Winf_12, John_1, Greg_2, Hugh_14, Boni_15, Mark_7, Albert_16, Amand_13,
Basil_3, Elias_17, Simp_18. The numbers indicate the ordering used in the
original dissertation of Sampson (1969).
</p>


<h3>Mislabeling in Versions Prior to 3.6.1</h3>

<p>In <code>ergm</code> version
3.6.0 and earlier, The adjacency matrices of the <code><a href="#topic+samplike">samplike</a></code>,
<code><a href="#topic+samplk1">samplk1</a></code>, <code><a href="#topic+samplk2">samplk2</a></code>, and <code><a href="#topic+samplk3">samplk3</a></code>
networks reflected the original Sampson (1969) ordering of the names even
though the vertex labels used the name order of de Nooy, Mrvar, and Batagelj
(2005). That is, in <code>ergm</code> version 3.6.0 and earlier, the vertices were
mislabeled. The correct order is the same one given in Tables D5, D9, and
D13 of Sampson (1969): John Bosco, Gregory, Basil, Peter, Bonaventure,
Berthold, Mark, Victor, Ambrose, Romauld (Sampson uses both spellings
&quot;Romauld&quot; and &quot;Ramauld&quot; in the dissertation), Louis, Winfrid, Amand, Hugh,
Boniface, Albert, Elias, Simplicius. By contrast, the order given in
<code>ergm</code> version 3.6.0 and earlier is: Ramuald, Bonaventure, Ambrose,
Berthold, Peter, Louis, Victor, Winfrid, John Bosco, Gregory, Hugh,
Boniface, Mark, Albert, Amand, Basil, Elias, Simplicius.
</p>


<h3>Source</h3>

<p>Sampson, S.~F. (1968), <em>A novitiate in a period of change: An
experimental and case study of relationships,</em> Unpublished Ph.D.
dissertation, Department of Sociology, Cornell University.
</p>
<p><a href="http://vlado.fmf.uni-lj.si/pub/networks/data/esna/sampson.htm">http://vlado.fmf.uni-lj.si/pub/networks/data/esna/sampson.htm</a>
</p>


<h3>References</h3>

<p>White, H.C., Boorman, S.A. and Breiger, R.L. (1976).
<em>Social structure from multiple networks. I. Blockmodels of roles and
positions.</em> American Journal of Sociology, 81(4), 730-780.
</p>
<p>Wouter de Nooy, Andrej Mrvar, Vladimir Batagelj (2005) <em>Exploratory
Social Network Analysis with Pajek</em>, Cambridge: Cambridge University Press
</p>


<h3>See Also</h3>

<p>florentine, network, plot.network, ergm
</p>

<hr>
<h2 id='san'>Generate networks with a given set of network statistics</h2><span id='topic+san'></span><span id='topic+san.default'></span><span id='topic+san.formula'></span><span id='topic+san.ergm_model'></span>

<h3>Description</h3>

<p>This function attempts to find a network or networks whose statistics match
those passed in via the <code>target.stats</code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>san(object, ...)

## S3 method for class 'formula'
san(
  object,
  response = NULL,
  reference = ~Bernoulli,
  constraints = ~.,
  target.stats = NULL,
  nsim = NULL,
  basis = NULL,
  output = c("network", "edgelist", "ergm_state"),
  only.last = TRUE,
  control = control.san(),
  verbose = FALSE,
  offset.coef = NULL,
  ...
)

## S3 method for class 'ergm_model'
san(
  object,
  reference = ~Bernoulli,
  constraints = ~.,
  target.stats = NULL,
  nsim = NULL,
  basis = NULL,
  output = c("network", "edgelist", "ergm_state"),
  only.last = TRUE,
  control = control.san(),
  verbose = FALSE,
  offset.coef = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="san_+3A_object">object</code></td>
<td>
<p>Either a <code><a href="stats.html#topic+formula">formula</a></code> or some other supported
representation of an ERGM, such as an <code><a href="#topic+ergm_model">ergm_model</a></code> object.
<code><a href="stats.html#topic+formula">formula</a></code> should be of the form <code>y ~ &lt;model terms&gt;</code>, where
<code>y</code> is a network object or a matrix that can be coerced to a
<code><a href="network.html#topic+network">network</a></code> object.  For the details on the possible <code>&lt;model
  terms&gt;</code>, see <code><a href="#topic+ergmTerm">ergmTerm</a></code>.  To create a
<code><a href="network.html#topic+network">network</a></code> object in , use the
<code>network()</code> function, then add nodal attributes to it using
the <code>%v%</code> operator if necessary.</p>
</td></tr>
<tr><td><code id="san_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other functions.</p>
</td></tr>
<tr><td><code id="san_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="san_+3A_reference">reference</code></td>
<td>
<p>A one-sided formula specifying
the reference measure (<code class="reqn">h(y)</code>) to be used.
See help for <a href="#topic+ergm-references">ERGM reference measures</a> implemented in the
<strong><a href="#topic+ergm-package">ergm</a></strong> package.</p>
</td></tr>
<tr><td><code id="san_+3A_constraints">constraints</code></td>
<td>
<p>A formula specifying one or more constraints
on the support of the distribution of the networks being modeled. Multiple constraints
may be given, separated by &ldquo;+&rdquo; and &ldquo;-&rdquo; operators. See
<code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for the detailed explanation of
their semantics and also for an indexed list of the constraints visible to the <span class="pkg">ergm</span> package.
</p>
<p>The default is to have no constraints except those provided through
the <code><a href="#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>Together with the model terms in the formula and the reference measure, the constraints
define the distribution of networks being modeled.
</p>
<p>It is also possible to specify a proposal function directly either
by passing a string with the function's name (in which case,
arguments to the proposal should be specified through the
<code>MCMC.prop.args</code> argument to the relevant control function, or
by giving it on the LHS of the hints formula to <code>MCMC.prop</code>
argument to the control function. This will override
the one chosen automatically.
</p>
<p>Note that not all possible combinations of constraints and reference
measures are supported. However, for relatively simple constraints
(i.e., those that simply permit or forbid specific dyads or sets of
dyads from changing), arbitrary combinations should be possible.</p>
</td></tr>
<tr><td><code id="san_+3A_target.stats">target.stats</code></td>
<td>
<p>A vector of the same length as the number of non-offset statistics
implied by the formula.</p>
</td></tr>
<tr><td><code id="san_+3A_nsim">nsim</code></td>
<td>
<p>Number of networks to generate. Deprecated: just use <code><a href="base.html#topic+replicate">replicate()</a></code>.</p>
</td></tr>
<tr><td><code id="san_+3A_basis">basis</code></td>
<td>
<p>If not NULL, a <code>network</code> object used to start the Markov
chain.  If NULL, this is taken to be the network named in the formula.</p>
</td></tr>
<tr><td><code id="san_+3A_output">output</code></td>
<td>
<p>Character, one of <code>"network"</code> (default),
<code>"edgelist"</code>, or <code>"ergm_state"</code>: determines the
output format. Partial matching is performed.</p>
</td></tr>
<tr><td><code id="san_+3A_only.last">only.last</code></td>
<td>
<p>if <code>TRUE</code>, only return the last network generated;
otherwise, return a <code><a href="#topic+network.list">network.list</a></code> with <code>nsim</code> networks.</p>
</td></tr>
<tr><td><code id="san_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.san">control.san()</a></code>. Its documentation
gives the the list of recognized control parameters and their
meaning. The more generic utility <code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL)
also provides argument completion for the available control
functions and limited argument name checking.</p>
</td></tr>
<tr><td><code id="san_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="san_+3A_offset.coef">offset.coef</code></td>
<td>
<p>A vector of offset coefficients; these must be passed in by the user.
Note that these should be the same set of coefficients one would pass to <code>ergm</code> via
its <code>offset.coef</code> argument.</p>
</td></tr>
<tr><td><code id="san_+3A_formula">formula</code></td>
<td>
<p>(By default, the <code>formula</code> is taken from the <code>ergm</code>
object.  If a different <code>formula</code> object is wanted, specify it here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following description is an exegesis of section 4 of Krivitsky
et al. (2022).
</p>
<p>Let <code class="reqn">\mathbf{g}</code> be a vector of target statistics for the
network we wish to construct. That is, we are given an arbitrary network
<code class="reqn">\mathbf{y}^0 \in \mathcal{Y}</code>, and we seek a network
<code class="reqn">\mathbf{y} \in \mathcal{Y}</code> such that
<code class="reqn">\mathbf{g}(\mathbf{y}) \approx \mathbf{g}</code> &ndash; ideally equality is achieved,
but in practice we may have to settle for a close approximation. The
variant of simulated annealing is as follows.
</p>
<p>The energy function is defined
</p>
<p style="text-align: center;"><code class="reqn">E_W (\mathbf{y}) = (\mathbf{g}(\mathbf{y}) - \mathbf{g})^\mathsf{T} W (\mathbf{g}(\mathbf{y}) - \mathbf{g}),</code>
</p>

<p>with <code class="reqn">W</code> a symmetric positive (barring multicollinearity in statistics)
definite matrix of weights. This function achieves 0 only if the target is
reached. A good choice of this matrix yields a more efficient search.
</p>
<p>A standard simulated annealing loop is used, as described below, with some
modifications. In particular, we allow the user to specify a vector of
offsets <code class="reqn">\eta</code> to bias the annealing, with <code class="reqn">\eta_k = 0</code> 
denoting no offset. Offsets can be used with SAN to forbid certain
statistics from ever increasing or decreasing. As with <code><a href="#topic+ergm">ergm()</a></code>, offset
terms are specified using the <code><a href="stats.html#topic+offset">offset()</a></code> decorator and their coefficients
specified with the <code>offset.coef</code> argument. By default, finite offsets are
ignored by, but this can be overridden by setting the <code><a href="#topic+control.san">control.san()</a></code>
argument <code>SAN.ignore.finite.offsets = FALSE</code>.
</p>
<p>The number of simulated annealing runs is specified by the <code>SAN.maxit</code>
control parameter and the initial value of the temperature <code class="reqn">T</code> is set
to <code>SAN.tau</code>. The value of <code class="reqn">T</code> decreases linearly until <code class="reqn">T = 0</code>
at the last run, which implies that all proposals that increase
<code class="reqn">E_W (\mathbf{y})</code> are rejected. The weight matrix <code class="reqn">W</code>
is initially set to <code class="reqn">I_p / p</code>, where <code class="reqn">I_p</code> is the identity matrix
of an appropriate dimension. For weight <code class="reqn">W</code> and temperature <code class="reqn">T</code>,
the simulated annealing iteration proceeds as follows:
</p>

<ol>
<li><p> Test if <code class="reqn">E_W(\mathbf{y}) = 0</code>. If so, then exit.
</p>
</li>
<li><p> Generate a perturbed network <code class="reqn">\mathbf{y^*}</code> from a proposal that
respects the model constraints. (This is typically the same proposal as
that used for MCMC.)
</p>
</li>
<li><p> Store the quantity
<code class="reqn">\mathbf{g}(\mathbf{y^*}) - \mathbf{g}(\mathbf{y})</code>
for later use.
</p>
</li>
<li><p> Calculate acceptance probability
</p>
<p style="text-align: center;"><code class="reqn">\alpha = \exp[ - (E_W (\mathbf{y^*}) - E_W (\mathbf{y})) / T + \eta^\mathsf{T} (\mathbf{g}(\mathbf{y^*}) - \mathbf{g}(\mathbf{y}))]</code>
</p>

<p>(If <code class="reqn">|\eta_k| = \infty</code> and <code class="reqn">g_k (\mathbf{y^*}) - g_k (\mathbf{y}) = 0</code>, their product is defined to be 0.)
</p>
</li>
<li><p> Replace <code class="reqn">\mathbf{y}</code> with <code class="reqn">\mathbf{y^*}</code> with probability
<code class="reqn">\min(1, \alpha)</code>.
</p>
</li></ol>

<p>After the specified number of iterations, <code class="reqn">T</code> is updated as described
above, and <code class="reqn">W</code> is recalculated by first computing a matrix <code class="reqn">S</code>, the
sample covariance matrix of the proposed differences stored in Step 3
(i.e., whether or not they were rejected), then
<code class="reqn">W = S^+ / tr(S^+)</code>, where <code class="reqn">S^+</code> is the
Moore–Penrose pseudoinverse of <code class="reqn">S</code> and <code class="reqn">tr(S^+)</code> is the
trace of <code class="reqn">S^+</code>. The differences in Step 3 closely reflect the
relative variances and correlations among the network statistics.
</p>
<p>In Step 2, the many options for MCMC proposals can provide for effective
means of speeding the SAN algorithm's search for a viable network.
</p>


<h3>Value</h3>

<p>A network or list of networks that hopefully have network
statistics close to the <code>target.stats</code> vector. No guarantees
are provided about their probability distribution. Additionally,
<code><a href="#topic+attr">attr()</a></code>-style attributes <code>formula</code> and <code>stats</code> are included.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>san(formula)</code>: Sufficient statistics are specified by a <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
</li>
<li> <p><code>san(ergm_model)</code>: A lower-level function that expects a pre-initialized <code><a href="#topic+ergm_model">ergm_model</a></code>.
</p>
</li></ul>


<h3>References</h3>

<p>Krivitsky, P. N., Hunter, D. R., Morris, M., &amp; Klumb, C. (2022).
ergm 4: Computational Improvements. arXiv preprint arXiv:2203.08198.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# initialize x to a random undirected network with 50 nodes and a density of 0.1
x &lt;- network(50, density = 0.05, directed = FALSE)
 
# try to find a network on 50 nodes with 300 edges, 150 triangles,
# and 1250 4-cycles, starting from the network x
y &lt;- san(x ~ edges + triangles + cycle(4), target.stats = c(300, 150, 1250))

# check results
summary(y ~ edges + triangles + cycle(4))

# initialize x to a random directed network with 50 nodes
x &lt;- network(50)

# add vertex attributes
x %v% 'give' &lt;- runif(50, 0, 1)
x %v% 'take' &lt;- runif(50, 0, 1)

# try to find a set of 100 directed edges making the outward sum of
# 'give' and the inward sum of 'take' both equal to 62.5, so in
# edges (i,j) the node i tends to have above average 'give' and j
# tends to have above average 'take'
y &lt;- san(x ~ edges + nodeocov('give') + nodeicov('take'), target.stats = c(100, 62.5, 62.5))

# check results
summary(y ~ edges + nodeocov('give') + nodeicov('take'))


# initialize x to a random undirected network with 50 nodes
x &lt;- network(50, directed = FALSE)

# add a vertex attribute
x %v% 'popularity' &lt;- runif(50, 0, 1)

# try to find a set of 100 edges making the total sum of
# popularity(i) and popularity(j) over all edges (i,j) equal to
# 125, so nodes with higher popularity are more likely to be
# connected to other nodes
y &lt;- san(x ~ edges + nodecov('popularity'), target.stats = c(100, 125))
 
# check results
summary(y ~ edges + nodecov('popularity'))

# creates a network with denser "core" spreading out to sparser
# "periphery"
plot(y)

</code></pre>

<hr>
<h2 id='search.ergmTerms'>Search ERGM terms, constraints, references, hints, and proposals</h2><span id='topic+search.ergmTerms'></span><span id='topic+search.ergmConstraints'></span><span id='topic+search.ergmReferences'></span><span id='topic+search.ergmHints'></span><span id='topic+search.ergmProposals'></span>

<h3>Description</h3>

<p>Searches through the database of <code><a href="#topic+ergmTerm">ergmTerm</a></code>s,
<code><a href="#topic+ergmConstraint">ergmConstraint</a></code>s, <code><a href="#topic+ergmReference">ergmReference</a></code>s, <code><a href="#topic+ergmHint">ergmHint</a></code>s, and
<code><a href="#topic+ergmProposal">ergmProposal</a></code>s and prints out a list of terms and term-alikes
appropriate for the specified network's structural constraints,
optionally restricting by additional keywords and search term
matches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.ergmTerms(search, net, keywords, name, packages)

search.ergmConstraints(search, keywords, name, packages)

search.ergmReferences(search, keywords, name, packages)

search.ergmHints(search, keywords, name, packages)

search.ergmProposals(search, name, reference, constraints, packages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.ergmTerms_+3A_search">search</code></td>
<td>
<p>optional character search term to search for in the text of the
term descriptions. Only matching terms will be returned. Matching is case
insensitive.</p>
</td></tr>
<tr><td><code id="search.ergmTerms_+3A_net">net</code></td>
<td>
<p>a network object that the term would be applied to, used as
template to determine directedness, bipartite, etc</p>
</td></tr>
<tr><td><code id="search.ergmTerms_+3A_keywords">keywords</code></td>
<td>
<p>optional character vector of keyword tags to use to
restrict the results (i.e. 'curved', 'triad-related')</p>
</td></tr>
<tr><td><code id="search.ergmTerms_+3A_name">name</code></td>
<td>
<p>optional character name of a specific term to return</p>
</td></tr>
<tr><td><code id="search.ergmTerms_+3A_packages">packages</code></td>
<td>
<p>optional character vector indicating the subset of packages in which to search</p>
</td></tr>
<tr><td><code id="search.ergmTerms_+3A_reference">reference</code>, <code id="search.ergmTerms_+3A_constraints">constraints</code></td>
<td>
<p>optional names of references and constraints to narrow down the proposal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="base.html#topic+grep">grep</a></code> internally to match the search terms against the term
description, so <code>search</code> is currently matched as a single phrase.
Keyword tags will only return a match if all of the specified tags are
included in the term.
</p>


<h3>Value</h3>

<p>prints out the name and short description of matching terms, and
invisibly returns them as a list.  If <code>name</code> is specified, prints out
the full definition for the named term.
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ergmTerm">ergmTerm</a></code>,
<code><a href="#topic+ergmConstraint">ergmConstraint</a></code>, <code><a href="#topic+ergmReference">ergmReference</a></code>, <code><a href="#topic+ergmHint">ergmHint</a></code>, and
<code><a href="#topic+ergmProposal">ergmProposal</a></code>, for lists of terms and term-alikes visible to <span class="pkg">ergm</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# find all of the terms that mention triangles
search.ergmTerms('triangle')

# two ways to search for bipartite terms:

# search using a bipartite net as a template
myNet&lt;-network.initialize(5,bipartite=3)
search.ergmTerms(net=myNet)

# or request the bipartite keyword
search.ergmTerms(keywords='bipartite')

# search on multiple keywords
search.ergmTerms(keywords=c('bipartite','dyad-independent'))

# print out the content for a specific term
search.ergmTerms(name='b2factor')

# request the bipartite keyword in the ergm package
search.ergmTerms(keywords='bipartite', packages='ergm')


# find all of the constraint that mention degrees
search.ergmConstraints('degree')

# search for hints only
search.ergmConstraints(keywords='hint')

# search on multiple keywords
search.ergmConstraints(keywords=c('directed','dyad-independent'))

# print out the content for a specific constraint
search.ergmConstraints(name='b1degrees')

# request the bipartite keyword in the ergm package
search.ergmConstraints(keywords='directed', packages='ergm')


# find all discrete references
search.ergmReferences(keywords='discrete')


# find all of the hints
search.ergmHints('degree')


# find all of the proposals that mention triangles
search.ergmProposals('MH algorithm')

# print out the content for a specific proposals
search.ergmProposals(name='randomtoggle')

# find all proposals with required or optional constraints
search.ergmProposals(constraints='.dyads')

# find all proposals with references
search.ergmProposals(reference='Bernoulli')

# request proposals that mention triangle in the ergm package
search.ergmProposals('MH algorithm', packages='ergm')

</code></pre>

<hr>
<h2 id='sender-ergmTerm'>Sender effect</h2><span id='topic+sender-ergmTerm'></span><span id='topic+InitErgmTerm.sender'></span><span id='topic+InitWtErgmTerm.sender'></span>

<h3>Description</h3>

<p>This term adds one network statistic for each node equal to the number of
out-ties for that node. This measures the activity of the node. The term for
the first node is omitted by default because of linear dependence that
arises if this term is used together with <code>edges</code> , but its coefficient
can be computed as the negative of the sum of the coefficients of all the
other actors. That is, the average coefficient is zero, following the
Holland-Leinhardt parametrization of the $p_1$ model (Holland and Leinhardt,
1981).
</p>
<p>For undirected networks, see <code>sociality</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: sender(base=1, nodes=-1)

# valued: sender(base=1, nodes=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sender-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="sender-ergmTerm_+3A_nodes">nodes</code></td>
<td>
<p>specify which nodes' statistics should be included or excluded (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
<tr><td><code id="sender-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>nodes</code> are passed,
<code>nodes</code> overrides <code>base</code>.
</p>
<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, binary, valued</p>


<hr>
<h2 id='shrink_into_CH'>Identify the position of a point relative to the  convex hull of a set of points</h2><span id='topic+shrink_into_CH'></span>

<h3>Description</h3>

<p>This function uses linear programming to find the value by which
vector <code>p</code> needs to be scaled towards or away from vector <code>m</code> in
order for <code>p</code> to be on the boundary of the convex hull of rows of
<code>M</code>. If <code>p</code> is a matrix, a value that scales all rows of <code>p</code> into
the convex hull of <code>M</code> is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_into_CH(
  p,
  M,
  m = NULL,
  verbose = FALSE,
  ...,
  solver = c("glpk", "lpsolve")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink_into_CH_+3A_p">p</code></td>
<td>
<p>a <code class="reqn">d</code>-dimensional vector or a matrix with <code class="reqn">d</code>
columns.</p>
</td></tr>
<tr><td><code id="shrink_into_CH_+3A_m">M</code></td>
<td>
<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix.  Each row of <code>M</code> is a
<code class="reqn">d</code>-dimensional vector.</p>
</td></tr>
<tr><td><code id="shrink_into_CH_+3A_m">m</code></td>
<td>
<p>a <code class="reqn">d</code>-dimensional vector specifying the value towards
which to shrink; must be in the interior of the convex hull of
<code class="reqn">M</code>, and defaults to its centroid (column means).</p>
</td></tr>
<tr><td><code id="shrink_into_CH_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="shrink_into_CH_+3A_...">...</code></td>
<td>
<p>arguments passed directly to linear program solver.</p>
</td></tr>
<tr><td><code id="shrink_into_CH_+3A_solver">solver</code></td>
<td>
<p>a character string selecting which solver to use; by
default, tries <code>Rglpk</code>'s but falls back to <code>lpSolveAPI</code>'s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, telling whether <code>p</code> is (or all rows of
<code>p</code> are) in the closed convex hull of the points in
<code>M</code>.
</p>
<p>The scaling factor described above is
returned. <code>shrink_into_CH() &gt;= 1</code> indicates that all points in
<code>p</code> are in the convex hull of <code>M</code>.
</p>


<h3>Note</h3>

<p>This is a successor to the deprecated function <code>is.inCH()</code>, which
was originally written for the &quot;stepping&quot; algorithm of Hummel et al
(2012). See Krivitsky, Kuvelkar, and Hunter (2022) for detailed
discussion of algorithms used in <code>is.inCH()</code> and
<code>shrink_into_CH()</code>.
</p>


<h3>References</h3>

<p><a href="https://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node22.html">https://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node22.html</a>
</p>
<p>Hummel, R. M., Hunter, D. R., and Handcock, M. S. (2012), Improving
Simulation-Based Algorithms for Fitting ERGMs, <em>Journal of
Computational and Graphical Statistics</em>, 21: 920-939.
</p>
<p>Krivitsky, P. N., Kuvelkar, A. R., and Hunter,
D. R. (2022). Likelihood-based Inference for Exponential-Family
Random Graph Models via Linear Programming. <em>arXiv preprint</em>
arXiv:2202.03572. <a href="https://arxiv.org/abs/2202.03572">https://arxiv.org/abs/2202.03572</a>
</p>

<hr>
<h2 id='simmelian-ergmTerm'>Simmelian triads</h2><span id='topic+simmelian-ergmTerm'></span><span id='topic+InitErgmTerm.simmelian'></span>

<h3>Description</h3>

<p>This term adds one
statistic to the model equal to the number of Simmelian triads, as defined
by Krackhardt and Handcock (2007). This is a complete sub-graph of size
three.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: simmelian
</code></pre>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, binary</p>


<hr>
<h2 id='simmelianties-ergmTerm'>Ties in simmelian triads</h2><span id='topic+simmelianties-ergmTerm'></span><span id='topic+InitErgmTerm.simmelianties'></span>

<h3>Description</h3>

<p>This term adds
one statistic to the model equal to the number of ties in the network that
are associated with Simmelian triads, as defined by Krackhardt and Handcock
(2007). Each Simmelian has six ties in it but, because Simmelians can
overlap in terms of nodes (and associated ties), the total number of ties in
these Simmelians is less than six times the number of Simmelians. Hence this
is a measure of the clustering of Simmelians (given the number of
Simmelians).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: simmelianties
</code></pre>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, binary</p>


<hr>
<h2 id='simulate.ergm'>Draw from the distribution of an Exponential Family Random Graph Model</h2><span id='topic+simulate.ergm'></span><span id='topic+simulate.formula_lhs_network'></span><span id='topic+simulate.formula.ergm'></span><span id='topic+simulate_formula'></span><span id='topic+.simulate_formula.network'></span><span id='topic+simulate_formula.network'></span><span id='topic+simulate_formula.ergm_state'></span><span id='topic+simulate.ergm_model'></span><span id='topic+simulate.ergm_state_full'></span><span id='topic+simulate.ergm_state'></span>

<h3>Description</h3>

<p><code><a href="stats.html#topic+simulate">simulate</a></code> is used to draw from exponential
family random network models.  See <code><a href="#topic+ergm">ergm</a></code> for more
information on these models.
</p>
<p>The method for <code><a href="#topic+ergm">ergm</a></code> objects inherits the model,
the coefficients, the response attribute, the reference, the
constraints, and most simulation parameters from the model fit,
unless overridden by passing them explicitly. Unless overridden,
the simulation is initialized with either a random draw from near
the fitted model saved by <code><a href="#topic+ergm">ergm()</a></code> or, if unavailable, the
network to which the ERGM was fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula_lhs_network'
simulate(object, nsim = 1, seed = NULL, ...)

simulate_formula(object, ..., basis = eval_lhs.formula(object))

## S3 method for class 'network'
simulate_formula(
  object,
  nsim = 1,
  seed = NULL,
  coef,
  response = NULL,
  reference = ~Bernoulli,
  constraints = ~.,
  observational = FALSE,
  monitor = NULL,
  statsonly = FALSE,
  esteq = FALSE,
  output = c("network", "stats", "edgelist", "ergm_state"),
  simplify = TRUE,
  sequential = TRUE,
  control = control.simulate.formula(),
  verbose = FALSE,
  ...,
  basis = ergm.getnetwork(object),
  do.sim = NULL,
  return.args = NULL
)

## S3 method for class 'ergm_state'
simulate_formula(
  object,
  nsim = 1,
  seed = NULL,
  coef,
  response = NULL,
  reference = ~Bernoulli,
  constraints = ~.,
  observational = FALSE,
  monitor = NULL,
  statsonly = FALSE,
  esteq = FALSE,
  output = c("network", "stats", "edgelist", "ergm_state"),
  simplify = TRUE,
  sequential = TRUE,
  control = control.simulate.formula(),
  verbose = FALSE,
  ...,
  basis = ergm.getnetwork(object),
  do.sim = NULL,
  return.args = NULL
)

## S3 method for class 'ergm_model'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  coef,
  reference = if (is(constraints, "ergm_proposal")) NULL else trim_env(~Bernoulli),
  constraints = trim_env(~.),
  observational = FALSE,
  monitor = NULL,
  basis = NULL,
  esteq = FALSE,
  output = c("network", "stats", "edgelist", "ergm_state"),
  simplify = TRUE,
  sequential = TRUE,
  control = control.simulate.formula(),
  verbose = FALSE,
  ...,
  do.sim = NULL,
  return.args = NULL
)

## S3 method for class 'ergm_state_full'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  coef,
  esteq = FALSE,
  output = c("network", "stats", "edgelist", "ergm_state"),
  simplify = TRUE,
  sequential = TRUE,
  control = control.simulate.formula(),
  verbose = FALSE,
  ...,
  return.args = NULL
)

## S3 method for class 'ergm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  coef = coefficients(object),
  response = object$network %ergmlhs% "response",
  reference = object$reference,
  constraints = list(object$constraints, object$obs.constraints),
  observational = FALSE,
  monitor = NULL,
  basis = if (observational) object$network else NVL(object$newnetwork, object$network),
  statsonly = FALSE,
  esteq = FALSE,
  output = c("network", "stats", "edgelist", "ergm_state"),
  simplify = TRUE,
  sequential = TRUE,
  control = control.simulate.ergm(),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.ergm_+3A_object">object</code></td>
<td>
<p>Either a <code><a href="stats.html#topic+formula">formula</a></code> or an
<code><a href="#topic+ergm">ergm</a></code> object.  The <code><a href="stats.html#topic+formula">formula</a></code> should be of the form
<code>y ~ &lt;model terms&gt;</code>, where <code>y</code> is a network object or a matrix
that can be coerced to a <code><a href="network.html#topic+network">network</a></code> object.  For the
details on the possible <code>&lt;model terms&gt;</code>, see <code><a href="#topic+ergmTerm">ergmTerm</a></code>.
To create a <code><a href="network.html#topic+network">network</a></code> object in , use the
<code>network()</code> function, then add nodal attributes to it using the
<code>%v%</code> operator if necessary.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_nsim">nsim</code></td>
<td>
<p>Number of networks to be randomly drawn from the given
distribution on the set of all networks, returned by the Metropolis-Hastings
algorithm.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_basis">basis</code></td>
<td>
<p>a value (usually a <code><a href="network.html#topic+network">network</a></code>) to override the LHS of the formula.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_coef">coef</code></td>
<td>
<p>Vector of parameter values for the model from which the
sample is to be drawn.  If <code>object</code> is of class <code>ergm</code>,
the default value is the vector of estimated coefficients. Can be
set to <code>NULL</code> to bypass, but only if <code>return.args</code> below is used.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_reference">reference</code></td>
<td>
<p>A one-sided formula specifying
the reference measure (<code class="reqn">h(y)</code>) to be used.
See help for <a href="#topic+ergm-references">ERGM reference measures</a> implemented in the
<strong><a href="#topic+ergm-package">ergm</a></strong> package.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_constraints">constraints</code></td>
<td>
<p>A formula specifying one or more constraints
on the support of the distribution of the networks being modeled. Multiple constraints
may be given, separated by &ldquo;+&rdquo; and &ldquo;-&rdquo; operators. See
<code><a href="#topic+ergmConstraint">ergmConstraint</a></code> for the detailed explanation of
their semantics and also for an indexed list of the constraints visible to the <span class="pkg">ergm</span> package.
</p>
<p>The default is to have no constraints except those provided through
the <code><a href="#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>Together with the model terms in the formula and the reference measure, the constraints
define the distribution of networks being modeled.
</p>
<p>It is also possible to specify a proposal function directly either
by passing a string with the function's name (in which case,
arguments to the proposal should be specified through the
<code>MCMC.prop.args</code> argument to the relevant control function, or
by giving it on the LHS of the hints formula to <code>MCMC.prop</code>
argument to the control function. This will override
the one chosen automatically.
</p>
<p>Note that not all possible combinations of constraints and reference
measures are supported. However, for relatively simple constraints
(i.e., those that simply permit or forbid specific dyads or sets of
dyads from changing), arbitrary combinations should be possible.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_observational">observational</code></td>
<td>
<p>Inherit observational constraints rather than model
constraints.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_monitor">monitor</code></td>
<td>
<p>A one-sided formula specifying one or more terms
whose value is to be monitored. These terms are appended to the
model, along with a coefficient of 0, so their statistics are
returned. An <code><a href="#topic+ergm_model">ergm_model</a></code> objectcan be passed as well.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_statsonly">statsonly</code></td>
<td>
<p>Logical: If TRUE, return only the network statistics, not
the network(s) themselves. Deprecated in favor of <code style="white-space: pre;">&#8288;output=&#8288;</code>.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_esteq">esteq</code></td>
<td>
<p>Logical: If TRUE, compute the sample estimating equations of an
ERGM: if the model is non-curved, all non-offset statistics are returned
either way, but if the model is curved, the score estimating function values
(3.1) by Hunter and Handcock (2006) are returned instead.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_output">output</code></td>
<td>
<p>Normally character, one of <code>"network"</code> (default),
<code>"stats"</code>, <code>"edgelist"</code>, or <code>"ergm_state"</code>: determines the output
format. Partial matching is performed.
</p>
<p>Alternatively, a function with prototype
<code style="white-space: pre;">&#8288;function(ergm_state, chain, iter, ...)&#8288;</code> that is
called for each returned network, and its return value, rather
than the network itself, is stored. This can be used to, for
example, store the simulated networks to disk without storing
them in memory or compute network statistics not implemented
using the ERGM API, without having to store the networks
themselves.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_simplify">simplify</code></td>
<td>
<p>Logical: If <code>TRUE</code> the output is &quot;simplified&quot;:
sampled networks are returned in a single list, statistics from
multiple parallel chains are stacked, etc.. This makes it
consistent with behavior prior to <code>ergm</code> 3.10.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_sequential">sequential</code></td>
<td>
<p>Logical: If FALSE, each of the <code>nsim</code> simulated
Markov chains begins at the initial network.  If TRUE, the end of one
simulation is used as the start of the next.  Irrelevant when <code>nsim=1</code>.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
typically constructed with <code><a href="#topic+control.simulate.ergm">control.simulate.ergm()</a></code> or <code><a href="#topic+control.simulate.formula">control.simulate.formula()</a></code>, which have different
defaults. Their documentation gives the the list of recognized
control parameters and their meaning. The more generic utility
<code><a href="#topic+snctrl">snctrl()</a></code> (StatNet ConTRoL) also provides argument completion
for the available control functions and limited argument name
checking.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_do.sim">do.sim</code></td>
<td>
<p>Logical; a deprecated interface superseded by <code>return.args</code>,
that saves the inputs to the next level of the function.</p>
</td></tr>
<tr><td><code id="simulate.ergm_+3A_return.args">return.args</code></td>
<td>
<p>Character; if not <code>NULL</code>, the <code>simulate</code> method
for that particular class will, instead of proceeding for
simulation, instead return its arguments as a list that can be
passed as a second argument to <code><a href="base.html#topic+do.call">do.call()</a></code> or a lower-level
function such as <code><a href="#topic+ergm_MCMC_sample">ergm_MCMC_sample()</a></code>. This can be useful if, for
example, one wants to run several simulations with varying
coefficients and does not want to reinitialize the model and the
proposal every time. Valid inputs at this time are <code>"formula"</code>,
&quot;ergm_model&quot;, and one of the <code>"ergm_state"</code> classes, for the three
respective stopping points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sample of networks is randomly drawn from the specified model.  The model
is specified by the first argument of the function.  If the first argument
is a <code><a href="stats.html#topic+formula">formula</a></code> then this defines the model.  If the first
argument is the output of a call to <code><a href="#topic+ergm">ergm</a></code> then the model used
for that call is the one fit &ndash; and unless <code>coef</code> is specified, the
sample is from the MLE of the parameters.  If neither of those are given as
the first argument then a Bernoulli network is generated with the
probability of ties defined by <code>prob</code> or <code>coef</code>.
</p>
<p>Note that the first network is sampled after <code>burnin</code> steps,
and any subsequent networks are sampled each <code>interval</code> steps
after the first.
</p>
<p>More information can be found by looking at the documentation of
<code><a href="#topic+ergm">ergm</a></code>.
</p>


<h3>Value</h3>

<p>If <code>output=="stats"</code> an <code><a href="coda.html#topic+mcmc">mcmc</a></code> object containing the
simulated network statistics. If <code>control$parallel&gt;0</code>, an
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object. If <code>simplify=TRUE</code> (the default), these
would then be &quot;stacked&quot; and converted to a standard <code><a href="base.html#topic+matrix">matrix</a></code>. A
logical vector indicating whether or not the term had come from
the <code style="white-space: pre;">&#8288;monitor=&#8288;</code> formula is stored in <code><a href="#topic+attr">attr()</a></code>-style attribute
<code>"monitored"</code>.
</p>
<p>Otherwise, a representation of the simulated network is returned,
in the form specified by <code>output</code>. In addition to a network
representation or a list thereof, they have the following
<code><a href="#topic+attr">attr</a></code>-style attributes: </p>

<dl>
<dt><code>formula</code></dt><dd><p>The <code><a href="stats.html#topic+formula">formula</a></code> used to generate the
sample.</p>
</dd>
<dt><code>stats</code></dt><dd><p>An <code><a href="coda.html#topic+mcmc">mcmc</a></code> or <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object as above.</p>
</dd>
<dt><code>control</code></dt><dd><p>Control parameters used to generate the sample.</p>
</dd>
<dt><code>constraints</code></dt><dd><p>Constraints used to generate the sample.</p>
</dd>
<dt><code>reference</code></dt><dd><p>The reference measure for the sample.</p>
</dd>
<dt><code>monitor</code></dt><dd><p>The monitoring formula.</p>
</dd>
<dt><code>response</code></dt><dd><p>The edge attribute used as a response.</p>
</dd>
</dl>

<p>The following are the permitted network formats: </p>

<dl>
<dt><code>"network"</code></dt><dd><p>If <code>nsim==1</code>, an object of class
<code>network</code>.  If <code>nsim&gt;1</code>, it returns an object of class
<code><a href="#topic+network.list">network.list</a></code> (a list of networks) with the
above-listed additional attributes.</p>
</dd>
<dt><code>"edgelist"</code></dt><dd><p>An <code><a href="network.html#topic+edgelist">edgelist</a></code> representation of the network,
or a list thereof, depending on <code>nsim</code>.</p>
</dd>
<dt><code>"ergm_state"</code></dt><dd><p>A semi-internal representation of
a network consisting of a <code><a href="network.html#topic+network">network</a></code> object emptied of edges, with
an attached edgelist matrix, or a list thereof, depending on
<code>nsim</code>.</p>
</dd>
</dl>

<p>If <code>simplify==FALSE</code>, the networks are returned as a nested list,
with outer list being the parallel chain (including 1 for no
parallelism) and inner list being the samples within that chains
(including 1, if one network per chain). If <code>TRUE</code>, they are
concatenated, and if a total of one network had been simulated, the
network itself will be returned.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>simulate(ergm_state_full)</code>: a low-level function to simulate from an <code><a href="#topic+ergm_state">ergm_state</a></code> object.
</p>
</li></ul>


<h3>Note</h3>

<p>The actual <code><a href="network.html#topic+network">network</a></code> method for <code><a href="#topic+simulate_formula">simulate_formula()</a></code> is
actually called <code>.simulate_formula.network()</code> and is also
exported as an object. This allows it to be overridden by
extension packages, such as <code>tergm</code>, but also accessed directly
when needed.
</p>
<p><code><a href="#topic+simulate.ergm_model">simulate.ergm_model()</a></code> is a lower-level interface, providing
a <code><a href="stats.html#topic+simulate">simulate()</a></code> method for <code><a href="#topic+ergm_model">ergm_model</a></code> class. The <code>basis</code>
argument is required; <code>monitor</code>, if passed, must be an
<code><a href="#topic+ergm_model">ergm_model</a></code> as well; and <code>constraints</code> can be an
<code><a href="#topic+ergm_proposal">ergm_proposal</a></code> object instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm</a></code>, <code><a href="network.html#topic+network">network</a></code>,
<code><a href="#topic+ergm_MCMC_sample">ergm_MCMC_sample()</a></code> for a demonstration of <code style="white-space: pre;">&#8288;return.args=&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Let's draw from a Bernoulli model with 16 nodes
# and density 0.5 (i.e., coef = c(0,0))
#
g.sim &lt;- simulate(network(16) ~ edges + mutual, coef=c(0, 0))
#
# What are the statistics like?
#
summary(g.sim ~ edges + mutual)
#
# Now simulate a network with higher mutuality
#
g.sim &lt;- simulate(network(16) ~ edges + mutual, coef=c(0,2))
#
# How do the statistics look?
#
summary(g.sim ~ edges + mutual)
#
# Let's draw from a Bernoulli model with 16 nodes
# and tie probability 0.1
#
g.use &lt;- network(16,density=0.1,directed=FALSE)
#
# Starting from this network let's draw 3 realizations
# of a edges and 2-star network
#
g.sim &lt;- simulate(~edges+kstar(2), nsim=3, coef=c(-1.8,0.03),
               basis=g.use, control=control.simulate(
                 MCMC.burnin=1000,
                 MCMC.interval=100))
g.sim
summary(g.sim)
#
# attach the Florentine Marriage data
#
data(florentine)
#
# fit an edges and 2-star model using the ergm function
#
gest &lt;- ergm(flomarriage ~ edges + kstar(2))
summary(gest)
#
# Draw from the fitted model (statistics only), and observe the number
# of triangles as well.
#
g.sim &lt;- simulate(gest, nsim=10, 
            monitor=~triangles, output="stats",
            control=control.simulate.ergm(MCMC.burnin=1000, MCMC.interval=100))
g.sim

# Custom output: store the edgecount (computed in R), iteration index, and chain index.
output.f &lt;- function(x, iter, chain, ...){
  list(nedges = network.edgecount(as.network(x)),
       chain = chain, iter = iter)
}
g.sim &lt;- simulate(gest, nsim=3,
            output=output.f, simplify=FALSE,
            control=control.simulate.ergm(MCMC.burnin=1000, MCMC.interval=100))
unclass(g.sim)
</code></pre>

<hr>
<h2 id='simulate.formula'>A <code>simulate</code> Method for <code>formula</code> objects that dispatches based on the Left-Hand Side</h2><span id='topic+simulate.formula'></span><span id='topic+simulate.formula_lhs'></span>

<h3>Description</h3>

<p>This method evaluates the left-hand side (LHS) of the given formula and
dispatches it to an appropriate method based on the result by
setting an nonce class name on the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
simulate(object, nsim = 1, seed = NULL, ..., basis, newdata, data)

## S3 method for class 'formula_lhs'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.formula_+3A_object">object</code></td>
<td>
<p>a one- or two-sided <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_nsim">nsim</code>, <code id="simulate.formula_+3A_seed">seed</code></td>
<td>
<p>number of realisations to simulate and the random
seed to use; see <code><a href="stats.html#topic+simulate">simulate()</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_...">...</code></td>
<td>
<p>additional arguments to methods.</p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_basis">basis</code></td>
<td>
<p>if given, overrides the LHS of the formula for the
purposes of dispatching.</p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_newdata">newdata</code>, <code id="simulate.formula_+3A_data">data</code></td>
<td>
<p>if passed, the <code>object</code>'s LHS is evaluated in
this environment; at most one of the two may be passed.
</p>
<p>The dispatching works as follows:
</p>

<ol>
<li><p> If <code>basis</code> is not passed, and the formula has an LHS the
expression on the LHS of the formula in the <code>object</code> is
evaluated in the environment <code>newdata</code> or <code>data</code> (if given), in
any case enclosed by the environment of <code>object</code>. Otherwise,
<code>basis</code> is used.
</p>
</li>
<li><p> The result is set as an attribute <code>".Basis"</code> on <code>object</code>. If
there is no <code>basis</code> or LHS, it is not set.
</p>
</li>
<li><p> The class vector of <code>object</code> has <code>c("formula_lhs_<var>CLASS</var>", "formula_lhs")</code> prepended to it, where <var>CLASS</var> is the class
of the LHS value or <code>basis</code>. If LHS or <code>basis</code> has multiple
classes, they are all prepended; if there is no LHS or <code>basis</code>,
<code>c("formula_lhs_", "formula_lhs")</code> is.
</p>
</li>
<li> <p><code><a href="stats.html#topic+simulate">simulate()</a></code> generic is evaluated on the new <code>object</code>, with all
arguments passed on, excluding <code>basis</code>; if <code>newdata</code> or <code>data</code>
are missing, they too are not passed on. The evaluation takes
place in the parent's environment.
</p>
</li></ol>

<p>A &quot;method&quot; to receive a formula whose LHS evaluates to <var>CLASS</var>
can therefore be implemented by a function
<code style="white-space: pre;">&#8288;simulate.formula_lhs_\var{CLASS}()&#8288;</code>. This function can expect a
<code><a href="stats.html#topic+formula">formula</a></code> object, with additional attribute <code>.Basis</code> giving the
evaluated LHS (so that it does not need to be evaluated again).</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>simulate(formula_lhs)</code>: A function to catch the situation when there is no method implemented for the class to which the LHS evaluates.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.ergm">simulate.ergm()</a></code> family of functions, which uses this interface.
</p>

<hr>
<h2 id='smalldiff-ergmTerm'>Number of ties between actors with similar attribute values</h2><span id='topic+smalldiff-ergmTerm'></span><span id='topic+InitErgmTerm.smalldiff'></span>

<h3>Description</h3>

<p>This term adds one statistic, having as its
value the number of edges in the network for which the incident
actors' attribute values differ less than <code>cutoff</code> ; that is,
number of edges between <code>i</code> to <code>j</code> such that
<code>abs(attr[i]-attr[j])&lt;cutoff</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: smalldiff(attr, cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smalldiff-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="smalldiff-ergmTerm_+3A_maximum">maximum</code></td>
<td>
<p>difference in attribute values for ties to be considered</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, quantitative nodal attribute, undirected, binary</p>


<hr>
<h2 id='smallerthan-ergmTerm'>Number of dyads with values strictly smaller than a threshold</h2><span id='topic+smallerthan-ergmTerm'></span><span id='topic+InitWtErgmTerm.smallerthan'></span>

<h3>Description</h3>

<p>Adds the number of statistics equal to the length of <code>threshold</code>
equaling to the number of dyads whose values are exceeded by the
corresponding element of <code>threshold</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: smallerthan(threshold=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smallerthan-ergmTerm_+3A_threshold">threshold</code></td>
<td>
<p>vector of numerical values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected, valued</p>


<hr>
<h2 id='snctrl'>Statnet Control</h2><span id='topic+snctrl'></span>

<h3>Description</h3>

<p>A utility to facilitate argument completion of control lists, reexported from <code>statnet.common</code>.
</p>


<h3>Currently recognised control parameters</h3>

<p>This list is updated as packages are loaded and unloaded.
</p>


<h4>Package <span class="pkg">ergm</span></h4>

<dl>
<dt><code><a href="#topic+control.ergm">control.ergm</a></code></dt><dd><p><code>drop, init, init.method, main.method, force.main, main.hessian,
             checkpoint, resume, MPLE.samplesize, init.MPLE.samplesize,
             MPLE.type, MPLE.maxit, MPLE.nonvar, MPLE.nonident,
             MPLE.nonident.tol, MPLE.covariance.samplesize,
             MPLE.covariance.method, MPLE.covariance.sim.burnin,
             MPLE.covariance.sim.interval, MPLE.constraints.ignore,
             MCMC.prop, MCMC.prop.weights, MCMC.prop.args,
             MCMC.interval, MCMC.burnin, MCMC.samplesize,
             MCMC.effectiveSize, MCMC.effectiveSize.damp,
             MCMC.effectiveSize.maxruns,
             MCMC.effectiveSize.burnin.pval,
             MCMC.effectiveSize.burnin.min,
             MCMC.effectiveSize.burnin.max,
             MCMC.effectiveSize.burnin.nmin,
             MCMC.effectiveSize.burnin.nmax,
             MCMC.effectiveSize.burnin.PC,
             MCMC.effectiveSize.burnin.scl,
             MCMC.effectiveSize.order.max, MCMC.return.stats,
             MCMC.runtime.traceplot, MCMC.maxedges, MCMC.addto.se,
             MCMC.packagenames, SAN.maxit, SAN.nsteps.times, SAN,
             MCMLE.termination, MCMLE.maxit, MCMLE.conv.min.pval,
             MCMLE.confidence, MCMLE.confidence.boost,
             MCMLE.confidence.boost.threshold,
             MCMLE.confidence.boost.lag, MCMLE.NR.maxit,
             MCMLE.NR.reltol, obs.MCMC.mul, obs.MCMC.samplesize.mul,
             obs.MCMC.samplesize, obs.MCMC.effectiveSize,
             obs.MCMC.interval.mul, obs.MCMC.interval,
             obs.MCMC.burnin.mul, obs.MCMC.burnin, obs.MCMC.prop,
             obs.MCMC.prop.weights, obs.MCMC.prop.args,
             obs.MCMC.impute.min_informative,
             obs.MCMC.impute.default_density, MCMLE.min.depfac,
             MCMLE.sampsize.boost.pow, MCMLE.MCMC.precision,
             MCMLE.MCMC.max.ESS.frac, MCMLE.metric, MCMLE.method,
             MCMLE.dampening, MCMLE.dampening.min.ess,
             MCMLE.dampening.level, MCMLE.steplength.margin,
             MCMLE.steplength, MCMLE.steplength.parallel,
             MCMLE.sequential, MCMLE.density.guard.min,
             MCMLE.density.guard, MCMLE.effectiveSize,
             obs.MCMLE.effectiveSize, MCMLE.interval, MCMLE.burnin,
             MCMLE.samplesize.per_theta, MCMLE.samplesize.min,
             MCMLE.samplesize, obs.MCMLE.samplesize.per_theta,
             obs.MCMLE.samplesize.min, obs.MCMLE.samplesize,
             obs.MCMLE.interval, obs.MCMLE.burnin,
             MCMLE.steplength.solver, MCMLE.last.boost,
             MCMLE.steplength.esteq, MCMLE.steplength.miss.sample,
             MCMLE.steplength.min, MCMLE.effectiveSize.interval_drop,
             MCMLE.save_intermediates, MCMLE.nonvar, MCMLE.nonident,
             MCMLE.nonident.tol, SA.phase1_n, SA.initial_gain,
             SA.nsubphases, SA.min_iterations, SA.max_iterations,
             SA.phase3_n, SA.interval, SA.burnin, SA.samplesize,
             CD.samplesize.per_theta, obs.CD.samplesize.per_theta,
             CD.nsteps, CD.multiplicity, CD.nsteps.obs,
             CD.multiplicity.obs, CD.maxit, CD.conv.min.pval,
             CD.NR.maxit, CD.NR.reltol, CD.metric, CD.method,
             CD.dampening, CD.dampening.min.ess, CD.dampening.level,
             CD.steplength.margin, CD.steplength, CD.adaptive.epsilon,
             CD.steplength.esteq, CD.steplength.miss.sample,
             CD.steplength.min, CD.steplength.parallel,
             CD.steplength.solver, loglik, term.options, seed,
             parallel, parallel.type, parallel.version.check,
             parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="#topic+control.ergm.bridge">control.ergm.bridge</a></code></dt><dd><p><code>bridge.nsteps, bridge.target.se, bridge.bidirectional, MCMC.burnin,
                    MCMC.burnin.between, MCMC.interval,
                    MCMC.samplesize, obs.MCMC.burnin,
                    obs.MCMC.burnin.between, obs.MCMC.interval,
                    obs.MCMC.samplesize, MCMC.prop, MCMC.prop.weights,
                    MCMC.prop.args, obs.MCMC.prop,
                    obs.MCMC.prop.weights, obs.MCMC.prop.args,
                    MCMC.maxedges, MCMC.packagenames, term.options,
                    seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="#topic+control.ergm.godfather">control.ergm.godfather</a></code></dt><dd><p><code>term.options</code></p>
</dd><dt><code><a href="#topic+control.gof.ergm">control.gof.ergm</a></code></dt><dd><p><code>nsim, MCMC.burnin, MCMC.interval, MCMC.batch, MCMC.prop,
                 MCMC.prop.weights, MCMC.prop.args, MCMC.maxedges,
                 MCMC.packagenames, MCMC.runtime.traceplot,
                 network.output, seed, parallel, parallel.type,
                 parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="#topic+control.gof.formula">control.gof.formula</a></code></dt><dd><p><code>nsim, MCMC.burnin, MCMC.interval, MCMC.batch, MCMC.prop,
                    MCMC.prop.weights, MCMC.prop.args, MCMC.maxedges,
                    MCMC.packagenames, MCMC.runtime.traceplot,
                    network.output, seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="#topic+control.logLik.ergm">control.logLik.ergm</a></code></dt><dd><p><code>bridge.nsteps, bridge.target.se, bridge.bidirectional, MCMC.burnin,
                    MCMC.interval, MCMC.samplesize,
                    obs.MCMC.samplesize, obs.MCMC.interval,
                    obs.MCMC.burnin, MCMC.prop, MCMC.prop.weights,
                    MCMC.prop.args, obs.MCMC.prop,
                    obs.MCMC.prop.weights, obs.MCMC.prop.args,
                    MCMC.maxedges, MCMC.packagenames, term.options,
                    seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="#topic+control.san">control.san</a></code></dt><dd><p><code>SAN.maxit, SAN.tau, SAN.invcov, SAN.invcov.diag, SAN.nsteps.alloc,
            SAN.nsteps, SAN.samplesize, SAN.prop, SAN.prop.weights,
            SAN.prop.args, SAN.packagenames, SAN.ignore.finite.offsets,
            term.options, seed, parallel, parallel.type,
            parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="#topic+control.simulate">control.simulate</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                 MCMC.prop.args, MCMC.batch, MCMC.effectiveSize,
                 MCMC.effectiveSize.damp, MCMC.effectiveSize.maxruns,
                 MCMC.effectiveSize.burnin.pval,
                 MCMC.effectiveSize.burnin.min,
                 MCMC.effectiveSize.burnin.max,
                 MCMC.effectiveSize.burnin.nmin,
                 MCMC.effectiveSize.burnin.nmax,
                 MCMC.effectiveSize.burnin.PC,
                 MCMC.effectiveSize.burnin.scl,
                 MCMC.effectiveSize.order.max, MCMC.maxedges,
                 MCMC.packagenames, MCMC.runtime.traceplot,
                 network.output, term.options, parallel, parallel.type,
                 parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="#topic+control.simulate.ergm">control.simulate.ergm</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.scale, MCMC.prop, MCMC.prop.weights,
                      MCMC.prop.args, MCMC.batch, MCMC.effectiveSize,
                      MCMC.effectiveSize.damp,
                      MCMC.effectiveSize.maxruns,
                      MCMC.effectiveSize.burnin.pval,
                      MCMC.effectiveSize.burnin.min,
                      MCMC.effectiveSize.burnin.max,
                      MCMC.effectiveSize.burnin.nmin,
                      MCMC.effectiveSize.burnin.nmax,
                      MCMC.effectiveSize.burnin.PC,
                      MCMC.effectiveSize.burnin.scl,
                      MCMC.effectiveSize.order.max, MCMC.maxedges,
                      MCMC.packagenames, MCMC.runtime.traceplot,
                      network.output, term.options, parallel,
                      parallel.type, parallel.version.check,
                      parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="#topic+control.simulate.formula">control.simulate.formula</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                         MCMC.prop.args, MCMC.batch,
                         MCMC.effectiveSize, MCMC.effectiveSize.damp,
                         MCMC.effectiveSize.maxruns,
                         MCMC.effectiveSize.burnin.pval,
                         MCMC.effectiveSize.burnin.min,
                         MCMC.effectiveSize.burnin.max,
                         MCMC.effectiveSize.burnin.nmin,
                         MCMC.effectiveSize.burnin.nmax,
                         MCMC.effectiveSize.burnin.PC,
                         MCMC.effectiveSize.burnin.scl,
                         MCMC.effectiveSize.order.max, MCMC.maxedges,
                         MCMC.packagenames, MCMC.runtime.traceplot,
                         network.output, term.options, parallel,
                         parallel.type, parallel.version.check,
                         parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="#topic+control.simulate.formula.ergm">control.simulate.formula.ergm</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                              MCMC.prop.args, MCMC.batch,
                              MCMC.effectiveSize,
                              MCMC.effectiveSize.damp,
                              MCMC.effectiveSize.maxruns,
                              MCMC.effectiveSize.burnin.pval,
                              MCMC.effectiveSize.burnin.min,
                              MCMC.effectiveSize.burnin.max,
                              MCMC.effectiveSize.burnin.nmin,
                              MCMC.effectiveSize.burnin.nmax,
                              MCMC.effectiveSize.burnin.PC,
                              MCMC.effectiveSize.burnin.scl,
                              MCMC.effectiveSize.order.max,
                              MCMC.maxedges, MCMC.packagenames,
                              MCMC.runtime.traceplot, network.output,
                              term.options, parallel, parallel.type,
                              parallel.version.check,
                              parallel.inherit.MT, ...</code></p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="statnet.common.html#topic+snctrl">statnet.common::snctrl()</a></code>
</p>

<hr>
<h2 id='sociality-ergmTerm'>Undirected degree</h2><span id='topic+sociality-ergmTerm'></span><span id='topic+InitErgmTerm.sociality'></span><span id='topic+InitWtErgmTerm.sociality'></span>

<h3>Description</h3>

<p>This term adds one network statistic for each node equal to the number of
ties of that node. For directed networks, see <code>sender</code> and
<code>receiver</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: sociality(attr=NULL, base=1, levels=NULL, nodes=-1)

# valued: sociality(attr=NULL, base=1, levels=NULL, nodes=-1, form="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sociality-ergmTerm_+3A_attr">attr</code>, <code id="sociality-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>this optional argument is deprecated and will be replaced with a more elegant implementation in a future release. In the meantime, it specifies a categorical vertex attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details). If provided, this term only counts ties between nodes with the same value of the attribute (an actor-specific version of the <code>nodematch</code> term), restricted to be one of the values specified by (also deprecated) <code>levels</code> if <code>levels</code> is not <code>NULL</code> .</p>
</td></tr>
<tr><td><code id="sociality-ergmTerm_+3A_base">base</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="sociality-ergmTerm_+3A_nodes">nodes</code></td>
<td>
<p>By default, <code>nodes=-1</code> means that the statistic for the
first node will be omitted, but this argument may be changed to control
which statistics are included just as for the <code>nodes</code> argument of <code>sender</code> and
<code>receiver</code> terms.</p>
</td></tr>
<tr><td><code id="sociality-ergmTerm_+3A_form">form</code></td>
<td>
<p>character how to aggregate tie values in a valued ERGM</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>base</code>.
</p>
<p>The argument <code>base</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>base</code> and <code>nodes</code> are passed,
<code>nodes</code> overrides <code>base</code>.
</p>
<p>This term can only be used with undirected networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, dyad-independent, undirected, binary, valued</p>


<hr>
<h2 id='sparse-ergmHint'>Sparse network</h2><span id='topic+sparse-ergmHint'></span><span id='topic+InitErgmConstraint.sparse'></span><span id='topic+sparse-ergmConstraint'></span>

<h3>Description</h3>

<p>The network is sparse. This typically results in a Tie-Non-Tie (TNT) proposal regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># sparse
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmHint">ergmHint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>dyad-independent</p>


<hr>
<h2 id='spectrum0.mvar'>Multivariate version of <code>coda</code>'s <code><a href="coda.html#topic+spectrum0.ar">spectrum0.ar()</a></code>.</h2><span id='topic+spectrum0.mvar'></span>

<h3>Description</h3>

<p>Its return value, divided by <code>nrow(cbind(x))</code>, is the estimated
variance-covariance matrix of the sampling distribution of the mean
of <code>x</code> if <code>x</code> is a multivatriate time series with AR(<code class="reqn">p</code>) structure, with
<code class="reqn">p</code> determined by AIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrum0.mvar(
  x,
  order.max = NULL,
  aic = is.null(order.max),
  tol = .Machine$double.eps^0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrum0.mvar_+3A_x">x</code></td>
<td>
<p>a matrix with observations in rows and variables in
columns.</p>
</td></tr>
<tr><td><code id="spectrum0.mvar_+3A_order.max">order.max</code></td>
<td>
<p>maximum (or fixed) order for the AR model.</p>
</td></tr>
<tr><td><code id="spectrum0.mvar_+3A_aic">aic</code></td>
<td>
<p>use AIC to select the order (up to <code>order.max</code>).</p>
</td></tr>
<tr><td><code id="spectrum0.mvar_+3A_tol">tol</code></td>
<td>
<p>drop components until the reciprocal condition number of
the transformed variance-covariance matrix is greater than this.</p>
</td></tr>
<tr><td><code id="spectrum0.mvar_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="stats.html#topic+ar">ar()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix with dimension equalling to the number of
columns of <code>x</code>, with an additional attribute <code>"infl"</code> giving the
factor by which the effective sample size is reduced due to
autocorrelation, according to the Vats, Flegal, and Jones (2015)
estimate for ESS.
</p>


<h3>Note</h3>

<p><code><a href="stats.html#topic+ar">ar()</a></code> fails if <code>crossprod(x)</code> is singular,
which is remedied by mapping the variables onto the principal
components of <code>x</code>, dropping redundant dimentions.
</p>

<hr>
<h2 id='StdNormal-ergmProposal'>TODO</h2><span id='topic+StdNormal-ergmProposal'></span><span id='topic+InitWtErgmProposal.StdNormal'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='StdNormal-ergmReference'>Standard Normal reference</h2><span id='topic+StdNormal-ergmReference'></span><span id='topic+InitErgmReference.StdNormal'></span>

<h3>Description</h3>

<p>Specifies each dyad's baseline distribution to be the normal distribution
with mean 0 and variance 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># StdNormal
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmReference">ergmReference</a></code> for index of reference distributions currently visible to the package.
</p>


<h4>Keywords</h4>

<p>continuous</p>


<hr>
<h2 id='strat-ergmHint'>Stratify Proposed Toggles by Mixing Type on a Vertex Attribute</h2><span id='topic+strat-ergmHint'></span><span id='topic+InitErgmConstraint.strat'></span><span id='topic+strat-ergmConstraint'></span>

<h3>Description</h3>

<p>Proposed toggles are stratified according to mixing type
on a vertex attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># strat(attr=NULL, pmat=NULL, empirical=FALSE)
</code></pre>


<h3>Details</h3>

<p>The user may pass a vertex attribute <code>attr</code> as an argument
(the default for <code>attr</code> gives every vertex the same attribute
value), and may also pass a matrix of weights <code>pmat</code> (the default
for <code>pmat</code> gives equal weight to each mixing type). See
<a href="#topic+nodal_attributes">Specifying Vertex Attributes and Levels for details</a> on specifying vertex attributes. The
matrix <code>pmat</code>, if specified, must have the same dimensions as a
mixing matrix for the network and vertex attribute under
consideration, and the correspondence between rows and columns of
<code>pmat</code> and values of <code>attr</code> is the same as for a mixing matrix.
</p>
<p>The interpretation is that <code>pmat[i,j]/sum(pmat)</code> is the probability of
proposing a toggle for mixing type <code style="white-space: pre;">&#8288;(i,j)&#8288;</code>. (For undirected, unipartite
networks, <code>pmat</code> is first symmetrized, and then entries below the diagonal
are set to zero. Only entries on or above the diagonal of the symmetrized
<code>pmat</code> are considered when making proposals. This accounts for the
convention that mixing is undirected in an undirected, unipartite network:
a tail of type <code>i</code> and a head of type <code>j</code> has the same mixing type
as a tail of type <code>j</code> and a head of type <code>i</code>.)
</p>
<p>As an alternative way of specifying <code>pmat</code>, the user may pass
<code>empirical = TRUE</code> to use the mixing matrix of the network beginning
the MCMC chain as <code>pmat</code>. In order for this to work, that network should
have a reasonable (in particular, nonempty) edge set.
</p>
<p>While some mixing types may be assigned zero proposal probability
(either with a direct specification of <code>pmat</code> or with <code>empirical = TRUE</code>),
this will not be recognized as a constraint by all components of <code>ergm</code>,
and should be used with caution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmHint">ergmHint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>dyad-independent</p>


<hr>
<h2 id='sum-ergmTerm'>Sum of dyad values (optionally taken to a power)</h2><span id='topic+sum-ergmTerm'></span><span id='topic+InitWtErgmTerm.sum'></span>

<h3>Description</h3>

<p>This term adds one statistic equal to the sum of
dyad values taken to the power <code>pow</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: sum(pow=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum-ergmTerm_+3A_pow">pow</code></td>
<td>
<p>power of dyad values. Defaults to 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected, valued</p>


<hr>
<h2 id='Sum-ergmTerm'>A sum (or an arbitrary linear combination) of one or more formulas</h2><span id='topic+Sum-ergmTerm'></span><span id='topic+InitErgmTerm.Sum'></span><span id='topic+InitWtErgmTerm.Sum'></span>

<h3>Description</h3>

<p>This operator sums up the RHS statistics of the input formulas elementwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Sum(formulas, label)

# valued: Sum(formulas, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sum-ergmTerm_+3A_formulas">formulas</code></td>
<td>
<p>a list (constructed using <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>) of <code><a href="#topic+ergm">ergm()</a></code>-style formulas whose RHS gives the statistics to be evaluated, or a single formula.
</p>
<p>If a formula in the list has an LHS, it is interpreted as follows:
</p>

<ul>
<li><p> a numeric scalar: Network statistics of this formula will be multiplied by this.
</p>
</li>
<li><p> a numeric vector: Corresponding network statistics of this formula will be multiplied by this.
</p>
</li>
<li><p> a numeric matrix: Vector of network statistics will be pre-multiplied by this.
</p>
</li>
<li><p> a character string: One of several predefined linear combinations. Currently supported presets are as follows:
</p>

<ul>
<li> <p><code>"sum"</code> Network statistics of this formula will be summed up; equivalent to <code>matrix(1,1,p)</code> , where <code>p</code> is the length of the network statistic vector.
</p>
</li>
<li> <p><code>"mean"</code> Network statistics of this formula will be averaged; equivalent to <code>matrix(1/p,1,p)</code> , where <code>p</code> is the length of the network statistic vector.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="Sum-ergmTerm_+3A_label">label</code></td>
<td>
<p>used to specify the names of the elements of the resulting term sum vector. If <code>label</code> is a character vector of length 1,
it will be recycled with indices appended. If a function is specified, <code>formulas</code> parameter names are extracted and their list of character vectors is passed <code>label</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that each formula must either produce the same number of
statistics or be mapped through a matrix to produce the same
number of statistics.
</p>
<p>A single formula is also permitted. This can be useful if one
wishes to, say, scale or sum up the statistics returned by a formula.
</p>
<p>Offsets are ignored unless there is only one formula and the transformation only scales the statistics (i.e., the effective transformation matrix is diagonal).
</p>
<p>Curved models are supported, subject to some limitations. In particular, the first model's etamap will be used, overwriting the others. If <code>label</code> is not of length 1, it should have an <code>attr</code> -style attribute <code>"curved"</code> specifying the names for the curved parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>operator, binary, valued</p>


<hr>
<h2 id='summary_formula'>Dispatching a summary function based on the class of the LHS of a
formula.</h2><span id='topic+summary_formula'></span><span id='topic+summary_formula.ergm'></span><span id='topic+summary_formula.network.list'></span><span id='topic+summary_formula.network'></span><span id='topic+summary_formula.ergm_state'></span><span id='topic+summary_formula.matrix'></span><span id='topic+summary_formula.default'></span>

<h3>Description</h3>

<p>The generic <code><a href="#topic+summary_formula">summary_formula()</a></code> (note the underscore) expects a
formula argument and will attempt to identify the class of the LHS
of the formula and dispatch to the appropriate <code>summary_formula</code>
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_formula(object, ..., basis = NULL)

## S3 method for class 'ergm'
summary_formula(object, ..., basis = NULL)

## S3 method for class 'network.list'
summary_formula(object, response = NULL, ..., basis = eval_lhs.formula(object))

## S3 method for class 'network'
summary_formula(object, response = NULL, ..., basis = ergm.getnetwork(object))

## S3 method for class 'ergm_state'
summary_formula(object, ..., basis = NULL)

## S3 method for class 'matrix'
summary_formula(object, response = NULL, ..., basis = ergm.getnetwork(object))

## Default S3 method:
summary_formula(object, response = NULL, ..., basis = ergm.getnetwork(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_formula_+3A_object">object</code></td>
<td>
<p>A two-sided formula.</p>
</td></tr>
<tr><td><code id="summary_formula_+3A_...">...</code></td>
<td>
<p>further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="summary_formula_+3A_basis">basis</code></td>
<td>
<p>Optional object of the same class as the LHS of the formula, substituted in place of the LHS.</p>
</td></tr>
<tr><td><code id="summary_formula_+3A_response">response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt><dd><p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt><dd><p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code><a href="base.html#topic+logical">logical</a></code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code><a href="base.html#topic+numeric">numeric</a></code> for valued.</p>
</dd>
<dt>a formula</dt><dd><p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of statistics measured on the network.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>summary_formula(ergm)</code>: an <code><a href="#topic+ergm">ergm</a></code> fit method, extracting its model from the fit.
</p>
</li>
<li> <p><code>summary_formula(network.list)</code>: a method for a <code><a href="#topic+network.list">network.list</a></code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(network)</code>: a method for a <code><a href="network.html#topic+network">network</a></code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(ergm_state)</code>: a method for the semi-internal <code><a href="#topic+ergm_state">ergm_state</a></code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(matrix)</code>: a method for a <code><a href="base.html#topic+matrix">matrix</a></code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(default)</code>: a fallback method.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm()</a></code>, <code><a href="network.html#topic+network">network()</a></code>, <code><a href="#topic+ergmTerm">ergmTerm</a></code>
</p>
<p><code><a href="#topic+summary.ergm_model">summary.ergm_model()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Lets look at the Florentine marriage data
#
data(florentine)
#
# test the summary_formula function
#
summary(flomarriage ~ edges + kstar(2))
m &lt;- as.matrix(flomarriage)
summary(m ~ edges)  # twice as large as it should be
summary(m ~ edges, directed=FALSE) # Now it's correct

</code></pre>

<hr>
<h2 id='summary.ergm'>Summarizing ERGM Model Fits</h2><span id='topic+summary.ergm'></span><span id='topic+print.summary.ergm'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">base::summary()</a></code> method for <code><a href="#topic+ergm">ergm()</a></code> fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm'
summary(
  object,
  ...,
  correlation = FALSE,
  covariance = FALSE,
  total.variation = TRUE
)

## S3 method for class 'summary.ergm'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  correlation = x$correlation,
  covariance = x$covariance,
  signif.stars = getOption("show.signif.stars"),
  eps.Pvalue = 1e-04,
  print.formula = FALSE,
  print.fitinfo = TRUE,
  print.coefmat = TRUE,
  print.message = TRUE,
  print.deviances = TRUE,
  print.drop = TRUE,
  print.offset = TRUE,
  print.call = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ergm_+3A_object">object</code></td>
<td>
<p>an object of class <code>ergm</code>, usually, a result of a call to
<code><a href="#topic+ergm">ergm()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+summary.ergm">summary.ergm()</a></code> additional arguments are passed to
<code><a href="#topic+logLik.ergm">logLik.ergm()</a></code>. For <code><a href="#topic+print.summary.ergm">print.summary.ergm()</a></code>, to <code><a href="stats.html#topic+printCoefmat">stats::printCoefmat()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the
estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_covariance">covariance</code></td>
<td>
<p>logical; if <code>TRUE</code>, the covariance matrix of the estimated
parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_total.variation">total.variation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the standard errors reported in
the <code style="white-space: pre;">&#8288;Std. Error&#8288;</code> column are based on the sum of the likelihood variation
and the MCMC variation. If <code>FALSE</code> only the likelihood variation is used.
The <code class="reqn">p</code>-values are based on this source of variation.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_x">x</code></td>
<td>
<p>object of class <code>summary.ergm</code> returned by <code><a href="#topic+summary.ergm">summary.ergm()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_digits">digits</code></td>
<td>
<p>significant digits for coefficients</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>whether to print dots and stars to signify
statistical significance. See <code><a href="stats.html#topic+print.summary.lm">print.summary.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_eps.pvalue">eps.Pvalue</code></td>
<td>
<p><code class="reqn">p</code>-values below this level will be printed
as &quot;&lt;<code>eps.Pvalue</code>&quot;.</p>
</td></tr>
<tr><td><code id="summary.ergm_+3A_print.formula">print.formula</code>, <code id="summary.ergm_+3A_print.fitinfo">print.fitinfo</code>, <code id="summary.ergm_+3A_print.coefmat">print.coefmat</code>, <code id="summary.ergm_+3A_print.message">print.message</code>, <code id="summary.ergm_+3A_print.deviances">print.deviances</code>, <code id="summary.ergm_+3A_print.drop">print.drop</code>, <code id="summary.ergm_+3A_print.offset">print.offset</code>, <code id="summary.ergm_+3A_print.call">print.call</code></td>
<td>
<p>which components of the fit summary to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+summary.ergm">summary.ergm()</a></code> tries to be smart about formatting the
coefficients, standard errors, etc.
</p>
<p>The default printout of the summary object contains the
call, number of iterations used, null and residual deviances, and
the values of AIC and BIC (and their MCMC standard errors, if
applicable). The coefficient table contains the following
columns:
</p>

<ul>
<li> <p><code>Estimate</code>, <code style="white-space: pre;">&#8288;Std. Error&#8288;</code> - parameter estimates and their standard errors
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;MCMC %&#8288;</code> - if <code>total.variation=TRUE</code> (default) the percentage of standard
error attributable to MCMC estimation process rounded to an integer. See
also <code><a href="#topic+vcov.ergm">vcov.ergm()</a></code> and its <code>sources</code> argument.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;z value&#8288;</code>, <code style="white-space: pre;">&#8288;Pr(&gt;|z|)&#8288;</code> - z-test and p-values
</p>
</li></ul>



<h3>Value</h3>

<p>The returned object is a list of class &quot;ergm.summary&quot; with
the following elements:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>ERGM model formula</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>R call used to fit the model</p>
</td></tr>
<tr><td><code>correlation</code>, <code>covariance</code></td>
<td>
<p>whether to print correlation/covariance matrices of the estimated parameters</p>
</td></tr>
<tr><td><code>pseudolikelihood</code></td>
<td>
<p>was the model estimated with MPLE</p>
</td></tr>
<tr><td><code>independence</code></td>
<td>
<p>is the model dyad-independent</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the <code><a href="#topic+control.ergm">control.ergm()</a></code> object used</p>
</td></tr>
<tr><td><code>samplesize</code></td>
<td>
<p>MCMC sample size</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>optional message on the validity of the standard error estimates</p>
</td></tr>
<tr><td><code>null.lik.0</code></td>
<td>
<p>It is <code>TRUE</code> of the null model likelihood has not been calculated. See <code><a href="#topic+logLikNull">logLikNull()</a></code></p>
</td></tr>
<tr><td><code>devtext</code>, <code>devtable</code></td>
<td>
<p>Deviance type and table</p>
</td></tr>
<tr><td><code>aic</code>, <code>bic</code></td>
<td>
<p>values of AIC and BIC</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>matrices with model parameters and associated statistics</p>
</td></tr>
<tr><td><code>asycov</code></td>
<td>
<p>asymptotic covariance matrix</p>
</td></tr>
<tr><td><code>asyse</code></td>
<td>
<p>asymptotic standard error matrix</p>
</td></tr>
<tr><td><code>offset</code>, <code>drop</code>, <code>estimate</code>, <code>iterations</code>, <code>mle.lik</code>, <code>null.lik</code></td>
<td>

<p>see documentation of the object returned by <code><a href="#topic+ergm">ergm()</a></code>
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+ergm">ergm()</a></code>, <code><a href="#topic+print.ergm">print.ergm()</a></code>, and
<code><a href="base.html#topic+summary">base::summary()</a></code>. Function <code><a href="stats.html#topic+coef">stats::coef()</a></code> will extract the matrix of
coefficients with standard errors, t-statistics and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(florentine)

 x &lt;- ergm(flomarriage ~ density)
 summary(x)

</code></pre>

<hr>
<h2 id='summary.ergm_model'>Evaluate network summary statistics from an initialized ergm model</h2><span id='topic+summary.ergm_model'></span>

<h3>Description</h3>

<p>Returns a vector of the model's statistics for a given network or
an empty network. This is a low-level function that should not be
used by end-users, but may be useful to developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm_model'
summary(object, nw = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ergm_model_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+ergm_model">ergm_model</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.ergm_model_+3A_nw">nw</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> whose statistics are to be evaluated,
though an <code><a href="#topic+ergm_state">ergm_state</a></code> object will also work. If <code>NULL</code>,
returns empty network's statistics for that model.</p>
</td></tr>
<tr><td><code id="summary.ergm_model_+3A_...">...</code></td>
<td>
<p>Further arguments to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary_formula">summary_formula()</a></code>
</p>

<hr>
<h2 id='summary.formula'>Calculation of network or graph statistics or other attributes
specified on a formula</h2><span id='topic+summary.formula'></span><span id='topic+summary'></span>

<h3>Description</h3>

<p>Most generally, this function computes those summaries of the
object on the LHS of the formula that are specified by its RHS.  In
particular, if given a network as its LHS and
<code><a href="#topic+ergmTerm">ergmTerm</a></code> on its RHS, it computes the sufficient
statistics associated with those terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.formula_+3A_object">object</code></td>
<td>
<p>A formula having as its LHS a
<code><a href="network.html#topic+network">network</a></code> object or a matrix that can be
coerced to a <code><a href="network.html#topic+network">network</a></code> object, a
<code><a href="#topic+network.list">network.list</a></code>, or other types to be summarized using a formula. (See
&lsquo;methods(&rsquo;summary_formula') for the possible LHS types.</p>
</td></tr>
<tr><td><code id="summary.formula_+3A_...">...</code></td>
<td>
<p>further arguments passed to or used by methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In practice, <code><a href="#topic+summary.formula">summary.formula()</a></code> is a thin wrapper around the
<code><a href="#topic+summary_formula">summary_formula()</a></code> generic, which dispatches methods based on the
class of the LHS of the formula.
</p>


<h3>Value</h3>

<p>A vector of statistics specified in RHS of the formula.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm()</a></code>, <code><a href="network.html#topic+network">network()</a></code>, <code><a href="#topic+ergmTerm">ergmTerm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Lets look at the Florentine marriage data
#
data(florentine)
#
# test the summary_formula function
#
summary(flomarriage ~ edges + kstar(2))
m &lt;- as.matrix(flomarriage)
summary(m ~ edges)  # twice as large as it should be
summary(m ~ edges, directed=FALSE) # Now it's correct

</code></pre>

<hr>
<h2 id='Symmetrize-ergmTerm'>Evaluation on symmetrized (undirected) network</h2><span id='topic+Symmetrize-ergmTerm'></span><span id='topic+InitErgmTerm.Symmetrize'></span>

<h3>Description</h3>

<p>Evaluates the terms in <code>formula</code> on an undirected network
constructed by symmetrizing the LHS network using one of four rules:
</p>

<ol>
<li><p> &quot;weak&quot; A tie <code class="reqn">(i,j)</code> is present in the constructed
network if the LHS network has either tie <code class="reqn">(i,j)</code> or
<code class="reqn">(j,i)</code> (or both).
</p>
</li>
<li><p> &quot;strong&quot; A tie <code class="reqn">(i,j)</code> is present in the constructed
network if the LHS network has both tie <code class="reqn">(i,j)</code> and tie
<code class="reqn">(j,i)</code> .
</p>
</li>
<li><p> &quot;upper&quot; A tie <code class="reqn">(i,j)</code> is present in the constructed
network if the LHS network has tie <code class="reqn">(\min(i,j),\max(i,j))</code> :
the upper triangle of the LHS network.
</p>
</li>
<li><p> &quot;lower&quot; A tie <code class="reqn">(i,j)</code> is present in the constructed
network if the LHS network has tie <code class="reqn">(\max(i,j),\min(i,j))</code> :
the lower triangle of the LHS network.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'># binary: Symmetrize(formula, rule="weak")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Symmetrize-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Symmetrize-ergmTerm_+3A_rule">rule</code></td>
<td>
<p>one of <code>"weak"</code>, <code>"strong"</code>, <code>"upper"</code>, <code>"lower"</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, operator, binary</p>


<hr>
<h2 id='threetrail-ergmTerm'>Three-trails</h2><span id='topic+threetrail-ergmTerm'></span><span id='topic+InitErgmTerm.threetrail'></span><span id='topic+InitErgmTerm.threepath'></span><span id='topic+threepath-ergmTerm'></span>

<h3>Description</h3>

<p>For an undirected network, this term adds one statistic equal to the number
of 3-trails, where a 3-trail is defined as a trail of length three that
traverses three distinct edges.
Note that a 3-trail need not
include four distinct nodes; in particular, a triangle counts as three
3-trails. For a directed network, this term adds four statistics
(or some subset of these four),
one for each of the four distinct types of directed three-paths. If the
nodes of the path are written from left to right such that the middle edge
points to the right (R), then the four types are RRR, RRL, LRR, and LRL.
That is, an RRR 3-trail is of the form
<code class="reqn">i\rightarrow j\rightarrow k\rightarrow l</code> , and RRL
3-trail is of the form
<code class="reqn">i\rightarrow j\rightarrow k\leftarrow l</code> , etc.
Like in the undirected case, there is no requirement that the nodes be
distinct in a directed 3-trail. However, the three edges must all be
distinct. Thus, a mutual tie <code class="reqn">i\leftrightarrow j</code> does not
count as a 3-trail of the form
<code class="reqn">i\rightarrow j\rightarrow i\leftarrow j</code> ; however,
in the subnetwork <code class="reqn">i\leftrightarrow j \rightarrow k</code> ,
there are two directed 3-trails, one LRR
( <code class="reqn">k\leftarrow j\rightarrow i\leftarrow j</code> )
and one RRR
( <code class="reqn">j\rightarrow i\rightarrow j\leftarrow k</code> ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: threetrail(keep=NULL, levels=NULL)

# binary: threepath(keep=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threetrail-ergmTerm_+3A_keep">keep</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="threetrail-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>specify a subset of the four statistics for directed networks. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>keep</code> is retained for backwards compatibility and may be
removed in a future version. When both <code>keep</code> and <code>levels</code> are passed,
<code>levels</code> overrides <code>keep</code>.
</p>
<p>This term used to be (inaccurately) called <code>threepath</code> . That
name has been deprecated and may be removed in a future version.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, undirected, binary</p>


<hr>
<h2 id='TNT-ergmProposal'>Default MH algorithm</h2><span id='topic+TNT-ergmProposal'></span><span id='topic+InitErgmProposal.TNT'></span>

<h3>Description</h3>

<p>Stratifies the population of dyads
edge status: those having ties and those having no ties (hence T/NT).
This is useful for improving performance in sparse networks,
because it gives at least 50\
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='to_ergm_Cdouble.network'>Methods to serialize objects into numeric vectors for passing to the C side.</h2><span id='topic+to_ergm_Cdouble.network'></span><span id='topic+to_ergm_Cdouble.ergm_state'></span><span id='topic+to_ergm_Cdouble.matrix'></span><span id='topic+to_ergm_Cdouble.rlebdm'></span><span id='topic+to_ergm_Cdouble'></span>

<h3>Description</h3>

<p>These methods return a vector of <code><a href="base.html#topic+double">double</a></code>s. For edge lists, this
usually takes the form of a <code class="reqn">2 e + 1</code>- or <code class="reqn">3 e + 1</code>-vector,
containing the number of edges followed a column-major
serialization of the edgelist matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
to_ergm_Cdouble(x, attrname = NULL, ...)

## S3 method for class 'ergm_state'
to_ergm_Cdouble(x, attrname = NULL, ...)

## S3 method for class 'matrix'
to_ergm_Cdouble(x, prototype = NULL, ...)

## S3 method for class 'rlebdm'
to_ergm_Cdouble(x, ...)

to_ergm_Cdouble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_ergm_Cdouble.network_+3A_x">x</code></td>
<td>
<p>object to be serialized.</p>
</td></tr>
<tr><td><code id="to_ergm_Cdouble.network_+3A_attrname">attrname</code></td>
<td>
<p>name of an edge attribute.</p>
</td></tr>
<tr><td><code id="to_ergm_Cdouble.network_+3A_...">...</code></td>
<td>
<p>arguments for methods.</p>
</td></tr>
<tr><td><code id="to_ergm_Cdouble.network_+3A_prototype">prototype</code></td>
<td>
<p>A network whose relevant attributes (size,
directedness, bipartitedness, and presence of loops) are imposed
on the output edgelist if <code>x</code> is already an edgelist. (For
example, if the prototype is undirected, <code>to_ergm_Cdouble</code>
will ensure that <code class="reqn">t &lt; h</code>.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+rlebdm">rlebdm</a></code> method returns a vector with the following:
</p>

<ul>
<li><p> number of nonzero dyads,
</p>
</li>
<li><p> number of runs of nonzeros,
</p>
</li>
<li><p> starting positions of the runs, and
</p>
</li>
<li><p> cumulative lengths of the runs, prepended with 0.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>to_ergm_Cdouble(network)</code>: Method for <code><a href="network.html#topic+network">network</a></code> objects.
</p>
</li>
<li> <p><code>to_ergm_Cdouble(ergm_state)</code>: Method for <code><a href="#topic+ergm_state">ergm_state</a></code> objects, extracting their edgelists.
</p>
</li>
<li> <p><code>to_ergm_Cdouble(matrix)</code>: Method for <code><a href="base.html#topic+matrix">matrix</a></code> objects, assumed to be edgelists.
</p>
</li>
<li> <p><code>to_ergm_Cdouble(rlebdm)</code>: Method for <code><a href="#topic+rlebdm">rlebdm</a></code> objects.
</p>
</li></ul>

<hr>
<h2 id='transitive-ergmTerm'>Transitive triads</h2><span id='topic+transitive-ergmTerm'></span><span id='topic+InitErgmTerm.transitive'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model, equal to the number of triads in
the network that are transitive. The transitive triads are those of type
<code style="white-space: pre;">&#8288;120D&#8288;</code> , <code style="white-space: pre;">&#8288;030T&#8288;</code> , <code style="white-space: pre;">&#8288;120U&#8288;</code> , or <code>300</code> in the categorization
of Davis and Leinhardt (1972). For details on the 16 possible triad types,
see <code>?triad.classify</code> in the <a href="https://CRAN.R-project.org/package=sna"><span class="pkg">sna</span></a> package.
Note the distinction from the <code>ttriple</code> term. This term can only be
used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: transitive
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, binary</p>


<hr>
<h2 id='transitiveties-ergmTerm'>Transitive ties</h2><span id='topic+transitiveties-ergmTerm'></span><span id='topic+InitErgmTerm.transitiveties'></span>

<h3>Description</h3>

<p>This term adds one statistic, equal to the number of ties
<code class="reqn">i\rightarrow j</code> such that there exists a two-path from
<code class="reqn">i</code> to <code class="reqn">j</code> . (Related to the <code>ttriple</code> term.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: transitiveties(attr=NULL, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitiveties-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>quantitative attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.) If set, all three nodes involved ( <code class="reqn">i</code> , <code class="reqn">j</code> , and the node on the two-path) must match
on this attribute in order for <code class="reqn">i\rightarrow j</code> to be counted.</p>
</td></tr>
<tr><td><code id="transitiveties-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>TODO (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, triad-related, undirected, binary</p>


<hr>
<h2 id='transitiveweights-ergmTerm'>Transitive weights</h2><span id='topic+transitiveweights-ergmTerm'></span><span id='topic+InitWtErgmTerm.transitiveweights'></span>

<h3>Description</h3>

<p>This statistic implements the transitive weights
statistic defined by Krivitsky (2012), Equation 13. For each of these options,
the first (and the default) is more stable but also more
conservative, while the second is more sensitive but more likely
to induce a multimodal distribution of networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># valued: transitiveweights(twopath="min", combine="max", affect="min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitiveweights-ergmTerm_+3A_twopath">twopath</code></td>
<td>
<p>the minimum
of the constituent dyads ( <code>"min"</code> ) or their geometric mean
( <code>"geomean"</code> )</p>
</td></tr>
<tr><td><code id="transitiveweights-ergmTerm_+3A_combine">combine</code></td>
<td>
<p>the maximum of the
2-path strengths ( <code>"max"</code> ) or their sum ( <code>"sum"</code> )</p>
</td></tr>
<tr><td><code id="transitiveweights-ergmTerm_+3A_affect">affect</code></td>
<td>
<p>the minimum of the focus dyad and the
combined strength of the two paths ( <code>"min"</code> ) or their
geometric mean ( <code>"geomean"</code> )</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, nonnegative, triad-related, undirected, valued</p>


<hr>
<h2 id='triadcensus-ergmTerm'>Triad census</h2><span id='topic+triadcensus-ergmTerm'></span><span id='topic+InitErgmTerm.triadcensus'></span>

<h3>Description</h3>

<p>For a directed network, this term adds one network statistic for each of
an arbitrary subset of the 16 possible types of triads categorized by
Davis and Leinhardt (1972) as <code style="white-space: pre;">&#8288;003, 012, 102, 021D, 021U, 021C, 111D, &#8288;</code> <code style="white-space: pre;">&#8288;	111U, 030T, 030C, 201, 120D, 120U, 120C, 210,&#8288;</code> and <code>300</code> . Note that at
least one category should be dropped; otherwise a linear dependency will
exist among the 16 statistics, since they must sum to the total number of
three-node sets. By default, the category <code>003</code> , which is the category
of completely empty three-node sets, is dropped. This is considered category
zero, and the others are numbered 1 through 15 in the order given above. Each statistic is the count of the corresponding triad
type in the network. For details on the 16 types, see <code>?triad.classify</code>
in the <a href="https://CRAN.R-project.org/package=sna"><span class="pkg">sna</span></a> package, on which this code is based. For an undirected
network, the triad census is over the four types defined by the number of
ties (i.e., 0, 1, 2, and 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: triadcensus(levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triadcensus-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>For directed networks, specify a set of terms to add other than the default value of <code>1:15</code>.
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, triad-related, undirected, binary</p>


<hr>
<h2 id='triangle-ergmTerm'>Triangles</h2><span id='topic+triangle-ergmTerm'></span><span id='topic+InitErgmTerm.triangle'></span><span id='topic+triangles-ergmTerm'></span>

<h3>Description</h3>

<p>By default, this term adds one statistic to the model equal to the number of triangles
in the network. For an undirected network, a triangle is defined to be any
set <code class="reqn">\{(i,j), (j,k), (k,i)\}</code> of three edges. For a directed network, a
triangle is defined as any set of three edges <code class="reqn">(i{\rightarrow}j)</code>
and <code class="reqn">(j{\rightarrow}k)</code> and either <code class="reqn">(k{\rightarrow}i)</code>
or <code class="reqn">(k{\leftarrow}i)</code> . The former case is called a &quot;transitive
triple&quot; and the latter is called a &quot;cyclic triple&quot;, so in the case of a
directed network, <code>triangle</code> equals <code>ttriple</code> plus <code>ctriple</code>
&mdash; thus at most two of these three terms can be in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: triangle(attr=NULL, diff=FALSE, levels=NULL)

# binary: triangles(attr=NULL, diff=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle-ergmTerm_+3A_attr">attr</code>, <code id="triangle-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>quantitative attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.) If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code> ,
then the count is restricted to those triples of nodes with
equal values of the vertex attribute specified by <code>attr</code> . If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code> ,
then one statistic is added for each value of <code>attr</code> ,
equal to the number of triangles where all three nodes have that value of the attribute.</p>
</td></tr>
<tr><td><code id="triangle-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>add one statistic for each value specified if <code>diff</code> is <code>TRUE</code>. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, frequently-used, triad-related, undirected, binary</p>


<hr>
<h2 id='tripercent-ergmTerm'>Triangle percentage</h2><span id='topic+tripercent-ergmTerm'></span><span id='topic+InitErgmTerm.tripercent'></span>

<h3>Description</h3>

<p>By default, this term adds one statistic to the model equal to 100 times the ratio of
the number of triangles in the network to the sum of the number of triangles
and the number of 2-stars not in triangles (the latter is considered a
potential but incomplete triangle). In case the denominator equals zero,
the statistic is defined to be zero. For the definition of triangle, see
<code>triangle</code> . This is often called
the mean correlation coefficient. This term can only be
used with undirected networks; for directed networks, it is difficult to
define the numerator and denominator in a consistent and meaningful way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: tripercent(attr=NULL, diff=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tripercent-ergmTerm_+3A_attr">attr</code>, <code id="tripercent-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>quantitative attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.) If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code> ,
then the counts are restricted to those triples of nodes with
equal values of the vertex attribute specified by <code>attr</code> . If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code> ,
then one statistic is added for each value of <code>attr</code> ,
equal to the number of triangles where all three nodes have that value of the attribute.</p>
</td></tr>
<tr><td><code id="tripercent-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>add one statistic for each value specified if <code>diff</code> is <code>TRUE</code>
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, triad-related, undirected, binary</p>


<hr>
<h2 id='ttriple-ergmTerm'>Transitive triples</h2><span id='topic+ttriple-ergmTerm'></span><span id='topic+InitErgmTerm.ttriple'></span><span id='topic+InitErgmTerm.ttriad'></span><span id='topic+ttriad-ergmTerm'></span>

<h3>Description</h3>

<p>By default, this term adds one statistic to the model, equal to the number of transitive
triples in the network, defined as a set of edges <code class="reqn">\{(i{\rightarrow}j),
  j{\rightarrow}k), (i{\rightarrow}k)\}</code> . Note that
<code>triangle</code> equals <code>ttriple+ctriple</code> for a directed network, so at
most two of the three terms can be in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: ttriple(attr=NULL, diff=FALSE, levels=NULL)

# binary: ttriad
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttriple-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="ttriple-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code> ,
then the count is over the number of transitive triples where all three nodes have the same value of
the attribute. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code> ,
then one statistic is added for each value of <code>attr</code> ,
equal to the number of triangles where all three nodes have that value of the attribute.</p>
</td></tr>
<tr><td><code id="ttriple-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>add one statistic for each value specified if <code>diff</code> is <code>TRUE</code>. (See Specifying Vertex
attributes and Levels (<code><a href="#topic+nodal_attributes">?nodal_attributes</a></code>) for details.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, triad-related, binary</p>


<hr>
<h2 id='twopath-ergmTerm'>2-Paths</h2><span id='topic+twopath-ergmTerm'></span><span id='topic+InitErgmTerm.twopath'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model, equal to the number of 2-paths in
the network. For a directed network this is defined as a pair of edges
<code class="reqn">(i{\rightarrow}j), (j{\rightarrow}k)</code> , where <code class="reqn">i</code> and
<code class="reqn">j</code> must be distinct. That is, it is a directed path of length 2 from
<code class="reqn">i</code> to <code class="reqn">k</code> via <code class="reqn">j</code> . For directed networks a 2-path is also a
mixed 2-star but the interpretation is usually different; see <code>m2star</code> .
For undirected networks a twopath is defined as a pair of edges
<code class="reqn">\{i,j\}, \{j,k\}</code> . That is, it is an undirected path of length 2 from
<code class="reqn">i</code> to <code class="reqn">k</code> via <code class="reqn">j</code> , also known as a 2-star.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: twopath
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, undirected, binary</p>


<hr>
<h2 id='Unif-ergmProposal'>TODO</h2><span id='topic+Unif-ergmProposal'></span><span id='topic+InitWtErgmProposal.Unif'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='Unif-ergmReference'>Continuous Uniform reference</h2><span id='topic+Unif-ergmReference'></span><span id='topic+InitErgmReference.Unif'></span>

<h3>Description</h3>

<p>Specifies each dyad's baseline distribution to be continuous uniform
between <code>a</code> and <code>b</code>: <code class="reqn">h(y)=1</code> , with the support being <code style="white-space: pre;">&#8288;[a, b]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Unif(a,b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Unif-ergmReference_+3A_a">a</code>, <code id="Unif-ergmReference_+3A_b">b</code></td>
<td>
<p>minimum and maximum to the baseline discrete uniform distribution, both inclusive. Both values must be finite.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmReference">ergmReference</a></code> for index of reference distributions currently visible to the package.
</p>


<h4>Keywords</h4>

<p>continuous</p>


<hr>
<h2 id='UnifNonObserved-ergmProposal'>TODO</h2><span id='topic+UnifNonObserved-ergmProposal'></span><span id='topic+InitWtErgmProposal.UnifNonObserved'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='update.network'>Update the edges in a network based on a matrix</h2><span id='topic+update.network'></span><span id='topic+update_network'></span><span id='topic+update_network.matrix_edgelist'></span><span id='topic+update_network.data.frame'></span><span id='topic+update_network.matrix'></span><span id='topic+update_network.ergm_state'></span>

<h3>Description</h3>

<p>Replaces the edges in a <code><a href="network.html#topic+network">network</a></code> object with the edges corresponding
to the sociomatrix or edge list specified by <code>new</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
update(object, ...)

update_network(object, new, ...)

## S3 method for class 'matrix_edgelist'
update_network(object, new, attrname = if (ncol(new) &gt; 2) names(new)[3], ...)

## S3 method for class 'data.frame'
update_network(object, new, attrname = if (ncol(new) &gt; 2) names(new)[3], ...)

## S3 method for class 'matrix'
update_network(object, new, matrix.type = NULL, attrname = NULL, ...)

## S3 method for class 'ergm_state'
update_network(object, new, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.network_+3A_object">object</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object.</p>
</td></tr>
<tr><td><code id="update.network_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently unused.</p>
</td></tr>
<tr><td><code id="update.network_+3A_new">new</code></td>
<td>
<p>Either an adjacency matrix (a matrix of values
indicating the presence and/or the value of a tie from i to j) or
an edge list (a two-column matrix listing origin and destination
node numbers for each edge, with an optional third column for the
value of the edge).</p>
</td></tr>
<tr><td><code id="update.network_+3A_attrname">attrname</code></td>
<td>
<p>For a network with edge weights gives the name of
the edge attribute whose names to set.</p>
</td></tr>
<tr><td><code id="update.network_+3A_matrix.type">matrix.type</code></td>
<td>
<p>One of <code>"adjacency"</code> or <code>"edgelist"</code> telling
which type of matrix <code>new</code> is.  Default is to use the
<code><a href="network.html#topic+which.matrix.type">which.matrix.type</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code><a href="network.html#topic+network">network</a></code> object with the edges specified by
<code>new</code> and network and vertex attributes copied from
the input network <code>object</code>. Input network is not modified.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>update_network()</code>: dispatcher for network update based on the type of updating information.
</p>
</li>
<li> <p><code>update_network(matrix_edgelist)</code>: a method for updating a network based on a matrix-form edgelist
</p>
</li>
<li> <p><code>update_network(data.frame)</code>: a method for updating a network based on an edgelist
</p>
</li>
<li> <p><code>update_network(matrix)</code>: a method for updating a network based on a matrix
</p>
</li>
<li> <p><code>update_network(ergm_state)</code>: a method for updating a network based on an <code><a href="#topic+ergm_state">ergm_state</a></code> object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+ergm">ergm()</a></code>, <code><a href="network.html#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
data(florentine)
#
# test the network.update function
#
# Create a Bernoulli network
rand.net &lt;- network(network.size(flomarriage))
# store the sociomatrix 
rand.mat &lt;- rand.net[,]
# Update the network
update(flomarriage, rand.mat, matrix.type="adjacency")
# Try this with an edgelist
rand.mat &lt;- as.matrix.network.edgelist(flomarriage)[1:5,]
update(flomarriage, rand.mat, matrix.type="edgelist")

</code></pre>

<hr>
<h2 id='wrap.ergm_model'>Wrap a submodel's curved, empty network statistics, and extended
state (read-only) specification (if present) for output from an
<code>InitErgmTerm</code> or <code>InitWtErgmTerm</code>.</h2><span id='topic+wrap.ergm_model'></span>

<h3>Description</h3>

<p>Given a <code>ergm</code> model and (optionally) a function with which to wrap
parameter names, wrap the calls to its <code>ergm.eta()</code> and
<code>ergm.etagrad()</code> into <code>map()</code> and <code>gradient()</code> functions, similarly
with the <code>params</code> element; wrap empty network statistics; wrap
indicator of dyadic independence; and wrap offset indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap.ergm_model(m, nw, namewrap = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap.ergm_model_+3A_m">m</code></td>
<td>
<p>An <code>ergm_model</code> object.</p>
</td></tr>
<tr><td><code id="wrap.ergm_model_+3A_nw">nw</code></td>
<td>
<p>A <code>network</code> object.</p>
</td></tr>
<tr><td><code id="wrap.ergm_model_+3A_namewrap">namewrap</code></td>
<td>
<p>An optional function taking a character vector and
returning a character vector of the same length, called on the
model's canonical and curved parameter names to wrap them. Set to
<code>NULL</code> for auxiliary terms to avoid generating elements not
relevant to auxiliaries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>map</code>, <code>gradient</code>, <code>params</code>,
<code>emptynwstats</code>, <code>dependence</code>, <code>offsettheta</code>, and <code>offsetmap</code>,
suitable for concatenating with an <code>InitErgmTerm</code> or
<code>InitWtErgmTerm</code> output list (possibly after modification).
</p>

<hr>
<h2 id='wtd.median'>Weighted Median</h2><span id='topic+wtd.median'></span>

<h3>Description</h3>

<p>Compute weighted median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtd.median(x, na.rm = FALSE, weight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtd.median_+3A_x">x</code></td>
<td>
<p>Vector of data, same length as <code>weight</code></p>
</td></tr>
<tr><td><code id="wtd.median_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical: Should NAs be stripped before computation proceeds?</p>
</td></tr>
<tr><td><code id="wtd.median_+3A_weight">weight</code></td>
<td>
<p>Vector of weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a simple algorithm based on sorting.
</p>


<h3>Value</h3>

<p>Returns an empirical .5 quantile from a weighted sample.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
