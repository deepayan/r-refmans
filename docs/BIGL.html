<!DOCTYPE html><html><head><title>Help for package BIGL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BIGL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addResids'><p>Add residuals by adding to mean effects</p></a></li>
<li><a href='#backscaleResids'><p>Backscale residuals</p></a></li>
<li><a href='#Blissindependence'><p>Bliss Independence Model</p></a></li>
<li><a href='#bootConfInt'><p>Obtain confidence intervals for the raw effect sizes on every off-axis point and overall</p></a></li>
<li><a href='#boxcox.transformation'><p>Apply two-parameter Box-Cox transformation</p></a></li>
<li><a href='#coef.MarginalFit'><p>Coefficients from marginal model estimation</p></a></li>
<li><a href='#col2hex'><p>R color to RGB (red/green/blue) conversion.</p></a></li>
<li><a href='#constructFormula'><p>Construct a model formula from parameter constraint matrix</p></a></li>
<li><a href='#contour.ResponseSurface'><p>Method for plotting of contours based on maxR statistics</p></a></li>
<li><a href='#df.residual.MarginalFit'><p>Residual degrees of freedom in marginal model estimation</p></a></li>
<li><a href='#directAntivirals'><p>Partial data with combination experiments of direct-acting antivirals</p></a></li>
<li><a href='#directAntivirals_ALL'><p>Full data with combination experiments of direct-acting antivirals</p></a></li>
<li><a href='#fitMarginals'><p>Fit two 4-parameter log-logistic functions for a synergy experiment</p></a></li>
<li><a href='#fitSurface'><p>Fit response surface model and compute meanR and maxR statistics</p></a></li>
<li><a href='#fitted.MarginalFit'><p>Compute fitted values from monotherapy estimation</p></a></li>
<li><a href='#fitted.ResponseSurface'><p>Predicted values of the response surface according to the given null model</p></a></li>
<li><a href='#generalizedLoewe'><p>Compute combined predicted response from drug doses according to standard or</p>
generalized Loewe model.</a></li>
<li><a href='#generateData'><p>Generate data from parameters of marginal monotherapy model</p></a></li>
<li><a href='#get.abs_tval'><p>Return absolute t-value, used in optimization call in</p>
<code>optim.boxcox</code></a></li>
<li><a href='#get.summ.data'><p>Summarize data by factor</p></a></li>
<li><a href='#getCP'><p>Estimate CP matrix from bootstraps</p></a></li>
<li><a href='#getd1d2'><p>A function to get the d1d2 identifier</p></a></li>
<li><a href='#getR'><p>Helper functions for the test statistics</p></a></li>
<li><a href='#GetStartGuess'><p>Estimate initial values for dose-response curve fit</p></a></li>
<li><a href='#getTransformations'><p>Return a list with transformation functions</p></a></li>
<li><a href='#harbronLoewe'><p>Alternative Loewe generalization</p></a></li>
<li><a href='#hsa'><p>Highest Single Agent model</p></a></li>
<li><a href='#initialMarginal'><p>Estimate initial values for fitting marginal dose-response curves</p></a></li>
<li><a href='#isobologram'><p>Isobologram of the response surface predicted by the null model</p></a></li>
<li><a href='#L4'><p>4-parameter logistic dose-response function</p></a></li>
<li><a href='#marginalNLS'><p>Fit two 4-parameter log-logistic functions with non-linear least squares</p></a></li>
<li><a href='#marginalOptim'><p>Fit two 4-parameter log-logistic functions with common baseline</p></a></li>
<li><a href='#maxR'><p>Compute maxR statistic for each off-axis dose combination</p></a></li>
<li><a href='#meanR'><p>Compute meanR statistic for the estimated model</p></a></li>
<li><a href='#modelVar'><p>Calculate model variance, assuming variance increases linearly with mean</p></a></li>
<li><a href='#optim.boxcox'><p>Find optimal Box-Cox transformation parameters</p></a></li>
<li><a href='#outsidePoints'><p>List non-additive points</p></a></li>
<li><a href='#plot.BIGLconfInt'><p>Plot confidence intervals in a contour plot</p></a></li>
<li><a href='#plot.effect-size'><p>Plot of effect-size object</p></a></li>
<li><a href='#plot.MarginalFit'><p>Plot monotherapy curve estimates</p></a></li>
<li><a href='#plot.maxR'><p>Plot of maxR object</p></a></li>
<li><a href='#plot.meanR'><p>Plot bootstrapped cumulative distribution function of meanR null distribution</p></a></li>
<li><a href='#plot.ResponseSurface'><p>Method for plotting response surface objects</p></a></li>
<li><a href='#plotConfInt'><p>Plot confidence intervals from BIGL object in a contour plot</p></a></li>
<li><a href='#plotMeanVarFit'><p>Make a mean-variance plot</p></a></li>
<li><a href='#plotResponseSurface'><p>Plot response surface</p></a></li>
<li><a href='#predict.MarginalFit'><p>Predict values on the dose-response curve</p></a></li>
<li><a href='#predictOffAxis'><p>Compute off-axis predictions</p></a></li>
<li><a href='#predictResponseSurface'><p>Predict the entire response surface, so including on-axis points, and return</p>
the result as a matrix. For plotting purposes.</a></li>
<li><a href='#predictVar'><p>Predict variance</p></a></li>
<li><a href='#print.summary.BIGLconfInt'><p>Print summary of BIGLconfInt object</p></a></li>
<li><a href='#print.summary.MarginalFit'><p>Print method for summary of <code>MarginalFit</code> object</p></a></li>
<li><a href='#print.summary.maxR'><p>Print summary of maxR object</p></a></li>
<li><a href='#print.summary.meanR'><p>Print summary of meanR object</p></a></li>
<li><a href='#print.summary.ResponseSurface'><p>Print method for the summary function of <code>ResponseSurface</code> object</p></a></li>
<li><a href='#residuals.MarginalFit'><p>Residuals from marginal model estimation</p></a></li>
<li><a href='#runBIGL'><p>Run the BIGL application for demonstrating response surfaces</p></a></li>
<li><a href='#sampleResids'><p>Sample residuals according to a new model</p></a></li>
<li><a href='#scaleResids'><p>Functions for scaling, and rescaling residuals. May lead to unstable behaviour in practice</p></a></li>
<li><a href='#simulateNull'><p>Simulate data from a given null model and monotherapy coefficients</p></a></li>
<li><a href='#summary.BIGLconfInt'><p>Summary of confidence intervals object</p></a></li>
<li><a href='#summary.MarginalFit'><p>Summary of <code>MarginalFit</code> object</p></a></li>
<li><a href='#summary.maxR'><p>Summary of maxR object</p></a></li>
<li><a href='#summary.meanR'><p>Summary of meanR object</p></a></li>
<li><a href='#summary.ResponseSurface'><p>Summary of <code>ResponseSurface</code> object</p></a></li>
<li><a href='#synergy_plot_bycomp'><p>Plot 2D cross section of response surface</p></a></li>
<li><a href='#vcov.MarginalFit'><p>Estimate of coefficient variance-covariance matrix</p></a></li>
<li><a href='#wildbootAddResids'><p>Sample residuals according to a new model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Biochemically Intuitive Generalized Loewe Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Heather Turner, Annelies Tourny, Olivier Thas, Maxim Nazarov, Rytis Bagdziunas, Stijn Hawinkel, Javier Franco PÃ©rez, Kathy Mutambanengwe</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kathy Mutambanengwe &lt;kathy.mutambanengwe@openanalytics.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Response surface methods for drug synergy analysis. Available
    methods include generalized and classical Loewe formulations as well as Highest
    Single Agent methodology. Response surfaces can be plotted in an interactive
    3-D plot and formal statistical tests for presence of synergistic effects are
    available. Implemented methods and tests are described in the article 
    "BIGL: Biochemically Intuitive Generalized Loewe null model for prediction 
    of the expected combined effect compatible with partial agonism and antagonism"
    by Koen Van der Borght, Annelies Tourny, Rytis Bagdziunas, Olivier Thas, 
    Maxim Nazarov, Heather Turner, Bie Verbist &amp; Hugo Ceulemans (2017) 
    &lt;<a href="https://doi.org/10.1038%2Fs41598-017-18068-5">doi:10.1038/s41598-017-18068-5</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, MASS, methods, minpack.lm, numDeriv, parallel,
progress, plotly, robustbase, scales, nleqslv, data.table,
lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, shiny, DT</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/openanalytics/BIGL">https://github.com/openanalytics/BIGL</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/openanalytics/BIGL/issues">https://github.com/openanalytics/BIGL/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 21:49:32 UTC; kathy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 01:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='addResids'>Add residuals by adding to mean effects</h2><span id='topic+addResids'></span>

<h3>Description</h3>

<p>Add residuals by adding to mean effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addResids(means, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addResids_+3A_means">means</code></td>
<td>
<p>a vector of means</p>
</td></tr>
<tr><td><code id="addResids_+3A_...">...</code></td>
<td>
<p>passed on to predictVar</p>
</td></tr>
</table>

<hr>
<h2 id='backscaleResids'>Backscale residuals</h2><span id='topic+backscaleResids'></span>

<h3>Description</h3>

<p>Backscale residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backscaleResids(scaledResids, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backscaleResids_+3A_scaledresids">scaledResids</code></td>
<td>
<p>scaled residuals</p>
</td></tr>
<tr><td><code id="backscaleResids_+3A_...">...</code></td>
<td>
<p>passed on to predictVar</p>
</td></tr>
</table>

<hr>
<h2 id='Blissindependence'>Bliss Independence Model</h2><span id='topic+Blissindependence'></span>

<h3>Description</h3>

<p>This function returns fractional response levels for when these are based on
Bliss Independence Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Blissindependence(doseInput, parmInput, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Blissindependence_+3A_doseinput">doseInput</code></td>
<td>
<p>Dose-response dataframe containing <code>"d1"</code> and
<code>"d2"</code> columns</p>
</td></tr>
<tr><td><code id="Blissindependence_+3A_parminput">parmInput</code></td>
<td>
<p>Numeric vector or list with appropriately named
parameter inputs. Typically, it will be coefficients from a
<code>MarginalFit</code> object.</p>
</td></tr>
<tr><td><code id="Blissindependence_+3A_...">...</code></td>
<td>
<p>Further arguments that are currently unused</p>
</td></tr>
</table>

<hr>
<h2 id='bootConfInt'>Obtain confidence intervals for the raw effect sizes on every off-axis point and overall</h2><span id='topic+bootConfInt'></span>

<h3>Description</h3>

<p>Obtain confidence intervals for the raw effect sizes on every off-axis point and overall
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootConfInt(
  Total,
  idUnique,
  bootStraps,
  transforms,
  respS,
  B.B,
  method,
  CP,
  reps,
  n1,
  cutoff,
  R,
  fitResult,
  bootRS,
  data_off,
  posEffect = all(Total$effect &gt;= 0),
  transFun,
  invTransFun,
  model,
  rescaleResids,
  wild_bootstrap,
  wild_bootType,
  control,
  digits,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootConfInt_+3A_total">Total</code></td>
<td>
<p>data frame with all effects and mean effects</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_idunique">idUnique</code></td>
<td>
<p>unique combinations of on-axis points, a character vector</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_bootstraps">bootStraps</code></td>
<td>
<p>precomputed bootstrap objects</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_resps">respS</code></td>
<td>
<p>the observed response surface</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_b.b">B.B</code></td>
<td>
<p>Number of iterations to use in bootstrapping null distribution for
either meanR or maxR statistics.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_method">method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_cp">CP</code></td>
<td>
<p>Prediction covariance matrix. If not specified, it will be estimated
by bootstrap using <code>B.CP</code> iterations.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_reps">reps</code></td>
<td>
<p>Numeric vector containing number of replicates for each off-axis
dose combination. If missing, it will be calculated automatically from output
of <code><a href="#topic+predictOffAxis">predictOffAxis</a></code> function.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_n1">n1</code></td>
<td>
<p>the number of off-axis points</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_cutoff">cutoff</code></td>
<td>
<p>Cut-off to use in maxR procedure for declaring non-additivity
(default is 0.95).</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_r">R</code></td>
<td>
<p>Numeric vector containing mean deviation of predicted response
surface from the observed one at each of the off-axis points. If missing,
it will be calculated automatically from output of
<code><a href="#topic+predictOffAxis">predictOffAxis</a></code> function.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_fitresult">fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code><a href="#topic+fitMarginals">fitMarginals</a></code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_bootrs">bootRS</code></td>
<td>
<p>a boolean, should bootstrapped response surfaces be used in the
calculation of the confidence intervals?</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_data_off">data_off</code></td>
<td>
<p>data frame with off -axis information</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_poseffect">posEffect</code></td>
<td>
<p>a boolean, are effects restricted to be positive</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_transfun">transFun</code>, <code id="bootConfInt_+3A_invtransfun">invTransFun</code></td>
<td>
<p>the transformation and inverse transformation functions for the variance</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_model">model</code></td>
<td>
<p>The mean-variance model</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_rescaleresids">rescaleResids</code></td>
<td>
<p>a boolean indicating whether to rescale residuals,
or else normality of the residuals is assumed.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_wild_bootstrap">wild_bootstrap</code></td>
<td>
<p>Whether special bootstrap to correct for
heteroskedasticity should be used. If <code>wild_bootstrap = TRUE</code>, errors
are generated from <code>sampling_errors</code> multiplied by a random variable
following Rademacher distribution. Argument is used only if <code>error = 4</code>.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_wild_boottype">wild_bootType</code></td>
<td>
<p>Type of distribution to be used for wild bootstrap. If <code>wild_bootstrap = TRUE</code>, 
errors are generated from &quot;rademacher&quot;, &quot;gamma&quot;, &quot;normal&quot; or &quot;two-point&quot; distribution.</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_control">control</code></td>
<td>
<p>If <code>control = "FCR"</code> then algorithm controls false coverage rate, if <code>control = "dFCR"</code> then 
algorithm controls directional false coverage rate, if <code>control = "FWER"</code> then 
algorithm controls family wise error rate</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_digits">digits</code></td>
<td>
<p>Numeric value indicating the number of digits used for numeric values in confidence intervals</p>
</td></tr>
<tr><td><code id="bootConfInt_+3A_...">...</code></td>
<td>
<p>Further arguments that will be later passed to
<code><a href="#topic+generateData">generateData</a></code> function during bootstrapping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>offAxis</code></td>
<td>
<p>The off-axis bootstrapped confidence intervals</p>
</td></tr>
<tr><td><code>single</code></td>
<td>
<p>A mean effect and percentile and studentized boostrap intervals</p>
</td></tr>
</table>

<hr>
<h2 id='boxcox.transformation'>Apply two-parameter Box-Cox transformation</h2><span id='topic+boxcox.transformation'></span>

<h3>Description</h3>

<p>Apply two-parameter Box-Cox transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox.transformation(y, lambda, alpha = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox.transformation_+3A_y">y</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="boxcox.transformation_+3A_lambda">lambda</code></td>
<td>
<p>Power parameter in power transform</p>
</td></tr>
<tr><td><code id="boxcox.transformation_+3A_alpha">alpha</code></td>
<td>
<p>Shift paramater in 2-parameter power transform. Defaults to
<code>0</code> which implies a 1-parameter Box-Cox transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Power-transformed data
</p>

<hr>
<h2 id='coef.MarginalFit'>Coefficients from marginal model estimation</h2><span id='topic+coef.MarginalFit'></span>

<h3>Description</h3>

<p>Coefficients from marginal model estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.MarginalFit_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function</p>
</td></tr>
<tr><td><code id="coef.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='col2hex'>R color to RGB (red/green/blue) conversion.</h2><span id='topic+col2hex'></span>

<h3>Description</h3>

<p>R color to RGB (red/green/blue) conversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2hex(cname, alpha = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col2hex_+3A_cname">cname</code></td>
<td>
<p>vector of any of the three kinds of R color specifications, i.e., either a color name (as listed by <code><a href="grDevices.html#topic+colors">colors</a></code>()), a hexadecimal string of the form &quot;#rrggbb&quot; or &quot;#rrggbbaa&quot; (see <code><a href="grDevices.html#topic+rgb">rgb</a></code>), or a positive integer i meaning <code><a href="grDevices.html#topic+palette">palette</a></code>()[i].</p>
</td></tr>
<tr><td><code id="col2hex_+3A_alpha">alpha</code></td>
<td>
<p>logical value indicating whether the alpha channel (opacity) values should be returned.</p>
</td></tr>
</table>

<hr>
<h2 id='constructFormula'>Construct a model formula from parameter constraint matrix</h2><span id='topic+constructFormula'></span>

<h3>Description</h3>

<p>For parameter names defined in <code>naming</code> vector, formula is constructed
so that <code>consMatrix %*% naming = consVector</code> is satisfied. Constraint
coefficients are normalized and convert into fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructFormula(
  consMatrix = NULL,
  consVector = NULL,
  naming = c("h1", "h2", "b", "m1", "m2", "e1", "e2"),
  extraVars = c("d1", "d2"),
  formulaArgs = c("effect", "fn")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constructFormula_+3A_consmatrix">consMatrix</code></td>
<td>
<p>Constraint matrix</p>
</td></tr>
<tr><td><code id="constructFormula_+3A_consvector">consVector</code></td>
<td>
<p>Constraint vector</p>
</td></tr>
<tr><td><code id="constructFormula_+3A_naming">naming</code></td>
<td>
<p>Parameter names</p>
</td></tr>
<tr><td><code id="constructFormula_+3A_extravars">extraVars</code></td>
<td>
<p>Non-parameter variables used in the formula and function
evaluation. These will be appended to the formula.</p>
</td></tr>
<tr><td><code id="constructFormula_+3A_formulaargs">formulaArgs</code></td>
<td>
<p>Character vector of length two. First element indicates
name for the response variable. Second element indicates name of the
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a model construct appropriate for
<code><a href="#topic+fitMarginals">fitMarginals</a></code> function. It also separates variables into those
that are free and those which are constrained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  constM &lt;- rbind(c(0, 0, 1, 0, 0, 0, 0),
                  c(0, 0, 0, -1, 1, 0, 0))
  constV &lt;- c(0.9, 0)
  constructFormula(constM, constV)
</code></pre>

<hr>
<h2 id='contour.ResponseSurface'>Method for plotting of contours based on maxR statistics</h2><span id='topic+contour.ResponseSurface'></span>

<h3>Description</h3>

<p>Method for plotting of contours based on maxR statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResponseSurface'
contour(
  x,
  colorBy = "maxR",
  reverse.x = FALSE,
  reverse.y = FALSE,
  swapAxes = FALSE,
  greyScale = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour.ResponseSurface_+3A_x">x</code></td>
<td>
<p>Output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="contour.ResponseSurface_+3A_colorby">colorBy</code></td>
<td>
<p>String indicating the characteristic to use for coloring (&quot;maxR&quot; or &quot;effect-size&quot;). By default, &quot;maxR&quot;.</p>
</td></tr>
<tr><td><code id="contour.ResponseSurface_+3A_reverse.x">reverse.x</code></td>
<td>
<p>Reverse x axis?</p>
</td></tr>
<tr><td><code id="contour.ResponseSurface_+3A_reverse.y">reverse.y</code></td>
<td>
<p>Reverse y axis?</p>
</td></tr>
<tr><td><code id="contour.ResponseSurface_+3A_swapaxes">swapAxes</code></td>
<td>
<p>Swap x and y axes?</p>
</td></tr>
<tr><td><code id="contour.ResponseSurface_+3A_greyscale">greyScale</code></td>
<td>
<p>If <code>greyScale = TRUE</code>, then plot is in grey scale,
otherwise in colour.</p>
</td></tr>
<tr><td><code id="contour.ResponseSurface_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="#topic+plot.maxR">plot.maxR</a></code> or <code><a href="#topic+plot.effect-size">plot.effect-size</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='df.residual.MarginalFit'>Residual degrees of freedom in marginal model estimation</h2><span id='topic+df.residual.MarginalFit'></span>

<h3>Description</h3>

<p>Residual degrees of freedom in marginal model estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.residual.MarginalFit_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function</p>
</td></tr>
<tr><td><code id="df.residual.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='directAntivirals'>Partial data with combination experiments of direct-acting antivirals</h2><span id='topic+directAntivirals'></span>

<h3>Description</h3>

<p>A dataset containing 11 combination experiments of direct-acting antivirals.
</p>


<h3>Format</h3>

<p>A data frame with 3520 rows and 6 variables:
</p>

<ul>
<li><p> experiment: ID of experiment (1-11)
</p>
</li>
<li><p> cpd1: name of the first compound (4 different compounds)
</p>
</li>
<li><p> cpd2: name of the second compound (11 different compounds)
</p>
</li>
<li><p> effect: observed effect (cell count)
</p>
</li>
<li><p> d1: dose of the first compound
</p>
</li>
<li><p> d2: dose of the second compound
</p>
</li></ul>


<hr>
<h2 id='directAntivirals_ALL'>Full data with combination experiments of direct-acting antivirals</h2><span id='topic+directAntivirals_ALL'></span>

<h3>Description</h3>

<p>A dataset containing 11 combination experiments of direct-acting antivirals.
This dataset is larger than <code>directAntivirals</code> dataset as it includes
concentrations at levels of <code>1e6</code> which can render plots visually
unappealing.
</p>


<h3>Format</h3>

<p>A data frame with 4224 rows and 6 variables:
</p>

<ul>
<li><p> experiment: ID of experiment (1-11)
</p>
</li>
<li><p> cpd1: name of the first compound (4 different compounds)
</p>
</li>
<li><p> cpd2: name of the second compound (11 different compounds)
</p>
</li>
<li><p> effect: observed effect (cell count)
</p>
</li>
<li><p> d1: dose of the first compound
</p>
</li>
<li><p> d2: dose of the second compound
</p>
</li></ul>


<hr>
<h2 id='fitMarginals'>Fit two 4-parameter log-logistic functions for a synergy experiment</h2><span id='topic+fitMarginals'></span>

<h3>Description</h3>

<p>This function uses dose-response data for two compounds and estimates
coefficients for monotherapy models of both of these compounds such that they
share a common baseline. Currently, these coefficients are estimated by
default using a non-linear least squares approximation. Although entire
dose-response data can be provided, estimation will subset the part of data
where at least one of the compounds is dosed at zero, i.e. on-axis data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMarginals(
  data,
  transforms = NULL,
  start = NULL,
  constraints = NULL,
  fixed = NULL,
  method = c("nlslm", "nls", "optim"),
  names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitMarginals_+3A_data">data</code></td>
<td>
<p>Dose-response dataframe. Marginal data will be extracted from
it automatically.</p>
</td></tr>
<tr><td><code id="fitMarginals_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="fitMarginals_+3A_start">start</code></td>
<td>
<p>Starting parameter values. If not specified, they will be
obtained from <code><a href="#topic+initialMarginal">initialMarginal</a></code>.</p>
</td></tr>
<tr><td><code id="fitMarginals_+3A_constraints">constraints</code></td>
<td>
<p>List of constraint matrix and vector which will be passed
to <code><a href="#topic+constructFormula">constructFormula</a></code>. If <code>constraints = NULL</code>, no
constraints on parameter estimation will be imposed.</p>
</td></tr>
<tr><td><code id="fitMarginals_+3A_fixed">fixed</code></td>
<td>
<p>This arguments provides a user-friendly alternative to impose a
fixed value for marginal parameters. It must be a named vector with names
contained in <code>c("h1", "h2", "b", "m1", "m2", "e1", "e2")</code>. For
example, <code>fixed = c("m1" = 1, "h1" = 1)</code> will automatically generate
appropriate constraint matrix and vector to set the maximal response and
the Hill coefficient of the first compound to 1. If both <code>constraints</code>
and <code>fixed</code> arguments are passed, then only <code>fixed</code> will be used.</p>
</td></tr>
<tr><td><code id="fitMarginals_+3A_method">method</code></td>
<td>
<p>Which estimation method should be used to obtain the estimates.
If <code>method = "nls"</code>, simple non-linear least squares
<code><a href="stats.html#topic+nls">nls</a></code> will be used. If <code>method = "nlslm"</code>
Levenberg-Marquardt non-linear least squares
<code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code> is used instead (default). If <code>method
= "optim"</code>, residual sum of squares will be minimized using general purpose
optimization based on Nelder-Mean algorithm in <code><a href="stats.html#topic+optim">optim</a></code>.
This method can be noticeably slower than the non-linear least squares
methods.</p>
</td></tr>
<tr><td><code id="fitMarginals_+3A_names">names</code></td>
<td>
<p>Compound names to be used on the plot labels.</p>
</td></tr>
<tr><td><code id="fitMarginals_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to the optimizer function, 
such as <code>lower</code> or <code>upper</code> (for the &quot;nlslm&quot; method), or 
<code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model formula is specified as <code>effect ~ fn(h1, h2, ...)</code> where <code>fn</code>
is a hard-coded function which fits two 4-parameter log-logistic functions
simultaneously so that the baseline can be shared. If transformation
functions are provided, <code>fn</code> is consequently adjusted to account for
them.
</p>


<h3>Value</h3>

<p>This function returns a <code>MarginalFit</code> object with monotherapy
coefficient estimates and diverse information regarding monotherapy
estimation. <code>MarginalFit</code> object is essentially a list with
appropriately named elements.
</p>
<p>Among these list elements, <code>"coef"</code> is a named vector with parameter
estimates. <code>h1</code> and <code>h2</code> are Hill's slope coefficients for each
of the compounds, <code>m1</code> and <code>m2</code> are their maximal response levels
whereas <code>b</code> is the shared baseline. Lastly, <code>e1</code> and <code>e2</code>
are log-transformed EC50 values.
</p>
<p><code>"sigma"</code> is standard deviation of residuals for the estimated
monotherapy model and <code>"df"</code> is the degrees of freedom for the
residuals. <code>"vcov"</code> is the variance-covariance matrix of the estimated
parameters.
</p>
<p>Return object also contains information regarding data, biological and
power transformations used in this estimation as well as model construct
and method of estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data &lt;- subset(directAntivirals, experiment == 1)
  ## Data must contain d1, d2 and effect columns
  transforms &lt;- getTransformations(data)
  fitMarginals(data, transforms)
</code></pre>

<hr>
<h2 id='fitSurface'>Fit response surface model and compute meanR and maxR statistics</h2><span id='topic+fitSurface'></span>

<h3>Description</h3>

<p>This function computes predictions for off-axis dose combinations according
to the BIGL or HSA null model and, if required, computes appropriate meanR
and maxR statistics. Function requires as input dose-response dataframe and
output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> containing estimates for the monotherapy
model. If transformation functions were used in monotherapy estimation, these
should also be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSurface(
  data,
  fitResult,
  transforms = fitResult$transforms,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  effect = "effect",
  d1 = "d1",
  d2 = "d2",
  statistic = c("none", "meanR", "maxR", "both"),
  CP = NULL,
  B.CP = 50,
  B.B = NULL,
  nested_bootstrap = FALSE,
  error = 4,
  sampling_errors = NULL,
  wild_bootstrap = FALSE,
  wild_bootType = "normal",
  control = "FWER",
  cutoff = 0.95,
  parallel = FALSE,
  progressBar = TRUE,
  method = c("equal", "model", "unequal"),
  confInt = TRUE,
  digits = 9,
  bootRS = TRUE,
  trans = "identity",
  rescaleResids = FALSE,
  invtrans = switch(trans, identity = "identity", log = "exp"),
  newtonRaphson = FALSE,
  asymptotes = 2,
  bootmethod = method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitSurface_+3A_data">data</code></td>
<td>
<p>Dose-response dataframe.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_fitresult">fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code><a href="#topic+fitMarginals">fitMarginals</a></code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_effect">effect</code></td>
<td>
<p>Name of the response column in the data (&quot;effect&quot;)</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_d1">d1</code></td>
<td>
<p>Name of the column with doses of the first compound (&quot;d1&quot;)</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_d2">d2</code></td>
<td>
<p>Name of the column with doses of the second compound (&quot;d2&quot;)</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_statistic">statistic</code></td>
<td>
<p>Which statistics should be computed. This argument can take
one of the values from <code>c("none", "meanR", "maxR", "both")</code>.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_cp">CP</code></td>
<td>
<p>Prediction covariance matrix. If not specified, it will be estimated
by bootstrap using <code>B.CP</code> iterations.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_b.cp">B.CP</code></td>
<td>
<p>Number of bootstrap iterations to use for CP matrix estimation</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_b.b">B.B</code></td>
<td>
<p>Number of iterations to use in bootstrapping null distribution for
either meanR or maxR statistics.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_nested_bootstrap">nested_bootstrap</code></td>
<td>
<p>When statistics are calculated, if
<code>nested_bootstrap = TRUE</code>, <code>CP</code> matrix is recalculated at each
bootstrap iteration of <code>B.B</code> using <code>B.CP</code> iterations. Using such
nested bootstrap may however significantly increase computational time. If
<code>nested_bootstrap = FALSE</code>, <code>CP</code> bootstrapped data reuses
<code>CP</code> matrix calculated from the original data.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_error">error</code></td>
<td>
<p>Type of error for resampling in the bootstrapping procedure.
This argument will be passed to <code><a href="#topic+generateData">generateData</a></code>. If <code>error
= 4</code> (default), the error terms for generating distribution of the null
will be resampled from the vector specified in <code>sampling_errors</code>. If
<code>error = 1</code>, normal errors are added. If <code>error = 2</code>, errors are
sampled from a mixture of two normal distributions. If <code>error = 3</code>,
errors are generated from a rescaled chi-square distribution.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_sampling_errors">sampling_errors</code></td>
<td>
<p>Sampling vector to resample errors from. Used only if
<code>error</code> is 4 and is passed as argument to <code><a href="#topic+generateData">generateData</a></code>.
If <code>sampling_errors = NULL</code> (default), mean residuals at off-axis
points between observed and predicted response are taken.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_wild_bootstrap">wild_bootstrap</code></td>
<td>
<p>Whether special bootstrap to correct for
heteroskedasticity should be used. If <code>wild_bootstrap = TRUE</code>, errors
are generated from <code>sampling_errors</code> multiplied by a random variable
following Rademacher distribution. Argument is used only if <code>error = 4</code>.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_wild_boottype">wild_bootType</code></td>
<td>
<p>Type of distribution to be used for wild bootstrap. If <code>wild_bootstrap = TRUE</code>, 
errors are generated from &quot;rademacher&quot;, &quot;gamma&quot;, &quot;normal&quot; or &quot;two-point&quot; distribution.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_control">control</code></td>
<td>
<p>If <code>control = "FCR"</code> then algorithm controls false coverage rate, if <code>control = "dFCR"</code> then 
algorithm controls directional false coverage rate, if <code>control = "FWER"</code> then 
algorithm controls family wise error rate</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_cutoff">cutoff</code></td>
<td>
<p>Cut-off to use in maxR procedure for declaring non-additivity
(default is 0.95).</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallel computing should be used for bootstrap. This
parameter can take either integer value to specify the number of threads to
be used or logical <code>TRUE/FALSE</code>. If <code>parallel = TRUE</code>, then
<code>max(1, detectCores()-1)</code> is set to be the number of threads. If
<code>parallel = FALSE</code>, then a single thread is used and cluster object
is not created.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_progressbar">progressBar</code></td>
<td>
<p>A boolean, should progress of bootstraps be shown?</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_method">method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_confint">confInt</code></td>
<td>
<p>a boolean, should confidence intervals be returned?</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_digits">digits</code></td>
<td>
<p>Numeric value indicating the number of digits used for numeric values in confidence intervals</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_bootrs">bootRS</code></td>
<td>
<p>a boolean, should bootstrapped response surfaces be used in the
calculation of the confidence intervals?</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_trans">trans</code>, <code id="fitSurface_+3A_invtrans">invtrans</code></td>
<td>
<p>the transformation function for the variance and its
inverse, possibly as strings</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_rescaleresids">rescaleResids</code></td>
<td>
<p>a boolean indicating whether to rescale residuals,
or else normality of the residuals is assumed.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_newtonraphson">newtonRaphson</code></td>
<td>
<p>A boolean, should Newton-Raphson be used to find Loewe
response surfaces? May be faster but also less stable to switch on</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_asymptotes">asymptotes</code></td>
<td>
<p>Number of asymptotes. It can be either <code>1</code>
as in standard Loewe model or <code>2</code> as in generalized Loewe model.</p>
</td></tr>
<tr><td><code id="fitSurface_+3A_bootmethod">bootmethod</code></td>
<td>
<p>The resampling method to be used in the bootstraps. Defaults to the same as method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see the example vignette <code>vignette("analysis", package = "BIGL")</code>
and the report &quot;Lack of fit test for detecting synergy&quot; included in the
<code>papers</code> folder for further details on the test statistics used:
<code>system.file("papers", "newStatistics.pdf", package = "BIGL")</code>
</p>


<h3>Value</h3>

<p>This function returns a <code>ResponseSurface</code> object with estimates
of the predicted surface. <code>ResponseSurface</code> object is essentially a
list with appropriately named elements.
</p>
<p>Elements of the list include input data, monotherapy model coefficients and
transformation functions, null model used to construct the surface as well
as estimated CP matrix, occupancy level at
each dose combination according to the generalized Loewe model and
<code>"offAxisTable"</code> element which contains observed and predicted effects
as well as estimated z-scores for each dose combination.
</p>
<p>If statistical testing was done, returned object contains <code>"meanR"</code>
and <code>"maxR"</code> elements with output from <code><a href="#topic+meanR">meanR</a></code> and
<code><a href="#topic+maxR">maxR</a></code> respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data &lt;- subset(directAntivirals, experiment == 4)
  ## Data should contain d1, d2 and effect columns
  transforms &lt;- list("PowerT" = function(x, args) with(args, log(x)),
                     "InvPowerT" = function(y, args) with(args, exp(y)),
                     "BiolT" = function(x, args) with(args, N0 * exp(x * time.hours)),
                     "InvBiolT" = function(y, args) with(args, 1/time.hours * log(y/N0)),
                     "compositeArgs" = list(N0 = 1, time.hours = 72))
  fitResult &lt;- fitMarginals(data, transforms)
  surf &lt;- fitSurface(data, fitResult, statistic = "meanR")
  summary(surf)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.MarginalFit'>Compute fitted values from monotherapy estimation</h2><span id='topic+fitted.MarginalFit'></span>

<h3>Description</h3>

<p>Compute fitted values from monotherapy estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.MarginalFit_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function</p>
</td></tr>
<tr><td><code id="fitted.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.ResponseSurface'>Predicted values of the response surface according to the given null model</h2><span id='topic+fitted.ResponseSurface'></span>

<h3>Description</h3>

<p>Predicted values of the response surface according to the given null model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResponseSurface'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.ResponseSurface_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="fitted.ResponseSurface_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>

<hr>
<h2 id='generalizedLoewe'>Compute combined predicted response from drug doses according to standard or
generalized Loewe model.</h2><span id='topic+generalizedLoewe'></span>

<h3>Description</h3>

<p>Compute combined predicted response from drug doses according to standard or
generalized Loewe model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generalizedLoewe(
  doseInput,
  parmInput,
  asymptotes = 2,
  startvalues = NULL,
  newtonRaphson = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalizedLoewe_+3A_doseinput">doseInput</code></td>
<td>
<p>Dose-response dataframe containing <code>"d1"</code> and
<code>"d2"</code> columns</p>
</td></tr>
<tr><td><code id="generalizedLoewe_+3A_parminput">parmInput</code></td>
<td>
<p>Numeric vector or list with appropriately named
parameter inputs. Typically, it will be coefficients from a
<code>MarginalFit</code> object.</p>
</td></tr>
<tr><td><code id="generalizedLoewe_+3A_asymptotes">asymptotes</code></td>
<td>
<p>Number of asymptotes. It can be either <code>1</code>
as in standard Loewe model or <code>2</code> as in generalized Loewe model.</p>
</td></tr>
<tr><td><code id="generalizedLoewe_+3A_startvalues">startvalues</code></td>
<td>
<p>Starting values for the non-linear equation,
from the observed data</p>
</td></tr>
<tr><td><code id="generalizedLoewe_+3A_newtonraphson">newtonRaphson</code></td>
<td>
<p>a boolean, is Newton raphson used for finding the
response surface? May be faster but also less stable</p>
</td></tr>
<tr><td><code id="generalizedLoewe_+3A_...">...</code></td>
<td>
<p>Further arguments that are currently unused</p>
</td></tr>
</table>

<hr>
<h2 id='generateData'>Generate data from parameters of marginal monotherapy model</h2><span id='topic+generateData'></span>

<h3>Description</h3>

<p>This function is used to generate data for bootstrapping of the null
distribution for various estimates. Optional arguments such as specific
choice of sampling vector or corrections for heteroskedasticity can be
specified in the function arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateData(
  pars,
  sigma,
  data = NULL,
  transforms = NULL,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  error = 1,
  sampling_errors = NULL,
  means = NULL,
  model = NULL,
  method = "equal",
  wild_bootstrap = FALSE,
  wild_bootType = "normal",
  rescaleResids,
  invTransFun,
  newtonRaphson = FALSE,
  bootmethod = method,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateData_+3A_pars">pars</code></td>
<td>
<p>Coefficients of the marginal model along with their appropriate
naming scheme. These will typically be estimated using
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. Futhermore, <code>pars</code> can simply be a
<code>MarginalFit</code> object and <code>transforms</code> object will be
automatically extracted.</p>
</td></tr>
<tr><td><code id="generateData_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation to use for randomly generated error terms. This
argument is unused if <code>error = 4</code> so that sampling error vector is
provided.</p>
</td></tr>
<tr><td><code id="generateData_+3A_data">data</code></td>
<td>
<p>Data frame with dose columns <code>("d1", "d2")</code> to generate the
effect for. Only <code>"d1"</code> and <code>"d2"</code> columns of the dose-response
dataframe should be passed to this argument. <code>"effect"</code> column should
not be passed and if it is, the column will be replaced by simulated data.</p>
</td></tr>
<tr><td><code id="generateData_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="generateData_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="generateData_+3A_error">error</code></td>
<td>
<p>Type of error for resampling. <code>error = 1</code> (Default) adds
normal errors to the simulated effects, <code>error = 2</code> adds errors sampled
from a mixture of two normal distributions, <code>error = 3</code> generates errors
from a rescaled chi-square distribution. <code>error = 4</code> will use bootstrap.
Choosing this option, the error terms will be resampled from the vector
specified in <code>sampling_errors</code>.</p>
</td></tr>
<tr><td><code id="generateData_+3A_sampling_errors">sampling_errors</code></td>
<td>
<p>Sampling vector to resample errors from. Used only if
<code>error = 4</code>.</p>
</td></tr>
<tr><td><code id="generateData_+3A_means">means</code></td>
<td>
<p>The vector of mean values of the response surface, for variance modelling</p>
</td></tr>
<tr><td><code id="generateData_+3A_model">model</code></td>
<td>
<p>The mean-variance model</p>
</td></tr>
<tr><td><code id="generateData_+3A_method">method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td></tr>
<tr><td><code id="generateData_+3A_wild_bootstrap">wild_bootstrap</code></td>
<td>
<p>Whether special bootstrap to correct for
heteroskedasticity should be used. If <code>wild_bootstrap = TRUE</code>, errors
are generated from <code>sampling_errors</code> multiplied by a random variable
following Rademacher distribution. Argument is used only if <code>error = 4</code>.</p>
</td></tr>
<tr><td><code id="generateData_+3A_wild_boottype">wild_bootType</code></td>
<td>
<p>Type of distribution to be used for wild bootstrap. If <code>wild_bootstrap = TRUE</code>, 
errors are generated from &quot;rademacher&quot;, &quot;gamma&quot;, &quot;normal&quot; or &quot;two-point&quot; distribution.</p>
</td></tr>
<tr><td><code id="generateData_+3A_rescaleresids">rescaleResids</code></td>
<td>
<p>a boolean indicating whether to rescale residuals,
or else normality of the residuals is assumed.</p>
</td></tr>
<tr><td><code id="generateData_+3A_invtransfun">invTransFun</code></td>
<td>
<p>the inverse transformation function, back to the variance domain</p>
</td></tr>
<tr><td><code id="generateData_+3A_newtonraphson">newtonRaphson</code></td>
<td>
<p>A boolean, should Newton-Raphson be used to find Loewe
response surfaces? May be faster but also less stable to switch on</p>
</td></tr>
<tr><td><code id="generateData_+3A_bootmethod">bootmethod</code></td>
<td>
<p>The resampling method to be used in the bootstraps. Defaults to the same as method</p>
</td></tr>
<tr><td><code id="generateData_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dose-response dataframe with generated data including <code>"effect"</code>
as well as <code>"d1"</code> and <code>"d2"</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  coefs &lt;- c("h1" = 1, "h2" = 1.5, "b" = 0,
             "m1" = 1, "m2" = 2, "e1" = 0.5, "e2" = 0.1)

  ## Dose levels are set to be integers from 0 to 10
  generateData(coefs, sigma = 1)

  ## Dose levels are taken from existing dataset with d1 and d2 columns
  data &lt;- subset(directAntivirals, experiment == 1)
  generateData(data = data[, c("d1", "d2")], pars = coefs, sigma = 1)
</code></pre>

<hr>
<h2 id='get.abs_tval'>Return absolute t-value, used in optimization call in
<code><a href="#topic+optim.boxcox">optim.boxcox</a></code></h2><span id='topic+get.abs_tval'></span>

<h3>Description</h3>

<p>Return absolute t-value, used in optimization call in
<code><a href="#topic+optim.boxcox">optim.boxcox</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.abs_tval(value, fac, lambda, zero.add2 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.abs_tval_+3A_value">value</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="get.abs_tval_+3A_fac">fac</code></td>
<td>
<p>factor</p>
</td></tr>
<tr><td><code id="get.abs_tval_+3A_lambda">lambda</code></td>
<td>
<p>box-cox parameter</p>
</td></tr>
<tr><td><code id="get.abs_tval_+3A_zero.add2">zero.add2</code></td>
<td>
<p>2nd box-cox parameter</p>
</td></tr>
</table>

<hr>
<h2 id='get.summ.data'>Summarize data by factor</h2><span id='topic+get.summ.data'></span>

<h3>Description</h3>

<p>Summarize data by factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.summ.data(value, fac)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.summ.data_+3A_value">value</code></td>
<td>
<p>data to sumamrize</p>
</td></tr>
<tr><td><code id="get.summ.data_+3A_fac">fac</code></td>
<td>
<p>factor to summarize by</p>
</td></tr>
</table>

<hr>
<h2 id='getCP'>Estimate CP matrix from bootstraps</h2><span id='topic+getCP'></span>

<h3>Description</h3>

<p>This function is generally called from within <code><a href="#topic+fitSurface">fitSurface</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCP(bootStraps, null_model, transforms, sigma0, doseGrid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCP_+3A_bootstraps">bootStraps</code></td>
<td>
<p>the bootstraps carried out already</p>
</td></tr>
<tr><td><code id="getCP_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="getCP_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="getCP_+3A_sigma0">sigma0</code></td>
<td>
<p>standard deviation of the null model on the real data</p>
</td></tr>
<tr><td><code id="getCP_+3A_dosegrid">doseGrid</code></td>
<td>
<p>a grid of dose combinations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated CP matrix
</p>

<hr>
<h2 id='getd1d2'>A function to get the d1d2 identifier</h2><span id='topic+getd1d2'></span>

<h3>Description</h3>

<p>A function to get the d1d2 identifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getd1d2(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getd1d2_+3A_dat">dat</code></td>
<td>
<p>the data frame containing d1 and d2 entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of d1d2 identifiers
</p>

<hr>
<h2 id='getR'>Helper functions for the test statistics</h2><span id='topic+getR'></span>

<h3>Description</h3>

<p>Helper functions for the test statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getR(data, idUnique, transforms, respS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getR_+3A_data">data</code></td>
<td>
<p>the datasets</p>
</td></tr>
<tr><td><code id="getR_+3A_idunique">idUnique</code></td>
<td>
<p>id of unique off axis points</p>
</td></tr>
<tr><td><code id="getR_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="getR_+3A_resps">respS</code></td>
<td>
<p>the evaluated response surface</p>
</td></tr>
</table>

<hr>
<h2 id='GetStartGuess'>Estimate initial values for dose-response curve fit</h2><span id='topic+GetStartGuess'></span>

<h3>Description</h3>

<p>Estimate initial values for dose-response curve fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetStartGuess(df, transforms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetStartGuess_+3A_df">df</code></td>
<td>
<p>Dose-response dataframe containing <code>"dose"</code> and
<code>"effect"</code> columns</p>
</td></tr>
<tr><td><code id="GetStartGuess_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
</table>

<hr>
<h2 id='getTransformations'>Return a list with transformation functions</h2><span id='topic+getTransformations'></span>

<h3>Description</h3>

<p>This function takes in response data from a dose-response model and attempts
to find an optimal Box-Cox power transform based on
<code><a href="#topic+optim.boxcox">optim.boxcox</a></code> function. It then returns a list of transformation
functions which contains this power transform and its inverse which can be
subsequently used in <code><a href="#topic+fitMarginals">fitMarginals</a></code> and <code><a href="#topic+fitSurface">fitSurface</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransformations(data, shift = FALSE, args = list(N0 = 1, time.hours = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransformations_+3A_data">data</code></td>
<td>
<p>Dose-response dataframe.</p>
</td></tr>
<tr><td><code id="getTransformations_+3A_shift">shift</code></td>
<td>
<p>If <code>TRUE</code> or is a numeric value, then a two-parameter
Box-Cox transformation is assumed. This parameter will be passed on to
<code><a href="#topic+optim.boxcox">optim.boxcox</a></code> function.</p>
</td></tr>
<tr><td><code id="getTransformations_+3A_args">args</code></td>
<td>
<p>List with elements that are added to the list of transformation
function and which can be used by these functions. In particular, this
list should be of type <code>args = list("N0" = 1, "time.hours" = 1)</code> where
<code>N0</code> and <code>time.hours</code> are arguments used for the biological
transform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additionally, returned list contains biological transform and its inverse
based on a simple exponential growth model, especially useful when response
data is provided in cell counts. User can additionally provide arguments for
these biological transforms where <code>N0</code> stands for initial cell count and
<code>time.hours</code> indicates number in hours after which response data was
measured.
</p>
<p><code><a href="#topic+getTransformations">getTransformations</a></code> relies on
<code><a href="#topic+optim.boxcox">optim.boxcox</a></code> to obtain the optimal Box-Cox transformation
parameters. However, <code><a href="#topic+optim.boxcox">optim.boxcox</a></code> optimizes for the power
parameter only within the interval (0.1, 0.9). Hence, if obtained power
parameter is close to 0.1, then a logarithmic transformation is applied
instead.
</p>


<h3>Value</h3>

<p>This function returns a list with transformation functions. These
include power transformation (<code>"PowerT"</code>) and its inverse
(<code>"InvPowerT"</code>) as well as biological transformation (<code>"BiolT"</code>)
and its inverse (<code>"InvBiolT"</code>).
</p>
<p>Power transformation is a 1-parameter Box-Cox transformation. If
<code>shift = TRUE</code>, then power transformation is a 2-parameter Box-Cox
transformation. Optimal values for power and shift operators are selected
by means of <code><a href="#topic+optim.boxcox">optim.boxcox</a></code> function.
</p>
<p>Biological transformation <code>y = N0 * exp(x * t)</code> where <code>N0</code> is the
initial cell count and <code>t</code> is the incubation time. If response/effect
variable (<code>y</code>) is given in terms of cell counts, biological
transformation ensures that modelisation is done for the growth rate
instead (<code>x</code>).
</p>
<p>Returned list also contains <code>"compositeArgs"</code> elements shared by all
the transformation functions. These arguments include initial cell count
(<code>"N0"</code>) and incubation time (<code>"time.hours"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data &lt;- subset(directAntivirals, experiment == 1)
  ## Data must contain d1, d2 and effect columns
  getTransformations(data)
</code></pre>

<hr>
<h2 id='harbronLoewe'>Alternative Loewe generalization</h2><span id='topic+harbronLoewe'></span>

<h3>Description</h3>

<p>Alternative Loewe generalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harbronLoewe(
  doseInput,
  parmInput,
  asymptotes = 2,
  startvalues = NULL,
  newtonRaphson = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harbronLoewe_+3A_doseinput">doseInput</code></td>
<td>
<p>Dose-response dataframe containing <code>"d1"</code> and
<code>"d2"</code> columns</p>
</td></tr>
<tr><td><code id="harbronLoewe_+3A_parminput">parmInput</code></td>
<td>
<p>Numeric vector or list with appropriately named
parameter inputs. Typically, it will be coefficients from a
<code>MarginalFit</code> object.</p>
</td></tr>
<tr><td><code id="harbronLoewe_+3A_asymptotes">asymptotes</code></td>
<td>
<p>Number of asymptotes. It can be either <code>1</code>
as in standard Loewe model or <code>2</code> as in generalized Loewe model.</p>
</td></tr>
<tr><td><code id="harbronLoewe_+3A_startvalues">startvalues</code></td>
<td>
<p>Starting values for the non-linear equation,
from the observed data</p>
</td></tr>
<tr><td><code id="harbronLoewe_+3A_newtonraphson">newtonRaphson</code></td>
<td>
<p>a boolean, is Newton raphson used for finding the
response surface? May be faster but also less stable</p>
</td></tr>
<tr><td><code id="harbronLoewe_+3A_...">...</code></td>
<td>
<p>Further arguments that are currently unused</p>
</td></tr>
</table>

<hr>
<h2 id='hsa'>Highest Single Agent model</h2><span id='topic+hsa'></span>

<h3>Description</h3>

<p>This function returns response levels for when these are based on
Highest Single Agent (HSA) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsa(doseInput, parmInput, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsa_+3A_doseinput">doseInput</code></td>
<td>
<p>Dose-response dataframe containing <code>"d1"</code> and
<code>"d2"</code> columns</p>
</td></tr>
<tr><td><code id="hsa_+3A_parminput">parmInput</code></td>
<td>
<p>Numeric vector or list with appropriately named
parameter inputs. Typically, it will be coefficients from a
<code>MarginalFit</code> object.</p>
</td></tr>
<tr><td><code id="hsa_+3A_...">...</code></td>
<td>
<p>Further arguments that are currently unused</p>
</td></tr>
</table>

<hr>
<h2 id='initialMarginal'>Estimate initial values for fitting marginal dose-response curves</h2><span id='topic+initialMarginal'></span>

<h3>Description</h3>

<p>This is a wrapper function which, when a dose-response dataframe is provided,
returns start value estimates for both compounds that could be supplied to
<code><a href="#topic+fitMarginals">fitMarginals</a></code> function. This function is also used by
<code><a href="#topic+fitMarginals">fitMarginals</a></code> if no initials values were supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialMarginal(data, transforms = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialMarginal_+3A_data">data</code></td>
<td>
<p>Dose-response dataframe. Marginal data will be extracted from
it automatically.</p>
</td></tr>
<tr><td><code id="initialMarginal_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="initialMarginal_+3A_...">...</code></td>
<td>
<p>Further parameters that are currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function returns <code>e1</code> and <code>2</code> which are
log-transformed inflection points for respective compounds.
</p>


<h3>Value</h3>

<p>Named vector with parameter estimates. Parameter names are consistent
with parameter names in <code><a href="#topic+fitMarginals">fitMarginals</a></code>. <code>h1</code> and <code>h2</code>
are Hill's slope coefficients for each of the compounds, <code>m1</code> and
<code>m2</code> are their maximal response levels whereas <code>b</code> is the shared
baseline. Lastly, <code>e1</code> and <code>e2</code> are log-transformed EC50 values.
</p>


<h3>Note</h3>

<p>Returns starting value for e = log(EC50).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data &lt;- subset(directAntivirals, experiment == 1)
  ## Data must contain d1, d2 and effect columns
  transforms &lt;- getTransformations(data)
  initialMarginal(data, transforms)
</code></pre>

<hr>
<h2 id='isobologram'>Isobologram of the response surface predicted by the null model</h2><span id='topic+isobologram'></span>

<h3>Description</h3>

<p>If transformation functions are used, then the isobologram response levels
will be plotted on the transformed scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isobologram(x, grid.len = 100, logScale = TRUE, greyScale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isobologram_+3A_x">x</code></td>
<td>
<p>Output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="isobologram_+3A_grid.len">grid.len</code></td>
<td>
<p>Number of concentrations to plot for each compound in the
contour plot. An evenly spaced grid of doses will be generated for each
compound given its respective observed minimum and maximum doses. Note that
<code>grid.len^2</code> computations will be needed later so this number should
stay reasonably low.</p>
</td></tr>
<tr><td><code id="isobologram_+3A_logscale">logScale</code></td>
<td>
<p>If <code>logScale = TRUE</code>, then grid of doses is evenly
spaced in the logarithmic scale.</p>
</td></tr>
<tr><td><code id="isobologram_+3A_greyscale">greyScale</code></td>
<td>
<p>If <code>greyScale = TRUE</code>, then plot is in grey scale,
otherwise in colour.</p>
</td></tr>
<tr><td><code id="isobologram_+3A_...">...</code></td>
<td>
<p>Further parameters that are not used at this moment.</p>
</td></tr>
</table>

<hr>
<h2 id='L4'>4-parameter logistic dose-response function</h2><span id='topic+L4'></span>

<h3>Description</h3>

<p>4-parameter logistic dose-response function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L4(dose, b, L, U, logEC50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L4_+3A_dose">dose</code></td>
<td>
<p>Dose level</p>
</td></tr>
<tr><td><code id="L4_+3A_b">b</code></td>
<td>
<p>Hill's coefficient (slope of the curve)</p>
</td></tr>
<tr><td><code id="L4_+3A_l">L</code></td>
<td>
<p>Baseline effect (at zero dose)</p>
</td></tr>
<tr><td><code id="L4_+3A_u">U</code></td>
<td>
<p>Asymptote effect (at infinite dose)</p>
</td></tr>
<tr><td><code id="L4_+3A_logec50">logEC50</code></td>
<td>
<p>Point of inflection (in logarithmic terms)</p>
</td></tr>
</table>

<hr>
<h2 id='marginalNLS'>Fit two 4-parameter log-logistic functions with non-linear least squares</h2><span id='topic+marginalNLS'></span>

<h3>Description</h3>

<p>This function does not automatically extract marginal data and requires
model input obtained from <code><a href="#topic+constructFormula">constructFormula</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalNLS(data, transforms = NULL, start, model, nlsfn = nls, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalNLS_+3A_data">data</code></td>
<td>
<p>Dose-response dataframe. Marginal data will be extracted from
it automatically.</p>
</td></tr>
<tr><td><code id="marginalNLS_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="marginalNLS_+3A_start">start</code></td>
<td>
<p>Starting parameter values. If not specified, they will be
obtained from <code><a href="#topic+initialMarginal">initialMarginal</a></code>.</p>
</td></tr>
<tr><td><code id="marginalNLS_+3A_model">model</code></td>
<td>
<p>List with model parameters. Typically, this is an output from
<code><a href="#topic+constructFormula">constructFormula</a></code>.</p>
</td></tr>
<tr><td><code id="marginalNLS_+3A_nlsfn">nlsfn</code></td>
<td>
<p>Non-linear least-squares optimizer function</p>
</td></tr>
<tr><td><code id="marginalNLS_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to the optimizer function, 
such as <code>lower</code> or <code>upper</code> (for the &quot;nlslm&quot; method), or 
<code>control</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='marginalOptim'>Fit two 4-parameter log-logistic functions with common baseline</h2><span id='topic+marginalOptim'></span>

<h3>Description</h3>

<p>This function is an alternative to non-linear least squares and
provides optimization framework with <code><a href="stats.html#topic+optim">optim</a></code> function.
It is however noticeably slower than NLS methods and can be especially
time consuming in large datasets, in particular if bootstrap statistics
are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalOptim(data, transforms = NULL, start, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalOptim_+3A_data">data</code></td>
<td>
<p>Dose-response dataframe. Marginal data will be extracted from
it automatically.</p>
</td></tr>
<tr><td><code id="marginalOptim_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="marginalOptim_+3A_start">start</code></td>
<td>
<p>Starting parameter values. If not specified, they will be
obtained from <code><a href="#topic+initialMarginal">initialMarginal</a></code>.</p>
</td></tr>
<tr><td><code id="marginalOptim_+3A_model">model</code></td>
<td>
<p>List with model parameters. Typically, this is an output from
<code><a href="#topic+constructFormula">constructFormula</a></code>.</p>
</td></tr>
<tr><td><code id="marginalOptim_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="stats.html#topic+optim">optim</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance-covariance matrix which is returned by <code><a href="stats.html#topic+optim">optim</a></code>
is based on the fact that minimization of sum-of-squared residuals leads
essentially to a maximum likelihood estimator and so variance-covariance
matrix can be estimated using inverse Hessian evaluated at the optimal
parameters. In some cases, so obtained variance-covariance matrix might not
be positive-definite which probably means that estimates are unstable
because of either a poor choice of initial values or poor properties of the
data itself.
</p>

<hr>
<h2 id='maxR'>Compute maxR statistic for each off-axis dose combination</h2><span id='topic+maxR'></span>

<h3>Description</h3>

<p><code><a href="#topic+maxR">maxR</a></code> computes maxR statistics for each off-axis dose
combination given the data provided. It provides a summary with results
indicating whether a given point is estimated to be synergetic or
antagonistic. These can be based either on normal approximation or a
fully bootstrapped distribution of the statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxR(
  data_off,
  fitResult,
  transforms = fitResult$transforms,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  R,
  CP,
  reps,
  nested_bootstrap = FALSE,
  B.B = NULL,
  cutoff = 0.95,
  cl = NULL,
  B.CP = NULL,
  method = c("equal", "model", "unequal"),
  bootStraps,
  idUnique,
  n1,
  doseGridOff,
  transFun,
  invTransFun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxR_+3A_data_off">data_off</code></td>
<td>
<p>data frame with off -axis information</p>
</td></tr>
<tr><td><code id="maxR_+3A_fitresult">fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code><a href="#topic+fitMarginals">fitMarginals</a></code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td></tr>
<tr><td><code id="maxR_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="maxR_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="maxR_+3A_r">R</code></td>
<td>
<p>Numeric vector containing mean deviation of predicted response
surface from the observed one at each of the off-axis points. If missing,
it will be calculated automatically from output of
<code><a href="#topic+predictOffAxis">predictOffAxis</a></code> function.</p>
</td></tr>
<tr><td><code id="maxR_+3A_cp">CP</code></td>
<td>
<p>Prediction covariance matrix. If not specified, it will be estimated
by bootstrap using <code>B.CP</code> iterations.</p>
</td></tr>
<tr><td><code id="maxR_+3A_reps">reps</code></td>
<td>
<p>Numeric vector containing number of replicates for each off-axis
dose combination. If missing, it will be calculated automatically from output
of <code><a href="#topic+predictOffAxis">predictOffAxis</a></code> function.</p>
</td></tr>
<tr><td><code id="maxR_+3A_nested_bootstrap">nested_bootstrap</code></td>
<td>
<p>When statistics are calculated, if
<code>nested_bootstrap = TRUE</code>, <code>CP</code> matrix is recalculated at each
bootstrap iteration of <code>B.B</code> using <code>B.CP</code> iterations. Using such
nested bootstrap may however significantly increase computational time. If
<code>nested_bootstrap = FALSE</code>, <code>CP</code> bootstrapped data reuses
<code>CP</code> matrix calculated from the original data.</p>
</td></tr>
<tr><td><code id="maxR_+3A_b.b">B.B</code></td>
<td>
<p>Number of iterations to use in bootstrapping null distribution for
either meanR or maxR statistics.</p>
</td></tr>
<tr><td><code id="maxR_+3A_cutoff">cutoff</code></td>
<td>
<p>Cut-off to use in maxR procedure for declaring non-additivity
(default is 0.95).</p>
</td></tr>
<tr><td><code id="maxR_+3A_cl">cl</code></td>
<td>
<p>If parallel computations are desired, <code>cl</code> should be a cluster
object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. If parallel
computing is active, progress reporting messages are not necessarily
ordered as it should be expected.</p>
</td></tr>
<tr><td><code id="maxR_+3A_b.cp">B.CP</code></td>
<td>
<p>Number of bootstrap iterations to use for CP matrix estimation</p>
</td></tr>
<tr><td><code id="maxR_+3A_method">method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td></tr>
<tr><td><code id="maxR_+3A_bootstraps">bootStraps</code></td>
<td>
<p>precomputed bootstrap objects</p>
</td></tr>
<tr><td><code id="maxR_+3A_idunique">idUnique</code></td>
<td>
<p>unique combinations of on-axis points, a character vector</p>
</td></tr>
<tr><td><code id="maxR_+3A_n1">n1</code></td>
<td>
<p>the number of off-axis points</p>
</td></tr>
<tr><td><code id="maxR_+3A_dosegridoff">doseGridOff</code></td>
<td>
<p>dose grid for off-axis points</p>
</td></tr>
<tr><td><code id="maxR_+3A_transfun">transFun</code>, <code id="maxR_+3A_invtransfun">invTransFun</code></td>
<td>
<p>the transformation and inverse transformation functions for the variance</p>
</td></tr>
<tr><td><code id="maxR_+3A_...">...</code></td>
<td>
<p>Further arguments that will be later passed to
<code><a href="#topic+generateData">generateData</a></code> function during bootstrapping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a <code>maxR</code> object with estimates for the
maxR statistical test. <code>maxR</code> object is essentially a list with
appropriately named elements.
</p>
<p>In particular, <code>maxR</code> object contains <code>"Ymean"</code> element which is
a summary table of maxR test results for each dose combination. This table
contains mean deviation from the predicted surface, normalized deviation
(<code>"absR"</code>) as well as a statistical call whether this deviation is
significant. Distributional information on which these calls are made can
be retrieved from the attributes of the <code>"Ymean"</code> dataframe.
</p>
<p>Also, <code>maxR</code> object contains <code>"Call"</code> element which indicates the
general direction of the deviation of the observed surface from the null.
This call is based on the strongest local deviation in the <code>"Ymean"</code>
table. 4 values are available here: <code>"Syn"</code>, <code>"Ant"</code>,
<code>"None"</code>, <code>"Undefined"</code>. If one compound acts as an agonist while
another one is an antagonist, then a deviation from the null is classified
as <code>"Undefined"</code>. If both compounds act in the same direction, then a
stronger than individual effect is classified as synergy while a weaker
effect would be classified as antagonism.
</p>

<hr>
<h2 id='meanR'>Compute meanR statistic for the estimated model</h2><span id='topic+meanR'></span>

<h3>Description</h3>

<p><code><a href="#topic+meanR">meanR</a></code> computes the meanR statistic for the provided model
and returns the computed F-statistic and the estimated p-value. p-value
can be calculated either by assuming an exact distribution or using
bootstrapping procedure. In the latter case, null distribution of
bootstrapped F-statistics is also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanR(
  data_off,
  fitResult,
  transforms = fitResult$transforms,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  R,
  CP,
  reps,
  nested_bootstrap = FALSE,
  B.B = NULL,
  B.CP = NULL,
  cl = NULL,
  method = c("equal", "model", "unequal"),
  bootStraps,
  paramsBootstrap,
  idUnique,
  n1,
  transFun,
  invTransFun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanR_+3A_data_off">data_off</code></td>
<td>
<p>data frame with off -axis information</p>
</td></tr>
<tr><td><code id="meanR_+3A_fitresult">fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code><a href="#topic+fitMarginals">fitMarginals</a></code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td></tr>
<tr><td><code id="meanR_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="meanR_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="meanR_+3A_r">R</code></td>
<td>
<p>Numeric vector containing mean deviation of predicted response
surface from the observed one at each of the off-axis points. If missing,
it will be calculated automatically from output of
<code><a href="#topic+predictOffAxis">predictOffAxis</a></code> function.</p>
</td></tr>
<tr><td><code id="meanR_+3A_cp">CP</code></td>
<td>
<p>Matrix which is part of covariance matrix for the <code>R</code> argument</p>
</td></tr>
<tr><td><code id="meanR_+3A_reps">reps</code></td>
<td>
<p>Numeric vector containing number of replicates for each off-axis
dose combination. If missing, it will be calculated automatically from output
of <code><a href="#topic+predictOffAxis">predictOffAxis</a></code> function.</p>
</td></tr>
<tr><td><code id="meanR_+3A_nested_bootstrap">nested_bootstrap</code></td>
<td>
<p>When statistics are calculated, if
<code>nested_bootstrap = TRUE</code>, <code>CP</code> matrix is recalculated at each
bootstrap iteration of <code>B.B</code> using <code>B.CP</code> iterations. Using such
nested bootstrap may however significantly increase computational time. If
<code>nested_bootstrap = FALSE</code>, <code>CP</code> bootstrapped data reuses
<code>CP</code> matrix calculated from the original data.</p>
</td></tr>
<tr><td><code id="meanR_+3A_b.b">B.B</code></td>
<td>
<p>Number of iterations to use in bootstrapping null distribution for
either meanR or maxR statistics.</p>
</td></tr>
<tr><td><code id="meanR_+3A_b.cp">B.CP</code></td>
<td>
<p>Number of bootstrap iterations to use for CP matrix estimation</p>
</td></tr>
<tr><td><code id="meanR_+3A_cl">cl</code></td>
<td>
<p>If parallel computations are desired, <code>cl</code> should be a cluster
object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. If parallel
computing is active, progress reporting messages are not necessarily
ordered as it should be expected.</p>
</td></tr>
<tr><td><code id="meanR_+3A_method">method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td></tr>
<tr><td><code id="meanR_+3A_bootstraps">bootStraps</code></td>
<td>
<p>precomputed bootstrap objects</p>
</td></tr>
<tr><td><code id="meanR_+3A_paramsbootstrap">paramsBootstrap</code></td>
<td>
<p>parameters for the nested bootstrap</p>
</td></tr>
<tr><td><code id="meanR_+3A_idunique">idUnique</code></td>
<td>
<p>unique combinations of on-axis points, a character vector</p>
</td></tr>
<tr><td><code id="meanR_+3A_n1">n1</code></td>
<td>
<p>the number of off-axis points</p>
</td></tr>
<tr><td><code id="meanR_+3A_transfun">transFun</code>, <code id="meanR_+3A_invtransfun">invTransFun</code></td>
<td>
<p>the transformation and inverse transformation functions for the variance</p>
</td></tr>
<tr><td><code id="meanR_+3A_...">...</code></td>
<td>
<p>Further arguments that will be later passed to
<code><a href="#topic+generateData">generateData</a></code> function during bootstrapping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a <code>meanR</code> object with estimates for the
meanR statistical test. <code>meanR</code> object is essentially a list with
appropriately named elements.
</p>
<p><code>meanR</code> object list includes notably the calculated F-statistic,
p-value and degrees of freedom (<code>"n1"</code> and <code>"df0"</code> respectively)
used to find the critical value of the F-distribution under the null.
</p>
<p>If <code><a href="#topic+meanR">meanR</a></code> test is run with bootstrapping, then p-value
estimate is based on bootstrapped null distribution of test statistic and an
additional element <code>"FDist"</code> (of class <code>"ecdf"</code>) is returned.
</p>

<hr>
<h2 id='modelVar'>Calculate model variance, assuming variance increases linearly with mean</h2><span id='topic+modelVar'></span>

<h3>Description</h3>

<p>Calculate model variance, assuming variance increases linearly with mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelVar(dat_off, transFun, invTransFun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelVar_+3A_dat_off">dat_off</code></td>
<td>
<p>off-axis points data</p>
</td></tr>
<tr><td><code id="modelVar_+3A_transfun">transFun</code>, <code id="modelVar_+3A_invtransfun">invTransFun</code></td>
<td>
<p>the transformation and inverse transformation functions for the variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the predicted model variance
</p>

<hr>
<h2 id='optim.boxcox'>Find optimal Box-Cox transformation parameters</h2><span id='topic+optim.boxcox'></span>

<h3>Description</h3>

<p>Find optimal Box-Cox transformation parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.boxcox(value, fac, shift = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.boxcox_+3A_value">value</code></td>
<td>
<p>Response variable in the data, e.g. <code>"effect"</code> column</p>
</td></tr>
<tr><td><code id="optim.boxcox_+3A_fac">fac</code></td>
<td>
<p>Factor indicating groups of replicates, e.g.
<code>interaction(d1,d2)</code></p>
</td></tr>
<tr><td><code id="optim.boxcox_+3A_shift">shift</code></td>
<td>
<p>Whether to use 2-parameter Box-Cox transformation. Input may be
<code>TRUE/FALSE</code> or a numeric value indicating the shift parameter to use.
If <code>FALSE</code>, shift parameter is set to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with power and shift parameter in that order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data &lt;- subset(directAntivirals, experiment == 1)
  optim.boxcox(data$effect, interaction(data$d1, data$d2))
</code></pre>

<hr>
<h2 id='outsidePoints'>List non-additive points</h2><span id='topic+outsidePoints'></span>

<h3>Description</h3>

<p>List all points with corresponding p-values declared non-additive by the
maxR statistical test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outsidePoints(maxR, B = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outsidePoints_+3A_maxr">maxR</code></td>
<td>
<p>maxR statistics table returned by <code>Ymean</code> component from the
output of <code><a href="#topic+maxR">maxR</a></code> function. This can also be <code>"maxR"</code>
element in the output of <code><a href="#topic+fitSurface">fitSurface</a></code> function.</p>
</td></tr>
<tr><td><code id="outsidePoints_+3A_b">B</code></td>
<td>
<p>Iterations to use for the distribution of the maxR statistic. This
is only used if <code>Ymean</code> dataframe does not have a <code>"distr"</code> attribute
attached as is normally done when using <code><a href="#topic+fitSurface">fitSurface</a></code> or <code><a href="#topic+maxR">maxR</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe listing only dose combinations that exhibit
significant deviations from the expected response surface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data &lt;- subset(directAntivirals, experiment == 2)
  ## Data must contain d1, d2 and effect columns
  fitResult &lt;- fitMarginals(data)
  surf &lt;- fitSurface(data, fitResult, statistic = "maxR")
  outsidePoints(surf$maxR$Ymean)

</code></pre>

<hr>
<h2 id='plot.BIGLconfInt'>Plot confidence intervals in a contour plot</h2><span id='topic+plot.BIGLconfInt'></span>

<h3>Description</h3>

<p>Plot confidence intervals in a contour plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BIGLconfInt'
plot(
  x,
  color = "effect-size",
  showAll = TRUE,
  digits = 3,
  xlab,
  ylab,
  greyScale = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BIGLconfInt_+3A_x">x</code></td>
<td>
<p>off axis confidence intervals, a data frame</p>
</td></tr>
<tr><td><code id="plot.BIGLconfInt_+3A_color">color</code></td>
<td>
<p>analysis with which to colour cells, either <code>effect-size</code> or <code>maxR</code></p>
</td></tr>
<tr><td><code id="plot.BIGLconfInt_+3A_showall">showAll</code></td>
<td>
<p>show all intervals in the plot or only significant ones, logical defaulting to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.BIGLconfInt_+3A_digits">digits</code></td>
<td>
<p>Numeric value indicating the number of digits used for numeric values</p>
</td></tr>
<tr><td><code id="plot.BIGLconfInt_+3A_xlab">xlab</code></td>
<td>
<p>String for the x axis label</p>
</td></tr>
<tr><td><code id="plot.BIGLconfInt_+3A_ylab">ylab</code></td>
<td>
<p>String for the y axis label</p>
</td></tr>
<tr><td><code id="plot.BIGLconfInt_+3A_greyscale">greyScale</code></td>
<td>
<p>If <code>greyScale = TRUE</code>, then plot is in grey scale,
otherwise in colour.</p>
</td></tr>
<tr><td><code id="plot.BIGLconfInt_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p>written after the contour() function in the <code>drugCombo</code> package
</p>

<hr>
<h2 id='plot.effect-size'>Plot of effect-size object</h2><span id='topic+plot.effect-size'></span>

<h3>Description</h3>

<p>Plot of effect-size object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''effect-size''
plot(
  x,
  main = "Contour plot for effect size",
  xlab = "Dose (Compound 1)",
  ylab = "Dose (Compound 2)",
  colorPalette,
  logScale = TRUE,
  zTransform = function(z) {
     z
 },
  digits,
  digitsFunc,
  reverse.x = FALSE,
  reverse.y = FALSE,
  swapAxes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.effect-size_+3A_x">x</code></td>
<td>
<p>Object of class <code>effect-size</code>.</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_main">main</code></td>
<td>
<p>The main title (on top) using font, size (character
expansion) and color <code>par(c("font.main", "cex.main", "col.main"))</code>.</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_xlab">xlab</code></td>
<td>
<p>X axis label using font, size and color 
<code>par(c("font.lab", "cex.lab", "col.lab"))</code>.</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label, same font attributes as <code>xlab</code>.</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_colorpalette">colorPalette</code></td>
<td>
<p>Vector of color values</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_logscale">logScale</code></td>
<td>
<p>logScale</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_ztransform">zTransform</code></td>
<td>
<p>zTransform</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_digits">digits</code></td>
<td>
<p>Numeric value indicating the number of digits used for numeric values. Whether <code>digitsFunc</code> is provided, this will be ignored.</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_digitsfunc">digitsFunc</code></td>
<td>
<p>Function to be applied to numeric values like doses. This expects a single parameter.</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_reverse.x">reverse.x</code></td>
<td>
<p>Reverse x axis?</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_reverse.y">reverse.y</code></td>
<td>
<p>Reverse y axis?</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_swapaxes">swapAxes</code></td>
<td>
<p>Swap x and y axes?</p>
</td></tr>
<tr><td><code id="plot.effect-size_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to <code><a href="base.html#topic+format">format</a></code> function
for formatting of axis labels</p>
</td></tr>
</table>

<hr>
<h2 id='plot.MarginalFit'>Plot monotherapy curve estimates</h2><span id='topic+plot.MarginalFit'></span>

<h3>Description</h3>

<p>Plot monotherapy curve estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
plot(x, ncol = 2, logScale = TRUE, smooth = TRUE, dataScale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MarginalFit_+3A_x">x</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function or a
<code>"MarginalFit"</code> object</p>
</td></tr>
<tr><td><code id="plot.MarginalFit_+3A_ncol">ncol</code></td>
<td>
<p>Number of plots per row</p>
</td></tr>
<tr><td><code id="plot.MarginalFit_+3A_logscale">logScale</code></td>
<td>
<p>Whether x-axis should be plotted on a logarithmic scale</p>
</td></tr>
<tr><td><code id="plot.MarginalFit_+3A_smooth">smooth</code></td>
<td>
<p>Whether to draw a smooth fitted curve (deafult), or 
line segments connecting predicted points only</p>
</td></tr>
<tr><td><code id="plot.MarginalFit_+3A_datascale">dataScale</code></td>
<td>
<p>Whether to draw plot on original data scale in case when 
transformations were used for fitting. Default (FALSE) is to plot on the 
<code>coef(x)</code> scale</p>
</td></tr>
<tr><td><code id="plot.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>ggplot</code> object. It can be consequently modified by
using standard operations on <code>ggplot</code> objects (if <code>ggplot2</code>
package is loaded).
</p>

<hr>
<h2 id='plot.maxR'>Plot of maxR object</h2><span id='topic+plot.maxR'></span>

<h3>Description</h3>

<p>Plot of maxR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxR'
plot(
  x,
  main = "Contour plot for maxR",
  xlab = "Dose (Compound 1)",
  ylab = "Dose (Compound 2)",
  colorPalette = c("blue", "white", "red"),
  logScale = TRUE,
  zTransform = function(z) {
     z
 },
  plevels = c(0.7, 0.8, 0.9, 0.95, 0.99, 0.999),
  cutoff = max(plevels),
  maxshow = NULL,
  reverse.x = FALSE,
  reverse.y = FALSE,
  swapAxes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.maxR_+3A_x">x</code></td>
<td>
<p>Output of <code><a href="#topic+maxR">maxR</a></code>. This can also be <code>"maxR"</code>
element in the output of <code><a href="#topic+fitSurface">fitSurface</a></code>.</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_main">main</code></td>
<td>
<p>Fixed non-moving title for the 3D plot</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_xlab">xlab</code></td>
<td>
<p>X axis label using font, size and color 
<code>par(c("font.lab", "cex.lab", "col.lab"))</code>.</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label, same font attributes as <code>xlab</code>.</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_colorpalette">colorPalette</code></td>
<td>
<p>Vector of color names for surface</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_logscale">logScale</code></td>
<td>
<p>Draw doses on log-scale (setting zeroes to be finite constant)</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_ztransform">zTransform</code></td>
<td>
<p>Optional transformation function for z-axis. By default,
identity function is used.</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_plevels">plevels</code></td>
<td>
<p>Probability levels used to generate a color scale</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_cutoff">cutoff</code></td>
<td>
<p>Probability cutoff to use for range of colors</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_maxshow">maxshow</code></td>
<td>
<p>Forced value for range of colors</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_reverse.x">reverse.x</code></td>
<td>
<p>Reverse x axis?</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_reverse.y">reverse.y</code></td>
<td>
<p>Reverse y axis?</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_swapaxes">swapAxes</code></td>
<td>
<p>Swap x and y axes?</p>
</td></tr>
<tr><td><code id="plot.maxR_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to <code><a href="base.html#topic+format">format</a></code> function
for formatting of axis labels</p>
</td></tr>
</table>

<hr>
<h2 id='plot.meanR'>Plot bootstrapped cumulative distribution function of meanR null distribution</h2><span id='topic+plot.meanR'></span>

<h3>Description</h3>

<p>Plot bootstrapped cumulative distribution function of meanR null distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'meanR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.meanR_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+meanR">meanR</a></code></p>
</td></tr>
<tr><td><code id="plot.meanR_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='plot.ResponseSurface'>Method for plotting response surface objects</h2><span id='topic+plot.ResponseSurface'></span>

<h3>Description</h3>

<p>Method for plotting response surface objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResponseSurface'
plot(
  x,
  color = c("z-score", "maxR", "occupancy", "effect-size"),
  greyScale = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ResponseSurface_+3A_x">x</code></td>
<td>
<p>Output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="plot.ResponseSurface_+3A_color">color</code></td>
<td>
<p>Character indicating on what values surface coloring will be
based.
</p>
<p>If <code>color = "z-score"</code>, surface coloring will be based on median of
standardized off-axis Z-scores. Median function can be replaced by other
function using an optional <code>colorfun</code> argument which will be passed to
<code>plotResponseSurface</code>. Color breaks are determined here by standard
deviation of off-axis Z-scores. For <code>color = "maxR"</code>, coloring will be
based on values of maxR statistic and the quantile of its distribution
(bootstrapped or not). If <code>color = "occupancy"</code>, coloring will be
based on calculated occupancy rate for the respective dose combination.
If <code>color = "effect-size"</code>, coloring will be
based on effect size for the respective dose combination.</p>
</td></tr>
<tr><td><code id="plot.ResponseSurface_+3A_greyscale">greyScale</code></td>
<td>
<p>If <code>greyScale = TRUE</code>, then plot is in grey scale,
otherwise in colour.</p>
</td></tr>
<tr><td><code id="plot.ResponseSurface_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="#topic+plotResponseSurface">plotResponseSurface</a></code>.
<code>colorBy</code> argument in this method is computed automatically and thus
cannot be passed to <code><a href="#topic+plotResponseSurface">plotResponseSurface</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plotConfInt'>Plot confidence intervals from BIGL object in a contour plot</h2><span id='topic+plotConfInt'></span>

<h3>Description</h3>

<p>Plot confidence intervals from BIGL object in a contour plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConfInt(BIGLobj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotConfInt_+3A_biglobj">BIGLobj</code></td>
<td>
<p>Output from <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="plotConfInt_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+plot.BIGLconfInt">plot.BIGLconfInt</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='plotMeanVarFit'>Make a mean-variance plot</h2><span id='topic+plotMeanVarFit'></span>

<h3>Description</h3>

<p>Make a mean-variance plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMeanVarFit(
  data,
  trans = "identity",
  invtrans = switch(trans, identity = "identity", log = "exp"),
  main = paste(switch(trans, identity = "No", log = "log"), "transformation"),
  log = switch(trans, identity = "", log = "y", ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMeanVarFit_+3A_data">data</code></td>
<td>
<p>a dataset or matrix with d1, d2 and effect column</p>
</td></tr>
<tr><td><code id="plotMeanVarFit_+3A_trans">trans</code>, <code id="plotMeanVarFit_+3A_invtrans">invtrans</code></td>
<td>
<p>the transformation function for the variance and its inverse, possibly as strings</p>
</td></tr>
<tr><td><code id="plotMeanVarFit_+3A_main">main</code></td>
<td>
<p>the title of the plot</p>
</td></tr>
<tr><td><code id="plotMeanVarFit_+3A_log">log</code></td>
<td>
<p>log-transform of the axes, as in plot()</p>
</td></tr>
<tr><td><code id="plotMeanVarFit_+3A_...">...</code></td>
<td>
<p>passed on to plot()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a crucial graphical check for deciding on the
</p>


<h3>Value</h3>

<p>Plots the mean-variance trend
</p>

<hr>
<h2 id='plotResponseSurface'>Plot response surface</h2><span id='topic+plotResponseSurface'></span>

<h3>Description</h3>

<p>Plot the 3-dimensional response surface predicted by one of the null
models. This plot allows for a visual comparison between the null
model prediction and observed points. This function is mainly used
as the workhorse of <code><a href="#topic+plot.ResponseSurface">plot.ResponseSurface</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotResponseSurface(
  data,
  fitResult = NULL,
  transforms = fitResult$transforms,
  predSurface = NULL,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  colorPalette = c("red", "grey70", "blue"),
  colorPaletteNA = "grey70",
  colorBy = "none",
  addPoints = TRUE,
  colorPoints = c("black", "sandybrown", "brown", "white"),
  breaks,
  radius = 4,
  logScale = TRUE,
  colorfun = median,
  zTransform = function(x) x,
  add = FALSE,
  main = "",
  legend = FALSE,
  xat = "actual",
  yat = "actual",
  plotfun = NULL,
  gradient = TRUE,
  width = 800,
  height = 800,
  title = "",
  digitsFunc = function(x) {
     x
 },
  reverse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotResponseSurface_+3A_data">data</code></td>
<td>
<p>Object &quot;data&quot; from the output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_fitresult">fitResult</code></td>
<td>
<p>Object &quot;fitResult&quot; from the output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_transforms">transforms</code></td>
<td>
<p>Object &quot;transforms&quot; from the output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_predsurface">predSurface</code></td>
<td>
<p>Vector of all predicted responses based on
<code>expand.grid(uniqueDoses)</code>. If not supplied, it will be computed
with <code><a href="#topic+predictOffAxis">predictOffAxis</a></code> function.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_null_model">null_model</code></td>
<td>
<p>If <code>predSurface</code> is not supplied, it is computed using
one of the available null models, i.e. <code>"loewe"</code>, <code>"hsa"</code>, 
<code>"bliss"</code> and <code>"loewe2"</code>. See also <code><a href="#topic+fitSurface">fitSurface</a></code>.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_colorpalette">colorPalette</code></td>
<td>
<p>Vector of color names for surface</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_colorpalettena">colorPaletteNA</code></td>
<td>
<p>Color used in the matrix of colours when the combination of doses doesn't exist (NA)</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_colorby">colorBy</code></td>
<td>
<p>This parameter determines values on which coloring is based
for the 3-dimensional surface. If matrix or a data frame with <code>d1</code> and
<code>d2</code> columns is supplied, dose combinations from <code>colorBy</code> will be
matched automatically to the appropriate dose combinations in <code>data</code>.
Unmatched dose combinations will be set to 0. This is especially useful for
plotting results for off-axis estimates only, e.g. off-axis Z-scores or
maxR test statistics. If <code>colorBy = "colors"</code>, surface will be colored
using colors in <code>colorPalette</code> argument.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_addpoints">addPoints</code></td>
<td>
<p>Boolean whether the dose points should be included</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_colorpoints">colorPoints</code></td>
<td>
<p>Colors for off-axis and on-axis points. Character vector
of length four with colors for 1) off-axis points; 2) on-axis points of the
first drug (i.e. second drug is dosed at zero); 3) on-axis points of the
second drug; 4) on-axis points where both drugs are dosed at zero.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_breaks">breaks</code></td>
<td>
<p>Numeric vector with numerical breaks. To be used in conjunction
with <code>colorPalette</code> argument. If named, the labels will be displayed in the legend</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_radius">radius</code></td>
<td>
<p>Size of spheres (default is 4)</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_logscale">logScale</code></td>
<td>
<p>Draw doses on log-scale (setting zeroes to be finite constant)</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_colorfun">colorfun</code></td>
<td>
<p>If replicates in <code>colorBy</code> variable are present, these
will be aggregated using <code>colorfun</code> function. This can also be a
custom function returning a scalar.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_ztransform">zTransform</code></td>
<td>
<p>Optional transformation function for z-axis. By default,
identity function is used.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_add">add</code></td>
<td>
<p>(deprecated) Add the predicted response surface to an existing plot. Will not
draw any points, just the surface. Must be called after another call to
<code><a href="#topic+plotResponseSurface">plotResponseSurface</a></code>.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_main">main</code></td>
<td>
<p>Fixed non-moving title for the 3D plot</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_legend">legend</code></td>
<td>
<p>Whether legend should be added (default FALSE)</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_xat">xat</code></td>
<td>
<p>x-axis ticks: &quot;pretty&quot;, &quot;actual&quot; or a numeric vector</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_yat">yat</code></td>
<td>
<p>y-axis ticks: &quot;pretty&quot;, &quot;actual&quot; or a numeric vector</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_plotfun">plotfun</code></td>
<td>
<p>If replicates for dose combinations in <code>data</code> are
available, points can be aggregated using <code>plotfun</code> function.
Typically, it will be <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+median">median</a></code>,
<code><a href="base.html#topic+min">min</a></code> or <code><a href="base.html#topic+max">max</a></code> but a custom-defined function
returning a scalar from a vector is also possible.</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_gradient">gradient</code></td>
<td>
<p>Boolean indicating whether colours should be interpolated between breaks (default TRUE). 
If FALSE, <code>colorPalette</code> must contain length(breaks)-1 colours</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_width">width</code></td>
<td>
<p>Width in pixels (optional, defaults to 800px).</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_height">height</code></td>
<td>
<p>Height in pixels (optional, defaults to 800px).</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_title">title</code></td>
<td>
<p>String title (default &quot;&quot;)</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_digitsfunc">digitsFunc</code></td>
<td>
<p>Function to be applied to the axis values</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_reverse">reverse</code></td>
<td>
<p>Boolean indicating whether colours should be reversed (default FALSE).</p>
</td></tr>
<tr><td><code id="plotResponseSurface_+3A_...">...</code></td>
<td>
<p>Further arguments to format axis labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plotly plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data &lt;- subset(directAntivirals, experiment == 1)
  ## Data must contain d1, d2 and effect columns
  fitResult &lt;- fitMarginals(data)
  data_mean &lt;- aggregate(effect ~ d1 + d2, data = data[, c("d1", "d2", "effect")],
                         FUN = mean)

  ## Construct the surface from marginal fit estimates based on HSA
  ## model and color it by mean effect level
  plotResponseSurface(data, fitResult, null_model = "hsa",
                      colorBy = data_mean, breaks = 10^(c(0, 3, 4, 6)),
                      colorPalette = c("grey", "blue", "green"))

  ## Response surface based on Loewe additivity model and colored with
  ## rainbow colors.
  plotResponseSurface(data, fitResult, null_model = "loewe", breaks = c(-Inf, 0, Inf),
                      colorBy = "colors", colorPalette = rainbow(6))

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.MarginalFit'>Predict values on the dose-response curve</h2><span id='topic+predict.MarginalFit'></span>

<h3>Description</h3>

<p>Predict values on the dose-response curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MarginalFit_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function</p>
</td></tr>
<tr><td><code id="predict.MarginalFit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for <code>d1</code> and
<code>d2</code> variables with which to predict. If omitted, the fitted values
are used. Doses that are passed to this function must correspond to
marginal data, i.e. at least one of the doses must be zero.</p>
</td></tr>
<tr><td><code id="predict.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='predictOffAxis'>Compute off-axis predictions</h2><span id='topic+predictOffAxis'></span>

<h3>Description</h3>

<p>Given a dataframe with dose-response data, this function uses coefficient
estimates from the marginal (on-axis) monotherapy model to compute the
expected values of response at off-axis dose combinations using a provided
null model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictOffAxis(
  doseGrid,
  fitResult,
  transforms = fitResult$transforms,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  fit = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictOffAxis_+3A_dosegrid">doseGrid</code></td>
<td>
<p>A dose grid with unique combination of doses</p>
</td></tr>
<tr><td><code id="predictOffAxis_+3A_fitresult">fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code><a href="#topic+fitMarginals">fitMarginals</a></code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td></tr>
<tr><td><code id="predictOffAxis_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="predictOffAxis_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="predictOffAxis_+3A_fit">fit</code></td>
<td>
<p>a pre-calculated off-axis fit</p>
</td></tr>
<tr><td><code id="predictOffAxis_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the Loewe fitters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions returns a named vector with predicted off-axis points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data &lt;- subset(directAntivirals, experiment == 1)
  ## Data must contain d1, d2 and effect columns
  transforms &lt;- getTransformations(data)
  fitResult &lt;- fitMarginals(data, transforms)
    uniqueDoses &lt;- with(data, list("d1" = sort(unique(data$d1)),
    "d2" = sort(unique(data$d2))))
    doseGrid &lt;- expand.grid(uniqueDoses)
  predictOffAxis(fitResult, null_model = "hsa", doseGrid = doseGrid)
</code></pre>

<hr>
<h2 id='predictResponseSurface'>Predict the entire response surface, so including on-axis points, and return
the result as a matrix. For plotting purposes.</h2><span id='topic+predictResponseSurface'></span>

<h3>Description</h3>

<p>Predict the entire response surface, so including on-axis points, and return
the result as a matrix. For plotting purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictResponseSurface(
  doseGrid,
  fitResult,
  null_model,
  transforms = fitResult$transforms
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictResponseSurface_+3A_dosegrid">doseGrid</code></td>
<td>
<p>A dose grid with unique combination of doses</p>
</td></tr>
<tr><td><code id="predictResponseSurface_+3A_fitresult">fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code><a href="#topic+fitMarginals">fitMarginals</a></code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td></tr>
<tr><td><code id="predictResponseSurface_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="predictResponseSurface_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
</table>

<hr>
<h2 id='predictVar'>Predict variance</h2><span id='topic+predictVar'></span>

<h3>Description</h3>

<p>Predict variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictVar(means, model, invTransFun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictVar_+3A_means">means</code></td>
<td>
<p>a vector of means</p>
</td></tr>
<tr><td><code id="predictVar_+3A_model">model</code></td>
<td>
<p>The mean-variance model</p>
</td></tr>
<tr><td><code id="predictVar_+3A_invtransfun">invTransFun</code></td>
<td>
<p>the inverse transformation function, back to the variance domain</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.BIGLconfInt'>Print summary of BIGLconfInt object</h2><span id='topic+print.summary.BIGLconfInt'></span>

<h3>Description</h3>

<p>Print summary of BIGLconfInt object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.BIGLconfInt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.BIGLconfInt_+3A_x">x</code></td>
<td>
<p>Summary of BIGLconfInt object</p>
</td></tr>
<tr><td><code id="print.summary.BIGLconfInt_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.MarginalFit'>Print method for summary of <code>MarginalFit</code> object</h2><span id='topic+print.summary.MarginalFit'></span>

<h3>Description</h3>

<p>Print method for summary of <code>MarginalFit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.MarginalFit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.MarginalFit_+3A_x">x</code></td>
<td>
<p>Summary of <code>MarginalFit</code> object</p>
</td></tr>
<tr><td><code id="print.summary.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.maxR'>Print summary of maxR object</h2><span id='topic+print.summary.maxR'></span>

<h3>Description</h3>

<p>Print summary of maxR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.maxR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.maxR_+3A_x">x</code></td>
<td>
<p>Summary of <code>"maxR"</code> object</p>
</td></tr>
<tr><td><code id="print.summary.maxR_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.meanR'>Print summary of meanR object</h2><span id='topic+print.summary.meanR'></span>

<h3>Description</h3>

<p>Print summary of meanR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.meanR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.meanR_+3A_x">x</code></td>
<td>
<p>Summary of meanR object</p>
</td></tr>
<tr><td><code id="print.summary.meanR_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.ResponseSurface'>Print method for the summary function of <code>ResponseSurface</code> object</h2><span id='topic+print.summary.ResponseSurface'></span>

<h3>Description</h3>

<p>Print method for the summary function of <code>ResponseSurface</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ResponseSurface'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ResponseSurface_+3A_x">x</code></td>
<td>
<p>Summary of <code>ResponseSurface</code> object</p>
</td></tr>
<tr><td><code id="print.summary.ResponseSurface_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>

<hr>
<h2 id='residuals.MarginalFit'>Residuals from marginal model estimation</h2><span id='topic+residuals.MarginalFit'></span>

<h3>Description</h3>

<p>Residuals from marginal model estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.MarginalFit_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function</p>
</td></tr>
<tr><td><code id="residuals.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='runBIGL'>Run the BIGL application for demonstrating response surfaces</h2><span id='topic+runBIGL'></span>

<h3>Description</h3>

<p>Run the BIGL application for demonstrating response surfaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBIGL(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBIGL_+3A_...">...</code></td>
<td>
<p>Pass parameters to <code><a href="shiny.html#topic+runApp">runApp</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  runBIGL()

## End(Not run)
</code></pre>

<hr>
<h2 id='sampleResids'>Sample residuals according to a new model</h2><span id='topic+sampleResids'></span>

<h3>Description</h3>

<p>Sample residuals according to a new model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleResids(means, sampling_errors, method, rescaleResids, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleResids_+3A_means">means</code></td>
<td>
<p>a vector of means</p>
</td></tr>
<tr><td><code id="sampleResids_+3A_sampling_errors">sampling_errors</code></td>
<td>
<p>Sampling vector to resample errors from. Used only if
<code>error</code> is 4 and is passed as argument to <code><a href="#topic+generateData">generateData</a></code>.
If <code>sampling_errors = NULL</code> (default), mean residuals at off-axis
points between observed and predicted response are taken.</p>
</td></tr>
<tr><td><code id="sampleResids_+3A_method">method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td></tr>
<tr><td><code id="sampleResids_+3A_rescaleresids">rescaleResids</code></td>
<td>
<p>a boolean indicating whether to rescale residuals,
or else normality of the residuals is assumed.</p>
</td></tr>
<tr><td><code id="sampleResids_+3A_...">...</code></td>
<td>
<p>passed on to predictVar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sampled residuals
</p>

<hr>
<h2 id='scaleResids'>Functions for scaling, and rescaling residuals. May lead to unstable behaviour in practice</h2><span id='topic+scaleResids'></span>

<h3>Description</h3>

<p>Functions for scaling, and rescaling residuals. May lead to unstable behaviour in practice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleResids(sampling_errors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleResids_+3A_sampling_errors">sampling_errors</code></td>
<td>
<p>A vector of raw  residuals</p>
</td></tr>
<tr><td><code id="scaleResids_+3A_...">...</code></td>
<td>
<p>passed on to predictVar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are calculated with respect to the average observation on
the off-axis point, so replicates are required!
</p>

<hr>
<h2 id='simulateNull'>Simulate data from a given null model and monotherapy coefficients</h2><span id='topic+simulateNull'></span>

<h3>Description</h3>

<p>Simulate data from a given null model and monotherapy coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateNull(
  data,
  fitResult,
  doseGrid,
  transforms = fitResult$transforms,
  startvalues,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateNull_+3A_data">data</code></td>
<td>
<p>Dose-response dataframe.</p>
</td></tr>
<tr><td><code id="simulateNull_+3A_fitresult">fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code><a href="#topic+fitMarginals">fitMarginals</a></code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code><a href="#topic+fitMarginals">fitMarginals</a></code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td></tr>
<tr><td><code id="simulateNull_+3A_dosegrid">doseGrid</code></td>
<td>
<p>A grid of dose combinations</p>
</td></tr>
<tr><td><code id="simulateNull_+3A_transforms">transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td></tr>
<tr><td><code id="simulateNull_+3A_startvalues">startvalues</code></td>
<td>
<p>Starting values for the non-linear equation,
from the observed data</p>
</td></tr>
<tr><td><code id="simulateNull_+3A_null_model">null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td></tr>
<tr><td><code id="simulateNull_+3A_...">...</code></td>
<td>
<p>Further parameters that will be passed to
<code><a href="#topic+generateData">generateData</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with <code>data</code> element containing simulated data and
<code>fitResult</code> element containing marginal fit on the simulated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data &lt;- subset(directAntivirals, experiment == 1)
  ## Data must contain d1, d2 and effect columns
  fitResult &lt;- fitMarginals(data)
  simDat &lt;- simulateNull(data, fitResult, expand.grid(d1 = data$d1, d2 = data$d2),
  null_model = "hsa")
</code></pre>

<hr>
<h2 id='summary.BIGLconfInt'>Summary of confidence intervals object</h2><span id='topic+summary.BIGLconfInt'></span>

<h3>Description</h3>

<p>Summary of confidence intervals object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BIGLconfInt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BIGLconfInt_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+bootConfInt">bootConfInt</a></code></p>
</td></tr>
<tr><td><code id="summary.BIGLconfInt_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='summary.MarginalFit'>Summary of <code>MarginalFit</code> object</h2><span id='topic+summary.MarginalFit'></span>

<h3>Description</h3>

<p>Summary of <code>MarginalFit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.MarginalFit_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function</p>
</td></tr>
<tr><td><code id="summary.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='summary.maxR'>Summary of maxR object</h2><span id='topic+summary.maxR'></span>

<h3>Description</h3>

<p>Summary of maxR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.maxR_+3A_object">object</code></td>
<td>
<p>Object of <code>"maxR"</code> class</p>
</td></tr>
<tr><td><code id="summary.maxR_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='summary.meanR'>Summary of meanR object</h2><span id='topic+summary.meanR'></span>

<h3>Description</h3>

<p>Summary of meanR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'meanR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.meanR_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+meanR">meanR</a></code></p>
</td></tr>
<tr><td><code id="summary.meanR_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='summary.ResponseSurface'>Summary of <code>ResponseSurface</code> object</h2><span id='topic+summary.ResponseSurface'></span>

<h3>Description</h3>

<p>Summary of <code>ResponseSurface</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResponseSurface'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ResponseSurface_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitSurface">fitSurface</a></code></p>
</td></tr>
<tr><td><code id="summary.ResponseSurface_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>

<hr>
<h2 id='synergy_plot_bycomp'>Plot 2D cross section of response surface</h2><span id='topic+synergy_plot_bycomp'></span>

<h3>Description</h3>

<p>Plot 2D cross section of response surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synergy_plot_bycomp(ls, xlab = NULL, ylab = NULL, color = FALSE, plotBy = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synergy_plot_bycomp_+3A_ls">ls</code></td>
<td>
<p>list of results objects obtained from <code><a href="#topic+fitSurface">fitSurface</a></code>. Names of list objects 
expected to be one of the null model options i.e. loewe, loewe2, hsa, bliss</p>
</td></tr>
<tr><td><code id="synergy_plot_bycomp_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis</p>
</td></tr>
<tr><td><code id="synergy_plot_bycomp_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis</p>
</td></tr>
<tr><td><code id="synergy_plot_bycomp_+3A_color">color</code></td>
<td>
<p>plot lines in colour? Defaults to FALSE</p>
</td></tr>
<tr><td><code id="synergy_plot_bycomp_+3A_plotby">plotBy</code></td>
<td>
<p>compound name to be used for order of plotting. If plotBy = &quot;Compound 1&quot; then plots are split by 
concentrations in Compound 1 and concentrations in Compound 2 are shown on the x-axis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mohammed Ibrahim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data &lt;- subset(directAntivirals, experiment == 1)
  transforms &lt;- list("PowerT" = function(x, args) with(args, log(x)),
                     "InvPowerT" = function(y, args) with(args, exp(y)),
                     "BiolT" = function(x, args) with(args, N0 * exp(x * time.hours)),
                     "InvBiolT" = function(y, args) with(args, 1/time.hours * log(y/N0)),
                     "compositeArgs" = list(N0 = 1, time.hours = 72))
  fitResult &lt;- fitMarginals(data, transforms)
  nullModels &lt;- c("loewe", "loewe2", "bliss", "hsa")
  rs_list &lt;- Map(fitSurface, null_model = nullModels, MoreArgs = list(
      data = data, fitResult = fitResult, B.CP = 50, statistic = "none"))
  synergy_plot_bycomp(ls = rs_list, plotBy = "Compound 1", color = TRUE)
  synergy_plot_bycomp(ls = rs_list, plotBy = "Compound 2", color = TRUE)

## End(Not run) 
</code></pre>

<hr>
<h2 id='vcov.MarginalFit'>Estimate of coefficient variance-covariance matrix</h2><span id='topic+vcov.MarginalFit'></span>

<h3>Description</h3>

<p>Estimate of coefficient variance-covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarginalFit'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.MarginalFit_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+fitMarginals">fitMarginals</a></code> function</p>
</td></tr>
<tr><td><code id="vcov.MarginalFit_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='wildbootAddResids'>Sample residuals according to a new model</h2><span id='topic+wildbootAddResids'></span>

<h3>Description</h3>

<p>Sample residuals according to a new model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wildbootAddResids(
  means,
  sampling_errors,
  method,
  rescaleResids,
  model,
  invTransFun,
  wild_bootstrap,
  wild_bootType,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wildbootAddResids_+3A_means">means</code></td>
<td>
<p>a vector of means</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_sampling_errors">sampling_errors</code></td>
<td>
<p>Sampling vector to resample errors from. Used only if
<code>error</code> is 4 and is passed as argument to <code><a href="#topic+generateData">generateData</a></code>.
If <code>sampling_errors = NULL</code> (default), mean residuals at off-axis
points between observed and predicted response are taken.</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_method">method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_rescaleresids">rescaleResids</code></td>
<td>
<p>a boolean indicating whether to rescale residuals,
or else normality of the residuals is assumed.</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_model">model</code></td>
<td>
<p>The mean-variance model</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_invtransfun">invTransFun</code></td>
<td>
<p>the inverse transformation function, back to the variance domain</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_wild_bootstrap">wild_bootstrap</code></td>
<td>
<p>Whether special bootstrap to correct for
heteroskedasticity should be used. If <code>wild_bootstrap = TRUE</code>, errors
are generated from <code>sampling_errors</code> multiplied by a random variable
following Rademacher distribution. Argument is used only if <code>error = 4</code>.</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_wild_boottype">wild_bootType</code></td>
<td>
<p>Type of distribution to be used for wild bootstrap. If <code>wild_bootstrap = TRUE</code>, 
errors are generated from &quot;rademacher&quot;, &quot;gamma&quot;, &quot;normal&quot; or &quot;two-point&quot; distribution.</p>
</td></tr>
<tr><td><code id="wildbootAddResids_+3A_...">...</code></td>
<td>
<p>passed on to predictVar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sampled residuals
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
