<!DOCTYPE html><html lang="en-US"><head><title>Help for package NMsim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NMsim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add'><p>Create function that adds text elements to vector</p></a></li>
<li><a href='#addClass'><p>Add class if not already present</p></a></li>
<li><a href='#addEVID2'><p>Add simulation records to dosing records</p></a></li>
<li><a href='#addResVar'><p>Add residual variability based on parameter estimates</p></a></li>
<li><a href='#callNonmemDirect'><p>Generate system command to call Nonmem directly</p></a></li>
<li><a href='#checkTimes'><p>Test if file modification times indicate that Nonmem models should</p>
be re-run</a></li>
<li><a href='#cleanStrings'><p>Drop spaces and odd characters. Use to ensure generated file names</p>
are usable.</a></li>
<li><a href='#completeCov'><p>Expand a set of covariate values into a data.set with reference</p>
value</a></li>
<li><a href='#count_ij'><p>Assign i and j indexes based on parameter section text</p></a></li>
<li><a href='#dtapply'><p>Apply function and return a data.table</p></a></li>
<li><a href='#expandCovs'><p>Create data set where each covariate is univariately varied</p></a></li>
<li><a href='#findUpdated'><p>Filter control streams to only those updated since last run</p></a></li>
<li><a href='#genPhiFile'><p>Generate a .phi file for further simulation with Nonmem</p></a></li>
<li><a href='#initsToExt'><p>Convert inits elements to a parameter data.frame</p></a></li>
<li><a href='#inputArchiveDefault'><p>Default location of input archive file</p></a></li>
<li><a href='#itriag'><p>Row numbers of elements in a triangular representation of a symmetric matrix</p></a></li>
<li><a href='#jtriag'><p>Column numbers of elements in a triangular representation of a symmetric matrix</p></a></li>
<li><a href='#modifyModel'><p>Internal method for handling modify.model argument to NMsim</p></a></li>
<li><a href='#NMcreateDoses'><p>Easily and flexibly generate dosing records</p></a></li>
<li><a href='#NMcreateMatLines'><p>Create text lines for OMEGA and SIGMA Nonmem sections</p></a></li>
<li><a href='#NMexec'><p>Execute Nonmem and archive input data with model files</p></a></li>
<li><a href='#NMexecDirectory'><p>Execute Nonmem inside a dedicated directory</p></a></li>
<li><a href='#NMgenPNM'><p>Generate PNM file for sge clusters</p></a></li>
<li><a href='#NMreadFilters'><p>Read data filters from a NONMEM model</p></a></li>
<li><a href='#NMreadInits'><p>Tabulate information from parameter sections in control streams</p></a></li>
<li><a href='#NMreadSim'><p>Read simulation results based on NMsim's track of model runs</p></a></li>
<li><a href='#NMreadSimModTab'><p>Read simulation results from rds objects and/or NMsimModTab objects</p></a></li>
<li><a href='#NMreadSimModTabOne'><p>Read simulation results from an rds or a NMsimModTab object</p></a></li>
<li><a href='#NMreadSimRes'><p>Read simulation results from data.frames or fst files</p></a></li>
<li><a href='#NMreadSimResOne'><p>read one sim element. This will be run in lapply in NMreadSim.</p></a></li>
<li><a href='#NMreadSizes'><p>Read SIZES info from a control stream</p></a></li>
<li><a href='#NMreplaceInits'><p>Replace initial values in Nonmem control stream</p></a></li>
<li><a href='#NMrunLin'><p>Internal function to run Nonmem on linux</p></a></li>
<li><a href='#NMseed'><p>Add seed string to simulation model data.table</p></a></li>
<li><a href='#NMsim'><p>Simulate from an estimated Nonmem model</p></a></li>
<li><a href='#NMsim_asis'><p>Simulation method that uses the provided control stream as is</p></a></li>
<li><a href='#NMsim_default'><p>Transform an estimated Nonmem model into a simulation control</p>
stream</a></li>
<li><a href='#NMsim_EBE'><p>Use emperical Bayes estimates to simulate re-using ETAs</p></a></li>
<li><a href='#NMsim_known'><p>NMsim_known is an old name for NMsim_EBE()</p></a></li>
<li><a href='#NMsim_NWPRI'><p>Simulate with parameter variability using the NONMEM NWPRI subroutine</p></a></li>
<li><a href='#NMsim_typical'><p>Typical subject simiulation method</p></a></li>
<li><a href='#NMsim_VarCov'><p>Simulate with parameter values sampled from a covariance step</p></a></li>
<li><a href='#NMsimCheckMod'><p>Check a simulation control streams for things that can cause trouble in NMsim</p></a></li>
<li><a href='#NMsimTestConf'><p>Summarize and test NMsim configuration</p></a></li>
<li><a href='#NMupdateInits'><p>Create new Nonmem control stream with updated initial parameter values</p></a></li>
<li><a href='#NMupdateSizes'><p>Create or update $SIZES in a control stream</p></a></li>
<li><a href='#NMwriteInits'><p>Writes a parameter values to a control stream</p></a></li>
<li><a href='#NWPRI_df'><p>Add degrees of freedom by OMEGA/SIGMA block</p></a></li>
<li><a href='#overwrite'><p>Create function that modifies text elements in a vector</p></a></li>
<li><a href='#padZeros'><p>pad zeros on integers</p></a></li>
<li><a href='#pasteFuns'><p>Paste string to start of vector only</p></a></li>
<li><a href='#prettyMatLines'><p>Print OMEGA and SIGMA matrices for NONMEM sections in block format.</p>
Note: This function currently only works with fixed blocks as in
the NMsim_NWPRI functionality for printing $THETAPV.</a></li>
<li><a href='#readParsWide'><p>Parameter data from csv</p></a></li>
<li><a href='#sampleParsSimpar'><p>Sample model parameters using the 'simpar' package</p></a></li>
<li><a href='#simpleCharArg'><p>Check that a variable is a single character string meeting specified requirements</p></a></li>
<li><a href='#simPopEtas'><p>Generate a population based on a Nonmem model</p></a></li>
<li><a href='#summarizeCovs'><p>Summarize simulated exposures relative to reference subject</p></a></li>
<li><a href='#triagSize'><p>Calculate number of elements for matrix specification</p></a></li>
<li><a href='#unNMsimModTab'><p>Remove NMsimModTab class and discard NMsimModTab meta data</p></a></li>
<li><a href='#unNMsimRes'><p>Remove NMsimRes class and discard NMsimRes meta data</p></a></li>
<li><a href='#writeTextFile'><p>Conveniently writeLines to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Seamless 'Nonmem' Simulation Platform</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Delff &lt;philip@delff.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A complete and seamless 'Nonmem' simulation interface within R. Turns 'Nonmem' control streams into simulation control streams, executes them with specified simulation input data and returns the results. The simulation is performed by 'Nonmem', eliminating manual work and risks of re-implementation of models in other tools.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, NMdata (&ge; 0.1.6), R.utils, MASS, fst, xfun</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, ggplot2, patchwork, tracee,
tidyvpc, simpar, kableExtra, coveffectsplot, NMcalc</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mpn.metworx.com/snapshots/stable/2024-09-23">https://mpn.metworx.com/snapshots/stable/2024-09-23</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NMautoverse/NMsim/issues">https://github.com/NMautoverse/NMsim/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://NMautoverse.github.io/NMsim/">https://NMautoverse.github.io/NMsim/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 02:04:50 UTC; philipde</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Delff [aut, cre],
  Brian Reilly [ctb],
  Sanaya Shroff [ctb],
  Boris Grinshpun [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-13 03:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add'>Create function that adds text elements to vector</h2><span id='topic+add'></span>

<h3>Description</h3>

<p>Create function that adds text elements to vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(..., .pos = "bottom")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_+3A_...">...</code></td>
<td>
<p>Elements to add.</p>
</td></tr>
<tr><td><code id="add_+3A_.pos">.pos</code></td>
<td>
<p>Either \&quot;top\&quot; or \&quot;bottom\&quot;. Decides if new text is prepended or appended to existing text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that adds the specified text to character vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myfun &lt;- add("b","d")
myfun("a")
myfun2 &lt;- add("b","d",.pos="top")
myfun2("a")
</code></pre>

<hr>
<h2 id='addClass'>Add class if not already present</h2><span id='topic+addClass'></span>

<h3>Description</h3>

<p>Add class if not already present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addClass(data, class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addClass_+3A_data">data</code></td>
<td>
<p>The object to add class to</p>
</td></tr>
<tr><td><code id="addClass_+3A_class">class</code></td>
<td>
<p>The class to add (character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with additional class
</p>

<hr>
<h2 id='addEVID2'>Add simulation records to dosing records</h2><span id='topic+addEVID2'></span>

<h3>Description</h3>

<p>Adds simulation events to all subjects in a data set. Copies over
columns that are not varying at subject level (i.e. non-variying
covariates). Can add simulation events relative to previous dosing
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEVID2(
  data,
  TIME,
  TAPD,
  CMT,
  EVID = 2,
  col.id = "ID",
  args.NMexpandDoses,
  unique = TRUE,
  as.fun,
  doses,
  time.sim
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addEVID2_+3A_data">data</code></td>
<td>
<p>Nonmem-style data set. If using 'TAPD' an 'EVID'
column must contain 1 for dosing records.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_time">TIME</code></td>
<td>
<p>A numerical vector with simulation times. Can also be
a data.frame in which case it must contain a 'TIME' column and
is merged with 'data'.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_tapd">TAPD</code></td>
<td>
<p>A numerical vector with simulation times, relative to
previous dose. When this is used, 'data' must contain rows
with 'EVID=1' events and a 'TIME' column. 'TAPD' can also be a
data.frame in which case it must contain a 'TAPD' column and
is merged with 'data'.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_cmt">CMT</code></td>
<td>
<p>The compartment in which to insert the EVID=2
records. Required if 'CMT' is a column in 'data'. If longer
than one, the records will be repeated in all the specified
compartments. If a data.frame, covariates can be specified.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_evid">EVID</code></td>
<td>
<p>The value to put in the EVID column for the created
rows. Default is 2 but 0 may be prefered even for simulation.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_col.id">col.id</code></td>
<td>
<p>The name of the column in 'data' that holds the
unique subject identifier.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_args.nmexpanddoses">args.NMexpandDoses</code></td>
<td>
<p>Only relevant - and likely not needed -
if data contains ADDL and II columns. If those columns are
included, 'addEVID2()' will use 'NMdata::NMexpanDoses()' to
evaluate the time of each dose. Other than the 'data'
argument, 'addEVID2()' relies on the default 'NMexpanDoses()'
argument values. If this is insufficient, you can specify
other argument values in a list, or you can call
'NMdata::NMexpanDoses()' manually before calling 'addEVID2()'.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_unique">unique</code></td>
<td>
<p>If 'TRUE' (default), events are reduced to unique
time points before insertion. Sometimes, it's easier to
combine sequences of time points that overlap (maybe across
'TIME' and 'TAPD'), and let 'addEVID2()' clean them. If you
want to keep your duplicated events, use 'unique=FALSE'.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a
'data.frame'. Pass a function (say 'tibble::as_tibble') in
as.fun to convert to something else. If data.tables are
wanted, use 'as.fun=&quot;data.table&quot;'. The default can be
configured using 'NMdataConf()'.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_doses">doses</code></td>
<td>
<p>Deprecated. Use 'data'.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_time.sim">time.sim</code></td>
<td>
<p>Deprecated. Use 'TIME'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting data set is ordered by ID, TIME, and
EVID. You may have to reorder for your specific needs.
</p>


<h3>Value</h3>

<p>A data.frame with dosing records
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(doses1 &lt;- NMcreateDoses(TIME=c(0,12,24,36),AMT=c(2,1)))
addEVID2(doses1,TIME=seq(0,28,by=4),CMT=2)

## two named compartments
dt.doses &lt;- NMcreateDoses(TIME=c(0,12),AMT=10,CMT=1)
seq.time &lt;- c(0,4,12,24)
dt.cmt &lt;- data.frame(CMT=c(2,3),analyte=c("parent","metabolite"))
res &lt;- addEVID2(dt.doses,TIME=seq.time,CMT=dt.cmt)

## Separate sampling schemes depending on covariate values
dt.doses &lt;- NMcreateDoses(TIME=data.frame(regimen=c("SD","MD","MD"),TIME=c(0,0,12)),AMT=10,CMT=1)

seq.time.sd &lt;- data.frame(regimen="SD",TIME=seq(0,6))
seq.time.md &lt;- data.frame(regimen="MD",TIME=c(0,4,12,24))
seq.time &lt;- rbind(seq.time.sd,seq.time.md)
addEVID2(dt.doses,TIME=seq.time,CMT=2)

## an observed sample scheme and additional simulation times
df.doses &lt;- NMcreateDoses(TIME=0,AMT=50,addl=list(ADDL=2,II=24))
dense &lt;- c(seq(1,3,by=.1),4:6,seq(8,12,by=4),18,24)
trough &lt;- seq(0,3*24,by=24)
sim.extra &lt;- seq(0,(24*3),by=2)
time.all &lt;- c(dense,dense+24*3,trough,sim.extra)
time.all &lt;- sort(unique(time.all))
dt.sample &lt;- data.frame(TIME=time.all)
dt.sample$isobs &lt;- as.numeric(dt.sample$TIME%in%c(dense,trough))
dat.sim &lt;- addEVID2(dt.doses,TIME=dt.sample,CMT=2)

## TAPD - time after previous dose
df.doses &lt;- NMcreateDoses(TIME=c(0,12),AMT=10,CMT=1)
seq.time &lt;- c(0,4,12,24)
addEVID2(df.doses,TAPD=seq.time,CMT=2)

## TIME and TAPD
df.doses &lt;- NMcreateDoses(TIME=c(0,12),AMT=10,CMT=1)
seq.time &lt;- c(0,4,12,24)
addEVID2(df.doses,TIME=seq.time,TAPD=3,CMT=2)
</code></pre>

<hr>
<h2 id='addResVar'>Add residual variability based on parameter estimates</h2><span id='topic+addResVar'></span>

<h3>Description</h3>

<p>Add residual variability based on parameter estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addResVar(
  data,
  path.ext,
  prop = NULL,
  add = NULL,
  log = FALSE,
  par.type = "SIGMA",
  trunc0 = TRUE,
  scale.par,
  subset,
  seed,
  col.ipred = "IPRED",
  col.ipredvar = "IPREDVAR",
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addResVar_+3A_data">data</code></td>
<td>
<p>A data set containing indiviudual predictions. Often a
result of NMsim.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_path.ext">path.ext</code></td>
<td>
<p>Path to the ext file to take the parameter
estimates from.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_prop">prop</code></td>
<td>
<p>Parameter number of parameter holding variance of the
proportional error component. If ERR(1) is used for
proportional error, use prop=1. Can also refer to a theta
number.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_add">add</code></td>
<td>
<p>Parameter number of parameter holding variance of the
additive error component. If ERR(1) is used for additive
error, use add=1. Can also refer to a theta number.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_log">log</code></td>
<td>
<p>Should the error be added on log scale? This is used to
obtain an exponential error distribution.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_par.type">par.type</code></td>
<td>
<p>Use &quot;sigma&quot; if variances are estimated with the
SIGMA matrix. Use &quot;theta&quot; if THETA parameters are used. See
'scale.par' too.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_trunc0">trunc0</code></td>
<td>
<p>If log=FALSE, truncate simulated values at 0? If
trunc0, returned predictions can be negative.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_scale.par">scale.par</code></td>
<td>
<p>Denotes if parmeter represents a variance or a
standard deviation. Allowed values and default value depends
on 'par.type'.  </p>
 <ul>
<li><p> if par.type=&quot;sigma&quot; only &quot;var&quot;
is allowed.  </p>
</li>
<li><p> if par.type=&quot;theta&quot; allowed values are &quot;sd&quot;
and &quot;var&quot;. Default is &quot;sd&quot;.</p>
</li></ul>
</td></tr>
<tr><td><code id="addResVar_+3A_subset">subset</code></td>
<td>
<p>A character string with an expression denoting a
subset in which to add the residual error. Example:
subset=&quot;DVID=='A'&quot;</p>
</td></tr>
<tr><td><code id="addResVar_+3A_seed">seed</code></td>
<td>
<p>A number to pass to set.seed() before
simulating. Default is to generate a seed and report it in the
console. Use seed=FALSE to avoid setting the seed (if you
prefer doing it otherwise).</p>
</td></tr>
<tr><td><code id="addResVar_+3A_col.ipred">col.ipred</code></td>
<td>
<p>The name of the column containing individual
predictions.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_col.ipredvar">col.ipredvar</code></td>
<td>
<p>The name of the column to be created by
addResVar to contain the simulated observations (individual
predictions plus residual error).</p>
</td></tr>
<tr><td><code id="addResVar_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## based on SIGMA
simres.var &lt;- addResVar(data=simres,
                        path.ext = "path/to/model.ext",
                        prop = 1,
                        add = 2,
                        par.type = "SIGMA",
                        log = FALSE)

## If implemented using THETAs
simres.var &lt;- addResVar(data=simres,
                        path.ext = "path/to/model.ext",
                        prop = 8, ## point to elements in THETA
                        add = 9,  ## point to elements in THETA
                        par.type = "THETA",
                        log = FALSE)


## End(Not run)

</code></pre>

<hr>
<h2 id='callNonmemDirect'>Generate system command to call Nonmem directly</h2><span id='topic+callNonmemDirect'></span>

<h3>Description</h3>

<p>Generate system command to call Nonmem directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callNonmemDirect(file.mod, path.nonmem)
</code></pre>

<hr>
<h2 id='checkTimes'>Test if file modification times indicate that Nonmem models should
be re-run</h2><span id='topic+checkTimes'></span>

<h3>Description</h3>

<p>Test if file modification times indicate that Nonmem models should
be re-run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTimes(
  file,
  use.input = TRUE,
  nminfo.input = NULL,
  file.mod,
  tz.lst = NULL,
  use.tmp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkTimes_+3A_file">file</code></td>
<td>
<p>Path to Nonmem-created file. Typically an output
control stream.</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_use.input">use.input</code></td>
<td>
<p>Scan input data for updates too? Default is TRUE.</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_nminfo.input">nminfo.input</code></td>
<td>
<p>If you do want to take into account input data
but avoid re-reading the information, you can pass the NMdata
meta data object.</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_file.mod">file.mod</code></td>
<td>
<p>The input control stream</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_tz.lst">tz.lst</code></td>
<td>
<p>If files are moved around on or between file
systems, the file modification time may not be reflective of
the Nonmem runtime. In that case, you can choose to extract
the time stamp from the output control stream. The issue is
that Nonmem does not write the time zone, so you have to pass
that to checkTimes if this is wanted.</p>
</td></tr>
</table>

<hr>
<h2 id='cleanStrings'>Drop spaces and odd characters. Use to ensure generated file names
are usable.</h2><span id='topic+cleanStrings'></span>

<h3>Description</h3>

<p>Drop spaces and odd characters. Use to ensure generated file names
are usable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanStrings(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleanStrings_+3A_x">x</code></td>
<td>
<p>a string to clean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NMsim:::cleanStrings("e w% # ff!l3:t,3?.csv")
NMsim:::cleanStrings("3!?:#;&lt;&gt;=, {}|=g+&amp;-
.csv")
</code></pre>

<hr>
<h2 id='completeCov'>Expand a set of covariate values into a data.set with reference
value</h2><span id='topic+completeCov'></span>

<h3>Description</h3>

<p>Expand a set of covariate values into a data.set with reference
value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completeCov(covlist, data, col.id = "ID", sigdigs = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="completeCov_+3A_covlist">covlist</code></td>
<td>
<p>A covariate specififed in a list. See
?expandCovLists.</p>
</td></tr>
<tr><td><code id="completeCov_+3A_data">data</code></td>
<td>
<p>See ?expandCovLists.</p>
</td></tr>
<tr><td><code id="completeCov_+3A_col.id">col.id</code></td>
<td>
<p>The subject ID column name. Necessary because
quantiles sould be quantiles of distribution of covariate on
subjects, not on observations (each subject contributes once).</p>
</td></tr>
<tr><td><code id="completeCov_+3A_sigdigs">sigdigs</code></td>
<td>
<p>Used for rounding of covariate values if using
quantiles or if using a function to find reference.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    NMsim:::completeCov(covlist=list(covvar="WEIGHTB",values=c(30,60,90),ref=50),sigdigs=3)
</code></pre>

<hr>
<h2 id='count_ij'>Assign i and j indexes based on parameter section text</h2><span id='topic+count_ij'></span>

<h3>Description</h3>

<p>Assign i and j indexes based on parameter section text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_ij(res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_ij_+3A_res">res</code></td>
<td>
<p>elements as detected by 'NMreadInits()'</p>
</td></tr>
</table>

<hr>
<h2 id='dtapply'>Apply function and return a data.table</h2><span id='topic+dtapply'></span>

<h3>Description</h3>

<p>A convenience function that returns a data.table with a column
representing the input values and a column with results. This is
still experimental and will not work for many input structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtapply(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtapply_+3A_...">...</code></td>
<td>
<p>arguments passed to lapply</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only functions that return vectors are currently
supported. dtapply should support functions that return
data.frames.
</p>


<h3>Value</h3>

<p>a data.table
</p>

<hr>
<h2 id='expandCovs'>Create data set where each covariate is univariately varied</h2><span id='topic+expandCovs'></span>

<h3>Description</h3>

<p>Each covariate is univariately varied while other covariates are
kept at reference values. This structure is often used for
forest-plot type simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandCovs(..., data, col.id = "ID", sigdigs = 2, reduce.ref = TRUE, as.fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandCovs_+3A_...">...</code></td>
<td>
<p>Covariates provided as lists - see examples. The name
of the arguement must match columns in data set. An element
called ref must contain either a reference value or a function
to use to derive the reference value from data
(e.g. 'median'). Provide either 'values' or 'quantiles' to
define the covariate values of interest (typically, the values
that should later be simulated and maybe shown in a forest
plot). 'label' is optional - if missing, the argument name
will be used. If quantiles are requested, they are derived
after requiring unique values for each subject.</p>
</td></tr>
<tr><td><code id="expandCovs_+3A_data">data</code></td>
<td>
<p>A data set needed if the reference(s) value of one or
more covariates is/are provided as functions (like median), or
if covariate values are provided as quantiles.</p>
</td></tr>
<tr><td><code id="expandCovs_+3A_col.id">col.id</code></td>
<td>
<p>The subject ID column name. Necessary because
quantiles sould be quantiles of distribution of covariate on
subjects, not on observations (each subject contributes once).</p>
</td></tr>
<tr><td><code id="expandCovs_+3A_sigdigs">sigdigs</code></td>
<td>
<p>Used for rounding of covariate values if using
quantiles or if using a function to find reference.</p>
</td></tr>
<tr><td><code id="expandCovs_+3A_reduce.ref">reduce.ref</code></td>
<td>
<p>If 'TRUE' (default), only return one row with
all reference values. If 'FALSE' there will be one such row
for each covariate. When reduced to one line, all columns
related to covariate-level information such as covariate name
will contain 'NA' for the reference.</p>
</td></tr>
<tr><td><code id="expandCovs_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
file.mod &lt;- system.file("examples/nonmem/xgxr134.mod",package="NMdata")
res &lt;- NMdata::NMscanData(file.mod)
expandCovs(
    WEIGHTB=list(ref=70,values=c(40,60,80,100),label="Bodyweight (kg)"),
## notice, values OR quantiles can be provided
    AGE=list(ref=median, quantiles=c(10,25,75,90)/100, label="Age (years)"
             ),
    data=res
)

## End(Not run)
</code></pre>

<hr>
<h2 id='findUpdated'>Filter control streams to only those updated since last run</h2><span id='topic+findUpdated'></span>

<h3>Description</h3>

<p>Filter control streams to only those updated since last run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findUpdated(mods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findUpdated_+3A_mods">mods</code></td>
<td>
<p>list of (input or output) control streams to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of paths found models
</p>

<hr>
<h2 id='genPhiFile'>Generate a .phi file for further simulation with Nonmem</h2><span id='topic+genPhiFile'></span>

<h3>Description</h3>

<p>This will typically be used in a couple of different
situations. One is if a number of new subjects have been simulated
and their ETAs should be reused in subsequent simulations. Another
is internally by NMsim when simulating new subjects from models
estimated with SAEM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPhiFile(data, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genPhiFile_+3A_data">data</code></td>
<td>
<p>A dataset that contains &quot;ID&quot; and all ETAs. This can be
obtained by 'NMdata::NMscanData'.</p>
</td></tr>
<tr><td><code id="genPhiFile_+3A_file">file</code></td>
<td>
<p>Path to the .phi file to be written.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, character lines (strings) optionally written to file
</p>

<hr>
<h2 id='initsToExt'>Convert inits elements to a parameter data.frame</h2><span id='topic+initsToExt'></span>

<h3>Description</h3>

<p>Convert inits elements to a parameter data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initsToExt(elements)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initsToExt_+3A_elements">elements</code></td>
<td>
<p>The elements object produced by 'NMreadInits()'.</p>
</td></tr>
</table>

<hr>
<h2 id='inputArchiveDefault'>Default location of input archive file</h2><span id='topic+inputArchiveDefault'></span>

<h3>Description</h3>

<p>Default location of input archive file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputArchiveDefault(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inputArchiveDefault_+3A_file">file</code></td>
<td>
<p>Path to input or output control stream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A file name (character)
</p>

<hr>
<h2 id='itriag'>Row numbers of elements in a triangular representation of a symmetric matrix</h2><span id='topic+itriag'></span>

<h3>Description</h3>

<p>Row numbers of elements in a triangular representation of a symmetric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itriag(blocksize, istart = 1, diag = "lower")
</code></pre>

<hr>
<h2 id='jtriag'>Column numbers of elements in a triangular representation of a symmetric matrix</h2><span id='topic+jtriag'></span>

<h3>Description</h3>

<p>Column numbers of elements in a triangular representation of a symmetric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jtriag(blocksize, istart = 1, diag = "lower")
</code></pre>

<hr>
<h2 id='modifyModel'>Internal method for handling modify.model argument to NMsim</h2><span id='topic+modifyModel'></span>

<h3>Description</h3>

<p>Internal method for handling modify.model argument to NMsim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyModel(modify.model, dt.models)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifyModel_+3A_modify.model">modify.model</code></td>
<td>
<p>A list</p>
</td></tr>
<tr><td><code id="modifyModel_+3A_dt.models">dt.models</code></td>
<td>
<p>a data.table</p>
</td></tr>
</table>

<hr>
<h2 id='NMcreateDoses'>Easily and flexibly generate dosing records</h2><span id='topic+NMcreateDoses'></span>

<h3>Description</h3>

<p>Columns will be extended by repeating last value of the column if
needed in order to match length of other columns. Combinations of
different columns can be generated by specifying covariates on the
columns where the regimens differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcreateDoses(
  TIME,
  AMT,
  EVID = 1,
  CMT = 1,
  ADDL = NULL,
  II = NULL,
  RATE = NULL,
  SS = NULL,
  addl = NULL,
  addl.lastonly = TRUE,
  col.id = "ID",
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMcreateDoses_+3A_time">TIME</code></td>
<td>
<p>The time of the dosing events. Required.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_amt">AMT</code></td>
<td>
<p>vector or data.frame with amounts amount. Required.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_evid">EVID</code></td>
<td>
<p>The event ID to use for doses. Default is to use
EVID=1, but EVID might also be wanted.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_cmt">CMT</code></td>
<td>
<p>Compartment number. Default is to dose into CMT=1. Use
'CMT=NA' or 'CMT=NULL' to omit in result.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_addl">ADDL</code></td>
<td>
<p>Number of additional dose events. Must be in
combination with and consistent with II. Notice if of length
1, only applied to last event in each regimen.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_ii">II</code></td>
<td>
<p>Dosing frequency of additional events specified in
'ADDL'. See 'ADDL' too.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_rate">RATE</code></td>
<td>
<p>Infusion rate. Optional.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_ss">SS</code></td>
<td>
<p>steady-state flag. Optional.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_addl">addl</code></td>
<td>
<p>A list of ADDL and II that will be applied to last
dose. This may be prefered if II and ADDL depend on covariates
- see examples. Optional.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_addl.lastonly">addl.lastonly</code></td>
<td>
<p>If ADDL and II are of length 1, apply only
to last event of a regimen? The default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_col.id">col.id</code></td>
<td>
<p>Default is to denote the dosing regimens by an ID
column. The name of the column can be modified using this
argument. Use 'col.id=NA' to omit the column altogether. The
latter may be wanted if repeating the regimen for a number of
subjects after running 'NMcreateDoses()'.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only TIME and AMT are required. AMT, RATE, SS, II, ADDL,
CMT are of length 1 or longer. Those not of max length 1 are
repeated.  If TIME is longer than those, they are extended to
match length of TIME. All these arguments can be data.frames
with additional columns that define distinct dosing regimens -
with distinct subject ids. However, if covariates are applied
to ADDL+II, see the addl argument and see examples.
</p>
<p>Allowed combinations of
AMT, RATE, SS, II here:
<a href="https://ascpt.onlinelibrary.wiley.com/doi/10.1002/psp4.12404">https://ascpt.onlinelibrary.wiley.com/doi/10.1002/psp4.12404</a>
</p>


<h3>Value</h3>

<p>A data.frame with dosing events
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
## Users should not use setDTthreads. This is for CRAN to only use 1 core.
data.table::setDTthreads(1) 
## arguments are expanded - makes loading easy
NMcreateDoses(TIME=c(0,12,24,36),AMT=c(2,1))
## Different doses by covariate
NMcreateDoses(TIME=c(0,12,24),AMT=data.table(AMT=c(2,1,4,2),DOSE=c(1,2)))
## Make Nonmem repeat the last dose. This is a total of 20 dosing events.
## The default, addl.lastonly=TRUE means if ADDL and II are of
## length 1, they only apply to last event.
NMcreateDoses(TIME=c(0,12),AMT=c(2,1),ADDL=9*2,II=12)
dt.amt &lt;- data.table(DOSE=c(100,400))
## multiple dose regimens. 
## Specifying the time points explicitly
dt.amt &lt;- data.table(AMT=c(200,100,800,400)*1000,DOSE=c(100,100,400,400))
doses.md.1 &lt;- NMcreateDoses(TIME=seq(0,by=24,length.out=7),AMT=dt.amt)
doses.md.1$dose &lt;- paste(doses.md.1$DOSE,"mg")
doses.md.1$regimen &lt;- "QD"
doses.md.1
## or using ADDL+II
dt.amt &lt;- data.table(AMT=c(200,100,800,400)*1000,DOSE=c(100,100,400,400))
doses.md.2 &lt;- NMcreateDoses(TIME=c(0,24),AMT=dt.amt,addl=data.table(ADDL=c(0,5),II=c(0,24)))
doses.md.2$dose &lt;- paste(doses.md.2$DOSE,"mg")
doses.md.2$regimen &lt;- "QD"
doses.md.2
## ADDL and II can be wrapped in a data.frame. This allows including covariates
NMcreateDoses(TIME=c(0,12),AMT=c(2,1),addl=data.frame(ADDL=c(NA,9*2),II=c(NA,12),trt=c("A","B")))
</code></pre>

<hr>
<h2 id='NMcreateMatLines'>Create text lines for OMEGA and SIGMA Nonmem sections</h2><span id='topic+NMcreateMatLines'></span>

<h3>Description</h3>

<p>Create text lines for OMEGA and SIGMA Nonmem sections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcreateMatLines(omegas, as.one.block = FALSE, fix = TRUE, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMcreateMatLines_+3A_omegas">omegas</code></td>
<td>
<p>A data.table with at least 'i', 'j' and 'value'
columns. See 'NMdata::NMreadExt' and the pars element returned
by that function. Must at least have columns 'i', 'j',
'value', 'iblock', 'blocksize', 'FIX'.</p>
</td></tr>
<tr><td><code id="NMcreateMatLines_+3A_as.one.block">as.one.block</code></td>
<td>
<p>If 'TRUE', all values are printed as one
block. If 'FALSE' (default), matrix will be separeted into
blocks based on position non-zero off-diagonal
values. Generally speaking, for 'OMEGA' matrices (var-cov
matrices for ETAs), this should be 'FALSE', and for
variance-covariance matrices (like 'THETAP'), this should be
'TRUE'.</p>
</td></tr>
<tr><td><code id="NMcreateMatLines_+3A_fix">fix</code></td>
<td>
<p>Include 'FIX' for all lines? If not, none will be
fixed. Currently, there is no support for keeping</p>
</td></tr>
<tr><td><code id="NMcreateMatLines_+3A_type">type</code></td>
<td>
<p>The matrix type. 'OMEGA' or 'SIGMA' - case
in-sensitive. Will be used to print say '$OMEGA' in front of
each line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>

<hr>
<h2 id='NMexec'>Execute Nonmem and archive input data with model files</h2><span id='topic+NMexec'></span>

<h3>Description</h3>

<p>Execute Nonmem from within R - optionally but by default in
parallel. Archiving the input data ensures that postprocessing can
still be reproduced if the input data files should be updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMexec(
  files,
  file.pattern,
  dir,
  sge = TRUE,
  input.archive,
  nc,
  dir.data = NULL,
  wait = FALSE,
  path.nonmem,
  update.only = FALSE,
  fun.post,
  method.execute,
  dir.psn,
  args.psn.execute,
  files.needed,
  clean = 1,
  backup = TRUE,
  quiet = FALSE,
  nmquiet = FALSE,
  system.type
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMexec_+3A_files">files</code></td>
<td>
<p>File paths to the models (control streams) to run
nonmem on. See file.pattern too.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_file.pattern">file.pattern</code></td>
<td>
<p>Alternatively to files, you can supply a
regular expression which will be passed to list.files as the
pattern argument. If this is used, use dir argument as
well. Also see data.file to only process models that use a
specific data file.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_dir">dir</code></td>
<td>
<p>If file.pattern is used, dir is the directory to search
for control streams in.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_sge">sge</code></td>
<td>
<p>Use the sge queing system. Default is TRUE. Disable for
quick models not to wait for the queue to run the job.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_input.archive">input.archive</code></td>
<td>
<p>A function of the model file path to generate
the path in which to archive the input data as RDS. Set to
FALSE not to archive the data.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_nc">nc</code></td>
<td>
<p>Number of cores to use if sending to the cluster. This
will only be used if <code>method.execute="psn"</code>, and
<code>sge=TRUE</code>. Default is 64.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_dir.data">dir.data</code></td>
<td>
<p>The directory in which the data file is
stored. This is normally not needed as data will be found
using the path in the control stream. This argument may be
removed in the future since it should not be needed.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_wait">wait</code></td>
<td>
<p>Wait for process to finish before making R console
available again? This is useful if calling NMexec from a
function that needs to wait for the output of the Nonmem run
to be available for further processing.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_path.nonmem">path.nonmem</code></td>
<td>
<p>The path to the nonmem executable. Only used if
<code>method.execute="direct"</code> or
<code>method.execute="nmsim"</code> (which is not default). If this
argument is not supplied, NMexec will try to run nmfe75,
i.e. this has to be available in the path of the underlying
shell. The default value can be modified using
<code>NMdata::NMdataConf</code>, like
<code>NMdataConf(path.nonmem="/path/to/nonmem")</code></p>
</td></tr>
<tr><td><code id="NMexec_+3A_update.only">update.only</code></td>
<td>
<p>Only run model(s) if control stream or data
updated since last run?</p>
</td></tr>
<tr><td><code id="NMexec_+3A_fun.post">fun.post</code></td>
<td>
<p>A function of the path to the control stream
('file.mod') that generates bash code to be evaluated once
Nonmem is done. This can be used to automatically run a
goodness-of-fit script or a simulation script after model
estimation.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_method.execute">method.execute</code></td>
<td>
<p>How to run Nonmem. Must be one of 'psn',
'nmsim', or 'direct'. 
</p>

<ul>
<li><p> psn PSN's execute is used. This supports parallel Nonmem
runs. Use the <code>nc</code> argument to control how many cores to use
for each job. For estimation runs, this is most likely the better
choice, if you have PSN installed. See <code>dir.psn</code> argument
too.
</p>
</li>
<li><p> nmsim Creates a temporary directory and runs Nonmem
inside that directory before copying relevant results files back
to the folder where the input control stream was. If
<code>sge=TRUE</code>, the job will be submitted to a cluster, but
parallel execution of the job itself is not supported. See
<code>path.nonmem</code> argument too.
</p>
</li>
<li><p> direct Nonmem is called directly on the control stream. This
is the simplest method and is the least convenient in most
cases. It does not offer parallel runs and leaves all the Nonmem
output files next to the control streams.
</p>
</li></ul>

<p>See 'sge' as well.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_dir.psn">dir.psn</code></td>
<td>
<p>The directory in which to find PSN
executables. This is only needed if these are not searchable
in the system path, or if the user should want to be explicit
about where to find them (i.e. want to use a specific
installed version of PSN).</p>
</td></tr>
<tr><td><code id="NMexec_+3A_args.psn.execute">args.psn.execute</code></td>
<td>
<p>A character string with arguments passed
to execute. Default is
&quot;-model_dir_name -nm_output=coi,cor,cov,ext,phi,shk,xml&quot;.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_files.needed">files.needed</code></td>
<td>
<p>In case method.execute=&quot;nmsim&quot;, this argument
specifies files to be copied into the temporary directory
before Nonmem is run. Input control stream and simulation
input data does not need to be specified.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_clean">clean</code></td>
<td>
<p>The degree of cleaning (file removal) to do after
Nonmem execution. If 'method.execute==&quot;psn&quot;', this is passed
to PSN's 'execute'. If 'method.execute==&quot;nmsim&quot;' a similar
behavior is applied, even though not as granular. NMsim's
internal method only distinguishes between 0 (no cleaning),
any integer 1-4 (default, quite a bit of cleaning) and 5
(remove temporary dir completely).</p>
</td></tr>
<tr><td><code id="NMexec_+3A_backup">backup</code></td>
<td>
<p>Before running, should existing results files be
backed up in a sub directory? If not, the files will be
deleted before running.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_quiet">quiet</code></td>
<td>
<p>Suppress messages on what NMexec is doing? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_nmquiet">nmquiet</code></td>
<td>
<p>Suppress terminal output from 'Nonmem'. This is
likely to only work on linux/unix systems.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_system.type">system.type</code></td>
<td>
<p>A charachter string, either \&quot;windows\&quot; or
\&quot;linux\&quot; - case insensitive. Windows is only experimentally
supported. Default is to use <code>Sys.info()[["sysname"]]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this to read the archived input data when retrieving
the nonmem results:
<code>NMdataConf(file.data=inputArchiveDefault)</code>
</p>
<p>Since 'NMexec' will typically not be used for simulations directly
('NMsim' is the natural interface for that purpose), the default
method for 'NMexec' is currently to use 'method.execute=&quot;psn&quot;'
which is at this point the only of the methods that allow for
multi-core execution of a single Nonmem job (NB:
'method.execute=&quot;NMsim&quot;' can run multiple jobs in parallel which
is normally sufficient for simulations).
</p>


<h3>Value</h3>

<p>NULL (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file.mod &lt;- "run001.mod"
## Not run: 
## run locally - not on cluster
NMexec(file.mod,sge=FALSE)
## run on cluster with 16 cores. 64 cores is default
NMexec(file.mod,nc=16)
## submit multiple models to cluster
multiple.models &lt;- c("run001.mod","run002.mod")
NMexec(multiple.models,nc=16)
## run all models called run001.mod - run099.mod if updated. 64 cores to each.
NMexec(file.pattern="run0..\\.mod",dir="models",nc=16,update.only=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='NMexecDirectory'>Execute Nonmem inside a dedicated directory</h2><span id='topic+NMexecDirectory'></span>

<h3>Description</h3>

<p>Like PSN's execute with less features. But easier to control from
NMexec. NMexecDirectory is not intended to be run by the user. Use
<code>NMexec</code> or <code>NMsim</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMexecDirectory(
  file.mod,
  path.nonmem,
  files.needed,
  dir.data = "..",
  system.type,
  clean,
  sge = nc &gt; 1,
  nc = 1,
  pnm,
  fun.post = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMexecDirectory_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to a Nonmem input control stream.</p>
</td></tr>
<tr><td><code id="NMexecDirectory_+3A_path.nonmem">path.nonmem</code></td>
<td>
<p>Path to Nonmem executable. You may want to
control this with <code>NMdata::NMdataConf</code>.</p>
</td></tr>
<tr><td><code id="NMexecDirectory_+3A_files.needed">files.needed</code></td>
<td>
<p>Files needed to run the control stream. This
cold be a .phi file from which etas will be read. Notice,
input data set will be handled automatically, you do not need
to specify that.</p>
</td></tr>
<tr><td><code id="NMexecDirectory_+3A_dir.data">dir.data</code></td>
<td>
<p>If NULL, data will be copied into the temporary
directory, and Nonmem will read it from there. If not NULL,
dir.data must be the relative path from where Nonmem is run to
where the input data file is stored. This would be &quot;..&quot; if the
run directory is created in a directory where the data is
stored.</p>
</td></tr>
<tr><td><code id="NMexecDirectory_+3A_clean">clean</code></td>
<td>
<p>The degree of cleaning (file removal) to do after
Nonmem execution. If 'method.execute==&quot;psn&quot;', this is passed
to PSN's 'execute'. If 'method.execute==&quot;nmsim&quot;' a similar
behavior is applied, even though not as granular. NMsim's
internal method only distinguishes between 0 (no cleaning),
any integer 1-4 (default, quite a bit of cleaning) and 5
(remove temporary dir completely).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bash shell script for execution of Nonmem
</p>

<hr>
<h2 id='NMgenPNM'>Generate PNM file for sge clusters</h2><span id='topic+NMgenPNM'></span>

<h3>Description</h3>

<p>Generate PNM file for sge clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMgenPNM(nc, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMgenPNM_+3A_nc">nc</code></td>
<td>
<p>number of cores wanted</p>
</td></tr>
<tr><td><code id="NMgenPNM_+3A_file">file</code></td>
<td>
<p>The file path to write the result to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file path (character string)
</p>

<hr>
<h2 id='NMreadFilters'>Read data filters from a NONMEM model</h2><span id='topic+NMreadFilters'></span>

<h3>Description</h3>

<p>Read data filters from a NONMEM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadFilters(file, lines, filters.only = TRUE, as.fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadFilters_+3A_file">file</code></td>
<td>
<p>Control stream path</p>
</td></tr>
<tr><td><code id="NMreadFilters_+3A_lines">lines</code></td>
<td>
<p>Control stream lines if already read from file</p>
</td></tr>
<tr><td><code id="NMreadFilters_+3A_filters.only">filters.only</code></td>
<td>
<p>Return the filters only or also return the remaining text in a separate object? If 'FALSE', a list with the two objects is returned.</p>
</td></tr>
<tr><td><code id="NMreadFilters_+3A_as.fun">as.fun</code></td>
<td>
<p>Function to run on the tables with filters.</p>
</td></tr>
</table>

<hr>
<h2 id='NMreadInits'>Tabulate information from parameter sections in control streams</h2><span id='topic+NMreadInits'></span>

<h3>Description</h3>

<p>Tabulate information from parameter sections in control streams
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadInits(file, lines, section, return = "pars", as.fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadInits_+3A_file">file</code></td>
<td>
<p>Path to a control stream. See 'lines' too.</p>
</td></tr>
<tr><td><code id="NMreadInits_+3A_lines">lines</code></td>
<td>
<p>A control stream as text lines. Use this or 'file'.</p>
</td></tr>
<tr><td><code id="NMreadInits_+3A_section">section</code></td>
<td>
<p>The section to read. Typically, &quot;theta&quot;, &quot;omega&quot;,
or &quot;sigma&quot;. Default is those three.</p>
</td></tr>
<tr><td><code id="NMreadInits_+3A_return">return</code></td>
<td>
<p>By default (when <code>return="pars"</code>, a parameter
table with initial values, FIX, lower and upper bounds etc. In
most cases, that is what is needed to derive information about
parameter definitions. If <code>return="all"</code>, two additional
tables are returned which can be used if the aim is to modify
and write the resulting parameters to a control stream.</p>
</td></tr>
<tr><td><code id="NMreadInits_+3A_as.fun">as.fun</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.frame' with parameter values. If 'return=&quot;all&quot;', a
list of three tables.
</p>

<hr>
<h2 id='NMreadSim'>Read simulation results based on NMsim's track of model runs</h2><span id='topic+NMreadSim'></span>

<h3>Description</h3>

<p>Read simulation results based on NMsim's track of model runs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSim(
  x,
  check.time = FALSE,
  dir.sims,
  wait = FALSE,
  quiet = FALSE,
  progress,
  rm.tmp = FALSE,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadSim_+3A_x">x</code></td>
<td>
<p>Path to the simulation-specific rds file generated by
NMsim, typically called 'NMsim_MetaData.rds'. Can also be a
table of simulation runs as stored in 'rds' files by
'NMsim'. The latter should almost never be used.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_check.time">check.time</code></td>
<td>
<p>If found, check whether 'fst' file modification
time is newer than 'rds' file. The 'fst' is generated based on
information in &lsquo;rds', but notice that some systems don&rsquo;t
preserve the file modification times. Becasue of that,
'check.time' is 'FALSE' by default.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_dir.sims">dir.sims</code></td>
<td>
<p>By default, 'NMreadSim' will use information about
the relative path from the results table file
('_MetaData.rds') to the Nonmem simulation results. If these
paths have changed, or for other reasons this doesn't work,
you can use the 'dir.sims' argument to specify where to find
the Nonmem simulation results. If an '.fst' file was already
generated and is found next to the '_MetaData.rds', the path
to the Nonmem simulation results is not used.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_wait">wait</code></td>
<td>
<p>If simulations seem to not be done yet, wait for them
to finish? If not, an error will be thrown. If you choose to
wait, the risk is results never come. 'NMreadSim' will be
waiting for an 'lst' file. If Nonmem fails, it will normally
generate an 'lst' file. But if 'NMTRAN' fails (checks of
control stream prior to running Nonmem), the 'lst' file is not
generated.  Default is not to wait.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_quiet">quiet</code></td>
<td>
<p>Turn off some messages about what is going on?
Default is to report the messages.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being read. The progress
tracking is based on the number of models completed/read, not
the status of the individual models.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_rm.tmp">rm.tmp</code></td>
<td>
<p>If results are read successfully, remove temporary
simulation results files? This can be useful after a script is
developed and intermediate debugging information is not
needed. It cleans up and saves significant disk space.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data set of class defined by as.fun
</p>

<hr>
<h2 id='NMreadSimModTab'>Read simulation results from rds objects and/or NMsimModTab objects</h2><span id='topic+NMreadSimModTab'></span>

<h3>Description</h3>

<p>Read simulation results from rds objects and/or NMsimModTab objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimModTab(
  x,
  check.time = FALSE,
  dir.sims,
  wait = FALSE,
  skip.missing = FALSE,
  quiet = FALSE,
  progress,
  read.fst = NULL,
  fast.tables = NULL,
  carry.out = NULL,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadSimModTab_+3A_x">x</code></td>
<td>
<p>Path to the simulation-specific rds file generated by
NMsim, typically called 'NMsim_MetaData.rds'. Can also be a
table of simulation runs as stored in 'rds' files by
'NMsim'. The latter should almost never be used.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_check.time">check.time</code></td>
<td>
<p>If found, check whether 'fst' file modification
time is newer than 'rds' file. The 'fst' is generated based on
information in &lsquo;rds', but notice that some systems don&rsquo;t
preserve the file modification times. Becasue of that,
'check.time' is 'FALSE' by default.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_dir.sims">dir.sims</code></td>
<td>
<p>By default, 'NMreadSim' will use information about
the relative path from the results table file
('_MetaData.rds') to the Nonmem simulation results. If these
paths have changed, or for other reasons this doesn't work,
you can use the 'dir.sims' argument to specify where to find
the Nonmem simulation results. If an '.fst' file was already
generated and is found next to the '_MetaData.rds', the path
to the Nonmem simulation results is not used.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_wait">wait</code></td>
<td>
<p>If simulations seem to not be done yet, wait for them
to finish? If not, an error will be thrown. If you choose to
wait, the risk is results never come. 'NMreadSim' will be
waiting for an 'lst' file. If Nonmem fails, it will normally
generate an 'lst' file. But if 'NMTRAN' fails (checks of
control stream prior to running Nonmem), the 'lst' file is not
generated.  Default is not to wait.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_quiet">quiet</code></td>
<td>
<p>Turn off some messages about what is going on?
Default is to report the messages.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being simulated. The progress
tracking is based on the number of models completed, not the
status of the individual models.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>

<hr>
<h2 id='NMreadSimModTabOne'>Read simulation results from an rds or a NMsimModTab object</h2><span id='topic+NMreadSimModTabOne'></span>

<h3>Description</h3>

<p>Read simulation results from an rds or a NMsimModTab object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimModTabOne(
  modtab,
  check.time = FALSE,
  dir.sims,
  wait = FALSE,
  quiet = FALSE,
  skip.missing = FALSE,
  progress,
  read.fst = NULL,
  fast.tables = NULL,
  carry.out = NULL,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadSimModTabOne_+3A_check.time">check.time</code></td>
<td>
<p>If found, check whether 'fst' file modification
time is newer than 'rds' file. The 'fst' is generated based on
information in &lsquo;rds', but notice that some systems don&rsquo;t
preserve the file modification times. Becasue of that,
'check.time' is 'FALSE' by default.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_dir.sims">dir.sims</code></td>
<td>
<p>By default, 'NMreadSim' will use information about
the relative path from the results table file
('_MetaData.rds') to the Nonmem simulation results. If these
paths have changed, or for other reasons this doesn't work,
you can use the 'dir.sims' argument to specify where to find
the Nonmem simulation results. If an '.fst' file was already
generated and is found next to the '_MetaData.rds', the path
to the Nonmem simulation results is not used.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_wait">wait</code></td>
<td>
<p>If simulations seem to not be done yet, wait for them
to finish? If not, an error will be thrown. If you choose to
wait, the risk is results never come. 'NMreadSim' will be
waiting for an 'lst' file. If Nonmem fails, it will normally
generate an 'lst' file. But if 'NMTRAN' fails (checks of
control stream prior to running Nonmem), the 'lst' file is not
generated.  Default is not to wait.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_quiet">quiet</code></td>
<td>
<p>Turn off some messages about what is going on?
Default is to report the messages.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being read. The progress
tracking is based on the number of models completed/read, not
the status of the individual models.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>

<hr>
<h2 id='NMreadSimRes'>Read simulation results from data.frames or fst files</h2><span id='topic+NMreadSimRes'></span>

<h3>Description</h3>

<p>Read simulation results from data.frames or fst files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimRes(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadSimRes_+3A_x">x</code></td>
<td>
<p>a data set or a fst file</p>
</td></tr>
</table>

<hr>
<h2 id='NMreadSimResOne'>read one sim element. This will be run in lapply in NMreadSim.</h2><span id='topic+NMreadSimResOne'></span>

<h3>Description</h3>

<p>read one sim element. This will be run in lapply in NMreadSim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimResOne(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadSimResOne_+3A_x">x</code></td>
<td>
<p>A path to an fst file or a data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>

<hr>
<h2 id='NMreadSizes'>Read SIZES info from a control stream</h2><span id='topic+NMreadSizes'></span>

<h3>Description</h3>

<p>Read SIZES info from a control stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSizes(file.mod = NULL, lines = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreadSizes_+3A_file.mod">file.mod</code></td>
<td>
<p>Control stream path.</p>
</td></tr>
<tr><td><code id="NMreadSizes_+3A_lines">lines</code></td>
<td>
<p>Character vector with control stream file.</p>
</td></tr>
</table>

<hr>
<h2 id='NMreplaceInits'>Replace initial values in Nonmem control stream</h2><span id='topic+NMreplaceInits'></span>

<h3>Description</h3>

<p>Replace initial values in Nonmem control stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreplaceInits(inits, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMreplaceInits_+3A_inits">inits</code></td>
<td>
<p>A data.frame with new initial estimates, same style
as returned by NMdata::NMreadExt. Column' par.type' can contain
elements THETA, OMEGA, SIGMA.</p>
</td></tr>
<tr><td><code id="NMreplaceInits_+3A_...">...</code></td>
<td>
<p>Passed to NMdata::NMwriteSection. This is important for
NMreplaceInits to run at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified control stream
</p>

<hr>
<h2 id='NMrunLin'>Internal function to run Nonmem on linux</h2><span id='topic+NMrunLin'></span>

<h3>Description</h3>

<p>Internal function to run Nonmem on linux
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMrunLin(
  fn.mod,
  dir.mod.abs,
  exts.cp,
  meta.tables,
  path.nonmem,
  clean,
  sge,
  nc,
  pnm,
  fun.post = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMrunLin_+3A_fn.mod">fn.mod</code></td>
<td>
<p>Just the file name, not including path</p>
</td></tr>
</table>

<hr>
<h2 id='NMseed'>Add seed string to simulation model data.table</h2><span id='topic+NMseed'></span>

<h3>Description</h3>

<p>This is an internal NMsim function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMseed(models, nseeds, dist, values, fun.seed = seedFunDefault)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMseed_+3A_models">models</code></td>
<td>
<p>A data.frame containing model paths etc as created
by <code>NMsim()</code>.</p>
</td></tr>
<tr><td><code id="NMseed_+3A_nseeds">nseeds</code></td>
<td>
<p>Number of seeds in each simulation control
stream. Default is to match length of dist.</p>
</td></tr>
<tr><td><code id="NMseed_+3A_dist">dist</code></td>
<td>
<p>Distribution of random sources. These character
strings will be pasted directly into the Nonem control streams
after the seed values. Default is &quot;&quot; which means one normal
distribution. <code>dist=c("","UNIFORM")</code> will give two seeds
with random sources following a normal and a uniform
distribution.</p>
</td></tr>
<tr><td><code id="NMseed_+3A_values">values</code></td>
<td>
<p>Optionally, seed values. This can be a data.frame
with as many columns as random sources.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data.table with simulation model information
including seed strings.
</p>

<hr>
<h2 id='NMsim'>Simulate from an estimated Nonmem model</h2><span id='topic+NMsim'></span>

<h3>Description</h3>

<p>Supply a data set and an estimation input control stream, and
NMsim can create neccesary files (control stream, data files), run
the simulation and read the results. It has additional methods for
other simulation types available, can do multiple simulations at
once and more. Please see vignettes for an introduction to how to
get the most out of this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim(
  file.mod,
  data,
  subproblems = NULL,
  reuse.results = FALSE,
  seed.R,
  seed.nm,
  name.sim,
  table.vars,
  table.options,
  table.format,
  carry.out = TRUE,
  method.sim = NMsim_default,
  typical = FALSE,
  inits,
  modify,
  filters,
  sizes,
  path.nonmem = NULL,
  sge = FALSE,
  nc = 1,
  execute = TRUE,
  script = NULL,
  transform = NULL,
  order.columns = TRUE,
  method.execute,
  nmrep,
  col.flagn = FALSE,
  sim.dir.from.scratch = TRUE,
  create.dirs = TRUE,
  dir.psn,
  args.psn.execute,
  args.NMscanData,
  as.fun,
  system.type = NULL,
  dir.sims,
  dir.res,
  file.res,
  wait,
  text.sim = "",
  auto.dv = TRUE,
  clean,
  quiet = FALSE,
  nmquiet,
  progress,
  check.mod = TRUE,
  format.data.complete = "rds",
  text.table,
  suffix.sim,
  seed,
  file.ext = NULL,
  method.update.inits,
  modify.model,
  list.sections,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_+3A_file.mod">file.mod</code></td>
<td>
<p>Path(s) to the input control stream(s) to run the
simulation on. The output control stream is for now assumed to
be stored next to the input control stream and ending in .lst
instead of .mod. The .ext file must also be present. If
simulating known subjects, the .phi is necessary too.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_data">data</code></td>
<td>
<p>The simulation data as a <code>data.frame</code> or a list
of <code>data.frame</code>s. If a list, the model(s) will be run on
each of the data sets in the list.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_subproblems">subproblems</code></td>
<td>
<p>Number of subproblems to use as
<code>SUBPROBLEMS</code> in <code>$SIMULATION</code> block in Nonmem. The
default is subproblem=0 which means not to use
<code>SUBPROBLEMS</code>.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_reuse.results">reuse.results</code></td>
<td>
<p>If simulation results found on file, should
they be used? If TRUE and reading the results fail, the
simulations will still be rerun.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_seed.r">seed.R</code></td>
<td>
<p>A value passed to <code>set.seed()</code>. It is
recommended to use <code>seed.R</code> rather than calling
<code>set.seed()</code> manually because the seed can then be
captured and stored by <code>NMsim()</code> for reproducibility. See
<code>seed.nm</code> for finer control of the seeds that are used in
the Nonmem control streams.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_seed.nm">seed.nm</code></td>
<td>
<p>Control Nonmem seeds. If a numeric, a vector or a
'data.frame', these are used as the the seed values (a single
value or vector will be recycled so make sure the dimesnsions
are right, the number of columns in a <code>data.frame</code> will
dictate the number of seeds in each Nonmem control stream. Use
a list with elements 'values', and 'dist' and others for
detailed control of the random sources. See <code>?NMseed</code> for
details on what arguments can be passed this way.
</p>
<p>Default is to draw seeds betwen
0 and 2147483647 (the values supported by Nonmem) for each
simulation. You can pass a function that will be evaluated
(say to choose a different pool of seeds to draw from).
</p>
<p>To avoid changing an exisiting seed in a control stream, use
<code>seed.nm="asis"</code>.
</p>
<p>In case <code>method.sim=NMsim_EBE</code>, seeds are not used.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_name.sim">name.sim</code></td>
<td>
<p>Give all filenames related to the simulation a
suffix. A short string describing the sim is recommended like
&quot;ph3_regimens&quot;.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_table.vars">table.vars</code></td>
<td>
<p>Variables to be printed in output table as a
character vector or a space-separated string of variable
names. The default is to export the same tables as listed in
the input control stream. If <code>table.vars</code> is provided,
all output tables in estimation control streams are dropped
and replaced by a new one with just the provided variables. If
many variables are exported, and much fewer are used, it can
speed up NMsim significantly to only export what is needed
(sometimes this is as little as &quot;PRED IPRED&quot;). Nonmem writes
data slowly so reducing output data can make a very big
difference in execution time. See <code>table.options</code> too.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_table.options">table.options</code></td>
<td>
<p>A character vector or a string of
space-separated options. Only used if <code>table.vars</code> is
provided. If constructing a new output table with
<code>table.vars</code> the default is to add two options,
<code>NOAPPEND</code> and <code>NOPRINT</code>. You can modify that with
<code>table.options</code>. Do not try to modify output filename -
<code>NMsim</code> takes care of that.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_table.format">table.format</code></td>
<td>
<p>A format for '$TABLE'. Only used if
'table.vars' is provided.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_carry.out">carry.out</code></td>
<td>
<p>Variables from input data that should be included
in results. Default is to include everything. If working with
large data sets, it may be wanted to provide a subset of the
columns here. If doing very large simulations, this may also
be a way to save memory.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_method.sim">method.sim</code></td>
<td>
<p>A function (not quoted) that creates the
simulation control stream and other necessary files for a
simulation based on the estimation control stream, the data,
etc. The default is called <code>NMsim_default</code> which will
replace any estimation and covariance step by a simulation
step. See details section on oter methods, and see examples
and especially vignettes on how to use the different provided
methods.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_typical">typical</code></td>
<td>
<p>Run with all ETAs fixed to zero? Technically all
ETAs=0 is obtained by replacing <code>$OMEGA</code> by a zero
matrix. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_inits">inits</code></td>
<td>
<p>Control the parameter values. 'inits' is a list. The
'method' element controls which method is used to do this, and
this corresponds to the old 'method.update.inits' argument. If
using the new 'method=nmsim' you can specify parameter
values, fix/unfix them, and edit lower and upper limits for
estimation.
</p>

<ul>
<li><p>'method=&quot;nmsim&quot;', all other
arguments are passed to 'NMwriteInits'. This is a flexible
method that allows for modification of the parameter values
and is expected to be the default method in the
future. Example which will update the parameter values based
on the available estimate, but with 'THETA(2)=1.3':
'inits=list(method=&quot;nmsim&quot;,&quot;THETA(2)&quot;=list(init=1.3))'. See
'?NMwriteInits' too.
</p>
</li>
<li><p>'method=&quot;psn&quot;'
uses PSN's &quot;update_inits&quot;. Requires a functioning PSN
installation and possibly that <code>dir.psn</code> is correctly
set. The advantages of this method are that it keeps comments
in the control stream and that it is a method known to many.
</p>
</li>
<li><p>'method=&quot;nmsim&quot;'
Uses a simple internal method to update the parameter values
based on the ext file.  The advantages of &quot;nmsim&quot; are it does not
require PSN, and that it does not rely on code-interpretation for generation of simulation control streams. &quot;nmsim&quot; fixes the whole
OMEGA and SIGMA matrices as single blocks making the $OMEGA and
$SIGMA sections of the control streams less easy to read. On the
other hand, this method is robust because it avoids any
interpretation of BLOCK structure or other code in the control
streams.
</p>
</li>
<li><p>'method=&quot;none&quot;' Do nothing. This is useful if the model to simulate
has not been estimated but parameter values have been manually put
into the respective sections in the control stream.
</p>
</li></ul>

<p>See also 'file.ext' which can now be handled by 'inits' too. This
change collects the update of the &quot;initial&quot;
parameter values into one interface rather than multiple
arguments.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_modify">modify</code></td>
<td>
<p>Named list of additional control stream
section edits. Note, these can be functions that define how to
edit sections. This is an advanced feature which is not needed
to run most simulations. It is however powerful for some types
of analyses, like modifying parameter values. See vignettes
for further information.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_filters">filters</code></td>
<td>
<p>Edit data filters ('IGNORE'/'ACCEPT' statements)
before running model. This should normally only be used if no
data set is provided. It can be useful if simulating for a VPC
but a different subset of data needs to be simulated than the
one used for estimation. A common example on this is inclusion
of BLQ's in the VPC even if they were excluded in the
estimation. See '?NMreadFilters' which returns a table you can
edit and pass to 'filters'. You can also just pass a string
representing the full set of filters to be used. If you pass a
string, consider including &quot;IGN=@&quot; to avoid character rows,
like the column headers.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_sizes">sizes</code></td>
<td>
<p>If needed, adjust the '$SIZES' section by providing a
list of arguments to 'NMupdateSizes()'. Example:
&lsquo;sizes=list(PD=80)'. See '?NMupdateSizes' for details. Don&rsquo;t
use arguments like 'file.mod' and 'newfile' which are handled
internally.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_path.nonmem">path.nonmem</code></td>
<td>
<p>The path to the Nonmem executable to use. The
could be something like &quot;/usr/local/NONMEM/run/nmfe75&quot; (which
is a made up example). No default is available. You should be
able to figure this out through how you normally execute
Nonmem, or ask a colleague.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_sge">sge</code></td>
<td>
<p>Submit to cluster? Default is not to, but this is very
useful if creating a large number of simulations,
e.g. simulate with all parameter estimates from a bootstrap
result.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_nc">nc</code></td>
<td>
<p>Number of cores used in parallelization. Only used if
'sge=TRUE'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_execute">execute</code></td>
<td>
<p>Execute the simulation or only prepare it?
'execute=FALSE' can be useful if you want to do additional
tweaks or simulate using other parameter estimates.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_script">script</code></td>
<td>
<p>The path to the script where this is run. For
stamping of dataset so results can be traced back to code.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_transform">transform</code></td>
<td>
<p>A list defining transformations to be applied
after the Nonmem simulations and before plotting. For each
list element, its name refers to the name of the column to
transform, the contents must be the function to apply.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_order.columns">order.columns</code></td>
<td>
<p>reorder columns by calling
<code>NMdata::NMorderColumns</code> before saving dataset and
running simulations? Default is TRUE.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_method.execute">method.execute</code></td>
<td>
<p>Specify how to call Nonmem. Options are
&quot;psn&quot; (PSN's execute), &quot;nmsim&quot; (an internal method similar to
PSN's execute), and &quot;direct&quot; (just run Nonmem directly and
dump all the temporary files). &quot;nmsim&quot; has advantages over
&quot;psn&quot; that makes it the only supported method when
type.sim=&quot;NMsim_EBE&quot;. &quot;psn&quot; has the simple advantage that the
path to nonmem does not have to be specified if &quot;execute&quot; is
in the system search path. So as long as you know where your
Nonmem executable is, &quot;nmsim&quot; is recommended. The default is
&quot;nmsim&quot; if path.nonmem is specified, and &quot;psn&quot; if not.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_nmrep">nmrep</code></td>
<td>
<p>Include 'NMREP' as counter of subproblems? The
default is to do so if 'subproblems&gt;0'. This will insert a
counter called 'NMREP' in the '$ERROR' section and include
that in the output table(s). At this point, nothing is done to
avoid overwriting existing variables.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_col.flagn">col.flagn</code></td>
<td>
<p>Only used if 'data' is provided. Use this if you
are including an exclusion flag column in data. However, what
NMsim will then do is to require that column to equal '0'
(zero) for the rows to be simulated. It is often better to
subset the data before simulation. See 'filters' too.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_sim.dir.from.scratch">sim.dir.from.scratch</code></td>
<td>
<p>If TRUE (default) this will wipe the
simulation directory before running new simulations. The
directory that will be emptied is _not_ dir.sims where you may
keep many or all your simulations. It is the subdirectory
named based on the run name and <code>name.sim</code>. The reason it
is advised to wipe this directory is that if you in a previous
simulation created simulation runs that are now obsolete, you
could end up reading those too when collecting the
results. NMsim will delete previously generated simulation
control streams with the same name, but this option goes
further. An example where it is important is if you first ran
1000 replications, fixed something and now rand 500. If you
choose FALSE here, you can end up with the results of 500 new
and 500 old simulations.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_create.dirs">create.dirs</code></td>
<td>
<p>If the directories specified in dir.sims and
dir.res do not exists, should it be created? Default is TRUE.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_dir.psn">dir.psn</code></td>
<td>
<p>The directory in which to find PSN's executables
('execute' and 'update_inits'). The default is to rely on the
system's search path. So if you can run 'execute' and
'update_inits' by just typing that in a terminal, you don't
need to specify this unless you want to explicitly use a
specific installation of PSN on your system.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_args.psn.execute">args.psn.execute</code></td>
<td>
<p>A charachter string that will be passed as
arguments PSN's 'execute'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_args.nmscandata">args.NMscanData</code></td>
<td>
<p>If <code>table.options</code> is used, NMsim
turns to 'NMdata::NMscanData()' for a general method to read
the output tables. Use 'args.NMscanData' to pass additional
arguments (in a list) to that function if you want the results
to be read in a specific way. This can be if the model for
some reason drops rows, and you need to merge by a row
identifier. You would do 'args.NMscanData=list(col.row=&quot;ROW&quot;)'
to merge by a column called 'ROW'. This is only used in rare
cases. Better just stick to NMsim's optimized default
'table.options' and related methods for reading results.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_system.type">system.type</code></td>
<td>
<p>A charachter string, either \&quot;windows\&quot; or
\&quot;linux\&quot; - case insensitive. Windows is only experimentally
supported. Default is to use <code>Sys.info()[["sysname"]]</code>.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_dir.sims">dir.sims</code></td>
<td>
<p>The directory in which NMsim will store all
generated files. Default is to create a folder called 'NMsim'
next to 'file.mod'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_dir.res">dir.res</code></td>
<td>
<p>Provide a path to a directory in which to save rds
files with paths to results. Default is to use dir.sims. After
running 'NMreadSim()' on these files, the original simulation
files can be deleted. Hence, providing both 'dir.sims' and
'dir.res' provides a structure that is simple to
clean. 'dir.sims' can be purged when 'NMreadSim' has been run
and only small 'rds' and 'fst' files will be kept in
'dir.res'. Notice, in case multiple models are simulated,
multiple 'rds' (to be read with 'NMreadSim()') files will be
created by default. In cases where multiple models are
simulated, see 'file.res' to get just one file refering to all
simulation results.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_file.res">file.res</code></td>
<td>
<p>Path to an rds file that will contain a table of
the simulated models and other metadata. This is needed for
subsequently retrieving all the results using
'NMreadSim()'. The default is to create a file called
'NMsim_..._MetaData.rds' under the <code>dir.res</code> directory
where ... is based on the model name. However, if multiple
models (<code>file.mod</code>) are simulated, this will result in
multiple rds files. Specifying a path ensures that one rds
file containing information about all simulated models will be
created. Notice if <code>file.res</code> is supplied, <code>dir.res</code>
is not used.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_wait">wait</code></td>
<td>
<p>Wait for simulations to finish? Default is to do so if
simulations are run locally but not to if they are sent to the
cluster. Waiting for them means that the results will be read
when simulations are done. If not waiting, path(s) to 'rds'
files to read will be returned. Pass them through
'NMreadSim()' (which also supports waiting for the simulations
to finish).</p>
</td></tr>
<tr><td><code id="NMsim_+3A_text.sim">text.sim</code></td>
<td>
<p>A character string to be pasted into
$SIMULATION. This must not contain seed or SUBPROBLEM which
are handled separately. Default is to include &quot;ONLYSIM&quot;. You
cannot avoid that using 'text.sim'. Instead, you can use
'onlysim=FALSE' which will be passed to 'NMsim_default()'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_auto.dv">auto.dv</code></td>
<td>
<p>Add a column called 'DV' to input data sets if a
column of that name is not found? Nonmem is generally
dependent on a 'DV' column in input data but this is typically
uninformative in simulation data sets and hence easily
forgotten when generating simulation data sets. If
<code>auto.dv=TRUE</code> and no 'DV' column is found, 'DV=NA' will
be added. In this case ('auto.dv=TRUE' and no 'DV' column
found) a 'MDV=1' column will also be added if none found.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_clean">clean</code></td>
<td>
<p>The degree of cleaning (file removal) to do after
Nonmem execution. If 'method.execute==&quot;psn&quot;', this is passed
to PSN's 'execute'. If 'method.execute==&quot;nmsim&quot;' a similar
behavior is applied, even though not as granular. NMsim's
internal method only distinguishes between 0 (no cleaning),
any integer 1-4 (default, quite a bit of cleaning) and 5
(remove temporary dir completely).</p>
</td></tr>
<tr><td><code id="NMsim_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, messages from what is going on will be
suppressed.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_nmquiet">nmquiet</code></td>
<td>
<p>Silent console messages from Nonmem? The default
behaviour depends. It is FALSE if there is only one model to
execute and 'progress=FALSE'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being simulated. The progress
tracking is based on the number of models completed, not the
status of the individual models.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_check.mod">check.mod</code></td>
<td>
<p>Check the provided control streams for contents
that may cause issues for simulation. Default is 'TRUE', and
it is only recommended to disable this if you are fully aware
of such a feature of your control stream, you know how it
impacts simulation, and you want to get rid of warnings.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_format.data.complete">format.data.complete</code></td>
<td>
<p>For development purposes - users do
not need this argument. Controls what format the complete
input data set is saved in.  Possible values are 'rds'
(default), 'fst' (experimental) and 'csv'. 'fst' may be faster
and use less disk space but factor levels may be lost from
input data to output data. 'csv' will also lead to loss of
additional information such as factor levels.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_text.table">text.table</code></td>
<td>
<p>Deprecated. Use 'table.vars' and 'table.options'
instead.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_suffix.sim">suffix.sim</code></td>
<td>
<p>Deprecated. Use name.sim instead.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_seed">seed</code></td>
<td>
<p>Deprecated. See <code>seed.R</code> and <code>seed.nm</code>.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_file.ext">file.ext</code></td>
<td>
<p>Depecated. Use
'inits=list(file.ext=&quot;path/to/file.ext&quot;)' instead. Optionally
provide a parameter estimate file from Nonmem. This is
normally not needed since 'NMsim' will by default use the ext
file stored next to the input control stream (replacing the
file name extension with '.ext'). If using
method.update.inits=&quot;psn&quot;, this argument cannot be used.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_method.update.inits">method.update.inits</code></td>
<td>
<p>Deprecated, please migrate to 'inits'
instead. The initial values of all parameters are by updated
from the estimated model before running the simulation. NMsim
can do this with a native function or use PSN to do it - or
the step can be skipped to not update the values.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_modify.model">modify.model</code></td>
<td>
<p>Deprecated. Use modify instead.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_list.sections">list.sections</code></td>
<td>
<p>Deprecated. Use modify instead.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>method.sim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loosely speaking, the argument <code>method.sim</code> defines
_what_ NMsim will do, <code>method.execute</code> define _how_ it
does it. <code>method.sim</code> takes a function that converts an
estimation control stream into whatever should be
run. Features like replacing '$INPUT', '$DATA', '$TABLE', and
handling seeds are NMsim features that are done in addition to
the <code>method.sim</code>. Also the <code>modeify.model</code> argument
is handled in addition to the <code>method.sim</code>. The
<code>subproblems</code> and <code>seed.nm</code> arguments are available
to all methods creating a <code>$SIMULATION</code> section.
</p>
<p>Notice, the following functions are internally available to
'NMsim' so you can run them by say <code>method.sim=NMsim_EBE</code>
without quotes. To see the code of that method, type
<code>NMsim_EBE</code>.
</p>

<ul>
<li> <p><code>NMsim_default</code> The default behaviour. Replaces any
$ESTIMATION and $COVARIANCE sections by a $SIMULATION section.
</p>
</li>
<li> <p><code>NMsim_asis</code> The simplest of all method. It does nothing (but
again, <code>NMsim</code> handles '$INPUT', '$DATA', '$TABLE' and
more. Use this for instance if you already created a simulation
(or estimation actually) control stream and want NMsim to run it
on different data sets.
</p>
</li>
<li> <p><code>NMsim_EBE</code> Simulates _known_ ETAs. By default, the ETA
values are automatically taken from the estimation run. This is
what is refered to as emperical Bayes estimates, hence the name of
the method &quot;NMsim_EBE&quot;. However, the user can also provide a
different '.phi' file which may contain simulated ETA values (see
the 'file.phi' argument). ID values in the simulation data set
must match ID values in the phi file for this step to work. If
refering to estimated subjects, the .phi file from the estimation
run must be found next to the .lst file from the estimation with
the same file name stem (say 'run1.lst' and 'run1.phi'). Again, ID
values in the (simulation) input data must be ID values that were
used in the estimation too. The method Runs an <code>$ESTIMATION
MAXEVAL=0</code> but pulls in ETAs for the ID's found in data. No
<code>$SIMULATION</code> step is run which unfortunately means no
residual error will be simulated.
</p>
</li>
<li> <p><code>NMsim_VarCov</code> Like <code>NMsim_default</code> but '$THETA',
'$OMEGA', and 'SIGMA' are drawn from distribution estimated in
covariance step. This means that a successful covariance step must
be available from the estimation. NB. A multivariate normal
distribution is used for all parameters, including '$OMEGA' and
'$SIGMA' which is not the correct way to do this. In case the
simulation leads to negative diagonal elements in $OMEGA and
$SIGMA, those values are truncated at zero. This method is only
valid for simulation of '$THETA' variability. The method accepts a
table of parameter values that can be produced with other tools
than 'NMsim'. For simulation with parameter variability based on
bootstrap results, use <code>NMsim_default</code>.
</p>
</li>
<li> <p><code>NMsim_typical</code> Deprecated. Use <code>typical=TRUE</code> instead. 
</p>
</li></ul>



<h3>Value</h3>

<p>A data.frame with simulation results (same number of rows
as input data). If 'sge=TRUE' a character vector with paths to
simulation control streams.
</p>

<hr>
<h2 id='NMsim_asis'>Simulation method that uses the provided control stream as is</h2><span id='topic+NMsim_asis'></span>

<h3>Description</h3>

<p>The simplest of all method. It does nothing (but again,
<code>NMsim</code> handles '$INPUT', '$DATA', '$TABLE' and more. Use
this for instance if you already created a simulation (or
estimation actually) control stream and want NMsim to run it on
different data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_asis(file.sim, file.mod, data.sim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_asis_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_asis_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_asis_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to simulation control stream
</p>

<hr>
<h2 id='NMsim_default'>Transform an estimated Nonmem model into a simulation control
stream</h2><span id='topic+NMsim_default'></span>

<h3>Description</h3>

<p>The default behaviour of <code>NMsim</code>. Replaces any $ESTIMATION
and $COVARIANCE sections by a $SIMULATION section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_default(
  file.sim,
  file.mod,
  data.sim,
  nsims = 1,
  onlysim = TRUE,
  replace.sim = TRUE,
  return.text = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_default_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_nsims">nsims</code></td>
<td>
<p>Number of replications wanted. The default is 1. If
greater, multiple control streams will be generated.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_onlysim">onlysim</code></td>
<td>
<p>Include 'ONLYSIM' in '$SIMULATION'? Default is
'TRUE'. Only applied when 'replace.sim='TRUE'.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_replace.sim">replace.sim</code></td>
<td>
<p>If there is a $SIMULATION section in the
contents of file.sim, should it be replaced? Default is
yes. See the <code>list.section</code> argument to <code>NMsim</code> for
how to provide custom contents to sections with <code>NMsim</code>
instead of editing the control streams beforehand.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_return.text">return.text</code></td>
<td>
<p>If TRUE, just the text will be returned, and
resulting control stream is not written to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of simulation control stream paths
</p>

<hr>
<h2 id='NMsim_EBE'>Use emperical Bayes estimates to simulate re-using ETAs</h2><span id='topic+NMsim_EBE'></span>

<h3>Description</h3>

<p>Simulation reusing ETA values from
estimation run or otherwise specified ETA values. For observed subjects, this is refered to as emperical Bayes
estimates (EBE). The .phi file from the estimation run must be found
next to the .lst file from the estimation.This means that ID
values in the (simulation) input data must be ID values that were
used in the estimation too. Runs an <code>$ESTIMATION MAXEVAL=0</code>
but pulls in ETAs for the ID's found in data. No
<code>$SIMULATION</code> step is run which may affect how for instance
residual variability is simulated, if at all. You can also specify a different <code>.phi</code> file which can be a simulation result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_EBE(file.sim, file.mod, data.sim, file.phi, return.text = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_EBE_+3A_file.sim">file.sim</code></td>
<td>
<p>The path to the control stream to be edited. This function overwrites the contents of the file pointed to by file.sim.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to the path to the original input control stream provided as 'file.mod' to 'NMsim()'.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_file.phi">file.phi</code></td>
<td>
<p>A phi file to take the known subjects from. The
default is to replace the filename extension on file.mod with
.phi. A different .phi file would be used if you want to reuse
subjects simulated in a previous simulation.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_return.text">return.text</code></td>
<td>
<p>If TRUE, just the text will be returned, and
resulting control stream is not written to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to simulation control stream
</p>


<h3>See Also</h3>

<p>simPopEtas
</p>

<hr>
<h2 id='NMsim_known'>NMsim_known is an old name for NMsim_EBE()</h2><span id='topic+NMsim_known'></span>

<h3>Description</h3>

<p>NMsim_known is an old name for NMsim_EBE()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_known(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_known_+3A_...">...</code></td>
<td>
<p>Everything passed to NMsim_EBE()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to simulation control stream
</p>

<hr>
<h2 id='NMsim_NWPRI'>Simulate with parameter variability using the NONMEM NWPRI subroutine</h2><span id='topic+NMsim_NWPRI'></span>

<h3>Description</h3>

<p>Modify control stream for simulation with uncertainty
using inverse-Wishart distribution for OMEGA and SIGMA
parameters
</p>
<p>This function does not run any simulations. To simulate, using
this method, see 'NMsim()'. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_NWPRI(file.sim, file.mod, data.sim, PLEV = 0.999, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_NWPRI_+3A_file.sim">file.sim</code></td>
<td>
<p>The path to the control stream to be edited. This function overwrites the contents of the file pointed to by file.sim.</p>
</td></tr>
<tr><td><code id="NMsim_NWPRI_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to the path to the original input control stream provided as 'file.mod' to 'NMsim()'.</p>
</td></tr>
<tr><td><code id="NMsim_NWPRI_+3A_data.sim">data.sim</code></td>
<td>
<p>Included for compatibility with 'NMsim()'. Not used.</p>
</td></tr>
<tr><td><code id="NMsim_NWPRI_+3A_plev">PLEV</code></td>
<td>
<p>Used in <code>$PRIOR NWPRI PLEV=0.999</code>. This is a 
NONMEM argument to the NWPRI subroutine. When PLEV &lt; 1, a 
value of THETA will actually be obtained using a truncated 
multivariate normal distribution, i.e. from an ellipsoidal 
region R1 over which  only  a fraction of mass of the 
normal occurs. This fraction is given by PLEV.</p>
</td></tr>
<tr><td><code id="NMsim_NWPRI_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'NMsim_default()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate with parameter uncertainty. THETA parameters are
sampled from a multivariate normal distribution while OMEGA
and SIGMA are simulated from the inverse-Wishart
distribution. Correlations of OMEGA and SIGMA parameters will
only be applied within modeled &quot;blocks&quot;.
</p>


<h3>Value</h3>

<p>Path to simulation control stream
</p>


<h3>Author(s)</h3>

<p>Brian Reilly, Philip Delff
</p>


<h3>References</h3>

<p><a href="https://ascpt.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2Fpsp4.12422&amp;file=psp412422-sup-0001-Supinfo1.pdf">inverse-Wishart degrees of freedom calculation for OMEGA and SIGMA: NONMEM tutorial part II, supplement 1, part C.</a>
</p>


<h3>See Also</h3>

<p>NMsim_VarCov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simres &lt;- NMsim(file.path,method.sim=NMsim_WPRI,typical=TRUE,subproblems=500)

## End(Not run)
</code></pre>

<hr>
<h2 id='NMsim_typical'>Typical subject simiulation method</h2><span id='topic+NMsim_typical'></span>

<h3>Description</h3>

<p>Like <code>NMsim_default</code> but with all ETAs=0, giving a
&quot;typical subject&quot; simulation. Do not confuse this with a
&quot;reference subject&quot; simulation which has to do with covariate
values. Technically all ETAs=0 is obtained by replacing
<code>$OMEGA</code> by a zero matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_typical(file.sim, file.mod, data.sim, return.text = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_typical_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_typical_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_typical_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_typical_+3A_return.text">return.text</code></td>
<td>
<p>If TRUE, just the text will be returned, and
resulting control stream is not written to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to simulation control stream
</p>

<hr>
<h2 id='NMsim_VarCov'>Simulate with parameter values sampled from a covariance step</h2><span id='topic+NMsim_VarCov'></span>

<h3>Description</h3>

<p>Like <code>NMsim_default</code> but '$THETA', '$OMEGA', and 'SIGMA' are
drawn from distribution estimated in covariance step. A successful
covariance step must be available from the estimation. In case the
simulation leads to negative diagonal elements in $OMEGA and
$SIGMA, those values are truncated at zero. For simulation with
parameter variability based on bootstrap results, use
<code>NMsim_default</code>.
</p>
<p>This function does not run any simulations. To simulate, using
this method, see 'NMsim()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_VarCov(file.sim, file.mod, data.sim, nsims, ext, write.ext = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsim_VarCov_+3A_file.sim">file.sim</code></td>
<td>
<p>The path to the control stream to be edited. This
function overwrites the contents of the file pointed to by
file.sim.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to the path to the original input control
stream provided as 'file.mod' to 'NMsim()'.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_data.sim">data.sim</code></td>
<td>
<p>Included for compatibility with 'NMsim()'. Not
used.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_nsims">nsims</code></td>
<td>
<p>Number of replications wanted. The default is 1. If
greater, multiple control streams will be generated.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_ext">ext</code></td>
<td>
<p>Parameter values in long format as created by
'readParsWide' and 'NMdata::NMreadExt'.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_write.ext">write.ext</code></td>
<td>
<p>If supplied, a path to an rds file where the
parameter values used for simulation will be saved.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'NMsim_default()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of simulation control stream paths
</p>

<hr>
<h2 id='NMsimCheckMod'>Check a simulation control streams for things that can cause trouble in NMsim</h2><span id='topic+NMsimCheckMod'></span>

<h3>Description</h3>

<p>Check a simulation control streams for things that can cause trouble in NMsim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsimCheckMod(file.mod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsimCheckMod_+3A_file.mod">file.mod</code></td>
<td>
<p>A control stream to check</p>
</td></tr>
</table>

<hr>
<h2 id='NMsimTestConf'>Summarize and test NMsim configuration</h2><span id='topic+NMsimTestConf'></span>

<h3>Description</h3>

<p>Summarize and test NMsim configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsimTestConf(
  path.nonmem,
  dir.psn,
  method.execute,
  must.work = FALSE,
  system.type
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMsimTestConf_+3A_path.nonmem">path.nonmem</code></td>
<td>
<p>See ?NMsim</p>
</td></tr>
<tr><td><code id="NMsimTestConf_+3A_dir.psn">dir.psn</code></td>
<td>
<p>See ?NMsim</p>
</td></tr>
<tr><td><code id="NMsimTestConf_+3A_method.execute">method.execute</code></td>
<td>
<p>See ?NMsim</p>
</td></tr>
<tr><td><code id="NMsimTestConf_+3A_must.work">must.work</code></td>
<td>
<p>Throw an error if the configuration does not seem
to match system.</p>
</td></tr>
<tr><td><code id="NMsimTestConf_+3A_system.type">system.type</code></td>
<td>
<p>See ?NMsim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with configuration values
</p>

<hr>
<h2 id='NMupdateInits'>Create new Nonmem control stream with updated initial parameter values</h2><span id='topic+NMupdateInits'></span>

<h3>Description</h3>

<p>Create new Nonmem control stream with updated initial parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMupdateInits(file.mod, file.ext, newfile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMupdateInits_+3A_file.mod">file.mod</code></td>
<td>
<p>The control stream to update. Will not be edited.</p>
</td></tr>
<tr><td><code id="NMupdateInits_+3A_file.ext">file.ext</code></td>
<td>
<p>Path to ext file. Default is to replace extension on 'file.mod'.</p>
</td></tr>
<tr><td><code id="NMupdateInits_+3A_newfile">newfile</code></td>
<td>
<p>New file to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting control stream path(s)
</p>

<hr>
<h2 id='NMupdateSizes'>Create or update $SIZES in a control stream</h2><span id='topic+NMupdateSizes'></span>

<h3>Description</h3>

<p>Update $SIZES parameters in a control stream. The control stream
can be in a file or provided as a character vector (file lines).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMupdateSizes(
  file.mod = NULL,
  newfile,
  lines = NULL,
  wipe = FALSE,
  write = !is.null(newfile),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMupdateSizes_+3A_file.mod">file.mod</code></td>
<td>
<p>A path to a control stream. See also alternative
'lines' argument. Notice, if 'write' is 'TRUE' (default) and
'newfile' is not provided, 'file.mod' will be overwritten.</p>
</td></tr>
<tr><td><code id="NMupdateSizes_+3A_newfile">newfile</code></td>
<td>
<p>An optional path to write the resulting control
stream to. If nothing is provided, the default is to overwrite
'file.mod'.</p>
</td></tr>
<tr><td><code id="NMupdateSizes_+3A_lines">lines</code></td>
<td>
<p>Control stream lines as a character vector. If you
already read the control stream - say using
'NMdata::NMreadSection()', use this to modify the text lines.</p>
</td></tr>
<tr><td><code id="NMupdateSizes_+3A_wipe">wipe</code></td>
<td>
<p>The default behavior ('wipe=FALSE') is to add the
'$SIZES' values to any existing values found. If SIZES
parameter names are overlapping with existing, the values will
be updated. If 'wipe=TRUE', any existing '$SIZES' section is
disregarded.</p>
</td></tr>
<tr><td><code id="NMupdateSizes_+3A_write">write</code></td>
<td>
<p>Write results to 'newfile'?</p>
</td></tr>
<tr><td><code id="NMupdateSizes_+3A_...">...</code></td>
<td>
<p>The $SIZES parameters. Provided anything, like 'PD=40'
See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character lines with updated control stream
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## No existing SIZES in control stream
## Not run: 
file.mod &lt;- system.file("examples/nonmem/xgxr032.mod",package="NMsim")
NMupdateSizes(file.mod,LTV=50,write=FALSE)

## End(Not run)
## This controls stream has existing SIZES
## Not run: 
file.mod &lt;- system.file("examples/nonmem/xgxr134.mod",package="NMsim")
NMupdateSizes(file.mod,LTV=50,write=FALSE)

## End(Not run)
## provide control stream as text lines
## Not run: 
file.mod &lt;- system.file("examples/nonmem/xgxr032.mod",package="NMsim")
lines &lt;- readLines(file.mod)
NMupdateSizes(lines=lines,LTV=50,write=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='NMwriteInits'>Writes a parameter values to a control stream</h2><span id='topic+NMwriteInits'></span>

<h3>Description</h3>

<p>Edit parameter values, fix/unfix them, or edit lower/upper bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMwriteInits(
  file.mod,
  update = TRUE,
  file.ext = NULL,
  ext,
  values,
  newfile,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMwriteInits_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to control stream.</p>
</td></tr>
<tr><td><code id="NMwriteInits_+3A_update">update</code></td>
<td>
<p>If 'TRUE' (default), the parameter values are
updated based on the '.ext' file.</p>
</td></tr>
<tr><td><code id="NMwriteInits_+3A_file.ext">file.ext</code></td>
<td>
<p>Optionally provide the path to an '.ext' file. If
not provided, the default is to replace the file name
extention on 'file.mod' with '.ext'. This is only used if
'update=TRUE'.</p>
</td></tr>
<tr><td><code id="NMwriteInits_+3A_values">values</code></td>
<td>
<p>A list of lists. Each list specifies a parameter
with named elements. Must be named by the parameter name. ll,
ul and fix can be supplied to modify the parameter. See
examples. Notice, you can use '...' instead. 'values' may be easier for programming but other than that, most users will find '...' more intuitive.</p>
</td></tr>
<tr><td><code id="NMwriteInits_+3A_newfile">newfile</code></td>
<td>
<p>If provided, the results are written to this file
as a new input control stream.</p>
</td></tr>
<tr><td><code id="NMwriteInits_+3A_...">...</code></td>
<td>
<p>Parameter specifications. See examples,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a control stream as lines in a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Requires NMdata 0.1.9
## Not run: 
file.mod &lt;- system.file("examples/nonmem/xgxr021.mod",package="NMsim") 
NMwriteInits(file.mod,
values=list( "theta(2)"=list(init=1.4),
             "THETA(3)"=list(FIX=1),
             "omega(2,2)"=list(init=0.1))
)
NMwriteInits(file.mod,
  "theta(2)"=list(init=1.4),
  "THETA(3)"=list(FIX=1),
  "omega(2,2)"=list(init=0.1)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='NWPRI_df'>Add degrees of freedom by OMEGA/SIGMA block</h2><span id='topic+NWPRI_df'></span>

<h3>Description</h3>

<p>Calculate and add degrees of freedom to be used for simulation
using the inverse Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NWPRI_df(pars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NWPRI_df_+3A_pars">pars</code></td>
<td>
<p>Parameters in long format, as returned by
'NMreadExt()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The degrees of freedom are calculated as DF =
2*((est**2)/(se**2)) + 1 -blocksize-1 DF2 is then adjusted to
not be greater than the blocksize, and the minumum degrees of
freedom observed in the block is applied to the full
block. For fixed parameters, DF2 equals the blocksize.
</p>


<h3>Value</h3>

<p>A data.table with DF2 added. See details.
</p>


<h3>References</h3>

<p><a href="https://ascpt.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2Fpsp4.12422&amp;file=psp412422-sup-0001-Supinfo1.pdf">inverse-Wishart degrees of freedom calculation for OMEGA and SIGMA: NONMEM tutorial part II, supplement 1, part C.</a>
</p>


<h3>See Also</h3>

<p>NMsim_NWPRI
</p>

<hr>
<h2 id='overwrite'>Create function that modifies text elements in a vector</h2><span id='topic+overwrite'></span>

<h3>Description</h3>

<p>Create function that modifies text elements in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overwrite(..., fixed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overwrite_+3A_...">...</code></td>
<td>
<p>Passed to 'gsub()'</p>
</td></tr>
<tr><td><code id="overwrite_+3A_fixed">fixed</code></td>
<td>
<p>This is passed to gsub(), but &lsquo;overwrite()'&rsquo;s default behavior is the opposite of the one of 'gsub()'. Default is 'FALSE' which means that strings that are exactly matched will be replaced. This is useful because strings like 'THETA(1)' contains special characters. Use 'fixed=FALSE' to use regular expressions. Also, see other arguments accepted by 'gsub()' for advanced features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that runs 'gsub' to character vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myfun &lt;- overwrite("b","d")
myfun(c("a","b","c","abc"))
## regular expressions
myfun2 &lt;- overwrite("b.*","d",fixed=FALSE)
myfun2(c("a","b","c","abc"))
</code></pre>

<hr>
<h2 id='padZeros'>pad zeros on integers</h2><span id='topic+padZeros'></span>

<h3>Description</h3>

<p>pad zeros on integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padZeros(x, nchars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padZeros_+3A_x">x</code></td>
<td>
<p>integers to pad. They can be coded as characters already.</p>
</td></tr>
<tr><td><code id="padZeros_+3A_nchars">nchars</code></td>
<td>
<p>Optional specification of length of character
strings to return. If not supplied, characters will be padded
to match length of max value in x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='pasteFuns'>Paste string to start of vector only</h2><span id='topic+pasteFuns'></span><span id='topic+pasteBegin'></span><span id='topic+pasteEnd'></span>

<h3>Description</h3>

<p>paste(str,x) will prepend str to all values of x. use pasteBegin
to only paste it to the first value of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pasteBegin(x, add, ...)

pasteEnd(x, add, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pasteFuns_+3A_x">x</code></td>
<td>
<p>A vector of strings</p>
</td></tr>
<tr><td><code id="pasteFuns_+3A_add">add</code></td>
<td>
<p>A string to add</p>
</td></tr>
<tr><td><code id="pasteFuns_+3A_...">...</code></td>
<td>
<p>Aditional arguments to 'paste()'.</p>
</td></tr>
</table>

<hr>
<h2 id='prettyMatLines'>Print OMEGA and SIGMA matrices for NONMEM sections in block format.
Note: This function currently only works with fixed blocks as in 
the NMsim_NWPRI functionality for printing $THETAPV.</h2><span id='topic+prettyMatLines'></span>

<h3>Description</h3>

<p>Print OMEGA and SIGMA matrices for NONMEM sections in block format.
Note: This function currently only works with fixed blocks as in 
the NMsim_NWPRI functionality for printing $THETAPV.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettyMatLines(block_mat_string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prettyMatLines_+3A_block_mat_string">block_mat_string</code></td>
<td>
<p>Output of NMsim::NMcreateMatLines. This is
a string of OMEGA/SIGMA estimates that will be wrapped onto
multiple lines for ease of reading in NONMEM control streams.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently not used by any functions in
NMsim and is for now deprecated. NMcreateMatLines() handles
this internally.
</p>


<h3>Value</h3>

<p>Character vector
</p>

<hr>
<h2 id='readParsWide'>Parameter data from csv</h2><span id='topic+readParsWide'></span>

<h3>Description</h3>

<p>Reads output table from simpar and returns a long format
data.table. This is the same format as returned by NMreadExt()
which can be used by NMsim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readParsWide(
  data,
  col.model = NULL,
  strings.par.type = c(THETA = "^T.*", OMEGA = "^O.*", SIGMA = "^S."),
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readParsWide_+3A_data">data</code></td>
<td>
<p>A data.frame or a path to a delimited file to be read
using 'data.table::fread'.</p>
</td></tr>
<tr><td><code id="readParsWide_+3A_col.model">col.model</code></td>
<td>
<p>Name of the model counter, default is &quot;model&quot;. If
the provided name is not found in data, it will be created as
a row counter. Why needed? Each row in data represents a set
of parameters, i.e. a model. In the long format result, each
model will have multiple rows. Hence, a model identifier is
needed to distinguish between models in results.</p>
</td></tr>
<tr><td><code id="readParsWide_+3A_strings.par.type">strings.par.type</code></td>
<td>
<p>Defines how column names get associated
with THETA, OMEGA, and SIGMA. Default is to look for &quot;T&quot;, &quot;O&quot;,
or &quot;S&quot; as starting letter. If customizing, make sure each no
column name will be matched by more than one criterion.</p>
</td></tr>
<tr><td><code id="readParsWide_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say <code>tibble::as_tibble</code>) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The wide data format read by 'readParsWide' is not a Nonmem
format. It is used to bridge output from other tools such as
simpar, and potentially PSN. 
</p>
<p>This function reads a data that is &quot;wide&quot; in parameters - it has a
column for each parameter, and one row per parameter set or
&quot;model&quot;. It returns a data set that is &quot;long&quot; in model and
parameters. The long format contains
</p>

<ul>
<li><p> id.model.par The unique model-parameter identifier. The row-identifier.
</p>
</li>
<li><p> model Model identifier. 
</p>
</li>
<li><p> par.type (&quot;THETA&quot;, &quot;OMEGA&quot;, &quot;SIGMA&quot;)
</p>
</li>
<li><p> i and j indexes for the parameters (j is NA for par.type==&quot;THETA&quot;).
</p>
</li>
<li><p> value The parameter value 
</p>
</li>
<li><p> parameter Nonmem-style parameter names. THETA1, OMEGA(1,1) etc. Notice the inconsistent naming of THETA vs others.
</p>
</li>
<li><p> name.wide The column name in the wide data where this value was taken
</p>
</li></ul>

<p>The columns or &quot;measure variables&quot; from which to read values  are
specified as three regular expressions, called THETA, OMEGA, and SIGMA. The default three regular expressions will associate a column name starting with &quot;T&quot; with THETAs, while &quot;O&quot; or &quot;S&quot; followed by anything means &quot;OMEGA&quot; or &quot;SIGMA&quot;.
</p>
<p>readParsWide extracts i and j indexes from sequences of digits in the column names. TH.1 would be TETA1, SG1.1 is SIGMA(1,1).
</p>


<h3>Value</h3>

<p>a long-format data.frame of model parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tab.ext &lt;- readParsCsv("simpartab.csv")
## or
tab.simpar &lt;- fread("simpartab.csv")
tab.ext &lt;- readParsCsv(tab.simpar)
NMsim(...,method.sim=NMsim_VarCov,tab.ext=tab.ext)

## End(Not run)
</code></pre>

<hr>
<h2 id='sampleParsSimpar'>Sample model parameters using the 'simpar' package</h2><span id='topic+sampleParsSimpar'></span>

<h3>Description</h3>

<p>Sample model parameters using the 'simpar' package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleParsSimpar(file.mod, nsim, format = "ext", seed.R, as.fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleParsSimpar_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to model control stream. Will be used for
both 'NMreadExt()' and 'NMreadCov()', and extension will
automatically be replaced by '.ext' and '.cov'.</p>
</td></tr>
<tr><td><code id="sampleParsSimpar_+3A_nsim">nsim</code></td>
<td>
<p>Number of sets of parameter values to generate. Passed
to 'simpar'.</p>
</td></tr>
<tr><td><code id="sampleParsSimpar_+3A_format">format</code></td>
<td>
<p>&quot;ext&quot; (default) or &quot;wide&quot;.</p>
</td></tr>
<tr><td><code id="sampleParsSimpar_+3A_seed.r">seed.R</code></td>
<td>
<p>seed value passed to set.seed().</p>
</td></tr>
<tr><td><code id="sampleParsSimpar_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with sampled model parameters
</p>


<h3>Author(s)</h3>

<p>Sanaya Shroff, Philip Delff
</p>

<hr>
<h2 id='simpleCharArg'>Check that a variable is a single character string meeting specified requirements</h2><span id='topic+simpleCharArg'></span>

<h3>Description</h3>

<p>Check that a variable is a single character string meeting specified requirements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleCharArg(name.arg, val.arg, default, accepted, lower = TRUE, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleCharArg_+3A_name.arg">name.arg</code></td>
<td>
<p>Name of the argument</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_val.arg">val.arg</code></td>
<td>
<p>argument value</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_default">default</code></td>
<td>
<p>If val.arg is NULL, what should be returned?</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_accepted">accepted</code></td>
<td>
<p>What values are allowed</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_lower">lower</code></td>
<td>
<p>run tolower?</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_clean">clean</code></td>
<td>
<p>clean white spaces?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Better options may be available in packages like
checkmate. This function doesn't only check the parameter
value, it also sets it to the default value if missing.
</p>


<h3>Value</h3>

<p>The resulting parameter value
</p>

<hr>
<h2 id='simPopEtas'>Generate a population based on a Nonmem model</h2><span id='topic+simPopEtas'></span>

<h3>Description</h3>

<p>Generate a population based on a Nonmem model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPopEtas(file, N, seed.R, pars, file.phi, as.fun, file.mod, seed, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simPopEtas_+3A_file">file</code></td>
<td>
<p>Passed to 'NMdata::NMreadExt()'. Path to ext file. By
default, 'NMreadExt()' uses a'auto.ext=TRUE' which means that
the file name extension is replaced by '.ext'. If your ext
file name extension is not '.ext', add 'auto.ext=FALSE' (see
...).</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_n">N</code></td>
<td>
<p>Number of subjects to generate</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_seed.r">seed.R</code></td>
<td>
<p>Optional seed. Will be passed to 'set.seed'. Same
thing as running 'set.seed' just before calling
'simPopEtas()'.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_pars">pars</code></td>
<td>
<p>A long-format parameter table containing par.type and
i columns. If this is supplied, the parameter values will not
be read from an ext file, and file has no effect. If an ext
file is available, it is most likely better to use the file
argument.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_file.phi">file.phi</code></td>
<td>
<p>An optional phi file to write the generated
subjects to.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_file.mod">file.mod</code></td>
<td>
<p>Deprecated. Use file instead.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_seed">seed</code></td>
<td>
<p>Deprecated. Use seed.R instead.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to NMdata::NMreadExt().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>

<hr>
<h2 id='summarizeCovs'>Summarize simulated exposures relative to reference subject</h2><span id='topic+summarizeCovs'></span>

<h3>Description</h3>

<p>Summarize simulated exposures relative to reference subject
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeCovs(data, funs.exposure, cols.value, cover.ci = 0.95, by, as.fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizeCovs_+3A_data">data</code></td>
<td>
<p>Simulated data to process. This data.frame must
contain must contain multiple columns, as defined by
NMsim::expandCovs().</p>
</td></tr>
<tr><td><code id="summarizeCovs_+3A_funs.exposure">funs.exposure</code></td>
<td>
<p>A named list of functions to apply for
derivation of exposure metrics.</p>
</td></tr>
<tr><td><code id="summarizeCovs_+3A_cols.value">cols.value</code></td>
<td>
<p>The default is to run exposure metrics based on
the 'PRED' column. Specify another or multiple columns to run
the analysis on.</p>
</td></tr>
<tr><td><code id="summarizeCovs_+3A_cover.ci">cover.ci</code></td>
<td>
<p>The coverage of the confidence intervals. Default
is 0.95.</p>
</td></tr>
<tr><td><code id="summarizeCovs_+3A_by">by</code></td>
<td>
<p>a character vector of names columns to perform all
calculations by. This could be sampling subsets or analyte.</p>
</td></tr>
<tr><td><code id="summarizeCovs_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a
'data.frame'. Pass a function (say 'tibble::as_tibble') in
as.fun to convert to something else. If data.tables are
wanted, use 'as.fun=&quot;data.table&quot;'. The default can be
configured using 'NMdataConf()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These columns are expected to be present, and differences within any of them will lead to separate summarizing (say for a s covariate value to be plotted):
cc(model,type,pred.type,covvar,covlabel,covref,covval)
</p>


<h3>Value</h3>

<p>A data.frame
</p>

<hr>
<h2 id='triagSize'>Calculate number of elements for matrix specification</h2><span id='topic+triagSize'></span>

<h3>Description</h3>

<p>calculate number of elements in the diagonal and lower triangle of
a matrix, based on the length of the diagonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triagSize(diagSize)
</code></pre>

<hr>
<h2 id='unNMsimModTab'>Remove NMsimModTab class and discard NMsimModTab meta data</h2><span id='topic+unNMsimModTab'></span><span id='topic+is.NMsimModTab'></span><span id='topic+NMsimModTabOperations'></span><span id='topic+merge.NMsimModTab'></span><span id='topic+t.NMsimModTab'></span><span id='topic+dimnames.NMsimModTab'></span><span id='topic+rbind.NMsimModTab'></span><span id='topic+cbind.NMsimModTab'></span>

<h3>Description</h3>

<p>Remove NMsimModTab class and discard NMsimModTab meta data
</p>
<p>Check if an object is 'NMsimModTab'
</p>
<p>Basic arithmetic on NMsimModTab objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unNMsimModTab(x)

is.NMsimModTab(x)

## S3 method for class 'NMsimModTab'
merge(x, ...)

## S3 method for class 'NMsimModTab'
t(x, ...)

## S3 method for class 'NMsimModTab'
dimnames(x, ...)

## S3 method for class 'NMsimModTab'
rbind(x, ...)

## S3 method for class 'NMsimModTab'
cbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unNMsimModTab_+3A_x">x</code></td>
<td>
<p>an NMsimModTab object</p>
</td></tr>
<tr><td><code id="unNMsimModTab_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When 'dimnames', 'merge', 'cbind', 'rbind', or 't' is
called on an 'NMsimModTab' object, the 'NMsimModTab' class is dropped,
and then the operation is performed. So if and 'NMsimModTab' object
inherits from 'data.frame' and no other classes (which is
default), these operations will be performed using the
'data.frame' methods. But for example, if you use 'as.fun' to
get a 'data.table' or 'tbl', their respective methods are used
instead.
</p>


<h3>Value</h3>

<p>x stripped from the 'NMsimModTab' class
</p>
<p>logical if x is an 'NMsimModTab' object
</p>
<p>An object that is not of class 'NMsimModTab'.
</p>

<hr>
<h2 id='unNMsimRes'>Remove NMsimRes class and discard NMsimRes meta data</h2><span id='topic+unNMsimRes'></span><span id='topic+is.NMsimRes'></span><span id='topic+NMsimResOperations'></span><span id='topic+merge.NMsimRes'></span><span id='topic+t.NMsimRes'></span><span id='topic+dimnames.NMsimRes'></span><span id='topic+rbind.NMsimRes'></span><span id='topic+cbind.NMsimRes'></span>

<h3>Description</h3>

<p>Remove NMsimRes class and discard NMsimRes meta data
</p>
<p>Check if an object is 'NMsimRes'
</p>
<p>Basic arithmetic on NMsimRes objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unNMsimRes(x)

is.NMsimRes(x)

## S3 method for class 'NMsimRes'
merge(x, ...)

## S3 method for class 'NMsimRes'
t(x, ...)

## S3 method for class 'NMsimRes'
dimnames(x, ...)

## S3 method for class 'NMsimRes'
rbind(x, ...)

## S3 method for class 'NMsimRes'
cbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unNMsimRes_+3A_x">x</code></td>
<td>
<p>an NMsimRes object</p>
</td></tr>
<tr><td><code id="unNMsimRes_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When 'dimnames', 'merge', 'cbind', 'rbind', or 't' is
called on an 'NMsimRes' object, the 'NMsimRes' class is dropped,
and then the operation is performed. So if and 'NMsimRes' object
inherits from 'data.frame' and no other classes (which is
default), these operations will be performed using the
'data.frame' methods. But for example, if you use 'as.fun' to
get a 'data.table' or 'tbl', their respective methods are used
instead.
</p>


<h3>Value</h3>

<p>x stripped from the 'NMsimRes' class
</p>
<p>logical if x is an 'NMsimRes' object
</p>
<p>An object that is not of class 'NMsimRes'.
</p>

<hr>
<h2 id='writeTextFile'>Conveniently writeLines to file</h2><span id='topic+writeTextFile'></span>

<h3>Description</h3>

<p>Conveniently writeLines to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeTextFile(lines, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeTextFile_+3A_lines">lines</code></td>
<td>
<p>the character lines to write</p>
</td></tr>
<tr><td><code id="writeTextFile_+3A_file">file</code></td>
<td>
<p>The file name path to write to</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
