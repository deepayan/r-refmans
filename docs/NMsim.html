<!DOCTYPE html><html><head><title>Help for package NMsim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NMsim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addEVID2'><p>Add simulation records to dosing records</p></a></li>
<li><a href='#addResVar'><p>Add residual variability based on parameter estimates</p></a></li>
<li><a href='#callNonmemDirect'><p>Generate system command to call Nonmem directly</p></a></li>
<li><a href='#checkTimes'><p>Test if file modification times indicate that Nonmem models should</p>
be re-run</a></li>
<li><a href='#cleanStrings'><p>Drop spaces and odd characters</p></a></li>
<li><a href='#dt2mat'><p>Convert a data.table of parameter estimates to a matrix</p></a></li>
<li><a href='#dtapply'><p>Apply function and return a data.table</p></a></li>
<li><a href='#findUpdated'><p>Filter control streams to only those updated since last run</p></a></li>
<li><a href='#genPhiFile'><p>Generate a .phi file for further simulation with Nonmem</p></a></li>
<li><a href='#inputArchiveDefault'><p>Default location of input archive file</p></a></li>
<li><a href='#NMcreateDoses'><p>Easily generate dosing records</p></a></li>
<li><a href='#NMcreateMatLines'><p>Create text lines for OMEGA and SIGMA Nonmem sections</p></a></li>
<li><a href='#NMexec'><p>Execute Nonmem and archive input data with model files</p></a></li>
<li><a href='#NMexecDirectory'><p>Execute Nonmem inside a dedicated directory</p></a></li>
<li><a href='#NMgenPNM'><p>Generate PNM file for sge clusters</p></a></li>
<li><a href='#NMreadSim'><p>Read simulation results based on NMsim's track of model runs</p></a></li>
<li><a href='#NMreadSimModTab'><p>Read simulation results from rds objects and/or NMsimModTab objects</p></a></li>
<li><a href='#NMreadSimModTabOne'><p>Read simulation results from an rds or a NMsimModTab object</p></a></li>
<li><a href='#NMreadSimRes'><p>Read simulation results from data.frames or fst files</p></a></li>
<li><a href='#NMreadSimResOne'><p>read one sim element. This will be run in lapply in NMreadSim.</p></a></li>
<li><a href='#NMreplaceInits'><p>Replace initial values in Nonmem control stream</p></a></li>
<li><a href='#NMseed'><p>Add seed string to simulation model data.table</p></a></li>
<li><a href='#NMsim'><p>Simulate from an estimated Nonmem model</p></a></li>
<li><a href='#NMsim_asis'><p>Simulation method that uses the provided control stream as is</p></a></li>
<li><a href='#NMsim_default'><p>Transform an estimated Nonmem model into a simulation control</p>
stream</a></li>
<li><a href='#NMsim_EBE'><p>Use emperical Bayes estimates to simulate re-using ETAs</p></a></li>
<li><a href='#NMsim_known'><p>NMsim_known is an old name for NMsim_EBE()</p></a></li>
<li><a href='#NMsim_typical'><p>Typical subject simiulation method</p></a></li>
<li><a href='#NMsim_VarCov'><p>Simulate with parameter values sampled from a covariance step</p></a></li>
<li><a href='#NMsimCheckMod'><p>Check a simulation control streams for things that can cause trouble in NMsim</p></a></li>
<li><a href='#NMupdateInits'><p>Create new Nonmem control stream with updated initial parameter values</p></a></li>
<li><a href='#padZeros'><p>pad zeros on integers</p></a></li>
<li><a href='#readParsWide'><p>Parameter data from csv</p></a></li>
<li><a href='#simpleCharArg'><p>Check that a variable is a single character string meeting specified requirements</p></a></li>
<li><a href='#simPopEtas'><p>Generate a population based on a Nonmem model</p></a></li>
<li><a href='#unNMsimModTab'><p>Remove NMsimModTab class and discard NMsimModTab meta data</p></a></li>
<li><a href='#unNMsimRes'><p>Remove NMsimRes class and discard NMsimRes meta data</p></a></li>
<li><a href='#writeTextFile'><p>Conveniently writeLines to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Seamless 'Nonmem' Simulation Platform</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Delff &lt;philip@delff.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A complete and seamless 'Nonmem' simulation interface from within R. Turns 'Nonmem' control streams into simulation control streams, executes them with specified simulation input data and returns the results. The simulation is performed by 'Nonmem', eliminating time spent and risks of re-implementation of models in other tools.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, NMdata (&ge; 0.1.5), R.utils, MASS, fst, xfun</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, ggplot2, patchwork, tracee,
tidyvpc</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/philipdelff/NMsim/issues">https://github.com/philipdelff/NMsim/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://philipdelff.github.io/NMsim/">https://philipdelff.github.io/NMsim/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-03 11:47:24 UTC; philipde</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Delff [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-03 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addEVID2'>Add simulation records to dosing records</h2><span id='topic+addEVID2'></span>

<h3>Description</h3>

<p>Performs the simple job of adding simulation events to all
subjects in a data set. Copies over columns that are not varying
at subject level (i.e. non-variying covariates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEVID2(doses, time.sim, CMT, EVID = 2, as.fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addEVID2_+3A_doses">doses</code></td>
<td>
<p>dosing records Nonmem style (EVID==1 records from a
data set)</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_time.sim">time.sim</code></td>
<td>
<p>A numerical vector with simulation times. Can also
be a data.frame in which case it must contain a 'TIME' column
and is merged with subjects found in 'doses'. The latter
feature is experimental.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_cmt">CMT</code></td>
<td>
<p>The compartment in which to insert the EVID=2
records. If longer than one, the records will be repeated in
all the specified compartments. If a data.frame, covariates
can be specified.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_evid">EVID</code></td>
<td>
<p>The value to put in the EVID column for the created
rows. Default is 2 but 0 may be prefered even for simulation.</p>
</td></tr>
<tr><td><code id="addEVID2_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting data set is ordered by ID, TIME, and
EVID. You may have to reorder for your specific needs.
</p>


<h3>Value</h3>

<p>A data.frame with dosing records
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(doses1 &lt;- NMcreateDoses(TIME=c(0,12,24,36),AMT=c(2,1)))
addEVID2(doses1,time.sim=seq(0,28,by=4),CMT=2)

## two named compartments
dt.doses &lt;- NMcreateDoses(TIME=c(0,12),AMT=10,CMT=1)
seq.time &lt;- c(0,4,12,24)
dt.cmt &lt;- data.frame(CMT=c(2,3),analyte=c("parent","metabolite"))
res &lt;- addEVID2(dt.doses,time.sim=seq.time,CMT=dt.cmt)

## Separate sampling schemes depending on covariate values
dt.doses &lt;- NMcreateDoses(TIME=data.frame(regimen=c("SD","MD","MD"),TIME=c(0,0,12)),AMT=10,CMT=1)

seq.time.sd &lt;- data.frame(regimen="SD",TIME=seq(0,6))
seq.time.md &lt;- data.frame(regimen="MD",TIME=c(0,4,12,24))
seq.time &lt;- rbind(seq.time.sd,seq.time.md)
addEVID2(dt.doses,time.sim=seq.time,CMT=2)

## an observed sample scheme and additional simulation times
df.doses &lt;- NMcreateDoses(TIME=0,AMT=50,addl=list(ADDL=2,II=24))
dense &lt;- c(seq(1,3,by=.1),4:6,seq(8,12,by=4),18,24)
trough &lt;- seq(0,3*24,by=24)
sim.extra &lt;- seq(0,(24*3),by=2)
time.all &lt;- c(dense,dense+24*3,trough,sim.extra)
time.all &lt;- sort(unique(time.all))
dt.sample &lt;- data.frame(TIME=time.all)
dt.sample$isobs &lt;- as.numeric(dt.sample$TIME%in%c(dense,trough))
dat.sim &lt;- addEVID2(dt.doses,time.sim=dt.sample,CMT=2)

</code></pre>

<hr>
<h2 id='addResVar'>Add residual variability based on parameter estimates</h2><span id='topic+addResVar'></span>

<h3>Description</h3>

<p>Add residual variability based on parameter estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addResVar(
  data,
  path.ext,
  prop = NULL,
  add = NULL,
  log = FALSE,
  par.type = "SIGMA",
  trunc0 = TRUE,
  scale.par,
  subset,
  seed,
  col.ipred = "IPRED",
  col.ipredvar = "IPREDVAR",
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addResVar_+3A_data">data</code></td>
<td>
<p>A data set containing indiviudual predictions. Often a
result of NMsim.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_path.ext">path.ext</code></td>
<td>
<p>Path to the ext file to take the parameter
estimates from.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_prop">prop</code></td>
<td>
<p>Parameter number of parameter holding variance of the
proportional error component. If ERR(1) is used for
proportional error, use prop=1. Can also refer to a theta
number.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_add">add</code></td>
<td>
<p>Parameter number of parameter holding variance of the
additive error component. If ERR(1) is used for additive
error, use add=1. Can also refer to a theta number.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_log">log</code></td>
<td>
<p>Should the error be added on log scale? This is used to
obtain an exponential error distribution.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_par.type">par.type</code></td>
<td>
<p>Use &quot;sigma&quot; if variances are estimated with the
SIGMA matrix. Use &quot;theta&quot; if THETA parameters are used. See
'scale.par' too.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_trunc0">trunc0</code></td>
<td>
<p>If log=FALSE, truncate simulated values at 0? If
trunc0, returned predictions can be negative.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_scale.par">scale.par</code></td>
<td>
<p>Denotes if parmeter represents a variance or a
standard deviation. Allowed values and default value depends
on 'par.type'.  </p>
 <ul>
<li><p> if par.type=&quot;sigma&quot; only &quot;var&quot;
is allowed.  </p>
</li>
<li><p> if par.type=&quot;theta&quot; allowed values are &quot;sd&quot;
and &quot;var&quot;. Default is &quot;sd&quot;.</p>
</li></ul>
</td></tr>
<tr><td><code id="addResVar_+3A_subset">subset</code></td>
<td>
<p>A character string with an expression denoting a
subset in which to add the residual error. Example:
subset=&quot;DVID=='A'&quot;</p>
</td></tr>
<tr><td><code id="addResVar_+3A_seed">seed</code></td>
<td>
<p>A number to pass to set.seed() before
simulating. Default is to generate a seed and report it in the
console. Use seed=FALSE to avoid setting the seed (if you
prefer doing it otherwise).</p>
</td></tr>
<tr><td><code id="addResVar_+3A_col.ipred">col.ipred</code></td>
<td>
<p>The name of the column containing individual
predictions.</p>
</td></tr>
<tr><td><code id="addResVar_+3A_col.ipredvar">col.ipredvar</code></td>
<td>
<p>The name of the column to be created by
addResVar to contain the simulated observations (individual
predictions plus residual error).</p>
</td></tr>
<tr><td><code id="addResVar_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## based on SIGMA
simres.var &lt;- addResVar(data=simres,
                        path.ext = "path/to/model.ext",
                        prop = 1,
                        add = 2,
                        par.type = "SIGMA",
                        log = FALSE)

## If implemented using THETAs
simres.var &lt;- addResVar(data=simres,
                        path.ext = "path/to/model.ext",
                        prop = 8, ## point to elements in THETA
                        add = 9,  ## point to elements in THETA
                        par.type = "THETA",
                        log = FALSE)


## End(Not run)

</code></pre>

<hr>
<h2 id='callNonmemDirect'>Generate system command to call Nonmem directly</h2><span id='topic+callNonmemDirect'></span>

<h3>Description</h3>

<p>Generate system command to call Nonmem directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callNonmemDirect(file.mod, path.nonmem)
</code></pre>

<hr>
<h2 id='checkTimes'>Test if file modification times indicate that Nonmem models should
be re-run</h2><span id='topic+checkTimes'></span>

<h3>Description</h3>

<p>Test if file modification times indicate that Nonmem models should
be re-run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTimes(
  file.lst,
  use.input = TRUE,
  nminfo.input = NULL,
  file.mod,
  tz.lst = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkTimes_+3A_file.lst">file.lst</code></td>
<td>
<p>The output control stream.</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_use.input">use.input</code></td>
<td>
<p>Scan input data for updates too? Default is TRUE.</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_nminfo.input">nminfo.input</code></td>
<td>
<p>If you do want to take into account input data
but avoid re-reading the information, you can pass the NMdata
meta data object.</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_file.mod">file.mod</code></td>
<td>
<p>The input control stream</p>
</td></tr>
<tr><td><code id="checkTimes_+3A_tz.lst">tz.lst</code></td>
<td>
<p>If files are moved around on or between file
systems, the file modification time may not be reflective of
the Nonmem runtime. In that case, you can choose to extract
the time stamp from the output control stream. The issue is
that Nonmem does not write the time zone, so you have to pass
that to checkTimes if this is wanted.</p>
</td></tr>
</table>

<hr>
<h2 id='cleanStrings'>Drop spaces and odd characters</h2><span id='topic+cleanStrings'></span>

<h3>Description</h3>

<p>Drop spaces and odd characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanStrings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanStrings_+3A_x">x</code></td>
<td>
<p>a string to clean</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NMsim:::cleanStrings("e w% # ff!l3:t,3?.csv")
NMsim:::cleanStrings("3!?:#;&lt;&gt;=, {}|=g+&amp;-
.csv")
</code></pre>

<hr>
<h2 id='dt2mat'>Convert a data.table of parameter estimates to a matrix</h2><span id='topic+dt2mat'></span>

<h3>Description</h3>

<p>Often needed when using estimates of Omega or Sigma matrices in
further calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt2mat(pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt2mat_+3A_pars">pars</code></td>
<td>
<p>A data.table with parameters like a subjset of the
parameter list returned by NMreadExt.</p>
</td></tr>
</table>

<hr>
<h2 id='dtapply'>Apply function and return a data.table</h2><span id='topic+dtapply'></span>

<h3>Description</h3>

<p>A convenience function that returns a data.table with a column
representing the input values and a column with results. This is
still experimental and will not work for many input structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtapply(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtapply_+3A_...">...</code></td>
<td>
<p>arguments passed to lapply</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only functions that return vectors are currently
supported. dtapply should support functions that return
data.frames.
</p>


<h3>Value</h3>

<p>a data.table
</p>

<hr>
<h2 id='findUpdated'>Filter control streams to only those updated since last run</h2><span id='topic+findUpdated'></span>

<h3>Description</h3>

<p>Filter control streams to only those updated since last run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findUpdated(mods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findUpdated_+3A_mods">mods</code></td>
<td>
<p>list of (input or output) control streams to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of paths found models
</p>

<hr>
<h2 id='genPhiFile'>Generate a .phi file for further simulation with Nonmem</h2><span id='topic+genPhiFile'></span>

<h3>Description</h3>

<p>This will typically be used in a couple of different
situations. One is if a number of new subjects have been simulated
and their ETAs should be reused in subsequent simulations. Another
is internally by NMsim when simulating new subjects from models
estimated with SAEM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPhiFile(data, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genPhiFile_+3A_data">data</code></td>
<td>
<p>A dataset that contains &quot;ID&quot; and all ETAs. This can be
obtained by 'NMdata::NMscanData'.</p>
</td></tr>
<tr><td><code id="genPhiFile_+3A_file">file</code></td>
<td>
<p>Path to the .phi file to be written.</p>
</td></tr>
</table>

<hr>
<h2 id='inputArchiveDefault'>Default location of input archive file</h2><span id='topic+inputArchiveDefault'></span>

<h3>Description</h3>

<p>Default location of input archive file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputArchiveDefault(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputArchiveDefault_+3A_file">file</code></td>
<td>
<p>Path to input or output control stream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A file name (character)
</p>

<hr>
<h2 id='NMcreateDoses'>Easily generate dosing records</h2><span id='topic+NMcreateDoses'></span>

<h3>Description</h3>

<p>Combinations of different columns can be generated. Columns will
be extended by repeating last value of the column if needed in
order to match length of other columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcreateDoses(
  TIME,
  AMT = NULL,
  RATE = NULL,
  SS = NULL,
  CMT = 1,
  EVID = 1,
  addl = NULL,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMcreateDoses_+3A_time">TIME</code></td>
<td>
<p>The time of the dosing events</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_amt">AMT</code></td>
<td>
<p>vector or dataa.frame with amounts amount</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_rate">RATE</code></td>
<td>
<p>Optional infusion rate</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_ss">SS</code></td>
<td>
<p>Optional steady-state flag</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_cmt">CMT</code></td>
<td>
<p>Compartment number. Default is to dose into CMT=1.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_evid">EVID</code></td>
<td>
<p>The event ID to use for doses. Default is to use
EVID=1, but EVID might also be wanted.</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_addl">addl</code></td>
<td>
<p>Optinal. A list of ADDL and II that will be applied to
last dose</p>
</td></tr>
<tr><td><code id="NMcreateDoses_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental. Please check output before use. AMT, RATE,
SS, II, CMT are vectors of length 1 or longer. Those not of
max length 1 are repeated.  If TIME is longer than those, they
are extended to match length of TIME. Allowed combinations of
AMT, RATE, SS, II here:
<a href="https://ascpt.onlinelibrary.wiley.com/doi/10.1002/psp4.12404">https://ascpt.onlinelibrary.wiley.com/doi/10.1002/psp4.12404</a>
</p>


<h3>Value</h3>

<p>A data.frame with dosing events
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
## Users should not use setDTthreads. This is for CRAN to only use 1 core.
data.table::setDTthreads(1) 
## arguments are expanded - makes loading easy
NMcreateDoses(TIME=c(0,12,24,36),AMT=c(2,1))
## Different doses by covariate
NMcreateDoses(TIME=c(0,12,24),AMT=data.table(AMT=c(2,1,4,2),DOSE=c(1,2)))
## Make Nonmem repeat the last dose. This is a total of 20 dosing events.
NMcreateDoses(TIME=c(0,12),AMT=c(2,1),addl=list(ADDL=c(NA,9*2),II=c(NA,12)))
dt.amt &lt;- data.table(DOSE=c(100,400))
dt.amt[,AMT:=DOSE*1000]
dt.amt
doses.sd &lt;- NMcreateDoses(TIME=0,AMT=dt.amt)
doses.sd$dose &lt;- paste(doses.sd$DOSE,"mg")
doses.sd$regimen &lt;- "SD"
doses.sd

### multiple dose regimens with loading are easily created with NMcreateDoses too
## Specifying the time points explicitly
dt.amt &lt;- data.table(AMT=c(200,100,800,400)*1000,DOSE=c(100,100,400,400))
doses.md.1 &lt;- NMcreateDoses(TIME=seq(0,by=24,length.out=7),AMT=dt.amt)
doses.md.1$dose &lt;- paste(doses.md.1$DOSE,"mg")
doses.md.1$regimen &lt;- "QD"
doses.md.1
## or using ADDL+II
dt.amt &lt;- data.table(AMT=c(200,100,800,400)*1000,DOSE=c(100,100,400,400))
doses.md.2 &lt;- NMcreateDoses(TIME=c(0,24),AMT=dt.amt,addl=data.table(ADDL=c(0,5),II=c(0,24)))
doses.md.2$dose &lt;- paste(doses.md.2$DOSE,"mg")
doses.md.2$regimen &lt;- "QD"
doses.md.2
</code></pre>

<hr>
<h2 id='NMcreateMatLines'>Create text lines for OMEGA and SIGMA Nonmem sections</h2><span id='topic+NMcreateMatLines'></span>

<h3>Description</h3>

<p>Create text lines for OMEGA and SIGMA Nonmem sections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcreateMatLines(omegas, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMcreateMatLines_+3A_omegas">omegas</code></td>
<td>
<p>See NMdata::NMreadExt and the pars element returned by that
function.</p>
</td></tr>
<tr><td><code id="NMcreateMatLines_+3A_type">type</code></td>
<td>
<p>The matrix type. OMEGA or SIGMA - case in-sensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>

<hr>
<h2 id='NMexec'>Execute Nonmem and archive input data with model files</h2><span id='topic+NMexec'></span>

<h3>Description</h3>

<p>Execute Nonmem from within R - optionally but by default in
parallel. Archiving the input data ensures that postprocessing can
still be reproduced if the input data files should be updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMexec(
  files,
  file.pattern,
  dir,
  sge = TRUE,
  input.archive,
  nc = 64,
  dir.data = NULL,
  wait = FALSE,
  args.psn.execute,
  update.only = FALSE,
  nmquiet = FALSE,
  method.execute = "psn",
  dir.psn,
  path.nonmem,
  system.type,
  files.needed,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMexec_+3A_files">files</code></td>
<td>
<p>File paths to the models (control streams) to run
nonmem on. See file.pattern too.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_file.pattern">file.pattern</code></td>
<td>
<p>Alternatively to files, you can supply a
regular expression which will be passed to list.files as the
pattern argument. If this is used, use dir argument as
well. Also see data.file to only process models that use a
specific data file.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_dir">dir</code></td>
<td>
<p>If file.pattern is used, dir is the directory to search
for control streams in.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_sge">sge</code></td>
<td>
<p>Use the sge queing system. Default is TRUE. Disable for
quick models not to wait for the queue to run the job.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_input.archive">input.archive</code></td>
<td>
<p>A function of the model file path to generate
the path in which to archive the input data as RDS. Set to
NULL not to archive the data.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_nc">nc</code></td>
<td>
<p>Number of cores to use if sending to the cluster. This
will only be used if <code>method.execute="psn"</code>, and
<code>sge=TRUE</code>. Default is 64.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_dir.data">dir.data</code></td>
<td>
<p>The directory in which the data file is
stored. This is normally not needed as data will be found
using the path in the control stream. This argument may be
removed in the future since it should not be needed.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_wait">wait</code></td>
<td>
<p>Wait for process to finish before making R console
available again? This is useful if calling NMexec from a
function that needs to wait for the output of the Nonmem run
to be available for further processing.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_args.psn.execute">args.psn.execute</code></td>
<td>
<p>A character string with arguments passed
to execute. Default is
&quot;-model_dir_name -nm_output=xml,ext,cov,cor,coi,phi,shk&quot;.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_update.only">update.only</code></td>
<td>
<p>Only run model(s) if control stream or data
updated since last run?</p>
</td></tr>
<tr><td><code id="NMexec_+3A_nmquiet">nmquiet</code></td>
<td>
<p>Suppress terminal output from 'Nonmem'. This is
likely to only work on linux/unix systems.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_method.execute">method.execute</code></td>
<td>
<p>How to run Nonmem. Must be one of 'psn',
'nmsim', or 'direct'. 
</p>

<ul>
<li><p> psn PSN's execute is used. This supports parallel Nonmem
runs. Use the <code>nc</code> argument to control how many cores to use
for each job. For estimation runs, this is most likely the better
choice, if you have PSN installed. See <code>dir.psn</code> argument
too.
</p>
</li>
<li><p> nmsim Creates a temporary directory and runs Nonmem
inside that directory before copying relevant results files back
to the folder where the input control stream was. If
<code>sge=TRUE</code>, the job will be submitted to a cluster, but
parallel execution of the job itself is not supported. See
<code>path.nonmem</code> argument too.
</p>
</li>
<li><p> direct Nonmem is called directly on the control stream. This
is the simplest method and is the least convenient in most
cases. It does not offer parallel runs and leaves all the Nonmem
output files next to the control streams.
</p>
</li></ul>

<p>See 'sge' as well.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_dir.psn">dir.psn</code></td>
<td>
<p>The directory in which to find PSN
executables. This is only needed if these are not searchable
in the system path, or if the user should want to be explicit
about where to find them (i.e. want to use a specific
installed version of PSN).</p>
</td></tr>
<tr><td><code id="NMexec_+3A_path.nonmem">path.nonmem</code></td>
<td>
<p>The path to the nonmem executable. Only used if
<code>method.execute="direct"</code> or
<code>method.execute="nmsim"</code> (which is not default). If this
argument is not supplied, NMexec will try to run nmfe75,
i.e. this has to be available in the path of the underlying
shell. The default value can be modified using
<code>NMdata::NMdataConf</code>, like
<code>NMdataConf(path.nonmem="/path/to/nonmem")</code></p>
</td></tr>
<tr><td><code id="NMexec_+3A_system.type">system.type</code></td>
<td>
<p>A charachter string, either \&quot;windows\&quot; or
\&quot;linux\&quot; - case insensitive. Windows is only experimentally
supported. Default is to use <code>Sys.info()[["sysname"]]</code>.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_files.needed">files.needed</code></td>
<td>
<p>In case method.execute=&quot;nmsim&quot;, this argument
specifies files to be copied into the temporary directory
before Nonmem is run. Input control stream and simulation
input data does not need to be specified.</p>
</td></tr>
<tr><td><code id="NMexec_+3A_quiet">quiet</code></td>
<td>
<p>Suppress messages on what NMexec is doing? Default is
FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this to read the archived input data when retrieving
the nonmem results:
<code>NMdataConf(file.data=inputArchiveDefault)</code>
</p>
<p>Since 'NMexec' will typically not be used for simulations directly
('NMsim' is the natural interface for that purpose), the default
method for 'NMexec' is currently to use 'method.execute=&quot;psn&quot;'
which is at this point the only of the methods that allow for
multi-core execution of a single Nonmem job (NB:
'method.execute=&quot;NMsim&quot;' can run multiple jobs in parallel which
is normally sufficient for simulations).
</p>


<h3>Value</h3>

<p>NULL (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file.mod &lt;- "run001.mod"
## Not run: 
## run locally - not on cluster
NMexec(file.mod,sge=FALSE)
## run on cluster with 16 cores. 64 cores is default
NMexec(file.mod,nc=16)
## submit multiple models to cluster
multiple.models &lt;- c("run001.mod","run002.mod")
NMexec(multiple.models,nc=16)
## run all models called run001.mod - run099.mod if updated. 64 cores to each.
NMexec(file.pattern="run0..\\.mod",dir="models",nc=16,update.only=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='NMexecDirectory'>Execute Nonmem inside a dedicated directory</h2><span id='topic+NMexecDirectory'></span>

<h3>Description</h3>

<p>Like PSN's execute with less features. But easier to control from
NMexec. NMexecDirectory is not intended to be run by the user. Use
<code>NMexec</code> or <code>NMsim</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMexecDirectory(
  file.mod,
  path.nonmem,
  files.needed,
  dir.data = "..",
  system.type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMexecDirectory_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to a Nonmem input control stream.</p>
</td></tr>
<tr><td><code id="NMexecDirectory_+3A_path.nonmem">path.nonmem</code></td>
<td>
<p>Path to Nonmem executable. You may want to
control this with <code>NMdata::NMdataConf</code>.</p>
</td></tr>
<tr><td><code id="NMexecDirectory_+3A_files.needed">files.needed</code></td>
<td>
<p>Files needed to run the control stream. This
cold be a .phi file from which etas will be read. Notice,
input data set will be handled automatically, you do not need
to specify that.</p>
</td></tr>
<tr><td><code id="NMexecDirectory_+3A_dir.data">dir.data</code></td>
<td>
<p>If NULL, data will be copied into the temporary
directory, and Nonmem will read it from there. If not NULL,
dir.data must be the relative path from where Nonmem is run to
where the input data file is stored. This would be &quot;..&quot; if the
run directory is created in a directory where the data is
stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bash shell script for execution of Nonmem
</p>

<hr>
<h2 id='NMgenPNM'>Generate PNM file for sge clusters</h2><span id='topic+NMgenPNM'></span>

<h3>Description</h3>

<p>Generate PNM file for sge clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMgenPNM(nc, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMgenPNM_+3A_nc">nc</code></td>
<td>
<p>number of cores wanted</p>
</td></tr>
<tr><td><code id="NMgenPNM_+3A_file">file</code></td>
<td>
<p>The file path to write the result to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file path (character string)
</p>

<hr>
<h2 id='NMreadSim'>Read simulation results based on NMsim's track of model runs</h2><span id='topic+NMreadSim'></span>

<h3>Description</h3>

<p>Read simulation results based on NMsim's track of model runs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSim(
  x,
  check.time = FALSE,
  dir.sims,
  wait = FALSE,
  quiet = FALSE,
  progress,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadSim_+3A_x">x</code></td>
<td>
<p>Path to the simulation-specific rds file generated by
NMsim, typically called 'NMsim_MetaData.rds'. Can also be a table
of simulation runs as stored in 'rds' files by 'NMsim'. The
latter should almost never be used.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_check.time">check.time</code></td>
<td>
<p>If found, check whether 'fst' file modification
time is newer than 'rds' file. The 'fst' is generated based on
information in &lsquo;rds', but notice that some systems don&rsquo;t
preserve the file modification times. Becasue of that,
'check.time' is 'FALSE' by default.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_dir.sims">dir.sims</code></td>
<td>
<p>By default, 'NMreadSim' will use information about
the relative path from the results table file ('_MetaData.rds')
to the Nonmem simulation results. If these paths have changed,
or for other reasons this doesn't work, you can use the
'dir.sims' argument to specify where to find the Nonmem
simulation results. If an '.fst' file was already generated
and is found next to the '_MetaData.rds', the path to the Nonmem
simulation results is not used.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_wait">wait</code></td>
<td>
<p>If simulations seem to not be done yet, wait for them
to finish? If not, an error will be thrown. If you choose to
wait, the risk is results never come. 'NMreadSim' will be
waiting for an 'lst' file. If Nonmem fails, it will normally
generate an 'lst' file. But if 'NMTRAN' fails (checks of
control stream prior to running Nonmem), the 'lst' file is not
generated.  Default is not to wait.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_quiet">quiet</code></td>
<td>
<p>Turn off some messages about what is going on?
Default is to report the messages.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being read. The progress
tracking is based on the number of models completed/read, not
the status of the individual models.</p>
</td></tr>
<tr><td><code id="NMreadSim_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data set of class defined by as.fun
</p>

<hr>
<h2 id='NMreadSimModTab'>Read simulation results from rds objects and/or NMsimModTab objects</h2><span id='topic+NMreadSimModTab'></span>

<h3>Description</h3>

<p>Read simulation results from rds objects and/or NMsimModTab objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimModTab(
  x,
  check.time = FALSE,
  dir.sims,
  wait = FALSE,
  skip.missing = FALSE,
  quiet = FALSE,
  progress,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadSimModTab_+3A_x">x</code></td>
<td>
<p>Path to the simulation-specific rds file generated by
NMsim, typically called 'NMsim_MetaData.rds'. Can also be a table
of simulation runs as stored in 'rds' files by 'NMsim'. The
latter should almost never be used.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_check.time">check.time</code></td>
<td>
<p>If found, check whether 'fst' file modification
time is newer than 'rds' file. The 'fst' is generated based on
information in &lsquo;rds', but notice that some systems don&rsquo;t
preserve the file modification times. Becasue of that,
'check.time' is 'FALSE' by default.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_dir.sims">dir.sims</code></td>
<td>
<p>By default, 'NMreadSim' will use information about
the relative path from the results table file ('_MetaData.rds')
to the Nonmem simulation results. If these paths have changed,
or for other reasons this doesn't work, you can use the
'dir.sims' argument to specify where to find the Nonmem
simulation results. If an '.fst' file was already generated
and is found next to the '_MetaData.rds', the path to the Nonmem
simulation results is not used.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_wait">wait</code></td>
<td>
<p>If simulations seem to not be done yet, wait for them
to finish? If not, an error will be thrown. If you choose to
wait, the risk is results never come. 'NMreadSim' will be
waiting for an 'lst' file. If Nonmem fails, it will normally
generate an 'lst' file. But if 'NMTRAN' fails (checks of
control stream prior to running Nonmem), the 'lst' file is not
generated.  Default is not to wait.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_quiet">quiet</code></td>
<td>
<p>Turn off some messages about what is going on?
Default is to report the messages.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being simulated. The progress
tracking is based on the number of models completed, not the
status of the individual models.</p>
</td></tr>
<tr><td><code id="NMreadSimModTab_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>

<hr>
<h2 id='NMreadSimModTabOne'>Read simulation results from an rds or a NMsimModTab object</h2><span id='topic+NMreadSimModTabOne'></span>

<h3>Description</h3>

<p>Read simulation results from an rds or a NMsimModTab object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimModTabOne(
  modtab,
  check.time = FALSE,
  dir.sims,
  wait = FALSE,
  quiet = FALSE,
  skip.missing = FALSE,
  progress,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadSimModTabOne_+3A_check.time">check.time</code></td>
<td>
<p>If found, check whether 'fst' file modification
time is newer than 'rds' file. The 'fst' is generated based on
information in &lsquo;rds', but notice that some systems don&rsquo;t
preserve the file modification times. Becasue of that,
'check.time' is 'FALSE' by default.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_dir.sims">dir.sims</code></td>
<td>
<p>By default, 'NMreadSim' will use information about
the relative path from the results table file ('_MetaData.rds')
to the Nonmem simulation results. If these paths have changed,
or for other reasons this doesn't work, you can use the
'dir.sims' argument to specify where to find the Nonmem
simulation results. If an '.fst' file was already generated
and is found next to the '_MetaData.rds', the path to the Nonmem
simulation results is not used.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_wait">wait</code></td>
<td>
<p>If simulations seem to not be done yet, wait for them
to finish? If not, an error will be thrown. If you choose to
wait, the risk is results never come. 'NMreadSim' will be
waiting for an 'lst' file. If Nonmem fails, it will normally
generate an 'lst' file. But if 'NMTRAN' fails (checks of
control stream prior to running Nonmem), the 'lst' file is not
generated.  Default is not to wait.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_quiet">quiet</code></td>
<td>
<p>Turn off some messages about what is going on?
Default is to report the messages.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being read. The progress
tracking is based on the number of models completed/read, not
the status of the individual models.</p>
</td></tr>
<tr><td><code id="NMreadSimModTabOne_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>

<hr>
<h2 id='NMreadSimRes'>Read simulation results from data.frames or fst files</h2><span id='topic+NMreadSimRes'></span>

<h3>Description</h3>

<p>Read simulation results from data.frames or fst files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimRes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadSimRes_+3A_x">x</code></td>
<td>
<p>a data set or a fst file</p>
</td></tr>
</table>

<hr>
<h2 id='NMreadSimResOne'>read one sim element. This will be run in lapply in NMreadSim.</h2><span id='topic+NMreadSimResOne'></span>

<h3>Description</h3>

<p>read one sim element. This will be run in lapply in NMreadSim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSimResOne(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadSimResOne_+3A_x">x</code></td>
<td>
<p>A path to an fst file or a data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>

<hr>
<h2 id='NMreplaceInits'>Replace initial values in Nonmem control stream</h2><span id='topic+NMreplaceInits'></span>

<h3>Description</h3>

<p>Replace initial values in Nonmem control stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreplaceInits(inits, fix = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreplaceInits_+3A_inits">inits</code></td>
<td>
<p>A data.frame with new initial estimates, same style
as returned by NMdata::NMreadExt. Column' par.type' can contain
elements THETA, OMEGA, SIGMA.</p>
</td></tr>
<tr><td><code id="NMreplaceInits_+3A_fix">fix</code></td>
<td>
<p>Fix the initial values? Default is not to.</p>
</td></tr>
<tr><td><code id="NMreplaceInits_+3A_...">...</code></td>
<td>
<p>Passed to NMdata::NMwriteSection. This is important for
NMreplaceInits to run at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified control stream
</p>

<hr>
<h2 id='NMseed'>Add seed string to simulation model data.table</h2><span id='topic+NMseed'></span>

<h3>Description</h3>

<p>This is an internal NMsim function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMseed(models, nseeds, dist, values, fun.seed = seedFunDefault)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMseed_+3A_models">models</code></td>
<td>
<p>A data.frame containing model paths etc as created
by <code>NMsim()</code>.</p>
</td></tr>
<tr><td><code id="NMseed_+3A_nseeds">nseeds</code></td>
<td>
<p>Number of seeds in each simulation control
stream. Default is to match length of dist.</p>
</td></tr>
<tr><td><code id="NMseed_+3A_dist">dist</code></td>
<td>
<p>Distribution of random sources. These character
strings will be pasted directly into the Nonem control streams
after the seed values. Default is &quot;&quot; which means one normal
distribution. <code>dist=c("","UNIFORM")</code> will give two seeds
with random sources following a normal and a uniform
distribution.</p>
</td></tr>
<tr><td><code id="NMseed_+3A_values">values</code></td>
<td>
<p>Optionally, seed values. This can be a data.frame
with as many columns as random sources.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data.table with simulation model information
including seed strings.
</p>

<hr>
<h2 id='NMsim'>Simulate from an estimated Nonmem model</h2><span id='topic+NMsim'></span>

<h3>Description</h3>

<p>Supply a data set and an estimation input control stream, and
NMsim can create neccesary files (control stream, data files), run
the simulation and read the results. It has additional methods for
other simulation types available, can do multiple simulations at
once and more. Please see vignettes for an introduction to how to
get the most out of this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim(
  file.mod,
  data,
  dir.sims,
  name.sim,
  order.columns = TRUE,
  file.ext = NULL,
  script = NULL,
  subproblems = NULL,
  reuse.results = FALSE,
  seed.R,
  seed.nm,
  args.psn.execute,
  table.vars,
  table.options,
  text.sim = "",
  method.sim = NMsim_default,
  typical = FALSE,
  execute = TRUE,
  sge = FALSE,
  nc = 1,
  transform = NULL,
  method.execute,
  method.update.inits,
  create.dirs = TRUE,
  dir.psn,
  modify.model,
  sim.dir.from.scratch = TRUE,
  col.row,
  args.NMscanData,
  path.nonmem = NULL,
  nmquiet = TRUE,
  progress,
  as.fun,
  suffix.sim,
  text.table,
  system.type = NULL,
  dir.res,
  file.res,
  wait,
  auto.dv = TRUE,
  quiet = FALSE,
  check.mod = TRUE,
  seed,
  list.sections,
  format.data.complete = "rds",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsim_+3A_file.mod">file.mod</code></td>
<td>
<p>Path(s) to the input control stream(s) to run the
simulation on. The output control stream is for now assumed to
be stored next to the input control stream and ending in .lst
instead of .mod. The .ext file must also be present. If
simulating known subjects, the .phi is necessary too.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_data">data</code></td>
<td>
<p>The simulation data as a <code>data.frame</code> or a list
of <code>data.frame</code>s. If a list, the model(s) will be run on
each of the data sets in the list.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_dir.sims">dir.sims</code></td>
<td>
<p>The directory in which NMsim will store all
generated files. Default is to create a folder called 'NMsim'
next to 'file.mod'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_name.sim">name.sim</code></td>
<td>
<p>Give all filenames related to the simulation a
suffix. A short string describing the sim is recommended like
&quot;ph3_regimens&quot;.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_order.columns">order.columns</code></td>
<td>
<p>reorder columns by calling
<code>NMdata::NMorderColumns</code> before saving dataset and
running simulations? Default is TRUE.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_file.ext">file.ext</code></td>
<td>
<p>Optionally provide a parameter estimate file from
Nonmem. This is normally not needed since 'NMsim' will by
default use the ext file stored next to the input control
stream (replacing the file name extension with '.ext'). If
using method.update.inits=&quot;psn&quot;, this argument cannot be
used. If you want provide parameters to be used for the
simulation, look at the 'ext' argument to 'NMsim_VarCov'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_script">script</code></td>
<td>
<p>The path to the script where this is run. For
stamping of dataset so results can be traced back to code.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_subproblems">subproblems</code></td>
<td>
<p>Number of subproblems to use as
<code>SUBPROBLEMS</code> in <code>$SIMULATION</code> block in Nonmem. The
default is subproblem=0 which means not to use
<code>SUBPROBLEMS</code>.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_reuse.results">reuse.results</code></td>
<td>
<p>If simulation results found on file, should
they be used? If TRUE and reading the results fail, the
simulations will still be rerun.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_seed.r">seed.R</code></td>
<td>
<p>A value passed to <code>set.seed()</code>. It may be
better use <code>seed.R</code> rather than calling <code>set.seed()</code>
manually because the seed can then be captured and stored by
<code>NMsim()</code> for reproducibility. See <code>seed.nm</code> for
finer control of the seeds that are used in the Nonmem control
streams.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_seed.nm">seed.nm</code></td>
<td>
<p>Control Nonmem seeds. If a numeric, a vector or a
'data.frame', these are used as the the seed values (a single
value or vector will be recycled so make sure the dimesnsions
are right, the number of columns in a <code>data.frame</code> will
dictate the number of seeds in each Nonmem control stream. Use
a list with elements 'values', and 'dist' and others for
detailed control of the random sources. See <code>?NMseed</code> for
details on what arguments can be passed this way.
</p>
<p>Default is to draw seeds betwen
0 and 2147483647 (the values supported by Nonmem) for each
simulation. You can pass a function that will be evaluated
(say to choose a different pool of seeds to draw from).
</p>
<p>To avoid changing an exisiting seed in a control stream, use
<code>seed.nm="asis"</code>.
</p>
<p>In case <code>method.sim=NMsim_EBE</code>, seeds are not used.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_args.psn.execute">args.psn.execute</code></td>
<td>
<p>A charachter string that will be passed as
arguments PSN's 'execute'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_table.vars">table.vars</code></td>
<td>
<p>Variables to be printed in output table as a
character vector or a space-separated string of variable
names. The default is to export the same tables as listed in
the input control stream. If <code>table.vars</code> is provided,
all output tables in estimation control streams are dropped
and replaced by a new one with just the provided variables. If
many variables are exported, and much fewer are used, it can
speed up NMsim significantly to only export what is needed
(sometimes this is as little as &quot;PRED IPRED&quot;). Nonmem writes
data slowly so reducing output data can make a big difference
in execution time. See <code>table.options</code> too.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_table.options">table.options</code></td>
<td>
<p>A character vector or a string of
space-separated options. Only used if <code>table.vars</code> is
provided. If constructing a new output table with
<code>table.vars</code> the default is to add two options,
<code>NOAPPEND</code> and <code>NOPRINT</code>. You can modeify that with
<code>table.options</code>. Do not try to modify output filename -
<code>NMsim</code> takes care of that.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_text.sim">text.sim</code></td>
<td>
<p>A character string to be pasted into
$SIMULATION. This must not contain seed or SUBPROBLEM which
are handled separately. Default is to include &quot;ONLYSIM&quot;. To
avoid that, use text.sim=&quot;&quot;.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_method.sim">method.sim</code></td>
<td>
<p>A function (not quoted) that creates the
simulation control stream and other necessary files for a
simulation based on the estimation control stream, the data,
etc. The default is called <code>NMsim_default</code> which will
replace any estimation and covariance step by a simulation
step. See details section on oter methods, and see examples
and especially vignettes on how to use the different provided
methods.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_typical">typical</code></td>
<td>
<p>Run with all ETAs fixed to zero? Technically all ETAs=0 is obtained by replacing
<code>$OMEGA</code> by a zero matrix. Default is FALSE.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_execute">execute</code></td>
<td>
<p>Execute the simulation or only prepare it?
'execute=FALSE' can be useful if you want to do additional
tweaks or simulate using other parameter estimates.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_sge">sge</code></td>
<td>
<p>Submit to cluster? Default is not to, but this is very
useful if creating a large number of simulations,
e.g. simulate with all parameter estimates from a bootstrap
result.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_nc">nc</code></td>
<td>
<p>Number of cores used in parallelization. This is so far
only supported with <code>method.execute="psn"</code>.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_transform">transform</code></td>
<td>
<p>A list defining transformations to be applied
after the Nonmem simulations and before plotting. For each
list element, its name refers to the name of the column to
transform, the contents must be the function to apply.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_method.execute">method.execute</code></td>
<td>
<p>Specify how to call Nonmem. Options are
&quot;psn&quot; (PSN's execute), &quot;nmsim&quot; (an internal method similar to
PSN's execute), and &quot;direct&quot; (just run Nonmem directly and
dump all the temporary files). &quot;nmsim&quot; has advantages over
&quot;psn&quot; that makes it the only supported method when
type.sim=&quot;NMsim_EBE&quot;. &quot;psn&quot; has the simple advantage that
the path to nonmem does not have to be specified if &quot;execute&quot;
is in the system search path. So as long as you know where
your Nonmem executable is, &quot;nmsim&quot; is recommended. The default
is &quot;nmsim&quot; if path.nonmem is specified, and &quot;psn&quot; if not.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_method.update.inits">method.update.inits</code></td>
<td>
<p>The initial values of all parameters
are by updated from the estimated model before running the
simulation. NMsim can do this with a native function or use
PSN to do it - or the step can be skipped to not update the
values. The possible values are
</p>

<ul>
<li><p>&quot;psn&quot;
uses PSN's &quot;update_inits&quot;. Requires a functioning PSN
installation and possibly that <code>dir.psn</code> is correctly
set. The advantages of this method are that it keeps comments
in the control stream and that it is a method known to many.
</p>
</li>
<li><p>&quot;nmsim&quot;
Uses a simple internal method to update the parameter values
based on the ext file.  The advantages of &quot;nmsim&quot; are it does not
require PSN, and that it does not rely on code-interpretation for generation of simulation control streams. &quot;nmsim&quot; fixes the whole
OMEGA and SIGMA matrices as single blocks making the $OMEGA and
$SIGMA sections of the control streams less easy to read. On the
other hand, this method is robust because it avoids any
interpretation of BLOCK structure or other code in the control
streams.
</p>
</li>
<li><p>&quot;none&quot; Do nothing. This is useful if the model to simulate
has not been estimated but parameter values have been manually put
into the respective sections in the control stream.
</p>
<p>On linux/mac, The default is to use &quot;PSN&quot; if found. On Windows, &quot;nmsim&quot;
is the default.
</p>
</li></ul>
</td></tr>
<tr><td><code id="NMsim_+3A_create.dirs">create.dirs</code></td>
<td>
<p>If the directories specified in dir.sims and
dir.res do not exists, should it be created? Default is TRUE.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_dir.psn">dir.psn</code></td>
<td>
<p>The directory in which to find PSN's executables
('execute' and 'update_inits'). The default is to rely on the
system's search path. So if you can run 'execute' and
'update_inits' by just typing that in a terminal, you don't
need to specify this unless you want to explicitly use a
specific installation of PSN on your system.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_modify.model">modify.model</code></td>
<td>
<p>Named list of additional control stream
section edits. Note, these can be functions that define how to
edit sections. This is an advanced feature which is not needed
to run most simulations. It is however powerful for some types
of analyses, like modifying parameter values. See vignettes
for further information.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_sim.dir.from.scratch">sim.dir.from.scratch</code></td>
<td>
<p>If TRUE (default) this will wipe the
simulation directory before running new simulations. The
directory that will be emptied is _not_ dir.sims where you may
keep many or all your simulations. It is the subdirectory
named based on the run name and <code>name.sim</code>. The reason it
is advised to wipe this directory is that if you in a previous
simulation created simulation runs that are now obsolete, you
could end up reading those too when collecting the
results. NMsim will delete previously generated simulation
control streams with the same name, but this option goes
further. An example where it is important is if you first ran
1000 replications, fixed something and now rand 500. If you
choose FALSE here, you can end up with the results of 500 new
and 500 old simulations.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_col.row">col.row</code></td>
<td>
<p>Only used if data is not supplied (which is most
likely for simulations for VPCs) A column name to use for a
row identifier. If none is supplied,
<code>NMdataConf()[['col.row']]</code> will be used. If the column
already exists in the data set, it will be used as is, if not
it will be added.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_args.nmscandata">args.NMscanData</code></td>
<td>
<p>If <code>execute=TRUE&amp;sge=FALSE</code>, NMsim
will normally read the results using <code>NMreadSim</code>. Use
this argument to pass additional arguments (in a list) to that
function if you want the results to be read in a specific
way. This can be if the model for some reason drops rows, and
you need to merge by a row identifier. You would do
'args.NMscanData=list(col.row=&quot;ROW&quot;)' to merge by a column
called 'ROW'. This is only used in rare cases.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_path.nonmem">path.nonmem</code></td>
<td>
<p>The path to the Nonmem executable to use. The
could be something like &quot;/usr/local/NONMEM/run/nmfe75&quot; (which
is a made up example). No default is available. You should be
able to figure this out through how you normally execute
Nonmem, or ask a colleague.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_nmquiet">nmquiet</code></td>
<td>
<p>Silent messages from Nonmem. The default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_progress">progress</code></td>
<td>
<p>Track progress? Default is 'TRUE' if 'quiet' is
FALSE and more than one model is being simulated. The progress
tracking is based on the number of models completed, not the
status of the individual models.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_suffix.sim">suffix.sim</code></td>
<td>
<p>Deprecated. Use name.sim instead.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_text.table">text.table</code></td>
<td>
<p>A character string including the variables to
export from Nonmem.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_system.type">system.type</code></td>
<td>
<p>A charachter string, either \&quot;windows\&quot; or
\&quot;linux\&quot; - case insensitive. Windows is only experimentally
supported. Default is to use <code>Sys.info()[["sysname"]]</code>.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_dir.res">dir.res</code></td>
<td>
<p>Provide a path to a directory in which to save rds
files with paths to results. Default is to use dir.sims. After
running 'NMreadSim()' on these files, the original simulation
files can be deleted. Hence, providing both 'dir.sims' and
'dir.res' provides a structure that is simple to
clean. 'dir.sims' can be purged when 'NMreadSim' has been run
and only small 'rds' and 'fst' files will be kept in
'dir.res'. Notice, in case multiple models are simulated,
multiple 'rds' (to be read with 'NMreadSim()') files will be
created by default. In cases where multiple models are
simulated, see 'file.res' to get just one file refering to all
simulation results.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_file.res">file.res</code></td>
<td>
<p>Path to an rds file that will contain a table of
the simulated models and other metadata. This is needed for
subsequently retrieving all the results using
'NMreadSim()'. The default is to create a file called
'NMsim_..._MetaData.rds' under the <code>dir.res</code> directory
where ... is based on the model name. However, if multiple
models (<code>file.mod</code>) are simulated, this will result in
multiple rds files. Specifying a path ensures that one rds
file containing information about all simulated models will be
created. Notice if <code>file.res</code> is supplied, <code>dir.res</code>
is not used.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_wait">wait</code></td>
<td>
<p>Wait for simulations to finish? Default is to do so if
simulations are run locally but not to if they are sent to the
cluster. Waiting for them means that the results will be read
when simulations are done. If not waiting, path(s) to 'rds'
files to read will be returned. Pass them through
'NMreadSim()' (which also supports waiting for the simulations
to finish).</p>
</td></tr>
<tr><td><code id="NMsim_+3A_auto.dv">auto.dv</code></td>
<td>
<p>Add a column called 'DV' to simulation data sets if
a column of that name is not found? Nonmem is generally
dependent on a 'DV' column in input data but this is typically
uninformative in simulation data sets and hence easily
forgotten when generating simulation data sets.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, messages from what is going on will be
suppressed.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_check.mod">check.mod</code></td>
<td>
<p>Check the provided control streams for contents
that may cause issues for simulation. Default is 'TRUE', and
it is only recommended to disable this if you are fully aware
of such a feature of your control stream, you know how it
impacts simulation, and you want to get rid of warnings.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_seed">seed</code></td>
<td>
<p>Deprecated. See <code>seed.R</code> and <code>seed.nm</code>.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_list.sections">list.sections</code></td>
<td>
<p>Deprecated. Use modify.model instead.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_format.data.complete">format.data.complete</code></td>
<td>
<p>For development purposes - users do
not need this argument. Controls what format the complete
input data set is saved in.  Possible values are 'rds'
(default), 'fst' (experimental) and 'csv'. 'fst' may be faster
and use less disk space but factor levels may be lost from
input data to output data. 'csv' will also lead to loss of
additional information such as factor levels.</p>
</td></tr>
<tr><td><code id="NMsim_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>method.sim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loosely speaking, the argument <code>method.sim</code> defines
_what_ NMsim will do, <code>method.execute</code> define _how_ it
does it. <code>method.sim</code> takes a function that converts an
estimation control stream into whatever should be
run. Features like replacing '$INPUT', '$DATA', '$TABLE', and
handling seeds are NMsim features that are done in addition to
the <code>method.sim</code>. Also the <code>modeify.model</code> argument
is handled in addition to the <code>method.sim</code>. The
<code>subproblems</code> and <code>seed</code> arguments are available to
all methods creating a <code>$SIMULATION</code> section.
</p>
<p>Notice, the following functions are internally available to
'NMsim' so you can run them by say <code>method.sim=NMsim_EBE</code>
without quotes. To see the code of that method, type
<code>NMsim_EBE</code>.
</p>

<ul>
<li> <p><code>NMsim_default</code> The default behaviour. Replaces any
$ESTIMATION and $COVARIANCE sections by a $SIMULATION section.
</p>
</li>
<li> <p><code>NMsim_asis</code> The simplest of all method. It does nothing (but
again, <code>NMsim</code> handles '$INPUT', '$DATA', '$TABLE' and
more. Use this for instance if you already created a simulation
(or estimation actually) control stream and want NMsim to run it
on different data sets.
</p>
</li>
<li> <p><code>NMsim_typical</code> Deprecated. Use <code>typical=TRUE</code> instead. 
</p>
</li>
<li> <p><code>NMsim_EBE</code> Simulates _known_ ETAs. By default, the ETA
values are automatically taken from the estimation run. This is
what is refered to as emperical Bayes estimates, hence the name of
the method &quot;NMsim_EBE&quot;. However, the user can also provide a
different '.phi' file which may contain simulated ETA values (see
the 'file.phi' argument). ID values in the simulation data set
must match ID values in the phi file for this step to work. If
refering to estimated subjects, the .phi file from the estimation
run must be found next to the .lst file from the estimation with
the same file name stem (say 'run1.lst' and 'run1.phi'). Again, ID
values in the (simulation) input data must be ID values that were
used in the estimation too. The method Runs an <code>$ESTIMATION
MAXEVAL=0</code> but pulls in ETAs for the ID's found in data. No
<code>$SIMULATION</code> step is run which unfortunately means no
residual error will be simulated.
</p>
</li>
<li> <p><code>NMsim_VarCov</code> Like <code>NMsim_default</code> but '$THETA',
'$OMEGA', and 'SIGMA' are drawn from distribution estimated in
covariance step. This means that a successful covariance step must
be available from the estimation. NB. A multivariate normal
distribution is used for all parameters, including '$OMEGA' and
'$SIGMA' which is not the correct way to do this. In case the
simulation leads to negative diagonal elements in $OMEGA and
$SIGMA, those values are truncated at zero. This method is only
valid for simulation of '$THETA' variability. The method accepts a
table of parameter values that can be produced with other tools
than 'NMsim'. For simulation with parameter variability based on
bootstrap results, use <code>NMsim_default</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A data.frame with simulation results (same number of rows
as input data). If 'sge=TRUE' a character vector with paths to
simulation control streams.
</p>

<hr>
<h2 id='NMsim_asis'>Simulation method that uses the provided control stream as is</h2><span id='topic+NMsim_asis'></span>

<h3>Description</h3>

<p>The simplest of all method. It does nothing (but again,
<code>NMsim</code> handles '$INPUT', '$DATA', '$TABLE' and more. Use
this for instance if you already created a simulation (or
estimation actually) control stream and want NMsim to run it on
different data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_asis(file.sim, file.mod, data.sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsim_asis_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_asis_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_asis_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to simulation control stream
</p>

<hr>
<h2 id='NMsim_default'>Transform an estimated Nonmem model into a simulation control
stream</h2><span id='topic+NMsim_default'></span>

<h3>Description</h3>

<p>The default behaviour of <code>NMsim</code>. Replaces any $ESTIMATION
and $COVARIANCE sections by a $SIMULATION section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_default(
  file.sim,
  file.mod,
  data.sim,
  nsims = 1,
  replace.sim = TRUE,
  return.text = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsim_default_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_nsims">nsims</code></td>
<td>
<p>Number of replications wanted. The default is 1. If
greater, multiple control streams will be generated.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_replace.sim">replace.sim</code></td>
<td>
<p>If there is a $SIMULATION section in the
contents of file.sim, should it be replaced? Default is
yes. See the <code>list.section</code> argument to <code>NMsim</code> for
how to provide custom contents to sections with <code>NMsim</code>
instead of editing the control streams beforehand.</p>
</td></tr>
<tr><td><code id="NMsim_default_+3A_return.text">return.text</code></td>
<td>
<p>If TRUE, just the text will be returned, and
resulting control stream is not written to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of simulation control stream paths
</p>

<hr>
<h2 id='NMsim_EBE'>Use emperical Bayes estimates to simulate re-using ETAs</h2><span id='topic+NMsim_EBE'></span>

<h3>Description</h3>

<p>Simulation reusing ETA values from
estimation run or otherwise specified ETA values. For observed subjects, this is refered to as emperical Bayes
estimates (EBE). The .phi file from the estimation run must be found
next to the .lst file from the estimation.This means that ID
values in the (simulation) input data must be ID values that were
used in the estimation too. Runs an <code>$ESTIMATION MAXEVAL=0</code>
but pulls in ETAs for the ID's found in data. No
<code>$SIMULATION</code> step is run which may affect how for instance
residual variability is simulated, if at all. You can also specify a different <code>.phi</code> file which can be a simulation result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_EBE(file.sim, file.mod, data.sim, file.phi, return.text = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsim_EBE_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_file.phi">file.phi</code></td>
<td>
<p>A phi file to take the known subjects from. The
default is to replace the filename extension on file.mod with
.phi. A different .phi file would be used if you want to reuse
subjects simulated in a previous simulation.</p>
</td></tr>
<tr><td><code id="NMsim_EBE_+3A_return.text">return.text</code></td>
<td>
<p>If TRUE, just the text will be returned, and
resulting control stream is not written to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to simulation control stream
</p>


<h3>See Also</h3>

<p>simPopEtas
</p>

<hr>
<h2 id='NMsim_known'>NMsim_known is an old name for NMsim_EBE()</h2><span id='topic+NMsim_known'></span>

<h3>Description</h3>

<p>NMsim_known is an old name for NMsim_EBE()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_known(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsim_known_+3A_...">...</code></td>
<td>
<p>Everything passed to NMsim_EBE()</p>
</td></tr>
</table>

<hr>
<h2 id='NMsim_typical'>Typical subject simiulation method</h2><span id='topic+NMsim_typical'></span>

<h3>Description</h3>

<p>Like <code>NMsim_default</code> but with all ETAs=0, giving a
&quot;typical subject&quot; simulation. Do not confuse this with a
&quot;reference subject&quot; simulation which has to do with covariate
values. Technically all ETAs=0 is obtained by replacing
<code>$OMEGA</code> by a zero matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_typical(file.sim, file.mod, data.sim, return.text = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsim_typical_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_typical_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_typical_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_typical_+3A_return.text">return.text</code></td>
<td>
<p>If TRUE, just the text will be returned, and
resulting control stream is not written to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to simulation control stream
</p>

<hr>
<h2 id='NMsim_VarCov'>Simulate with parameter values sampled from a covariance step</h2><span id='topic+NMsim_VarCov'></span>

<h3>Description</h3>

<p>Like <code>NMsim_default</code> but '$THETA', '$OMEGA', and 'SIGMA' are
drawn from distribution estimated in covariance step. This means
that a successful covariance step must be available from the
estimation. In case the simulation leads to negative diagonal
elements in $OMEGA and $SIGMA, those values are truncated at
zero. For simulation with parameter variability based on bootstrap
results, use <code>NMsim_default</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsim_VarCov(file.sim, file.mod, data.sim, nsims, ext, write.ext = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsim_VarCov_+3A_file.sim">file.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_file.mod">file.mod</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_data.sim">data.sim</code></td>
<td>
<p>See <code>?NMsim</code>.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_nsims">nsims</code></td>
<td>
<p>Number of replications wanted. The default is 1. If
greater, multiple control streams will be generated.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_ext">ext</code></td>
<td>
<p>Parameter values in long format as created by
'readParsWide' and 'NMdata::NMreadExt'.</p>
</td></tr>
<tr><td><code id="NMsim_VarCov_+3A_write.ext">write.ext</code></td>
<td>
<p>If supplied, a path to an rds file where the
parameter values used for simulation will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of simulation control stream paths
</p>

<hr>
<h2 id='NMsimCheckMod'>Check a simulation control streams for things that can cause trouble in NMsim</h2><span id='topic+NMsimCheckMod'></span>

<h3>Description</h3>

<p>Check a simulation control streams for things that can cause trouble in NMsim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMsimCheckMod(file.mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMsimCheckMod_+3A_file.mod">file.mod</code></td>
<td>
<p>A control stream to check</p>
</td></tr>
</table>

<hr>
<h2 id='NMupdateInits'>Create new Nonmem control stream with updated initial parameter values</h2><span id='topic+NMupdateInits'></span>

<h3>Description</h3>

<p>Create new Nonmem control stream with updated initial parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMupdateInits(file.mod, file.ext, newfile, fix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMupdateInits_+3A_file.mod">file.mod</code></td>
<td>
<p>The control stream to update. Will not be edited.</p>
</td></tr>
<tr><td><code id="NMupdateInits_+3A_file.ext">file.ext</code></td>
<td>
</td></tr>
<tr><td><code id="NMupdateInits_+3A_newfile">newfile</code></td>
<td>
<p>New file to generate</p>
</td></tr>
<tr><td><code id="NMupdateInits_+3A_fix">fix</code></td>
<td>
<p>Fix the values? Probably only TRUE is supported. Passed to <code>NMreplaceInits()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting control stream path(s)
</p>

<hr>
<h2 id='padZeros'>pad zeros on integers</h2><span id='topic+padZeros'></span>

<h3>Description</h3>

<p>pad zeros on integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padZeros(x, nchars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padZeros_+3A_x">x</code></td>
<td>
<p>integers to pad. They can be coded as characters already.</p>
</td></tr>
<tr><td><code id="padZeros_+3A_nchars">nchars</code></td>
<td>
<p>Optional specification of length of character
strings to return. If not supplied, characters will be padded
to match length of max value in x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='readParsWide'>Parameter data from csv</h2><span id='topic+readParsWide'></span>

<h3>Description</h3>

<p>Reads output table from simpar and returns a long format
data.table. This is the same format as returned by NMreadExt()
which can be used by NMsim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readParsWide(
  data,
  col.model = NULL,
  strings.par.type = c(THETA = "^T.*", OMEGA = "^O.*", SIGMA = "^S."),
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readParsWide_+3A_data">data</code></td>
<td>
<p>A data.frame or a path to a delimited file to be read
using 'data.table::fread'.</p>
</td></tr>
<tr><td><code id="readParsWide_+3A_col.model">col.model</code></td>
<td>
<p>Name of the model counter, default is &quot;model&quot;. If
the provided name is not found in data, it will be created as
a row counter. Why needed? Each row in data represents a set
of parameters, i.e. a model. In the long format result, each
model will have multiple rows. Hence, a model identifier is
needed to distinguish between models in results.</p>
</td></tr>
<tr><td><code id="readParsWide_+3A_strings.par.type">strings.par.type</code></td>
<td>
<p>Defines how column names get associated
with THETA, OMEGA, and SIGMA. Default is to look for &quot;T&quot;, &quot;O&quot;,
or &quot;S&quot; as starting letter. If customizing, make sure each no
column name will be matched by more than one criterion.</p>
</td></tr>
<tr><td><code id="readParsWide_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say <code>tibble::as_tibble</code>) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The wide data format read by 'readParsWide' is not a Nonmem
format. It is used to bridge output from other tools such as
simpar, and potentially PSN. 
</p>
<p>This function reads a data that is &quot;wide&quot; in parameters - it has a
column for each parameter, and one row per parameter set or
&quot;model&quot;. It returns a data set that is &quot;long&quot; in model and
parameters. The long format contains
</p>

<ul>
<li><p> id.model.par The unique model-parameter identifier. The row-identifier.
</p>
</li>
<li><p> model Model identifier. 
</p>
</li>
<li><p> par.type (&quot;THETA&quot;, &quot;OMEGA&quot;, &quot;SIGMA&quot;)
</p>
</li>
<li><p> i and j indexes for the parameters (j is NA for par.type==&quot;THETA&quot;).
</p>
</li>
<li><p> value The parameter value 
</p>
</li>
<li><p> parameter Nonmem-style parameter names. THETA1, OMEGA(1,1) etc. Notice the inconsistent naming of THETA vs others.
</p>
</li>
<li><p> name.wide The column name in the wide data where this value was taken
</p>
</li></ul>

<p>The columns or &quot;measure variables&quot; from which to read values  are
specified as three regular expressions, called THETA, OMEGA, and SIGMA. The default three regular expressions will associate a column name starting with &quot;T&quot; with THETAs, while &quot;O&quot; or &quot;S&quot; followed by anything means &quot;OMEGA&quot; or &quot;SIGMA&quot;.
</p>
<p>readParsWide extracts i and j indexes from sequences of digits in the column names. TH.1 would be TETA1, SG1.1 is SIGMA(1,1).
</p>


<h3>Value</h3>

<p>a long-format data.frame of model parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tab.ext &lt;- readParsCsv("simpartab.csv")
## or
tab.simpar &lt;- fread("simpartab.csv")
tab.ext &lt;- readParsCsv(tab.simpar)
NMsim(...,method.sim=NMsim_VarCov,tab.ext=tab.ext)

## End(Not run)
</code></pre>

<hr>
<h2 id='simpleCharArg'>Check that a variable is a single character string meeting specified requirements</h2><span id='topic+simpleCharArg'></span>

<h3>Description</h3>

<p>Check that a variable is a single character string meeting specified requirements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleCharArg(name.arg, val.arg, default, accepted, lower = TRUE, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleCharArg_+3A_name.arg">name.arg</code></td>
<td>
<p>Name of the argument</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_val.arg">val.arg</code></td>
<td>
<p>argument value</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_default">default</code></td>
<td>
<p>If val.arg is NULL, what should be returned?</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_accepted">accepted</code></td>
<td>
<p>What values are allowed</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_lower">lower</code></td>
<td>
<p>run tolower?</p>
</td></tr>
<tr><td><code id="simpleCharArg_+3A_clean">clean</code></td>
<td>
<p>clean white spaces?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Better options may be available in packages like
checkmate. This function doesn't only check the parameter
value, it also sets it to the default value if missing.
</p>


<h3>Value</h3>

<p>The resulting parameter value
</p>

<hr>
<h2 id='simPopEtas'>Generate a population based on a Nonmem model</h2><span id='topic+simPopEtas'></span>

<h3>Description</h3>

<p>Generate a population based on a Nonmem model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPopEtas(file.mod, N, seed, file.phi, as.fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPopEtas_+3A_file.mod">file.mod</code></td>
<td>
<p>Path to input control stream</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_n">N</code></td>
<td>
<p>Number of subjects to generate</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_seed">seed</code></td>
<td>
<p>Optional seed. Will be passed to 'set.seed'. Same
thing as running 'set.seed' just before calling
'simPopEtas()'.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_file.phi">file.phi</code></td>
<td>
<p>An optional phi file to write the generated subjects to.</p>
</td></tr>
<tr><td><code id="simPopEtas_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say 'tibble::as_tibble') in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>

<hr>
<h2 id='unNMsimModTab'>Remove NMsimModTab class and discard NMsimModTab meta data</h2><span id='topic+unNMsimModTab'></span><span id='topic+is.NMsimModTab'></span><span id='topic+NMsimModTabOperations'></span><span id='topic+merge.NMsimModTab'></span><span id='topic+t.NMsimModTab'></span><span id='topic+dimnames.NMsimModTab'></span><span id='topic+rbind.NMsimModTab'></span><span id='topic+cbind.NMsimModTab'></span>

<h3>Description</h3>

<p>Remove NMsimModTab class and discard NMsimModTab meta data
</p>
<p>Check if an object is 'NMsimModTab'
</p>
<p>Basic arithmetic on NMsimModTab objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unNMsimModTab(x)

is.NMsimModTab(x)

## S3 method for class 'NMsimModTab'
merge(x, ...)

## S3 method for class 'NMsimModTab'
t(x, ...)

## S3 method for class 'NMsimModTab'
dimnames(x, ...)

## S3 method for class 'NMsimModTab'
rbind(x, ...)

## S3 method for class 'NMsimModTab'
cbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unNMsimModTab_+3A_x">x</code></td>
<td>
<p>an NMsimModTab object</p>
</td></tr>
<tr><td><code id="unNMsimModTab_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When 'dimnames', 'merge', 'cbind', 'rbind', or 't' is
called on an 'NMsimModTab' object, the 'NMsimModTab' class is dropped,
and then the operation is performed. So if and 'NMsimModTab' object
inherits from 'data.frame' and no other classes (which is
default), these operations will be performed using the
'data.frame' methods. But for example, if you use 'as.fun' to
get a 'data.table' or 'tbl', their respective methods are used
instead.
</p>


<h3>Value</h3>

<p>x stripped from the 'NMsimModTab' class
</p>
<p>logical if x is an 'NMsimModTab' object
</p>
<p>An object that is not of class 'NMsimModTab'.
</p>

<hr>
<h2 id='unNMsimRes'>Remove NMsimRes class and discard NMsimRes meta data</h2><span id='topic+unNMsimRes'></span><span id='topic+is.NMsimRes'></span><span id='topic+NMsimResOperations'></span><span id='topic+merge.NMsimRes'></span><span id='topic+t.NMsimRes'></span><span id='topic+dimnames.NMsimRes'></span><span id='topic+rbind.NMsimRes'></span><span id='topic+cbind.NMsimRes'></span>

<h3>Description</h3>

<p>Remove NMsimRes class and discard NMsimRes meta data
</p>
<p>Check if an object is 'NMsimRes'
</p>
<p>Basic arithmetic on NMsimRes objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unNMsimRes(x)

is.NMsimRes(x)

## S3 method for class 'NMsimRes'
merge(x, ...)

## S3 method for class 'NMsimRes'
t(x, ...)

## S3 method for class 'NMsimRes'
dimnames(x, ...)

## S3 method for class 'NMsimRes'
rbind(x, ...)

## S3 method for class 'NMsimRes'
cbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unNMsimRes_+3A_x">x</code></td>
<td>
<p>an NMsimRes object</p>
</td></tr>
<tr><td><code id="unNMsimRes_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When 'dimnames', 'merge', 'cbind', 'rbind', or 't' is
called on an 'NMsimRes' object, the 'NMsimRes' class is dropped,
and then the operation is performed. So if and 'NMsimRes' object
inherits from 'data.frame' and no other classes (which is
default), these operations will be performed using the
'data.frame' methods. But for example, if you use 'as.fun' to
get a 'data.table' or 'tbl', their respective methods are used
instead.
</p>


<h3>Value</h3>

<p>x stripped from the 'NMsimRes' class
</p>
<p>logical if x is an 'NMsimRes' object
</p>
<p>An object that is not of class 'NMsimRes'.
</p>

<hr>
<h2 id='writeTextFile'>Conveniently writeLines to file</h2><span id='topic+writeTextFile'></span>

<h3>Description</h3>

<p>Conveniently writeLines to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeTextFile(lines, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeTextFile_+3A_lines">lines</code></td>
<td>
<p>the character lines to write</p>
</td></tr>
<tr><td><code id="writeTextFile_+3A_file">file</code></td>
<td>
<p>The file name path to write to</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
