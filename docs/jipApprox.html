<!DOCTYPE html><html><head><title>Help for package jipApprox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jipApprox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jipApprox-package'><p>jipApprox: Approximate inclusion probabilities for survey sampling</p></a></li>
<li><a href='#brewer'><p>Brewer sampling procedure &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p></a></li>
<li><a href='#excludeSSU'><p>Exclude self-selecting units</p></a></li>
<li><a href='#HTvar'><p>Variance of the Horvitz-Thompson estimator</p></a></li>
<li><a href='#is.wholenumber'><p>Check if a number is integer</p></a></li>
<li><a href='#jip_approx'><p>Approximate Joint-Inclusion Probabilities</p></a></li>
<li><a href='#jip_Brewer'><p>Brewer's joint-inclusion probability approximations</p></a></li>
<li><a href='#jip_Hajek'><p>Hájek's joint-inclusion probability approximation</p></a></li>
<li><a href='#jip_HartleyRao'><p>Hartley-Rao approximation of joint-inclusion probabilities</p></a></li>
<li><a href='#jip_MonteCarlo'><p>Approximate inclusion probabilities by Monte Carlo simulation</p></a></li>
<li><a href='#jip_Tille'><p>Tillé's approximation of joint-inclusion probabilities</p></a></li>
<li><a href='#jipDFtoM'><p>Transform a Joint-Inclusion Probability data.frame to a matrix</p></a></li>
<li><a href='#jipMtoDF'><p>Transform a matrix of Joint-Inclusion Probabilities to a data.frame</p></a></li>
<li><a href='#maxEntropy'><p>Conditional Poisson Sampling (maximum entropy sampling)</p></a></li>
<li><a href='#pre_CPS'><p>Conditional Poisson Sampling  - compute selection probabilities</p></a></li>
<li><a href='#pre_tille'><p>Tillé's elimination procedure - elimination probabilities</p></a></li>
<li><a href='#sampford'><p>Rao-Sampford sampling</p></a></li>
<li><a href='#save_output'><p>Save partial results</p></a></li>
<li><a href='#tille'><p>Tillé's elimination procedure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Approximate Inclusion Probabilities for Survey Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Approximate joint-inclusion probabilities in Unequal Probability Sampling, or compute Monte Carlo approximations of the first and second-order inclusion probabilities of a general sampling design as in Fattorini (2006) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F93.2.269">doi:10.1093/biomet/93.2.269</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rhobis/jipApprox/issues">https://github.com/rhobis/jipApprox/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>sampling</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-26 08:11:03 UTC; Roberto</td>
</tr>
<tr>
<td>Author:</td>
<td>Roberto Sichera [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roberto Sichera &lt;rob.sichera@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-26 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jipApprox-package'>jipApprox: Approximate inclusion probabilities for survey sampling</h2><span id='topic+jipApprox'></span><span id='topic+jipApprox-package'></span>

<h3>Description</h3>

<p>Approximate joint-inclusion probabilities in Unequal Probability Sampling,
or compute Monte Carlo approximations of the first and second-order inclusion
probabilities of a general sampling design as in Fattorini (2006)
&lt;doi:10.1093/biomet/93.2.269&gt;.
</p>


<h3>Approximation of Joint-inclusion probabilities</h3>

<p>Function <code><a href="#topic+jip_approx">jip_approx</a></code> provides a number of approximations of the
second-order inclusion probabilities that require only the first-order inclusion
probabilities. These approximations may be employed in unequal probability sampling
design with high entropy. A more flexible approximation may be obtained by using
function <code><a href="#topic+jip_MonteCarlo">jip_MonteCarlo</a></code>, which estimates inclusion probabilities
through a Monte Carlo simulation.
</p>
<p>The variance of the Horvitz-Thompson total estimator may be then estimated by
plugging the approximated joint probabilities into the Horvitz-Thompson or
Sen-Yates-Grundy variance estimator using function <code><a href="#topic+HTvar">HTvar</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Roberto Sichera <a href="mailto:rob.sichera@gmail.com">rob.sichera@gmail.com</a>
</p>


<h3>References</h3>

<p>Matei, A.; Tillé, Y., 2005. Evaluation of variance approximations and estimators
in maximum entropy sampling with unequal probability and fixed sample size.
Journal of Official Statistics 21 (4), 543-570.
</p>
<p>Haziza, D.; Mecatti, F.; Rao, J.N.K. 2008.
Evaluation of some approximate variance estimators under the Rao-Sampford
unequal probability sampling design. Metron LXVI (1), 91-108.
</p>
<p>Fattorini, L. 2006.
Applying the Horvitz-Thompson criterion in complex designs: A computer-intensive
perspective for estimating inclusion probabilities.
Biometrika 93 (2), 269-278
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/rhobis/jipApprox/issues">https://github.com/rhobis/jipApprox/issues</a>
</p>
</li></ul>


<hr>
<h2 id='brewer'>Brewer sampling procedure &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h2><span id='topic+brewer'></span>

<h3>Description</h3>

<p>Brewer sampling procedure &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brewer(pik, n, N, s, list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brewer_+3A_pik">pik</code></td>
<td>
<p>vector of first-order inclusion probabilities</p>
</td></tr>
<tr><td><code id="brewer_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="brewer_+3A_n">N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="brewer_+3A_s">s</code></td>
<td>
<p>vector of length N, with 1s at the positions of self-selecting units</p>
</td></tr>
<tr><td><code id="brewer_+3A_list">list</code></td>
<td>
<p>vector with positions of self selcting units</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this function is a modified version of function <code><a href="sampling.html#topic+UPbrewer">UPbrewer</a></code>,
from the <span class="pkg">sampling</span> package.
</p>

<hr>
<h2 id='excludeSSU'>Exclude self-selecting units</h2><span id='topic+excludeSSU'></span>

<h3>Description</h3>

<p>Exclude self-selecting units and units with probability zero and returns a list
with parameters needed to perform sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excludeSSU(pik, eps = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excludeSSU_+3A_pik">pik</code></td>
<td>
<p>vector of first-order inclusion probabilities</p>
</td></tr>
<tr><td><code id="excludeSSU_+3A_eps">eps</code></td>
<td>
<p>control value for pik</p>
</td></tr>
</table>


<h3>Note</h3>

<p>the code is taken from package <span class="pkg">sampling</span>
</p>

<hr>
<h2 id='HTvar'>Variance of the Horvitz-Thompson estimator</h2><span id='topic+HTvar'></span>

<h3>Description</h3>

<p>Compute or estimate the variance of the Horvitz-Thompson total estimator
by the Horvitz-Thompson or Sen-Yates-Grundy variance estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTvar(y, pikl, sample = TRUE, method = "HT")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTvar_+3A_y">y</code></td>
<td>
<p>numeric vector representing the variable of interest</p>
</td></tr>
<tr><td><code id="HTvar_+3A_pikl">pikl</code></td>
<td>
<p>matrix of second-order (joint) inclusion probabilities; the diagonal
must contain the first-order inclusion probabilities.</p>
</td></tr>
<tr><td><code id="HTvar_+3A_sample">sample</code></td>
<td>
<p>logical value indicating whether sample or population values are provided.
If <code>sample=TRUE</code>, the function returns a sample estimate of the variance,
while if <code>sample=FALSE</code>, the Variance is computed over all population units.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="HTvar_+3A_method">method</code></td>
<td>
<p>string, indicating if the Horvitz-Thompson (<code>"HT"</code>) or the
Sen-Yates-Grundy (<code>"SYG"</code>) estimator should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Horvitz-Thompson variance is defined as
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i\in U}\sum_{j \in U} \frac{(\pi_{ij} - \pi_i\pi_j)}{\pi_i\pi_j} y_i y_j </code>
</p>

<p>which is estimated by
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i\in U}\sum_{j \in U} \frac{(\pi_{ij} - \pi_i\pi_j)}{\pi_i\pi_j\pi_{ij}} y_i y_j </code>
</p>

<p>The Sen-Yates-Grundy variance is obtained from the Horvitz-Thompson variance
by conditioning on the sample size n, and is therefore only appliable to
fixed size sampling designs:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i\in U}\sum_{j &gt; i} (\pi_i\pi_j - \pi_{ij}) \Biggl(\frac{y_i}{\pi_i} - \frac{y_j}{\pi_j} \Biggr)^2 </code>
</p>

<p>Its estimator is
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i\in U}\sum_{j &gt; i} \frac{(\pi_i\pi_j - \pi_{ij})}{\pi_{ij}} \Biggl(\frac{y_i}{\pi_i} - \frac{y_j}{\pi_j} \Biggr)^2 </code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
### Generate population data ---
N &lt;- 500; n &lt;- 50

set.seed(0)
x &lt;- rgamma(500, scale=10, shape=5)
y &lt;- abs( 2*x + 3.7*sqrt(x) * rnorm(N) )

pik  &lt;- n * x/sum(x)
pikl &lt;- jip_approx(pik, method='Hajek')

### Dummy sample ---
s   &lt;- sample(N, n)


### Compute Variance ---
HTvar(y=y, pikl=pikl, sample=FALSE, method="HT")
HTvar(y=y, pikl=pikl, sample=FALSE, method="SYG")


### Estimate Variance ---
#' HTvar(y=y[s], pikl=pikl[s,s], sample=TRUE, method="HT")
#' HTvar(y=y[s], pikl=pikl[s,s], sample=TRUE, method="SYG")


</code></pre>

<hr>
<h2 id='is.wholenumber'>Check if a number is integer</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Check if <code>x</code> is an integer number, differently from <code>is.integer</code>,
which checks the type of the object <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>a scalar or a numeric vector</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>a scalar, indicating the tolerance</p>
</td></tr>
</table>


<h3>Note</h3>

<p>From the help page of function <code><a href="base.html#topic+is.integer">is.integer</a></code>
</p>

<hr>
<h2 id='jip_approx'>Approximate Joint-Inclusion Probabilities</h2><span id='topic+jip_approx'></span>

<h3>Description</h3>

<p>Approximations of joint-inclusion probabilities by means of first-order
inclusion probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jip_approx(pik, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jip_approx_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all
population units.</p>
</td></tr>
<tr><td><code id="jip_approx_+3A_method">method</code></td>
<td>
<p>string representing one of the available approximation methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available methods are <code>"Hajek"</code>, <code>"HartleyRao"</code>, <code>"Tille"</code>,
<code>"Brewer1"</code>,<code>"Brewer2"</code>,<code>"Brewer3"</code>, and <code>"Brewer4"</code>.
Note that these methods were derived for high-entropy sampling designs,
therefore they could have low performance under different designs.
</p>
<p>Hájek (1964) approximation [<code>method="Hajek"</code>] is derived under Maximum Entropy sampling design
and is given by
</p>
<p style="text-align: center;"><code class="reqn">\tilde{\pi}_{ij} = \pi_i\pi_j \frac{1 - (1-\pi_i)(1-\pi_j)}{d} </code>
</p>

<p>where <code class="reqn">d = \sum_{i\in U} \pi_i(1-\pi_i) </code>
</p>
<p>Hartley and Rao (1962) proposed the following approximation under
randomised systematic sampling [<code>method="HartleyRao"</code>]:
</p>
<p style="text-align: center;"><code class="reqn">\tilde{\pi}_{ij} = \frac{n-1}{n} \pi_i\pi_j + \frac{n-1}{n^2} (\pi_i^2 \pi_j + \pi_i \pi_j^2)
      - \frac{n-1}{n^3}\pi_i\pi_j \sum_{i\in U} \pi_j^2</code>
</p>

<p style="text-align: center;"><code class="reqn"> + \frac{2(n-1)}{n^3} (\pi_i^3 \pi_j + \pi_i\pi_j^3 + \pi_i^2 \pi_j^2)
      - \frac{3(n-1)}{n^4} (\pi_i^2 \pi_j + \pi_i\pi_j^2) \sum_{i \in U}\pi_i^2</code>
</p>

<p style="text-align: center;"><code class="reqn">+ \frac{3(n-1)}{n^5} \pi_i\pi_j \biggl( \sum_{i\in U} \pi_i^2 \biggr)^2
      - \frac{2(n-1)}{n^4} \pi_i\pi_j \sum_{i \in U} \pi_j^3  </code>
</p>

<p>Tillé (1996) proposed the approximation <code class="reqn">\tilde{\pi}_{ij} = \beta_i\beta_j</code>,
where the coefficients <code class="reqn">\beta_i</code> are computed iteratively through the
following procedure [<code>method="Tille"</code>]:
</p>

<ol>
<li> <p><code class="reqn">\beta_i^{(0)} = \pi_i, \,\, \forall i\in U</code>
</p>
</li>
<li> <p><code class="reqn"> \beta_i^{(2k-1)} = \frac{(n-1)\pi_i}{\beta^{(2k-2)} - \beta_i^{(2k-2)}}  </code>
</p>
</li>
<li> <p><code class="reqn">\beta_i^{2k} = \beta_i^{(2k-1)}
        \Biggl( \frac{n(n-1)}{(\beta^(2k-1))^2 - \sum_{i\in U} (\beta_k^{(2k-1)})^2 } \Biggr)^(1/2) </code>
</p>
</li></ol>

<p>with <code class="reqn">\beta^{(k)} = \sum_{i\in U} \beta_i^{i}, \,\, k=1,2,3, \dots </code>
</p>
<p>Finally, Brewer (2002) and Brewer and Donadio (2003) proposed four approximations,
which are defined by the general form
</p>
<p style="text-align: center;"><code class="reqn">\tilde{\pi}_{ij} = \pi_i\pi_j (c_i + c_j)/2  </code>
</p>

<p>where the <code class="reqn">c_i</code> determine the approximation used:
</p>

<ul>
<li><p> Equation (9)  [<code>method="Brewer1"</code>]:
</p>
<p style="text-align: center;"><code class="reqn">c_i = (n-1) / (n-\pi_i)</code>
</p>

</li>
<li><p> Equation (10) [<code>method="Brewer2"</code>]:
</p>
<p style="text-align: center;"><code class="reqn">c_i = (n-1) / \Bigl(n- n^{-1}\sum_{i\in U}\pi_i^2 \Bigr)</code>
</p>

</li>
<li><p> Equation (11) [<code>method="Brewer3"</code>]:
</p>
<p style="text-align: center;"><code class="reqn">c_i = (n-1) / \Bigl(n - 2\pi_i + n^{-1}\sum_{i\in U}\pi_i^2 \Bigr)</code>
</p>

</li>
<li><p> Equation (18) [<code>method="Brewer4"</code>]:
</p>
<p style="text-align: center;"><code class="reqn">c_i = (n-1) / \Bigl(n - (2n-1)(n-1)^{-1}\pi_i + (n-1)^{-1}\sum_{i\in U}\pi_i^2 \Bigr)</code>
</p>

</li></ul>



<h3>Value</h3>

<p>A symmetric matrix of inclusion probabilities, which diagonal is the
vector of first-order inclusion probabilities.
</p>


<h3>References</h3>

<p>Hartley, H.O.; Rao, J.N.K., 1962. Sampling With Unequal Probability and Without Replacement.
The Annals of Mathematical Statistics 33 (2), 350-374.
</p>
<p>Hájek, J., 1964. Asymptotic Theory of Rejective Sampling with Varying Probabilities from a Finite Population.
The Annals of Mathematical Statistics 35 (4), 1491-1523.
</p>
<p>Tillé, Y., 1996. Some Remarks on Unequal Probability Sampling Designs Without Replacement.
Annals of Economics and Statistics 44, 177-189.
</p>
<p>Brewer, K.R.W.; Donadio, M.E., 2003. The High Entropy Variance of the Horvitz-Thompson Estimator.
Survey Methodology 29 (2), 189-196.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Generate population data ---
N &lt;- 20; n&lt;-5

set.seed(0)
x &lt;- rgamma(N, scale=10, shape=5)
y &lt;- abs( 2*x + 3.7*sqrt(x) * rnorm(N) )

pik  &lt;- n * x/sum(x)

### Approximate joint-inclusion probabilities ---
pikl &lt;- jip_approx(pik, method='Hajek')
pikl &lt;- jip_approx(pik, method='HartleyRao')
pikl &lt;- jip_approx(pik, method='Tille')
pikl &lt;- jip_approx(pik, method='Brewer1')
pikl &lt;- jip_approx(pik, method='Brewer2')
pikl &lt;- jip_approx(pik, method='Brewer3')
pikl &lt;- jip_approx(pik, method='Brewer4')



</code></pre>

<hr>
<h2 id='jip_Brewer'>Brewer's joint-inclusion probability approximations</h2><span id='topic+jip_Brewer'></span>

<h3>Description</h3>

<p>Approximation of joint inclusion probabilities by one of the estimators
proposed by Brewer and Donadio (2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jip_Brewer(pik, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jip_Brewer_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all
population units.</p>
</td></tr>
<tr><td><code id="jip_Brewer_+3A_method">method</code></td>
<td>
<p>string representing one of the available approximation methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"Brewer18"</code> is the approximation showed in equation (18) of Brewer and Donadio (2003)
</p>

<hr>
<h2 id='jip_Hajek'>Hájek's joint-inclusion probability approximation</h2><span id='topic+jip_Hajek'></span>

<h3>Description</h3>

<p>Estimate joint-inclusion probabilities using Hájek (1964) equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jip_Hajek(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jip_Hajek_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all
population units.</p>
</td></tr>
</table>

<hr>
<h2 id='jip_HartleyRao'>Hartley-Rao approximation of joint-inclusion probabilities</h2><span id='topic+jip_HartleyRao'></span>

<h3>Description</h3>

<p>Approximation of joint-inclusion probabilities with precision of order
<code class="reqn">O(N^{-4})</code> for the random systematic sampling design
by Hartley and Rao (1962), pag. 369 eq. 5.15
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jip_HartleyRao(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jip_HartleyRao_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all
population units.</p>
</td></tr>
</table>

<hr>
<h2 id='jip_MonteCarlo'>Approximate inclusion probabilities by Monte Carlo simulation</h2><span id='topic+jip_MonteCarlo'></span>

<h3>Description</h3>

<p>Approximate first and second-order inclusion probabilities by means of
Monte Carlo simulation.
Estimates are obtained as proportion of the number of occurrences of each unit or
couple of units over the total number of replications. One unit is added to both
numerator and  denominator to assure strict positivity of estimates (Fattorini, 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jip_MonteCarlo(
  x,
  n,
  replications = 1e+06,
  design,
  units,
  seed = NULL,
  as_data_frame = FALSE,
  design_pars,
  write_on_file = FALSE,
  filename,
  path,
  by = NULL,
  progress_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jip_MonteCarlo_+3A_x">x</code></td>
<td>
<p>size measure or first-order inclusion probabilities, a vector or single-column data.frame</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_n">n</code></td>
<td>
<p>sample size (for fixed-size designs), or expected sample size (for Poisson sampling)</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_replications">replications</code></td>
<td>
<p>numeric value, number of independent Monte Carlo replications</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_design">design</code></td>
<td>
<p>sampling procedure to be used for sample selection.
Either a string indicating the name of the sampling design or a function;
see section &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_units">units</code></td>
<td>
<p>indices of units for which probabilities have to be estimated.
Optional, if missing, estimates are produced for the whole population</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_seed">seed</code></td>
<td>
<p>a valid seed value for reproducibility</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_as_data_frame">as_data_frame</code></td>
<td>
<p>logical, should output be in a data.frame form? if FALSE,
a matrix is returned</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_design_pars">design_pars</code></td>
<td>
<p>only used when a function is passed to argument <code>design</code>,
named list of parameters to pass to the sampling design function.</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_write_on_file">write_on_file</code></td>
<td>
<p>logical, should output be written on a text file?</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_filename">filename</code></td>
<td>
<p>string indicating the name of the file to create on disk,
must include the <code>.txt</code> extension; only applies if <code>write_on_file = TRUE</code>.</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_path">path</code></td>
<td>
<p>string indicating the path to the directory where the output file
should be created; only applies if <code>write_on_file = TRUE</code>.</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_by">by</code></td>
<td>
<p>optional; integer scalar indicating every how many replications a partial output
should be saved</p>
</td></tr>
<tr><td><code id="jip_MonteCarlo_+3A_progress_bar">progress_bar</code></td>
<td>
<p>logical, indicating whether a progress bar is desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>design</code> accepts either a string indicating the sampling design
to use to draw samples or a function.
Accepted designs are &quot;brewer&quot;, &quot;tille&quot;, &quot;maxEntropy&quot;, &quot;poisson&quot;,
&quot;sampford&quot;, &quot;systematic&quot;, &quot;randomSystematic&quot;.
The user may also pass a function as argument; such function should take as input
the parameters passed to argument <code>design_pars</code> and return either a logical
vector or a vector of 0s and 1s,  where <code>TRUE</code> or <code>1</code> indicate sampled
units and <code>FALSE</code> or <code>0</code> indicate non-sample units.
The length of such vector must be equal to the length of <code>x</code>
if <code>units</code> is not specified, otherwise it must have the same length of <code>units</code>.
</p>
<p>When <code>write_on_file = TRUE</code>, specifying a value for aurgument <code>by</code>
will produce intermediate files with approximate inclusion probabilities every
<code>by</code> number of replications. E.g., if <code>replications=1e06</code> and <code>by=5e05</code>,
two output files will be created: one with estimates at <code>5e05</code>
and one at <code>1e06</code> replications.
This option is particularly useful to assess convergence of the estimates.
</p>


<h3>Value</h3>

<p>A matrix of estimated inclusion probabilities if <code>as_data_frame=FALSE</code>,
otherwise a data.frame with three columns: the first two indicate the ids of the
the couple of units, while the third one contains the joint-inclusion probability
values. Please, note that when <code>as_data_frame=TRUE</code>, first-order
inclusion probabilities are not returned.
</p>


<h3>References</h3>

<p>Fattorini, L. 2006.
Applying the Horvitz-Thompson criterion in complex designs: A computer-intensive
perspective for estimating inclusion probabilities.
Biometrika 93 (2), 269–278
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Generate population data ---
N &lt;- 20; n&lt;-5

set.seed(0)
x &lt;- rgamma(N, scale=10, shape=5)
y &lt;- abs( 2*x + 3.7*sqrt(x) * rnorm(N) )

pik  &lt;- n * x/sum(x)

### Approximate joint-inclusion probabilities
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "brewer")
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "tille")
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "maxEntropy")
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "randomSystematic")
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "systematic")
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "sampford")
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "poisson")

#Use an external function to draw samples
pikl &lt;- jip_MonteCarlo(x=pik, n=n, replications=100,
                       design = sampling::UPmidzuno, design_pars = list(pik=pik))
#Write output on file after 50 and 100 replications
pikl &lt;- jip_MonteCarlo(x=pik, n = n, replications = 100, design = "brewer",
                       write_on_file = TRUE, filename="test.txt", path=tempdir(), by = 50 )

</code></pre>

<hr>
<h2 id='jip_Tille'>Tillé's approximation of joint-inclusion probabilities</h2><span id='topic+jip_Tille'></span>

<h3>Description</h3>

<p>Compute the approximation of joint-inclusion probabilities by means of the
Iterative Proportional Fitting Procedure (IPFP) proposed by Tillé (1996)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jip_Tille(pik, eps = 1e-06, maxIter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jip_Tille_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all
population units.</p>
</td></tr>
<tr><td><code id="jip_Tille_+3A_eps">eps</code></td>
<td>
<p>tolerance value for the convergence of the fixed-point procedure</p>
</td></tr>
<tr><td><code id="jip_Tille_+3A_maxiter">maxIter</code></td>
<td>
<p>a scalar indicating the maximum number of iterations for the
fixed-point procedure</p>
</td></tr>
</table>

<hr>
<h2 id='jipDFtoM'>Transform a Joint-Inclusion Probability data.frame to a matrix</h2><span id='topic+jipDFtoM'></span>

<h3>Description</h3>

<p>Transform a Joint-Inclusion Probability data.frame to a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jipDFtoM(jip, symmetric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jipDFtoM_+3A_jip">jip</code></td>
<td>
<p>vector or data.frame containing the joint-inclusion probabilities</p>
</td></tr>
<tr><td><code id="jipDFtoM_+3A_symmetric">symmetric</code></td>
<td>
<p>boolean, if <code>TRUE</code>, returns a symmetric matrix, otherwise,
an upper triangular matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric matrix of joint-inclusion probabilities if <code>TRUE</code>, otherwise,
an upper triangular matrix
</p>

<hr>
<h2 id='jipMtoDF'>Transform a matrix of Joint-Inclusion Probabilities to a data.frame</h2><span id='topic+jipMtoDF'></span>

<h3>Description</h3>

<p>Transform a matrix of Joint-Inclusion Probabilities to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jipMtoDF(jip, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jipMtoDF_+3A_jip">jip</code></td>
<td>
<p>a square matrix of joint-inclusion probabilities, symmetric or
upper-triangular</p>
</td></tr>
<tr><td><code id="jipMtoDF_+3A_id">id</code></td>
<td>
<p>optional, vector of id labels, its length should be equal to
<code>ncol(jip)</code> and <code>nrow(jip)</code></p>
</td></tr>
</table>

<hr>
<h2 id='maxEntropy'>Conditional Poisson Sampling (maximum entropy sampling)</h2><span id='topic+maxEntropy'></span>

<h3>Description</h3>

<p>Draw a sample by means of Conditional Poisson Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxEntropy(pik, N, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxEntropy_+3A_pik">pik</code></td>
<td>
<p>vector of first-order inclusion probabilities</p>
</td></tr>
<tr><td><code id="maxEntropy_+3A_n">N</code></td>
<td>
<p>population size (excluding self-selecting units)</p>
</td></tr>
<tr><td><code id="maxEntropy_+3A_q">q</code></td>
<td>
<p>matrix of selection probabilities, computed by means of function
<code>UPMEsfromq()</code> of package <code>sampling</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this functions is a modified version of function <code><a href="sampling.html#topic+UPmaxentropy">UPmaxentropy</a></code>,
in the <span class="pkg">sampling</span> package.
</p>

<hr>
<h2 id='pre_CPS'>Conditional Poisson Sampling  - compute selection probabilities</h2><span id='topic+pre_CPS'></span>

<h3>Description</h3>

<p>Compute matrix of selection probabilities for Conditional Poisson Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_CPS(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_CPS_+3A_pik">pik</code></td>
<td>
<p>vector of first-order inclusion probabilities</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this functions is a modified version of function <code><a href="sampling.html#topic+UPmaxentropy">UPmaxentropy</a></code>,
in the <span class="pkg">sampling</span> package.
</p>

<hr>
<h2 id='pre_tille'>Tillé's elimination procedure - elimination probabilities</h2><span id='topic+pre_tille'></span>

<h3>Description</h3>

<p>Computes a matrix with elimination probabilities for each step
of Tillé's elimination procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_tille(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_tille_+3A_pik">pik</code></td>
<td>
<p>vector of first-order inclusion probabilities</p>
</td></tr>
</table>

<hr>
<h2 id='sampford'>Rao-Sampford sampling</h2><span id='topic+sampford'></span>

<h3>Description</h3>

<p>Draw a sample by means of Rao-Sampford sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampford(pik, n, N, s, list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampford_+3A_pik">pik</code></td>
<td>
<p>vector of first-order inclusion probabilities</p>
</td></tr>
<tr><td><code id="sampford_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="sampford_+3A_n">N</code></td>
<td>
<p>population size (excluding self-selecting units)</p>
</td></tr>
<tr><td><code id="sampford_+3A_s">s</code></td>
<td>
<p>vector of length N, with 1s at the positions of self-selecting units</p>
</td></tr>
<tr><td><code id="sampford_+3A_list">list</code></td>
<td>
<p>vector with positions of self selcting units</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this function is a modified version of function <code><a href="sampling.html#topic+UPsampford">UPsampford</a></code>,
in the <span class="pkg">sampling</span> package.
</p>

<hr>
<h2 id='save_output'>Save partial results</h2><span id='topic+save_output'></span>

<h3>Description</h3>

<p>Write joint inclusion probability estimates on a file every <code>by</code> replications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_output(
  iteration,
  design_name,
  counts,
  units,
  filename,
  path,
  status,
  as_data_frame
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_output_+3A_iteration">iteration</code></td>
<td>
<p>integer indicating the iterations the simulation is at</p>
</td></tr>
<tr><td><code id="save_output_+3A_design_name">design_name</code></td>
<td>
<p>string indicating the name of the sampling design to include
in the filename</p>
</td></tr>
<tr><td><code id="save_output_+3A_counts">counts</code></td>
<td>
<p>matrix with number of occurrences of couple of units up to
current replication</p>
</td></tr>
<tr><td><code id="save_output_+3A_units">units</code></td>
<td>
<p>id of units for which output should be saved</p>
</td></tr>
<tr><td><code id="save_output_+3A_filename">filename</code></td>
<td>
<p>name of the file to write on disk</p>
</td></tr>
<tr><td><code id="save_output_+3A_path">path</code></td>
<td>
<p>path to the directory where the file should be saved</p>
</td></tr>
<tr><td><code id="save_output_+3A_status">status</code></td>
<td>
<p><code>1</code> if partial results are written before the maximum number
of replications is reached, <code>0</code> otherwise</p>
</td></tr>
<tr><td><code id="save_output_+3A_as_data_frame">as_data_frame</code></td>
<td>
<p>logical, should output be in form of a data frame?</p>
</td></tr>
</table>

<hr>
<h2 id='tille'>Tillé's elimination procedure</h2><span id='topic+tille'></span>

<h3>Description</h3>

<p>Draw a sample by means of Tillé's elimination procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tille(pik, n, N, s, list, pmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tille_+3A_pik">pik</code></td>
<td>
<p>vector of first-order inclusion probabilities</p>
</td></tr>
<tr><td><code id="tille_+3A_n">n</code></td>
<td>
<p>sample size (excluding self-selecting units)</p>
</td></tr>
<tr><td><code id="tille_+3A_n">N</code></td>
<td>
<p>population size (excluding self-selecting units)</p>
</td></tr>
<tr><td><code id="tille_+3A_s">s</code></td>
<td>
<p>vector of length N, with 1s at the positions of self-selecting units</p>
</td></tr>
<tr><td><code id="tille_+3A_list">list</code></td>
<td>
<p>vector with positions of self selcting units</p>
</td></tr>
<tr><td><code id="tille_+3A_pmat">pmat</code></td>
<td>
<p>matrix of dimension $(N-n)xN, where each row has elimination probabilities
for population units for one step of the procedure.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
