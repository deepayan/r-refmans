<!DOCTYPE html><html><head><title>Help for package starsExtra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {starsExtra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#starsExtra-package'><p>starsExtra: Miscellaneous Functions for Working with 'stars' Rasters</p></a></li>
<li><a href='#aspect'><p>Calculate topographic aspect from a DEM</p></a></li>
<li><a href='#carmel'><p>Digital Elevation Model of Mount Carmel</p></a></li>
<li><a href='#CI'><p>Calculate the Convergence Index (CI) from a slope raster</p></a></li>
<li><a href='#dem'><p>Small Digital Elevation Model</p></a></li>
<li><a href='#detrend'><p>Detrend a Digital Elevation Model</p></a></li>
<li><a href='#dist_to_nearest'><p>Calculate raster of distances to nearest feature</p></a></li>
<li><a href='#extract2'><p>Extract raster values by lines or polygons</p></a></li>
<li><a href='#flowlength'><p>Calculate flow length</p></a></li>
<li><a href='#focal2'><p>Apply a focal filter on a raster</p></a></li>
<li><a href='#focal2r'><p>Apply a focal filter on a raster (R)</p></a></li>
<li><a href='#footprints'><p>Footprints</p></a></li>
<li><a href='#golan'><p>Digital Elevation Model of Golan Heights</p></a></li>
<li><a href='#landsat'><p>RGB image of Mount Carmel</p></a></li>
<li><a href='#layer_to_matrix'><p>Get <code>stars</code> layer values as matrix</p></a></li>
<li><a href='#layer_to_vector'><p>Get <code>stars</code> layer values as vector</p></a></li>
<li><a href='#make_grid'><p>Make 'stars' grid from 'sf' layer</p></a></li>
<li><a href='#matrix_extend'><p>Extend matrix</p></a></li>
<li><a href='#matrix_get_neighbors'><p>Get neighboring cell values for given matrix cell</p></a></li>
<li><a href='#matrix_to_stars'><p>Convert <code>matrix</code> to <code>stars</code></p></a></li>
<li><a href='#matrix_trim'><p>Trim matrix</p></a></li>
<li><a href='#mode_value'><p>Mode</p></a></li>
<li><a href='#normalize_2d'><p>Normalize a 2D 'stars' object</p></a></li>
<li><a href='#normalize_3d'><p>Normalize a 3D 'stars' object</p></a></li>
<li><a href='#rgb_to_greyscale'><p>Convert RGB to greyscale</p></a></li>
<li><a href='#slope'><p>Calculate topographic slope from a DEM</p></a></li>
<li><a href='#trim2'><p>Remove empty outer rows and columns</p></a></li>
<li><a href='#w_azimuth'><p>Create matrix with azimuths to center</p></a></li>
<li><a href='#w_circle'><p>Create matrix with circular weight pattern</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions for Working with 'stars' Rasters</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Miscellaneous functions for working with 'stars' objects, mainly single-band rasters. Currently includes functions for: (1) focal filtering, (2) detrending of Digital Elevation Models, (3) calculating flow length, (4) calculating the Convergence Index, (5) calculating topographic aspect and topographic slope.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), sf, stars</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, mgcv, nngeo, units</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, knitr, rmarkdown, raster</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://michaeldorman.github.io/starsExtra/">https://michaeldorman.github.io/starsExtra/</a>,
<a href="https://github.com/michaeldorman/starsExtra/">https://github.com/michaeldorman/starsExtra/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/michaeldorman/starsExtra/issues/">https://github.com/michaeldorman/starsExtra/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-13 14:13:32 UTC; michael</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dorman [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dorman &lt;dorman@post.bgu.ac.il&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='starsExtra-package'>starsExtra: Miscellaneous Functions for Working with 'stars' Rasters</h2><span id='topic+starsExtra'></span><span id='topic+starsExtra-package'></span>

<h3>Description</h3>

<p>Miscellaneous functions for working with 'stars' objects, mainly single-band rasters. Currently includes functions for: (1) focal filtering, (2) detrending of Digital Elevation Models, (3) calculating flow length, (4) calculating the Convergence Index, (5) calculating topographic aspect and topographic slope.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Dorman <a href="mailto:dorman@post.bgu.ac.il">dorman@post.bgu.ac.il</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://michaeldorman.github.io/starsExtra/">https://michaeldorman.github.io/starsExtra/</a>
</p>
</li>
<li> <p><a href="https://github.com/michaeldorman/starsExtra/">https://github.com/michaeldorman/starsExtra/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/michaeldorman/starsExtra/issues/">https://github.com/michaeldorman/starsExtra/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='aspect'>Calculate topographic aspect from a DEM</h2><span id='topic+aspect'></span>

<h3>Description</h3>

<p>Calculates topographic aspect given a Digital Elevation Model (DEM) raster. Input and output are rasters of class <code>stars</code>, single-band (i.e., only '&quot;x&quot;' and '&quot;y&quot;' dimensions), with one attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aspect(x, na_flag = -9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aspect_+3A_x">x</code></td>
<td>
<p>A raster (class <code>stars</code>) with two dimensions: <code>x</code> and <code>y</code>, i.e., a single-band raster, representing a DEM.</p>
</td></tr>
<tr><td><code id="aspect_+3A_na_flag">na_flag</code></td>
<td>
<p>Value used to mark <code>NA</code> values in C code. This should be set to a value which is guaranteed to be absent from the input raster <code>x</code> (default is <code>-9999</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> raster with topographic slope, i.e., the azimuth where the terrain is tilted towards, in decimal degrees (0-360) clockwise from north. Aspect of flat terrain, i.e., where all values in the neighborhood are equal, is set to <code>-1</code>. Returned raster values are of class <code>units</code> (decimal degrees).
</p>


<h3>Note</h3>

<p>Aspect calculation results in <code>NA</code> when at least one of the cell neighbors is <code>NA</code>, including the outermost rows and columns. Given that the focal window size in aspect calculation is 3*3, this means that the outermost one row and one column are given an aspect value of <code>NA</code>.
</p>
<p>The raster must be in projected CRS, and units of x/y resolution are assumed to be the same as units of elevation (typically <em>meters</em>).
</p>


<h3>References</h3>

<p>The topographic aspect algorithm is based on the <em>How aspect works</em> article in the ArcGIS documentation:
</p>
<p><a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-aspect-works.htm">https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-aspect-works.htm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example
data(dem)
dem_aspect = aspect(dem)
plot(
  dem, text_values = TRUE, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "input (elevation)"
)
plot(
  dem_aspect, text_values = TRUE, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "output (aspect)"
)

# Larger example
data(carmel)
carmel_aspect = aspect(carmel)
plot(
  carmel, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "input (elevation)"
)
plot(
  carmel_aspect, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "output (aspect)"
)


</code></pre>

<hr>
<h2 id='carmel'>Digital Elevation Model of Mount Carmel</h2><span id='topic+carmel'></span>

<h3>Description</h3>

<p>A <code>stars</code> object representing a Digital Elevation Model (DEM) Digital Elevation Model of Mount Carmel, at 90m resolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carmel
</code></pre>


<h3>Format</h3>

<p>A <code>stars</code> object with 1 attribute:
</p>

<dl>
<dt>elevation</dt><dd><p>Elevation above sea level, in meters</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot(carmel, breaks = "equal", col = terrain.colors(11))
</code></pre>

<hr>
<h2 id='CI'>Calculate the Convergence Index (CI) from a slope raster</h2><span id='topic+CI'></span>

<h3>Description</h3>

<p>Calculates the Convergence Index (CI) given a topographic slope raster. Input and output are rasters of class <code>stars</code>, single-band (i.e., only '&quot;x&quot;' and '&quot;y&quot;' dimensions), with one attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI(x, k, na.rm = FALSE, na_flag = -9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CI_+3A_x">x</code></td>
<td>
<p>A raster (class <code>stars</code>) with two dimensions: <code>x</code> and <code>y</code>, i.e., a single-band raster, representing aspect in decimal degrees clockwise from north, possibly including <code>-1</code> to specify flat terrain, such as returned by function <code><a href="#topic+aspect">aspect</a></code>.</p>
</td></tr>
<tr><td><code id="CI_+3A_k">k</code></td>
<td>
<p>k Neighborhood size around focal cell. Must be an odd number. For example, <code>k=3</code> implies a 3*3 neighborhood.</p>
</td></tr>
<tr><td><code id="CI_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be ignored when calculating CI? Default is <code>FALSE</code>, i.e., when at least one aspect value in the neighborhood is <code>NA</code> the CI is also set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="CI_+3A_na_flag">na_flag</code></td>
<td>
<p>Value used to mark <code>NA</code> values in C code. This should be set to a value which is guaranteed to be absent from the input raster <code>x</code> (default is <code>-9999</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> raster with CI values.
</p>


<h3>Note</h3>

<p>The raster is &quot;padded&quot; with <code>(k-1)/2</code> more rows and columns of <code>NA</code> values on all sides, so that the neighborhood of the outermost rows and columns is still a complete neighborhood. Those rows and columns are removed from the final result before returning it.
Aspect values of <code>-1</code>, specifying flat terrain, are assigned with a CI value of <code>0</code> regardless of their neighboring values.
</p>


<h3>References</h3>

<p>The Convergence Index algorithm is described in:
</p>
<p>Thommeret, N., Bailly, J. S., &amp; Puech, C. (2010). Extraction of thalweg networks from DTMs: application to badlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example
data(dem)
dem_asp = aspect(dem)
dem_ci = CI(dem_asp, k = 3)
r = c(dem, round(dem_ci, 1), along = 3)
r = st_set_dimensions(r, 3, values = c("input (aspect)", "output (CI, k=3)"))
plot(r, text_values = TRUE, breaks = "equal", col = terrain.colors(10), mfrow = c(1, 2))

# Larger example
data(golan)
golan_asp = aspect(golan)
golan_ci = CI(golan_asp, k = 25)
plot(golan_asp, breaks = "equal", col = hcl.colors(11, "Spectral"), main = "input (aspect)")
plot(golan_ci, breaks = "equal", col = hcl.colors(11, "Spectral"), main = "output (CI, k=25)")


</code></pre>

<hr>
<h2 id='dem'>Small Digital Elevation Model</h2><span id='topic+dem'></span>

<h3>Description</h3>

<p>A <code>stars</code> object representing a small 13*11 Digital Elevation Model (DEM), at 90m resolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem
</code></pre>


<h3>Format</h3>

<p>A <code>stars</code> object with 1 attribute:
</p>

<dl>
<dt>elevation</dt><dd><p>Elevation above sea level, in meters</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot(dem, text_values = TRUE, breaks = "equal", col = terrain.colors(11))
</code></pre>

<hr>
<h2 id='detrend'>Detrend a Digital Elevation Model</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p>Detrends a Digital Elevation Model (DEM) raster, by subtracting a trend surface. The trend is computed using <code>mgcv::gam</code> or <code>mgcv::bam</code> (when <code>parallel&gt;1</code>) with formula <code>z ~ s(x, y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(x, parallel = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_x">x</code></td>
<td>
<p>A two-dimensional <code>stars</code> object representing the DEM</p>
</td></tr>
<tr><td><code id="detrend_+3A_parallel">parallel</code></td>
<td>
<p>Number of parallel processes. With <code>parallel=1</code> uses ordinary, non-parallel processing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-dimensional <code>stars</code> object, with two attributes:</p>

<ul>
<li><p><code>resid</code> - the detrended result, i.e., &quot;residual&quot;
</p>
</li>
<li><p><code>trend</code> - the estimated &quot;trend&quot; which was subtracted from the actual elevation to obtain <code>resid</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Small example
data(dem)
dem1 = detrend(dem)
dem1 = st_redimension(dem1)
dem1 = st_set_dimensions(dem1, 3, values = c("resid", "trend"))
plot(round(dem1), text_values = TRUE, col = terrain.colors(11))

# Larger example 1
data(carmel)
carmel1 = detrend(carmel, parallel = 2)
carmel1 = st_redimension(carmel1)
carmel1 = st_set_dimensions(carmel1, 3, values = c("resid", "trend"))
plot(carmel1, col = terrain.colors(11))

# Larger example 2
data(golan)
golan1 = detrend(golan, parallel = 2)
golan1 = st_redimension(golan1)
golan1 = st_set_dimensions(golan1, 3, values = c("resid", "trend"))
plot(golan1, col = terrain.colors(11))

</code></pre>

<hr>
<h2 id='dist_to_nearest'>Calculate raster of distances to nearest feature</h2><span id='topic+dist_to_nearest'></span>

<h3>Description</h3>

<p>Given a <code>stars</code> raster and an <code>sf</code> vector layer, returns a new raster with the distances of each cell centroid to the nearest feature in the vector layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_to_nearest(x, v, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_to_nearest_+3A_x">x</code></td>
<td>
<p>A <code>stars</code> layer, used as a &quot;grid&quot; for distance calculations</p>
</td></tr>
<tr><td><code id="dist_to_nearest_+3A_v">v</code></td>
<td>
<p>An <code>sf</code>, <code>sfc</code> or <code>sfg</code> object</p>
</td></tr>
<tr><td><code id="dist_to_nearest_+3A_progress">progress</code></td>
<td>
<p>Display progress bar? The default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> raster with distances to nearest feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 'sf' layer
x = st_point(c(0,0))
y = st_point(c(1,1))
x = st_sfc(x, y)
x = st_sf(x)
x = st_buffer(x, 0.5)

# Make grid
r = make_grid(x, res = 0.1, buffer = 0.5)
d = dist_to_nearest(r, x, progress = FALSE)

# Plot
plot(d, breaks = "equal", axes = TRUE, reset = FALSE)
plot(st_geometry(x), add = TRUE, pch = 4, cex = 3)
</code></pre>

<hr>
<h2 id='extract2'>Extract raster values by lines or polygons</h2><span id='topic+extract2'></span>

<h3>Description</h3>

<p>Extract raster values by lines or polygons, summarizing for each feature using a function specified by the user. This function is aimed to reproduce (some of) the functionality of <code>raster::extract</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract2(x, v, fun, progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract2_+3A_x">x</code></td>
<td>
<p>A <code>stars</code> object</p>
</td></tr>
<tr><td><code id="extract2_+3A_v">v</code></td>
<td>
<p>An <code>sf</code> layer that determines values to extract</p>
</td></tr>
<tr><td><code id="extract2_+3A_fun">fun</code></td>
<td>
<p>A function to summarize cell values per feature/band</p>
</td></tr>
<tr><td><code id="extract2_+3A_progress">progress</code></td>
<td>
<p>Display progress bar? The default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="extract2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (single-band raster) or <code>matrix</code> (multi-band raster) with the extracted and summarized values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Polygons
pol = st_bbox(landsat)
pol = st_as_sfc(pol)
set.seed(1)
pol = st_sample(pol, 5)
pol = st_buffer(pol, 100)
pol = c(pol, pol)

# Plot
plot(landsat[,,,1,drop=TRUE], reset = FALSE)
plot(pol, add = TRUE)

# Single-band raster
aggregate(landsat[,,,1,drop=TRUE], pol, mean, na.rm = TRUE)[[1]]  ## Duplicated areas get 'NA'
extract2(landsat[,,,1,drop=TRUE], pol, mean, na.rm = TRUE, progress = FALSE)

# Multi-band example
extract2(landsat, pol, mean, na.rm = TRUE, progress = FALSE)

# Lines
lines = st_cast(pol, "LINESTRING")

# Single-band raster
extract2(landsat[,,,1,drop=TRUE], lines, mean, na.rm = TRUE, progress = FALSE)

# Multi-band example
extract2(landsat, lines, mean, na.rm = TRUE, progress = FALSE)

</code></pre>

<hr>
<h2 id='flowlength'>Calculate flow length</h2><span id='topic+flowlength'></span>

<h3>Description</h3>

<p>Calculates flow length for each pixel in a Digital Elevation Model (DEM) raster. Inputs and output are rasters of class <code>stars</code>, single-band (i.e., only '&quot;x&quot;' and '&quot;y&quot;' dimensions), with one attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowlength(elev, veg, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flowlength_+3A_elev">elev</code></td>
<td>
<p>A numeric <code>stars</code> raster representing a Digital Elevation Model (DEM).</p>
</td></tr>
<tr><td><code id="flowlength_+3A_veg">veg</code></td>
<td>
<p>A matching logical <code>stars</code> raster representing vegetation presence. <code>TRUE</code> values represent vegetated cells where flow is absorbed (i.e. sinks), <code>FALSE</code> values represent cells where flow is unobstructed.</p>
</td></tr>
<tr><td><code id="flowlength_+3A_progress">progress</code></td>
<td>
<p>Display progress bar? The default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>stars</code> raster where each cell value is flow length, in resolution units.
</p>


<h3>References</h3>

<p>The algorithm is described in:
</p>
<p>Mayor, A. G., Bautista, S., Small, E. E., Dixon, M., &amp; Bellot, J. (2008). Measurement of the connectivity of runoff source areas as determined by vegetation pattern and topography: A tool for assessing potential water and soil losses in drylands. Water Resources Research, 44(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Fig. 2 in Mayor et al. 2008

elev = rbind(
  c(8, 8, 8, 8, 9, 8, 9),
  c(7, 7, 7, 7, 9, 7, 7),
  c(6, 6, 6, 6, 6, 5, 7),
  c(4, 5, 5, 3, 5, 4, 7),
  c(4, 5, 4, 5, 4, 6, 5),
  c(3, 3, 3, 3, 2, 3, 3),
  c(2, 2, 2, 3, 4, 1, 3)
)
veg = rbind(
  c(TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE),
  c(TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE),
  c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE),
  c(FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, TRUE),
  c(TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE),
  c(TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE),
  c(FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE)
)
elev = matrix_to_stars(elev)
veg = matrix_to_stars(veg)

# Calculate flow length
fl = flowlength(elev, veg, progress = FALSE)

# Plot
plot(
  round(elev, 1), text_values = TRUE, breaks = "equal", 
  col = terrain.colors(6), main = "input (elevation)"
)
plot(
  veg*1, text_values = TRUE, breaks = "equal", 
  col = rev(terrain.colors(2)), main = "input (vegetation)"
)
plot(
  round(fl, 1), text_values = TRUE, breaks = "equal", 
  col = terrain.colors(6), main = "output (flowlength)"
)

# Larger example
data(carmel)
elev = carmel
elev[is.na(elev)] = 0
veg = elev &gt; 100
fl = flowlength(elev, veg, progress = FALSE)
plot(fl, breaks = "equal", col = hcl.colors(11), main = "flowlength (m)")

</code></pre>

<hr>
<h2 id='focal2'>Apply a focal filter on a raster</h2><span id='topic+focal2'></span>

<h3>Description</h3>

<p>Applies a focal filter with weighted neighborhood <code>w</code> on a raster. The weights (<code>w</code>) can be added to, subtracted from, multiplied by or divided with the raster values (as specified with <code>weight_fun</code>). The focal cell is then taken as the mean, sum, minimum or maximum of the weighted values (as specified with <code>fun</code>).  Input and output are rasters of class <code>stars</code>, single-band (i.e., only '&quot;x&quot;' and '&quot;y&quot;' dimensions), with one attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focal2(
  x,
  w,
  fun = "mean",
  weight_fun = "*",
  na.rm = FALSE,
  mask = FALSE,
  na_flag = -9999
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focal2_+3A_x">x</code></td>
<td>
<p>A raster (class <code>stars</code>) with one attribute and two dimensions: <code>x</code> and <code>y</code>, i.e., a single-band raster.</p>
</td></tr>
<tr><td><code id="focal2_+3A_w">w</code></td>
<td>
<p>Weights matrix defining the neighborhood size around the focal cell, as well as the weights. For example, <code>matrix(1,3,3)</code> implies a neighborhood of size 3*3 with equal weights of 1 for all cells. The matrix must be square, i.e., with an odd number of rows and columns.</p>
</td></tr>
<tr><td><code id="focal2_+3A_fun">fun</code></td>
<td>
<p>A function to aggregate the resulting values for each neighborhood. Possible values are: <code>"mean"</code>, <code>"sum"</code>, <code>"min"</code>, <code>"max"</code>, and <code>"mode"</code>. The default is <code>"mean"</code>, i.e., the resulting values per neighborhood are <em>averaged</em> before being assigned to the new focal cell value.</p>
</td></tr>
<tr><td><code id="focal2_+3A_weight_fun">weight_fun</code></td>
<td>
<p>An operator which is applied on each pair of values comprising the cell value and the respective weight value, as in <code>raster_value-weight</code>. Possible values are: <code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"/"</code>. The default is <code>"*"</code>, i.e., each cell value is <em>multiplied</em> by the respective weight.</p>
</td></tr>
<tr><td><code id="focal2_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values in the neighborhood be removed from the calculation? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="focal2_+3A_mask">mask</code></td>
<td>
<p>If <code>TRUE</code>, pixels with <code>NA</code> in the input are set to <code>NA</code> in the output as well, i.e., the output is &quot;masked&quot; using the input (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="focal2_+3A_na_flag">na_flag</code></td>
<td>
<p>Value used to mark <code>NA</code> values in C code. This should be set to a value which is guaranteed to be absent from the input raster <code>x</code> (default is <code>-9999</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered <code>stars</code> raster.
</p>


<h3>Note</h3>

<p>The raster is &quot;padded&quot; with <code>(nrow(w)-1)/2</code> more rows and columns of <code>NA</code> values on all sides, so that the neighborhood of the outermost rows and columns is still a complete neighborhood. Those rows and columns are removed from the final result before returning it. This means, for instance, that the outermost rows and columns in the result will be <code>NA</code> when using <code>na.rm=FALSE</code>.
</p>


<h3>References</h3>

<p>The function interface was inspired by function <code>raster::focal</code>. The C code for this function is a modified and expanded version of the C function named <code>applyKernel</code> included with R package <code>spatialfil</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example
data(dem)
dem_mean3 = focal2(dem, matrix(1, 3, 3), "mean")
r = c(dem, round(dem_mean3, 1), along = 3)
r = st_set_dimensions(r, 3, values = c("input", "output (mean, k=3)"))
plot(r, text_values = TRUE, breaks = "equal", col = terrain.colors(11))

# Larger example
data(carmel)
carmel_mean15 = focal2(carmel, matrix(1, 15, 15), "mean")
r = c(carmel, carmel_mean15, along = 3)
r = st_set_dimensions(r, 3, values = c("input", "output (mean, k=15)"))
plot(r, breaks = "equal", col = terrain.colors(11))


</code></pre>

<hr>
<h2 id='focal2r'>Apply a focal filter on a raster (R)</h2><span id='topic+focal2r'></span>

<h3>Description</h3>

<p>Applies a focal filter with neighborhood size <code>k</code>*<code>k</code> on a raster (class <code>stars</code>), using R code. This function is relatively slow, provided here mainly for testing purposes or for custom using functions which are not provided by <code>focal2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focal2r(x, w, fun, mask = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focal2r_+3A_x">x</code></td>
<td>
<p>A raster (class <code>stars</code>) with two dimensions: <code>x</code> and <code>y</code>, i.e., a single-band raster</p>
</td></tr>
<tr><td><code id="focal2r_+3A_w">w</code></td>
<td>
<p>Weights matrix defining the neighborhood size around the focal cell, as well as the weights. For example, <code>matrix(1,3,3)</code> implies a neighborhood of size 3*3 with equal weights of 1 for all cells. Focal cell values are multiplied by the matrix values before being passed to function <code>fun</code>. The matrix must be square, i.e., with an odd number of rows and columns.</p>
</td></tr>
<tr><td><code id="focal2r_+3A_fun">fun</code></td>
<td>
<p>A function to be applied on each neighborhood, after it has been multiplied by the matrix. The function needs to accepts a vector (of length equal to <code>length(w)</code> and return a vector of length <code>1</code></p>
</td></tr>
<tr><td><code id="focal2r_+3A_mask">mask</code></td>
<td>
<p>If <code>TRUE</code>, pixels with <code>NA</code> in the input are set to <code>NA</code> in the output as well, i.e., the output is &quot;masked&quot; with the input (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="focal2r_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered <code>stars</code> raster
</p>


<h3>Note</h3>

<p>The raster is &quot;padded&quot; with one more row/column of <code>NA</code> values on all sides, so that the neigborhood of the outermost rows and columns is still a complete 3x3 neighborhood. Those rows and columns are removed from the filtered result before returning it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Small example
data(dem)
dem1 = focal2r(dem, matrix(1,3,3), mean, na.rm = TRUE)
dem2 = focal2r(dem, matrix(1,3,3), min, na.rm = TRUE)
dem3 = focal2r(dem, matrix(1,3,3), max, na.rm = TRUE)
r = c(dem, round(dem1, 1), dem2, dem3, along = 3)
r = st_set_dimensions(r, 3, values = c("input", "mean", "min", "max"))
plot(r, text_values = TRUE, breaks = "equal", col = terrain.colors(10))
# Larger example
data(carmel)
carmel1 = focal2r(carmel, matrix(1,3,3), mean, na.rm = TRUE, mask = TRUE)
carmel2 = focal2r(carmel, matrix(1,9,9), mean, na.rm = TRUE, mask = TRUE)
carmel3 = focal2r(carmel, matrix(1,15,15), mean, na.rm = TRUE, mask = TRUE)
r = c(carmel, carmel1, carmel2, carmel3, along = 3)
r = st_set_dimensions(r, 3, values = c("input", "k=3", "k=9", "k=15"))
plot(r, breaks = "equal", col = terrain.colors(100))


</code></pre>

<hr>
<h2 id='footprints'>Footprints</h2><span id='topic+footprints'></span>

<h3>Description</h3>

<p>Calculates a polygon layer with the footprints of raster images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>footprints(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="footprints_+3A_x">x</code></td>
<td>
<p>A <code>character</code> vector of raster file paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> layer with the footprints (i.e., bounding box polygons) of the rasters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create sample files
file1 = tempfile(fileext = ".tif")
file2 = tempfile(fileext = ".tif")
file3 = tempfile(fileext = ".tif")
r1 = landsat[,1:100, 1:100,]
r2 = landsat[,101:200, 101:200,]
r3 = landsat[,21:40, 51:120,]
write_stars(r1, file1)
write_stars(r2, file2)
write_stars(r3, file3)

# Calculate footprints
files = c(file1, file2, file3)
pol = footprints(files)
pol

</code></pre>

<hr>
<h2 id='golan'>Digital Elevation Model of Golan Heights</h2><span id='topic+golan'></span>

<h3>Description</h3>

<p>A <code>stars</code> object representing a Digital Elevation Model (DEM) Digital Elevation Model of part of the Golan Heights and Lake Kinneret, at 90m resolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>golan
</code></pre>


<h3>Format</h3>

<p>A <code>stars</code> object with 1 attribute:
</p>

<dl>
<dt>elevation</dt><dd><p>Elevation above sea level, in meters</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot(golan, breaks = "equal", col = terrain.colors(11))
</code></pre>

<hr>
<h2 id='landsat'>RGB image of Mount Carmel</h2><span id='topic+landsat'></span>

<h3>Description</h3>

<p>A <code>stars</code> object representing an RGB image of part of Mount Carmel, at 30m resolution. The data source is Landsat-8 Surface Reflectance product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landsat
</code></pre>


<h3>Format</h3>

<p>A <code>stars</code> object with 1 attribute:
</p>

<dl>
<dt>refl</dt><dd><p>Reflectance, numeric value between 0 and 1</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot(landsat, breaks = "equal")
</code></pre>

<hr>
<h2 id='layer_to_matrix'>Get <code>stars</code> layer values as matrix</h2><span id='topic+layer_to_matrix'></span>

<h3>Description</h3>

<p>Extracts the values of a single layer in a <code>stars</code> object to a <code>matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_to_matrix(x, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer_to_matrix_+3A_x">x</code></td>
<td>
<p>A <code>stars</code> raster with one attribute and two dimensions, <code>x</code> and <code>y</code>, i.e., a single-band raster.</p>
</td></tr>
<tr><td><code id="layer_to_matrix_+3A_check">check</code></td>
<td>
<p>Whether to check (and fix if necessary) that input has one attribute, one layer and x-y as dimensions 1-2 (default is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the layer values, having the same orientation as the raster (i.e., rows represent the y-axis and columns represent the x-axis).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dem)
m = layer_to_matrix(dem)
m

</code></pre>

<hr>
<h2 id='layer_to_vector'>Get <code>stars</code> layer values as vector</h2><span id='topic+layer_to_vector'></span>

<h3>Description</h3>

<p>Extracts the values of a single layer in a <code>stars</code> object to a vector. Cell values are ordered from top-left corner to the right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_to_vector(x, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer_to_vector_+3A_x">x</code></td>
<td>
<p>A raster (class <code>stars</code>) with two dimensions: <code>x</code> and <code>y</code>, i.e., a single-band raster.</p>
</td></tr>
<tr><td><code id="layer_to_vector_+3A_check">check</code></td>
<td>
<p>Whether to check (and fix if necessary) that input has one attribute, one layer and x-y as dimensions 1-2 (default is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with cell values, ordered by rows, starting from the top left corner (north-west) and to the right.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dem)
v = layer_to_vector(dem)
v

</code></pre>

<hr>
<h2 id='make_grid'>Make 'stars' grid from 'sf' layer</h2><span id='topic+make_grid'></span>

<h3>Description</h3>

<p>Create 'stars' raster grid from bounding box of 'sf' vector layer, possibly buffered, with specified resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_grid(x, res, buffer = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_grid_+3A_x">x</code></td>
<td>
<p>An <code>sf</code>, <code>sfc</code> or <code>sfg</code> object</p>
</td></tr>
<tr><td><code id="make_grid_+3A_res">res</code></td>
<td>
<p>Required grid resolution, in CRS units of <code>x</code></p>
</td></tr>
<tr><td><code id="make_grid_+3A_buffer">buffer</code></td>
<td>
<p>Buffer size around <code>x</code> (default is <code>0</code>, i.e., no buffer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> raster with the grid, with all cell values equal to <code>1</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 'sf' layer
x = st_point(c(0,0))
y = st_point(c(1,1))
x = st_sfc(x, y)
x = st_sf(x)

# Make grid
r = make_grid(x, res = 0.1, buffer = 0.5)
r[[1]][] = rep(1:3, length.out = length(r[[1]]))

# Plot
plot(r, axes = TRUE, reset = FALSE)
plot(st_geometry(x), add = TRUE, pch = 4, cex = 3, col = "red")
</code></pre>

<hr>
<h2 id='matrix_extend'>Extend matrix</h2><span id='topic+matrix_extend'></span>

<h3>Description</h3>

<p>Adds <code>n</code> rows and columns with <code>NA</code> values on all sides of a <code>matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_extend(m, n = 1, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_extend_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code></p>
</td></tr>
<tr><td><code id="matrix_extend_+3A_n">n</code></td>
<td>
<p>By how many rows/columns to extend the matrix on each side?</p>
</td></tr>
<tr><td><code id="matrix_extend_+3A_fill">fill</code></td>
<td>
<p>Fill value (default is <code>NA</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An extended <code>matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = matrix(1:6, nrow = 2, ncol = 3)
m
matrix_extend(m, 1)
matrix_extend(m, 2)
matrix_extend(m, 3)
</code></pre>

<hr>
<h2 id='matrix_get_neighbors'>Get neighboring cell values for given matrix cell</h2><span id='topic+matrix_get_neighbors'></span>

<h3>Description</h3>

<p>Get the values of a <code>k</code>*<code>k</code> neighborhood, as vector and by row, given a <code>matrix</code>, <code>k</code>, and focal cell position (row and column).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_get_neighbors(m, pos, k = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_get_neighbors_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="matrix_get_neighbors_+3A_pos">pos</code></td>
<td>
<p>The focal cell position, a <code>numeric</code> vector of length two of the form <code>c(row, column)</code>.</p>
</td></tr>
<tr><td><code id="matrix_get_neighbors_+3A_k">k</code></td>
<td>
<p>Neighborhood size around the focal cell. For example, <code>k=3</code> implies a neighborhood of size 3*3. Must be an odd positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with cell values, ordered by rows, starting from the top left corner of the neighborhood and to the right. When neighborhood extends beyond matrix bounds, only the &quot;existing&quot; values are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = matrix(1:12, nrow = 3, ncol = 4)
m
matrix_get_neighbors(m, pos = c(2, 2), k = 3)
matrix_get_neighbors(m, pos = c(2, 2), k = 5)
matrix_get_neighbors(m, pos = c(2, 2), k = 7)  # Same result
</code></pre>

<hr>
<h2 id='matrix_to_stars'>Convert <code>matrix</code> to <code>stars</code></h2><span id='topic+matrix_to_stars'></span>

<h3>Description</h3>

<p>Converts <code>matrix</code> to a single-band <code>stars</code> raster, conserving the matrix orientation where rows become the y-axis and columns become the y-axis. The bottom-left corner of the axis is set to <code>(0,0)</code> coordinate, so that x and y coordinates are positive across the raster extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_stars(m, res = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_stars_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code></p>
</td></tr>
<tr><td><code id="matrix_to_stars_+3A_res">res</code></td>
<td>
<p>The cell size, default is <code>1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volcano)
r = matrix_to_stars(volcano, res = 10)
plot(r)

</code></pre>

<hr>
<h2 id='matrix_trim'>Trim matrix</h2><span id='topic+matrix_trim'></span>

<h3>Description</h3>

<p>Removes <code>n</code> rows and columns with <code>NA</code> values on all sides of a <code>matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_trim(m, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_trim_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code></p>
</td></tr>
<tr><td><code id="matrix_trim_+3A_n">n</code></td>
<td>
<p>By how many rows/columns to trim the matrix on each side?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trimmed <code>matrix</code>, or <code>NULL</code> if trimming results in an &quot;empty&quot; matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = matrix(1:80, nrow = 8, ncol = 10)
m
matrix_trim(m, 1)
matrix_trim(m, 2)
matrix_trim(m, 3)
matrix_trim(m, 4)
</code></pre>

<hr>
<h2 id='mode_value'>Mode</h2><span id='topic+mode_value'></span>

<h3>Description</h3>

<p>Find the mode (i.e., most common value) in a numeric vector. In case of ties, the first encountered value is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_value(x, na_flag = -9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_value_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> or <code>logical</code> vector</p>
</td></tr>
<tr><td><code id="mode_value_+3A_na_flag">na_flag</code></td>
<td>
<p>Value used to mark <code>NA</code> values in C code. This should be set to a value which is guaranteed to be absent from the input vector <code>x</code> (default is <code>-9999</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mode, <code>numeric</code> vector of length 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(3, 2, 5, 5, 3, 10, 2, 5)
mode_value(x)

</code></pre>

<hr>
<h2 id='normalize_2d'>Normalize a 2D 'stars' object</h2><span id='topic+normalize_2d'></span>

<h3>Description</h3>

<p>Check, and possibly correct, that the input <code>stars</code> object:
</p>

<ul>
<li><p>Has exactly one attribute.
</p>
</li>
<li><p>Has exactly two dimensions.
</p>
</li>
<li><p>The dimensions are spatial, named <code>x</code> and <code>y</code> (in that order).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>normalize_2d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_2d_+3A_x">x</code></td>
<td>
<p>A <code>stars</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>stars</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example
data(dem)
normalize_2d(dem)
</code></pre>

<hr>
<h2 id='normalize_3d'>Normalize a 3D 'stars' object</h2><span id='topic+normalize_3d'></span>

<h3>Description</h3>

<p>Check, and possibly correct, that the input <code>stars</code> object:
</p>

<ul>
<li><p>Has exactly one attribute.
</p>
</li>
<li><p>Has exactly three dimensions.
</p>
</li>
<li><p>The first two dimensions are spatial, named <code>x</code> and <code>y</code> (in that order).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>normalize_3d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_3d_+3A_x">x</code></td>
<td>
<p>A <code>stars</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>stars</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example
data(landsat)
normalize_3d(landsat)
</code></pre>

<hr>
<h2 id='rgb_to_greyscale'>Convert RGB to greyscale</h2><span id='topic+rgb_to_greyscale'></span>

<h3>Description</h3>

<p>Convert a 3-band RGB raster to 1-band greyscale raster. Based on <code>wvtool::rgb2gray</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb_to_greyscale(x, rgb = 1:3, coefs = c(0.3, 0.59, 0.11))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgb_to_greyscale_+3A_x">x</code></td>
<td>
<p>A three-dimensional <code>stars</code> object with RGB values</p>
</td></tr>
<tr><td><code id="rgb_to_greyscale_+3A_rgb">rgb</code></td>
<td>
<p>Indices of RGB bands, default is <code>c(1, 2, 3)</code></p>
</td></tr>
<tr><td><code id="rgb_to_greyscale_+3A_coefs">coefs</code></td>
<td>
<p>RGB weights, default is <code>c(0.30,0.59,0.11)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-dimensional <code>stars</code> object greyscale values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(landsat)
plot(landsat, rgb = 1:3)
landsat_grey = rgb_to_greyscale(landsat)
plot(landsat_grey, breaks = "equal")

</code></pre>

<hr>
<h2 id='slope'>Calculate topographic slope from a DEM</h2><span id='topic+slope'></span>

<h3>Description</h3>

<p>Calculates topographic slope given a Digital Elevation Model (DEM) raster. Input and output are rasters of class <code>stars</code>, single-band (i.e., only '&quot;x&quot;' and '&quot;y&quot;' dimensions), with one attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(x, na_flag = -9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slope_+3A_x">x</code></td>
<td>
<p>A raster (class <code>stars</code>) with two dimensions: <code>x</code> and <code>y</code>, i.e., a single-band raster, representing a DEM.</p>
</td></tr>
<tr><td><code id="slope_+3A_na_flag">na_flag</code></td>
<td>
<p>Value used to mark <code>NA</code> values in C code. This should be set to a value which is guaranteed to be absent from the input raster <code>x</code> (default is <code>-9999</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> raster with topographic slope, i.e., the azimuth where the terrain is tilted towards, in decimal degrees (0-360) clockwise from north.
</p>


<h3>Note</h3>

<p>Slope calculation results in <code>NA</code> when at least one of the cell neighbors is <code>NA</code>, including the outermost rows and columns. Given that the focal window size in slope calculation is 3*3, this means that the outermost one row and one column are given an slope value of <code>NA</code>. 
</p>
<p>The raster must be in projected CRS, and units of x/y resolution are assumed to be the same as units of elevation (typically <em>meters</em>).
</p>


<h3>References</h3>

<p>The topographic slope algorithm is based on the <em>How slope works</em> article in the ArcGIS documentation:
</p>
<p><a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-slope-works.htm">https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-slope-works.htm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example
data(dem)
dem_slope = slope(dem)
plot(
  dem, text_values = TRUE, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "input (elevation)"
)

plot(
  dem_slope, text_values = TRUE, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "output (slope)"
)
# Larger example
data(carmel)
carmel_slope = slope(carmel)
plot(
  carmel, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "input (elevation)"
)
plot(
  carmel_slope, breaks = "equal", 
  col = hcl.colors(11, "Spectral"), main = "output (slope)"
)


</code></pre>

<hr>
<h2 id='trim2'>Remove empty outer rows and columns</h2><span id='topic+trim2'></span>

<h3>Description</h3>

<p>Removes complete outer rows and columns which have <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim2_+3A_x">x</code></td>
<td>
<p>A two-dimensional <code>stars</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>stars</code> object with empty outer rows and columns removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single-band example
data(dem)
dem[[1]][1,] = NA
dem1 = trim2(dem)

# Multi-band example
data(landsat)
landsat[[1]][1:100,,] = NA
landsat1 = trim2(landsat)

</code></pre>

<hr>
<h2 id='w_azimuth'>Create matrix with azimuths to center</h2><span id='topic+w_azimuth'></span>

<h3>Description</h3>

<p>Creates a <code>matrix</code> with directions (i.e., azimuth) to central cell, of specified size <code>k</code>. The matrix can be used as weight matrix when calculating the convergence index (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_azimuth(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_azimuth_+3A_k">k</code></td>
<td>
<p>Neighborhood size around focal cell. Must be an odd number. For example, <code>k=3</code> implies a 3*3 neighborhood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> where each cell value is the azimuth from that cell towards the matrix center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = w_azimuth(3)
m
m = w_azimuth(5)
m

</code></pre>

<hr>
<h2 id='w_circle'>Create matrix with circular weight pattern</h2><span id='topic+w_circle'></span>

<h3>Description</h3>

<p>Creates a <code>matrix</code> with where a circular pattern is filled with values of <code>1</code> and the remaining cells are filled with values of <code>0</code> (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_circle(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_circle_+3A_k">k</code></td>
<td>
<p>Neighborhood size around focal cell. Must be an odd number. For example, <code>k=3</code> implies a 3*3 neighborhood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with a circular pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = w_circle(3)
image(m, asp = 1, axes = FALSE)
m = w_circle(5)
image(m, asp = 1, axes = FALSE)
m = w_circle(15)
image(m, asp = 1, axes = FALSE)
m = w_circle(35)
image(m, asp = 1, axes = FALSE)
m = w_circle(91)
image(m, asp = 1, axes = FALSE)
m = w_circle(151)
image(m, asp = 1, axes = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
