<!DOCTYPE html><html><head><title>Help for package covr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {covr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_coverage'><p>Convert a counters object to a coverage object</p></a></li>
<li><a href='#as_coverage_with_tests'><p>Clean and restructure counter tests for a coverage object</p></a></li>
<li><a href='#azure'><p>Run covr on a package and output the result so it is available on Azure Pipelines</p></a></li>
<li><a href='#clear_counters'><p>clear all previous counters</p></a></li>
<li><a href='#code_coverage'><p>Calculate coverage of code directly</p></a></li>
<li><a href='#codecov'><p>Run covr on a package and upload the result to codecov.io</p></a></li>
<li><a href='#count'><p>increment a given counter</p></a></li>
<li><a href='#count_test'><p>Append a test trace to a counter, updating global current test</p></a></li>
<li><a href='#coverage_to_list'><p>Convert a coverage dataset to a list</p></a></li>
<li><a href='#coveralls'><p>Run covr on a package and upload the result to coveralls</p></a></li>
<li><a href='#covr-package'><p>covr: Test coverage for packages</p></a></li>
<li><a href='#covr.record_tests'><p>Record Test Traces During Coverage Execution</p></a></li>
<li><a href='#display_name'><p>Retrieve the path name (filename) for each coverage object</p></a></li>
<li><a href='#environment_coverage'><p>Calculate coverage of an environment</p></a></li>
<li><a href='#exclusions'><p>Exclusions</p></a></li>
<li><a href='#file_coverage'><p>Calculate test coverage for sets of files</p></a></li>
<li><a href='#file_report'><p>A coverage report for a specific file</p></a></li>
<li><a href='#function_coverage'><p>Calculate test coverage for a specific function.</p></a></li>
<li><a href='#gitlab'><p>Run covr on package and create report for GitLab</p></a></li>
<li><a href='#has_srcref'><p>Is the source bound to the expression</p></a></li>
<li><a href='#in_covr'><p>Determine if code is being run in covr</p></a></li>
<li><a href='#is_covr_count_call'><p>Is the expression a call to covr:::count</p></a></li>
<li><a href='#is_current_test_finished'><p>Returns TRUE if we've moved on from test reflected in .current_test</p></a></li>
<li><a href='#key'><p>Generate a key for a  call</p></a></li>
<li><a href='#new_counter'><p>initialize a new counter</p></a></li>
<li><a href='#new_test_counter'><p>Initialize a new test counter for a coverage trace</p></a></li>
<li><a href='#package_coverage'><p>Calculate test coverage for a package</p></a></li>
<li><a href='#percent_coverage'><p>Provide percent coverage of package</p></a></li>
<li><a href='#print.coverage'><p>Print a coverage object</p></a></li>
<li><a href='#report'><p>Display covr results using a standalone report</p></a></li>
<li><a href='#system_check'><p>Run a system command and check if it succeeds.</p></a></li>
<li><a href='#system_output'><p>Run a system command and capture the output.</p></a></li>
<li><a href='#tally_coverage'><p>Tally coverage by line or expression</p></a></li>
<li><a href='#to_cobertura'><p>Create a Cobertura XML file</p></a></li>
<li><a href='#to_sonarqube'><p>Create a SonarQube Generic XML file for test coverage according to</p>
https://docs.sonarqube.org/latest/analysis/generic-test/
Based on cobertura.R</a></li>
<li><a href='#trace_calls'><p>trace each call with a srcref attribute</p></a></li>
<li><a href='#truncate_call'><p>Truncate call objects to limit the number of arguments</p></a></li>
<li><a href='#update_current_test'><p>Update current test if unit test expression has progressed</p></a></li>
<li><a href='#value'><p>Retrieve the value from an object</p></a></li>
<li><a href='#zero_coverage'><p>Provide locations of zero coverage</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Test Coverage for Packages</td>
</tr>
<tr>
<td>Version:</td>
<td>3.6.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Track and report code coverage for your package and (optionally)
    upload the results to a coverage service like 'Codecov' <a href="https://about.codecov.io">https://about.codecov.io</a> or
    'Coveralls' <a href="https://coveralls.io">https://coveralls.io</a>. Code coverage is a measure of the amount of
    code being exercised by a set of tests. It is an indirect measure of test
    quality and completeness. This package is compatible with any testing
    methodology or framework and tracks coverage of both R code and compiled
    C/C++/FORTRAN code.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://covr.r-lib.org">https://covr.r-lib.org</a>, <a href="https://github.com/r-lib/covr">https://github.com/r-lib/covr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/covr/issues">https://github.com/r-lib/covr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, stats, utils, jsonlite, rex, httr, crayon, withr (&ge;
1.0.2), yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R6, curl, knitr, rmarkdown, htmltools, DT (&ge; 0.2), testthat,
rlang, rstudioapi (&ge; 0.2), xml2 (&ge; 1.0.0), parallel, memoise,
mockery, covr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-08 21:07:59 UTC; jimhester</td>
</tr>
<tr>
<td>Author:</td>
<td>Jim Hester [aut, cre],
  Willem Ligtenberg [ctb],
  Kirill Müller [ctb],
  Henrik Bengtsson [ctb],
  Steve Peak [ctb],
  Kirill Sevastyanenko [ctb],
  Jon Clayden [ctb],
  Robert Flight [ctb],
  Eric Brown [ctb],
  Brodie Gaslam [ctb],
  Will Beasley [ctb],
  Robert Krzyzanowski [ctb],
  Markus Wamser [ctb],
  Karl Forner [ctb],
  Gergely Daróczi [ctb],
  Jouni Helske [ctb],
  Kun Ren [ctb],
  Jeroen Ooms [ctb],
  Ken Williams [ctb],
  Chris Campbell [ctb],
  David Hugh-Jones [ctb],
  Qin Wang [ctb],
  Doug Kelkhoff [ctb],
  Ivan Sagalaev [ctb, cph] (highlight.js library),
  Mark Otto [ctb] (Bootstrap library),
  Jacob Thornton [ctb] (Bootstrap library),
  Bootstrap contributors [ctb] (Bootstrap library),
  Twitter, Inc [cph] (Bootstrap library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jim Hester &lt;james.f.hester@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-09 08:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_coverage'>Convert a counters object to a coverage object</h2><span id='topic+as_coverage'></span>

<h3>Description</h3>

<p>Convert a counters object to a coverage object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_coverage(counters = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_coverage_+3A_counters">counters</code></td>
<td>
<p>An environment of covr trace results to convert to a coverage
object. If <code>counters</code> is not provided, the <code>covr</code> namespace value
<code>.counters</code> is used.</p>
</td></tr>
<tr><td><code id="as_coverage_+3A_...">...</code></td>
<td>
<p>Additional attributes to include with the coverage object.</p>
</td></tr>
</table>

<hr>
<h2 id='as_coverage_with_tests'>Clean and restructure counter tests for a coverage object</h2><span id='topic+as_coverage_with_tests'></span>

<h3>Description</h3>

<p>For tests produced with <code>options(covr.record_tests)</code>, prune any unused
records in the $tests$tally matrices of each trace and get rid of the
wrapping $tests environment (reassigning with value of $tests$tally)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_coverage_with_tests(counters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_coverage_with_tests_+3A_counters">counters</code></td>
<td>
<p>An environment of covr trace results to convert to a coverage
object. If <code>counters</code> is not provided, the <code>covr</code> namespace value
<code>.counters</code> is used.</p>
</td></tr>
</table>

<hr>
<h2 id='azure'>Run covr on a package and output the result so it is available on Azure Pipelines</h2><span id='topic+azure'></span>

<h3>Description</h3>

<p>Run covr on a package and output the result so it is available on Azure Pipelines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azure(
  ...,
  coverage = package_coverage(..., quiet = quiet),
  filename = "coverage.xml",
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="azure_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="azure_+3A_coverage">coverage</code></td>
<td>
<p>an existing coverage object to submit, if <code>NULL</code>,
<code><a href="#topic+package_coverage">package_coverage()</a></code> will be called with the arguments from
<code>...</code></p>
</td></tr>
<tr><td><code id="azure_+3A_filename">filename</code></td>
<td>
<p>the name of the Cobertura XML file</p>
</td></tr>
<tr><td><code id="azure_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code>, print the coverage before submission.</p>
</td></tr>
</table>

<hr>
<h2 id='clear_counters'>clear all previous counters</h2><span id='topic+clear_counters'></span>

<h3>Description</h3>

<p>clear all previous counters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_counters()
</code></pre>

<hr>
<h2 id='code_coverage'>Calculate coverage of code directly</h2><span id='topic+code_coverage'></span>

<h3>Description</h3>

<p>This function is useful for testing, and is a thin wrapper around
<code><a href="#topic+file_coverage">file_coverage()</a></code> because parseData is not populated properly
unless the functions are defined in a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code_coverage(
  source_code,
  test_code,
  line_exclusions = NULL,
  function_exclusions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code_coverage_+3A_source_code">source_code</code></td>
<td>
<p>A character vector of source code</p>
</td></tr>
<tr><td><code id="code_coverage_+3A_test_code">test_code</code></td>
<td>
<p>A character vector of test code</p>
</td></tr>
<tr><td><code id="code_coverage_+3A_line_exclusions">line_exclusions</code></td>
<td>
<p>a named list of files with the lines to exclude from
each file.</p>
</td></tr>
<tr><td><code id="code_coverage_+3A_function_exclusions">function_exclusions</code></td>
<td>
<p>a vector of regular expressions matching function
names to exclude. Example <code style="white-space: pre;">&#8288;print\\\.&#8288;</code> to match print methods.</p>
</td></tr>
<tr><td><code id="code_coverage_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+file_coverage">file_coverage()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>source &lt;- "add &lt;- function(x, y) { x + y }"
test &lt;- "add(1, 2) == 3"
code_coverage(source, test)
</code></pre>

<hr>
<h2 id='codecov'>Run covr on a package and upload the result to codecov.io</h2><span id='topic+codecov'></span>

<h3>Description</h3>

<p>Run covr on a package and upload the result to codecov.io
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codecov(
  ...,
  coverage = NULL,
  base_url = "https://codecov.io",
  token = NULL,
  commit = NULL,
  branch = NULL,
  pr = NULL,
  flags = NULL,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codecov_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="codecov_+3A_coverage">coverage</code></td>
<td>
<p>an existing coverage object to submit, if <code>NULL</code>,
<code><a href="#topic+package_coverage">package_coverage()</a></code> will be called with the arguments from
<code>...</code></p>
</td></tr>
<tr><td><code id="codecov_+3A_base_url">base_url</code></td>
<td>
<p>Codecov url (change for Enterprise)</p>
</td></tr>
<tr><td><code id="codecov_+3A_token">token</code></td>
<td>
<p>a codecov upload token, if <code>NULL</code> then following external
sources will be checked in this order:
</p>

<ol>
<li><p> the environment variable &lsquo;CODECOV_TOKEN&rsquo;. If it is empty, then
</p>
</li>
<li><p> package will look at directory of the package for a file <code>codecov.yml</code>.
File must have <code>codecov</code> section where field <code>token</code> is set to a token that
will be used.
</p>
</li></ol>
</td></tr>
<tr><td><code id="codecov_+3A_commit">commit</code></td>
<td>
<p>explicitly set the commit this coverage result object
corresponds to. Is looked up from the service or locally if it is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="codecov_+3A_branch">branch</code></td>
<td>
<p>explicitly set the branch this coverage result object
corresponds to, this is looked up from the service or locally if it is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="codecov_+3A_pr">pr</code></td>
<td>
<p>explicitly set the pr this coverage result object corresponds to,
this is looked up from the service if it is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="codecov_+3A_flags">flags</code></td>
<td>
<p>A flag to use for this coverage upload see
<a href="https://docs.codecov.com/docs/flags">https://docs.codecov.com/docs/flags</a> for details.</p>
</td></tr>
<tr><td><code id="codecov_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code>, print the coverage before submission.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
codecov(path = "test")

## End(Not run)
</code></pre>

<hr>
<h2 id='count'>increment a given counter</h2><span id='topic+count'></span>

<h3>Description</h3>

<p>increment a given counter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_key">key</code></td>
<td>
<p>generated with <code><a href="#topic+key">key()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='count_test'>Append a test trace to a counter, updating global current test</h2><span id='topic+count_test'></span>

<h3>Description</h3>

<p>Append a test trace to a counter, updating global current test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_test(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_test_+3A_key">key</code></td>
<td>
<p>generated with <code><a href="#topic+key">key()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='coverage_to_list'>Convert a coverage dataset to a list</h2><span id='topic+coverage_to_list'></span>

<h3>Description</h3>

<p>Convert a coverage dataset to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage_to_list(x = package_coverage())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_to_list_+3A_x">x</code></td>
<td>
<p>a coverage dataset, defaults to running <code>package_coverage()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing coverage result for each individual file and the whole package
</p>

<hr>
<h2 id='coveralls'>Run covr on a package and upload the result to coveralls</h2><span id='topic+coveralls'></span>

<h3>Description</h3>

<p>Run covr on a package and upload the result to coveralls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coveralls(
  ...,
  coverage = NULL,
  repo_token = Sys.getenv("COVERALLS_TOKEN"),
  service_name = Sys.getenv("CI_NAME", "travis-ci"),
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coveralls_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="coveralls_+3A_coverage">coverage</code></td>
<td>
<p>an existing coverage object to submit, if <code>NULL</code>,
<code><a href="#topic+package_coverage">package_coverage()</a></code> will be called with the arguments from
<code>...</code></p>
</td></tr>
<tr><td><code id="coveralls_+3A_repo_token">repo_token</code></td>
<td>
<p>The secret repo token for your repository,
found at the bottom of your repository's page on Coveralls. This is useful
if your job is running on a service Coveralls doesn't support out-of-the-box.
If set to NULL, it is assumed that the job is running on travis-ci</p>
</td></tr>
<tr><td><code id="coveralls_+3A_service_name">service_name</code></td>
<td>
<p>the CI service to use, if environment variable
&lsquo;CI_NAME&rsquo; is set that is used, otherwise &lsquo;travis-ci&rsquo; is used.</p>
</td></tr>
<tr><td><code id="coveralls_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code>, print the coverage before submission.</p>
</td></tr>
</table>

<hr>
<h2 id='covr-package'>covr: Test coverage for packages</h2><span id='topic+covr'></span><span id='topic+covr-package'></span>

<h3>Description</h3>

<p>covr tracks and reports code coverage for your package and (optionally)
upload the results to a coverage service like 'Codecov' <a href="https://about.codecov.io">https://about.codecov.io</a> or
'Coveralls' <a href="https://coveralls.io">https://coveralls.io</a>. Code coverage is a measure of the amount of
code being exercised by a set of tests. It is an indirect measure of test
quality and completeness. This package is compatible with any testing
methodology or framework and tracks coverage of both R code and compiled
C/C++/FORTRAN code.
</p>


<h3>Details</h3>

<p>A coverage report can be used to inspect coverage for each line in your
package. Using <code>report()</code> requires the additional dependencies <code>DT</code> and <code>htmltools</code>.
</p>
<div class="sourceCode r"><pre># If run with no arguments `report()` implicitly calls `package_coverage()`
report()
</pre></div>


<h3>Package options</h3>

<p><code>covr</code> uses the following <code><a href="base.html#topic+options">options()</a></code> to configure behaviour:
</p>

<ul>
<li> <p><code>covr.covrignore</code>: A filename to use as an ignore file,
listing glob-style wildcarded paths of files to ignore for coverage
calculations. Defaults to the value of environment variable
<code>COVR_COVRIGNORE</code>, or <code>".covrignore"</code>  if the neither the option nor the
environment variable are set.
</p>
</li>
<li> <p><code>covr.exclude_end</code>: Used along with <code>covr.exclude_start</code>, an optional
regular expression which ends a line-exclusion region. For more
details, see <code>?exclusions</code>.
</p>
</li>
<li> <p><code>covr.exclude_pattern</code>: An optional line-exclusion pattern. Lines
which match the pattern will be excluded from coverage. For more details,
see <code>?exclusions</code>.
</p>
</li>
<li> <p><code>covr.exclude_start</code>: Used along with <code>covr.exclude_end</code>, an optional
regular expression which starts a line-exclusion region. For more
details, see <code>?exclusions</code>.
</p>
</li>
<li> <p><code>covr.filter_non_package</code>: If <code>TRUE</code> (the default behavior), coverage
of files outside the target package are filtered from coverage output.
</p>
</li>
<li> <p><code>covr.fix_parallel_mcexit</code>:
</p>
</li>
<li> <p><code>covr.flags</code>:
</p>
</li>
<li> <p><code>covr.gcov</code>: If the appropriate gcov version is not on your path you
can use this option to set the appropriate location. If set to &quot;&quot; it will
turn off coverage of compiled code.
</p>
</li>
<li> <p><code>covr.gcov_additional_paths</code>:
</p>
</li>
<li> <p><code>covr.gcov_args</code>:
</p>
</li>
<li> <p><code>covr.icov</code>:
</p>
</li>
<li> <p><code>covr.icov_args</code>:
</p>
</li>
<li> <p><code>covr.icov_flags</code>:
</p>
</li>
<li> <p><code>covr.icov_prof</code>:
</p>
</li>
<li> <p><code>covr.rstudio_source_markers</code>: A logical value. If <code>TRUE</code> (the
default behavior), source markers are displayed within the RStudio IDE
when using <code>zero_coverage</code>.
</p>
</li>
<li> <p><code>covr.record_tests</code>: If <code>TRUE</code> (default <code>NULL</code>), record a listing of
top level test expressions and associate tests with <code>covr</code> traces
evaluated during the test's execution. For more details, see
<code>?covr.record_tests</code>.
</p>
</li>
<li> <p><code>covr.showCfunctions</code>:
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jim Hester <a href="mailto:james.f.hester@gmail.com">james.f.hester@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Willem Ligtenberg [contributor]
</p>
</li>
<li><p> Kirill Müller [contributor]
</p>
</li>
<li><p> Henrik Bengtsson [contributor]
</p>
</li>
<li><p> Steve Peak [contributor]
</p>
</li>
<li><p> Kirill Sevastyanenko [contributor]
</p>
</li>
<li><p> Jon Clayden [contributor]
</p>
</li>
<li><p> Robert Flight [contributor]
</p>
</li>
<li><p> Eric Brown [contributor]
</p>
</li>
<li><p> Brodie Gaslam [contributor]
</p>
</li>
<li><p> Will Beasley [contributor]
</p>
</li>
<li><p> Robert Krzyzanowski [contributor]
</p>
</li>
<li><p> Markus Wamser [contributor]
</p>
</li>
<li><p> Karl Forner [contributor]
</p>
</li>
<li><p> Gergely Daróczi [contributor]
</p>
</li>
<li><p> Jouni Helske [contributor]
</p>
</li>
<li><p> Kun Ren [contributor]
</p>
</li>
<li><p> Jeroen Ooms [contributor]
</p>
</li>
<li><p> Ken Williams [contributor]
</p>
</li>
<li><p> Chris Campbell [contributor]
</p>
</li>
<li><p> David Hugh-Jones [contributor]
</p>
</li>
<li><p> Qin Wang [contributor]
</p>
</li>
<li><p> Doug Kelkhoff [contributor]
</p>
</li>
<li><p> Ivan Sagalaev (highlight.js library) [contributor, copyright holder]
</p>
</li>
<li><p> Mark Otto (Bootstrap library) [contributor]
</p>
</li>
<li><p> Jacob Thornton (Bootstrap library) [contributor]
</p>
</li>
<li><p>  Bootstrap contributors (Bootstrap library) [contributor]
</p>
</li>
<li><p>  Twitter, Inc (Bootstrap library) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://covr.r-lib.org">https://covr.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/covr">https://github.com/r-lib/covr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/covr/issues">https://github.com/r-lib/covr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='covr.record_tests'>Record Test Traces During Coverage Execution</h2><span id='topic+covr.record_tests'></span>

<h3>Description</h3>

<p>By setting <code>options(covr.record_tests = TRUE)</code>, the result of covr coverage
collection functions will include additional data pertaining to the tests
which are executed and an index of which tests, at what stack depth, trigger
the execution of each trace.
</p>


<h3>Details</h3>

<p>This functionality requires that the package code and tests are installed and
sourced with the source. For more details, refer to R options, <code>keep.source</code>,
<code>keep.source.pkgs</code> and <code>keep.parse.data.pkgs</code>.
</p>


<h3>Additional fields</h3>

<p>Within the <code>covr</code> result, you can explore this information in two places:
</p>

<ul>
<li> <p><code>attr(,"tests")</code>: A list of call stacks, which results in target code
execution.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$&lt;srcref&gt;$tests&#8288;</code>: For each srcref count in the coverage object, a
<code style="white-space: pre;">&#8288;$tests&#8288;</code> field is now included which contains a matrix with three columns,
&quot;test&quot;, &quot;depth&quot; and &quot;i&quot; which specify the test number (corresponding to the
index of the test in <code>attr(,"tests")</code>, the stack depth into the target
code where the trace was executed, and the order of execution for each
test.
</p>
</li></ul>



<h3>Test traces</h3>

<p>The content of test traces are dependent on the unit testing framework that
is used by the target package. The behavior is contingent on the available
information in the sources kept for the testing files.
</p>
<p>Test traces are extracted by the following criteria:
</p>

<ol>
<li><p> If any <code>srcref</code> files are are provided by a file within <a href="#topic+covr">covr</a>'s temporary
library, all calls from those files are kept as a test trace. This will
collect traces from tests run with common testing frameworks such as
<code>testthat</code> and <code>RUnit</code>.
</p>
</li>
<li><p> Otherwise, as a conservative fallback in situations where no source
references are found, or when none are from within the temporary
directory, the entire call stack is collected.
</p>
</li></ol>

<p>These calls are subsequently subset for only those up until the call to
<a href="#topic+covr">covr</a>'s internal <code>count</code> function, and will always include the last call in
the call stack prior to a call to <code>count</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fcode &lt;- '
f &lt;- function(x) {
  if (x)
    f(!x)
  else
    FALSE
}'

options(covr.record_tests = TRUE)
cov &lt;- code_coverage(fcode, "f(TRUE)")

# extract executed test code for the first test
tail(attr(cov, "tests")[[1L]], 1L)
# [[1]]
# f(TRUE)

# extract test itemization per trace
cov[[3]][c("srcref", "tests")]
# $srcref
# f(!x)
#
# $tests
#      test depth i
# [1,]    1     2 4

# reconstruct the code path of a test by ordering test traces by [,"i"]
lapply(cov, `[[`, "tests")
# $`source.Ref2326138c55:4:6:4:10:6:10:4:4`
#      test depth i
# [1,]    1     1 2
#
# $`source.Ref2326138c55:3:8:3:8:8:8:3:3`
#      test depth i
# [1,]    1     1 1
# [2,]    1     2 3
#
# $`source.Ref2326138c55:6:6:6:10:6:10:6:6`
#      test depth i
# [1,]    1     2 4

</code></pre>

<hr>
<h2 id='display_name'>Retrieve the path name (filename) for each coverage object</h2><span id='topic+display_name'></span>

<h3>Description</h3>

<p>Retrieve the path name (filename) for each coverage object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_name_+3A_x">x</code></td>
<td>
<p>A coverage object</p>
</td></tr>
</table>

<hr>
<h2 id='environment_coverage'>Calculate coverage of an environment</h2><span id='topic+environment_coverage'></span>

<h3>Description</h3>

<p>Calculate coverage of an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>environment_coverage(
  env = parent.frame(),
  test_files,
  line_exclusions = NULL,
  function_exclusions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="environment_coverage_+3A_env">env</code></td>
<td>
<p>The environment to be instrumented.</p>
</td></tr>
<tr><td><code id="environment_coverage_+3A_test_files">test_files</code></td>
<td>
<p>Character vector of test files with code to test the
functions</p>
</td></tr>
<tr><td><code id="environment_coverage_+3A_line_exclusions">line_exclusions</code></td>
<td>
<p>a named list of files with the lines to exclude from
each file.</p>
</td></tr>
<tr><td><code id="environment_coverage_+3A_function_exclusions">function_exclusions</code></td>
<td>
<p>a vector of regular expressions matching function
names to exclude. Example <code style="white-space: pre;">&#8288;print\\\.&#8288;</code> to match print methods.</p>
</td></tr>
</table>

<hr>
<h2 id='exclusions'>Exclusions</h2><span id='topic+exclusions'></span>

<h3>Description</h3>

<p>covr supports a couple of different ways of excluding some or all of a file.
</p>


<h3>Line Exclusions</h3>

<p>The <code>line_exclusions</code> argument to <code>package_coverage()</code> can be used
to exclude some or all of a file.  This argument takes a list of filenames
or named ranges to exclude.
</p>


<h3>Function Exclusions</h3>

<p>Alternatively <code>function_exclusions</code> can be used to exclude R functions
based on regular expression(s). For example <code style="white-space: pre;">&#8288;print\\\.*&#8288;</code> can be used to
exclude all the print methods defined in a package from coverage.
</p>


<h3>Exclusion Comments</h3>

<p>In addition you can exclude lines from the coverage by putting special comments
in your source code. This can be done per line or by specifying a range.
The patterns used can be specified by the <code>exclude_pattern</code>, <code>exclude_start</code>,
<code>exclude_end</code> arguments to <code>package_coverage()</code> or by setting the global
options <code>covr.exclude_pattern</code>, <code>covr.exclude_start</code>, <code>covr.exclude_end</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# exclude whole file of R/test.R
package_coverage(exclusions = "R/test.R")

# exclude lines 1 to 10 and 15 from R/test.R
package_coverage(line_exclusions = list("R/test.R" = c(1:10, 15)))

# exclude lines 1 to 10 from R/test.R, all of R/test2.R
package_coverage(line_exclusions = list("R/test.R" = 1:10, "R/test2.R"))

# exclude all print and format methods from the package.
package_coverage(function_exclusions = c("print\\.", "format\\."))

# single line exclusions
f1 &lt;- function(x) {
  x + 1 # nocov
}

# ranged exclusions
f2 &lt;- function(x) { # nocov start
  x + 2
} # nocov end

## End(Not run)
</code></pre>

<hr>
<h2 id='file_coverage'>Calculate test coverage for sets of files</h2><span id='topic+file_coverage'></span>

<h3>Description</h3>

<p>The files in <code>source_files</code> are first sourced into a new environment
to define functions to be checked. Then they are instrumented to track
coverage and the files in <code>test_files</code> are sourced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_coverage(
  source_files,
  test_files,
  line_exclusions = NULL,
  function_exclusions = NULL,
  parent_env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_coverage_+3A_source_files">source_files</code></td>
<td>
<p>Character vector of source files with function
definitions to measure coverage</p>
</td></tr>
<tr><td><code id="file_coverage_+3A_test_files">test_files</code></td>
<td>
<p>Character vector of test files with code to test the
functions</p>
</td></tr>
<tr><td><code id="file_coverage_+3A_line_exclusions">line_exclusions</code></td>
<td>
<p>a named list of files with the lines to exclude from
each file.</p>
</td></tr>
<tr><td><code id="file_coverage_+3A_function_exclusions">function_exclusions</code></td>
<td>
<p>a vector of regular expressions matching function
names to exclude. Example <code style="white-space: pre;">&#8288;print\\\.&#8288;</code> to match print methods.</p>
</td></tr>
<tr><td><code id="file_coverage_+3A_parent_env">parent_env</code></td>
<td>
<p>The parent environment to use when sourcing the files.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># For the purpose of this example, save code containing code and tests to files
cat("add &lt;- function(x, y) { x + y }", file="add.R")
cat("add(1, 2) == 3", file="add_test.R")

# Use file_coverage() to calculate test coverage
file_coverage(source_files = "add.R", test_files = "add_test.R")

# cleanup
file.remove(c("add.R", "add_test.R"))
</code></pre>

<hr>
<h2 id='file_report'>A coverage report for a specific file</h2><span id='topic+file_report'></span>

<h3>Description</h3>

<p>A coverage report for a specific file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_report(
  x = package_coverage(),
  file = NULL,
  out_file = file.path(tempdir(), paste0(get_package_name(x), "-file-report.html")),
  browse = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_report_+3A_x">x</code></td>
<td>
<p>a coverage dataset, defaults to running <code>package_coverage()</code>.</p>
</td></tr>
<tr><td><code id="file_report_+3A_file">file</code></td>
<td>
<p>The file to report on, if <code>NULL</code>, use the first file in the
coverage output.</p>
</td></tr>
<tr><td><code id="file_report_+3A_out_file">out_file</code></td>
<td>
<p>The output file</p>
</td></tr>
<tr><td><code id="file_report_+3A_browse">browse</code></td>
<td>
<p>whether to open a browser to view the report.</p>
</td></tr>
</table>

<hr>
<h2 id='function_coverage'>Calculate test coverage for a specific function.</h2><span id='topic+function_coverage'></span>

<h3>Description</h3>

<p>Calculate test coverage for a specific function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_coverage(fun, code = NULL, env = NULL, enc = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="function_coverage_+3A_fun">fun</code></td>
<td>
<p>name of the function.</p>
</td></tr>
<tr><td><code id="function_coverage_+3A_code">code</code></td>
<td>
<p>expressions to run.</p>
</td></tr>
<tr><td><code id="function_coverage_+3A_env">env</code></td>
<td>
<p>environment the function is defined in.</p>
</td></tr>
<tr><td><code id="function_coverage_+3A_enc">enc</code></td>
<td>
<p>the enclosing environment which to run the expressions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>add &lt;- function(x, y) { x + y }
function_coverage(fun = add, code = NULL) # 0% coverage
function_coverage(fun = add, code = add(1, 2) == 3) # 100% coverage
</code></pre>

<hr>
<h2 id='gitlab'>Run covr on package and create report for GitLab</h2><span id='topic+gitlab'></span>

<h3>Description</h3>

<p>Utilize internal GitLab static pages to publish package coverage.
Creates local covr report in a package subdirectory.
Uses the <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#pages">pages</a>
GitLab job to publish the report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gitlab(..., coverage = NULL, file = "public/coverage.html", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gitlab_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="gitlab_+3A_coverage">coverage</code></td>
<td>
<p>an existing coverage object to submit, if <code>NULL</code>,
<code><a href="#topic+package_coverage">package_coverage()</a></code> will be called with the arguments from
<code>...</code></p>
</td></tr>
<tr><td><code id="gitlab_+3A_file">file</code></td>
<td>
<p>The report filename.</p>
</td></tr>
<tr><td><code id="gitlab_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code>, print the coverage before submission.</p>
</td></tr>
</table>

<hr>
<h2 id='has_srcref'>Is the source bound to the expression</h2><span id='topic+has_srcref'></span>

<h3>Description</h3>

<p>Is the source bound to the expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_srcref(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_srcref_+3A_expr">expr</code></td>
<td>
<p>A language object which may have a <code>srcref</code> attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the language object has source
</p>

<hr>
<h2 id='in_covr'>Determine if code is being run in covr</h2><span id='topic+in_covr'></span>

<h3>Description</h3>

<p>covr functions set the environment variable <code>R_COVR</code> when they are running.
<code><a href="#topic+in_covr">in_covr()</a></code> returns <code>TRUE</code> if this environment variable is set and <code>FALSE</code>
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_covr()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(testthat)) {
  testthat::skip_if(in_covr())
}
</code></pre>

<hr>
<h2 id='is_covr_count_call'>Is the expression a call to covr:::count</h2><span id='topic+is_covr_count_call'></span>

<h3>Description</h3>

<p>Is the expression a call to covr:::count
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_covr_count_call(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_covr_count_call_+3A_expr">expr</code></td>
<td>
<p>A language object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the object is a call to
<code>covr:::count</code>.
</p>

<hr>
<h2 id='is_current_test_finished'>Returns TRUE if we've moved on from test reflected in .current_test</h2><span id='topic+is_current_test_finished'></span>

<h3>Description</h3>

<p>Quickly dismiss the need to update the current test if we can. To test if
we're still in the last test, check if the same srcref (or call, if source is
not kept) exists at the last recorded calling frame prior to entering a covr
trace. If this has changed, do a more comprehensive test to see if any of the
test call stack has changed, in which case we are onto a new test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_current_test_finished()
</code></pre>

<hr>
<h2 id='key'>Generate a key for a  call</h2><span id='topic+key'></span>

<h3>Description</h3>

<p>Generate a key for a  call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_+3A_x">x</code></td>
<td>
<p>the srcref of the call to create a key for</p>
</td></tr>
</table>

<hr>
<h2 id='new_counter'>initialize a new counter</h2><span id='topic+new_counter'></span>

<h3>Description</h3>

<p>initialize a new counter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_counter(src_ref, parent_functions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_counter_+3A_src_ref">src_ref</code></td>
<td>
<p>a <code><a href="base.html#topic+srcfile">base::srcref()</a></code></p>
</td></tr>
<tr><td><code id="new_counter_+3A_parent_functions">parent_functions</code></td>
<td>
<p>the functions that this srcref is contained in.</p>
</td></tr>
</table>

<hr>
<h2 id='new_test_counter'>Initialize a new test counter for a coverage trace</h2><span id='topic+new_test_counter'></span>

<h3>Description</h3>

<p>Initialize a test counter, a matrix used to tally tests, their stack depth
and the execution order as the trace associated with <code>key</code> is hit. Each
test trace is an environment, which allows assignment into a pre-allocated
<code>tests</code> matrix with minimall reallocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_test_counter(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_test_counter_+3A_key">key</code></td>
<td>
<p>generated with <code><a href="#topic+key">key()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tests</code> matrix has columns <code>tests</code>, <code>depth</code> and <code>i</code>,
corresponding to the test index (the index of the associated test in
<code>.counters$tests</code>), the stack depth when the trace is evaluated and the
number of traces that have been hit so far during test evaluation.
</p>

<hr>
<h2 id='package_coverage'>Calculate test coverage for a package</h2><span id='topic+package_coverage'></span>

<h3>Description</h3>

<p>This function calculates the test coverage for a development package on the
<code>path</code>. By default it runs only the package tests, but it can also run
vignette and example code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>package_coverage(
  path = ".",
  type = c("tests", "vignettes", "examples", "all", "none"),
  combine_types = TRUE,
  relative_path = TRUE,
  quiet = TRUE,
  clean = TRUE,
  line_exclusions = NULL,
  function_exclusions = NULL,
  code = character(),
  install_path = temp_file("R_LIBS"),
  ...,
  exclusions,
  pre_clean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="package_coverage_+3A_path">path</code></td>
<td>
<p>file path to the package.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_type">type</code></td>
<td>
<p>run the package &lsquo;tests&rsquo;, &lsquo;vignettes&rsquo;,
&lsquo;examples&rsquo;, &lsquo;all&rsquo;, or &lsquo;none&rsquo;. The default is
&lsquo;tests&rsquo;.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_combine_types">combine_types</code></td>
<td>
<p>If <code>TRUE</code> (the default) the coverage for all types
is simply summed into one coverage object. If <code>FALSE</code> separate objects
are used for each type of coverage.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_relative_path">relative_path</code></td>
<td>
<p>whether to output the paths as relative or absolute
paths. If a string, it is interpreted as a root path and all paths will be
relative to that root.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_quiet">quiet</code></td>
<td>
<p>whether to load and compile the package quietly, useful for
debugging errors.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_clean">clean</code></td>
<td>
<p>whether to clean temporary output files after running, mainly
useful for debugging errors.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_line_exclusions">line_exclusions</code></td>
<td>
<p>a named list of files with the lines to exclude from
each file.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_function_exclusions">function_exclusions</code></td>
<td>
<p>a vector of regular expressions matching function
names to exclude. Example <code style="white-space: pre;">&#8288;print\\\.&#8288;</code> to match print methods.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_code">code</code></td>
<td>
<p>A character vector of additional test code to run.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_install_path">install_path</code></td>
<td>
<p>The path the instrumented package will be installed to
and tests run in. By default it is a path in the R sessions temporary
directory. It can sometimes be useful to set this (along with <code>clean = FALSE</code>) to help debug test failures.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="tools.html#topic+testInstalledPackage">tools::testInstalledPackage()</a></code>.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_exclusions">exclusions</code></td>
<td>
<p>&lsquo;Deprecated&rsquo;, please use &lsquo;line_exclusions&rsquo; instead.</p>
</td></tr>
<tr><td><code id="package_coverage_+3A_pre_clean">pre_clean</code></td>
<td>
<p>whether to delete all objects present in the src directory before recompiling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="tools.html#topic+testInstalledPackage">tools::testInstalledPackage()</a></code> to run the
code, if you would like to test your package in another way you can set
<code>type = "none"</code> and pass the code to run as a character vector to the
<code>code</code> parameter.
</p>
<p>Parallelized code using <span class="pkg">parallel</span>'s <code><a href="parallel.html#topic+mcparallel">mcparallel()</a></code> needs to
use a patched <code>parallel:::mcexit</code>. This is done automatically if the
package depends on <span class="pkg">parallel</span>, but can also be explicitly set using the
environment variable <code>COVR_FIX_PARALLEL_MCEXIT</code> or the global option
<code>covr.fix_parallel_mcexit</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exclusions">exclusions()</a></code> For details on excluding parts of the
package from the coverage calculations.
</p>

<hr>
<h2 id='percent_coverage'>Provide percent coverage of package</h2><span id='topic+percent_coverage'></span>

<h3>Description</h3>

<p>Calculate the total percent coverage from a coverage result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent_coverage(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_coverage_+3A_x">x</code></td>
<td>
<p>the coverage object returned from <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="percent_coverage_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+tally_coverage">tally_coverage()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total percentage as a <code>numeric(1)</code>.
</p>

<hr>
<h2 id='print.coverage'>Print a coverage object</h2><span id='topic+print.coverage'></span>

<h3>Description</h3>

<p>Print a coverage object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coverage'
print(x, group = c("filename", "functions"), by = "line", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coverage_+3A_x">x</code></td>
<td>
<p>the coverage object to be printed</p>
</td></tr>
<tr><td><code id="print.coverage_+3A_group">group</code></td>
<td>
<p>whether to group coverage by filename or function</p>
</td></tr>
<tr><td><code id="print.coverage_+3A_by">by</code></td>
<td>
<p>whether to count coverage by line or expression</p>
</td></tr>
<tr><td><code id="print.coverage_+3A_...">...</code></td>
<td>
<p>additional arguments ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coverage object (invisibly).
</p>

<hr>
<h2 id='report'>Display covr results using a standalone report</h2><span id='topic+report'></span>

<h3>Description</h3>

<p>Display covr results using a standalone report
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(
  x = package_coverage(),
  file = file.path(tempdir(), paste0(get_package_name(x), "-report.html")),
  browse = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_+3A_x">x</code></td>
<td>
<p>a coverage dataset, defaults to running <code>package_coverage()</code>.</p>
</td></tr>
<tr><td><code id="report_+3A_file">file</code></td>
<td>
<p>The report filename.</p>
</td></tr>
<tr><td><code id="report_+3A_browse">browse</code></td>
<td>
<p>whether to open a browser to view the report.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- package_coverage()
report(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='system_check'>Run a system command and check if it succeeds.</h2><span id='topic+system_check'></span>

<h3>Description</h3>

<p>This function automatically quotes both the command and each
argument so they are properly protected from shell expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system_check(
  cmd,
  args = character(),
  env = character(),
  quiet = FALSE,
  echo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="system_check_+3A_cmd">cmd</code></td>
<td>
<p>the command to run.</p>
</td></tr>
<tr><td><code id="system_check_+3A_args">args</code></td>
<td>
<p>a vector of command arguments.</p>
</td></tr>
<tr><td><code id="system_check_+3A_env">env</code></td>
<td>
<p>a named character vector of environment variables.  Will be quoted</p>
</td></tr>
<tr><td><code id="system_check_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code>, the command output will be echoed.</p>
</td></tr>
<tr><td><code id="system_check_+3A_echo">echo</code></td>
<td>
<p>if <code>TRUE</code>, the command to run will be echoed.</p>
</td></tr>
<tr><td><code id="system_check_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+system">base::system()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the command succeeds, an error will be thrown if the
command fails.
</p>

<hr>
<h2 id='system_output'>Run a system command and capture the output.</h2><span id='topic+system_output'></span>

<h3>Description</h3>

<p>This function automatically quotes both the command and each
argument so they are properly protected from shell expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system_output(
  cmd,
  args = character(),
  env = character(),
  quiet = FALSE,
  echo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="system_output_+3A_cmd">cmd</code></td>
<td>
<p>the command to run.</p>
</td></tr>
<tr><td><code id="system_output_+3A_args">args</code></td>
<td>
<p>a vector of command arguments.</p>
</td></tr>
<tr><td><code id="system_output_+3A_env">env</code></td>
<td>
<p>a named character vector of environment variables.  Will be quoted</p>
</td></tr>
<tr><td><code id="system_output_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code>, the command output will be echoed.</p>
</td></tr>
<tr><td><code id="system_output_+3A_echo">echo</code></td>
<td>
<p>if <code>TRUE</code>, the command to run will be echoed.</p>
</td></tr>
<tr><td><code id="system_output_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+system">base::system()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>command output if the command succeeds, an error will be thrown if
the command fails.
</p>

<hr>
<h2 id='tally_coverage'>Tally coverage by line or expression</h2><span id='topic+tally_coverage'></span>

<h3>Description</h3>

<p>Tally coverage by line or expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tally_coverage(x, by = c("line", "expression"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tally_coverage_+3A_x">x</code></td>
<td>
<p>the coverage object returned from <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="tally_coverage_+3A_by">by</code></td>
<td>
<p>whether to tally coverage by line or expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> of coverage tallied by line or expression.
</p>

<hr>
<h2 id='to_cobertura'>Create a Cobertura XML file</h2><span id='topic+to_cobertura'></span>

<h3>Description</h3>

<p>Create a
cobertura-compliant XML report following <a href="https://github.com/cobertura/cobertura/blob/master/cobertura/src/site/htdocs/xml/coverage-04.dtd">this DTD</a>.
Because there are <em>two</em> DTDs called <code style="white-space: pre;">&#8288;coverage-04.dtd&#8288;</code> and some tools do not seem to
adhere to either of them, the parser you're using may balk at the file. Please see
<a href="https://github.com/cobertura/cobertura/issues/425">this github discussion</a> for
context. Where <code>covr</code> doesn't provide a coverage metric (branch coverage,
complexity), a zero is reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_cobertura(cov, filename = "cobertura.xml")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_cobertura_+3A_cov">cov</code></td>
<td>
<p>the coverage object returned from <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="to_cobertura_+3A_filename">filename</code></td>
<td>
<p>the name of the Cobertura XML file</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Note</em>: This functionality requires the xml2 package be installed.
</p>

<hr>
<h2 id='to_sonarqube'>Create a SonarQube Generic XML file for test coverage according to
https://docs.sonarqube.org/latest/analysis/generic-test/
Based on cobertura.R</h2><span id='topic+to_sonarqube'></span>

<h3>Description</h3>

<p>This functionality requires the xml2 package be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_sonarqube(cov, filename = "sonarqube.xml")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_sonarqube_+3A_cov">cov</code></td>
<td>
<p>the coverage object returned from <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="to_sonarqube_+3A_filename">filename</code></td>
<td>
<p>the name of the SonarQube Generic XML file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Talkdesk Inc.
</p>

<hr>
<h2 id='trace_calls'>trace each call with a srcref attribute</h2><span id='topic+trace_calls'></span>

<h3>Description</h3>

<p>This function calls itself recursively so it can properly traverse the AST.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_calls(x, parent_functions = NULL, parent_ref = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_calls_+3A_x">x</code></td>
<td>
<p>the call</p>
</td></tr>
<tr><td><code id="trace_calls_+3A_parent_functions">parent_functions</code></td>
<td>
<p>the functions which this call is a child of.</p>
</td></tr>
<tr><td><code id="trace_calls_+3A_parent_ref">parent_ref</code></td>
<td>
<p>argument used to set the srcref of the current call during
the recursion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified expression with count calls inserted before each previous
call.
</p>


<h3>See Also</h3>

<p><a href="http://adv-r.had.co.nz/Expressions.html">http://adv-r.had.co.nz/Expressions.html</a>
</p>

<hr>
<h2 id='truncate_call'>Truncate call objects to limit the number of arguments</h2><span id='topic+truncate_call'></span>

<h3>Description</h3>

<p>A helper to circumvent R errors when deserializing large call objects from
Rds. Trims the number of arguments in a call object, and replaces the last
argument with a <code style="white-space: pre;">&#8288;&lt;truncated&gt;&#8288;</code> symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_call(call_obj, limit = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_call_+3A_call_obj">call_obj</code></td>
<td>
<p>A (possibly large) <code>call</code> object</p>
</td></tr>
<tr><td><code id="truncate_call_+3A_limit">limit</code></td>
<td>
<p>A <code>call</code> length limit to impose</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call_obj</code> with arguments trimmed
</p>

<hr>
<h2 id='update_current_test'>Update current test if unit test expression has progressed</h2><span id='topic+update_current_test'></span>

<h3>Description</h3>

<p>Updating a test logs some metadata regarding the current call stack, noteably
trying to capture information about the call stack prior to the covr::count
call being traced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_current_test()
</code></pre>


<h3>Details</h3>

<p>There are a couple patterns of behavior, which try to accommodate a variety
of testing suites:
</p>

<ul>
<li> <p><code>testthat</code>: During execution of <code>testthat</code>'s <code style="white-space: pre;">&#8288;test_*&#8288;</code> functions,
files are sourced and the working directory is temporarily changed to the
package <code style="white-space: pre;">&#8288;/tests&#8288;</code> directory. Knowing this, calls in the call stack which
are relative to this directory are extracted and recorded.
</p>
</li>
<li> <p><code>RUnit</code>:
</p>
</li>
<li> <p><code>custom</code>: Any other custom test suites may not have source kept with
their execution, in which case the entire test call stack is kept.
</p>
</li></ul>

<p>checks to see if the current call stack has the same
<code>srcref</code> (or expression, if no source is available) at the same frame prior
to entering into a package where <code>covr:::count</code> is called.
</p>

<hr>
<h2 id='value'>Retrieve the value from an object</h2><span id='topic+value'></span>

<h3>Description</h3>

<p>Retrieve the value from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_+3A_x">x</code></td>
<td>
<p>object from which to retrieve the value</p>
</td></tr>
<tr><td><code id="value_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>

<hr>
<h2 id='zero_coverage'>Provide locations of zero coverage</h2><span id='topic+zero_coverage'></span>

<h3>Description</h3>

<p>When examining the test coverage of a package, it is useful to know if there are
any locations where there is <strong>0</strong> test coverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_coverage(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_coverage_+3A_x">x</code></td>
<td>
<p>a coverage object returned <code><a href="#topic+package_coverage">package_coverage()</a></code></p>
</td></tr>
<tr><td><code id="zero_coverage_+3A_...">...</code></td>
<td>
<p>additional arguments passed to
<code><a href="#topic+tally_coverage">tally_coverage()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>if used within RStudio this function outputs the results using the
Marker API.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with coverage data where the coverage is 0.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
