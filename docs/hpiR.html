<!DOCTYPE html><html><head><title>Help for package hpiR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hpiR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hpiR'><p>hpiR: A package for house price indexes</p></a></li>
<li><a href='#buildForecastIDs'><p>Create the row IDs for forecast accuracy</p></a></li>
<li><a href='#buildForecastIDs.heddata'><p>Create the row IDs for forecast accuracy (hed approach)</p></a></li>
<li><a href='#buildForecastIDs.rtdata'><p>Create the row IDs for forecast accuracy (rt approach)</p></a></li>
<li><a href='#calcAccuracy'><p>Calculate the accuracy of an index</p></a></li>
<li><a href='#calcForecastError'><p>Calculate the forecast accuracy of series of indexes</p></a></li>
<li><a href='#calcInSampleError'><p>Calculate index errors in sample</p></a></li>
<li><a href='#calcInSampleError.heddata'><p>Calculate index errors in sample (hed approach)</p></a></li>
<li><a href='#calcInSampleError.rtdata'><p>Calculate index errors in sample (rt approach)</p></a></li>
<li><a href='#calcKFoldError'><p>Calculate index error with FKold (out of sample)</p></a></li>
<li><a href='#calcRevision'><p>Calculate revision values of an index</p></a></li>
<li><a href='#calcSeriesAccuracy'><p>Calculate the accuracy of a series of indexes</p></a></li>
<li><a href='#calcSeriesVolatility'><p>Calculate volatility of a series of indexes</p></a></li>
<li><a href='#calcVolatility'><p>Calculate index volatility</p></a></li>
<li><a href='#checkDate'><p>Validate the date argument</p></a></li>
<li><a href='#createKFoldData'><p>Create data for KFold error test</p></a></li>
<li><a href='#createKFoldData.rtdata'><p>Create data for KFold error test (rt approach)</p></a></li>
<li><a href='#createSeries'><p>Create a series of indexes</p></a></li>
<li><a href='#dateToPeriod'><p>Convert dates to a relative period</p></a></li>
<li><a href='#ex_sales'><p>Subset of Seattle Home Sales</p></a></li>
<li><a href='#hedCreateTrans'><p>Create data for 'hed' approach</p></a></li>
<li><a href='#hedIndex'><p>Create a full index object by hedonic approach</p></a></li>
<li><a href='#hedModel'><p>Estimate hedonic model for index creation</p></a></li>
<li><a href='#hedModel.base'><p>Hedonic model approach with base estimator</p></a></li>
<li><a href='#hedModel.robust'><p>Hedonic model approach with robust estimator</p></a></li>
<li><a href='#hedModel.weighted'><p>Hedonic model approach with weighted estimator</p></a></li>
<li><a href='#hpiModel'><p>Wrapper to estimate model approaches (generic method)</p></a></li>
<li><a href='#hpiModel.hed'><p>Specific method for hpi modeling (hed) approach)</p></a></li>
<li><a href='#hpiModel.rf'><p>Specific method for hpi modeling (hed) approach)</p></a></li>
<li><a href='#hpiModel.rt'><p>Specific method for hpi modeling (rt approach)</p></a></li>
<li><a href='#matchKFold'><p>Helper function to make KFold data</p></a></li>
<li><a href='#matchKFold.heddata'><p>Helper function to make KFold data</p></a></li>
<li><a href='#matchKFold.rtdata'><p>Helper function to make KFold data</p></a></li>
<li><a href='#modelToIndex'><p>Convert model results into a house price index</p></a></li>
<li><a href='#plot.hpi'><p>Plot method for 'hpi' object</p></a></li>
<li><a href='#plot.hpiaccuracy'><p>Plot method for 'hpiaccuracy' object</p></a></li>
<li><a href='#plot.hpiindex'><p>Plot method for 'hpiindex' object</p></a></li>
<li><a href='#plot.indexvolatility'><p>Plot method for 'indexvolatility' object</p></a></li>
<li><a href='#plot.seriesaccuracy'><p>Plot method for 'seriesaccuracy' object</p></a></li>
<li><a href='#plot.serieshpi'><p>Plot method for 'serieshpi' object</p></a></li>
<li><a href='#plot.seriesrevision'><p>Plot method for 'seriesrevision' object</p></a></li>
<li><a href='#rfIndex'><p>Create a full index object by random forest approach</p></a></li>
<li><a href='#rfModel'><p>Estimate random forest model for index creation</p></a></li>
<li><a href='#rfModel.pdp'><p>Random forest model approach with pdp estimator</p></a></li>
<li><a href='#rfSimDf'><p>Create simulation data for Random forest approach</p></a></li>
<li><a href='#rtCreateTrans'><p>Create transaction data for rt approach</p></a></li>
<li><a href='#rtIndex'><p>Create a full index object by repeat transaction approach</p></a></li>
<li><a href='#rtModel'><p>Estimate repeat transaction model for index creation</p></a></li>
<li><a href='#rtModel.base'><p>Repeat transaction model approach with base estimator</p></a></li>
<li><a href='#rtModel.robust'><p>Repeat transaction model approach with robust estimator</p></a></li>
<li><a href='#rtModel.weighted'><p>Repeat transaction model approach with weighted estimator</p></a></li>
<li><a href='#rtTimeMatrix'><p>Create model matrix for repeat transaction approach</p></a></li>
<li><a href='#seattle_sales'><p>Seattle Home Sales</p></a></li>
<li><a href='#smoothIndex'><p>Smooth an index</p></a></li>
<li><a href='#smoothSeries'><p>Smooth all indexes in a series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>House Price Indexes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andy Krause &lt;andyxkrause@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute house price indexes and series using a variety of different methods and
    models common through the real estate literature.  Evaluate index 'goodness' based
    on accuracy, volatility and revision statistics. Background on basic model construction
    for repeat sales models can be found at: Case and Quigley (1991) 
    <a href="https://ideas.repec.org/a/tpr/restat/v73y1991i1p50-58.html">https://ideas.repec.org/a/tpr/restat/v73y1991i1p50-58.html</a> and for hedonic pricing models at: 
    Bourassa et al (2006) &lt;<a href="https://doi.org/10.1016%2Fj.jhe.2006.03.001">doi:10.1016/j.jhe.2006.03.001</a>&gt;. The package author's working paper on the 
    random forest approach to house price indexes can be found at: <a href="http://www.github.com/andykrause/hpi_research">http://www.github.com/andykrause/hpi_research</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, lubridate, robustbase, ggplot2, imputeTS (&ge;
3.0), purrr, forecast, gridExtra, MASS, rlang, plyr, zoo,
ranger, pdp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.github.com/andykrause/hpiR">https://www.github.com/andykrause/hpiR</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>markdown, testthat, covr, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-01 15:24:12 UTC; andyk</td>
</tr>
<tr>
<td>Author:</td>
<td>Andy Krause [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-01 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hpiR'>hpiR: A package for house price indexes</h2><span id='topic+hpiR'></span><span id='topic+hpiR-package'></span>

<h3>Description</h3>

<p>House Price Indexes in R: A set of tools to create house price indexes and analyze
their various performance metrics.
</p>

<hr>
<h2 id='buildForecastIDs'>Create the row IDs for forecast accuracy</h2><span id='topic+buildForecastIDs'></span>

<h3>Description</h3>

<p>Generate a vector of row IDs for use in forecast accuracy tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildForecastIDs(time_cut, hpi_df, forecast_length = 1, train = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildForecastIDs_+3A_time_cut">time_cut</code></td>
<td>
<p>Period after which to cut off data</p>
</td></tr>
<tr><td><code id="buildForecastIDs_+3A_hpi_df">hpi_df</code></td>
<td>
<p>Data to be converted to training or scoring</p>
</td></tr>
<tr><td><code id="buildForecastIDs_+3A_forecast_length">forecast_length</code></td>
<td>
<p>default = 1; Length of forecasting to do</p>
</td></tr>
<tr><td><code id="buildForecastIDs_+3A_train">train</code></td>
<td>
<p>Default=TRUE; Create training data?  FALSE = Scoring data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of row_ids indicating inclusion in the forecasting data as either the
training set (train = TRUE) or the scoring set (train = FALSE)
</p>


<h3>Further Details</h3>

<p>This function is rarely (if ever) used directly.  Most often called by
'calcForecastError()'
</p>
<p>It is a generic method that dispatches on the 'hpi_df' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Load example sales
 data(ex_sales)

 # Create RT data
 rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date')

# Create ids
  fc_ids &lt;- buildForecastIDs(time_cut = 27,
                             hpi_df = rt_data,
                             forecast_length = 2,
                             train = TRUE)

</code></pre>

<hr>
<h2 id='buildForecastIDs.heddata'>Create the row IDs for forecast accuracy (hed approach)</h2><span id='topic+buildForecastIDs.heddata'></span>

<h3>Description</h3>

<p>Generate a vector of row IDs for use in forecast accuracy tests (hed approach)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'heddata'
buildForecastIDs(time_cut, hpi_df, forecast_length = 1,
  train = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildForecastIDs.heddata_+3A_time_cut">time_cut</code></td>
<td>
<p>Period after which to cut off data</p>
</td></tr>
<tr><td><code id="buildForecastIDs.heddata_+3A_hpi_df">hpi_df</code></td>
<td>
<p>Data to be converted to training or scoring</p>
</td></tr>
<tr><td><code id="buildForecastIDs.heddata_+3A_forecast_length">forecast_length</code></td>
<td>
<p>default = 1; Length of forecasting to do</p>
</td></tr>
<tr><td><code id="buildForecastIDs.heddata_+3A_train">train</code></td>
<td>
<p>Default=TRUE; Create training data?  FALSE = Scoring data</p>
</td></tr>
</table>

<hr>
<h2 id='buildForecastIDs.rtdata'>Create the row IDs for forecast accuracy (rt approach)</h2><span id='topic+buildForecastIDs.rtdata'></span>

<h3>Description</h3>

<p>Generate a vector of row IDs for use in forecast accuracy tests (rt approach)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rtdata'
buildForecastIDs(time_cut, hpi_df, forecast_length = 1,
  train = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildForecastIDs.rtdata_+3A_time_cut">time_cut</code></td>
<td>
<p>Period after which to cut off data</p>
</td></tr>
<tr><td><code id="buildForecastIDs.rtdata_+3A_hpi_df">hpi_df</code></td>
<td>
<p>Data to be converted to training or scoring</p>
</td></tr>
<tr><td><code id="buildForecastIDs.rtdata_+3A_forecast_length">forecast_length</code></td>
<td>
<p>default = 1; Length of forecasting to do</p>
</td></tr>
<tr><td><code id="buildForecastIDs.rtdata_+3A_train">train</code></td>
<td>
<p>Default=TRUE; Create training data?  FALSE = Scoring data</p>
</td></tr>
</table>

<hr>
<h2 id='calcAccuracy'>Calculate the accuracy of an index</h2><span id='topic+calcAccuracy'></span>

<h3>Description</h3>

<p>Estimate index accuracy using one of a variety of approaches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAccuracy(hpi_obj, test_method = "insample", test_type = "rt",
  pred_df = NULL, smooth = FALSE, in_place = FALSE,
  in_place_name = "accuracy", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAccuracy_+3A_hpi_obj">hpi_obj</code></td>
<td>
<p>Object of class 'hpi'</p>
</td></tr>
<tr><td><code id="calcAccuracy_+3A_test_method">test_method</code></td>
<td>
<p>default = 'insample'; Also 'kfold'</p>
</td></tr>
<tr><td><code id="calcAccuracy_+3A_test_type">test_type</code></td>
<td>
<p>default = 'rt'; Type of data to use for test.  See details.</p>
</td></tr>
<tr><td><code id="calcAccuracy_+3A_pred_df">pred_df</code></td>
<td>
<p>default = NULL; Extra data if the test_type doesn't match data in hpi_obj</p>
</td></tr>
<tr><td><code id="calcAccuracy_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; calculated on the smoothed index(es)</p>
</td></tr>
<tr><td><code id="calcAccuracy_+3A_in_place">in_place</code></td>
<td>
<p>default = FALSE; Should the result be returned into an existing 'hpi' object</p>
</td></tr>
<tr><td><code id="calcAccuracy_+3A_in_place_name">in_place_name</code></td>
<td>
<p>default = 'accuracy'; Name for returning in place</p>
</td></tr>
<tr><td><code id="calcAccuracy_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'hpiaccuracy' inheriting from class 'data.frame' containing
the following fields:
</p>

<dl>
<dt>prop_id</dt><dd><p>Property Identification number</p>
</dd>
<dt>price</dt><dd><p>Transaction Price</p>
</dd>
<dt>pred_price</dt><dd><p>Predicted price</p>
</dd>
<dt>error</dt><dd><p>(Prediction - Actual) / Actual</p>
</dd>
<dt>log_error</dt><dd><p>log(prediction) - log(actual)</p>
</dd>
<dt>pred_period</dt><dd><p>Period of the prediction</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>'rt' test type tests the ability of the index to correctly predict the second value in
a repeat transaction pair
FUTURE: 'hed' test type tests the ability of the index to improve an OLS model that
doesn't account for time.
(This approach is not ready yet).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load Data
 data(ex_sales)

 # Create Index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Calculate insample accuracy
 hpi_accr &lt;- calcAccuracy(hpi_obj = rt_index,
                          test_type = 'rt',
                          test_method = 'insample')

</code></pre>

<hr>
<h2 id='calcForecastError'>Calculate the forecast accuracy of series of indexes</h2><span id='topic+calcForecastError'></span>

<h3>Description</h3>

<p>Estimate the index accuracy with forecasting for a (progressive) series of indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcForecastError(is_obj, pred_df, return_forecasts = FALSE,
  forecast_length = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcForecastError_+3A_is_obj">is_obj</code></td>
<td>
<p>Object of class 'hpiseries'</p>
</td></tr>
<tr><td><code id="calcForecastError_+3A_pred_df">pred_df</code></td>
<td>
<p>Set of sales to be used for predictive quality of index</p>
</td></tr>
<tr><td><code id="calcForecastError_+3A_return_forecasts">return_forecasts</code></td>
<td>
<p>default = FALSE; return the forecasted indexes</p>
</td></tr>
<tr><td><code id="calcForecastError_+3A_forecast_length">forecast_length</code></td>
<td>
<p>default = 1; Length of period(s) in time to forecast</p>
</td></tr>
<tr><td><code id="calcForecastError_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'hpiaccuracy' inheriting from class 'data.frame' containing
the following fields:
</p>

<dl>
<dt>prop_id</dt><dd><p>Property Identification number</p>
</dd>
<dt>price</dt><dd><p>Transaction Price</p>
</dd>
<dt>pred_price</dt><dd><p>Predicted price</p>
</dd>
<dt>error</dt><dd><p>(Prediction - Actual) / Actual</p>
</dd>
<dt>log_error</dt><dd><p>log(prediction) - log(actual)</p>
</dd>
<dt>pred_period</dt><dd><p>Period of the prediction</p>
</dd>
<dt>series</dt><dd><p>Series position from which the prediction was generated</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>If you set 'return_forecasts' = TRUE, the forecasted indexes for each period will be
returned in the 'forecasts' attribute of the 'hpiaccuracy' object. (attr(accr_obj,
'forecasts')
</p>
<p>For now, the 'pred_df' object must be a set of repeat transactions with the class 'rt',
inheriting from 'hpidata'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load example sales
 data(ex_sales)

 # Create Index
 hed_index &lt;- hedIndex(trans_df = ex_sales,
                       periodicity = 'monthly',
                       max_date = '2011-12-31',
                       adj_type = 'clip',
                       date = 'sale_date',
                       price = 'sale_price',
                       trans_id = 'sale_id',
                       prop_id = 'pinx',
                       estimator = 'robust',
                       log_dep = TRUE,
                       trim_model = TRUE,
                       max_period = 24,
                       dep_var = 'price',
                       ind_var = c('tot_sf', 'beds', 'baths'),
                       smooth = FALSE)

 # Create Series (Suppressing messages do to small sample size of this example)
  suppressMessages(
    hpi_series &lt;- createSeries(hpi_obj = hed_index,
                               train_period = 12))

 # Create Prediction data
 rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          max_date = '2011-12-31',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date',
                          min_period_dist = 12)


 # Calculate forecast accuracty
 fc_accr &lt;- calcForecastError(is_obj = hpi_series,
                              pred_df = rt_data)

</code></pre>

<hr>
<h2 id='calcInSampleError'>Calculate index errors in sample</h2><span id='topic+calcInSampleError'></span>

<h3>Description</h3>

<p>Estimate the predictive error of an index via an in-sample approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcInSampleError(pred_df, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcInSampleError_+3A_pred_df">pred_df</code></td>
<td>
<p>Set of sales against which to test predictions</p>
</td></tr>
<tr><td><code id="calcInSampleError_+3A_index">index</code></td>
<td>
<p>Index (of class 'ts') to be tested for accuracy</p>
</td></tr>
<tr><td><code id="calcInSampleError_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'hpiaccuracy' inheriting from class 'data.frame'
containing the following fields:
</p>

<dl>
<dt>pair_id</dt><dd><p>Uniq Pair ID number</p>
</dd>
<dt>price</dt><dd><p>Transaction Price</p>
</dd>
<dt>pred_price</dt><dd><p>Predicted price</p>
</dd>
<dt>error</dt><dd><p>(Prediction - Actual) / Actual</p>
</dd>
<dt>log_error</dt><dd><p>log(prediction) - log(actual)</p>
</dd>
<dt>pred_period</dt><dd><p>Period of the prediction</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>In addition to being a stand-alone function, it is also used by 'calcForecastError'
and 'calcKFoldError&ldquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load example data
 data(ex_sales)

 # Create index with raw transaction data
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Calculate accuracy
 in_accr &lt;- calcInSampleError(pred_df = rt_index$data,
                              index = rt_index$index$value)

</code></pre>

<hr>
<h2 id='calcInSampleError.heddata'>Calculate index errors in sample (hed approach)</h2><span id='topic+calcInSampleError.heddata'></span>

<h3>Description</h3>

<p>Estimate the predictive error of an index via an in-sample approach (hed approach)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'heddata'
calcInSampleError(pred_df, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcInSampleError.heddata_+3A_pred_df">pred_df</code></td>
<td>
<p>Set of sales against which to test predictions</p>
</td></tr>
<tr><td><code id="calcInSampleError.heddata_+3A_index">index</code></td>
<td>
<p>Index (of class 'ts') to be tested for accuracy</p>
</td></tr>
<tr><td><code id="calcInSampleError.heddata_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>

<hr>
<h2 id='calcInSampleError.rtdata'>Calculate index errors in sample (rt approach)</h2><span id='topic+calcInSampleError.rtdata'></span>

<h3>Description</h3>

<p>Estimate the predictive error of an index via an in-sample approach (rt approach)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rtdata'
calcInSampleError(pred_df, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcInSampleError.rtdata_+3A_pred_df">pred_df</code></td>
<td>
<p>Set of sales against which to test predictions</p>
</td></tr>
<tr><td><code id="calcInSampleError.rtdata_+3A_index">index</code></td>
<td>
<p>Index (of class 'ts') to be tested for accuracy</p>
</td></tr>
<tr><td><code id="calcInSampleError.rtdata_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>

<hr>
<h2 id='calcKFoldError'>Calculate index error with FKold (out of sample)</h2><span id='topic+calcKFoldError'></span>

<h3>Description</h3>

<p>Use a KFold (out of sample) approach to estimate index accuracy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcKFoldError(hpi_obj, pred_df, k = 10, seed = 1, smooth = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcKFoldError_+3A_hpi_obj">hpi_obj</code></td>
<td>
<p>HPI object of class 'hpi'</p>
</td></tr>
<tr><td><code id="calcKFoldError_+3A_pred_df">pred_df</code></td>
<td>
<p>Data.frame of sales to be used for assessing predictive quality of index</p>
</td></tr>
<tr><td><code id="calcKFoldError_+3A_k">k</code></td>
<td>
<p>default=10; Number of folds to apply to holdout process</p>
</td></tr>
<tr><td><code id="calcKFoldError_+3A_seed">seed</code></td>
<td>
<p>default=1; Random seed generator to control the folding process</p>
</td></tr>
<tr><td><code id="calcKFoldError_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; Calculate on the smoothed index</p>
</td></tr>
<tr><td><code id="calcKFoldError_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'hpiaccuracy' inheriting from class 'data.frame' containing the
following fields:
</p>

<dl>
<dt>pair_id</dt><dd><p>Unique Pair ID</p>
</dd>
<dt>price</dt><dd><p>Transaction Price</p>
</dd>
<dt>pred_price</dt><dd><p>Predicted price</p>
</dd>
<dt>error</dt><dd><p>(Prediction - Actual) / Actual</p>
</dd>
<dt>log_error</dt><dd><p>log(prediction) - log(actual)</p>
</dd>
<dt>pred_period</dt><dd><p>Period of the prediction</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index with raw transaction data
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

  # Create prediction data
  rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date')

  # Calc Accuracy
  kf_accr &lt;- calcKFoldError(hpi_obj = rt_index,
                            pred_df = rt_data,
                            k = 10,
                            seed = 123,
                            smooth = FALSE)

</code></pre>

<hr>
<h2 id='calcRevision'>Calculate revision values of an index</h2><span id='topic+calcRevision'></span>

<h3>Description</h3>

<p>Create estimates of the revision statistics for a house price index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcRevision(series_obj, in_place = FALSE, in_place_name = "rev",
  smooth = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcRevision_+3A_series_obj">series_obj</code></td>
<td>
<p>A list of progressively longer indexes (a 'serieshpi&ldquo; object from
'createSeries()&ldquo;)</p>
</td></tr>
<tr><td><code id="calcRevision_+3A_in_place">in_place</code></td>
<td>
<p>default = FALSE; Calculating in place (adding to hpi)</p>
</td></tr>
<tr><td><code id="calcRevision_+3A_in_place_name">in_place_name</code></td>
<td>
<p>default = 'rev'; Name of revision object in_place</p>
</td></tr>
<tr><td><code id="calcRevision_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; Use smoothed indexes</p>
</td></tr>
<tr><td><code id="calcRevision_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of length 3 containing:
</p>

<dl>
<dt>period</dt><dd><p>Data.frame containing the period number, mean and median for that period</p>
</dd>
<dt>mean</dt><dd><p>Mean revision for all periods</p>
</dd>
<dt>median</dt><dd><p>Median revision for all periods</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>The revision object can be generate &quot;in place&quot; inside of the 'serieshpi' object by
setting 'in_place' equal to TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load example sales
 data(ex_sales)

 # Create Index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Create Series (Suppressing messages do to small sample size of this example)
  suppressMessages(
    hpi_series &lt;- createSeries(hpi_obj = rt_index,
                               train_period = 12))

 # Calculate revision
 series_rev &lt;-  calcRevision(series_obj = hpi_series)

</code></pre>

<hr>
<h2 id='calcSeriesAccuracy'>Calculate the accuracy of a series of indexes</h2><span id='topic+calcSeriesAccuracy'></span>

<h3>Description</h3>

<p>Estimate the index accuracy for a (progressive) series of indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSeriesAccuracy(series_obj, test_method = "insample",
  test_type = "rt", pred_df = NULL, smooth = FALSE,
  summarize = FALSE, in_place = FALSE, in_place_name = "accuracy",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSeriesAccuracy_+3A_series_obj">series_obj</code></td>
<td>
<p>Serieshpi object to be analyzed</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_test_method">test_method</code></td>
<td>
<p>default = 'insample'; Also 'kfold' or 'forecast'</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_test_type">test_type</code></td>
<td>
<p>default = 'rt'; Type of data to use for test.  See details.</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_pred_df">pred_df</code></td>
<td>
<p>default = NULL; Extra data if the test_type doesn't match data in hpi_obj</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; Analyze the smoothed indexes</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_summarize">summarize</code></td>
<td>
<p>default = FALSE; When multiple accuracy measurements for single observation
take the mean of them all.</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_in_place">in_place</code></td>
<td>
<p>default = FALSE; Should the result be returned into an existing 'hpi' object</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_in_place_name">in_place_name</code></td>
<td>
<p>default = 'accuracy'; Name for returning in place</p>
</td></tr>
<tr><td><code id="calcSeriesAccuracy_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&lsquo;seriesaccuracy' object (unless calculated &rsquo;in_place')
</p>


<h3>Further Details</h3>

<p>Unless using 'test_method = &quot;forecast&quot;&ldquo; with a &quot;forecast_length&quot; of 1, the results
will have more than one accuracy estimate per observations.  Setting 'summarize = TRUE'
will take the mean accuracy for each observation across all indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

  #  Create Series (Suppressing messages do to small sample size of this example)
  suppressMessages(
    hpi_series &lt;- createSeries(hpi_obj = rt_index,
                               train_period = 12))

  # Calculate insample accuracy
  hpi_series_accr &lt;- calcSeriesAccuracy(series_obj = hpi_series,
                                        test_type = 'rt',
                                        test_method = 'insample')

</code></pre>

<hr>
<h2 id='calcSeriesVolatility'>Calculate volatility of a series of indexes</h2><span id='topic+calcSeriesVolatility'></span>

<h3>Description</h3>

<p>Calculates volatility over a (progressive) series of indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSeriesVolatility(series_obj, window = 3, smooth = FALSE,
  in_place_name = "volatility", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSeriesVolatility_+3A_series_obj">series_obj</code></td>
<td>
<p>Series object to be calculated</p>
</td></tr>
<tr><td><code id="calcSeriesVolatility_+3A_window">window</code></td>
<td>
<p>default = 3; Rolling periods over which to calculate the volatility</p>
</td></tr>
<tr><td><code id="calcSeriesVolatility_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; Also calculate volatilities for smoothed indexes</p>
</td></tr>
<tr><td><code id="calcSeriesVolatility_+3A_in_place_name">in_place_name</code></td>
<td>
<p>name if saving in place</p>
</td></tr>
<tr><td><code id="calcSeriesVolatility_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'serieshpi' object
</p>


<h3>Further Details</h3>

<p>Leaving order blank default to a moving average with order 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load example sales
 data(ex_sales)

 # Create Index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Create Series (Suppressing messages do to small sample size of this example)
 suppressMessages(
    hpi_series &lt;- createSeries(hpi_obj = rt_index,
                               train_period = 12))

 # Calculate series volatility
 series_vol &lt;- calcSeriesVolatility(series_obj = hpi_series,
                                    window= 3)

</code></pre>

<hr>
<h2 id='calcVolatility'>Calculate index volatility</h2><span id='topic+calcVolatility'></span>

<h3>Description</h3>

<p>Create estimate of index volatility given a window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVolatility(index, window = 3, in_place = FALSE,
  in_place_name = "volatility", smooth = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVolatility_+3A_index">index</code></td>
<td>
<p>An object of class 'hpiindex'</p>
</td></tr>
<tr><td><code id="calcVolatility_+3A_window">window</code></td>
<td>
<p>default = 3; Rolling periods over which to calculate the volatility</p>
</td></tr>
<tr><td><code id="calcVolatility_+3A_in_place">in_place</code></td>
<td>
<p>default = FALSE; Adds volatility metric to the 'hpiindex' object
(may be within an 'hpi' object)</p>
</td></tr>
<tr><td><code id="calcVolatility_+3A_in_place_name">in_place_name</code></td>
<td>
<p>default = 'vol'; Name of volatility object in 'hpiindex' object</p>
</td></tr>
<tr><td><code id="calcVolatility_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; Calculate on the smoothed index?</p>
</td></tr>
<tr><td><code id="calcVolatility_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;indexvolatility' (S3) object, the &rsquo;index' slot of which is a 'ts' object
</p>

<dl>
<dt>roll</dt><dd><p> volatility at each rolling point</p>
</dd>
<dt>mean</dt><dd><p>overall mean volatility</p>
</dd>
<dt>median</dt><dd><p>overall median volatility</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>You may also provide an 'hpi' object to this function.  If you do, it will
extract the 'hpiindex' object from the 'index' slot in the 'hpi' class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load Data
 data(ex_sales)

 # Create index with raw transaction data
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Calculate Volatility
 index_vol &lt;- calcVolatility(index = rt_index,
                             window = 3)

</code></pre>

<hr>
<h2 id='checkDate'>Validate the date argument</h2><span id='topic+checkDate'></span>

<h3>Description</h3>

<p>Internal function to validate (or convert) the provided date field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDate(x_date, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkDate_+3A_x_date">x_date</code></td>
<td>
<p>Date string or vector</p>
</td></tr>
<tr><td><code id="checkDate_+3A_name">name</code></td>
<td>
<p>Name of argument to return in error/warning message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted date field
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load Data
  data(ex_sales)

 # Check date
  date_checked &lt;- checkDate(x_date = ex_sales$sale_date,
                            name = 'sale date')
</code></pre>

<hr>
<h2 id='createKFoldData'>Create data for KFold error test</h2><span id='topic+createKFoldData'></span>

<h3>Description</h3>

<p>Generic method for creating KFold testing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createKFoldData(score_ids, full_data, pred_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createKFoldData_+3A_score_ids">score_ids</code></td>
<td>
<p>Vector of row ids to be included in scoring data</p>
</td></tr>
<tr><td><code id="createKFoldData_+3A_full_data">full_data</code></td>
<td>
<p>Complete dataset (class 'hpidata&ldquo;) of this model type (rt or hed)</p>
</td></tr>
<tr><td><code id="createKFoldData_+3A_pred_df">pred_df</code></td>
<td>
<p>Data to be used for prediction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of length 2 containing:
</p>

<dl>
<dt>train</dt><dd><p>Training data.frame</p>
</dd>
<dt>score</dt><dd><p>Scoring data.frame</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>Called from 'calcKFoldError()&ldquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load Data
 data(ex_sales)

 # Create RT Data
 rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date')
 # Create folds
 k_folds &lt;- split(x = 1:nrow(rt_data),
                  f = sample(1:10, nrow(rt_data), replace = TRUE))

 # Create data from folds
 kfold_data &lt;- createKFoldData(score_ids = k_folds[[1]],
                               full_data = rt_data,
                               pred_df = rt_data)

</code></pre>

<hr>
<h2 id='createKFoldData.rtdata'>Create data for KFold error test (rt approach)</h2><span id='topic+createKFoldData.rtdata'></span>

<h3>Description</h3>

<p>'rtdata' method for creating KFold testing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rtdata'
createKFoldData(score_ids, full_data, pred_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createKFoldData.rtdata_+3A_score_ids">score_ids</code></td>
<td>
<p>Vector of row ids to be included in scoring data</p>
</td></tr>
<tr><td><code id="createKFoldData.rtdata_+3A_full_data">full_data</code></td>
<td>
<p>Complete dataset (class 'hpidata&ldquo;) of this model type (rt or hed)</p>
</td></tr>
<tr><td><code id="createKFoldData.rtdata_+3A_pred_df">pred_df</code></td>
<td>
<p>Data to be used for prediction</p>
</td></tr>
</table>

<hr>
<h2 id='createSeries'>Create a series of indexes</h2><span id='topic+createSeries'></span>

<h3>Description</h3>

<p>Generate a series of progressive indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSeries(hpi_obj, train_period = 12, max_period = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSeries_+3A_hpi_obj">hpi_obj</code></td>
<td>
<p>Object of class 'hpi'</p>
</td></tr>
<tr><td><code id="createSeries_+3A_train_period">train_period</code></td>
<td>
<p>default = 12; Number of periods to use as purely training before creating indexes</p>
</td></tr>
<tr><td><code id="createSeries_+3A_max_period">max_period</code></td>
<td>
<p>default = NULL; Maximum number of periods to create the index up to</p>
</td></tr>
<tr><td><code id="createSeries_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'serieshpi' object &ndash; a list of 'hpi' objects.
</p>


<h3>Further Details</h3>

<p>'train_period' Represents the shortest index that you will create. For certain
approaches, such as a repeat transaction model, indexes shorter than 10 will likely
be highly unstable.
</p>
<p>If 'max_period&ldquo; is left NULL, then it will forecast up to the end of the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Load example sales
 data(ex_sales)

 # Create Index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Create Series (Suppressing messages do to small sample size of this example)
  suppressMessages(
    hpi_series &lt;- createSeries(hpi_obj = rt_index,
                               train_period = 12))

</code></pre>

<hr>
<h2 id='dateToPeriod'>Convert dates to a relative period</h2><span id='topic+dateToPeriod'></span>

<h3>Description</h3>

<p>Create a relative period variable from a date variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateToPeriod(trans_df, date, periodicity = NULL, min_date = NULL,
  max_date = NULL, adj_type = "move", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dateToPeriod_+3A_trans_df">trans_df</code></td>
<td>
<p>data.frame of raw transactions</p>
</td></tr>
<tr><td><code id="dateToPeriod_+3A_date">date</code></td>
<td>
<p>name of field containing the date of the sale in Date or POSIXt format</p>
</td></tr>
<tr><td><code id="dateToPeriod_+3A_periodicity">periodicity</code></td>
<td>
<p>type of periodicity to use ('yearly', 'quarterly', 'monthly' or 'weekly)</p>
</td></tr>
<tr><td><code id="dateToPeriod_+3A_min_date">min_date</code></td>
<td>
<p>default = NULL; optional minimum date to use</p>
</td></tr>
<tr><td><code id="dateToPeriod_+3A_max_date">max_date</code></td>
<td>
<p>default = NULL; optional maximum date to use</p>
</td></tr>
<tr><td><code id="dateToPeriod_+3A_adj_type">adj_type</code></td>
<td>
<p>default = 'move'; how to handle min and max dates within the range of
transactions.  'move' min and/or max date or 'clip' the data</p>
</td></tr>
<tr><td><code id="dateToPeriod_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original data frame ('trans_df' object) with two new fields:
trans_period: integer value counting from the minimum transaction date in the
periodicity selected. Base value is 1. Primarily for modeling trans_date: properly
formatted transaction date
</p>


<h3>Further Details</h3>

<p>&quot;trans_period&quot; counts from the minimum transaction date provided.  As such the period
counts are relative, not absolute
</p>
<p>Additionally, this function modifies the data.frame that it is given and return that same
data.frame that it is given and returns that data.frame with the new fields attached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
  data(ex_sales)

# Convert to period df
  hpi_data &lt;- dateToPeriod(trans_df = ex_sales,
                           date = 'sale_date',
                           periodicity = 'monthly')

</code></pre>

<hr>
<h2 id='ex_sales'>Subset of Seattle Home Sales</h2><span id='topic+ex_sales'></span>

<h3>Description</h3>

<p>Seattle home sales from areas 13, 14,an 15 (central Seattle) 2010 to 2016.
Includes only detached single family residences and townhomes.  Data gathered from
the King County Assessor's FTP site. A number of initial data munging tasks were
necessary to bring the data into this format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex_sales)
</code></pre>


<h3>Format</h3>

<p>A <code>"data.frame"</code> with 5,348 rows and 16 variables
</p>

<dl>
<dt>pinx</dt><dd><p>The unique property identifying code.  Original value is preceded by
two '..'s to prevent the dropping of leading zeros</p>
</dd>
<dt>sale_id</dt><dd><p>The unique transaction identifying code.</p>
</dd>
<dt>sale_price</dt><dd><p>Price of the home</p>
</dd>
<dt>sale_date</dt><dd><p>Date of sale</p>
</dd>
<dt>use_type</dt><dd><p>Property use type</p>
</dd>
<dt>area</dt><dd><p>Assessment area or zone</p>
</dd>
<dt>lot_sf</dt><dd><p>Size of lot in square feet</p>
</dd>
<dt>wfnt</dt><dd><p>Is property waterfront?</p>
</dd>
<dt>bldg_grade</dt><dd><p>Quality of the building construction (higher is better)</p>
</dd>
<dt>tot_sf</dt><dd><p>Size of home in square feet</p>
</dd>
<dt>beds</dt><dd><p>Number of bedrooms</p>
</dd>
<dt>baths</dt><dd><p>Number of bathrooms</p>
</dd>
<dt>age</dt><dd><p>Age of home</p>
</dd>
<dt>eff_age</dt><dd><p>Age of home, considering major remodels</p>
</dd>
<dt>longitude</dt><dd><p>Longitude</p>
</dd>
<dt>latitude</dt><dd><p>Latitude </p>
</dd>
</dl>


<h3>Source</h3>

<p>King County Assessor: http://info.kingcounty.gov/assessor/DataDownload/
</p>

<hr>
<h2 id='hedCreateTrans'>Create data for 'hed' approach</h2><span id='topic+hedCreateTrans'></span>

<h3>Description</h3>

<p>Generate standardized data for the 'hed' modeling approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hedCreateTrans(trans_df, prop_id, trans_id, price, date = NULL,
  periodicity = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hedCreateTrans_+3A_trans_df">trans_df</code></td>
<td>
<p>sales transaction in either a data.frame or a
trans_df class from dateToPeriod() function</p>
</td></tr>
<tr><td><code id="hedCreateTrans_+3A_prop_id">prop_id</code></td>
<td>
<p>field contain the unique property identification</p>
</td></tr>
<tr><td><code id="hedCreateTrans_+3A_trans_id">trans_id</code></td>
<td>
<p>field containing the unique transaction identification</p>
</td></tr>
<tr><td><code id="hedCreateTrans_+3A_price">price</code></td>
<td>
<p>field containing the transaction price</p>
</td></tr>
<tr><td><code id="hedCreateTrans_+3A_date">date</code></td>
<td>
<p>default=NULL, field containing the date of the transaction.
Only necessary if not passing an 'hpidata' object</p>
</td></tr>
<tr><td><code id="hedCreateTrans_+3A_periodicity">periodicity</code></td>
<td>
<p>default=NULL, field containing the desired periodicity of analysis.
Only necessary if not passing a 'hpidata' object</p>
</td></tr>
<tr><td><code id="hedCreateTrans_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of transactions with standardized period field. Note that a full
data.frame of the possible periods, their values and names can be found in the
attributes to the returned 'hed' object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load example data
 data(ex_sales)

 # Create Hed Data
 ex_heddata &lt;- hedCreateTrans(trans_df = ex_sales,
                              prop_id = 'pinx',
                              trans_id = 'sale_id',
                              price = 'sale_price',
                              date = 'sale_date',
                              periodicity = 'monthly')

</code></pre>

<hr>
<h2 id='hedIndex'>Create a full index object by hedonic approach</h2><span id='topic+hedIndex'></span>

<h3>Description</h3>

<p>Wrapper to create index object via entire hedonic approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hedIndex(trans_df, dep_var = NULL, ind_var = NULL, hed_spec = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hedIndex_+3A_trans_df">trans_df</code></td>
<td>
<p>data.frame of transactions</p>
</td></tr>
<tr><td><code id="hedIndex_+3A_dep_var">dep_var</code></td>
<td>
<p>default = NULL; Dependent variable in hedonic model</p>
</td></tr>
<tr><td><code id="hedIndex_+3A_ind_var">ind_var</code></td>
<td>
<p>default = NULL; Independent variables in the hedonic model</p>
</td></tr>
<tr><td><code id="hedIndex_+3A_hed_spec">hed_spec</code></td>
<td>
<p>default = NULL; Full hedonic model specification</p>
</td></tr>
<tr><td><code id="hedIndex_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'hpi&ldquo; object.  S3 list with:
</p>

<dl>
<dt>data</dt><dd><p>'hpidata' object</p>
</dd>
<dt>model</dt><dd><p>'hpimodel' object</p>
</dd>
<dt>index</dt><dd><p>'hpiindex' object</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>Additional argument need to provide necessary argument for create 'hpidata' objects if
the 'trans_df' object is not of that class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index with raw transaction data
 hed_index &lt;- hedIndex(trans_df = ex_sales,
                       periodicity = 'monthly',
                       min_date = '2010-06-01',
                       max_date = '2015-11-30',
                       adj_type = 'clip',
                       date = 'sale_date',
                       price = 'sale_price',
                       trans_id = 'sale_id',
                       prop_id = 'pinx',
                       estimator = 'robust',
                       log_dep = TRUE,
                       trim_model = TRUE,
                       max_period = 48,
                       dep_var = 'price',
                       ind_var = c('tot_sf', 'beds', 'baths'),
                       smooth = FALSE)

</code></pre>

<hr>
<h2 id='hedModel'>Estimate hedonic model for index creation</h2><span id='topic+hedModel'></span>

<h3>Description</h3>

<p>Estimate coefficients for an index via the hedonic approach (generic method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hedModel(estimator, hed_df, hed_spec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hedModel_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted)</p>
</td></tr>
<tr><td><code id="hedModel_+3A_hed_df">hed_df</code></td>
<td>
<p>Repeat sales dataset from hedCreateSales()</p>
</td></tr>
<tr><td><code id="hedModel_+3A_hed_spec">hed_spec</code></td>
<td>
<p>Model specification ('formula' object)</p>
</td></tr>
<tr><td><code id="hedModel_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'hedmodel' object: model object of the estimator (ex.: 'lm')
</p>


<h3>Further Details</h3>

<p>&lsquo;estimator' argument must be in a class of &rsquo;base', 'weighted' or 'robust'
This function is not generally called directly, but rather from 'hpiModel()'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load example data
 data(ex_sales)

 # Create hedonic data
 hed_data &lt;- hedCreateTrans(trans_df = ex_sales,
                           prop_id = 'pinx',
                           trans_id = 'sale_id',
                           price = 'sale_price',
                           date = 'sale_date',
                           periodicity = 'monthly')

 # Estimate Model
 hed_model &lt;- hedModel(estimator = structure('base', class = 'base'),
                       hed_df = hed_data,
                       hed_spec = as.formula(log(price) ~ baths + tot_sf))

</code></pre>

<hr>
<h2 id='hedModel.base'>Hedonic model approach with base estimator</h2><span id='topic+hedModel.base'></span>

<h3>Description</h3>

<p>Use of base estimator in hedonic model approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'base'
hedModel(estimator, hed_df, hed_spec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hedModel.base_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted)</p>
</td></tr>
<tr><td><code id="hedModel.base_+3A_hed_df">hed_df</code></td>
<td>
<p>Repeat sales dataset from hedCreateSales()</p>
</td></tr>
<tr><td><code id="hedModel.base_+3A_hed_spec">hed_spec</code></td>
<td>
<p>Model specification ('formula' object)</p>
</td></tr>
<tr><td><code id="hedModel.base_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?hedModel' for more information
</p>

<hr>
<h2 id='hedModel.robust'>Hedonic model approach with robust estimator</h2><span id='topic+hedModel.robust'></span>

<h3>Description</h3>

<p>Use of robust estimator in hedonic model approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robust'
hedModel(estimator, hed_df, hed_spec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hedModel.robust_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted)</p>
</td></tr>
<tr><td><code id="hedModel.robust_+3A_hed_df">hed_df</code></td>
<td>
<p>Repeat sales dataset from hedCreateSales()</p>
</td></tr>
<tr><td><code id="hedModel.robust_+3A_hed_spec">hed_spec</code></td>
<td>
<p>Model specification ('formula' object)</p>
</td></tr>
<tr><td><code id="hedModel.robust_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?hedModel' for more information
</p>
<p>See '?hedModel' for more information
</p>

<hr>
<h2 id='hedModel.weighted'>Hedonic model approach with weighted estimator</h2><span id='topic+hedModel.weighted'></span>

<h3>Description</h3>

<p>Use of weighted estimator in hedonic model approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weighted'
hedModel(estimator, hed_df, hed_spec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hedModel.weighted_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted)</p>
</td></tr>
<tr><td><code id="hedModel.weighted_+3A_hed_df">hed_df</code></td>
<td>
<p>Repeat sales dataset from hedCreateSales()</p>
</td></tr>
<tr><td><code id="hedModel.weighted_+3A_hed_spec">hed_spec</code></td>
<td>
<p>Model specification ('formula' object)</p>
</td></tr>
<tr><td><code id="hedModel.weighted_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?hedModel' for more information
</p>

<hr>
<h2 id='hpiModel'>Wrapper to estimate model approaches (generic method)</h2><span id='topic+hpiModel'></span>

<h3>Description</h3>

<p>Generic method to estimate modeling approaches for indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpiModel(model_type, hpi_df, estimator = "base", log_dep = TRUE,
  trim_model = TRUE, mod_spec = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpiModel_+3A_model_type">model_type</code></td>
<td>
<p>Type of model to estimate ('rt', 'hed', 'rf')</p>
</td></tr>
<tr><td><code id="hpiModel_+3A_hpi_df">hpi_df</code></td>
<td>
<p>Dataset created by one of the *CreateTrans() function in this package.</p>
</td></tr>
<tr><td><code id="hpiModel_+3A_estimator">estimator</code></td>
<td>
<p>Type of estimator to be used ('base', 'weighted', 'robust')</p>
</td></tr>
<tr><td><code id="hpiModel_+3A_log_dep">log_dep</code></td>
<td>
<p>default TRUE, should the dependent variable (change in price) be logged?</p>
</td></tr>
<tr><td><code id="hpiModel_+3A_trim_model">trim_model</code></td>
<td>
<p>default TRUE, should excess be trimmed from model results ('lm' or 'rlm' object)?</p>
</td></tr>
<tr><td><code id="hpiModel_+3A_mod_spec">mod_spec</code></td>
<td>
<p>Model specification</p>
</td></tr>
<tr><td><code id="hpiModel_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hpimodel object consisting of:
</p>

<dl>
<dt>estimator</dt><dd><p>Type of estimator</p>
</dd>
<dt>coefficients</dt><dd><p>Data.frame of coefficient</p>
</dd>
<dt>model_obj</dt><dd><p>class 'rtmodel' or 'hedmodel'</p>
</dd>
<dt>mod_spec</dt><dd><p>Full model specification</p>
</dd>
<dt>log_dep</dt><dd><p>Binary: is the dependent variable in logged format</p>
</dd>
<dt>base_price</dt><dd><p>Mean price in the base period</p>
</dd>
<dt>periods</dt><dd><p>'data.frame' of periods</p>
</dd>
<dt>approach</dt><dd><p>Type of model used</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # With a raw transaction data.frame
 rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date')

 # Create model object
 hpi_model &lt;- hpiModel(model_type = 'rt',
                       hpi_df = rt_data,
                       estimator = 'base',
                       log_dep = TRUE)

 # For custom weighted repeat transaction model

 hpi_model_wgt &lt;- hpiModel(model_type = 'rt',
                           hpi_df = rt_data,
                           estimator = 'weighted',
                           weights = runif(nrow(rt_data), 0, 1))


</code></pre>

<hr>
<h2 id='hpiModel.hed'>Specific method for hpi modeling (hed) approach)</h2><span id='topic+hpiModel.hed'></span>

<h3>Description</h3>

<p>Estimate hpi models with hed approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hed'
hpiModel(model_type, hpi_df, estimator = "base",
  log_dep = TRUE, trim_model = TRUE, mod_spec = NULL,
  dep_var = NULL, ind_var = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpiModel.hed_+3A_model_type">model_type</code></td>
<td>
<p>Type of model to estimate ('rt', 'hed', 'rf')</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_hpi_df">hpi_df</code></td>
<td>
<p>Dataset created by one of the *CreateSales() function in this package.</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_estimator">estimator</code></td>
<td>
<p>Type of estimator to be used ('base', 'weighted', 'robust')</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_log_dep">log_dep</code></td>
<td>
<p>default=TRUE; should the dependent variable (change in price) be logged?</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_trim_model">trim_model</code></td>
<td>
<p>default TRUE, should excess be trimmed from model results ('lm' or 'rlm' object)?</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_mod_spec">mod_spec</code></td>
<td>
<p>default=NULL; hedonic model specification</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_dep_var">dep_var</code></td>
<td>
<p>default=NULL; dependent variable of the model</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_ind_var">ind_var</code></td>
<td>
<p>default=NULL; independent variable(s) of the model</p>
</td></tr>
<tr><td><code id="hpiModel.hed_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hpimodel object consisting of:
</p>

<dl>
<dt>estimator</dt><dd><p>Type of estimator</p>
</dd>
<dt>coefficients</dt><dd><p>Data.frame of coefficient</p>
</dd>
<dt>model_obj</dt><dd><p>class 'rtmodel' or 'hedmodel'</p>
</dd>
<dt>mod_spec</dt><dd><p>Full model specification</p>
</dd>
<dt>log_dep</dt><dd><p>Binary: is the dependent variable in logged format</p>
</dd>
<dt>base_price</dt><dd><p>Mean price in the base period</p>
</dd>
<dt>periods</dt><dd><p>'data.frame' of periods</p>
</dd>
<dt>approach</dt><dd><p>Type of model used</p>
</dd>
</dl>


<hr>
<h2 id='hpiModel.rf'>Specific method for hpi modeling (hed) approach)</h2><span id='topic+hpiModel.rf'></span>

<h3>Description</h3>

<p>Estimate hpi models with hed approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rf'
hpiModel(model_type, hpi_df, estimator = "pdp",
  log_dep = TRUE, trim_model = TRUE, mod_spec = NULL,
  dep_var = NULL, ind_var = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpiModel.rf_+3A_model_type">model_type</code></td>
<td>
<p>Type of model ('rt', 'hed', 'rf')</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_hpi_df">hpi_df</code></td>
<td>
<p>Dataset created by one of the *CreateSales() function in this package.</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_estimator">estimator</code></td>
<td>
<p>Type of estimator to be used ('base', 'weighted', 'robust')</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_log_dep">log_dep</code></td>
<td>
<p>default=TRUE; should the dependent variable (change in price) be logged?</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_trim_model">trim_model</code></td>
<td>
<p>default TRUE, should excess be trimmed from model results ('lm' or 'rlm' object)?</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_mod_spec">mod_spec</code></td>
<td>
<p>default=NULL; hedonic model specification</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_dep_var">dep_var</code></td>
<td>
<p>default=NULL; dependent variable of the model</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_ind_var">ind_var</code></td>
<td>
<p>default=NULL; independent variable(s) of the model</p>
</td></tr>
<tr><td><code id="hpiModel.rf_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hpimodel object consisting of:
</p>

<dl>
<dt>estimator</dt><dd><p>Type of estimator</p>
</dd>
<dt>coefficients</dt><dd><p>Data.frame of coefficient</p>
</dd>
<dt>model_obj</dt><dd><p>class 'rtmodel' or 'hedmodel'</p>
</dd>
<dt>mod_spec</dt><dd><p>Full model specification</p>
</dd>
<dt>log_dep</dt><dd><p>Binary: is the dependent variable in logged format</p>
</dd>
<dt>base_price</dt><dd><p>Mean price in the base period</p>
</dd>
<dt>periods</dt><dd><p>'data.frame' of periods</p>
</dd>
<dt>approach</dt><dd><p>Type of model used</p>
</dd>
</dl>


<hr>
<h2 id='hpiModel.rt'>Specific method for hpi modeling (rt approach)</h2><span id='topic+hpiModel.rt'></span>

<h3>Description</h3>

<p>Estimate hpi models with rt approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rt'
hpiModel(model_type, hpi_df, estimator = "base",
  log_dep = TRUE, trim_model = TRUE, mod_spec = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpiModel.rt_+3A_model_type">model_type</code></td>
<td>
<p>Type of model to estimate ('rt', 'hed', 'rf')</p>
</td></tr>
<tr><td><code id="hpiModel.rt_+3A_hpi_df">hpi_df</code></td>
<td>
<p>Dataset created by one of the *CreateTrans() function in this package.</p>
</td></tr>
<tr><td><code id="hpiModel.rt_+3A_estimator">estimator</code></td>
<td>
<p>Type of estimator to be used ('base', 'weighted', 'robust')</p>
</td></tr>
<tr><td><code id="hpiModel.rt_+3A_log_dep">log_dep</code></td>
<td>
<p>default TRUE, should the dependent variable (change in price) be logged?</p>
</td></tr>
<tr><td><code id="hpiModel.rt_+3A_trim_model">trim_model</code></td>
<td>
<p>default TRUE, should excess be trimmed from model results ('lm' or 'rlm' object)?</p>
</td></tr>
<tr><td><code id="hpiModel.rt_+3A_mod_spec">mod_spec</code></td>
<td>
<p>Model specification</p>
</td></tr>
<tr><td><code id="hpiModel.rt_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hpimodel object consisting of:
</p>

<dl>
<dt>estimator</dt><dd><p>Type of estimator</p>
</dd>
<dt>coefficients</dt><dd><p>Data.frame of coefficient</p>
</dd>
<dt>model_obj</dt><dd><p>class 'rtmodel' or 'hedmodel'</p>
</dd>
<dt>mod_spec</dt><dd><p>Full model specification</p>
</dd>
<dt>log_dep</dt><dd><p>Binary: is the dependent variable in logged format</p>
</dd>
<dt>base_price</dt><dd><p>Mean price in the base period</p>
</dd>
<dt>periods</dt><dd><p>'data.frame' of periods</p>
</dd>
<dt>approach</dt><dd><p>Type of model used</p>
</dd>
</dl>


<hr>
<h2 id='matchKFold'>Helper function to make KFold data</h2><span id='topic+matchKFold'></span>

<h3>Description</h3>

<p>Function to help create KFold data based on approach (Generic Method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchKFold(train_df, pred_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchKFold_+3A_train_df">train_df</code></td>
<td>
<p>Data.frame of training data</p>
</td></tr>
<tr><td><code id="matchKFold_+3A_pred_df">pred_df</code></td>
<td>
<p>Data.frame (class 'hpidata&ldquo;) to be used for prediction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<dl>
<dt>train</dt><dd><p>Training data</p>
</dd>
<dt>score</dt><dd><p>Scoring data</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>Helper function called from createKFoldData
</p>

<hr>
<h2 id='matchKFold.heddata'>Helper function to make KFold data</h2><span id='topic+matchKFold.heddata'></span>

<h3>Description</h3>

<p>Function to help create KFold data based on hed approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'heddata'
matchKFold(train_df, pred_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchKFold.heddata_+3A_train_df">train_df</code></td>
<td>
<p>Data.frame of training data</p>
</td></tr>
<tr><td><code id="matchKFold.heddata_+3A_pred_df">pred_df</code></td>
<td>
<p>Data.frame (class 'hpidata&ldquo;) to be used for prediction</p>
</td></tr>
</table>

<hr>
<h2 id='matchKFold.rtdata'>Helper function to make KFold data</h2><span id='topic+matchKFold.rtdata'></span>

<h3>Description</h3>

<p>Function to help create KFold data based on rt approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rtdata'
matchKFold(train_df, pred_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchKFold.rtdata_+3A_train_df">train_df</code></td>
<td>
<p>Data.frame of training data</p>
</td></tr>
<tr><td><code id="matchKFold.rtdata_+3A_pred_df">pred_df</code></td>
<td>
<p>Data.frame (class 'hpidata&ldquo;) to be used for prediction</p>
</td></tr>
</table>

<hr>
<h2 id='modelToIndex'>Convert model results into a house price index</h2><span id='topic+modelToIndex'></span>

<h3>Description</h3>

<p>Converts model results to standardized index objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelToIndex(model_obj, max_period = max(model_obj$coefficients$time),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelToIndex_+3A_model_obj">model_obj</code></td>
<td>
<p>Model results object</p>
</td></tr>
<tr><td><code id="modelToIndex_+3A_max_period">max_period</code></td>
<td>
<p>Maximum number of periods that should have been estimated.</p>
</td></tr>
<tr><td><code id="modelToIndex_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'hpiindex' object containing:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>vector of period names</p>
</td></tr>
<tr><td><code>numeric</code></td>
<td>
<p>vector of period in numeric form</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>vector of period numbers</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>'ts' object of the index values</p>
</td></tr>
<tr><td><code>imputed</code></td>
<td>
<p>vector of binary values indicating imputation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # With a raw transaction data.frame
 rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date')

 # Create model object
 hpi_model &lt;- hpiModel(model_type = 'rt',
                       hpi_df = rt_data,
                       estimator = 'base',
                       log_dep = TRUE)

 # Create Index
 hpi_index &lt;- modelToIndex(hpi_model,
                           max_period = 84)

</code></pre>

<hr>
<h2 id='plot.hpi'>Plot method for 'hpi' object</h2><span id='topic+plot.hpi'></span>

<h3>Description</h3>

<p>Specific plotting method for hpi objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hpi'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hpi_+3A_x">x</code></td>
<td>
<p>Object to plot of class 'hpi'</p>
</td></tr>
<tr><td><code id="plot.hpi_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'plotindex' object inheriting from a ggplot object
</p>


<h3>Further Details</h3>

<p>Additional argument can include those argument for 'plot.hpindex&ldquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index with raw transaction data
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Plot data
 plot(rt_index)
 plot(rt_index, smooth = TRUE)

</code></pre>

<hr>
<h2 id='plot.hpiaccuracy'>Plot method for 'hpiaccuracy' object</h2><span id='topic+plot.hpiaccuracy'></span>

<h3>Description</h3>

<p>Specific plotting method for hpiaccuracy objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hpiaccuracy'
plot(x, return_plot = FALSE, do_plot = TRUE,
  use_log_error = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hpiaccuracy_+3A_x">x</code></td>
<td>
<p>Object to plot of class 'hpiaccuracy&ldquo;</p>
</td></tr>
<tr><td><code id="plot.hpiaccuracy_+3A_return_plot">return_plot</code></td>
<td>
<p>default = FALSE; Return the plot to the function call</p>
</td></tr>
<tr><td><code id="plot.hpiaccuracy_+3A_do_plot">do_plot</code></td>
<td>
<p>default = FALSE; Execute plotting to terminal/console</p>
</td></tr>
<tr><td><code id="plot.hpiaccuracy_+3A_use_log_error">use_log_error</code></td>
<td>
<p>[FALSE] Use the log error?</p>
</td></tr>
<tr><td><code id="plot.hpiaccuracy_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'plotaccuracy' object inheriting from a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load Data
 data(ex_sales)

 # Create Index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Calculate insample accuracy
 hpi_accr &lt;- calcAccuracy(hpi_obj = rt_index,
                          test_type = 'rt',
                          test_method = 'insample')

 # Make Plot
 plot(hpi_accr)

</code></pre>

<hr>
<h2 id='plot.hpiindex'>Plot method for 'hpiindex' object</h2><span id='topic+plot.hpiindex'></span>

<h3>Description</h3>

<p>Specific plotting method for hpiindex objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hpiindex'
plot(x, show_imputed = FALSE, smooth = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hpiindex_+3A_x">x</code></td>
<td>
<p>Object to plot of class 'hpiindex&ldquo;</p>
</td></tr>
<tr><td><code id="plot.hpiindex_+3A_show_imputed">show_imputed</code></td>
<td>
<p>default = FALSE; highlight the imputed points</p>
</td></tr>
<tr><td><code id="plot.hpiindex_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; plot the smoothed index</p>
</td></tr>
<tr><td><code id="plot.hpiindex_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'plotindex' object inheriting from a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # With a raw transaction data.frame
 rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date')

 # Create model object
 hpi_model &lt;- hpiModel(model_type = 'rt',
                       hpi_df = rt_data,
                       estimator = 'base',
                       log_dep = TRUE)

 # Create Index
 hpi_index &lt;- modelToIndex(hpi_model,
                           max_period = 84)

 # Make Plot
 plot(hpi_index)

</code></pre>

<hr>
<h2 id='plot.indexvolatility'>Plot method for 'indexvolatility' object</h2><span id='topic+plot.indexvolatility'></span>

<h3>Description</h3>

<p>Specific plotting method for indexvolatility objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indexvolatility'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.indexvolatility_+3A_x">x</code></td>
<td>
<p>Object to plot of class 'indexvolatility&ldquo;</p>
</td></tr>
<tr><td><code id="plot.indexvolatility_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'plotvolatility' object inheriting from a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load Data
 data(ex_sales)

 # Create index with raw transaction data
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Calculate Volatility
 index_vol &lt;- calcVolatility(index = rt_index,
                             window = 3)

 # Make Plot
 plot(index_vol)

</code></pre>

<hr>
<h2 id='plot.seriesaccuracy'>Plot method for 'seriesaccuracy' object</h2><span id='topic+plot.seriesaccuracy'></span>

<h3>Description</h3>

<p>Specific plotting method for seriesaccuracy objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seriesaccuracy'
plot(x, return_plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.seriesaccuracy_+3A_x">x</code></td>
<td>
<p>Object of class 'hpiaccuracy&ldquo;</p>
</td></tr>
<tr><td><code id="plot.seriesaccuracy_+3A_return_plot">return_plot</code></td>
<td>
<p>default = FALSE; Return the plot to the function call</p>
</td></tr>
<tr><td><code id="plot.seriesaccuracy_+3A_...">...</code></td>
<td>
<p>Additional argument (passed to 'plot.hpiaccuracy()&ldquo;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'plotaccuracy' object inheriting from a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 #  Create Series (Suppressing messages do to small sample size of this example)
 suppressMessages(
    hpi_series &lt;- createSeries(hpi_obj = rt_index,
                               train_period = 12))

 # Calculate insample accuracy
 hpi_series_accr &lt;- calcSeriesAccuracy(series_obj = hpi_series,
                                       test_type = 'rt',
                                       test_method = 'insample')
 # Make Plot
 plot(hpi_series_accr)

</code></pre>

<hr>
<h2 id='plot.serieshpi'>Plot method for 'serieshpi' object</h2><span id='topic+plot.serieshpi'></span>

<h3>Description</h3>

<p>Specific plotting method for serieshpi objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serieshpi'
plot(x, smooth = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.serieshpi_+3A_x">x</code></td>
<td>
<p>Object of class 'serieshpi'</p>
</td></tr>
<tr><td><code id="plot.serieshpi_+3A_smooth">smooth</code></td>
<td>
<p>default = FALSE; plot the smoothed object</p>
</td></tr>
<tr><td><code id="plot.serieshpi_+3A_...">...</code></td>
<td>
<p>Additional Arguments'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'plotseries' object inheriting from a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Create Series (Suppressing messages do to small sample size of this example)
 suppressMessages(
   hpi_series &lt;- createSeries(hpi_obj = rt_index,
                              train_period = 12))

 # Make Plot
 plot(hpi_series)

</code></pre>

<hr>
<h2 id='plot.seriesrevision'>Plot method for 'seriesrevision' object</h2><span id='topic+plot.seriesrevision'></span>

<h3>Description</h3>

<p>Specific plotting method for seriesrevision objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seriesrevision'
plot(x, measure = "median", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.seriesrevision_+3A_x">x</code></td>
<td>
<p>Object to plot of class 'seriesrevision'</p>
</td></tr>
<tr><td><code id="plot.seriesrevision_+3A_measure">measure</code></td>
<td>
<p>default = 'median'; Metric to plot ('median' or 'mean')</p>
</td></tr>
<tr><td><code id="plot.seriesrevision_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'plotrevision' object inheriting from a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load example sales
 data(ex_sales)

 # Create Index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Create Series (Suppressing messages do to small sample size of this example)
 suppressMessages(
   hpi_series &lt;- createSeries(hpi_obj = rt_index,
                              train_period = 12))

 # Calculate revision
 series_rev &lt;-  calcRevision(series_obj = hpi_series)

 # Make Plot
 plot(series_rev)

</code></pre>

<hr>
<h2 id='rfIndex'>Create a full index object by random forest approach</h2><span id='topic+rfIndex'></span>

<h3>Description</h3>

<p>Wrapper to create index object via entire random forest approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfIndex(trans_df, dep_var = NULL, ind_var = NULL, rf_spec = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfIndex_+3A_trans_df">trans_df</code></td>
<td>
<p>data.frame of transactions</p>
</td></tr>
<tr><td><code id="rfIndex_+3A_dep_var">dep_var</code></td>
<td>
<p>default = NULL; Dependent variable in hedonic model</p>
</td></tr>
<tr><td><code id="rfIndex_+3A_ind_var">ind_var</code></td>
<td>
<p>default = NULL; Independent variables in the hedonic model</p>
</td></tr>
<tr><td><code id="rfIndex_+3A_rf_spec">rf_spec</code></td>
<td>
<p>default = NULL; Full random forest model specification</p>
</td></tr>
<tr><td><code id="rfIndex_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'hpi&ldquo; object.  S3 list with:
</p>

<dl>
<dt>data</dt><dd><p>'hpidata' object</p>
</dd>
<dt>model</dt><dd><p>'hpimodel' object</p>
</dd>
<dt>index</dt><dd><p>'hpiindex' object</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>Additional argument need to provide necessary argument for create 'hpidata' objects if
the 'trans_df' object is not of that class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # Load data
 data(ex_sales)

 # Create index with raw transaction data
 rf_index &lt;- rfIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'pdp',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     dep_var = 'price',
                     ind_var = c('tot_sf', 'beds', 'baths'),
                     smooth = FALSE,
                     ntrees = 10,
                     sim_count = 2)

</code></pre>

<hr>
<h2 id='rfModel'>Estimate random forest model for index creation</h2><span id='topic+rfModel'></span>

<h3>Description</h3>

<p>Estimate coefficients for an index via the random forest approach (generic method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfModel(estimator, rf_df, rf_spec, ntrees = 200, seed = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfModel_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (pdp)</p>
</td></tr>
<tr><td><code id="rfModel_+3A_rf_df">rf_df</code></td>
<td>
<p>Transactions dataset from hedCreateSales()</p>
</td></tr>
<tr><td><code id="rfModel_+3A_rf_spec">rf_spec</code></td>
<td>
<p>Model specification ('formula' object)</p>
</td></tr>
<tr><td><code id="rfModel_+3A_ntrees">ntrees</code></td>
<td>
<p>[200] Set number of trees to use</p>
</td></tr>
<tr><td><code id="rfModel_+3A_seed">seed</code></td>
<td>
<p>[1] Random seed for reproducibility</p>
</td></tr>
<tr><td><code id="rfModel_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'rfmodel' object: model object of the estimator (ex.: 'lm')
</p>


<h3>Further Details</h3>

<p>&lsquo;estimator' argument must be in a class of &rsquo;pdp'
This function is not generally called directly, but rather from 'hpiModel()'
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Load example data
 data(ex_sales)

 # Create hedonic data
 hed_data &lt;- hedCreateTrans(trans_df = ex_sales,
                           prop_id = 'pinx',
                           trans_id = 'sale_id',
                           price = 'sale_price',
                           date = 'sale_date',
                           periodicity = 'monthly')

 # Estimate Model
 rf_model &lt;- rfModel(estimator = structure('pdp', class = 'pdp'),
                     rf_df = hed_data,
                     rf_spec = as.formula(log(price) ~ baths + tot_sf),
                     ntrees = 10,
                     sim_count = 1)

</code></pre>

<hr>
<h2 id='rfModel.pdp'>Random forest model approach with pdp estimator</h2><span id='topic+rfModel.pdp'></span>

<h3>Description</h3>

<p>Use of pdp estimator in random forest approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdp'
rfModel(estimator, rf_df, rf_spec, ntrees = 200,
  seed = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfModel.pdp_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (pdp)</p>
</td></tr>
<tr><td><code id="rfModel.pdp_+3A_rf_df">rf_df</code></td>
<td>
<p>Transactions dataset from hedCreateSales()</p>
</td></tr>
<tr><td><code id="rfModel.pdp_+3A_rf_spec">rf_spec</code></td>
<td>
<p>Model specification ('formula' object)</p>
</td></tr>
<tr><td><code id="rfModel.pdp_+3A_ntrees">ntrees</code></td>
<td>
<p>[200] Set number of trees to use</p>
</td></tr>
<tr><td><code id="rfModel.pdp_+3A_seed">seed</code></td>
<td>
<p>[1] Random seed for reproducibility</p>
</td></tr>
<tr><td><code id="rfModel.pdp_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?rfModel' for more information
</p>

<hr>
<h2 id='rfSimDf'>Create simulation data for Random forest approach</h2><span id='topic+rfSimDf'></span>

<h3>Description</h3>

<p>Create data to use in PDP simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfSimDf(rf_df, seed, sim_ids = NULL, sim_count = NULL,
  sim_per = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfSimDf_+3A_rf_df">rf_df</code></td>
<td>
<p>Full training dataset</p>
</td></tr>
<tr><td><code id="rfSimDf_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility</p>
</td></tr>
<tr><td><code id="rfSimDf_+3A_sim_ids">sim_ids</code></td>
<td>
<p>row ids to simulate</p>
</td></tr>
<tr><td><code id="rfSimDf_+3A_sim_count">sim_count</code></td>
<td>
<p>number of random rows to simulate</p>
</td></tr>
<tr><td><code id="rfSimDf_+3A_sim_per">sim_per</code></td>
<td>
<p>percent of rows to randomly simulate</p>
</td></tr>
<tr><td><code id="rfSimDf_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?rfModel' for more information
</p>

<hr>
<h2 id='rtCreateTrans'>Create transaction data for rt approach</h2><span id='topic+rtCreateTrans'></span>

<h3>Description</h3>

<p>Generate standardized object for rt estimate approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtCreateTrans(trans_df, prop_id, trans_id, price, date = NULL,
  periodicity = NULL, seq_only = FALSE, min_period_dist = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtCreateTrans_+3A_trans_df">trans_df</code></td>
<td>
<p>transactions in either a data.frame or a 'hpidata&ldquo; class from
dateToPeriod() function</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_prop_id">prop_id</code></td>
<td>
<p>field contain the unique property identification</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_trans_id">trans_id</code></td>
<td>
<p>field containing the unique transaction identification</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_price">price</code></td>
<td>
<p>field containing the transaction price</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_date">date</code></td>
<td>
<p>default=NULL, field containing the date of the sale.
Only necessary if not passing an 'hpidata' object</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_periodicity">periodicity</code></td>
<td>
<p>default=NULL, field containing the desired periodicity of analysis.
Only necessary if not passing a 'hpidata' object</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_seq_only">seq_only</code></td>
<td>
<p>default=FALSE, indicating whether to only include sequential repeat observations
1 to 2 and 2 to 3.  False returns 1 to 2, 1 to 3 and 2 to 3.</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_min_period_dist">min_period_dist</code></td>
<td>
<p>[12] Minimum number of period required between repeat sales</p>
</td></tr>
<tr><td><code id="rtCreateTrans_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of repeat transactions. Note that a full data.frame of the possible
periods, their values and names can be found in the attributes to the returned 'rtdata' object
</p>


<h3>Further Details</h3>

<p>Properties with greater than two transactions during the period will make pairwise matches
among all sales.  Any property transacting twice in the same period will remove the lower
priced of the two transactions.
If passing a raw data.frame (not a 'hpidata&ldquo; object) the &quot;date&quot; field should refer to
a field containing a vector of class POSIXt or Date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # With a raw transaction data.frame
 rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                          prop_id = 'pinx',
                          trans_id = 'sale_id',
                          price = 'sale_price',
                          periodicity = 'monthly',
                          date = 'sale_date')

</code></pre>

<hr>
<h2 id='rtIndex'>Create a full index object by repeat transaction approach</h2><span id='topic+rtIndex'></span>

<h3>Description</h3>

<p>Wrapper to create index object via entire repeat transaction approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtIndex(trans_df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtIndex_+3A_trans_df">trans_df</code></td>
<td>
<p>data.frame of transactions.  Can be a 'hpidata' or an 'rtdata' object.</p>
</td></tr>
<tr><td><code id="rtIndex_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'hpi&ldquo; object.  S3 list with:
</p>

<dl>
<dt>data</dt><dd><p>'hpidata' object</p>
</dd>
<dt>model</dt><dd><p>'hpimodel' object</p>
</dd>
<dt>index</dt><dd><p>'hpiindex' object</p>
</dd>
</dl>



<h3>Further Details</h3>

<p>Additional argument need to provide necessary argument for create 'hpidata' objects if
the 'trans_df' object is not of that class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index with raw transaction data
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

</code></pre>

<hr>
<h2 id='rtModel'>Estimate repeat transaction model for index creation</h2><span id='topic+rtModel'></span>

<h3>Description</h3>

<p>Estimate coefficients for an index via the repeat transaction approach (generic method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtModel(rt_df, time_matrix, price_diff, estimator, lm_recover = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtModel_+3A_rt_df">rt_df</code></td>
<td>
<p>Repeat transactions dataset from rtCreateTrans()</p>
</td></tr>
<tr><td><code id="rtModel_+3A_time_matrix">time_matrix</code></td>
<td>
<p>Time matrix object from rtTimeMatrix()</p>
</td></tr>
<tr><td><code id="rtModel_+3A_price_diff">price_diff</code></td>
<td>
<p>Difference in price between the two transactions</p>
</td></tr>
<tr><td><code id="rtModel_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted).  Must be in that class.</p>
</td></tr>
<tr><td><code id="rtModel_+3A_lm_recover">lm_recover</code></td>
<td>
<p>(TRUE) Allows robust model to use linear model if it fails</p>
</td></tr>
<tr><td><code id="rtModel_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'rtmodel' object
</p>


<h3>Further Details</h3>

<p>Three available specific methods: 'base', 'robust' and 'weighted'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Load data
  data(ex_sales)

  # With a raw transaction data.frame
  rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                           prop_id = 'pinx',
                           trans_id = 'sale_id',
                           price = 'sale_price',
                           periodicity = 'monthly',
                           date = 'sale_date')

  # Calc price differences
  price_diff &lt;- rt_data$price_2 - rt_data$price_1

  # Create time matrix
  rt_matrix &lt;- rtTimeMatrix(rt_data)

  # Calculate model
  rt_model &lt;- rtModel(rt_df = rt_data,
                      price_diff = price_diff,
                      time_matrix = rt_matrix,
                      estimator = structure('base', class='base'))

</code></pre>

<hr>
<h2 id='rtModel.base'>Repeat transaction model approach with base estimator</h2><span id='topic+rtModel.base'></span>

<h3>Description</h3>

<p>Use of base estimator in repeat transactions model approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'base'
rtModel(rt_df, time_matrix, price_diff, estimator, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtModel.base_+3A_rt_df">rt_df</code></td>
<td>
<p>Repeat transactions dataset from rtCreateTrans()</p>
</td></tr>
<tr><td><code id="rtModel.base_+3A_time_matrix">time_matrix</code></td>
<td>
<p>Time matrix object from rtTimeMatrix()</p>
</td></tr>
<tr><td><code id="rtModel.base_+3A_price_diff">price_diff</code></td>
<td>
<p>Difference in price between the two transactions</p>
</td></tr>
<tr><td><code id="rtModel.base_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted).  Must be in that class.</p>
</td></tr>
<tr><td><code id="rtModel.base_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?rtModel' for more information
</p>

<hr>
<h2 id='rtModel.robust'>Repeat transaction model approach with robust estimator</h2><span id='topic+rtModel.robust'></span>

<h3>Description</h3>

<p>Use of robust estimator in repeat transactions model approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robust'
rtModel(rt_df, time_matrix, price_diff, estimator,
  lm_recover = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtModel.robust_+3A_rt_df">rt_df</code></td>
<td>
<p>Repeat transactions dataset from rtCreateTrans()</p>
</td></tr>
<tr><td><code id="rtModel.robust_+3A_time_matrix">time_matrix</code></td>
<td>
<p>Time matrix object from rtTimeMatrix()</p>
</td></tr>
<tr><td><code id="rtModel.robust_+3A_price_diff">price_diff</code></td>
<td>
<p>Difference in price between the two transactions</p>
</td></tr>
<tr><td><code id="rtModel.robust_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted).  Must be in that class.</p>
</td></tr>
<tr><td><code id="rtModel.robust_+3A_lm_recover">lm_recover</code></td>
<td>
<p>(TRUE) Allows robust model to use linear model if it fails</p>
</td></tr>
<tr><td><code id="rtModel.robust_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?rtModel' for more information
</p>

<hr>
<h2 id='rtModel.weighted'>Repeat transaction model approach with weighted estimator</h2><span id='topic+rtModel.weighted'></span>

<h3>Description</h3>

<p>Use of weighted estimator in repeat transactions model approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weighted'
rtModel(rt_df, time_matrix, price_diff, estimator, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtModel.weighted_+3A_rt_df">rt_df</code></td>
<td>
<p>Repeat transactions dataset from rtCreateTrans()</p>
</td></tr>
<tr><td><code id="rtModel.weighted_+3A_time_matrix">time_matrix</code></td>
<td>
<p>Time matrix object from rtTimeMatrix()</p>
</td></tr>
<tr><td><code id="rtModel.weighted_+3A_price_diff">price_diff</code></td>
<td>
<p>Difference in price between the two transactions</p>
</td></tr>
<tr><td><code id="rtModel.weighted_+3A_estimator">estimator</code></td>
<td>
<p>Type of model to estimates (base, robust, weighted).  Must be in that class.</p>
</td></tr>
<tr><td><code id="rtModel.weighted_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Further Details</h3>

<p>See '?rtModel' for more information
</p>

<hr>
<h2 id='rtTimeMatrix'>Create model matrix for repeat transaction approach</h2><span id='topic+rtTimeMatrix'></span>

<h3>Description</h3>

<p>Generates the array necessary to estimate a repeat transactions model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtTimeMatrix(rt_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtTimeMatrix_+3A_rt_df">rt_df</code></td>
<td>
<p>object of class 'rtdata': repeat transaction data.frame created by
rtCreateTrans()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix to be used on the right hand side of a repeat sales regression model
</p>


<h3>Further Details</h3>

<p>Time periods are calculated from the data provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Load data
  data(ex_sales)

  # With a raw transaction data.frame
  rt_data &lt;- rtCreateTrans(trans_df = ex_sales,
                           prop_id = 'pinx',
                           trans_id = 'sale_id',
                           price = 'sale_price',
                           periodicity = 'monthly',
                           date = 'sale_date')
 # Create Matrix
 rt_matrix &lt;- rtTimeMatrix(rt_data)

</code></pre>

<hr>
<h2 id='seattle_sales'>Seattle Home Sales</h2><span id='topic+seattle_sales'></span>

<h3>Description</h3>

<p>Seattle home sales from 2010 to 2016. Includes only detached single family
residences and townhomes.  Data gathered from the King County Assessor's FTP site.
A number of initial data munging tasks were necessary to bring the data into this format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seattle_sales)
</code></pre>


<h3>Format</h3>

<p>A <code>"data.frame"</code> with 43,313 rows and 16 variables
</p>

<dl>
<dt>pinx</dt><dd><p>The unique property identifying code.  Original value is preceded by two '..'s to prevent the dropping of leading zeros</p>
</dd>
<dt>sale_id</dt><dd><p>The unique transaction identifying code.</p>
</dd>
<dt>sale_price</dt><dd><p>Price of the home</p>
</dd>
<dt>sale_date</dt><dd><p>Date of sale</p>
</dd>
<dt>use_type</dt><dd><p>Property use type</p>
</dd>
<dt>area</dt><dd><p>Assessment area or zone</p>
</dd>
<dt>lot_sf</dt><dd><p>Size of lot in square feet</p>
</dd>
<dt>wfnt</dt><dd><p>Is property waterfront?</p>
</dd>
<dt>bldg_grade</dt><dd><p>Quality of the building construction (higher is better)</p>
</dd>
<dt>tot_sf</dt><dd><p>Size of home in square feet</p>
</dd>
<dt>beds</dt><dd><p>Number of bedrooms</p>
</dd>
<dt>baths</dt><dd><p>Number of bathrooms</p>
</dd>
<dt>age</dt><dd><p>Age of home</p>
</dd>
<dt>eff_age</dt><dd><p>Age of home, considering major remodels</p>
</dd>
<dt>longitude</dt><dd><p>Longitude</p>
</dd>
<dt>latitude</dt><dd><p>Latitude </p>
</dd>
</dl>


<h3>Source</h3>

<p>King County Assessor: http://info.kingcounty.gov/assessor/DataDownload/
</p>

<hr>
<h2 id='smoothIndex'>Smooth an index</h2><span id='topic+smoothIndex'></span>

<h3>Description</h3>

<p>Smooths an existing hpiindex object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothIndex(index_obj, order = 3, in_place = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothIndex_+3A_index_obj">index_obj</code></td>
<td>
<p>Index to be smoothed</p>
</td></tr>
<tr><td><code id="smoothIndex_+3A_order">order</code></td>
<td>
<p>default = 3; Number of nearby period to smooth with, multiple means
multiple iterations</p>
</td></tr>
<tr><td><code id="smoothIndex_+3A_in_place">in_place</code></td>
<td>
<p>default = FALSE; adds smoothed index to the 'hpiindex' object</p>
</td></tr>
<tr><td><code id="smoothIndex_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &lsquo;ts&ldquo; and &rsquo;smooth_index' object with smoothed index
</p>


<h3>Further Details</h3>

<p>Leaving order blank default to a moving average with order 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data
 data(ex_sales)

 # Create index with raw transaction data
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 # Create Smooth index
 sm_index &lt;- smoothIndex(index_obj = rt_index,
                         order = 3,
                         in_place = FALSE)

 # Create Smooth index (in place)
 sm_index &lt;- smoothIndex(index_obj = rt_index,
                         order = 3,
                         in_place = TRUE)

</code></pre>

<hr>
<h2 id='smoothSeries'>Smooth all indexes in a series</h2><span id='topic+smoothSeries'></span>

<h3>Description</h3>

<p>Smooths all indexes within a progressive series of indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothSeries(series_obj, order = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothSeries_+3A_series_obj">series_obj</code></td>
<td>
<p>Series to be smoothed</p>
</td></tr>
<tr><td><code id="smoothSeries_+3A_order">order</code></td>
<td>
<p>Number of nearby period to smooth with</p>
</td></tr>
<tr><td><code id="smoothSeries_+3A_...">...</code></td>
<td>
<p>Additional Arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'serieshpi' object with a smoothed index in each 'hpiindex' object
</p>


<h3>Further Details</h3>

<p>Leaving order blank default to a moving average with order 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Load data
 data(ex_sales)

 # Create index
 rt_index &lt;- rtIndex(trans_df = ex_sales,
                     periodicity = 'monthly',
                     min_date = '2010-06-01',
                     max_date = '2015-11-30',
                     adj_type = 'clip',
                     date = 'sale_date',
                     price = 'sale_price',
                     trans_id = 'sale_id',
                     prop_id = 'pinx',
                     estimator = 'robust',
                     log_dep = TRUE,
                     trim_model = TRUE,
                     max_period = 48,
                     smooth = FALSE)

 #  Create Series (Suppressing messages do to small sample size of this example)
 suppressMessages(
    hpi_series &lt;- createSeries(hpi_obj = rt_index,
                               train_period = 12))
 # Smooth indexes
 sm_series &lt;- smoothSeries(series_obj = hpi_series,
                           order = 5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
