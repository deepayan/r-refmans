<!DOCTYPE html><html><head><title>Help for package exvatools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {exvatools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bkd'><p>Get block diagonal matrix</p></a></li>
<li><a href='#bkdiag'><p>Diagonalize blocks of a block matrix</p></a></li>
<li><a href='#bkoffd'><p>Get block off-diagonal matrix</p></a></li>
<li><a href='#bkt'><p>Block transpose matrix</p></a></li>
<li><a href='#bktt'><p>Block transpose matrix with transposed blocks</p></a></li>
<li><a href='#csums'><p>Sum matrix columns and assign name to resulting row</p></a></li>
<li><a href='#diagcs'><p>Diagonalize the sums of columns of a matrix</p></a></li>
<li><a href='#dmult'><p>Multiply a diagonal matrix by another matrix</p></a></li>
<li><a href='#get_data'><p>Get data from different exvatools objects</p></a></li>
<li><a href='#get_exvadec_bkdown'><p>Get a summary decomposition of value added in exports</p></a></li>
<li><a href='#get_geo_codes'><p>Get the ISO3 codes of standard country groups</p></a></li>
<li><a href='#get_sec_codes'><p>Get the ISO3 codes of standard sector groups</p></a></li>
<li><a href='#get_va_exgr'><p>Detailed origin and destination of value added in gross exports</p></a></li>
<li><a href='#get_va_exgry'><p>Detailed origin and final absorption of value added in gross exports</p></a></li>
<li><a href='#get_va_fd'><p>Value added induced by final demand</p></a></li>
<li><a href='#get_xmatrix'><p>Get extraction matrix.</p></a></li>
<li><a href='#hmult'><p>Hadamard product of matrices</p></a></li>
<li><a href='#iciotest_data'><p>ICIO-type input-output table example data</p></a></li>
<li><a href='#info_geo'><p>Show available countries and country groups in a specific Input-Output table</p></a></li>
<li><a href='#info_sec'><p>Show available sectors and sector groups included in a specific Input-Output table</p></a></li>
<li><a href='#make_custom_wio'><p>Make standard world input-output matrices from custom data</p></a></li>
<li><a href='#make_exvadec'><p>Decomposition of value added in exports using different methodologies</p></a></li>
<li><a href='#make_exvadir'><p>Direction (detailed  origin and destination) of value added in exports</p></a></li>
<li><a href='#make_wio'><p>Make standard world input-output matrices from source files</p></a></li>
<li><a href='#meld'><p>Meld ICIO-type matrix (consolidating China and Mexico sub-components)</p></a></li>
<li><a href='#multd'><p>Multiply a matrix by a diagonal matrix</p></a></li>
<li><a href='#print.exvadec'><p>Print method for <code>exvadec</code> class</p></a></li>
<li><a href='#print.exvadir'><p>Print method for <code>exvadir</code> class</p></a></li>
<li><a href='#print.wio'><p>Print method for <code>wio</code> class</p></a></li>
<li><a href='#rsums'><p>Sum matrix rows and assign name to resulting column</p></a></li>
<li><a href='#set_zero'><p>Set to zero specific rows and columns of a matrix</p></a></li>
<li><a href='#sumgcols'><p>Sum groups of columns of a matrix and name the resulting columns</p></a></li>
<li><a href='#sumgrows'><p>Sum groups of rows of a matrix and name the resulting rows</p></a></li>
<li><a href='#summary.exvadec'><p>Summary method for <code>exvadec</code> class</p></a></li>
<li><a href='#summary.exvadir'><p>Summary method for <code>exvadir</code> class</p></a></li>
<li><a href='#summary.wio'><p>Summary method for <code>wio</code> class</p></a></li>
<li><a href='#sumncol'><p>Sum every nth column of a matrix and name the resulting columns</p></a></li>
<li><a href='#sumnrow'><p>Sum every nth row of a matrix and name the resulting rows</p></a></li>
<li><a href='#wiodtest_data'><p>WIOD-type input-output table example data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Value Added in Exports and Other Input-Output Table Analysis
Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of trade in value added with international
    input-output tables. Includes commands for easy data extraction,
    matrix manipulation, decomposition of value added in gross exports and
    calculation of value added indicators, with full geographical and
    sector customization.  Decomposition methods include Borin and Mancini
    (2023) &lt;<a href="https://doi.org/10.1080%2F09535314.2022.2153221">doi:10.1080/09535314.2022.2153221</a>&gt;, Miroudot and Ye (2021)
    &lt;<a href="https://doi.org/10.1080%2F09535314.2020.1730308">doi:10.1080/09535314.2020.1730308</a>&gt;, Wang et al. (2013)
    <a href="https://econpapers.repec.org/paper/nbrnberwo/19677.htm">https://econpapers.repec.org/paper/nbrnberwo/19677.htm</a> and Koopman
    et al. (2014) &lt;<a href="https://doi.org/10.1257%2Faer.104.2.459">doi:10.1257/aer.104.2.459</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, data.table, methods, openxlsx, reshape2, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 22:21:36 UTC; Enrique</td>
</tr>
<tr>
<td>Author:</td>
<td>Enrique Feas <a href="https://orcid.org/0000-0002-9431-6051"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Enrique Feas &lt;efeas@runbox.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-05 07:33:00 UTC</td>
</tr>
</table>
<hr>
<h2 id='bkd'>Get block diagonal matrix</h2><span id='topic+bkd'></span>

<h3>Description</h3>

<p>Produces a block diagonal matrix version of block matrix, i.e., a matrix
in which the diagonal blocks are non-zero and the off-diagonal blocks
are zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkd(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkd_+3A_df">df</code></td>
<td>
<p>A block matrix with named rows and columns. Names of countries
and sectors are automatically identified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Block diagonal version of the original matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
# Block diagonal version of Y (coincides with Yd)
bkd(wio$Y)
</code></pre>

<hr>
<h2 id='bkdiag'>Diagonalize blocks of a block matrix</h2><span id='topic+bkdiag'></span>

<h3>Description</h3>

<p>Diagonalize each block of a block matrix, so sectors of origin become also
sectors of destination. Blocks of dimension <code>NxN</code> will remain
<code>NxN</code>, but diagonalized, and blocks of dimensions <code>Nx1</code> will
be expanded to <code>NxN</code> and then diagonalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkdiag(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkdiag_+3A_df">df</code></td>
<td>
<p>A block matrix with named rows and columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>df</code> with blocks of dimension <code>NxN</code> diagonalized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
# Normal version of matrix Y
wio$Y
# Diagonal version (show first columns only)
bkdiag(wio$Y)[, 1:6]
</code></pre>

<hr>
<h2 id='bkoffd'>Get block off-diagonal matrix</h2><span id='topic+bkoffd'></span>

<h3>Description</h3>

<p>Produces a block off-diagonal matrix version of block matrix, i.e., a matrix
in which the diagonal blocks are zero and the off-diagonal blocks
are non-zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkoffd(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkoffd_+3A_df">df</code></td>
<td>
<p>A block matrix with named rows and columns. Names of countries
and sectors are automatically identified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Block off-diagonal version of the original matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
# Block off-diagonal version of Y (coincides with Ym)
bkoffd(wio$Y)
</code></pre>

<hr>
<h2 id='bkt'>Block transpose matrix</h2><span id='topic+bkt'></span>

<h3>Description</h3>

<p>Transpose a matrix by blocks, so <code>block(s,r)</code> becomes <code>block(r,s)</code>, but
elements within each block are not transposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkt(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkt_+3A_df">df</code></td>
<td>
<p>A block matrix with named rows and columns. Names of countries
and sectors are automatically identified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bkt()</code> takes a matrix of <code style="white-space: pre;">&#8288;c1 x c2&#8288;</code> blocks where each
block has a dimension <code style="white-space: pre;">&#8288;s1 x s2&#8288;</code> and transposes its blocks. Block
<code>B21</code> becomes <code>B12</code>, <code>B31</code> becomes <code>B13</code>, etc., but
blocks are not altered internally. For instance, a matrix with rows
5 exporting countries of 4 sectors each and columns with 3
importing countries with 2 aggregated sectors, i.e., a
(5 x 4) x (3 x 2), matrix will become a (3 x 4) x (5 x 2) matrix. The
rows will now show the importing countries and the sectors they import
from, and the columns will show the the exporting countries and the
sectors they export from.
</p>


<h3>Value</h3>

<p>Block transposed version of <code>df</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bktt">bktt()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
# Matrix Ym (exports of final products)
wio$Ym
# Block transposed version of Ym (imports of final products)
bkt(wio$Ym)
</code></pre>

<hr>
<h2 id='bktt'>Block transpose matrix with transposed blocks</h2><span id='topic+bktt'></span>

<h3>Description</h3>

<p>Block transpose matrix and then transpose each block. <code>block(s,r)</code> is
transformed into <code>block(r,s)</code> and then internally transposed. This is not
equivalent to directly transpose the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bktt(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bktt_+3A_df">df</code></td>
<td>
<p>A square block matrix with named rows and columns.
Names of countries and sectors are automatically identified. Unlike
<code><a href="#topic+bkt">bkt()</a></code>, <code>bktt()</code> can only be used with square block
matrices with <code>NxN</code> blocks (with row and column names in the form
<code>AUS_01T02</code>, <code>AUS_05</code>, etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Block transposed version of <code>df</code> with elements transposed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bkt">bkt()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
# Block-transpose Z and transpose blocks (show first elements only)
bktt(wio$Z)[1:6, 1:6]
# Note that directly transposing Z produces a different result:
t(wio$Z)[1:6, 1:6]
</code></pre>

<hr>
<h2 id='csums'>Sum matrix columns and assign name to resulting row</h2><span id='topic+csums'></span>

<h3>Description</h3>

<p>Improved version of <code>colSums()</code> for matrix output. The sum of columns is
kept as a row vector with column names and the resulting row can be
named in the same command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csums(df, row_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csums_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
<tr><td><code id="csums_+3A_row_name">row_name</code></td>
<td>
<p>String, name to assign to resulting row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row matrix (with rows and column names)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
csums(wio$Y, "TOTAL_Y")
</code></pre>

<hr>
<h2 id='diagcs'>Diagonalize the sums of columns of a matrix</h2><span id='topic+diagcs'></span>

<h3>Description</h3>

<p>Makes a diagonal matrix with the sums of columns of a matrix.
</p>
<p>Diagonalizes the sums of each column of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagcs(df)

diagcs(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagcs_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A diagonal matrix with the sums of columns in the diagonal.
</p>
<p>A diagonal matrix with the sums of columns in the diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest")
diagcs(wio$W %*% wio$Bd)
wio &lt;- make_wio("wiodtest")
diagcs(wio$W %*% wio$Bd)
</code></pre>

<hr>
<h2 id='dmult'>Multiply a diagonal matrix by another matrix</h2><span id='topic+dmult'></span>

<h3>Description</h3>

<p>Fast multiplication of a diagonal matrix by another matrix, taking
taking advantage of the properties of diagonal matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmult(matrix1, matrix2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmult_+3A_matrix1">matrix1</code></td>
<td>
<p>A diagonal matrix.</p>
</td></tr>
<tr><td><code id="dmult_+3A_matrix2">matrix2</code></td>
<td>
<p>An ordinary matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dmult()</code> will turn <code>matrix1</code> into a vector and multiply it
horizontally by every rows in <code>matrix2</code>. This saves precious computing
time.\
The number of rows and columns of the diagonal <code>matrix1</code> must be
equal to the number of rows of <code>matrix1</code>.
</p>


<h3>Value</h3>

<p>Product of matrix1 and matrix2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multd">multd()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest")
dmult(wio$W, wio$Bd)
</code></pre>

<hr>
<h2 id='get_data'>Get data from different exvatools objects</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Extracts exporting country and sector and destination data from a specific
variable in an <code>exvatools</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(
  exvatools_object,
  var,
  exporter,
  sector = "TOTAL",
  importer = "WLD",
  demand_comp = "TOTAL",
  custom = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_exvatools_object">exvatools_object</code></td>
<td>
<p>An <code>exvatools</code> object (<code>wio</code>,
<code>exvadec</code> or <code>exvadir</code>). If it is an ICIO <code>wio</code>, it will
be previously melded (i.e., China and Mexico will be grouped).</p>
</td></tr>
<tr><td><code id="get_data_+3A_var">var</code></td>
<td>
<p>String for the selected variable included in the <code>exvatools</code>
object: <code>"VA"</code>, <code>"X"</code>, <code>"EXGR"</code>, <code>"VAX"</code>,
<code>"DC"</code>, <code>"DVA"</code>, etc.</p>
</td></tr>
<tr><td><code id="get_data_+3A_exporter">exporter</code></td>
<td>
<p>String vector with codes of the exporting countries.\
If the <code>exvadec</code> object includes only one country or country group,
<code>exporter</code> is not required (data can only be extracted
for that country).\
If <code>exporter</code> is not specified and it is an <code>exvadir</code> object,
the exporter will be considered the world (<code>"WLD"</code>), as by
definition exporters in <code>exvadir</code> objects are the countries of
origin of value added. \
To include a vector with several exporters (e.g., <code>c("ESP", "FRA")</code>)
the <code>exvadec</code> object must have been created with the option
<code>exporter = "all"</code> in the command <code><a href="#topic+make_exvadec">make_exvadec()</a></code>.
<code>get_data()</code> will then produce matrices horizontally bound.</p>
</td></tr>
<tr><td><code id="get_data_+3A_sector">sector</code></td>
<td>
<p>A character vector with sector codes, e.g. <code>TOTAL</code>,
<code>AGF</code>, <code>MANUF</code>, <code>c("TOTAL", "AGF", "MANUF", "SERVS")</code>.
Available codes can be checked with <code><a href="#topic+info_sec">info_sec()</a></code>.</p>
</td></tr>
<tr><td><code id="get_data_+3A_importer">importer</code></td>
<td>
<p>String vector with importing country or country group codes,
e.g. <code>"WLD"</code>, <code>"ESP"</code>, <code>"EU27"</code>, <code>c("WLD", "EU27", "NONEU27")</code>. Available codes can be checked with
<code><a href="#topic+info_geo">info_geo()</a></code>.\
Please note that country groups will not show the strict values of
<code>"DVA"</code>, <code>"VAX"</code> etc. but an average value of the countries
included in that group. To obtain the specific <code>"DVA"</code>,
<code>"VAX"</code>, etc. for a group, an <code>exvadec</code> object must be
specifically created for that country group.\
Of course, variables that do not require to exclude double-counting,
like <code>"EXGR"</code>, <code>"DC"</code> or<code>"FC"</code> will be the same in
both cases, so no specific <code>exvadec</code> object will be required.</p>
</td></tr>
<tr><td><code id="get_data_+3A_demand_comp">demand_comp</code></td>
<td>
<p>A character vector of demand components, e.g.,
<code>"HFCE"</code>, <code>c("HFCE", "GCFC")</code>. Only valid for <code>wio</code>
objects.</p>
</td></tr>
<tr><td><code id="get_data_+3A_custom">custom</code></td>
<td>
<p>Boolean specifying whether custom-made groups of countries
or sectors are present in the environment to be used. For instance, a
custom <code>HITECH</code> custom variable including high-tech sectors or
a <code>LDC</code> variable with list of least-developed countries. Note that
custom variables should be referred to as strings in <code>get_data()</code>,
i.e. as <code>"HITECH"</code> and <code>"LDC"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-dimensional matrix with sector and geographical data of a
variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest")
get_data(wio, "EXGR", exp = "ESP", sec = "MANUF")
get_data(wio, "EXGR", exp = "ESP", sec = c("TOTAL", "MANUF", "SRVWC"),
         imp = c("USA", "FRA"))
</code></pre>

<hr>
<h2 id='get_exvadec_bkdown'>Get a summary decomposition of value added in exports</h2><span id='topic+get_exvadec_bkdown'></span>

<h3>Description</h3>

<p>Detail from an <code>exvadec</code> decomposition of a country by sector and
by destination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_exvadec_bkdown(
  exvadec_object,
  exporter = "WLD",
  sector = "TOTAL",
  importer = "WLD"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_exvadec_bkdown_+3A_exvadec_object">exvadec_object</code></td>
<td>
<p>An <code>exvadec</code> object created by
<code><a href="#topic+make_exvadec">make_exvadec()</a></code>.</p>
</td></tr>
<tr><td><code id="get_exvadec_bkdown_+3A_exporter">exporter</code></td>
<td>
<p>A character string with the code for the exporting country</p>
</td></tr>
<tr><td><code id="get_exvadec_bkdown_+3A_sector">sector</code></td>
<td>
<p>Character code of sector</p>
</td></tr>
<tr><td><code id="get_exvadec_bkdown_+3A_importer">importer</code></td>
<td>
<p>Character code of importer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print result to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
exvadec &lt;- make_exvadec(wio, quiet = TRUE)
get_exvadec_bkdown(exvadec, "ESP", "MANUF")
</code></pre>

<hr>
<h2 id='get_geo_codes'>Get the ISO3 codes of standard country groups</h2><span id='topic+get_geo_codes'></span>

<h3>Description</h3>

<p>Gets the ISO3 codes of standard country groups available for the
different input-output tables. The resulting format can be used to
extract elements of a matrix using <code>grep</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geo_codes(geo_id, wiotype = "icio2023", icio_extend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_geo_codes_+3A_geo_id">geo_id</code></td>
<td>
<p>String, country group id. Available <code>geo_ids</code> for a
specific input-output table can be obtained with the command
<code><a href="#topic+info_geo">info_geo()</a></code>.</p>
</td></tr>
<tr><td><code id="get_geo_codes_+3A_wiotype">wiotype</code></td>
<td>
<p>String, type of input-output table.</p>
</td></tr>
<tr><td><code id="get_geo_codes_+3A_icio_extend">icio_extend</code></td>
<td>
<p>Boolean. If <code>TRUE</code> and the input-output table
is of type <code>icio</code> extended, codes will also include the extended elements
for China (<code>CN1</code>, <code>CN2</code>) and Mexico (<code>MX1</code>, <code>MX2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Codes of country/countries ready to grep, e.g. <code>AUS|ARG|BEL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the codes of EU27 countries
get_geo_codes("EU27", "icio2023")
# Gets the codes for NAFTA and extends MEX to MX1|MX2
get_geo_codes("NAFTA", "icio2023", icio_extend = TRUE)
</code></pre>

<hr>
<h2 id='get_sec_codes'>Get the ISO3 codes of standard sector groups</h2><span id='topic+get_sec_codes'></span>

<h3>Description</h3>

<p>Gets the ISO3 codes of standard sector groups available for the
different input-output tables. The resulting format can be used to
extract elements of a matrix using <code>grep</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sec_codes(sector_id, wiotype = "icio2023", remove_letter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sec_codes_+3A_sector_id">sector_id</code></td>
<td>
<p>String, sector or sector group code. Available
<code>sector_ids</code> can be obtained with the command
<code><a href="#topic+info_sec">info_sec()</a></code>.</p>
</td></tr>
<tr><td><code id="get_sec_codes_+3A_wiotype">wiotype</code></td>
<td>
<p>String, type of input-output database.</p>
</td></tr>
<tr><td><code id="get_sec_codes_+3A_remove_letter">remove_letter</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the initial letter from
the sector code will be removed: <code>D20</code> or <code>C20</code> will
become <code style="white-space: pre;">&#8288;_20&#8288;</code>. This is needed to grep rows and columns, as
country-sector naming follows the pattern <code>AUS_01T02</code>, i.e.,
without the initial letter <code>D</code> or <code>C</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Codes of sector ready to grep, e.g. <code style="white-space: pre;">&#8288;_01|_02|_03&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get sector codes for manufactures in the icio2023 database.
get_sec_codes("MANUF", "icio2023")
# Get sector codes for services (including construction)
get_sec_codes("SRVWC", "icio2023")
# Get sector codes for manufacturing, removing the first letter so
# the result can be used with `grep` to select specific sectors from
# a matrix
get_sec_codes("MANUF", "icio2023", remove_letter = TRUE)
</code></pre>

<hr>
<h2 id='get_va_exgr'>Detailed origin and destination of value added in gross exports</h2><span id='topic+get_va_exgr'></span>

<h3>Description</h3>

<p>Origin of value added in gross exports. It combines a
<code><a href="#topic+make_exvadir">make_exvadir()</a></code> command and a <code><a href="#topic+get_data">get_data()</a></code> command to obtain
a result equivalent to the OECD's Origin of Value added in Gross Exports
<code>EXGR_BSCI</code>, but with much more flexible geographical and sector options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_va_exgr(
  wio_object,
  va_type = "FC",
  geo_orig = "WLD",
  sec_orig = "TOTAL",
  geo_export,
  sec_export = "TOTAL",
  as_numeric = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_va_exgr_+3A_wio_object">wio_object</code></td>
<td>
<p>An object of class <code>wio</code>.</p>
</td></tr>
<tr><td><code id="get_va_exgr_+3A_va_type">va_type</code></td>
<td>
<p>Character string specifying the output as domestic
content (<code>"DC"</code>), foreign content (<code>"FC"</code>) or total
content (<code>"TC"</code>) from the perspective of the exporter.
As origin of value added is specified, this is normally redundant, but in
the case of exporter <code>"WLD"</code>, the domestic and foreign content is
considered as the sum of domestic/foreign contents of all individual
countries. For groups (such as <code>"EU27"</code>) domestic/foreign means value
added from within/outside the group.</p>
</td></tr>
<tr><td><code id="get_va_exgr_+3A_geo_orig">geo_orig</code></td>
<td>
<p>Character string with code of country or country group
of origin of value added</p>
</td></tr>
<tr><td><code id="get_va_exgr_+3A_sec_orig">sec_orig</code></td>
<td>
<p>Character string with code of sector or sector group
of origin of value added. Combinations (with <code>"|"</code>) and exceptions
(with <code>"x"</code>) are allowed.</p>
</td></tr>
<tr><td><code id="get_va_exgr_+3A_geo_export">geo_export</code></td>
<td>
<p>Character string with code of exporting country or
country group.</p>
</td></tr>
<tr><td><code id="get_va_exgr_+3A_sec_export">sec_export</code></td>
<td>
<p>Character string with code of exporting sector or
sector group. Combinations (with <code>"|"</code>) and exceptions (with <code>"x"</code>)
are allowed.</p>
</td></tr>
<tr><td><code id="get_va_exgr_+3A_as_numeric">as_numeric</code></td>
<td>
<p>Boolean specifying whether to return a numeric value or
matrix (<code>TRUE</code>, default) or a data frame (default for
<code><a href="#topic+get_data">get_data()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, vector or data frame with export value added data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("iciotest")
# Exports of manufactures of Spain using foreign VA from France
get_va_exgr(wio, "FC", "FRA", "TOTAL", "ESP", "MANUF")
</code></pre>

<hr>
<h2 id='get_va_exgry'>Detailed origin and final absorption of value added in gross exports</h2><span id='topic+get_va_exgry'></span>

<h3>Description</h3>

<p>Get exports in terms of final absorption by origin of
value added and final destination. It combines a <code><a href="#topic+make_exvadir">make_exvadir()</a></code>
command and a <code><a href="#topic+get_data">get_data()</a></code> command to obtain a result equivalent to
that of the OECD's Gross Exports by Origin of Value Added and
Final destination (<code>FD_EXGR_VA</code>, <code>FD_EXGRFNL_VA</code> and <code>FD_EXGRINT_VA</code>),
but with much more flexible geographical and sector options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_va_exgry(
  wio_object,
  va_type = "TC",
  flow_type = "EXGRY",
  geo_orig = "WLD",
  geo_export,
  sec_export = "TOTAL",
  geo_fd = "WLD",
  as_numeric = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_va_exgry_+3A_wio_object">wio_object</code></td>
<td>
<p>An object of class <code>wio</code>.</p>
</td></tr>
<tr><td><code id="get_va_exgry_+3A_va_type">va_type</code></td>
<td>
<p>String for domestic content (<code>"DC"</code>), foreign content
(<code>"FC"</code>) or total content (<code>"TC"</code>) from the perspective of the exporter.
As origin of value added is specified, this is normally redundant, but
in the case of exporter <code>"WLD"</code>, the domestic and foreign content is
considered as the sum of domestic/foreign contents of all individual
countries. For groups (such as <code>"EU27"</code>) domestic/foreign means value
added from within/outside the group.</p>
</td></tr>
<tr><td><code id="get_va_exgry_+3A_flow_type">flow_type</code></td>
<td>
<p>String specifying the type of flow in terms of absorption.
It can be total gross exports (<code>"EXGRY"</code>), exports of final products
(<code>"EXGRY_FIN"</code>) or exports of intermediates (<code>"EXGRY_INT"</code>).</p>
</td></tr>
<tr><td><code id="get_va_exgry_+3A_geo_orig">geo_orig</code></td>
<td>
<p>Character string with code of country or country group
of origin of value added.</p>
</td></tr>
<tr><td><code id="get_va_exgry_+3A_geo_export">geo_export</code></td>
<td>
<p>Character string with code of exporting country or
country group.</p>
</td></tr>
<tr><td><code id="get_va_exgry_+3A_sec_export">sec_export</code></td>
<td>
<p>Character string with code of exporting sector or
sector group. Combinations (with <code>"|"</code>) and exceptions (with <code>"x"</code>)
are allowed.</p>
</td></tr>
<tr><td><code id="get_va_exgry_+3A_geo_fd">geo_fd</code></td>
<td>
<p>String character with code of country or country group
of final destination of exports</p>
</td></tr>
<tr><td><code id="get_va_exgry_+3A_as_numeric">as_numeric</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), returns a numeric
value, vector or matrix instead of a data frame (default for
<code><a href="#topic+get_data">get_data()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, vector or data frame with data of exports
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What part of French value added exported as US final intermediate
# manufactures ends up absorbed by Spain?
wio &lt;- make_wio("iciotest")
get_va_exgry(wio, flow_type = "EXGRY_INT", geo_orig = "FRA",
             geo_export = "USA", sec_export = "MANUF", geo_fd = "ESP")
</code></pre>

<hr>
<h2 id='get_va_fd'>Value added induced by final demand</h2><span id='topic+get_va_fd'></span>

<h3>Description</h3>

<p>Details of both geographical and sector origin of the
VA incorporated in exports induced by final demand. Equivalent to the
OECD's Origin of Value added in Final Demand (<code>FDVA_BSCI</code>), but with much
more flexible geographical and sector options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_va_fd(
  wio_object,
  va_type = "TOTAL",
  geo_orig = "WLD",
  sec_orig = "TOTAL",
  geo_fd = "WLD",
  sec_fd = "TOTAL",
  intra = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_va_fd_+3A_wio_object">wio_object</code></td>
<td>
<p>A <code>wio</code> object</p>
</td></tr>
<tr><td><code id="get_va_fd_+3A_va_type">va_type</code></td>
<td>
<p>String character with the type of VA induced (VA domestically
absorbed <code>"VAD"</code> or exported <code>"VAX"</code>) or the equivalent inducing VA
(domestic final demand <code>"DFD"</code> or foreign final demand
<code>"FFD"</code>). That is, <code>"VAD"</code> and <code>"DFD"</code> will produce the
same result, and so will <code>"VAX"</code> and <code>"FFD"</code>. Default is both,
i.e. <code>"TOTAL"</code> VA o total demand.</p>
</td></tr>
<tr><td><code id="get_va_fd_+3A_geo_orig">geo_orig</code></td>
<td>
<p>String character with code of country or country group
generating value added, i.e., exporter. Default is <code>"all"</code>)</p>
</td></tr>
<tr><td><code id="get_va_fd_+3A_sec_orig">sec_orig</code></td>
<td>
<p>String character with code of sector or sector group
generating value added. Default: <code>"all"</code>)</p>
</td></tr>
<tr><td><code id="get_va_fd_+3A_geo_fd">geo_fd</code></td>
<td>
<p>String character with code of country (or country group)
of final demand (inducing the generation of VA)</p>
</td></tr>
<tr><td><code id="get_va_fd_+3A_sec_fd">sec_fd</code></td>
<td>
<p>String character with code of sector (or sector group)
of final demand (inducing the generation of VA)</p>
</td></tr>
<tr><td><code id="get_va_fd_+3A_intra">intra</code></td>
<td>
<p>Boolean for inclusion of intra-regional exports
(default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with source and destination of value added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("iciotest")
# Get USA's total VA in services induced by China's manufacturing
get_va_fd(wio, geo_orig = "USA", sec_orig = "SRVWC",
         geo_fd = "CHN", sec_fd = "MANUF")
# Get world VA exported (VAX), i.e., world VA induced by the rest of
# the world not domestically absorbed
get_va_fd(wio, "VAX", "WLD", "TOTAL", "WLD", "TOTAL")
</code></pre>

<hr>
<h2 id='get_xmatrix'>Get extraction matrix.</h2><span id='topic+get_xmatrix'></span>

<h3>Description</h3>

<p>Creates a global extraction matrix <code>Anots</code> of an exporter and its inverse
<code>Bnots</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_xmatrix(
  wio,
  exporter,
  perim = "country",
  partner = "WLD",
  sector = "TOTAL",
  inverse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_xmatrix_+3A_wio">wio</code></td>
<td>
<p>A class <code>wio</code> object</p>
</td></tr>
<tr><td><code id="get_xmatrix_+3A_exporter">exporter</code></td>
<td>
<p>String, code of country or country group</p>
</td></tr>
<tr><td><code id="get_xmatrix_+3A_perim">perim</code></td>
<td>
<p>String: <code>"country"</code> for country perspective and
<code>"WLD"</code> for world perspective.</p>
</td></tr>
<tr><td><code id="get_xmatrix_+3A_partner">partner</code></td>
<td>
<p>String: code of country or country group
for bilateral perspectives (only with country).</p>
</td></tr>
<tr><td><code id="get_xmatrix_+3A_sector">sector</code></td>
<td>
<p>Character string: code of sector or sector group
for sector perspectives (only with country).</p>
</td></tr>
<tr><td><code id="get_xmatrix_+3A_inverse">inverse</code></td>
<td>
<p>Boolean, if <code>TRUE</code> returns the global inverse extraction
matrix <code>Bnots</code>, if <code>FALSE</code> just the global extraction matrix <code>Anots</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The global (inverse) extraction matrix of the specified exporter.
</p>

<hr>
<h2 id='hmult'>Hadamard product of matrices</h2><span id='topic+hmult'></span>

<h3>Description</h3>

<p>Hadamard product, i.e., element by element product of matrix <code>df1</code>
and matrix <code>df2</code> (by blocks). Both matrices must be block matrices, and the
number and dimension of blocks in matrix <code>df1</code> and <code>df2</code> must be
compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmult(df1, df2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmult_+3A_df1">df1</code></td>
<td>
<p>A block matrix with named rows and columns (country/sector)</p>
</td></tr>
<tr><td><code id="hmult_+3A_df2">df2</code></td>
<td>
<p>A block matrix with named rows and columns (country/sector)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a Hadamard product, matrices are multiplied block by block,
i.e., <code>block (s,r) %*% block(s,r)</code>.
</p>


<h3>Value</h3>

<p>Hadamard product of the two matrices.
</p>

<hr>
<h2 id='iciotest_data'>ICIO-type input-output table example data</h2><span id='topic+iciotest_data'></span>

<h3>Description</h3>

<p>An example of an ICIO-type input-output table, with rows for <code>MEX</code> and <code>CHN</code>
disaggregated into <code>MX1</code> and <code>MX2</code> and <code>CN1</code> and <code>CN2</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iciotest_data
</code></pre>


<h3>Format</h3>

<p>A matrix of 30 by 42, composed of two sub-matrices:
</p>

<ul>
<li><p> Sub-matrix <code>Z</code>, intermediate inputs: 30 by 30 (10 countries with 3
sectors each). 4 of those 10 are the extensions of <code>CHN</code> and <code>MEX</code>).
</p>
</li>
<li><p> Sub-matrix <code>Yfd</code>, final demand: 30 by 12 (10 countries with 3 sectors
each in rows, 6 countries by 2 demand components each in columns).
</p>
</li></ul>



<h3>Source</h3>

<p>Data were randomly generated with an uniform distribution.
</p>

<hr>
<h2 id='info_geo'>Show available countries and country groups in a specific Input-Output table</h2><span id='topic+info_geo'></span>

<h3>Description</h3>

<p>Show available countries and country groups in a specific Input-Output table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_geo(wiotype = "icio2023", lang = "en")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_geo_+3A_wiotype">wiotype</code></td>
<td>
<p>Character string specifying the world input-output database.</p>
</td></tr>
<tr><td><code id="info_geo_+3A_lang">lang</code></td>
<td>
<p>Character string for the language of the descriptive text:
<code>"eng"</code> for English (default) and <code>"es"</code> for Spanish.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints country codes and descriptive text in the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>info_geo("icio2023")
</code></pre>

<hr>
<h2 id='info_sec'>Show available sectors and sector groups included in a specific Input-Output table</h2><span id='topic+info_sec'></span>

<h3>Description</h3>

<p>Show available sectors and sector groups included in a specific Input-Output table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_sec(wiotype = "icio2023", lang = "en")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_sec_+3A_wiotype">wiotype</code></td>
<td>
<p>Character string specifying the world input-output database</p>
</td></tr>
<tr><td><code id="info_sec_+3A_lang">lang</code></td>
<td>
<p>Character string for the language of the descriptive text:
<code>eng</code> for English (default) and <code>es</code> for Spanish.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints ids, sector codes and descriptive text
</p>


<h3>Examples</h3>

<pre><code class='language-R'>info_sec("icio2023")
</code></pre>

<hr>
<h2 id='make_custom_wio'>Make standard world input-output matrices from custom data</h2><span id='topic+make_custom_wio'></span>

<h3>Description</h3>

<p>Creates a list object of class <code>wio</code> containing the typical
international input-output matrices in a standardized format, as well as a
list of code names (countries, sectors and demand components) and a list
of dimensions (number of countries, sectors and demand components), using
custom data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_custom_wio(
  df,
  g_names,
  n_names = NULL,
  fd_names = NULL,
  year = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_custom_wio_+3A_df">df</code></td>
<td>
<p>A data frame or matrix containing data for intermediate inputs
and final demand.</p>
</td></tr>
<tr><td><code id="make_custom_wio_+3A_g_names">g_names</code></td>
<td>
<p>A string vector with names of countries.</p>
</td></tr>
<tr><td><code id="make_custom_wio_+3A_n_names">n_names</code></td>
<td>
<p>A string vector with names of sectors. If missing, sectors
will be <code>S01</code>, <code>S02</code>, etc. If just one sector, it will be named
<code>TOTAL</code>.</p>
</td></tr>
<tr><td><code id="make_custom_wio_+3A_fd_names">fd_names</code></td>
<td>
<p>A string vector with names of final demand components.
If missing, demand components will be <code>FD1</code>, <code>FD2</code>, etc. If just one,
it will be named <code>FD</code>.</p>
</td></tr>
<tr><td><code id="make_custom_wio_+3A_year">year</code></td>
<td>
<p>Integer. If missing, the current year will be used.</p>
</td></tr>
<tr><td><code id="make_custom_wio_+3A_quiet">quiet</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, the function will produce a silent output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_custom_wio()</code> creates a <code>wio</code> from custom input-output data  provided
as a single matrix of dimension <code style="white-space: pre;">&#8288;GxN x GxFD&#8288;</code>, i.e., the matrix <code>Z</code> of
intermediate inputs (dimension <code style="white-space: pre;">&#8288;GxN x GxN&#8288;</code>) bound with the matrix <code>Yfd</code> of
final demand (dimension <code style="white-space: pre;">&#8288;GxN x GxFD&#8288;</code>). The matrices of total output <code>X</code> and
value added <code>VA</code> will be automatically generated, so should not be
included. Data must be exclusively numeric.
</p>
<p>A string vector with the names of countries is required. Number of countries
will be calculated from this vector. Names for sectors and final demand
components can be provided or will otherwise be automatically
generated. All names must be composed of alphabetic characters (no special
characters are allowed).
</p>


<h3>Value</h3>

<p>A <code>wio</code>object of <code>wiotype = "custom"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- as.data.frame(matrix(c(19:36), nrow = 3))
wio &lt;- make_custom_wio(df, g_names = c("C01", "C02", "C03"))
</code></pre>

<hr>
<h2 id='make_exvadec'>Decomposition of value added in exports using different methodologies</h2><span id='topic+make_exvadec'></span>

<h3>Description</h3>

<p>Calculates the decomposition of value added in exports of a country
or a group of countries according to different methodologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_exvadec(
  wio_object,
  exporter = "all",
  method = "bm_src",
  output = "standard",
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_exvadec_+3A_wio_object">wio_object</code></td>
<td>
<p>An object of class <code>wio</code> (standardized world
input-output table) obtained using <code><a href="#topic+make_wio">make_wio()</a></code>.</p>
</td></tr>
<tr><td><code id="make_exvadec_+3A_exporter">exporter</code></td>
<td>
<p>String with a country or a country group code
(e.g., <code>"USA"</code>, <code>"NAFTA"</code>, etc.). The default <code>"all"</code>
produces the decomposition of value added in exports for all
available individual countries.</p>
</td></tr>
<tr><td><code id="make_exvadec_+3A_method">method</code></td>
<td>
<p>A string specifying the export VA decomposition method:
</p>

<ul>
<li> <p><code>"bm_src"</code>: Borin and Mancini, source-based (2023) (default).
</p>
</li>
<li> <p><code>"bm_snk"</code>: Borin and Mancini, sink-based (2023).
</p>
</li>
<li> <p><code>"wwz"</code>: Wang et al. (2013).
</p>
</li>
<li> <p><code>"kww"</code>: Koopman et al. (2014).
</p>
</li>
<li> <p><code>"my"</code>: Miroudot and Ye (2021)
</p>
</li>
<li> <p><code>"oecd"</code>: OECD (not properly a decomposition).
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_exvadec_+3A_output">output</code></td>
<td>
<p>Type of matrices in output:
</p>

<ul>
<li> <p><code>"standard"</code> (default): Shows the domestic content (<code>DC</code>),
domestic value added (<code>DVA</code>), the domestic double counting
(<code>DDC</code>), the foreign content (<code>FC</code>), the foreign value
added (<code>FVA</code>) and the foreign double counting (<code>DDC</code>). The
value added exported (<code>VAX</code>) is also produced in most cases, and
additional indicators in some cases.
</p>
</li>
<li> <p><code>"terms"</code>: Shows the basic decomposition terms, whose sum gives
the value of gross exports. The number and specification of terms
follows the standard in the economic literature: 12 in the Borin and
Mancini (2019) decompositions (source and sink), 16 in the Wang et al.
(2013) decomposition, 9 in the Koopman et al. (2014) decomposition
and just 4 in the Miroudot and Ye (2021) decomposition (as the latter
does not expand value added in terms of final absorption). \
Additional outputs:
</p>
</li>
<li><p> For the <code>"bm_src"</code> (Borin and Mancini, 2023, source-based) method
there is an additional <code>"basic"</code> output, without <code>GVC</code> indicators. This
output will replace <code>"standard"</code> if targeted perspectives (sector,
bilateral or sector-bilateral) are selected.
</p>
</li>
<li><p> For the Miroudot and Ye (2021) method there is an additional
<code>"terms2"</code> output, when world perspective is selected.
</p>
</li>
<li><p> For the <code>"wwz"</code> (Wang et al. ,2013) decomposition there is an
additional <code>"terms2"</code> option with an alternative arrangement of
the 16 terms.
</p>
</li>
<li><p> For the <code>"oecd"</code> decomposition there is an additional <code>"tiva"</code>
output with several indicators of the OECD TiVA database.
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_exvadec_+3A_quiet">quiet</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, suppresses all status messages. Default
is <code>FALSE</code>, i.e., messages are shown.</p>
</td></tr>
<tr><td><code id="make_exvadec_+3A_...">...</code></td>
<td>
<p>Additional parameters for targeted value added perspectives.
These are only available for the <code>"bm_src"</code> (Borin and Mancini, 2023,
source-based) and the <code>"my"</code> (Miroudot and Ye, 2021) decomposition.
methods. Specific perimeters can be:
</p>

<ul>
<li> <p><code>partner</code> String, for bilateral perspective. Default is <code>"WLD"</code>, but
any country or country group code (e.g. <code>"USA"</code> or <code>"EU27"</code>) can be
specified. In that case, all flows that cross the bilateral geographic
perimeter more than once will be considered as double counting.
</p>
</li>
<li> <p><code>sector</code> String, for sector perspective. Default is <code>"TOTAL"</code>, but
any sector or sector group code (e.g. <code>"MANUF"</code>) can be specified. In
that case, all flows that cross the sector perimeter more than
once will be considered as double counting. \
The bilateral and sector perspectives can be combined in a
bilateral-sector perspective.
</p>
</li>
<li> <p><code>perim</code> Boolean (only for <code>"my"</code>, and incompatible with sector or partner
specifications). String, for general perimeter of value added.
If <code>perim = "WLD"</code> (world) is specified (default is exporting country),
then all flows that cross the border of <em>any</em> country
more than once will be considered as double counting (unlike in the
country perspective, where flows are considered as double counting
only when they <em>exit</em> the border of <em>the exporting country</em>
more than once). Please note that, when using the world perspective
(<code>perim = "WLD"</code>) and the terms output (<code>output = "terms"</code>, the foreign
double counting will be automatically divided into two
elements (<code>"terms2"</code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>exvadec</code> with several matrices
plus metadata.
</p>


<h3>References</h3>


<ul>
<li><p> Borin, A., &amp; Mancini, M. (2023). Measuring What Matters in Value-Added
Trade. Economic Systems Research, 1-25.
</p>
</li>
<li><p> Koopman, R., Wang, Z., &amp; Wei, S.-J. (2014). Tracing Value-Added and
Double Counting in Gross Exports. American Economic Review, 104(2),
459–494.
</p>
</li>
<li><p> Miroudot, S., &amp; Ye, M. (2021). Decomposing Value Added in Gross
Exports. Economic Systems Research, 33(1), 67–87.
</p>
</li>
<li><p> Wang, Z., Wei, S.-J., &amp; Zhu, K. (2013). Quantifying International
Production Sharing at the Bilateral and Sector Levels (NBER Working
Paper No. 19677). National Bureau of Economic Research, Inc.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create a test wio
wio &lt;- make_wio("iciotest")
# Make Borin and Mancini (2023) source decomposition for Spain
exvadec &lt;- make_exvadec(wio, exporter = "ESP", method = "bm_src")
# Make Wang et al. (2013) decomposition for all countries
# expressed in the traditional 16 terms
exvadec &lt;- make_exvadec(wio, method = "wwz", output = "terms")
</code></pre>

<hr>
<h2 id='make_exvadir'>Direction (detailed  origin and destination) of value added in exports</h2><span id='topic+make_exvadir'></span>

<h3>Description</h3>

<p>Direction of value added in exports, i.e., details of both
geographical and sector origin of the VA incorporated in exports and
of the final destination (in gross terms or in terms of final absorption).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_exvadir(
  wio_object,
  exporter,
  va_type = "TC",
  flow_type = "EXGR",
  orig_geo = "all",
  sec_orig = "all",
  via = "any",
  perspective = "exporter",
  intra = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_exvadir_+3A_wio_object">wio_object</code></td>
<td>
<p>A <code>wio</code> object</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_exporter">exporter</code></td>
<td>
<p>Country code (or country group code) of exporting country</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_va_type">va_type</code></td>
<td>
<p>VA total content (<code>"TC"</code>), domestic (<code>"DC"</code>) or foreign
content (<code>"FC"</code>) or VA content excluding double counting
(<code>"TVA"</code>, <code>"DVA"</code>, <code>"FVA"</code>)</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_flow_type">flow_type</code></td>
<td>
<p>Gross exports (<code>"EXGR"</code>) or in terms of final demand:
<code>"EXGRY"</code>, <code>"EXGRY_FIN"</code>, <code>"EXGRY_INT"</code>.</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_orig_geo">orig_geo</code></td>
<td>
<p>Geographical origin of value added (default: <code>"all"</code>)</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_sec_orig">sec_orig</code></td>
<td>
<p>Code of sector of origin of value added (default: <code>"all"</code>)</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_via">via</code></td>
<td>
<p>Code of intermediate importing country (default: <code>"any"</code>)</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_perspective">perspective</code></td>
<td>
<p>Sector perspective, <code>"origin"</code> or <code>"exporter"</code>.</p>
</td></tr>
<tr><td><code id="make_exvadir_+3A_intra">intra</code></td>
<td>
<p>Boolean for inclusion of intra-regional exports
(default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with source and destination of value added in exports
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
# Foreign services content of value added incorporated in exports of Spain,
# by country of origin and final destination, expressed in gross terms
# (equivalent to OECD TiVA’s indicator EXGR_SERV_FVA).
exvadir &lt;- make_exvadir(wio, va = "FC", flow="EXGR", exp="ESP",
                        sec_orig="SRVWC")
summary(exvadir)
</code></pre>

<hr>
<h2 id='make_wio'>Make standard world input-output matrices from source files</h2><span id='topic+make_wio'></span>

<h3>Description</h3>

<p>Creates a list object of class <code>wio</code> containing the typical
international input-output matrices in a standardized format, as well as a
list of code names (countries, sectors and demand components) and a list
of dimensions (number of countries, sectors and demand components). It
can use source files from well-known databases or internal data (test
data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_wio(wiotype = "icio2023", year = NULL, src_dir = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_wio_+3A_wiotype">wiotype</code></td>
<td>
<p>String specifying the name and edition of the
input-output tables to be used:
* <code>"icio2023"</code> for the 2023 edition of the OECD ICIO tables
(1995-2020) and <code>"icio2023s"</code> for the small format of the same edition.
The deprecated editions <code>"icio2021"</code> (1995-2018),
<code>"icio2018"</code> (1995-2011) and <code>"icio2016"</code>(2005-2015) remain
available for literature replication purposes.
* <code>"wiod2016"</code> for the 2016 edition of the WIOD tables
(2000-2014). The deprecated edition <code>"wiod2013"</code> (1995-2011)
remains available for literature replication purposes.
* <code>"lrwiod2022"</code> for the 2022 edition of the long-run WIOD
(1965-2000), useful for historical analysis.
* <code>"figaro2023i"</code> for the 2023 edition of the FIGARO EU Input-Output
Tables (EU IC-SUIOTs), industry-by-industry (2010-2021), and
<code>"figaro2023p"</code> for the product-by-product version of the same
database.The deprecated edition of 2022 (2010-2020)
remains available for literature replication purposes.
* <code>"mrio2023"</code> for the 2023 edition of the 62-country ADB MRIO tables,
<code>"mrio2023k"</code> for the same edition in constant prices, and
<code>"mrio2023x"</code> for the 72-country edition (years up to 2022).
* <code>"iciotest"</code> for an example of an ICIO-type international
input-output table (disaggregated for <code>MEX</code> into <code>MX1</code> and <code>MX2</code> and
for <code>CHN</code> into <code>CN1</code> and <code>CN2</code>) and <code>"wiodtest"</code> for an example of a
WIOD-type international input-output table (not disaggregated). Data
for these tables is not real, but these small input-output tables
are useful for didactic purposes and to check the functionality of
the program.</p>
</td></tr>
<tr><td><code id="make_wio_+3A_year">year</code></td>
<td>
<p>Integer specifying reference year. If <code>NULL</code> (default),
the last available year of the specified database will be used.</p>
</td></tr>
<tr><td><code id="make_wio_+3A_src_dir">src_dir</code></td>
<td>
<p>String specifying the source directory where the source file
of the international input-output tables is saved, normally as a zip file
(containing <code>.csv</code> files, <code>.RData</code> or <code>.xlsx</code> files, see Details). In
order for <code>make_wio()</code> to work, these zip files should not be renamed.
If <code>src_dir</code> is not specified, <code>make_wio()</code> will look in the
working directory.</p>
</td></tr>
<tr><td><code id="make_wio_+3A_quiet">quiet</code></td>
<td>
<p>Boolean, if <code>TRUE</code> suppress all status messages. Default
is <code>FALSE</code>, i.e., messages are shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_wio()</code> directly unzips and processes the original source files
for the different international input-output tables and returns a list
with the traditional matrices, including the coefficient matrix <code>A</code>, the
Leontief global inverse matrix <code>B</code>, the Leontief matrix of local inverse
matrices <code>Ld</code> and others.
</p>
<p>Original source files can be obtained from the OECD's
<a href="https://www.google.com/search?q=OECD+ICIO+tables">ICIO web page</a>,
the University of Groningen's
<a href="https://www.rug.nl/ggdc/valuechain/wiod/">WIOD web page</a>, the
<a href="https://ec.europa.eu/eurostat/web/esa-supply-use-input-tables/database">Eurostat web page</a>
or the <a href="https://kidb.adb.org/mrio">Asian Development Bank MRIO web page</a>
</p>
<p>If source files are used, they must be previously downloaded and
placed in an accessible folder in disk, without renaming them. The
following name pattern is expected:
</p>

<ul>
<li> <p><code>XXXX-XXXX.zip</code> for <code>"icio2023"</code> (<code>.csv</code> files)
</p>
</li>
<li> <p><code>XXXX-XXXX_SML.zip</code> for <code>"icio2023s"</code> (<code>.csv</code> files)
</p>
</li>
<li> <p><code>ICIO_XXXX-XXXX.zip</code> for <code>"icio2021"</code> (<code>.csv</code> files)
</p>
</li>
<li> <p><code>ICIO2018_XXXX.zip</code> for <code>"icio2018"</code> (<code>.csv</code> files)
</p>
</li>
<li> <p><code>ICIO2016_XXXX.zip</code> for <code>"icio2016"</code> (<code>.csv</code> files)
</p>
</li>
<li> <p><code>WIOTS_in_R.zip</code> for <code>"wiod2016"</code> (<code>.RData</code> files)
</p>
</li>
<li> <p><code>WIOTS_in_EXCEL.zip</code> for <code>"wiod2013"</code> (<code>.xlsx</code> files). Requires
package <code>openxlsx</code>..
</p>
</li>
<li> <p><code>lr_wiod_wiot_final_filled.csv</code> for <code>"lrwiod2022"</code>. Requires
packages <code>data.table</code> and <code>reshape2</code>.
</p>
</li>
<li> <p><code>matrix_eu-ic-io_ind-by-ind_23ed_XXXX.csv</code> for <code style="white-space: pre;">&#8288;"figaro2023i&#8288;</code> and
<code>matrix_eu-ic-io_prod-by-prod_23ed_XXXX.csv</code> for <code style="white-space: pre;">&#8288;"figaro2023p&#8288;</code>
(<code>.csv</code> files)
</p>
</li>
<li> <p><code>ADB-MRIO[XX]-XXXX_xxx2023.xlsx</code> for the <code>"mrio62-2023"</code>, <code>"mrio72-2023"</code>
and <code style="white-space: pre;">&#8288;ADB MRIO XXXX, at constant 2010 prices.xlsx&#8288;</code> for the
<code>"mrio62-2023k"</code> tables (with some exceptions).
The input-output framework follows the traditional demand model of
Leontief (1936), which makes assumptions about the stability of inputs
(and therefore value-added) as a proportion of production. This allows
production and value-added to be expressed as the result of variations
in final demand.\
Details about the content of the world input-output object (<code>wio</code>)
produced by <code>make_wio()</code> can be obtained with the command
<code>summary(wio_object)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list object of class <code>wio</code> including input-output
matrices, dimensions, and names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_custom_wio">make_custom_wio()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("iciotest")
summary(wio)
## Not run: 
# The following examples require the previous download of the source
# files in the working directory or in a directory specified by `src_dir`.
wio &lt;- make_wio("icio2023", 2020)
wio &lt;- make_wio("wiod2021", 2018)
wio &lt;- make_wio("wiod2023", 2020, src_dir = "C:/Users/John/R/")

## End(Not run)
</code></pre>

<hr>
<h2 id='meld'>Meld ICIO-type matrix (consolidating China and Mexico sub-components)</h2><span id='topic+meld'></span>

<h3>Description</h3>

<p>Meld <code>ICIO</code> matrix with extended countries.
Melds countries <code>CHN</code> and <code>MEX</code> from their extended versions
e.g., <code>CN1</code> and <code>CN2</code> are melded into <code>CHN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meld(df, meld_rows = TRUE, meld_cols = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meld_+3A_df">df</code></td>
<td>
<p>A block matrix.</p>
</td></tr>
<tr><td><code id="meld_+3A_meld_rows">meld_rows</code></td>
<td>
<p>Boolean, true to meld rows.</p>
</td></tr>
<tr><td><code id="meld_+3A_meld_cols">meld_cols</code></td>
<td>
<p>Boolean, true to meld cols.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Melded version of <code>ICIO</code> matrix.
</p>

<hr>
<h2 id='multd'>Multiply a matrix by a diagonal matrix</h2><span id='topic+multd'></span>

<h3>Description</h3>

<p>Fast multiplication of a matrix by a diagonal matrix, taking advantage
of the properties of diagonal matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multd(matrix1, matrix2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multd_+3A_matrix1">matrix1</code></td>
<td>
<p>An ordinary matrix.</p>
</td></tr>
<tr><td><code id="multd_+3A_matrix2">matrix2</code></td>
<td>
<p>A diagonal matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>multd()</code> will turn <code>matrix2</code> into a vector and multiply it
horizontally by every row in <code>matrix1</code>. This saves precious computing
time.\
The number of columns of <code>matrix1</code> must be equal to the rows and
columns of diagonal <code>matrix2</code>.
</p>


<h3>Value</h3>

<p>The product of matrix1 and matrix2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmult">dmult()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest")
multd(wio$B, wio$E)
</code></pre>

<hr>
<h2 id='print.exvadec'>Print method for <code>exvadec</code> class</h2><span id='topic+print.exvadec'></span>

<h3>Description</h3>

<p>Print method for <code>exvadec</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'exvadec'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.exvadec_+3A_x">x</code></td>
<td>
<p>An object of class <code>exvadec</code></p>
</td></tr>
<tr><td><code id="print.exvadec_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printout to console
</p>

<hr>
<h2 id='print.exvadir'>Print method for <code>exvadir</code> class</h2><span id='topic+print.exvadir'></span>

<h3>Description</h3>

<p>Print method for <code>exvadir</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'exvadir'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.exvadir_+3A_x">x</code></td>
<td>
<p>An object of class <code>exvadir</code></p>
</td></tr>
<tr><td><code id="print.exvadir_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printout to console
</p>

<hr>
<h2 id='print.wio'>Print method for <code>wio</code> class</h2><span id='topic+print.wio'></span>

<h3>Description</h3>

<p>Print method for <code>wio</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wio'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wio_+3A_x">x</code></td>
<td>
<p>An object of class <code>wio</code></p>
</td></tr>
<tr><td><code id="print.wio_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printout to console
</p>

<hr>
<h2 id='rsums'>Sum matrix rows and assign name to resulting column</h2><span id='topic+rsums'></span>

<h3>Description</h3>

<p>Improved version of <code>rowSums()</code> for matrix output. The sum of rows is kept
as a column vector with rows names and the resulting column can be
named in the same command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsums(df, col_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsums_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
<tr><td><code id="rsums_+3A_col_name">col_name</code></td>
<td>
<p>String, name to assign to resulting column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column matrix (with rows and column names)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
rsums(wio$Y, "Y")
</code></pre>

<hr>
<h2 id='set_zero'>Set to zero specific rows and columns of a matrix</h2><span id='topic+set_zero'></span>

<h3>Description</h3>

<p>Sets to zero specific rows and columns of a matrix, to
include and exclude specific geographical and sector effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_zero(df, orig = NULL, dest = NULL, wiotype = NULL, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_zero_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
<tr><td><code id="set_zero_+3A_orig">orig</code></td>
<td>
<p>A vector of integers with position of rows or a list of strings
with codes of country and sector of origin.</p>
</td></tr>
<tr><td><code id="set_zero_+3A_dest">dest</code></td>
<td>
<p>A vector of integers with position of columns or a list of
strings with codes of country and sector of destination.</p>
</td></tr>
<tr><td><code id="set_zero_+3A_wiotype">wiotype</code></td>
<td>
<p>String, type of <code>wio</code>. Required if origin or destination
is specified with lists of codes.</p>
</td></tr>
<tr><td><code id="set_zero_+3A_invert">invert</code></td>
<td>
<p>Boolean: FALSE (default) to set to zero the specified
countries and sectors, or TRUE to set to zero the non-specified countries
and sectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same matrix with specific rows and columns set to zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest")
# Set to zero Spanish exports of intermediates of manufacturing to
# non EU27 countries (for any sector of destination) in the coefficient
# matrix A
set_zero(wio$A, list("ESP", "MANUF"), list("NONEU27", "TOTAL"), "wiodtest")
# Set to zero Spanish exports of intermediates (extraction matrix of Spain)
set_zero(wio$A, list("ESP", "TOTAL"), list("WLDxESP", "TOTAL"), "wiodtest")
</code></pre>

<hr>
<h2 id='sumgcols'>Sum groups of columns of a matrix and name the resulting columns</h2><span id='topic+sumgcols'></span>

<h3>Description</h3>

<p>Groups a matrix by columns, by summing blocks of columns of size n each.
Matrix columns should be multiple of n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumgcols(df, n, col_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumgcols_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
<tr><td><code id="sumgcols_+3A_n">n</code></td>
<td>
<p>Integer, specifying the size of each group.</p>
</td></tr>
<tr><td><code id="sumgcols_+3A_col_names">col_names</code></td>
<td>
<p>String vector of length n, with names to assign to the
resulting columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each column is the sum of groups of n
columns of the original matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
sumgcols(wio$Yfd, wio$dims$FD, wio$names$g_names)
</code></pre>

<hr>
<h2 id='sumgrows'>Sum groups of rows of a matrix and name the resulting rows</h2><span id='topic+sumgrows'></span>

<h3>Description</h3>

<p>Groups a matrix by rows, summing blocks of rows of size n each.
Matrix rows should be multiple of n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumgrows(df, n, row_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumgrows_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
<tr><td><code id="sumgrows_+3A_n">n</code></td>
<td>
<p>Integer, specifying the size of each group.</p>
</td></tr>
<tr><td><code id="sumgrows_+3A_row_names">row_names</code></td>
<td>
<p>String vector of length n, with names to assign to the
resulting rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each row is the sum of groups of n rows
of the original matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
sumgrows(wio$Y, wio$dims$N, wio$names$g_names)
</code></pre>

<hr>
<h2 id='summary.exvadec'>Summary method for <code>exvadec</code> class</h2><span id='topic+summary.exvadec'></span>

<h3>Description</h3>

<p>Summary method for <code>exvadec</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'exvadec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.exvadec_+3A_object">object</code></td>
<td>
<p>An object of class <code>exvadec</code>.</p>
</td></tr>
<tr><td><code id="summary.exvadec_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printout to console
</p>

<hr>
<h2 id='summary.exvadir'>Summary method for <code>exvadir</code> class</h2><span id='topic+summary.exvadir'></span>

<h3>Description</h3>

<p>Summary method for <code>exvadir</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'exvadir'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.exvadir_+3A_object">object</code></td>
<td>
<p>An object of class <code>exvadir</code>.</p>
</td></tr>
<tr><td><code id="summary.exvadir_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printout to console
</p>

<hr>
<h2 id='summary.wio'>Summary method for <code>wio</code> class</h2><span id='topic+summary.wio'></span>

<h3>Description</h3>

<p>Summary method for <code>wio</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wio'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.wio_+3A_object">object</code></td>
<td>
<p>An object of class <code>wio</code></p>
</td></tr>
<tr><td><code id="summary.wio_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printout to console
</p>

<hr>
<h2 id='sumncol'>Sum every nth column of a matrix and name the resulting columns</h2><span id='topic+sumncol'></span>

<h3>Description</h3>

<p>Groups a matrix by columns, summing every Nth column. Matrix should be
multiple of N.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumncol(df, N, col_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumncol_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
<tr><td><code id="sumncol_+3A_n">N</code></td>
<td>
<p>Integer, specifying the resulting number of columns.</p>
</td></tr>
<tr><td><code id="sumncol_+3A_col_names">col_names</code></td>
<td>
<p>String vector of length N, with names to assign to the
resulting columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with N columns, where each columns is the sum of
every Nth column of the original matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
sumncol(wio$Yfd, wio$dims$FD, paste0("WLD", "_", wio$names$fd_names))
</code></pre>

<hr>
<h2 id='sumnrow'>Sum every nth row of a matrix and name the resulting rows</h2><span id='topic+sumnrow'></span>

<h3>Description</h3>

<p>Groups a matrix by rows, summing every <code>Nth</code> row. Matrix should be multiple
of <code>N</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumnrow(df, N, row_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumnrow_+3A_df">df</code></td>
<td>
<p>A matrix with named rows and columns.</p>
</td></tr>
<tr><td><code id="sumnrow_+3A_n">N</code></td>
<td>
<p>Integer, specifying the resulting number or rows.</p>
</td></tr>
<tr><td><code id="sumnrow_+3A_row_names">row_names</code></td>
<td>
<p>String vector of length <code>N</code>, with names to assign to the
resulting rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>N</code> rows, where each row is the sum of every <code>Nth</code> row
of the original matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wio &lt;- make_wio("wiodtest", quiet = TRUE)
sumnrow(wio$Y, wio$dims$N, paste0("WLD", "_",
        gsub("^D", "", wio$names$n_names)))
</code></pre>

<hr>
<h2 id='wiodtest_data'>WIOD-type input-output table example data</h2><span id='topic+wiodtest_data'></span>

<h3>Description</h3>

<p>An example of a WIOD-type input-output table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiodtest_data
</code></pre>


<h3>Format</h3>

<p>A matrix of 18 by 30, composed of two sub-matrices:
</p>

<ul>
<li><p> Sub-matrix <code>Z</code>, intermediate inputs: 18 by 18 (10 countries with 3
sectors each).
</p>
</li>
<li><p> Sub-matrix <code>Yfd</code>, final demand: 18 by 12 (6 countries with 3 sectors
each in rows, 6 countries by 2 demand components each in columns).
</p>
</li></ul>



<h3>Source</h3>

<p>Data were randomly generated with an uniform distribution.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
