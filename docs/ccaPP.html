<!DOCTYPE html><html><head><title>Help for package ccaPP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ccaPP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ccaPP-package'>
<p>(Robust) Canonical Correlation Analysis via Projection Pursuit</p></a></li>
<li><a href='#ccaGrid'><p>(Robust) CCA via alternating series of grid searches</p></a></li>
<li><a href='#ccaProj'><p>(Robust) CCA via projections through the data points</p></a></li>
<li><a href='#corFunctions'><p>Fast implementations of (robust) correlation estimators</p></a></li>
<li><a href='#diabetes'>
<p>Diabetes data</p></a></li>
<li><a href='#fastMAD'><p>Fast implementation of the median absolute deviation</p></a></li>
<li><a href='#fastMedian'><p>Fast implementation of the median</p></a></li>
<li><a href='#maxCorGrid'><p>(Robust) maximum correlation via alternating series of grid searches</p></a></li>
<li><a href='#maxCorProj'><p>(Robust) maximum correlation via projections through the data points</p></a></li>
<li><a href='#permTest'><p>(Robust) permutation test for no association</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>(Robust) Canonical Correlation Analysis via Projection Pursuit</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-09</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), parallel, pcaPP (&ge; 1.8-1), robustbase</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.0), RcppArmadillo (&ge; 0.4.100.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mvtnorm</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Canonical correlation analysis and maximum correlation via
    projection pursuit, as well as fast implementations of correlation
    estimators, with a focus on robust and nonparametric methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Alfons [aut, cre],
  David Simcha [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Alfons &lt;alfons@ese.eur.nl&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-09 10:52:53 UTC; andreas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-09 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ccaPP-package'>
(Robust) Canonical Correlation Analysis via Projection Pursuit
</h2><span id='topic+ccaPP-package'></span><span id='topic+ccaPP'></span>

<h3>Description</h3>

<p>Canonical correlation analysis and maximum correlation via
    projection pursuit, as well as fast implementations of correlation
    estimators, with a focus on robust and nonparametric methods.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ccaPP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> (Robust) Canonical Correlation Analysis via Projection Pursuit</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-12-09</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.2.0),
parallel,
pcaPP (&gt;= 1.8-1),
robustbase</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 0.11.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp (&gt;= 0.11.0), RcppArmadillo (&gt;= 0.4.100.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,
mvtnorm</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Canonical correlation analysis and maximum correlation via
    projection pursuit, as well as fast implementations of correlation
    estimators, with a focus on robust and nonparametric methods.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Andreas", "Alfons", email = "alfons@ese.eur.nl",
    role = c("aut", "cre")), person("David", "Simcha", role = "ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Andreas Alfons [aut, cre],
    David Simcha [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Andreas Alfons &lt;alfons@ese.eur.nl&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
ccaGrid                 (Robust) CCA via alternating series of grid
                        searches
ccaPP-package           (Robust) Canonical Correlation Analysis via
                        Projection Pursuit
ccaProj                 (Robust) CCA via projections through the data
                        points
corFunctions            Fast implementations of (robust) correlation
                        estimators
diabetes                Diabetes data
fastMAD                 Fast implementation of the median absolute
                        deviation
fastMedian              Fast implementation of the median
maxCorGrid              (Robust) maximum correlation via alternating
                        series of grid searches
maxCorProj              (Robust) maximum correlation via projections
                        through the data points
permTest                (Robust) permutation test for no association
</pre>


<h3>Author(s)</h3>

<p>Andreas Alfons [aut, cre],
    David Simcha [ctb]
</p>
<p>Maintainer: Andreas Alfons &lt;alfons@ese.eur.nl&gt;
</p>


<h3>References</h3>

<p>A. Alfons, C. Croux and P. Filzmoser (2016) Robust maximum association between 
data sets: The <span class="rlang"><b>R</b></span> Package <span class="pkg">ccaPP</span>.  <em>Austrian Journal of Statistics</em>, 
<b>45</b>(1), 71&ndash;79.
</p>
<p>A. Alfons, C. Croux and P. Filzmoser (2016) Robust maximum association 
estimators.  <em>Journal of the American Statistical Association</em>.  DOI 
10.1080/01621459.2016.1148609.  In press.
</p>

<hr>
<h2 id='ccaGrid'>(Robust) CCA via alternating series of grid searches</h2><span id='topic+ccaGrid'></span><span id='topic+print.cca'></span><span id='topic+CCAgrid'></span>

<h3>Description</h3>

<p>Perform canoncial correlation analysis via projection pursuit based on
alternating series of grid searches in two-dimensional subspaces of each
data set, with a focus on robust and nonparametric methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccaGrid(x, y, k = 1, method = c("spearman", "kendall", "quadrant", "M",
  "pearson"), control = list(...), nIterations = 10, nAlternate = 10,
  nGrid = 25, select = NULL, tol = 1e-06, standardize = TRUE,
  fallback = FALSE, seed = NULL, ...)

CCAgrid(x, y, k = 1, method = c("spearman", "kendall", "quadrant", "M",
  "pearson"), maxiter = 10, maxalter = 10, splitcircle = 25,
  select = NULL, zero.tol = 1e-06, standardize = TRUE,
  fallback = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccaGrid_+3A_x">x</code>, <code id="ccaGrid_+3A_y">y</code></td>
<td>
<p>each can be a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_k">k</code></td>
<td>
<p>an integer giving the number of canonical variables to compute.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_method">method</code></td>
<td>
<p>a character string specifying the correlation functional to
maximize.  Possible values are <code>"spearman"</code> for the Spearman
correlation, <code>"kendall"</code> for the Kendall correlation, <code>"quadrant"</code>
for the quadrant correlation, <code>"M"</code> for the correlation based on a
bivariate M-estimator of location and scatter with a Huber loss function, or
<code>"pearson"</code> for the classical Pearson correlation (see
<code><a href="#topic+corFunctions">corFunctions</a></code>).</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_control">control</code></td>
<td>
<p>a list of additional arguments to be passed to the specified
correlation functional.  If supplied, this takes precedence over additional
arguments supplied via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_niterations">nIterations</code>, <code id="ccaGrid_+3A_maxiter">maxiter</code></td>
<td>
<p>an integer giving the maximum number of
iterations.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_nalternate">nAlternate</code>, <code id="ccaGrid_+3A_maxalter">maxalter</code></td>
<td>
<p>an integer giving the maximum number of
alternate series of grid searches in each iteration.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_ngrid">nGrid</code>, <code id="ccaGrid_+3A_splitcircle">splitcircle</code></td>
<td>
<p>an integer giving the number of equally spaced
grid points on the unit circle to use in each grid search.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_select">select</code></td>
<td>
<p>optional; either an integer vector of length two or a list
containing two index vectors.  In the first case, the first integer gives
the number of variables of <code>x</code> to be randomly selected for determining
the order of the variables of <code>y</code> in the corresponding series of grid
searches, and vice versa for the second integer.  In the latter case, the
first list element gives the indices of the variables of <code>x</code> to be used
for determining the order of the variables of <code>y</code>, and vice versa for
the second integer (see &ldquo;Details&rdquo;).</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_tol">tol</code>, <code id="ccaGrid_+3A_zero.tol">zero.tol</code></td>
<td>
<p>a small positive numeric value to be used for
determining convergence.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_standardize">standardize</code></td>
<td>
<p>a logical indicating whether the data should be
(robustly) standardized.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_fallback">fallback</code></td>
<td>
<p>logical indicating whether a fallback mode for robust
standardization should be used.  If a correlation functional other than the
Pearson correlation is maximized, the first attempt for standardizing the
data is via median and MAD.  In the fallback mode, variables whose MADs are
zero (e.g., dummy variables) are standardized via mean and standard
deviation.  Note that if the Pearson correlation is maximized,
standardization is always done via mean and standard deviation.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).  This is only used if <code>select</code> specifies
the numbers of variables of each data set to be randomly selected for
determining the order of the variables of the respective other data set.</p>
</td></tr>
<tr><td><code id="ccaGrid_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the specified correlation
functional.  Currently, this is only relevant for the M-estimator.  For
Spearman, Kendall and quadrant correlation, consistency at the normal model
is always forced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is based on alternating series of grid searches in
two-dimensional subspaces of each data set.  In each grid search,
<code>nGrid</code> grid points on the unit circle in the corresponding plane are
obtained, and the directions from the center to each of the grid points are
examined.  In the first iteration, equispaced grid points in the interval
<code class="reqn">[-\pi/2, \pi/2)</code> are used.  In each subsequent
iteration, the angles are halved such that the interval
<code class="reqn">[-\pi/4, \pi/4)</code> is used in the second iteration and so
on.  If only one data set is multivariate, the algorithm simplifies
to iterative grid searches in two-dimensional subspaces of the corresponding
data set.
</p>
<p>In the basic algorithm, the order of the variables in a series of grid
searches for each of the data sets is determined by the average absolute
correlations with the variables of the respective other data set.  Since
this requires to compute the full <code class="reqn">(p \times q)</code> matrix of
absolute correlations, where <code class="reqn">p</code> denotes the number of variables of
<code>x</code> and <code class="reqn">q</code> the number of variables of <code>y</code>, a faster
modification is available as well.  In this modification, the average
absolute correlations are computed over only a subset of the variables of
the respective other data set.  It is thereby possible to use randomly
selected subsets of variables, or to specify the subsets of variables
directly.
</p>
<p>Note that also the data sets are ordered according to the maximum average
absolute correlation with the respective other data set to ensure symmetry
of the algorithm.
</p>
<p>For higher order canonical correlations, the data are first transformed into
suitable subspaces.  Then the alternate grid algorithm is applied to the
reduced data and the results are back-transformed to the original space.
</p>


<h3>Value</h3>

<p>An object of class <code>"cca"</code> with the following components:
</p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>a numeric vector giving the canonical correlation measures.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>a numeric matrix in which the columns contain the canonical vectors
for <code>x</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>a numeric matrix in which the columns contain the canonical vectors
for <code>y</code>.</p>
</td></tr>
<tr><td><code>centerX</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>centerY</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>scaleX</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>scaleY</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>CCAgrid</code> is a simple wrapper function for <code>ccaGrid</code> for
more compatibility with package <span class="pkg">pcaPP</span> concerning function and argument
names.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccaProj">ccaProj</a></code>, <code><a href="#topic+maxCorGrid">maxCorGrid</a></code>,
<code><a href="#topic+corFunctions">corFunctions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("diabetes")
x &lt;- diabetes$x
y &lt;- diabetes$y

## Spearman correlation
ccaGrid(x, y, method = "spearman")

## Pearson correlation
ccaGrid(x, y, method = "pearson")

</code></pre>

<hr>
<h2 id='ccaProj'>(Robust) CCA via projections through the data points</h2><span id='topic+ccaProj'></span><span id='topic+CCAproj'></span>

<h3>Description</h3>

<p>Perform canoncial correlation analysis via projection pursuit based on
projections through the data points, with a focus on robust and
nonparametric methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccaProj(x, y, k = 1, method = c("spearman", "kendall", "quadrant", "M",
  "pearson"), control = list(...), standardize = TRUE,
  useL1Median = TRUE, fallback = FALSE, ...)

CCAproj(x, y, k = 1, method = c("spearman", "kendall", "quadrant", "M",
  "pearson"), standardize = TRUE, useL1Median = TRUE,
  fallback = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccaProj_+3A_x">x</code>, <code id="ccaProj_+3A_y">y</code></td>
<td>
<p>each can be a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="ccaProj_+3A_k">k</code></td>
<td>
<p>an integer giving the number of canonical variables to compute.</p>
</td></tr>
<tr><td><code id="ccaProj_+3A_method">method</code></td>
<td>
<p>a character string specifying the correlation functional to
maximize.  Possible values are <code>"spearman"</code> for the Spearman
correlation, <code>"kendall"</code> for the Kendall correlation, <code>"quadrant"</code>
for the quadrant correlation, <code>"M"</code> for the correlation based on a
bivariate M-estimator of location and scatter with a Huber loss function, or
<code>"pearson"</code> for the classical Pearson correlation (see
<code><a href="#topic+corFunctions">corFunctions</a></code>).</p>
</td></tr>
<tr><td><code id="ccaProj_+3A_control">control</code></td>
<td>
<p>a list of additional arguments to be passed to the specified
correlation functional.  If supplied, this takes precedence over additional
arguments supplied via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="ccaProj_+3A_standardize">standardize</code></td>
<td>
<p>a logical indicating whether the data should be
(robustly) standardized.</p>
</td></tr>
<tr><td><code id="ccaProj_+3A_usel1median">useL1Median</code></td>
<td>
<p>a logical indicating whether the <code class="reqn">L_{1}</code> medians
should be used as the centers of the data sets in standardization (defaults
to <code>TRUE</code>).  If <code>FALSE</code>, the columnwise centers are used instead
(columnwise means if <code>method</code> is <code>"pearson"</code> and columnwise
medians otherwise).</p>
</td></tr>
<tr><td><code id="ccaProj_+3A_fallback">fallback</code></td>
<td>
<p>logical indicating whether a fallback mode for robust
standardization should be used.  If a correlation functional other than the
Pearson correlation is maximized, the first attempt for standardizing the
data is via median and MAD.  In the fallback mode, variables whose MADs are
zero (e.g., dummy variables) are standardized via mean and standard
deviation.  Note that if the Pearson correlation is maximized,
standardization is always done via mean and standard deviation.</p>
</td></tr>
<tr><td><code id="ccaProj_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the specified correlation
functional.  Currently, this is only relevant for the M-estimator.  For
Spearman, Kendall and quadrant correlation, consistency at the normal model
is always forced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First the candidate projection directions are defined for each data set
from the respective center through each data point.  Then the algorithm
scans all <code class="reqn">n^2</code> possible combinations for the maximum correlation,
where <code class="reqn">n</code> is the number of observations.
</p>
<p>For higher order canonical correlations, the data are first transformed into
suitable subspaces.  Then the alternate grid algorithm is applied to the
reduced data and the results are back-transformed to the original space.
</p>


<h3>Value</h3>

<p>An object of class <code>"cca"</code> with the following components:
</p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>a numeric vector giving the canonical correlation
measures.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>a numeric matrix in which the columns contain the canonical vectors
for <code>x</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>a numeric matrix in which the columns contain the canonical vectors
for <code>y</code>.</p>
</td></tr>
<tr><td><code>centerX</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>centerY</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>scaleX</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>scaleY</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>CCAproj</code> is a simple wrapper function for <code>ccaProj</code> for
more compatibility with package <span class="pkg">pcaPP</span> concerning function names.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccaGrid">ccaGrid</a></code>, <code><a href="#topic+maxCorProj">maxCorProj</a></code>,
<code><a href="#topic+corFunctions">corFunctions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("diabetes")
x &lt;- diabetes$x
y &lt;- diabetes$y

## Spearman correlation
ccaProj(x, y, method = "spearman")

## Pearson correlation
ccaProj(x, y, method = "pearson")

</code></pre>

<hr>
<h2 id='corFunctions'>Fast implementations of (robust) correlation estimators</h2><span id='topic+corFunctions'></span><span id='topic+corPearson'></span><span id='topic+corSpearman'></span><span id='topic+corKendall'></span><span id='topic+corQuadrant'></span><span id='topic+corM'></span>

<h3>Description</h3>

<p>Estimate the correlation of two vectors via fast C++ implementations, with a
focus on robust and nonparametric methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corPearson(x, y)

corSpearman(x, y, consistent = FALSE)

corKendall(x, y, consistent = FALSE)

corQuadrant(x, y, consistent = FALSE)

corM(x, y, prob = 0.9, initial = c("quadrant", "spearman", "kendall",
  "pearson"), tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corFunctions_+3A_x">x</code>, <code id="corFunctions_+3A_y">y</code></td>
<td>
<p>numeric vectors.</p>
</td></tr>
<tr><td><code id="corFunctions_+3A_consistent">consistent</code></td>
<td>
<p>a logical indicating whether a consistent estimate at the
bivariate normal distribution should be returned (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="corFunctions_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used for tuning the Huber
loss function (defaults to 0.9).</p>
</td></tr>
<tr><td><code id="corFunctions_+3A_initial">initial</code></td>
<td>
<p>a character string specifying the starting values for the
Huber M-estimator.  For <code>"quadrant"</code> (the default), <code>"spearman"</code>
or <code>"kendall"</code>, the consistent version of the respecive correlation
measure is used together with the medians and MAD's.  For <code>"pearson"</code>,
the Pearson correlation is used together with the means and standard
deviations.</p>
</td></tr>
<tr><td><code id="corFunctions_+3A_tol">tol</code></td>
<td>
<p>a small positive numeric value to be used for determining
convergence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>corPearson</code> estimates the classical Pearson correlation.
<code>corSpearman</code>, <code>corKendall</code> and <code>corQuadrant</code> estimate the
Spearman, Kendall and quadrant correlation, respectively, which are
nonparametric correlation measures that are somewhat more robust.
<code>corM</code> estimates the correlation based on a bivariate M-estimator of
location and scatter with a Huber loss function, which is sufficiently
robust in the bivariate case, but loses robustness with increasing dimension.
</p>
<p>The nonparametric correlation measures do not estimate the same population
quantities as the Pearson correlation, the latter of which is consistent at
the bivariate normal model.  Let <code class="reqn">\rho</code> denote the population
correlation at the normal model.  Then the Spearman correlation estimates
<code class="reqn">(6/\pi) \arcsin(\rho/2)</code>, while the Kendall and
quadrant correlation estimate
<code class="reqn">(2/\pi) \arcsin(\rho)</code>.  Consistent estimates are
thus easily obtained by taking the corresponding inverse expressions.
</p>
<p>The Huber M-estimator, on the other hand, is consistent at the bivariate
normal model.
</p>


<h3>Value</h3>

<p>The respective correlation estimate.
</p>


<h3>Note</h3>

<p>The Kendall correlation uses a naive <code class="reqn">n^2</code> implementation if
<code class="reqn">n &lt; 30</code> and a fast <code class="reqn">O(n \log(n))</code> implementation for
larger values, where <code class="reqn">n</code> denotes the number of observations.
</p>
<p>Functionality for removing observations with missing values is currently not
implemented.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons, <code class="reqn">O(n \log(n))</code> implementation of
the Kendall correlation by David Simcha
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccaGrid">ccaGrid</a></code>, <code><a href="#topic+ccaProj">ccaProj</a></code>,
<code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
library("mvtnorm")
set.seed(1234)  # for reproducibility
sigma &lt;- matrix(c(1, 0.6, 0.6, 1), 2, 2)
xy &lt;- rmvnorm(100, sigma=sigma)
x &lt;- xy[, 1]
y &lt;- xy[, 2]

## compute correlations

# Pearson correlation
corPearson(x, y)

# Spearman correlation
corSpearman(x, y)
corSpearman(x, y, consistent=TRUE)

# Kendall correlation
corKendall(x, y)
corKendall(x, y, consistent=TRUE)

# quadrant correlation
corQuadrant(x, y)
corQuadrant(x, y, consistent=TRUE)

# Huber M-estimator
corM(x, y)

</code></pre>

<hr>
<h2 id='diabetes'>
Diabetes data
</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>Subset of the diabetes data from Andrews &amp; Herzberg (1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diabetes)</code></pre>


<h3>Format</h3>

<p>A list with components <code>x</code> and <code>y</code>.  Both components are matrices 
with observations on different variables for the same <code class="reqn">n = 76</code> persons.
</p>
<p>Component <code>x</code> is a matrix containing the following <code class="reqn">p = 2</code> variables.
</p>

<dl>
<dt><code>RelativeWeight</code></dt><dd><p>relative weight.</p>
</dd>
<dt><code>PlasmaGlucose</code></dt><dd><p>fasting plasma glucose.</p>
</dd>
</dl>

<p>Component <code>y</code> is a matrix containing the following <code class="reqn">q = 3</code> variables.
</p>

<dl>
<dt><code>GlucoseIntolerance</code></dt><dd><p>glucose intolerance.</p>
</dd>
<dt><code>InsulinResponse</code></dt><dd><p>insulin response to oral glucose.</p>
</dd>
<dt><code>InsulinResistance</code></dt><dd><p>insulin resistance.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Andrews, D.F. and Herzberg, A.M. (1985) <em>Data</em>. Springer-Verlag. Page 215.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("diabetes")
x &lt;- diabetes$x
y &lt;- diabetes$y

## Spearman correlation
maxCorGrid(x, y, method = "spearman")
maxCorGrid(x, y, method = "spearman", consistent = TRUE)

## Pearson correlation
maxCorGrid(x, y, method = "pearson")
</code></pre>

<hr>
<h2 id='fastMAD'>Fast implementation of the median absolute deviation</h2><span id='topic+fastMAD'></span>

<h3>Description</h3>

<p>Compute the median absolute deviation with a fast C++ implementation.  By
default, a multiplication factor is applied for consistency at the normal
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastMAD(x, constant = 1.4826)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastMAD_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="fastMAD_+3A_constant">constant</code></td>
<td>
<p>a numeric multiplication factor.  The default value yields
consistency at the normal model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>a numeric value giving the sample median.</p>
</td></tr>
<tr><td><code>MAD</code></td>
<td>
<p>a numeric value giving the median absolute deviation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Functionality for removing observations with missing values is
currently not implemented.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastMedian">fastMedian</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)  # for reproducibility
x &lt;- rnorm(100)
fastMAD(x)

</code></pre>

<hr>
<h2 id='fastMedian'>Fast implementation of the median</h2><span id='topic+fastMedian'></span>

<h3>Description</h3>

<p>Compute the sample median with a fast C++ implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastMedian(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastMedian_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sample median.
</p>


<h3>Note</h3>

<p>Functionality for removing observations with missing values is
currently not implemented.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastMAD">fastMAD</a></code>, <code><a href="stats.html#topic+median">median</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)  # for reproducibility
x &lt;- rnorm(100)
fastMedian(x)

</code></pre>

<hr>
<h2 id='maxCorGrid'>(Robust) maximum correlation via alternating series of grid searches</h2><span id='topic+maxCorGrid'></span><span id='topic+print.maxCor'></span>

<h3>Description</h3>

<p>Compute the maximum correlation between two data sets via projection pursuit
based on alternating series of grid searches in two-dimensional subspaces of
each data set, with a focus on robust and nonparametric methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxCorGrid(x, y, method = c("spearman", "kendall", "quadrant", "M",
  "pearson"), control = list(...), nIterations = 10, nAlternate = 10,
  nGrid = 25, select = NULL, tol = 1e-06, standardize = TRUE,
  fallback = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxCorGrid_+3A_x">x</code>, <code id="maxCorGrid_+3A_y">y</code></td>
<td>
<p>each can be a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_method">method</code></td>
<td>
<p>a character string specifying the correlation functional to
maximize.  Possible values are <code>"spearman"</code> for the Spearman
correlation, <code>"kendall"</code> for the Kendall correlation, <code>"quadrant"</code>
for the quadrant correlation, <code>"M"</code> for the correlation based on a
bivariate M-estimator of location and scatter with a Huber loss function, or
<code>"pearson"</code> for the classical Pearson correlation (see
<code><a href="#topic+corFunctions">corFunctions</a></code>).</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_control">control</code></td>
<td>
<p>a list of additional arguments to be passed to the specified
correlation functional.  If supplied, this takes precedence over additional
arguments supplied via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_niterations">nIterations</code></td>
<td>
<p>an integer giving the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_nalternate">nAlternate</code></td>
<td>
<p>an integer giving the maximum number of alternate series
of grid searches in each iteration.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_ngrid">nGrid</code></td>
<td>
<p>an integer giving the number of equally spaced grid points on
the unit circle to use in each grid search.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_select">select</code></td>
<td>
<p>optional; either an integer vector of length two or a list
containing two index vectors.  In the first case, the first integer gives
the number of variables of <code>x</code> to be randomly selected for determining
the order of the variables of <code>y</code> in the corresponding series of grid
searches, and vice versa for the second integer.  In the latter case, the
first list element gives the indices of the variables of <code>x</code> to be used
for determining the order of the variables of <code>y</code>, and vice versa for
the second integer (see &ldquo;Details&rdquo;).</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_tol">tol</code></td>
<td>
<p>a small positive numeric value to be used for determining
convergence.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_standardize">standardize</code></td>
<td>
<p>a logical indicating whether the data should be
(robustly) standardized.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_fallback">fallback</code></td>
<td>
<p>logical indicating whether a fallback mode for robust
standardization should be used.  If a correlation functional other than the
Pearson correlation is maximized, the first attempt for standardizing the
data is via median and MAD.  In the fallback mode, variables whose MADs are
zero (e.g., dummy variables) are standardized via mean and standard
deviation.  Note that if the Pearson correlation is maximized,
standardization is always done via mean and standard deviation.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).  This is only used if <code>select</code> specifies
the numbers of variables of each data set to be randomly selected for
determining the order of the variables of the respective other data set.</p>
</td></tr>
<tr><td><code id="maxCorGrid_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the specified correlation
functional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is based on alternating series of grid searches in
two-dimensional subspaces of each data set.  In each grid search,
<code>nGrid</code> grid points on the unit circle in the corresponding plane are
obtained, and the directions from the center to each of the grid points are
examined.  In the first iteration, equispaced grid points in the interval
<code class="reqn">[-\pi/2, \pi/2)</code> are used.  In each subsequent
iteration, the angles are halved such that the interval
<code class="reqn">[-\pi/4, \pi/4)</code> is used in the second iteration and so
on.  If only one data set is multivariate, the algorithm simplifies
to iterative grid searches in two-dimensional subspaces of the corresponding
data set.
</p>
<p>In the basic algorithm, the order of the variables in a series of grid
searches for each of the data sets is determined by the average absolute
correlations with the variables of the respective other data set.  Since
this requires to compute the full <code class="reqn">(p \times q)</code> matrix of
absolute correlations, where <code class="reqn">p</code> denotes the number of variables of
<code>x</code> and <code class="reqn">q</code> the number of variables of <code>y</code>, a faster
modification is available as well.  In this modification, the average
absolute correlations are computed over only a subset of the variables of
the respective other data set.  It is thereby possible to use randomly
selected subsets of variables, or to specify the subsets of variables
directly.
</p>
<p>Note that also the data sets are ordered according to the maximum average
absolute correlation with the respective other data set to ensure symmetry
of the algorithm.
</p>


<h3>Value</h3>

<p>An object of class <code>"maxCor"</code> with the following components:
</p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>a numeric giving the maximum correlation estimate.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>numeric; the weighting vector for <code>x</code>.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>numeric; the weighting vector for <code>y</code>.</p>
</td></tr>
<tr><td><code>centerX</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>centerY</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>scaleX</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>scaleY</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>A. Alfons, C. Croux and P. Filzmoser (2016) Robust maximum association
between data sets: The <span class="rlang"><b>R</b></span> Package <span class="pkg">ccaPP</span>.  <em>Austrian Journal of
Statistics</em>, <b>45</b>(1), 71&ndash;79.
</p>
<p>A. Alfons, C. Croux and P. Filzmoser (2016) Robust maximum association
estimators.  <em>Journal of the American Statistical Association</em>.  DOI
10.1080/01621459.2016.1148609.  In press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxCorProj">maxCorProj</a></code>, <code><a href="#topic+ccaGrid">ccaGrid</a></code>,
<code><a href="#topic+corFunctions">corFunctions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("diabetes")
x &lt;- diabetes$x
y &lt;- diabetes$y

## Spearman correlation
maxCorGrid(x, y, method = "spearman")
maxCorGrid(x, y, method = "spearman", consistent = TRUE)

## Pearson correlation
maxCorGrid(x, y, method = "pearson")

</code></pre>

<hr>
<h2 id='maxCorProj'>(Robust) maximum correlation via projections through the data points</h2><span id='topic+maxCorProj'></span>

<h3>Description</h3>

<p>Compute the maximum correlation between two data sets via projection pursuit
based on projections through the data points, with a focus on robust and
nonparametric methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxCorProj(x, y, method = c("spearman", "kendall", "quadrant", "M",
  "pearson"), control = list(...), standardize = TRUE,
  useL1Median = TRUE, fallback = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxCorProj_+3A_x">x</code>, <code id="maxCorProj_+3A_y">y</code></td>
<td>
<p>each can be a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="maxCorProj_+3A_method">method</code></td>
<td>
<p>a character string specifying the correlation functional to
maximize.  Possible values are <code>"spearman"</code> for the Spearman
correlation, <code>"kendall"</code> for the Kendall correlation, <code>"quadrant"</code>
for the quadrant correlation, <code>"M"</code> for the correlation based on a
bivariate M-estimator of location and scatter with a Huber loss function, or
<code>"pearson"</code> for the classical Pearson correlation (see
<code><a href="#topic+corFunctions">corFunctions</a></code>).</p>
</td></tr>
<tr><td><code id="maxCorProj_+3A_control">control</code></td>
<td>
<p>a list of additional arguments to be passed to the specified
correlation functional.  If supplied, this takes precedence over additional
arguments supplied via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="maxCorProj_+3A_standardize">standardize</code></td>
<td>
<p>a logical indicating whether the data should be
(robustly) standardized.</p>
</td></tr>
<tr><td><code id="maxCorProj_+3A_usel1median">useL1Median</code></td>
<td>
<p>a logical indicating whether the <code class="reqn">L_{1}</code> medians
should be used as the centers of the data sets in standardization (defaults
to <code>TRUE</code>).  If <code>FALSE</code>, the columnwise centers are used instead
(columnwise means if <code>method</code> is <code>"pearson"</code> and columnwise
medians otherwise).</p>
</td></tr>
<tr><td><code id="maxCorProj_+3A_fallback">fallback</code></td>
<td>
<p>logical indicating whether a fallback mode for robust
standardization should be used.  If a correlation functional other than the
Pearson correlation is maximized, the first attempt for standardizing the
data is via median and MAD.  In the fallback mode, variables whose MADs are
zero (e.g., dummy variables) are standardized via mean and standard
deviation.  Note that if the Pearson correlation is maximized,
standardization is always done via mean and standard deviation.</p>
</td></tr>
<tr><td><code id="maxCorProj_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the specified correlation
functional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First the candidate projection directions are defined for each data set
from the respective center through each data point.  Then the algorithm
scans all <code class="reqn">n^2</code> possible combinations for the maximum correlation,
where <code class="reqn">n</code> is the number of observations.
</p>


<h3>Value</h3>

<p>An object of class <code>"maxCor"</code> with the following components:
</p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>a numeric giving the maximum correlation estimate.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>numeric; the weighting vector for <code>x</code>.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>numeric; the weighting vector for <code>y</code>.</p>
</td></tr>
<tr><td><code>centerX</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>centerY</code></td>
<td>
<p>a numeric vector giving the center estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>scaleX</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>x</code>.</p>
</td></tr>
<tr><td><code>scaleY</code></td>
<td>
<p>a numeric vector giving the scale estimates used in
standardization of <code>y</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxCorGrid">maxCorGrid</a></code>, <code><a href="#topic+ccaProj">ccaProj</a></code>,
<code><a href="#topic+corFunctions">corFunctions</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("diabetes")
x &lt;- diabetes$x
y &lt;- diabetes$y

## Spearman correlation
maxCorProj(x, y, method = "spearman")
maxCorProj(x, y, method = "spearman", consistent = TRUE)

## Pearson correlation
maxCorProj(x, y, method = "pearson")

</code></pre>

<hr>
<h2 id='permTest'>(Robust) permutation test for no association</h2><span id='topic+permTest'></span>

<h3>Description</h3>

<p>Test whether or not there is association betwenn two data sets, with a focus
on robust and nonparametric correlation measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permTest(x, y, R = 1000, fun = maxCorGrid, permutations = NULL,
  nCores = 1, cl = NULL, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permTest_+3A_x">x</code>, <code id="permTest_+3A_y">y</code></td>
<td>
<p>each can be a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="permTest_+3A_r">R</code></td>
<td>
<p>an integer giving the number of random permutations to be used.</p>
</td></tr>
<tr><td><code id="permTest_+3A_fun">fun</code></td>
<td>
<p>a function to compute a maximum correlation measure between
two data sets, e.g., <code><a href="#topic+maxCorGrid">maxCorGrid</a></code> (the default) or
<code><a href="#topic+maxCorProj">maxCorProj</a></code>.  It should expect the data to be passed as the
first and second argument, and must return an object of class
<code>"maxCor"</code>.</p>
</td></tr>
<tr><td><code id="permTest_+3A_permutations">permutations</code></td>
<td>
<p>an integer matrix in which each column contains the
indices of a permutation.  If supplied, this is preferred over <code>R</code>.</p>
</td></tr>
<tr><td><code id="permTest_+3A_ncores">nCores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.</p>
</td></tr>
<tr><td><code id="permTest_+3A_cl">cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.  If supplied, this is preferred over
<code>nCores</code>.</p>
</td></tr>
<tr><td><code id="permTest_+3A_seed">seed</code></td>
<td>
<p>optional integer giving the initial seed for the random number
generator (see <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).  For parallel computing, random
number streams are used rather than the standard random number generator and
the seed is set via <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
<tr><td><code id="permTest_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test generates <code>R</code> data sets by randomly permuting the observations
of <code>x</code>, while keeping the observations of <code>y</code> fixed.  In each
replication, a function to compute a maximum correlation measure is
applied to the permuted data sets.  The <code class="reqn">p</code>-value of the test is then
given by the percentage of replicates of the maximum correlation measure
that are larger than the maximum correlation measure computed from the
original data.
</p>


<h3>Value</h3>

<p>An object of class <code>"permTest"</code> with the following components:
</p>
<table>
<tr><td><code>pValue</code></td>
<td>
<p>the <code class="reqn">p</code>-value for the test.</p>
</td></tr>
<tr><td><code>cor0</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>the values of the test statistic for each of the permutated data
sets.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>the number of random permutations.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the seed of the random number generator.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>A. Alfons, C. Croux and P. Filzmoser (2016) Robust maximum association
between data sets: The <span class="rlang"><b>R</b></span> Package <span class="pkg">ccaPP</span>.  <em>Austrian Journal of
Statistics</em>, <b>45</b>(1), 71&ndash;79.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxCorGrid">maxCorGrid</a></code>, <code><a href="#topic+maxCorProj">maxCorProj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("diabetes")
x &lt;- diabetes$x
y &lt;- diabetes$y

## Spearman correlation
permTest(x, y, R = 100, method = "spearman")
permTest(x, y, R = 100, method = "spearman", consistent = TRUE)

## Pearson correlation
permTest(x, y, R = 100, method = "pearson")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
