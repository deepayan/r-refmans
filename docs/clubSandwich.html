<!DOCTYPE html><html><head><title>Help for package clubSandwich</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clubSandwich}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AchievementAwardsRCT'><p>Achievement Awards Demonstration program</p></a></li>
<li><a href='#coef_test'><p>Test all or selected regression coefficients in a fitted model</p></a></li>
<li><a href='#conf_int'><p>Calculate confidence intervals for all or selected regression coefficients in</p>
a fitted model</a></li>
<li><a href='#constraint_matrices'><p>Create constraint matrices</p></a></li>
<li><a href='#dropoutPrevention'><p>Dropout prevention/intervention program effects</p></a></li>
<li><a href='#findCluster.rma.mv'><p>Detect cluster structure of an rma.mv object</p></a></li>
<li><a href='#impute_covariance_matrix'><p>Impute a block-diagonal covariance matrix</p></a></li>
<li><a href='#linear_contrast'><p>Calculate confidence intervals and p-values for linear contrasts of</p>
regression coefficients in a fitted model</a></li>
<li><a href='#MortalityRates'><p>State-level annual mortality rates by cause among 18-20 year-olds</p></a></li>
<li><a href='#pattern_covariance_matrix'><p>Impute a patterned block-diagonal covariance matrix</p></a></li>
<li><a href='#SATcoaching'><p>Randomized experiments on SAT coaching</p></a></li>
<li><a href='#vcovCR'><p>Cluster-robust variance-covariance matrix</p></a></li>
<li><a href='#vcovCR.geeglm'><p>Cluster-robust variance-covariance matrix for a geeglm object.</p></a></li>
<li><a href='#vcovCR.glm'><p>Cluster-robust variance-covariance matrix for a glm object.</p></a></li>
<li><a href='#vcovCR.gls'><p>Cluster-robust variance-covariance matrix for a gls object.</p></a></li>
<li><a href='#vcovCR.ivreg'><p>Cluster-robust variance-covariance matrix for an ivreg object.</p></a></li>
<li><a href='#vcovCR.lm'><p>Cluster-robust variance-covariance matrix for an lm object.</p></a></li>
<li><a href='#vcovCR.lme'><p>Cluster-robust variance-covariance matrix for an lme object.</p></a></li>
<li><a href='#vcovCR.lmerMod'><p>Cluster-robust variance-covariance matrix for an lmerMod object.</p></a></li>
<li><a href='#vcovCR.mlm'><p>Cluster-robust variance-covariance matrix for an mlm object.</p></a></li>
<li><a href='#vcovCR.plm'><p>Cluster-robust variance-covariance matrix for a plm object.</p></a></li>
<li><a href='#vcovCR.rma.mv'><p>Cluster-robust variance-covariance matrix for a robu object.</p></a></li>
<li><a href='#vcovCR.rma.uni'><p>Cluster-robust variance-covariance matrix for a rma.uni object.</p></a></li>
<li><a href='#vcovCR.robu'><p>Cluster-robust variance-covariance matrix for a robu object.</p></a></li>
<li><a href='#Wald_test'><p>Test parameter constraints in a fitted linear regression model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cluster-Robust (Sandwich) Variance Estimators with Small-Sample
Corrections</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several cluster-robust variance estimators (i.e.,
    sandwich estimators) for ordinary and weighted least squares linear regression
    models, including the bias-reduced linearization estimator introduced by Bell
    and McCaffrey (2002) 
    <a href="https://www150.statcan.gc.ca/n1/pub/12-001-x/2002002/article/9058-eng.pdf">https://www150.statcan.gc.ca/n1/pub/12-001-x/2002002/article/9058-eng.pdf</a> and 
    developed further by Pustejovsky and Tipton (2017) 
    &lt;<a href="https://doi.org/10.1080%2F07350015.2016.1247004">doi:10.1080/07350015.2016.1247004</a>&gt;. The package includes functions for estimating
    the variance- covariance matrix and for testing single- and multiple-
    contrast hypotheses based on Wald test statistics. Tests of single regression
    coefficients use Satterthwaite or saddle-point corrections. Tests of multiple-
    contrast hypotheses use an approximation to Hotelling's T-squared distribution.
    Methods are provided for a variety of fitted models, including lm() and mlm
    objects, glm(), geeglm() (from package 'geepack'), ivreg() (from package 'AER'), ivreg() (from package 'ivreg' when 
    estimated by ordinary least squares), plm() (from package 'plm'), gls() and 
    lme() (from 'nlme'), lmer() (from &lsquo;lme4'), robu() (from &rsquo;robumeta'), and rma.uni() 
    and rma.mv() (from 'metafor').</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://jepusto.github.io/clubSandwich/">http://jepusto.github.io/clubSandwich/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jepusto/clubSandwich/issues">https://github.com/jepusto/clubSandwich/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, sandwich</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Formula, knitr, carData, geepack, metafor, metadat, robumeta,
nlme, mlmRev, AER, plm (&ge; 1.6-4), Matrix, lme4, zoo, testthat,
rmarkdown, covr, ivreg</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-20 02:09:26 UTC; James</td>
</tr>
<tr>
<td>Author:</td>
<td>James Pustejovsky <a href="https://orcid.org/0000-0003-0591-9465"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Pustejovsky &lt;jepusto@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-20 02:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AchievementAwardsRCT'>Achievement Awards Demonstration program</h2><span id='topic+AchievementAwardsRCT'></span>

<h3>Description</h3>

<p>Data from a randomized trial of the Achievement Awards
Demonstration program, reported in Angrist &amp; Lavy (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AchievementAwardsRCT
</code></pre>


<h3>Format</h3>

<p>A data frame with 16526 rows and 21 variables: </p>
 
<dl>
<dt>school_id</dt><dd><p>Fictitious school identification number</p>
</dd>
<dt>school_type</dt><dd><p>Factor identifying the school type (Arab religious, Jewish religious, Jewish secular)</p>
</dd>
<dt>pair</dt><dd><p>Number of treatment pair. Note that 7 is a triple.</p>
</dd> 
<dt>treated</dt><dd><p>Indicator for whether school was in treatment group</p>
</dd>
<dt>year</dt><dd><p>Cohort year</p>
</dd>
<dt>student_id</dt><dd><p>Fictitious student identification number</p>
</dd>
<dt>sex</dt><dd><p>Factor identifying student sex</p>
</dd>
<dt>siblings</dt><dd><p>Number of siblings</p>
</dd>
<dt>immigrant</dt><dd><p>Indicator for immigrant status</p>
</dd>
<dt>father_ed</dt><dd><p>Father's level of education</p>
</dd>
<dt>mother_ed</dt><dd><p>Mother's level of education</p>
</dd>
<dt>Bagrut_status</dt><dd><p>Indicator for Bagrut attainment</p>
</dd>
<dt>attempted</dt><dd><p>Number of Bagrut units attempted</p>
</dd>
<dt>awarded</dt><dd><p>Number of Bagrut units awarded</p>
</dd>
<dt>achv_math</dt><dd><p>Indicator for satisfaction of math requirement</p>
</dd>
<dt>achv_english</dt><dd><p>Indicator for satisfaction of English requirement</p>
</dd>
<dt>achv_hebrew</dt><dd><p>Indicator for satisfaction of Hebrew requirement</p>
</dd>
<dt>lagscore</dt><dd><p>Lagged Bagrut score</p>
</dd>
<dt>qrtl</dt><dd><p>Quartile within distribution of lagscore, calculated by cohort and sex</p>
</dd>
<dt>half</dt><dd><p>Lower or upper half within distribution of lagscore, calculated by cohort and sex</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://economics.mit.edu/people/faculty/josh-angrist/angrist-data-archive">Angrist Data Archive</a>
</p>


<h3>References</h3>

<p>Angrist, J. D., &amp; Lavy, V. (2009). The effects of high stakes 
high school achievement awards : Evidence from a randomized trial.
<em>American Economic Review, 99</em>(4), 1384-1414.
<a href="https://doi.org/10.1257/aer.99.4.1384">doi:10.1257/aer.99.4.1384</a>
</p>

<hr>
<h2 id='coef_test'>Test all or selected regression coefficients in a fitted model</h2><span id='topic+coef_test'></span>

<h3>Description</h3>

<p><code>coef_test</code> reports t-tests for each coefficient estimate in a fitted
linear regression model, using a sandwich estimator for the standard errors
and a small sample correction for the p-value. The small-sample correction is
based on a Satterthwaite approximation or a saddlepoint approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_test(
  obj,
  vcov,
  test = "Satterthwaite",
  coefs = "All",
  p_values = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_test_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate t-tests.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_vcov">vcov</code></td>
<td>
<p>Variance covariance matrix estimated using <code>vcovCR</code> or a
character string specifying which small-sample adjustment should be used to
calculate the variance-covariance.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_test">test</code></td>
<td>
<p>Character vector specifying which small-sample corrections to
calculate. <code>"z"</code> returns a z test (i.e., using a standard normal
reference distribution). <code>"naive-t"</code> returns a t test with <code>m -
1</code> degrees of freedom, where <code>m</code> is the number of unique clusters.
<code>"naive-tp"</code> returns a t test with <code>m - p</code> degrees of freedom,
where <code>p</code> is the number of regression coefficients in <code>obj</code>.
<code>"Satterthwaite"</code> returns a Satterthwaite correction.
<code>"saddlepoint"</code> returns a saddlepoint correction. Default is
<code>"Satterthwaite"</code>.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_coefs">coefs</code></td>
<td>
<p>Character, integer, or logical vector specifying which
coefficients should be tested. The default value <code>"All"</code> will test all
estimated coefficients.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_p_values">p_values</code></td>
<td>
<p>Logical indicating whether to report p-values. The default
value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+vcovCR">vcovCR</a></code>, which are only
needed if <code>vcov</code> is a character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing estimated regression coefficients, standard
errors, and test results. For the Satterthwaite approximation, degrees of
freedom and a p-value are reported. For the saddlepoint approximation, the
saddlepoint and a p-value are reported.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("ChickWeight", package = "datasets")
lm_fit &lt;- lm(weight ~ Diet  * Time, data = ChickWeight)
diet_index &lt;- grepl("Diet.:Time", names(coef(lm_fit)))
coef_test(lm_fit, vcov = "CR2", cluster = ChickWeight$Chick, coefs = diet_index)

V_CR2 &lt;- vcovCR(lm_fit, cluster = ChickWeight$Chick, type = "CR2")
coef_test(lm_fit, vcov = V_CR2, coefs = diet_index)

</code></pre>

<hr>
<h2 id='conf_int'>Calculate confidence intervals for all or selected regression coefficients in
a fitted model</h2><span id='topic+conf_int'></span>

<h3>Description</h3>

<p><code>conf_int</code> reports confidence intervals for each coefficient estimate in
a fitted linear regression model, using a sandwich estimator for the standard
errors and a small sample correction for the critical values. The
small-sample correction is based on a Satterthwaite approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf_int(
  obj,
  vcov,
  level = 0.95,
  test = "Satterthwaite",
  coefs = "All",
  ...,
  p_values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_int_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate confidence intervals.</p>
</td></tr>
<tr><td><code id="conf_int_+3A_vcov">vcov</code></td>
<td>
<p>Variance covariance matrix estimated using <code>vcovCR</code> or a
character string specifying which small-sample adjustment should be used to
calculate the variance-covariance.</p>
</td></tr>
<tr><td><code id="conf_int_+3A_level">level</code></td>
<td>
<p>Desired coverage level for confidence intervals.</p>
</td></tr>
<tr><td><code id="conf_int_+3A_test">test</code></td>
<td>
<p>Character vector specifying which small-sample corrections to
calculate. <code>"z"</code> returns a z test (i.e., using a standard normal
reference distribution). <code>"naive-t"</code> returns a t test with <code>m -
1</code> degrees of freedom, where <code>m</code> is the number of unique clusters.
<code>"naive-tp"</code> returns a t test with <code>m - p</code> degrees of freedom,
where <code>p</code> is the number of regression coefficients in <code>obj</code>.
<code>"Satterthwaite"</code> returns a Satterthwaite correction. Unlike in
<code>coef_test()</code>, <code>"saddlepoint"</code> is not currently supported in
<code>conf_int()</code> because saddlepoint confidence intervals do not have a
closed-form solution.</p>
</td></tr>
<tr><td><code id="conf_int_+3A_coefs">coefs</code></td>
<td>
<p>Character, integer, or logical vector specifying which
coefficients should be tested. The default value <code>"All"</code> will test all
estimated coefficients.</p>
</td></tr>
<tr><td><code id="conf_int_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+vcovCR">vcovCR</a></code>, which are only
needed if <code>vcov</code> is a character string.</p>
</td></tr>
<tr><td><code id="conf_int_+3A_p_values">p_values</code></td>
<td>
<p>Logical indicating whether to report p-values. The default
value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing estimated regression coefficients, standard
errors, confidence intervals, and (optionally) p-values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("ChickWeight", package = "datasets")
lm_fit &lt;- lm(weight ~ Diet  * Time, data = ChickWeight)
diet_index &lt;- grepl("Diet.:Time", names(coef(lm_fit)))
conf_int(lm_fit, vcov = "CR2", cluster = ChickWeight$Chick, coefs = diet_index)

V_CR2 &lt;- vcovCR(lm_fit, cluster = ChickWeight$Chick, type = "CR2")
conf_int(lm_fit, vcov = V_CR2, level = .99, coefs = diet_index)

</code></pre>

<hr>
<h2 id='constraint_matrices'>Create constraint matrices</h2><span id='topic+constraint_matrices'></span><span id='topic+constrain_zero'></span><span id='topic+constrain_equal'></span><span id='topic+constrain_pairwise'></span>

<h3>Description</h3>

<p>Helper functions to create common types of constraint matrices,
for use with <code><a href="#topic+Wald_test">Wald_test</a></code> to conduct Wald-type tests of linear
contrasts from a fitted regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrain_zero(constraints, coefs, reg_ex = FALSE)

constrain_equal(constraints, coefs, reg_ex = FALSE)

constrain_pairwise(constraints, coefs, reg_ex = FALSE, with_zero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraint_matrices_+3A_constraints">constraints</code></td>
<td>
<p>Set of constraints to test. Can be logical (using
<code>TRUE</code> to specify which coefficients to constrain), integer (specify
the index of coefficients to constrain), character (specify the names of
the coefficients to constrain), or a regular expression.</p>
</td></tr>
<tr><td><code id="constraint_matrices_+3A_coefs">coefs</code></td>
<td>
<p>Vector of coefficient estimates, used to determine the column
dimension of the constraint matrix. Can be omitted if the function is
called inside <code>Wald_test()</code>.</p>
</td></tr>
<tr><td><code id="constraint_matrices_+3A_reg_ex">reg_ex</code></td>
<td>
<p>Logical indicating whether <code>constraints</code> should be
interpreted as a regular expression. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="constraint_matrices_+3A_with_zero">with_zero</code></td>
<td>
<p>Logical indicating whether coefficients should also be
compared to zero. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constraints can be specified as character vectors, regular
expressions (with <code>reg_ex = TRUE</code>), integer vectors, or logical
vectors.
</p>
<p><code>constrain_zero()</code> Creates a matrix that constrains a specified set of
coefficients to all be equal to zero.
</p>
<p><code>constrain_equal()</code> Creates a matrix that constrains a specified set
of coefficients to all be equal.
</p>
<p><code>constrain_pairwise()</code> Creates a list of constraint matrices
consisting of all pairwise comparisons between a specified set of
coefficients. If <code>with_zero = TRUE</code>, then the list will also include a
set of constraint matrices comparing each coefficient to zero.
</p>


<h3>Value</h3>

<p>A matrix or list of matrices encoding the specified set of
constraints.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wald_test">Wald_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("carData", quietly = TRUE)) withAutoprint({

data(Duncan, package = "carData")
Duncan$cluster &lt;- sample(LETTERS[1:8], size = nrow(Duncan), replace = TRUE)

Duncan_fit &lt;- lm(prestige ~ 0 + type + income + type:income + type:education, data=Duncan)
# Note that type:income terms are interactions because main effect of income is included
# but type:education terms are separate slopes for each unique level of type

Duncan_coefs &lt;- coef(Duncan_fit)

# The following are all equivalent
constrain_zero(constraints = c("typeprof:income","typewc:income"), 
               coefs = Duncan_coefs)
constrain_zero(constraints = ":income", coefs = Duncan_coefs, 
               reg_ex = TRUE)
constrain_zero(constraints = 5:6, coefs = Duncan_coefs)
constrain_zero(constraints = c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE), 
               coefs = Duncan_coefs)

# The following are all equivalent
constrain_equal(c("typebc:education","typeprof:education","typewc:education"), 
                Duncan_coefs)
constrain_equal(":education", Duncan_coefs, reg_ex = TRUE)
constrain_equal(7:9, Duncan_coefs)
constrain_equal(c(FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE,TRUE), 
                Duncan_coefs)

# Test pairwise equality of the education slopes
constrain_pairwise(":education", Duncan_coefs,
                   reg_ex = TRUE)

# Test pairwise equality of the income slopes, plus compare against zero
constrain_pairwise(":income", Duncan_coefs, 
                   reg_ex = TRUE, with_zero = TRUE)
                   
})

</code></pre>

<hr>
<h2 id='dropoutPrevention'>Dropout prevention/intervention program effects</h2><span id='topic+dropoutPrevention'></span>

<h3>Description</h3>

<p>A dataset containing estimated effect sizes, variances, and covariates from a
meta-analysis of dropout prevention/intervention program effects, conducted
by Wilson et al. (2011). Missing observations were imputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropoutPrevention
</code></pre>


<h3>Format</h3>

<p>A data frame with 385 rows and 18 variables: </p>

<dl>
<dt>LOR1</dt><dd><p>log-odds ratio measuring the intervention effect</p>
</dd>
<dt>varLOR</dt><dd><p>estimated sampling variance of the log-odds ratio</p>
</dd>
<dt>studyID</dt><dd><p>unique identifier for each study</p>
</dd> <dt>studySample</dt><dd><p>unique
identifier for each sample within a study</p>
</dd> <dt>study_design</dt><dd><p>study design
(randomized, matched, or non-randomized and unmatched)</p>
</dd>
<dt>outcome</dt><dd><p>outcome measure for the intervention effect is estimated
(school dropout, school enrollment, graduation, graduation or GED receipt)</p>
</dd>
<dt>evaluator_independence</dt><dd><p>degree of evaluator independence
(independent, indirect but influential, involved in planning but not
delivery, involved in delivery)</p>
</dd> <dt>implementation_quality</dt><dd><p>level of
implementation quality (clear problems, possible problems, no apparent
problems)</p>
</dd> <dt>program_site</dt><dd><p>Program delivery site (community, mixed,
school classroom, school but outside of classroom)</p>
</dd>
<dt>attrition</dt><dd><p>Overall attrition (proportion)</p>
</dd>
<dt>group_equivalence</dt><dd><p>pretest group-equivalence log-odds ratio</p>
</dd>
<dt>adjusted</dt><dd><p>adjusted or unadjusted data used to calculate intervention
effect</p>
</dd> <dt>male_pct</dt><dd><p>proportion of the sample that is male</p>
</dd>
<dt>white_pct</dt><dd><p>proportion of the sample that is white</p>
</dd>
<dt>average_age</dt><dd><p>average age of the sample</p>
</dd> <dt>duration</dt><dd><p>program
duration (in weeks)</p>
</dd> <dt>service_hrs</dt><dd><p>program contact hours per week</p>
</dd>
<dt>big_study</dt><dd><p>indicator for the 32 studies with 3 or more effect sizes</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wilson, S. J., Lipsey, M. W., Tanner-Smith, E., Huang, C. H., &amp;
Steinka-Fry, K. T. (2011). Dropout prevention and intervention programs:
Effects on school completion and dropout Among school-aged children and
youth: A systematic review. _Campbell Systematic Reviews, 7_(1), 1-61.
<a href="https://doi.org/10.4073/csr.2011.8">doi:10.4073/csr.2011.8</a>
</p>


<h3>References</h3>

<p>Wilson, S. J., Lipsey, M. W., Tanner-Smith, E., Huang, C. H., &amp;
Steinka-Fry, K. T. (2011). Dropout prevention and intervention programs:
Effects on school completion and dropout Among school-aged children and
youth: A systematic review. _Campbell Systematic Reviews, 7_(1), 1-61.
<a href="https://doi.org/10.4073/csr.2011.8">doi:10.4073/csr.2011.8</a>
</p>
<p>Tipton, E., &amp; Pustejovsky, J. E. (2015). Small-sample adjustments for tests
of moderators and model fit using robust variance estimation in
meta-regression. _Journal of Educational and Behavioral Statistics, 40_(6), 604-634.
<a href="https://doi.org/10.3102/1076998615606099">doi:10.3102/1076998615606099</a>
</p>

<hr>
<h2 id='findCluster.rma.mv'>Detect cluster structure of an rma.mv object</h2><span id='topic+findCluster.rma.mv'></span>

<h3>Description</h3>

<p><code>findCluster.rma.mv</code> returns a vector of ID variables for the highest level of clustering in a fitted <code>rma.mv</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCluster.rma.mv(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findCluster.rma.mv_+3A_obj">obj</code></td>
<td>
<p>A fitted <code>rma.mv</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A a vector of ID variables for the highest level of clustering in <code>obj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("metafor", quietly = TRUE)) {

library(metafor)
data(dat.assink2016, package = "metadat")

mfor_fit &lt;- rma.mv(yi ~ year + deltype, 
                 V = vi, random = ~ 1 | study / esid,
                 data = dat.assink2016)
                 
findCluster.rma.mv(mfor_fit)

}

</code></pre>

<hr>
<h2 id='impute_covariance_matrix'>Impute a block-diagonal covariance matrix</h2><span id='topic+impute_covariance_matrix'></span>

<h3>Description</h3>

<p><code>impute_covariance_matrix</code> calculates a
block-diagonal covariance matrix, given the marginal variances, the block
structure, and an assumed correlation structure. Can be used to create
compound-symmetric structures, AR(1) auto-correlated structures, or
combinations thereof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_covariance_matrix(
  vi,
  cluster,
  r,
  ti,
  ar1,
  smooth_vi = FALSE,
  subgroup = NULL,
  return_list = identical(as.factor(cluster), sort(as.factor(cluster))),
  check_PD = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_covariance_matrix_+3A_vi">vi</code></td>
<td>
<p>Vector of variances</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_cluster">cluster</code></td>
<td>
<p>Vector indicating which effects belong to the same cluster.
Effects with the same value of 'cluster' will be treated as correlated.</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_r">r</code></td>
<td>
<p>Vector or numeric value of assumed constant correlation(s) between
effect size estimates from each study.</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_ti">ti</code></td>
<td>
<p>Vector of time-points describing temporal spacing of effects, for
use with auto-regressive correlation structures.</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_ar1">ar1</code></td>
<td>
<p>Vector or numeric value of assumed AR(1) auto-correlation(s)
between effect size estimates from each study. If specified, then <code>ti</code>
argument must be specified.</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_smooth_vi">smooth_vi</code></td>
<td>
<p>Logical indicating whether to smooth the marginal variances
by taking the average <code>vi</code> within each cluster. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_subgroup">subgroup</code></td>
<td>
<p>Vector of category labels describing sub-groups of effects.
If non-null, effects that share the same category label and the same
cluster will be treated as correlated, but effects with different category
labels will be treated as uncorrelated, even if they come from the same
cluster.</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_return_list">return_list</code></td>
<td>
<p>Optional logical indicating whether to return a list of
matrices (with one entry per block) or the full variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="impute_covariance_matrix_+3A_check_pd">check_PD</code></td>
<td>
<p>Optional logical indicating whether to check whether each
covariance matrix is positive definite. If <code>TRUE</code> (the default), the
function will display a warning if any covariance matrix is not positive
definite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A block-diagonal variance-covariance matrix (possibly represented as
a list of matrices) with a specified structure. The structure depends on
whether the <code>r</code> argument, <code>ar1</code> argument, or both arguments are
specified. Let <code class="reqn">v_{ij}</code> denote the specified variance for
effect <code class="reqn">i</code> in cluster <code class="reqn">j</code> and <code class="reqn">C_{hij}</code> be
the covariance between effects <code class="reqn">h</code> and <code class="reqn">i</code> in cluster
<code class="reqn">j</code>. </p>
 <ul>
<li><p>If only <code>r</code> is specified, each block
of the variance-covariance matrix will have a constant (compound symmetric)
correlation, so that </p>
<p style="text-align: center;"><code class="reqn">C_{hij} = r_j \sqrt{v_{hj} v_{ij},}</code>
</p>
<p> where <code class="reqn">r_j</code> is the specified correlation
for cluster <code class="reqn">j</code>. If only a single value is given in <code>r</code>, then
it will be used for every cluster. </p>
</li>
<li><p>If only <code>ar1</code> is
specified, each block of the variance-covariance matrix will have an
AR(1) auto-correlation structure, so that </p>
<p style="text-align: center;"><code class="reqn">C_{hij} = \phi_j^{|t_{hj}
  - t_{ij}|} \sqrt{v_{hj} v_{ij},}</code>
</p>
<p> where <code class="reqn">\phi_j</code> is the specified auto-correlation
for cluster <code class="reqn">j</code> and <code class="reqn">t_{hj}</code> and <code class="reqn">t_{ij}</code>
are specified time-points corresponding to effects <code class="reqn">h</code> and
<code class="reqn">i</code> in cluster <code class="reqn">j</code>. If only a single value is given in
<code>ar1</code>, then it will be used for every cluster. </p>
</li>
<li><p>If both <code>r</code>
and <code>ar1</code> are specified, each block of the variance-covariance
matrix will have combination of compound symmetric and an AR(1)
auto-correlation structures, so that </p>
<p style="text-align: center;"><code class="reqn">C_{hij} = \left[r_j + (1 -
  r_j)\phi_j^{|t_{hj} - t_{ij}|}\right] \sqrt{v_{hj} v_{ij},}</code>
</p>
<p> where
<code class="reqn">r_j</code> is the specified constant correlation for cluster
<code class="reqn">j</code>, <code class="reqn">\phi_j</code> is the specified auto-correlation for
cluster <code class="reqn">j</code> and <code class="reqn">t_{hj}</code> and <code class="reqn">t_{ij}</code> are
specified time-points corresponding to effects <code class="reqn">h</code> and
<code class="reqn">i</code> in cluster <code class="reqn">j</code>. If only single values are given in
<code>r</code> or <code>ar1</code>, they will be used for every cluster. </p>
</li></ul>
<p> If
<code>smooth_vi = TRUE</code>, then all of the variances within cluster
<code class="reqn">j</code> will be set equal to the average variance of cluster
<code class="reqn">j</code>, i.e., </p>
<p style="text-align: center;"><code class="reqn">v'_{ij} = \frac{1}{n_j} \sum_{i=1}^{n_j}
  v_{ij}</code>
</p>
<p> for
<code class="reqn">i=1,...,n_j</code> and <code class="reqn">j=1,...,k</code>.
</p>


<h3>Value</h3>

<p>If <code>cluster</code> is appropriately sorted, then a list of matrices,
with one entry per cluster, will be returned by default. If <code>cluster</code>
is out of order, then the full variance-covariance matrix will be returned
by default. The output structure can be controlled with the optional
<code>return_list</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("metafor", quietly = TRUE)) {

library(metafor)

# Constant correlation
data(SATcoaching)
V_list &lt;- impute_covariance_matrix(vi = SATcoaching$V, cluster = SATcoaching$study, r = 0.66)
MVFE &lt;- rma.mv(d ~ 0 + test, V = V_list, data = SATcoaching)
conf_int(MVFE, vcov = "CR2", cluster = SATcoaching$study)

}

</code></pre>

<hr>
<h2 id='linear_contrast'>Calculate confidence intervals and p-values for linear contrasts of
regression coefficients in a fitted model</h2><span id='topic+linear_contrast'></span>

<h3>Description</h3>

<p><code>linear_contrast</code> reports confidence intervals and (optionally) p-values
for linear contrasts of regression coefficients from a fitted model, using a
sandwich estimator for the standard errors and (optionally) a small sample
correction for the critical values. The default small-sample correction is
based on a Satterthwaite approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_contrast(
  obj,
  vcov,
  contrasts,
  level = 0.95,
  test = "Satterthwaite",
  ...,
  p_values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_contrast_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate confidence intervals.</p>
</td></tr>
<tr><td><code id="linear_contrast_+3A_vcov">vcov</code></td>
<td>
<p>Variance covariance matrix estimated using <code>vcovCR</code> or a
character string specifying which small-sample adjustment should be used to
calculate the variance-covariance.</p>
</td></tr>
<tr><td><code id="linear_contrast_+3A_contrasts">contrasts</code></td>
<td>
<p>A contrast matrix, or a list of multiple contrast matrices
to test. See details and examples.</p>
</td></tr>
<tr><td><code id="linear_contrast_+3A_level">level</code></td>
<td>
<p>Desired coverage level for confidence intervals.</p>
</td></tr>
<tr><td><code id="linear_contrast_+3A_test">test</code></td>
<td>
<p>Character vector specifying which small-sample corrections to
calculate. <code>"z"</code> returns a z test (i.e., using a standard normal
reference distribution). <code>"naive-t"</code> returns a t test with <code>m -
1</code> degrees of freedom, where <code>m</code> is the number of unique clusters.
<code>"naive-tp"</code> returns a t test with <code>m - p</code> degrees of freedom,
where <code>p</code> is the number of regression coefficients in <code>obj</code>.
<code>"Satterthwaite"</code> returns a Satterthwaite correction. Unlike in
<code>coef_test()</code>, <code>"saddlepoint"</code> is not currently supported in
<code>conf_int()</code> because saddlepoint confidence intervals do not have a
closed-form solution.</p>
</td></tr>
<tr><td><code id="linear_contrast_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+vcovCR">vcovCR</a></code>, which are only
needed if <code>vcov</code> is a character string.</p>
</td></tr>
<tr><td><code id="linear_contrast_+3A_p_values">p_values</code></td>
<td>
<p>Logical indicating whether to report p-values. The default
value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constraints can be specified directly as q X p matrices or
indirectly through <code><a href="#topic+constrain_pairwise">constrain_pairwise</a></code>,
<code><a href="#topic+constrain_equal">constrain_equal</a></code>, or <code><a href="#topic+constrain_zero">constrain_zero</a></code>.
</p>


<h3>Value</h3>

<p>A data frame containing estimated contrasts, standard
errors, confidence intervals, and (optionally) p-values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("ChickWeight", package = "datasets")
lm_fit &lt;- lm(weight ~ 0 + Diet + Time:Diet, data = ChickWeight)

# Pairwise comparisons of diet-by-time slopes
linear_contrast(lm_fit, vcov = "CR2", cluster = ChickWeight$Chick, 
                contrasts = constrain_pairwise("Diet.:Time", reg_ex = TRUE))


if (requireNamespace("carData", quietly = TRUE)) withAutoprint({

  data(Duncan, package = "carData")
  Duncan$cluster &lt;- sample(LETTERS[1:8], size = nrow(Duncan), replace = TRUE)

  Duncan_fit &lt;- lm(prestige ~ 0 + type + income + type:income + type:education, data=Duncan)
  # Note that type:income terms are interactions because main effect of income is included
  # but type:education terms are separate slopes for each unique level of type

  # Pairwise comparisons of type-by-education slopes
  linear_contrast(Duncan_fit, vcov = "CR2", cluster = Duncan$cluster,
                  contrasts = constrain_pairwise(":education", reg_ex = TRUE),
                  test = "Satterthwaite")
 
  # Pairwise comparisons of type-by-income interactions
  linear_contrast(Duncan_fit, vcov = "CR2", cluster = Duncan$cluster,
                  contrasts = constrain_pairwise(":income", reg_ex = TRUE, with_zero = TRUE),
                  test = "Satterthwaite")
                  
})

</code></pre>

<hr>
<h2 id='MortalityRates'>State-level annual mortality rates by cause among 18-20 year-olds</h2><span id='topic+MortalityRates'></span>

<h3>Description</h3>

<p>A dataset containing state-level annual mortality rates for select causes of
death, as well as data related to the minimum legal drinking age and alcohol
consumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MortalityRates
</code></pre>


<h3>Format</h3>

<p>A data frame with 5508 rows and 12 variables: </p>
 
<dl>
<dt>year</dt><dd><p>Year of observation</p>
</dd> 
<dt>state</dt><dd><p>identifier for state</p>
</dd> 
<dt>count</dt><dd><p>Number of deaths</p>
</dd> 
<dt>pop</dt><dd><p>Population size</p>
</dd> 
<dt>legal</dt><dd><p>Proportion of 18-20 year-old population that is legally allowed to drink</p>
</dd> 
<dt>beertaxa</dt><dd><p>Beer taxation rate</p>
</dd> 
<dt>beerpercap</dt><dd><p>Beer consumption per capita</p>
</dd> 
<dt>winepercap</dt><dd><p>Wine consumption per capita</p>
</dd> 
<dt>spiritpercap</dt><dd><p>Spirits consumption per capita</p>
</dd> 
<dt>totpercap</dt><dd><p>Total alcohol consumption per capita</p>
</dd> 
<dt>mrate</dt><dd><p>Mortality rate per 10,000</p>
</dd> 
<dt>cause</dt><dd><p>Cause of death</p>
</dd> 
</dl>



<h3>Source</h3>

<p><a href="http://masteringmetrics.com/wp-content/uploads/2015/01/deaths.dta">Mastering
'Metrics data archive</a>
</p>


<h3>References</h3>

<p>Angrist, J. D., and Pischke, J. S. (2014). _Mastering'metrics: the path from
cause to effect_. Princeton University Press, 2014.
</p>
<p>Carpenter, C., &amp; Dobkin, C. (2011). The minimum legal drinking age and public
health. _Journal of Economic Perspectives, 25_(2), 133-156.
<a href="https://doi.org/10.1257/jep.25.2.133">doi:10.1257/jep.25.2.133</a>
</p>

<hr>
<h2 id='pattern_covariance_matrix'>Impute a patterned block-diagonal covariance matrix</h2><span id='topic+pattern_covariance_matrix'></span>

<h3>Description</h3>

<p><code>pattern_covariance_matrix</code> calculates a
block-diagonal covariance matrix, given the marginal variances, the block
structure, and an assumed correlation structure defined by a patterned
correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern_covariance_matrix(
  vi,
  cluster,
  pattern_level,
  r_pattern,
  r,
  smooth_vi = FALSE,
  subgroup = NULL,
  return_list = identical(as.factor(cluster), sort(as.factor(cluster))),
  check_PD = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattern_covariance_matrix_+3A_vi">vi</code></td>
<td>
<p>Vector of variances</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_cluster">cluster</code></td>
<td>
<p>Vector indicating which effects belong to the same cluster.
Effects with the same value of 'cluster' will be treated as correlated.</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_pattern_level">pattern_level</code></td>
<td>
<p>Vector of categories for each effect size, used to
determine which entry of the pattern matrix will be used to impute a
correlation.</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_r_pattern">r_pattern</code></td>
<td>
<p>Patterned correlation matrix with row and column names
corresponding to the levels of <code>pattern</code>.</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_r">r</code></td>
<td>
<p>Vector or numeric value of assumed constant correlation(s) between
effect size estimates from each study.</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_smooth_vi">smooth_vi</code></td>
<td>
<p>Logical indicating whether to smooth the marginal variances
by taking the average <code>vi</code> within each cluster. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_subgroup">subgroup</code></td>
<td>
<p>Vector of category labels describing sub-groups of effects.
If non-null, effects that share the same category label and the same
cluster will be treated as correlated, but effects with different category
labels will be treated as uncorrelated, even if they come from the same
cluster.</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_return_list">return_list</code></td>
<td>
<p>Optional logical indicating whether to return a list of
matrices (with one entry per block) or the full variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="pattern_covariance_matrix_+3A_check_pd">check_PD</code></td>
<td>
<p>Optional logical indicating whether to check whether each
covariance matrix is positive definite. If <code>TRUE</code> (the default), the
function will display a warning if any covariance matrix is not positive
definite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A block-diagonal variance-covariance matrix (possibly represented as
a list of matrices) with a specified correlation structure, defined by a
patterned correlation matrix. Let <code class="reqn">v_{ij}</code> denote the specified
variance for effect <code class="reqn">i</code> in cluster <code class="reqn">j</code> and
<code class="reqn">C_{hij}</code> be the covariance between effects <code class="reqn">h</code> and
<code class="reqn">i</code> in cluster <code class="reqn">j</code>. Let <code class="reqn">p_{ij}</code> be the level
of the pattern variable for effect <code class="reqn">i</code> in cluster <code class="reqn">j</code>,
taking a value in <code class="reqn">1,...,C</code>. A patterned correlation matrix
is defined as a set of correlations between pairs of effects taking each
possible combination of patterns. Formally, let <code class="reqn">r_{cd}</code> be the
correlation between effects in categories <code class="reqn">c</code> and <code class="reqn">d</code>,
respectively, where <code class="reqn">r_{cd} = r_{dc}</code>. Then the
covariance between effects <code class="reqn">h</code> and <code class="reqn">i</code> in cluster
<code class="reqn">j</code> is taken to be </p>
<p style="text-align: center;"><code class="reqn">C_{hij} = \sqrt{v_{hj} v_{ij}} \times
  r_{p_{hj} p_{ij}}.</code>
</p>
 
<p>Correlations between effect sizes within the same category are defined by the diagonal
values of the pattern matrix, which may take values less than one. 
</p>
<p>Combinations of pattern levels that do not occur in the patterned correlation matrix will be set equal to <code>r</code>.
</p>
<p>If <code>smooth_vi = TRUE</code>, then all of the variances within cluster
<code class="reqn">j</code> will be set equal to the average variance of cluster
<code class="reqn">j</code>, i.e., </p>
<p style="text-align: center;"><code class="reqn">v'_{ij} = \frac{1}{n_j} \sum_{i=1}^{n_j}
  v_{ij}</code>
</p>
<p> for
<code class="reqn">i=1,...,n_j</code> and <code class="reqn">j=1,...,k</code>.
</p>


<h3>Value</h3>

<p>If <code>cluster</code> is appropriately sorted, then a list of matrices,
with one entry per cluster, will be returned by default. If <code>cluster</code>
is out of order, then the full variance-covariance matrix will be returned
by default. The output structure can be controlled with the optional
<code>return_list</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pkgs_available &lt;- 
  requireNamespace("metafor", quietly = TRUE) &amp; 
  requireNamespace("robumeta", quietly = TRUE)
  
if (pkgs_available) {
library(metafor)

data(oswald2013, package = "robumeta")
dat &lt;- escalc(data = oswald2013, measure = "ZCOR", ri = R, ni = N)
subset_ids &lt;- unique(dat$Study)[1:20]
dat &lt;- subset(dat, Study %in% subset_ids)

# make a patterned correlation matrix 

p_levels &lt;- levels(dat$Crit.Cat)
r_pattern &lt;- 0.7^as.matrix(dist(1:length(p_levels)))
diag(r_pattern) &lt;- seq(0.75, 0.95, length.out = 6)
rownames(r_pattern) &lt;- colnames(r_pattern) &lt;- p_levels

# impute the covariance matrix using patterned correlations
V_list &lt;- pattern_covariance_matrix(vi = dat$vi, 
                                    cluster = dat$Study, 
                                    pattern_level = dat$Crit.Cat,
                                    r_pattern = r_pattern,
                                    smooth_vi = TRUE)
                                    
# fit a model using imputed covariance matrix

MVFE &lt;- rma.mv(yi ~ 0 + Crit.Cat, V = V_list, 
               random = ~ Crit.Cat | Study,
               data = dat)
               
conf_int(MVFE, vcov = "CR2")

}

</code></pre>

<hr>
<h2 id='SATcoaching'>Randomized experiments on SAT coaching</h2><span id='topic+SATcoaching'></span>

<h3>Description</h3>

<p>Effect sizes from studies on the effects of SAT coaching,
reported in Kalaian and Raudenbush (1996)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SATcoaching
</code></pre>


<h3>Format</h3>

<p>A data frame with 67 rows and 11 variables: 
</p>
 
<dl>
<dt>study</dt><dd><p>Study identifier</p>
</dd>
<dt>year</dt><dd><p>Year of publication</p>
</dd> 
<dt>test</dt><dd><p>Character string indicating whether effect size corresponds to outcome on verbal (SATV) or math (SATM) test</p>
</dd>
<dt>d</dt><dd><p>Effect size estimate (Standardized mean difference)</p>
</dd> 
<dt>V</dt><dd><p>Variance of effect size estimate</p>
</dd> 
<dt>nT</dt><dd><p>Sample size in treatment condition</p>
</dd> 
<dt>nC</dt><dd><p>Sample size in control condition</p>
</dd> 
<dt>study_type</dt><dd><p>Character string indicating whether study design used a matched, non-equivalent, or randomized control group</p>
</dd> 
<dt>hrs</dt><dd><p>Hours of coaching</p>
</dd> 
<dt>ETS</dt><dd><p>Indicator variable for Educational Testing Service</p>
</dd> 
<dt>homework</dt><dd><p>Indicator variable for homework</p>
</dd> 
</dl>



<h3>References</h3>

<p>Kalaian, H. A. &amp; Raudenbush, S. W. (1996). A multivariate mixed 
linear model for meta-analysis. <em>Psychological Methods, 1</em>(3),
227-235. 
<a href="https://doi.org/10.1037/1082-989X.1.3.227">doi:10.1037/1082-989X.1.3.227</a>
</p>

<hr>
<h2 id='vcovCR'>Cluster-robust variance-covariance matrix</h2><span id='topic+vcovCR'></span><span id='topic+vcovCR.default'></span>

<h3>Description</h3>

<p>This is a generic function, with specific methods defined for 
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="plm.html#topic+plm">plm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, 
<code><a href="nlme.html#topic+gls">gls</a></code>, <code><a href="nlme.html#topic+lme">lme</a></code>,
<code><a href="robumeta.html#topic+robu">robu</a></code>, <code><a href="metafor.html#topic+rma.uni">rma.uni</a></code>, and
<code><a href="metafor.html#topic+rma.mv">rma.mv</a></code> objects.
</p>
<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovCR(obj, cluster, type, target, inverse_var, form, ...)

## Default S3 method:
vcovCR(
  obj,
  cluster,
  type,
  target = NULL,
  inverse_var = FALSE,
  form = "sandwich",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR_+3A_cluster">cluster</code></td>
<td>
<p>Expression or vector indicating which observations belong to 
the same cluster. For some classes, the cluster will be detected 
automatically if not specified.</p>
</td></tr>
<tr><td><code id="vcovCR_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working 
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code> 
adjustment matrices. If a vector, the target matrix is assumed to be 
diagonal. If not specified, <code>vcovCR</code> will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates.
</p>
<p>Several different small sample corrections are available, which run 
parallel with the &quot;HC&quot; corrections for heteroskedasticity-consistent 
variance estimators, as implemented in <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code>. The
&quot;CR2&quot; adjustment is recommended (Pustejovsky &amp; Tipton, 2017; Imbens &amp;
Kolesar, 2016). See Pustejovsky and Tipton (2017) and Cameron and Miller
(2015) for further technical details. Available options include: </p>

<dl>
<dt>&quot;CR0&quot;</dt><dd><p>is the original form of the sandwich estimator (Liang &amp; Zeger,
1986), which does not make any small-sample correction.</p>
</dd> 
<dt>&quot;CR1&quot;</dt><dd><p>multiplies CR0 by <code>m / (m - 1)</code>, where <code>m</code> is the 
number of clusters.</p>
</dd> 
<dt>&quot;CR1p&quot;</dt><dd><p>multiplies CR0 by <code>m / (m - p)</code>, where <code>m</code> is the 
number of clusters and <code>p</code> is the number of covariates.</p>
</dd> 
<dt>&quot;CR1S&quot;</dt><dd><p>multiplies CR0 by <code>(m (N-1)) / [(m - 
  1)(N - p)]</code>, where <code>m</code> is the number of clusters, <code>N</code> is the 
total number of observations, and <code>p</code> is the number of covariates. 
Some Stata commands use this correction by default.</p>
</dd> 
<dt>&quot;CR2&quot;</dt><dd><p>is the
&quot;bias-reduced linearization&quot; adjustment proposed by Bell and McCaffrey
(2002) and further developed in Pustejovsky and Tipton (2017). The
adjustment is chosen so that the variance-covariance estimator is exactly
unbiased under a user-specified working model.</p>
</dd> 
<dt>&quot;CR3&quot;</dt><dd><p>approximates the leave-one-cluster-out jackknife variance estimator (Bell &amp; McCaffrey,
2002).</p>
</dd> </dl>



<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists 
of a matrix of the estimated variance of and covariances between the 
regression coefficient estimates. The matrix has several attributes: 
</p>
 <dl>
<dt>type</dt><dd><p>indicates which small-sample adjustment was used</p>
</dd> 
<dt>cluster</dt><dd><p>contains the factor vector that defines independent 
clusters</p>
</dd> <dt>bread</dt><dd><p>contains the bread matrix</p>
</dd> <dt>v_scale</dt><dd><p>constant 
used in scaling the sandwich estimator</p>
</dd> <dt>est_mats</dt><dd><p>contains a list of 
estimating matrices used to calculate the sandwich estimator</p>
</dd> 
<dt>adjustments</dt><dd><p>contains a list of adjustment matrices used to calculate
the sandwich estimator</p>
</dd> <dt>target</dt><dd><p>contains the working 
variance-covariance model used to calculate the adjustment matrices. This 
is needed for calculating small-sample corrections for Wald tests.</p>
</dd> </dl>



<h3>References</h3>

<p>Bell, R. M., &amp; McCaffrey, D. F. (2002). Bias reduction in
standard errors for linear regression with multi-stage samples. Survey
Methodology, 28(2), 169-181.
</p>
<p>Cameron, A. C., &amp; Miller, D. L. (2015). A Practitioner's Guide to
Cluster-Robust Inference. <em>Journal of Human Resources, 50</em>(2), 317-372.
<a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Imbens, G. W., &amp; Kolesar, M. (2016). Robust standard errors in small samples:
Some practical advice. <em>Review of Economics and Statistics, 98</em>(4),
701-712. <a href="https://doi.org/10.1162/rest_a_00552">doi:10.1162/rest_a_00552</a>
</p>
<p>Liang, K.-Y., &amp; Zeger, S. L. (1986). Longitudinal data analysis using
generalized linear models. <em>Biometrika, 73</em>(1), 13-22.
<a href="https://doi.org/10.1093/biomet/73.1.13">doi:10.1093/biomet/73.1.13</a>
</p>
<p>Pustejovsky, J. E. &amp; Tipton, E. (2018). Small sample methods for
cluster-robust variance estimation and hypothesis testing in fixed effects
models. <em>Journal of Business and Economic Statistics, 36</em>(4), 672-683.
<a href="https://doi.org/10.1080/07350015.2016.1247004">doi:10.1080/07350015.2016.1247004</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR.lm">vcovCR.lm</a></code>, <code><a href="#topic+vcovCR.plm">vcovCR.plm</a></code>, 
<code><a href="#topic+vcovCR.glm">vcovCR.glm</a></code>, <code><a href="#topic+vcovCR.gls">vcovCR.gls</a></code>,
<code><a href="#topic+vcovCR.lme">vcovCR.lme</a></code>, <code><a href="#topic+vcovCR.lmerMod">vcovCR.lmerMod</a></code>, <code><a href="#topic+vcovCR.robu">vcovCR.robu</a></code>,
<code><a href="#topic+vcovCR.rma.uni">vcovCR.rma.uni</a></code>, <code><a href="#topic+vcovCR.rma.mv">vcovCR.rma.mv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate design with cluster-dependence
m &lt;- 8
cluster &lt;- factor(rep(LETTERS[1:m], 3 + rpois(m, 5)))
n &lt;- length(cluster)
X &lt;- matrix(rnorm(3 * n), n, 3)
nu &lt;- rnorm(m)[cluster]
e &lt;- rnorm(n)
y &lt;- X %*% c(.4, .3, -.3) + nu + e
dat &lt;- data.frame(y, X, cluster, row = 1:n)

# fit linear model
lm_fit &lt;- lm(y ~ X1 + X2 + X3, data = dat)
vcov(lm_fit)

# cluster-robust variance estimator with CR2 small-sample correction
vcovCR(lm_fit, cluster = dat$cluster, type = "CR2")

# compare small-sample adjustments
CR_types &lt;- paste0("CR",c("0","1","1S","2","3"))
sapply(CR_types, function(type) 
       sqrt(diag(vcovCR(lm_fit, cluster = dat$cluster, type = type))))

</code></pre>

<hr>
<h2 id='vcovCR.geeglm'>Cluster-robust variance-covariance matrix for a geeglm object.</h2><span id='topic+vcovCR.geeglm'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from an <code><a href="geepack.html#topic+geeglm">geeglm</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geeglm'
vcovCR(
  obj,
  cluster,
  type,
  target = NULL,
  inverse_var = NULL,
  form = "sandwich",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.geeglm_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.geeglm_+3A_cluster">cluster</code></td>
<td>
<p>Expression or vector indicating which observations belong to
the same cluster. Required for <code>geeglm</code> objects.</p>
</td></tr>
<tr><td><code id="vcovCR.geeglm_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.geeglm_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code>
adjustment matrices. If a vector, the target matrix is assumed to be
diagonal. If not specified, the target is taken to be the estimated variance function.</p>
</td></tr>
<tr><td><code id="vcovCR.geeglm_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.geeglm_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.geeglm_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists
of a matrix of the estimated variance of and covariances between the
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("geepack", quietly = TRUE)) {

  library(geepack)
  data(dietox, package = "geepack")
  dietox$Cu &lt;- as.factor(dietox$Cu)
  mf &lt;- formula(Weight ~ Cu * (Time + I(Time^2) + I(Time^3)))
  gee1 &lt;- geeglm(mf, data=dietox, id=Pig, family=poisson("identity"), corstr="ar1")
  V_CR &lt;- vcovCR(gee1, cluster = dietox$Pig, type = "CR2")
  coef_test(gee1, vcov = V_CR, test = "Satterthwaite")
  
}

</code></pre>

<hr>
<h2 id='vcovCR.glm'>Cluster-robust variance-covariance matrix for a glm object.</h2><span id='topic+vcovCR.glm'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from an <code><a href="stats.html#topic+glm">glm</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
vcovCR(
  obj,
  cluster,
  type,
  target = NULL,
  inverse_var = NULL,
  form = "sandwich",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.glm_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.glm_+3A_cluster">cluster</code></td>
<td>
<p>Expression or vector indicating which observations belong to
the same cluster. Required for <code>glm</code> objects.</p>
</td></tr>
<tr><td><code id="vcovCR.glm_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.glm_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code>
adjustment matrices. If a vector, the target matrix is assumed to be
diagonal. If not specified, the target is taken to be the estimated variance function.</p>
</td></tr>
<tr><td><code id="vcovCR.glm_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.glm_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.glm_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists
of a matrix of the estimated variance of and covariances between the
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("geepack", quietly = TRUE)) {

  data(dietox, package = "geepack")
  dietox$Cu &lt;- as.factor(dietox$Cu)
  weight_fit &lt;- glm(Weight ~ Cu * poly(Time, 3), data=dietox, family = "quasipoisson")
  V_CR &lt;- vcovCR(weight_fit, cluster = dietox$Pig, type = "CR2")
  coef_test(weight_fit, vcov = V_CR, test = "Satterthwaite")
  
}

</code></pre>

<hr>
<h2 id='vcovCR.gls'>Cluster-robust variance-covariance matrix for a gls object.</h2><span id='topic+vcovCR.gls'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from a <code><a href="nlme.html#topic+gls">gls</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
vcovCR(obj, cluster, type, target, inverse_var, form = "sandwich", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.gls_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.gls_+3A_cluster">cluster</code></td>
<td>
<p>Optional expression or vector indicating which observations 
belong to the same cluster. If not specified, will be set to 
<code>getGroups(obj)</code>.</p>
</td></tr>
<tr><td><code id="vcovCR.gls_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.gls_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working 
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code> 
adjustment matrices. If not specified, the target is taken to be the
estimated variance-covariance structure of the <code>gls</code> object.</p>
</td></tr>
<tr><td><code id="vcovCR.gls_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.gls_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.gls_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists 
of a matrix of the estimated variance of and covariances between the 
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("nlme", quietly = TRUE)) {

  library(nlme)
  data(Ovary, package = "nlme")
  Ovary$time_int &lt;- 1:nrow(Ovary)
  lm_AR1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), data = Ovary, 
                correlation = corAR1(form = ~ time_int | Mare))
  vcovCR(lm_AR1, type = "CR2")

}
    
</code></pre>

<hr>
<h2 id='vcovCR.ivreg'>Cluster-robust variance-covariance matrix for an ivreg object.</h2><span id='topic+vcovCR.ivreg'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from an ivreg object fitted
from the <a href="https://CRAN.R-project.org/package=AER"><span class="pkg">AER</span></a> package or the <a href="https://CRAN.R-project.org/package=ivreg"><span class="pkg">ivreg</span></a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivreg'
vcovCR(
  obj,
  cluster,
  type,
  target = NULL,
  inverse_var = FALSE,
  form = "sandwich",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.ivreg_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.ivreg_+3A_cluster">cluster</code></td>
<td>
<p>Expression or vector indicating which observations belong to
the same cluster. Required for <code>ivreg</code> objects.</p>
</td></tr>
<tr><td><code id="vcovCR.ivreg_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.ivreg_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code>
adjustment matrices. If a vector, the target matrix is assumed to be
diagonal. If not specified, the target is taken to be an identity matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.ivreg_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Not used for <code>ivreg</code> objects.</p>
</td></tr>
<tr><td><code id="vcovCR.ivreg_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.ivreg_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any &quot;ivreg&quot; objects fitted via the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> 
function from the <a href="https://CRAN.R-project.org/package=ivreg"><span class="pkg">ivreg</span></a> package, only traditional 2SLS 
regression method (method = &quot;OLS&quot;) is supported.
clubSandwich currently cannot support robust-regression methods such as
M-estimation (method = &quot;M&quot;) or MM-estimation (method = &quot;MM&quot;).
</p>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists
of a matrix of the estimated variance of and covariances between the
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("AER", quietly = TRUE)) withAutoprint({

  library(AER)
  data("CigarettesSW")
  Cigs &lt;- within(CigarettesSW, {
    rprice &lt;- price/cpi
    rincome &lt;- income/population/cpi
    tdiff &lt;- (taxs - tax)/cpi
  })

  iv_fit_AER &lt;- AER::ivreg(log(packs) ~ log(rprice) + log(rincome) | 
                  log(rincome) + tdiff + I(tax/cpi), data = Cigs)
  vcovCR(iv_fit_AER, cluster = Cigs$state, type = "CR2")
  coef_test(iv_fit_AER, vcov = "CR2", cluster = Cigs$state)

})

pkgs_available &lt;- 
  requireNamespace("AER", quietly = TRUE) &amp; 
  requireNamespace("ivreg", quietly = TRUE)

if (pkgs_available) withAutoprint ({

data("CigarettesSW")
  Cigs &lt;- within(CigarettesSW, {
    rprice &lt;- price/cpi
    rincome &lt;- income/population/cpi
    tdiff &lt;- (taxs - tax)/cpi
  })
iv_fit_ivreg &lt;- ivreg::ivreg(log(packs) ~ log(rprice) + log(rincome) | 
                  log(rincome) + tdiff + I(tax/cpi), data = Cigs)
  vcovCR(iv_fit_ivreg, cluster = Cigs$state, type = "CR2")
  coef_test(iv_fit_ivreg, vcov = "CR2", cluster = Cigs$state)
})

</code></pre>

<hr>
<h2 id='vcovCR.lm'>Cluster-robust variance-covariance matrix for an lm object.</h2><span id='topic+vcovCR.lm'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from an <code><a href="stats.html#topic+lm">lm</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
vcovCR(
  obj,
  cluster,
  type,
  target = NULL,
  inverse_var = NULL,
  form = "sandwich",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.lm_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.lm_+3A_cluster">cluster</code></td>
<td>
<p>Expression or vector indicating which observations belong to
the same cluster. Required for <code>lm</code> objects.</p>
</td></tr>
<tr><td><code id="vcovCR.lm_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.lm_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code>
adjustment matrices. If a vector, the target matrix is assumed to be
diagonal. If not specified, the target is taken to be an identity matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.lm_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.lm_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists
of a matrix of the estimated variance of and covariances between the
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("ChickWeight", package = "datasets")
lm_fit &lt;- lm(weight ~ Time + Diet:Time, data = ChickWeight)
vcovCR(lm_fit, cluster = ChickWeight$Chick, type = "CR2")

if (requireNamespace("plm", quietly = TRUE)) withAutoprint({

  data("Produc", package = "plm")
  lm_individual &lt;- lm(log(gsp) ~ 0 + state + log(pcap) + log(pc) + log(emp) + unemp, data = Produc)
  individual_index &lt;- !grepl("state", names(coef(lm_individual)))
  vcovCR(lm_individual, cluster = Produc$state, type = "CR2")[individual_index,individual_index]

  # compare to plm()
  plm_FE &lt;- plm::plm(log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp, 
                     data = Produc, index = c("state","year"), 
                     effect = "individual", model = "within")
  vcovCR(plm_FE, type="CR2")
  
})

</code></pre>

<hr>
<h2 id='vcovCR.lme'>Cluster-robust variance-covariance matrix for an lme object.</h2><span id='topic+vcovCR.lme'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from a <code><a href="nlme.html#topic+lme">lme</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
vcovCR(obj, cluster, type, target, inverse_var, form = "sandwich", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.lme_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.lme_+3A_cluster">cluster</code></td>
<td>
<p>Optional expression or vector indicating which observations 
belong to the same cluster. If not specified, will be set to 
<code>getGroups(obj)</code>.</p>
</td></tr>
<tr><td><code id="vcovCR.lme_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.lme_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working 
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code> 
adjustment matrices. If not specified, the target is taken to be the
estimated variance-covariance structure of the <code>lme</code> object.</p>
</td></tr>
<tr><td><code id="vcovCR.lme_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.lme_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.lme_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists 
of a matrix of the estimated variance of and covariances between the 
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("nlme", quietly = TRUE)) {

  library(nlme)
  rat_weight &lt;- lme(weight ~ Time * Diet, data=BodyWeight, ~ Time | Rat) 
  vcovCR(rat_weight, type = "CR2")

}

pkgs_available &lt;- 
  requireNamespace("nlme", quietly = TRUE) &amp; 
  requireNamespace("mlmRev", quietly = TRUE)

if (pkgs_available) {

  data(egsingle, package = "mlmRev")
  subset_ids &lt;- levels(egsingle$schoolid)[1:10]
  egsingle_subset &lt;- subset(egsingle, schoolid %in% subset_ids)
  
  math_model &lt;- lme(math ~ year * size + female + black + hispanic, 
                    random = list(~ year | schoolid, ~ 1 | childid), 
                    data = egsingle_subset)
                    
  vcovCR(math_model, type = "CR2")
  
}

</code></pre>

<hr>
<h2 id='vcovCR.lmerMod'>Cluster-robust variance-covariance matrix for an lmerMod object.</h2><span id='topic+vcovCR.lmerMod'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from <code><a href="lme4.html#topic+merMod-class">merMod</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerMod'
vcovCR(obj, cluster, type, target, inverse_var, form = "sandwich", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.lmerMod_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.lmerMod_+3A_cluster">cluster</code></td>
<td>
<p>Optional expression or vector indicating which observations 
belong to the same cluster. If not specified, will be set to 
<code>getGroups(obj)</code>.</p>
</td></tr>
<tr><td><code id="vcovCR.lmerMod_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.lmerMod_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working 
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code> 
adjustment matrices. If not specified, the target is taken to be the
estimated variance-covariance structure of the <code>lmerMod</code> object.</p>
</td></tr>
<tr><td><code id="vcovCR.lmerMod_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.lmerMod_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.lmerMod_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists 
of a matrix of the estimated variance of and covariances between the 
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("lme4", quietly = TRUE)) {

library(lme4)
sleep_fit &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
vcovCR(sleep_fit, type = "CR2")

}

pkgs_available &lt;- 
  requireNamespace("lme4", quietly = TRUE) &amp; 
  requireNamespace("mlmRev", quietly = TRUE)

if (pkgs_available) {

data(egsingle, package = "mlmRev")
subset_ids &lt;- levels(egsingle$schoolid)[1:10]
math_model &lt;- lmer(math ~ year * size + female + black + hispanic 
                   + (1 | schoolid) + (1 | childid), 
                   data = egsingle, subset = schoolid %in% subset_ids)
vcovCR(math_model, type = "CR2")
}

</code></pre>

<hr>
<h2 id='vcovCR.mlm'>Cluster-robust variance-covariance matrix for an mlm object.</h2><span id='topic+vcovCR.mlm'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix
of a set of regression coefficient estimates from an <code>mlm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlm'
vcovCR(obj, cluster, type, target, inverse_var, form = "sandwich", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.mlm_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.mlm_+3A_cluster">cluster</code></td>
<td>
<p>Optional expression or vector indicating which observations
belong to the same cluster. If not specified, each row of the data will be
treated as a separate cluster.</p>
</td></tr>
<tr><td><code id="vcovCR.mlm_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.mlm_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code>
adjustment matrices. If not specified, the target is taken to be an
identity matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.mlm_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.mlm_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.mlm_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists
of a matrix of the estimated variance of and covariances between the
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_fit &lt;- lm(cbind(Sepal.Length, Sepal.Width) ~ Species + 
               Petal.Length + Petal.Width, data = iris)
Vcluster &lt;- vcovCR(iris_fit, type = "CR2")
Vcluster

</code></pre>

<hr>
<h2 id='vcovCR.plm'>Cluster-robust variance-covariance matrix for a plm object.</h2><span id='topic+vcovCR.plm'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix
of a set of regression coefficient estimates from a <code><a href="plm.html#topic+plm">plm</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plm'
vcovCR(
  obj,
  cluster,
  type,
  target,
  inverse_var,
  form = "sandwich",
  ignore_FE = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.plm_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.plm_+3A_cluster">cluster</code></td>
<td>
<p>Optional character string, expression, or vector indicating
which observations belong to the same cluster. For fixed-effect models that
include individual effects or time effects (but not both), the cluster will
be taken equal to the included fixed effects if not otherwise specified.
Clustering on individuals can also be obtained by specifying the name of
the individual index (e.g., <code>cluster = "state"</code>) or <code>cluster =
"individual"</code>; clustering on time periods can be obtained by specifying the
name of the time index (e.g., <code>cluster = "year"</code>) or <code>cluster =
"time"</code>; if a group index is specified, clustering on groups (in which
individuals are nested) can be obtained by specifying the name of the group
index or <code>cluster = "group"</code>. For random-effects models, the cluster
will be taken equal to the included random effect identifier if not
otherwise specified.</p>
</td></tr>
<tr><td><code id="vcovCR.plm_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.plm_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code>
adjustment matrices. By default, the target is taken to be an identity
matrix for fixed effect models or the estimated compound-symmetric
covariance matrix for random effects models.</p>
</td></tr>
<tr><td><code id="vcovCR.plm_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.plm_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.plm_+3A_ignore_fe">ignore_FE</code></td>
<td>
<p>Optional logical controlling whether fixed effects are
ignored when calculating small-sample adjustments in models where fixed
effects are estimated through absorption.</p>
</td></tr>
<tr><td><code id="vcovCR.plm_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists
of a matrix of the estimated variance of and covariances between the
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("plm", quietly = TRUE)) withAutoprint({

  library(plm)
  # fixed effects
  data("Produc", package = "plm")
  plm_FE &lt;- plm(log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp,
                data = Produc, index = c("state","year","region"),
                effect = "individual", model = "within")
  vcovCR(plm_FE, type="CR2")
  vcovCR(plm_FE, type = "CR2", cluster = Produc$region) # clustering on region
  
  # random effects
  plm_RE &lt;- update(plm_FE, model = "random")
  vcovCR(plm_RE, type = "CR2")
  vcovCR(plm_RE, type = "CR2", cluster = Produc$region) # clustering on region
  
  # nested random effects
  plm_nested &lt;- update(plm_FE, effect = "nested", model = "random")
  vcovCR(plm_nested, type = "CR2") # clustering on region
})

pkgs_available &lt;- requireNamespace("plm", quietly = TRUE) &amp; requireNamespace("AER", quietly = TRUE)

if (pkgs_available) withAutoprint({
  # first differencing
  data(Fatalities, package = "AER")
  Fatalities &lt;- within(Fatalities, {
    frate &lt;- 10000 * fatal / pop
    drinkagec &lt;- cut(drinkage, breaks = 18:22, include.lowest = TRUE, right = FALSE)
    drinkagec &lt;- relevel(drinkagec, ref = 4)
  })

  plm_FD &lt;- plm(frate ~ beertax + drinkagec + miles + unemp + log(income),
                data = Fatalities, index = c("state", "year"),
                model = "fd")
  vcovHC(plm_FD, method="arellano", type = "sss", cluster = "group")
  vcovCR(plm_FD, type = "CR1S")
  vcovCR(plm_FD, type = "CR2")
  
})

</code></pre>

<hr>
<h2 id='vcovCR.rma.mv'>Cluster-robust variance-covariance matrix for a robu object.</h2><span id='topic+vcovCR.rma.mv'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from a 
<code><a href="metafor.html#topic+rma.mv">rma.mv</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rma.mv'
vcovCR(obj, cluster, type, target, inverse_var, form = "sandwich", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.rma.mv_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.rma.mv_+3A_cluster">cluster</code></td>
<td>
<p>Optional expression or vector indicating which observations 
belong to the same cluster. If not specified, will be set to the factor in
the random-effects structure with the fewest distinct levels. Caveat
emptor: the function does not check that the random effects are nested.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.mv_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.mv_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working 
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code> 
adjustment matrices. If not specified, the target is taken to be the 
estimated variance-covariance structure of the <code>rma.mv</code> object.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.mv_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.mv_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.mv_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists 
of a matrix of the estimated variance of and covariances between the 
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pkgs_available &lt;- 
  requireNamespace("metafor", quietly = TRUE) &amp; 
  requireNamespace("metadat", quietly = TRUE)

if (pkgs_available) withAutoprint({

library(metafor)
data(dat.assink2016, package = "metadat")

mfor_fit &lt;- rma.mv(yi ~ year + deltype, 
                 V = vi, random = ~ 1 | study / esid,
                 data = dat.assink2016)
mfor_fit

mfor_CR2 &lt;- vcovCR(mfor_fit, type = "CR2")
mfor_CR2

coef_test(mfor_fit, vcov = mfor_CR2, test = c("Satterthwaite", "saddlepoint"))
Wald_test(mfor_fit, constraints = constrain_zero(3:4), vcov = mfor_CR2)

})

</code></pre>

<hr>
<h2 id='vcovCR.rma.uni'>Cluster-robust variance-covariance matrix for a rma.uni object.</h2><span id='topic+vcovCR.rma.uni'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from a 
<code><a href="metafor.html#topic+rma.uni">rma.uni</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rma.uni'
vcovCR(obj, cluster, type, target, inverse_var, form = "sandwich", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.rma.uni_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.rma.uni_+3A_cluster">cluster</code></td>
<td>
<p>Expression or vector indicating which observations 
belong to the same cluster. Required for <code>rma.uni</code> objects.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.uni_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.uni_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working 
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code> 
adjustment matrices. If not specified, the target is taken to be diagonal
with entries equal to the estimated marginal variance of the effect sizes.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.uni_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.uni_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.rma.uni_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists 
of a matrix of the estimated variance of and covariances between the 
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pkgs_available &lt;- 
  requireNamespace("metafor", quietly = TRUE) &amp; 
  requireNamespace("metadat", quietly = TRUE)
  
if (pkgs_available) withAutoprint({

library(metafor)
data(dat.assink2016, package = "metadat")

mfor_fit &lt;- rma.uni(yi ~ year + deltype, vi = vi, 
                 data = dat.assink2016)
mfor_fit

mfor_CR2 &lt;- vcovCR(mfor_fit, type = "CR2", cluster = dat.assink2016$study)
mfor_CR2
coef_test(mfor_fit, vcov = mfor_CR2, test = c("Satterthwaite", "saddlepoint"))
Wald_test(mfor_fit, constraints = constrain_zero(2:4), vcov = mfor_CR2)

})

</code></pre>

<hr>
<h2 id='vcovCR.robu'>Cluster-robust variance-covariance matrix for a robu object.</h2><span id='topic+vcovCR.robu'></span>

<h3>Description</h3>

<p><code>vcovCR</code> returns a sandwich estimate of the variance-covariance matrix 
of a set of regression coefficient estimates from a
<code><a href="robumeta.html#topic+robu">robu</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robu'
vcovCR(obj, cluster, type, target, inverse_var, form = "sandwich", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCR.robu_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="vcovCR.robu_+3A_cluster">cluster</code></td>
<td>
<p>Optional expression or vector indicating which observations 
belong to the same cluster. If not specified, will be set to the
<code>studynum</code> used in fitting the <code><a href="robumeta.html#topic+robu">robu</a></code> object.</p>
</td></tr>
<tr><td><code id="vcovCR.robu_+3A_type">type</code></td>
<td>
<p>Character string specifying which small-sample adjustment should 
be used, with available options <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, or <code>"CR3"</code>. See &quot;Details&quot; section of 
<code><a href="#topic+vcovCR">vcovCR</a></code> for further information.</p>
</td></tr>
<tr><td><code id="vcovCR.robu_+3A_target">target</code></td>
<td>
<p>Optional matrix or vector describing the working 
variance-covariance model used to calculate the <code>CR2</code> and <code>CR4</code> 
adjustment matrices. If not specified, the target is taken to be the 
inverse of the estimated weights used in fitting the
<code><a href="robumeta.html#topic+robu">robu</a></code> object.</p>
</td></tr>
<tr><td><code id="vcovCR.robu_+3A_inverse_var">inverse_var</code></td>
<td>
<p>Optional logical indicating whether the weights used in 
fitting the model are inverse-variance. If not specified, <code>vcovCR</code> 
will attempt to infer a value.</p>
</td></tr>
<tr><td><code id="vcovCR.robu_+3A_form">form</code></td>
<td>
<p>Controls the form of the returned matrix. The default 
<code>"sandwich"</code> will return the sandwich variance-covariance matrix. 
Alternately, setting <code>form = "meat"</code> will return only the meat of the 
sandwich and setting <code>form = B</code>, where <code>B</code> is a matrix of 
appropriate dimension, will return the sandwich variance-covariance matrix 
calculated using <code>B</code> as the bread. <code>form = "estfun"</code> will return the 
(appropriately scaled) estimating function, the transposed crossproduct of 
which is equal to the sandwich variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="vcovCR.robu_+3A_...">...</code></td>
<td>
<p>Additional arguments available for some classes of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("vcovCR","clubSandwich")</code>, which consists 
of a matrix of the estimated variance of and covariances between the 
regression coefficient estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("robumeta", quietly = TRUE)) withAutoprint({
library(robumeta)
data(hierdat)

robu_fit &lt;- robu(effectsize ~ binge + followup + sreport + age, 
                 data = hierdat, studynum = studyid, 
                 var.eff.size = var, modelweights = "HIER")
robu_fit

robu_CR2 &lt;- vcovCR(robu_fit, type = "CR2")
robu_CR2
coef_test(robu_fit, vcov = robu_CR2, test = c("Satterthwaite", "saddlepoint"))

Wald_test(robu_fit, constraints = constrain_zero(c(2,4)), vcov = robu_CR2)
Wald_test(robu_fit, constraints = constrain_zero(2:5), vcov = robu_CR2)

})

</code></pre>

<hr>
<h2 id='Wald_test'>Test parameter constraints in a fitted linear regression model</h2><span id='topic+Wald_test'></span>

<h3>Description</h3>

<p><code>Wald_test</code> reports Wald-type tests of linear contrasts from a fitted
linear regression model, using a sandwich estimator for the
variance-covariance matrix and a small sample correction for the p-value.
Several different small-sample corrections are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wald_test(obj, constraints, vcov, test = "HTZ", tidy = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wald_test_+3A_obj">obj</code></td>
<td>
<p>Fitted model for which to calculate Wald tests.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_constraints">constraints</code></td>
<td>
<p>List of one or more constraints to test. See details and
examples.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_vcov">vcov</code></td>
<td>
<p>Variance covariance matrix estimated using <code>vcovCR</code> or a
character string specifying which small-sample adjustment should be used to
calculate the variance-covariance.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_test">test</code></td>
<td>
<p>Character vector specifying which small-sample correction(s) to
calculate. The following corrections are available: <code>"chi-sq"</code>,
<code>"Naive-F"</code>, <code>"Naive-Fp"</code>, <code>"HTA"</code>, <code>"HTB"</code>, <code>"HTZ"</code>, <code>"EDF"</code>,
<code>"EDT"</code>. Default is <code>"HTZ"</code>.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_tidy">tidy</code></td>
<td>
<p>Logical value controlling whether to tidy the test results. If
<code>constraints</code> is a list with multiple constraints, the result will
be coerced into a data frame when <code>tidy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+vcovCR">vcovCR</a></code>, which are only
needed if <code>vcov</code> is a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constraints can be specified directly as q X p matrices or
indirectly through <code><a href="#topic+constrain_equal">constrain_equal</a></code>,
<code><a href="#topic+constrain_zero">constrain_zero</a></code>, or <code><a href="#topic+constrain_pairwise">constrain_pairwise</a></code>
</p>


<h3>Value</h3>

<p>A list of test results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCR">vcovCR</a></code>, <code><a href="#topic+constrain_equal">constrain_equal</a></code>,
<code><a href="#topic+constrain_zero">constrain_zero</a></code>, <code><a href="#topic+constrain_pairwise">constrain_pairwise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("carData", quietly = TRUE)) withAutoprint({

data(Duncan, package = "carData")
Duncan$cluster &lt;- sample(LETTERS[1:8], size = nrow(Duncan), replace = TRUE)

Duncan_fit &lt;- lm(prestige ~ 0 + type + income + type:income + type:education, data=Duncan)
# Note that type:income terms are interactions because main effect of income is included
# but type:education terms are separate slopes for each unique level of type

# Test equality of intercepts
Wald_test(Duncan_fit,
          constraints = constrain_equal(1:3),
          vcov = "CR2", cluster = Duncan$cluster)

# Test equality of type-by-education slopes
Wald_test(Duncan_fit,
          constraints = constrain_equal(":education", reg_ex = TRUE),
          vcov = "CR2", cluster = Duncan$cluster)

# Pairwise comparisons of type-by-education slopes
Wald_test(Duncan_fit,
          constraints = constrain_pairwise(":education", reg_ex = TRUE),
          vcov = "CR2", cluster = Duncan$cluster)

# Test type-by-income interactions
Wald_test(Duncan_fit,
          constraints = constrain_zero(":income", reg_ex = TRUE),
          vcov = "CR2", cluster = Duncan$cluster)

# Pairwise comparisons of type-by-income interactions
Wald_test(Duncan_fit,
          constraints = constrain_pairwise(":income", reg_ex = TRUE, with_zero = TRUE),
          vcov = "CR2", cluster = Duncan$cluster)
          
})

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
