<!DOCTYPE html><html lang="en"><head><title>Help for package whitening</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {whitening}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#whitening-package'><p>The whitening Package</p></a></li>
<li><a href='#corplot'><p>Plots of Correlations and Loadings</p></a></li>
<li><a href='#explainedVariation'><p>Compute Explained Variation from Loadings</p></a></li>
<li><a href='#forina1986'><p>Forina 1986 Wine Data - Extended UCI Wine Data</p></a></li>
<li><a href='#lusc'><p>TCGA LUSC Data</p></a></li>
<li><a href='#nutrimouse'><p>Nutrimouse Data</p></a></li>
<li><a href='#pitprops14'><p>Pitprops Correlation Data for 14 Variables</p></a></li>
<li><a href='#scca'><p>Perform Canonical Correlation Analysis</p></a></li>
<li><a href='#simOrtho'><p>Simulate Random Orthogonal Matrix</p></a></li>
<li><a href='#whiten'><p>Whiten Data Matrix</p></a></li>
<li><a href='#whitening-internal'><p>Internal whitening Functions</p></a></li>
<li><a href='#whiteningLoadings'><p>Compute Whitening Loadings</p></a></li>
<li><a href='#whiteningMatrix'><p>Compute Whitening Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Whitening and High-Dimensional Canonical Correlation Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Korbinian Strimmer, Takoua Jendoubi, Agnan Kessy, Alex Lewin</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Korbinian Strimmer &lt;strimmerlab@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), corpcor (&ge; 1.6.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the whitening methods (ZCA, PCA, Cholesky,
 ZCA-cor, and PCA-cor) discussed in Kessy, Lewin, and Strimmer (2018)
 "Optimal whitening and decorrelation", &lt;<a href="https://doi.org/10.1080%2F00031305.2016.1277159">doi:10.1080/00031305.2016.1277159</a>&gt;,
 as well as the whitening approach to canonical correlation analysis allowing
 negative canonical correlations described in Jendoubi and Strimmer (2019)
 "A whitening approach to probabilistic canonical correlation analysis for omics
 data integration", &lt;<a href="https://doi.org/10.1186%2Fs12859-018-2572-9">doi:10.1186/s12859-018-2572-9</a>&gt;. The package also offers
 functions to simulate random orthogonal matrices, compute (correlation) loadings
 and explained variation. It also contains four example data sets (extended UCI 
 wine data, TCGA LUSC data, nutrimouse data, extended pitprops data).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://strimmerlab.github.io/software/whitening/">https://strimmerlab.github.io/software/whitening/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-07 10:17:28 UTC; strimmer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-07 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='whitening-package'>The whitening Package</h2><span id='topic+whitening-package'></span>

<h3>Description</h3>

<p>The &quot;whitening&quot; package implements the whitening methods (ZCA, PCA, Cholesky,
ZCA-cor, and PCA-cor) discussed in Kessy, Lewin, and Strimmer (2018)
as well as the whitening approach to canonical correlation analysis allowing negative canonical correlations described in Jendoubi and Strimmer (2019).
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io/">https://strimmerlab.github.io/</a>) with Takoua Jendoubi, Agnan Kessy, and Alex Lewin.
</p>


<h3>References</h3>

<p>Kessy, A., A. Lewin, and K. Strimmer. 2018.
Optimal whitening and decorrelation. The American Statistician. 72: 309-314.
&lt;DOI:10.1080/00031305.2016.1277159&gt;
</p>
<p>Jendoubi, T., and K. Strimmer 2019. A whitening approach to probabilistic canonical correlation analysis for omics data integration. 
BMC Bioinformatics 20: 15.
&lt;DOI:10.1186/s12859-018-2572-9&gt;
</p>
<p>Website: <a href="https://strimmerlab.github.io/software/whitening/">https://strimmerlab.github.io/software/whitening/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteningMatrix">whiteningMatrix</a></code>,
<code><a href="#topic+whiten">whiten</a></code>,
<code><a href="#topic+whiteningLoadings">whiteningLoadings</a></code>,
<code><a href="#topic+explainedVariation">explainedVariation</a></code>,
<code><a href="#topic+cca">cca</a></code>, and
<code><a href="#topic+scca">scca</a></code>.
</p>

<hr>
<h2 id='corplot'>Plots of Correlations and Loadings</h2><span id='topic+corplot'></span><span id='topic+loadplot'></span>

<h3>Description</h3>

<p><code>corplot</code> computes the correlation within and between <code>X</code> and <code>Y</code>
and displays the three corresponding matrices visusally.
</p>
<p><code>loadplot</code> computes the squared loadings for <code>X</code> and <code>Y</code> and plots the
resulting matrices.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corplot(cca.out, X, Y)
loadplot(cca.out, numScores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corplot_+3A_cca.out">cca.out</code></td>
<td>
<p>output from the <code><a href="#topic+scca">scca</a></code> or <code><a href="#topic+cca">cca</a></code> function.</p>
</td></tr>
<tr><td><code id="corplot_+3A_x">X</code>, <code id="corplot_+3A_y">Y</code></td>
<td>
<p>input data matrices.</p>
</td></tr>
<tr><td><code id="corplot_+3A_numscores">numScores</code></td>
<td>
<p>number of CCA scores shown in plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>
<p>Part of the plot code was adapted from the <code>img.matcor</code> function 
in the <code>CCA</code> package and from the <code>image.plot</code> function in the <code>fields</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scca">scca</a></code>.</p>

<hr>
<h2 id='explainedVariation'>Compute Explained Variation from Loadings</h2><span id='topic+explainedVariation'></span>

<h3>Description</h3>

<p><code>explainedVariation</code> computes the explained variation for each whitened variables from the loadings (both covariance loadings and correlation loadings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  explainedVariation(Phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explainedVariation_+3A_phi">Phi</code></td>
<td>
<p>Loading matrix (with columns referring to whitened variables).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>explainedVariation</code> computes for each column of
the loading matrix the sum of squares of the elements in that column.
</p>


<h3>Value</h3>

<p><code>explainedVariation</code> returns a vector with the explained variation contributed by each whitened variable.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Kessy, A., A. Lewin, and K. Strimmer. 2018.
Optimal whitening and decorrelation. The American Statistician. 72: 309-314.
&lt;DOI:10.1080/00031305.2016.1277159&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteningLoadings">whiteningLoadings</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

######

# example data set
# E. Anderson. 1935.  The irises of the Gaspe Peninsula.
# Bull. Am. Iris Soc. 59: 2--5
data("iris")
X = as.matrix(iris[,1:4])
d = ncol(X) # 4
n = nrow(X) # 150
colnames(X) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"

# estimate covariance
S = cov(X)

# PCA-cor loadings
ldgs = whiteningLoadings(S, method="PCA-cor")

# Explained variation from correlation loadings
explainedVariation( ldgs$Psi )


</code></pre>

<hr>
<h2 id='forina1986'>Forina 1986 Wine Data - Extended UCI Wine Data</h2><span id='topic+forina1986'></span>

<h3>Description</h3>

<p>The <code>forina1986</code> dataset describes 27 properties of 178 samples of wine from three 
grape varieties (59 Barolo, 71 Grignolino, 48 Barbera) as reported in Forina et al. (1986).   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(forina1986)
</code></pre>


<h3>Format</h3>

<p>A list containing the following components:
</p>
<p><code>attribs</code>  collects measurements for 27 attributes of 178 wine samples.
</p>
<p><code>type</code> describes the variety (&quot;Barolo&quot;, &quot;Grignolino&quot;, or &quot;Barbera&quot;).
</p>


<h3>Details</h3>

<p>This data set contains the full set of covariates described in Forina et al. (1986) 
except for Sulphate (variable 15 in Forina et al. 1986). These are:
1) Alcohol,
2) Sugar-free extract,
3) Fixed acidity,
4) Tartaric acid,
5) Malic acid,
6) Uronic acids,
7) pH,
8) Ash,
9) Alcalinity of ash,
10) Potassium,
11) Calcium,
12) Magnesium,
13) Phosphate,
14) Chloride,
15) Total phenols,
16) Flavanoids,
17) Nonflavanoid phenols,
18) Proanthocyanins,
19) Color intensity,
20) Hue,
21) OD280/OD315 of diluted wines,
22) OD280/OD315 of flavonoids,
23) Glycerol,
24) 2-3-butanediol,
25) Total nitrogen,
26) Proline,
and 27) Methanol.
</p>
<p>The UCI wine data set (<a href="https://archive.ics.uci.edu/ml/datasets/wine">https://archive.ics.uci.edu/ml/datasets/wine</a>) 
is a subset of the Forina et al. (1986) data set comprising only 13 variables.
</p>


<h3>Source</h3>

<p>The original data matrix is available from 
<a href="https://www.researchgate.net/publication/271908647_Wines_MForina_CArmanino_MCastino_MUbigli_Multivariate_data_analysis_as_discriminating_method_of_the_origin_of_wines_Vitis_25_189-201_1986">https://www.researchgate.net/publication/271908647_Wines_MForina_CArmanino_MCastino_MUbigli_Multivariate_data_analysis_as_discriminating_method_of_the_origin_of_wines_Vitis_25_189-201_1986</a>.
</p>


<h3>References</h3>

<p>Forina, M., Armanino, C., Castino, M., and Ubigli, M.
Multivariate data analysis as a discriminating method of the
origin of wines. Vitis 25:189-201 (1986). <a href="https://ojs.openagrar.de/index.php/VITIS/article/view/5950">https://ojs.openagrar.de/index.php/VITIS/article/view/5950</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

# load Forina 1986 wine data set
data(forina1986)

table(forina1986$type)
#    Barolo Grignolino    Barbera 
#        59         71         48

dim(forina1986$attrib)
# 178  27

colnames(forina1986$attrib)
# [1] "Alcohol"                      "Sugar-free extract"          
# [3] "Fixed acidity"                "Tartaric acid"               
# [5] "Malic acid"                   "Uronic acids"                
# [7] "pH"                           "Ash"                         
# [9] "Alkalinity of ash"            "Potassium"                   
#[11] "Calcium"                      "Magnesium"                   
#[13] "Phosphate"                    "Chloride"                    
#[15] "Total phenols"                "Flavanoids"                  
#[17] "Nonflavanoid phenols"         "Proanthocyanins"             
#[19] "Color intensity"              "Hue"                         
#[21] "OD280/OD315 of diluted wines" "OD280/OD315 of flavonoids"   
#[23] "Glycerol"                     "2-3-butanediol"              
#[25] "Total nitrogen"               "Proline"                     
#[27] "Methanol"  

# PCA-cor whitened data
Z = whiten(forina1986$attrib, method="PCA-cor") 

wt = as.integer(forina1986$type)
plot(Z[,1], Z[,2], xlab=expression(paste(Z[1])), ylab=expression(paste(Z[2])), 
  main="Forina 1986 Wine Data", sub="PCA-cor Whitening", col=wt, pch=wt+14)
legend("topright", levels(forina1986$type)[1:3], col=1:3, pch=(1:3)+14 )



## relationship to UCI wine data

# UCI wine data is a subset
uciwine.attrib = forina1986$attrib[, c("Alcohol", "Malic acid", "Ash", 
  "Alcalinity of ash", "Magnesium", "Total phenols", "Flavanoids", 
  "Nonflavanoid phenols", "Proanthocyanins", "Color intensity", "Hue", 
  "OD280/OD315 of diluted wines", "Proline")]

# two small differences compared to UCI wine data matrix
uciwine.attrib[172,"Color intensity"]  # 9.9 but 9.899999 in UCI matrix
uciwine.attrib[71,"Hue"] # 0.91 but 0.906 in UCI matrix
</code></pre>

<hr>
<h2 id='lusc'>TCGA LUSC Data</h2><span id='topic+lusc'></span>

<h3>Description</h3>

<p>A preprocessed sample of gene expression and methylation data as well as selected clinical covariates for 130 patients with lung squamous cell carcinoma (LUSC) as available from The Cancer Genome Atlas (TCGA) database (Kandoth et al. 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lusc)
</code></pre>


<h3>Format</h3>

<p><code>lusc$rnaseq2</code> is a 130 x 206 matrix containing the calibrated gene expression 
levels of 206 genes for 130 patients.
</p>
<p><code>lusc$methyl</code> is a 130 x 234 matrix containing the methylation levels
of 234 probes for 130 patients.
</p>
<p><code>sex</code> is a vector recording the sex (male vs. female) of the 130 patients.
</p>
<p><code>packs</code> is the number of cigarette packs per year smoked by each patient.
</p>
<p><code>survivalTime</code> is number of days to last follow-up or the days to death.
</p>
<p><code>censoringStatus</code> is the vital status (0=alive, 1=dead).
</p>


<h3>Details</h3>

<p>This data set is used to illustrate CCA-based data integration
in Jendoubi and Strimmer (2019) and also described in Wan et al. (2016).
</p>


<h3>Source</h3>

<p>The data were retrieved from TCGA (Kandoth et al. 2014) using the TCGA2STAT tool following the guidelines and the preprocessing steps detailed in Wan et al. (2016).
</p>


<h3>References</h3>

<p>Jendoubi, T., Strimmer, K.: A whitening approach to probabilistic canonical correlation analysis for omics data integration. BMC Bioinformatics 20:15 
&lt;DOI:10.1186/s12859-018-2572-9&gt;
</p>
<p>Kandoth, C., McLellan, M.D., Vandin, F., Ye, K., Niu, B., Lu, C., Xie, M., andJ. F. McMichael, Q.Z., Wyczalkowski, M.A., Leiserson, M.D.M., Miller, C.A., Welch, J.S., Walter, M.J., Wendl, M.C., Ley, T.J., Wilson, R.K., Raphael, B.J., Ding, L.: Mutational landscape and significance across 12 major cancer types.
Nature 502, 333&ndash;339 (2013). &lt;DOI:10.1038/nature12634&gt;
</p>
<p>Wan, Y.-W., Allen, G.I., Liu, Z.: TCGA2STAT: simple TCGA data access for integrated statistical analysis in R. Bioinformatics 32, 952&ndash;954 (2016). &lt;DOI:10.1093/bioinformatics/btv677&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

# load TGCA LUSC data set
data(lusc)

names(lusc)
#"rnaseq2"         "methyl"          "sex"             "packs"          
#"survivalTime"    "censoringStatus" 

dim(lusc$rnaseq2) # 130 206 gene expression
dim(lusc$methyl)  # 130 234 methylation level

## Not run: 
library("survival")
s = Surv(lusc$survivalTime, lusc$censoringStatus)
plot(survfit(s ~ lusc$sex), xlab = "Years", ylab = "Probability of survival", lty=c(2,1), lwd=2)
legend("topright", legend = c("male", "female"), lty =c(1,2), lwd=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='nutrimouse'>Nutrimouse Data</h2><span id='topic+nutrimouse'></span>

<h3>Description</h3>

<p>The <code>nutrimouse</code> dataset is a collection of gene expression and lipid measurements 
collected in a nutrigenomic study in the mouse studying 40 animals by Martin et al. (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nutrimouse)
</code></pre>


<h3>Format</h3>

<p>A list containing the following components:
</p>
<p><code>gene</code>  collects gene expression of 120 genes in liver tissue for 40 mice.
</p>
<p><code>lipid</code> collects concentrations of 21 lipids for 40 mice.
</p>
<p><code>diet</code> describes the diet of each mouse (&quot;coc&quot;, &quot;fish&quot;, &quot;lin&quot;, &quot;ref&quot;, or  &quot;sun&quot;).
</p>
<p><code>genotype</code> describes the genotype of each mouse: wild type (&quot;wt&quot;) or PPARalpha deficient (&quot;ppar&quot;).
</p>


<h3>Details</h3>

<p>This data set is used to illustrate CCA-based data integration
in Jendoubi and Strimmer (2019) and is also described in Gonzalez et al. (2008).
</p>


<h3>Source</h3>

<p>The original data are available in the <code>CCA</code> package by Gonzalez et al. (2008), see their function <code>nutrimouse</code>.
</p>


<h3>References</h3>

<p>Gonzalez, I., Dejean, S., Martin, P.G.P,  Baccini, A.
CCA: an R package to extend canonical correlation analysis. J. Statist. Software 23:1&ndash;13 (2008)
</p>
<p>Jendoubi, T., Strimmer, K.: A whitening approach to probabilistic canonical correlation analysis for omics data integration. BMC Bioinformatics 20:15 
&lt;DOI:10.1186/s12859-018-2572-9&gt;
</p>
<p>Martin, P.G.P., Guillou, H., Lasserre, F., Dejean, S., Lan, A., Pascussi, J.-M., Cristobal, M.S., Legrand, P., Besse, P., Pineau, T.: Novel aspects of PPARalpha-mediated regulation of lipid and xenobiotic metabolism revealed
through a multigenomic study. Hepatology 54, 767&ndash;777 (2007)
&lt;DOI:10.1002/hep.21510&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

# load nutrimouse data set
data(nutrimouse)

dim(nutrimouse$gene) # 40 120
dim(nutrimouse$lipid) # 40 21
levels( nutrimouse$diet ) #  "coc"  "fish" "lin"  "ref"  "sun"
levels( nutrimouse$genotype ) # "wt"   "ppar"
</code></pre>

<hr>
<h2 id='pitprops14'>Pitprops Correlation Data for 14 Variables</h2><span id='topic+pitprops14'></span>

<h3>Description</h3>

<p>Pit prop timber is used in construction to build mining tunnels. 
The <code>pitprops14</code> data is described in Jeffers (1967) and is
a correlation matrix that was calculated from measuring 14 physical properties
of 180 pit props made from wood from Corsican pines grown in East Anglia, UK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pitprops14)
</code></pre>


<h3>Format</h3>

<p>A correlation matrix of dimension 14 times 14.
</p>


<h3>Details</h3>

<p>The 14 variables are described in Jeffers (1967) as follows:
</p>
<p><code>topdiam</code>: the top diameter of the prop in inches;
<code>length</code>: the length of the prop in inches;
<code>moist</code>: the moisture content of the prop, expressed as a percentage of the dry weight;
<code>testsg</code>: the specific gravity of the timber at the time of the test;
<code>ovensg</code>: the oven-dry specific gravity of the timber;
<code>rinotop</code>: the number of annual rings at the top of the prop;
<code>ringbut</code>: the number of annual rings at the base of the prop;
<code>bowmax</code>: the maximum bow in inches;
<code>bowdist</code>: the distance of the point of maximum bow from the top of the prop in inches;
<code>whorls</code>: the number of knot whorls;
<code>clear</code>: the length of clear prop from the top of the prop in inches;
<code>knots</code>: the average number of knots per whorl;
<code>diaknot</code>: the average diameter of the knots in inches;
<code>maxcs</code>: the maximum compressive strength in lb per square inch.
</p>


<h3>Source</h3>

<p>The data set is printed in Jeffers (1967) in Table 2 and Table 5.
</p>


<h3>References</h3>

<p>Jeffers, J. N. R. 1967. Two case studies in the application of principal component analysis.    
JRSS C (Applied Statistics) 16: 225-236. &lt;DOI:10.2307/2985919&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

# load pitprops14 data set
data(pitprops14)
colnames(pitprops14)

# correlation matrix for the first 13 variables
pitprops13 = pitprops14[1:13, 1:13]

# correlation loadings for PCA whitening
Psi = whiteningLoadings(pitprops13, "PCA")$Psi

# corresponding explained variation
Psi.explained = explainedVariation(Psi)

# the first six whitened variables account for 87% of the variation
cumsum(Psi.explained)/13*100

</code></pre>

<hr>
<h2 id='scca'>Perform Canonical Correlation Analysis</h2><span id='topic+scca'></span><span id='topic+cca'></span>

<h3>Description</h3>

<p><code>scca</code> computes canonical correlations and directions using a shrinkage estimate of the joint 
correlation matrix of <code class="reqn">X</code> and <code class="reqn">Y</code>.
</p>
<p><code>cca</code>  computes canonical correlations and directions based on empirical correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scca(X, Y, lambda.cor, scale=TRUE, verbose=TRUE)
cca(X, Y, scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scca_+3A_x">X</code></td>
<td>
<p>First data matrix, with samples in rows and variables in columns.</p>
</td></tr>  
<tr><td><code id="scca_+3A_y">Y</code></td>
<td>
<p>Second data matrix, with samples in rows and variables in columns.</p>
</td></tr>  
<tr><td><code id="scca_+3A_lambda.cor">lambda.cor</code></td>
<td>
<p>Shrinkage intensity for estimating the joint correlation matrix - 
see <code><a href="corpcor.html#topic+cor.shrink">cor.shrink</a></code>. 
If not specified this will be estimated from the data.</p>
</td></tr>
<tr><td><code id="scca_+3A_scale">scale</code></td>
<td>
<p>Determines whether canonical directions are computed for standardized or raw data.
Note that if data are not standardized the canonical directions contain the scale
of the variables.</p>
</td></tr>
<tr><td><code id="scca_+3A_verbose">verbose</code></td>
<td>
<p>Report shrinkage intensities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The canonical directions in this function are scaled in such a way that they correspond to whitening matrices - see Jendoubi and Strimmer (2019) for details. Note that the sign convention for the canonical directions employed here  allows purposely for both positive and negative canonical correlations.
</p>
<p>The function <code>scca</code> uses some clever matrix algebra to avoid computation of full correlation matrices, and hence can be applied to high-dimensional data sets - see Jendoubi and Strimmer (2019) for details.
</p>
<p><code>cca</code> it is a shortcut for running <code>scca</code> with <code>lambda.cor=0</code> and <code>verbose=FALSE</code>.
</p>
<p>If <code>scale=FALSE</code> the standard deviations needed for the canonical directions are estimated 
by  <code>apply(X, 2, sd)</code> and <code>apply(X, 2, sd)</code>.
</p>
<p>If <code class="reqn">X</code> or <code class="reqn">Y</code> contains only a single variable the correlation-adjusted cross-correlations <code class="reqn">K</code> reduce to the CAR score (see function <code>carscore</code> in the <code>care</code> package) described in Strimmer and Zuber (2011).
</p>


<h3>Value</h3>

<p><code>scca</code> and <code>cca</code> return a list with the following components:
</p>
<p><code>K</code> - the correlation-adjusted cross-correlations.
</p>
<p><code>lambda</code> - the canonical correlations. 
</p>
<p><code>WX</code> and <code>WY</code> - the whitening matrices for  <code class="reqn">X</code> and <code class="reqn">Y</code>, with canonical directions in the rows. If <code>scale=FALSE</code> then canonical directions include scale of the data, if <code>scale=TRUE</code> then only correlations are needed to compute the canonical directions.
</p>
<p><code>PhiX</code> and <code>PhiY</code> - the loadings for <code class="reqn">X</code> and <code class="reqn">Y</code>. If <code>scale=TRUE</code> then these are the correlation loadings, i.e. the correlations between
the whitened variables and the original variables.
</p>
<p><code>scale</code> - whether data was standardized (if <code>scale=FALSE</code> then canonical directions include scale of the data).
</p>
<p><code>lambda.cor</code> - shrinkage intensity used for estimating the correlations (0 for empirical estimator)
</p>
<p><code>lambda.cor.estimated</code> - indicates whether shrinkage intenstiy was specified or estimated.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>) with Takoua Jendoubi.
</p>


<h3>References</h3>

<p>Jendoubi, T., and K. Strimmer 2019. A whitening approach to probabilistic canonical correlation analysis for omics data integration. 
BMC Bioinformatics 20: 15.
&lt;DOI:10.1186/s12859-018-2572-9&gt;
</p>
<p>Zuber, V., and K. Strimmer. 2011.  High-dimensional regression and 
variable selection using CAR scores.  Statist. Appl. Genet. Mol. Biol. 10: 34.
&lt;DOI:10.2202/1544-6115.1730&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cancor">cancor</a></code> and <code><a href="#topic+whiteningMatrix">whiteningMatrix</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

# example data set
data(LifeCycleSavings)
X = as.matrix( LifeCycleSavings[, 2:3] )
Y = as.matrix( LifeCycleSavings[, -(2:3)] )
n = nrow(X)
colnames(X) # "pop15" "pop75"
colnames(Y) # "sr"   "dpi"  "ddpi" 

# CCA

cca.out = cca(X, Y, scale=TRUE)
cca.out$lambda  # canonical correlations
cca.out$WX      # whitening matrix / canonical directions X
cca.out$WY      # whitening matrix / canonical directions Y
cca.out$K       # correlation-adjusted cross-correlations
cca.out$PhiX    # correlation loadings X
cca.out$PhiX    # correlation loadings Y

corplot(cca.out, X, Y)
loadplot(cca.out, 2)
# column sums of squared correlation loadings add to 1
colSums(cca.out$PhiX^2) 

# CCA whitened data
CCAX = tcrossprod( scale(X), cca.out$WX )
CCAY = tcrossprod( scale(Y), cca.out$WY )
zapsmall(cov(CCAX))
zapsmall(cov(CCAY))
zapsmall(cov(CCAX,CCAY)) # canonical correlations


# compare with built-in function cancor 
# note different signs in correlations and directions!
cancor.out = cancor(scale(X), scale(Y))
cancor.out$cor                  # canonical correlations
t(cancor.out$xcoef)*sqrt(n-1)   # canonical directions X
t(cancor.out$ycoef)*sqrt(n-1)   # canonical directions Y


## see "User guides, package vignettes and other documentation"
## for examples with high-dimensional data using the scca function


</code></pre>

<hr>
<h2 id='simOrtho'>Simulate Random Orthogonal Matrix</h2><span id='topic+simOrtho'></span>

<h3>Description</h3>

<p><code>simOrtho</code> generates a random orthogonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simOrtho(d, nonNegDiag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simOrtho_+3A_d">d</code></td>
<td>
<p>The dimension of the orthogonal matrix.</p>
</td></tr> 
<tr><td><code id="simOrtho_+3A_nonnegdiag">nonNegDiag</code></td>
<td>
<p>force the elements on the diagonal to be nonnegative (default: FALSE).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The algorithm is based on QR decomposition of a random matrix, see Section 3 page 404 in Stewart (1980).
</p>


<h3>Value</h3>

<p><code>simOrtho</code> returns a real matrix of size <code class="reqn">d</code> times <code class="reqn">d</code>.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>G.W. Stewart. 1980. The efficient generation of random orthogonal matrices with an application to condition estimators. SIAM J. Numer. Anal.  17:403-409. &lt;DOI:10.1137/0717034&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteningMatrix">whiteningMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

# simulate random orthogonal matrix
Q = simOrtho(4) # matrix of dimension 4x4
Q

zapsmall( crossprod(Q) )
zapsmall( tcrossprod(Q) )


</code></pre>

<hr>
<h2 id='whiten'>Whiten Data Matrix</h2><span id='topic+whiten'></span>

<h3>Description</h3>

<p><code>whiten</code> whitens a data matrix <code class="reqn">X</code> using the empirical covariance matrix <code class="reqn">cov(X)</code> as basis for computing the whitening transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  whiten(X, center=FALSE, method=c("ZCA", "ZCA-cor", "PCA", "PCA-cor", "Cholesky"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whiten_+3A_x">X</code></td>
<td>
<p>Data matrix, with samples in rows and variables in columns.</p>
</td></tr>
<tr><td><code id="whiten_+3A_center">center</code></td>
<td>
<p>Center columns to mean zero.</p>
</td></tr>
<tr><td><code id="whiten_+3A_method">method</code></td>
<td>
<p>Determines the type of whitening transformation (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following whitening approaches can be selected:
</p>
<p><code>method="ZCA"</code> and <code>method="ZCA-cov"</code>: ZCA whitening, also known as Mahalanobis whitening, ensures that the average covariance between whitened and orginal variables is maximal.  
</p>
<p><code>method="ZCA-cor"</code>: Likewise, ZCA-cor whitening leads to whitened variables that are maximally correlated (on average) with the original variables.  
</p>
<p><code>method="PCA"</code> and <code>method="PCA-cov"</code>: In contrast, PCA whitening lead to maximally compressed whitened variables, as measured by squared covariance.
</p>
<p><code>method="PCA-cor"</code>: PCA-cor whitening is similar to PCA whitening but uses squared correlations.  
</p>
<p><code>method="Cholesky"</code>: computes a whitening matrix by applying Cholesky decomposition.  This yields both a lower triangular positive diagonal whitening matrix and lower triangular positive diagonal loadings (cross-covariance and cross-correlation).  
</p>
<p>Note that Cholesky whitening depends on the ordering of input variables. In the convention used here the first input variable is linked with the first latent variable only, the second input variable is linked to the first and second latent variable only, and so on, and the last variable is linked to all latent variables. 
</p>
<p>ZCA-cor whitening is implicitely employed in computing CAT and CAR scores used for variable selection in classification and regression, see the functions <code>catscore</code> in the <code>sda</code> package and <code>carscore</code> in the <code>care</code> package.
</p>
<p>In both PCA and PCA-cor whitening there is a sign-ambiguity in the eigenvector matrices. In order to resolve the sign-ambiguity we use eigenvector matrices with a positive diagonal so that PCA and PCA-cor cross-correlations and cross-covariances have a positive diagonal for the given ordering of the original variables.
</p>
<p>For details see Kessy, Lewin, and Strimmer (2018).
</p>
<p>Canonical correlation analysis (CCA) can also be understood as a special form of whitening (also implemented in this package).
</p>


<h3>Value</h3>

<p><code>whiten</code> returns the whitened data matrix <code class="reqn">Z = X W^T</code>.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>) with Agnan Kessy and Alex Lewin.
</p>


<h3>References</h3>

<p>Kessy, A., A. Lewin, and K. Strimmer. 2018.
Optimal whitening and decorrelation. The American Statistician. 72: 309-314.
&lt;DOI:10.1080/00031305.2016.1277159&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteningMatrix">whiteningMatrix</a></code>, <code><a href="#topic+whiteningLoadings">whiteningLoadings</a></code>, <code><a href="#topic+scca">scca</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

######

# example data set
# E. Anderson. 1935.  The irises of the Gaspe Peninsula.
# Bull. Am. Iris Soc. 59: 2--5
data("iris")
X = as.matrix(iris[,1:4])
d = ncol(X) # 4
n = nrow(X) # 150
colnames(X) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"

# whitened data
Z.ZCAcor = whiten(X, method="ZCA-cor")

# check covariance matrix
zapsmall( cov(Z.ZCAcor) )
</code></pre>

<hr>
<h2 id='whitening-internal'>Internal whitening Functions</h2><span id='topic+whitening-internal'></span><span id='topic+whiteningCrossCov'></span><span id='topic+getPhiW'></span>

<h3>Description</h3>

<p>Internal whitening functions.
</p>


<h3>Note</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written).
</p>

<hr>
<h2 id='whiteningLoadings'>Compute Whitening Loadings</h2><span id='topic+whiteningLoadings'></span>

<h3>Description</h3>

<p><code>whiteningLoading</code> computes the loadings (= cross-covariance matrix <code class="reqn">\Phi=Cov(x, z)</code>) between the original and the whitened variables as well as the correlation loadings (= cross-correlation matrix  <code class="reqn">\Psi=Cor(x, z)</code>).  The original variables are in the rows and the whitened variables in the columns. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  whiteningLoadings(Sigma, method=c("ZCA", "ZCA-cor", "PCA", "PCA-cor", "Cholesky"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whiteningLoadings_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="whiteningLoadings_+3A_method">method</code></td>
<td>
<p>Determines the type of whitening transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\Phi=Cov(x, z)</code> is the cross-covariance matrix between the original and the whitened variables. It satisfies <code class="reqn">\Phi \Phi^{T} = \Sigma = Var(x)</code>. This cross-covariance matrix is the inverse of the whitening matrix so that <code class="reqn">\Phi = W^{-1}</code>. The cross-covariance matrix is therefore relevant in inverse whitening transformations (=coloring transformations)  <code class="reqn">x = \Phi z</code>.
</p>
<p><code class="reqn">\Psi=Cor(x, z)</code> is the cross-correlation matrix between the original and the whitened variables.
</p>
<p>The following different whitening approaches can be selected:
</p>
<p><code>method="ZCA"</code>: ZCA whitening, also known as Mahalanobis whitening, ensures that the average covariance between whitened and orginal variables is maximal.  
</p>
<p><code>method="ZCA-cor"</code>: Likewise, ZCA-cor whitening leads to whitened variables that are maximally correlated (on average) with the original variables.  
</p>
<p><code>method="PCA"</code>: In contrast, PCA whitening lead to maximally compressed whitened variables, as measured by squared covariance.
</p>
<p><code>method="PCA-cor"</code>: PCA-cor whitening is similar to PCA whitening but uses squared correlations.  
</p>
<p><code>method="Cholesky"</code>: computes a whitening matrix by applying Cholesky decomposition.  This yields both a lower triangular positive diagonal whitening matrix and lower triangular positive diagonal loadings (cross-covariance and cross-correlation).  
</p>
<p>Note that Cholesky whitening depends on the ordering of input variables. In the convention used here the first input variable is linked with the first latent variable only, the second input variable is linked to the first and second latent variable only, and so on, and the last variable is linked to all latent variables. 
</p>
<p>ZCA-cor whitening is implicitely employed in computing CAT and CAR scores used for variable selection in classification and regression, see the functions <code>catscore</code> in the <code>sda</code> package and <code>carscore</code> in the <code>care</code> package.
</p>
<p>In both PCA and PCA-cor whitening there is a sign-ambiguity in the eigenvector matrices. In order to resolve the sign-ambiguity we use eigenvector matrices with a positive diagonal so that PCA and PCA-cor cross-correlations and cross-covariances have a positive diagonal for the given ordering of the original variables.
</p>
<p>For details see Kessy, Lewin, and Strimmer (2018). 
</p>


<h3>Value</h3>

<p><code>whiteningLoadings</code> returns a list with the following items:
</p>
<p><code>Phi</code> - cross-covariance matrix <code class="reqn">\Phi</code> - the loadings. 
</p>
<p><code>Psi</code> - cross-correlation matrix <code class="reqn">\Psi</code> - the correlation loadings. 
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Kessy, A., A. Lewin, and K. Strimmer. 2018.
Optimal whitening and decorrelation. The American Statistician. 72: 309-314.
&lt;DOI:10.1080/00031305.2016.1277159&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+explainedVariation">explainedVariation</a></code>, <code><a href="#topic+whiten">whiten</a></code>, <code><a href="#topic+whiteningMatrix">whiteningMatrix</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

######

# example data set
# E. Anderson. 1935.  The irises of the Gaspe Peninsula.
# Bull. Am. Iris Soc. 59: 2--5
data("iris")
X = as.matrix(iris[,1:4])
d = ncol(X) # 4
n = nrow(X) # 150
colnames(X) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"

# estimate covariance
S = cov(X)

# ZCA-cor whitening matrix
W.ZCAcor = whiteningMatrix(S, method="ZCA-cor")

# ZCA-cor loadings
ldgs = whiteningLoadings(S, method="ZCA-cor")
ldgs

# cross-covariance matrix
Phi.ZCAcor = ldgs$Phi

# check constraint of cross-covariance matrix
tcrossprod(Phi.ZCAcor)
S

# cross-covariance matrix aka loadings is equal to the inverse whitening matrix
Phi.ZCAcor
solve(W.ZCAcor)
</code></pre>

<hr>
<h2 id='whiteningMatrix'>Compute Whitening Matrix</h2><span id='topic+whiteningMatrix'></span>

<h3>Description</h3>

<p><code>whiteningMatrix</code> computes the whitening matrix <code class="reqn">W</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  whiteningMatrix(Sigma, method=c("ZCA", "ZCA-cor", "PCA", "PCA-cor", "Cholesky"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whiteningMatrix_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="whiteningMatrix_+3A_method">method</code></td>
<td>
<p>Determines the type of whitening transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whitening is a linear transformation <code class="reqn">z = W x</code> where the whitening matrix satisfies the constraint <code class="reqn">W^T W = \Sigma^{-1}</code>  where <code class="reqn">\Sigma = Cov(x)</code>.
</p>
<p>This function implements various natural whitening transformations discussed in  Kessy, Lewin, and Strimmer (2018).
</p>
<p>The following different whitening approaches can be selected:
</p>
<p><code>method="ZCA"</code>: ZCA whitening, also known as Mahalanobis whitening, ensures that the average covariance between whitened and orginal variables is maximal.  
</p>
<p><code>method="ZCA-cor"</code>: Likewise, ZCA-cor whitening leads to whitened variables that are maximally correlated (on average) with the original variables.  
</p>
<p><code>method="PCA"</code>: In contrast, PCA whitening lead to maximally compressed whitened variables, as measured by squared covariance.
</p>
<p><code>method="PCA-cor"</code>: PCA-cor whitening is similar to PCA whitening but uses squared correlations.  
</p>
<p><code>method="Cholesky"</code>: computes a whitening matrix by applying Cholesky decomposition.  This yields both a lower triangular positive diagonal whitening matrix and lower triangular positive diagonal loadings (cross-covariance and cross-correlation).  
</p>
<p>Note that Cholesky whitening depends on the ordering of input variables. In the convention used here the first input variable is linked with the first latent variable only, the second input variable is linked to the first and second latent variable only, and so on, and the last variable is linked to all latent variables. 
</p>
<p>ZCA-cor whitening is implicitely employed in computing CAT and CAR scores used for variable selection in classification and regression, see the functions <code>catscore</code> in the <code>sda</code> package and <code>carscore</code> in the <code>care</code> package.
</p>
<p>In both PCA and PCA-cor whitening there is a sign-ambiguity in the eigenvector matrices. In order to resolve the sign-ambiguity we use eigenvector matrices with a positive diagonal so that PCA and PCA-cor cross-correlations and cross-covariances have a positive diagonal for the given ordering of the original variables.
</p>
<p>For details see Kessy, Lewin, and Strimmer (2018).
</p>
<p>Canonical correlation analysis (CCA) can also be understood as a special form of whitening (also implemented in this package).
</p>


<h3>Value</h3>

<p><code>whiteningMatrix</code> returns a square whitening matrix <code class="reqn">W</code>.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>) with Agnan Kessy and Alex Lewin.
</p>


<h3>References</h3>

<p>Kessy, A., A. Lewin, and K. Strimmer. 2018.
Optimal whitening and decorrelation. The American Statistician. 72: 309-314.
&lt;DOI:10.1080/00031305.2016.1277159&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiten">whiten</a></code>, <code><a href="#topic+whiteningLoadings">whiteningLoadings</a></code>, <code><a href="#topic+scca">scca</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load whitening library
library("whitening")

# example data set
# E. Anderson. 1935.  The irises of the Gaspe Peninsula.
# Bull. Am. Iris Soc. 59: 2--5
data("iris")
X = as.matrix(iris[,1:4])
d = ncol(X) # 4
n = nrow(X) # 150
colnames(X) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"

# estimate covariance
S = cov(X)

# ZCA-cor whitening matrix
W.ZCAcor = whiteningMatrix(S, method="ZCA-cor")

# check constraint on the whitening matrix
crossprod(W.ZCAcor)
solve(S)

# whitened data
Z = tcrossprod(X, W.ZCAcor) 
Z
zapsmall( cov(Z) )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
