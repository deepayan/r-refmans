<!DOCTYPE html><html><head><title>Help for package measuRing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {measuRing}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colNarrow'><p>Narrow rings</p></a></li>
<li><a href='#crossRings'><p>dplR crossdating</p></a></li>
<li><a href='#dataSegments'><p>Data segments</p></a></li>
<li><a href='#grayDarker'><p>Gray extremes</p></a></li>
<li><a href='#graySmoothed'><p>Smoothed gray</p></a></li>
<li><a href='#imageTogray'><p>Gray matrix</p></a></li>
<li><a href='#lagIngray'><p>First-local lag</p></a></li>
<li><a href='#linearDetect'><p>Linear detection</p></a></li>
<li><a href='#measuRing-package'><p>Detection and Control of Tree-Ring Widths on Scanned Image Sections</p></a></li>
<li><a href='#multiDetect'><p>Multiple detection of TRWs</p></a></li>
<li><a href='#plotSegments'><p>Image segments</p></a></li>
<li><a href='#reduceList'><p>ring-width object reduction</p></a></li>
<li><a href='#ringBorders'><p>Ring borders</p></a></li>
<li><a href='#ringDetect'><p>Single Detection of TRWs</p></a></li>
<li><a href='#ringSelect'><p>Visual selection</p></a></li>
<li><a href='#ringWidths'><p>Ring widths</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Detection and Control of Tree-Ring Widths on Scanned Image
Sections</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Wilson Lara, Carlos Sierra, Felipe Bravo</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-02-11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wilson Lara &lt;wilarhen@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>pastecs, png, tiff, dplR</td>
</tr>
<tr>
<td>Description:</td>
<td>Identification of ring borders on scanned image sections from dendrochronological samples. Processing of image reflectances to produce gray matrices and time series of smoothed gray values. Luminance data is plotted on segmented images for users to perform both: visual identification of ring borders or control of automatic detection. Routines to visually include/exclude ring borders on the R graphical devices, or automatically detect ring borders using a linear detection algorithm. This algorithm detects ring borders according to positive/negative extreme values in the smoothed time-series of gray values. Most of the in-package routines can be recursively implemented using the multiDetect() function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-02-20 15:02:58 UTC; wilar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-02-20 15:15:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='colNarrow'>Narrow rings</h2><span id='topic+colNarrow'></span>

<h3>Description</h3>

<p>This function can detect narrow rings in a sequence of tree-ring
widths in wood (TRWs). This and other in-package functions are
recursively implemented by <code><a href="#topic+multiDetect">multiDetect</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>colNarrow(rwidths, marker = 5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colNarrow_+3A_rwidths">rwidths</code></td>
<td>
<p>a dataframe with the ring widths such as that
produced by <code><a href="#topic+ringWidths">ringWidths</a></code>.</p>
</td></tr>
<tr><td><code id="colNarrow_+3A_marker">marker</code></td>
<td>
<p>a number from 1 to 10. Those rings with scaled
averages greater than or equal to this argument
will be identified as narrow rings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each ring is averaged with those rings on either side
of it (t-1,t,t+1), and averages are divided by the highest
computed average in the sample; such quotients are scaled from
10 (the narrowest possible ring) to one (the broadest ring).</p>


<h3>Value</h3>

<p>character vector with the columns in gray matrix corresponding
to the narrow rings (see <code><a href="#topic+ringDetect">ringDetect</a></code>,
<code><a href="#topic+multiDetect">multiDetect</a></code>, and<code><a href="#topic+plotSegments">plotSegments</a></code>).</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image section in package measuRing:
image1 &lt;- system.file("P105_a.png", package="measuRing")    
## (not run) compute a gray matrix from RGB in the image:
gray &lt;- imageTogray(image = image1,ppi=1000)
## (not run) Columns in gray matrix to be included/excluded:
Toinc &lt;- c(196,202,387,1564) 
Toexc &lt;- c(21,130,197,207,1444,1484)
## (not run) tree-ring widths:
rwidths &lt;- ringWidths(gray,inclu = Toinc,exclu = Toexc,last.yr=2012)
##(not run) narrow rings:
narrows &lt;- colNarrow(rwidths,marker = 8)
</code></pre>

<hr>
<h2 id='crossRings'>dplR crossdating </h2><span id='topic+crossRings'></span>

<h3>Description</h3>

<p>This function implements routines in <code><a href="dplR.html#topic+dplR">dplR</a></code> to
crossdate TRWs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossRings(mdr, smp = 1, ncol = 1:length(mdr), fun = "corr", 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossRings_+3A_mdr">mdr</code></td>
<td>
<p><code>list</code>. Set of detected TRWs such
as that produced by <code><a href="#topic+multiDetect">multiDetect</a></code>.</p>
</td></tr>
<tr><td><code id="crossRings_+3A_smp">smp</code></td>
<td>
<p><code>numeric</code> or <code>character</code>. Position or name
in the set of the sample being crossdated.</p>
</td></tr>
<tr><td><code id="crossRings_+3A_ncol">ncol</code></td>
<td>
<p><code>numeric</code> or
<code>character</code>. Positions or names in the
set of the TRWs used to crossdate the
sample.</p>
</td></tr>
<tr><td><code id="crossRings_+3A_fun">fun</code></td>
<td>
<p><code>character</code>. Function in <code><a href="dplR.html#topic+dplR">dplR</a></code>
to be implemented. Three functions can be used:
<code><a href="dplR.html#topic+corr.rwl.seg">corr.rwl.seg</a></code> ('corr'),
<code><a href="dplR.html#topic+ccf.series.rwl">ccf.series.rwl</a></code> ('ccf'), and
<code><a href="dplR.html#topic+spag.plot">spag.plot</a></code> ('spag').</p>
</td></tr>
<tr><td><code id="crossRings_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code>dplR</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output of selected function.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Paths to three image sections in the package:
img &lt;- system.file(c("P105_a.tif",
                     "P105_b.tif",
                     "P105_d.tif"),
                   package="measuRing")

## Recursive detection:
mrings &lt;- multiDetect(img,
                      last.yr = 2013,
                      auto.det = TRUE,
                      plot = FALSE)

## corr analysis
crossRings(mrings,
           fun = 'corr',
           seg.length = 10,
           bin.floor = 0,
           lag.max = 2,
           make.plot = FALSE)
</code></pre>

<hr>
<h2 id='dataSegments'>Data segments</h2><span id='topic+dataSegments'></span>

<h3>Description</h3>

<p>Segmented data sets required by function
<code><a href="#topic+plotSegments">plotSegments</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataSegments(image, segs = 1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataSegments_+3A_image">image</code></td>
<td>
<p>Either path of an image section or an array
representing a gray matrix.</p>
</td></tr>
<tr><td><code id="dataSegments_+3A_segs">segs</code></td>
<td>
<p>number of image segments.</p>
</td></tr>
<tr><td><code id="dataSegments_+3A_...">...</code></td>
<td>
<p>arguments to be passed to three functions:
<code><a href="#topic+ringWidths">ringWidths</a></code>, <code><a href="#topic+ringBorders">ringBorders</a></code>,
and/or <code><a href="#topic+imageTogray">imageTogray</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with segmented sets of the gray matrix, the ring
borders, and the ring widths (see
<code><a href="#topic+plotSegments">plotSegments</a></code>).</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image section in package measuRing:
image1 &lt;- system.file("P105_a.tif", package="measuRing")    
## (not run) compute a gray matrix from its RGB:
gray &lt;- imageTogray(image1)
## (not run) Columns in gray matrix to be included/excluded:
Toinc &lt;- c(196,202,387,1564) 
Toexc &lt;- c(21,130,197,207,1444,1484)
## (not run) segmented data:
segm &lt;- dataSegments(image1,segs = 3)
lapply(segm,str)
attributes(segm)
</code></pre>

<hr>
<h2 id='grayDarker'>Gray extremes</h2><span id='topic+grayDarker'></span>

<h3>Description</h3>

<p>This function can detect the extremes of the smoothed gray.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grayDarker(smoothed, origin = 0, darker = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grayDarker_+3A_smoothed">smoothed</code></td>
<td>
<p>a data frame with the smoothed gray such
as that produced by
<code><a href="#topic+graySmoothed">graySmoothed</a></code>.</p>
</td></tr>
<tr><td><code id="grayDarker_+3A_origin">origin</code></td>
<td>
<p>an origin to find the extremes.</p>
</td></tr>
<tr><td><code id="grayDarker_+3A_darker">darker</code></td>
<td>
<p>logical. If TRUE the function finds the
negative extremes. If FALSE the possitive
extremes are detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with the columns in gray matrix corresponding to
the extremes (see <code><a href="#topic+graySmoothed">graySmoothed</a></code> and
<code><a href="#topic+linearDetect">linearDetect</a></code>).</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) read one image section:
image1 &lt;- system.file("P105_a.png", package="measuRing")    
## (not run) gray matrix from RGB in image:
gray &lt;- imageTogray(image = image1,ppi = 1000)
## (not run) smoothed gray:
smoothed &lt;- graySmoothed(gray)
## (not run) column numbers of possitive and negative extremes:
posit &lt;- grayDarker(smoothed,darker=FALSE)
nega &lt;- grayDarker(smoothed,darker=TRUE)
str(nega)
</code></pre>

<hr>
<h2 id='graySmoothed'>Smoothed gray</h2><span id='topic+graySmoothed'></span>

<h3>Description</h3>

<p>Averaging, detrending, and smoothing of the columns in a gray matrix. </p>


<h3>Usage</h3>

<pre><code class='language-R'>graySmoothed(image, all = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graySmoothed_+3A_image">image</code></td>
<td>
<p>character or matrix. Either path of an image section
or an array representing a gray matrix.</p>
</td></tr>
<tr><td><code id="graySmoothed_+3A_all">all</code></td>
<td>
<p>logical. If TRUE the column numbers and
moving averages are added to the output.</p>
</td></tr>
<tr><td><code id="graySmoothed_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+imageTogray">imageTogray</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with the smoothed grays. If <code>all</code> is
TRUE then the output is extended with the columns in
gray matrix, and moving averages.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image section in package measuRing:
image1 &lt;- system.file("P105_a.png", package="measuRing")    
## (not run) the smoothed gray:
smoothed &lt;- graySmoothed(image1,ppi=1000)
## (not run) Plot of the smoothed gray:        
Smooth &lt;- ts(smoothed)
main. &lt;- 'Smoothed gray'
plot(Smooth,xlab = 'Column', main=main.,
     ylab = 'Smoothed gray',col = 'gray')

</code></pre>

<hr>
<h2 id='imageTogray'>Gray matrix</h2><span id='topic+imageTogray'></span>

<h3>Description</h3>

<p>This function can compute a gray matrix from the RGB in an
image section. Such an image section can be compressed in
either portable network graphics format (png) or tagged image
file format (tif).    </p>


<h3>Usage</h3>

<pre><code class='language-R'>imageTogray(image, ppi = NULL, rgb = c(0.3, 0.6, 0.1), p.row = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageTogray_+3A_image">image</code></td>
<td>
<p>character. path of an image section.</p>
</td></tr>
<tr><td><code id="imageTogray_+3A_ppi">ppi</code></td>
<td>
<p>NULL or integer. If NULL the image resolution
in points per inch is extracted from attributes
in <code>image</code>. If this attribute is not
embedded then users should provide it</p>
</td></tr>
<tr><td><code id="imageTogray_+3A_rgb">rgb</code></td>
<td>
<p>vector with three fractions, all of
them adding to one, to combine RGB channels into gray
matrix.</p>
</td></tr>
<tr><td><code id="imageTogray_+3A_p.row">p.row</code></td>
<td>
<p>proportion of rows of gray matrix to be
processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a gray matrix containing the image reflectances.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read two image sections in package measuRing:
image1 &lt;- system.file("P105_a.tif", package="measuRing")
image2 &lt;- system.file("P105_a.png", package="measuRing")
## (not run) compute a gray matrix:
gray &lt;- imageTogray(image1)
## (not run) - the ppi is embedded in the image:
attributes(gray)
## (not run) but, the ppi is not embedded in image2:
## - imageTogray will return an error:
## (uncoment and run):
## gray2 &lt;- imageTogray(image2)
## attributes(gray2)
## - the ppi should be provided (i.e. ppi = 1200):
gray3 &lt;- imageTogray(image2,ppi = 1200)
attributes(gray3)
##(not run) a plot of the gray matrix        
xrange &lt;- range(0:ncol(gray)) + c(-1,1)
yrange &lt;- range(0:nrow(gray)) + c(-1,1)    
{plot(xrange,yrange,xlim=xrange,ylim=yrange,xlab='',
      ylab='',type='n',asp=0)
rasterImage(gray,xrange[1],yrange[1],xrange[2],yrange[2])}    
</code></pre>

<hr>
<h2 id='lagIngray'>First-local lag</h2><span id='topic+lagIngray'></span>

<h3>Description</h3>

<p>This function can compute the lag of the first local on the
auto-correlation function (acf) of smoothed grays.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagIngray(image, acf = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagIngray_+3A_image">image</code></td>
<td>
<p>character or matrix. Either path of an image section
or an array representing a gray matrix.</p>
</td></tr>
<tr><td><code id="lagIngray_+3A_acf">acf</code></td>
<td>
<p>logical. If TRUE the output is extended with the
acf.</p>
</td></tr>
<tr><td><code id="lagIngray_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+imageTogray">imageTogray</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>constant value of the first local on the acf of the
smoothed gray. If acf is TRUE then the computed acf is
added to the output (see <code><a href="#topic+linearDetect">linearDetect</a></code>, and
<code><a href="#topic+graySmoothed">graySmoothed</a></code>).</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image sample in folder of package measuRing:
image1 &lt;- system.file("P105_a.tif", package="measuRing")
##(not run) First local in the acf of smoothed grays:       
local1 &lt;- lagIngray(image1,acf = TRUE)        
##(not run) Plot of first local over the acf: 
Flocal &lt;- local1[['local']]
Clocal &lt;- ts(local1[['acf']][Flocal,],start=Flocal)
acf &lt;- ts(local1[['acf']],start=1)    
{plot(acf,type='h',col='gray',xlab='Lag',main='First local lag')
points(Clocal,pch=19,cex=0.5)}
</code></pre>

<hr>
<h2 id='linearDetect'>Linear detection</h2><span id='topic+linearDetect'></span>

<h3>Description</h3>

<p>Function for developing linear detection of ring borders.</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearDetect(smoothed, origin = 0, darker = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearDetect_+3A_smoothed">smoothed</code></td>
<td>
<p>a data frame with smoothed grays such as that
produced by <code><a href="#topic+graySmoothed">graySmoothed</a></code>.</p>
</td></tr>
<tr><td><code id="linearDetect_+3A_origin">origin</code></td>
<td>
<p>numeric. an origin in smoothed gray to find the
ring borders.</p>
</td></tr>
<tr><td><code id="linearDetect_+3A_darker">darker</code></td>
<td>
<p>logical. If TRUE the algorithm uses the
negative extremes on smoothed grays to detect the ring
borders. If FALSE the possitive extremes are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with column numbers in gray matrix of the detected
ring borders (see <code><a href="#topic+grayDarker">grayDarker</a></code>, and
<code><a href="#topic+graySmoothed">graySmoothed</a></code>).</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image section in package measuRing:
image1 &lt;- system.file("P105_a.tif", package="measuRing")    
## (not run) smoothed gray:
smoothed &lt;- graySmoothed(image1)
## linear detection:
borders &lt;- linearDetect(smoothed)
str(borders)
</code></pre>

<hr>
<h2 id='measuRing-package'>Detection and Control of Tree-Ring Widths on Scanned Image Sections</h2><span id='topic+measuRing-package'></span><span id='topic+measuRing'></span>

<h3>Description</h3>

<p>Identification of ring borders on scanned image sections from dendrochronological samples. Processing of image reflectances to produce gray matrices and time series of smoothed gray values. Luminance data is plotted on segmented images for users to perform both: visual identification of ring borders or control of automatic detection. Routines to visually include/exclude ring borders on the R graphical devices, or automatically detect ring borders using a linear detection algorithm. This algorithm detects ring borders according to positive/negative extreme values in the smoothed time-series of gray values. Most of the in-package routines can be recursively implemented using the multiDetect() function.</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> measuRing</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Detection and Control of Tree-Ring Widths on Scanned Image Sections</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Wilson Lara, Carlos Sierra, Felipe Bravo</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-02-11</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Wilson Lara &lt;wilarhen@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> pastecs, png, tiff, dplR</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Identification of ring borders on scanned image sections from dendrochronological samples. Processing of image reflectances to produce gray matrices and time series of smoothed gray values. Luminance data is plotted on segmented images for users to perform both: visual identification of ring borders or control of automatic detection. Routines to visually include/exclude ring borders on the R graphical devices, or automatically detect ring borders using a linear detection algorithm. This algorithm detects ring borders according to positive/negative extreme values in the smoothed time-series of gray values. Most of the in-package routines can be recursively implemented using the multiDetect() function.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
colNarrow               Narrow rings
crossRings              dplR crossdating
dataSegments            Data segments
grayDarker              Gray extremes
graySmoothed            Smoothed gray
imageTogray             Gray matrix
lagIngray               First-local lag
linearDetect            Linear detection
measuRing-package       Detection and Control of Tree-Ring Widths on
                        Scanned Image Sections
multiDetect             Multiple detection of TRWs
plotSegments            Image segments
reduceList              ring-width object reduction
ringBorders             Ring borders
ringDetect              Single Detection of TRWs
ringSelect              Visual selection
ringWidths              Ring widths
</pre>
<p>Maintainer: Wilson Lara &lt;wilarhen@gmail.com&gt;
</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>

<hr>
<h2 id='multiDetect'>Multiple detection of TRWs</h2><span id='topic+multiDetect'></span>

<h3>Description</h3>

<p>This function recursively detects TRWs in sets of scanned images
of wood or gray matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiDetect(image, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiDetect_+3A_image">image</code></td>
<td>
<p><code>character</code> or <code>list</code>. Vector of Paths to the
image files or set of gray matrices.</p>
</td></tr>
<tr><td><code id="multiDetect_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+ringDetect">ringDetect</a></code>
and <code><a href="#topic+ringSelect">ringSelect</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>. Set of <code><a href="#topic+ringDetect">ringDetect</a></code> calls.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Paths to three image sections in the package:
img &lt;- system.file(c("P105_a.tif",
                     "P105_b.tif",
                     "P105_d.tif"),
                   package="measuRing")

## Recursive detection. Arbitrary ring borders and different years
## of formation of last rings in the images years are specified:
mrings &lt;- multiDetect(img,
                      inclu = list(c(1:40),c(1:30),c(1:41)),
                      last.yr = list(2014, 2013, 2012),
                      auto.det = c(FALSE,TRUE,FALSE),
                      plot = FALSE)
str(mrings)

## Updating the call in mrings using new arguments: 
mrings1 &lt;- update(mrings,
                  exclu = list(c(1:4),c(1:4),c(1:4)),
                  last.yr = 2016)

</code></pre>

<hr>
<h2 id='plotSegments'>Image segments</h2><span id='topic+plotSegments'></span>

<h3>Description</h3>

<p>One or several plots of consecutive segments of gray matrix and
smoothed grays.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSegments(image, ratio = NULL, marker = NULL, col.marker = "red", 
    tit = TRUE, plot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSegments_+3A_image">image</code></td>
<td>
<p>character or matrix. Either path of an image section
or an array representing a gray matrix.</p>
</td></tr>
<tr><td><code id="plotSegments_+3A_ratio">ratio</code></td>
<td>
<p>NULL or vector with two values representing
the aspect of the plots (height, and width). If
NULL the default aspect in <code>par()</code> is
used.</p>
</td></tr>
<tr><td><code id="plotSegments_+3A_marker">marker</code></td>
<td>
<p>NULL or a number from 1 to 10 as explained
in <code><a href="#topic+colNarrow">colNarrow</a></code>. If numeric then
three kind of markers are indicated: those
narrow rings with averages major than
<code>marker</code>, chronological markers
(decades, centuries, and millenia), and the
column numbers in gray matrix of the ring
borders. The markers are highlighted with
the color in <code>col.marker</code>. If NULL no
markers are highlighted.</p>
</td></tr>
<tr><td><code id="plotSegments_+3A_col.marker">col.marker</code></td>
<td>
<p>color of the markers.</p>
</td></tr>
<tr><td><code id="plotSegments_+3A_tit">tit</code></td>
<td>
<p>logical or character. A title for the
plots. If TRUE the main title is the image
name. For more than 1 segment the main title
ends with the segment number.</p>
</td></tr>
<tr><td><code id="plotSegments_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE the image segments are
plotted.</p>
</td></tr>
<tr><td><code id="plotSegments_+3A_...">...</code></td>
<td>
<p>arguments to be passed to four functions:
<code><a href="#topic+dataSegments">dataSegments</a></code>, <code><a href="#topic+ringWidths">ringWidths</a></code>,
<code><a href="#topic+ringBorders">ringBorders</a></code>, and/or
<code><a href="#topic+imageTogray">imageTogray</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the image segments and a list such as that produced by
<code><a href="#topic+dataSegments">dataSegments</a></code>.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image sample in folder of package measuRing:
image1 &lt;- system.file("P105_a.tif", package="measuRing")        
## column numbers to be included/avoided:
Toinc &lt;- c(196,202,387,1564) 
Toexc &lt;- c(21,130,197,207,1444,1484)        
##(not run) Plotting of five image segments:
plots &lt;- plotSegments(image1,rgb=c(0.5,0,0.5),last.yr=2011,
    marker=8,segs=3,inclu = Toinc,exclu = Toexc)
## plots &lt;- plotSegments(rwidths,segs = 4,marker=8)
## (not run) kill all the image segments:
graphics.off()
    
</code></pre>

<hr>
<h2 id='reduceList'>ring-width object reduction</h2><span id='topic+reduceList'></span>

<h3>Description</h3>

<p>ring-width objects are reduced to dplR chronologies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceList(mls, name.ls = "ringWidths", empty.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceList_+3A_mls">mls</code></td>
<td>
<p><code>List</code>. Object from <code><a href="#topic+multiDetect">multiDetect</a></code></p>
</td></tr>
<tr><td><code id="reduceList_+3A_name.ls">name.ls</code></td>
<td>
<p>Character. name of the list to be
reduced.</p>
</td></tr>
<tr><td><code id="reduceList_+3A_empty.rm">empty.rm</code></td>
<td>
<p>Logical. Remove empty lists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame  in wide format with the ring widths.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Paths to three image sections in the package:
img &lt;- system.file(c("P105_a.tif",
                     "P105_b.tif",
                     "P105_d.tif"),
                   package="measuRing")

## Recursive detection (arbitrary ring borders and formation years
## are included):
mrings &lt;- multiDetect(img,
                      inclu = list(c(1:40),c(1:30),c(1:41)),
                      last.yr = list(2014, 2013, 2012),
                      auto.det = c(FALSE,TRUE,FALSE),
                      plot = FALSE)
## Reducing the processed ring withs 
wide &lt;- reduceList(mrings)
tail(wide)
</code></pre>

<hr>
<h2 id='ringBorders'>Ring borders</h2><span id='topic+ringBorders'></span>

<h3>Description</h3>

<p>This function can find the ring borders in a gray matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ringBorders(image, auto.det = TRUE, darker = TRUE, origin = 0, 
    inclu = NULL, exclu = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ringBorders_+3A_image">image</code></td>
<td>
<p>character or matrix. Either path of an image section
or an array ##representing a gray matrix.</p>
</td></tr>
<tr><td><code id="ringBorders_+3A_auto.det">auto.det</code></td>
<td>
<p>logical. If TRUE the linear detection is
implemented (see
<code><a href="#topic+linearDetect">linearDetect</a></code>).</p>
</td></tr>
<tr><td><code id="ringBorders_+3A_darker">darker</code></td>
<td>
<p>logical. If TRUE the algorithm uses the
negative extremes on smoothed grays to
detect the ring borders. If FALSE the
possitive extremes are used.</p>
</td></tr>
<tr><td><code id="ringBorders_+3A_origin">origin</code></td>
<td>
<p>numeric. an origin in smoothed gray to
find the ring borders.</p>
</td></tr>
<tr><td><code id="ringBorders_+3A_inclu">inclu</code></td>
<td>
<p>NULL or vector with column numbers in gray
matrix, other than those automatically
detected, to be considered as ring borders.If
NULL no column numbers are included.</p>
</td></tr>
<tr><td><code id="ringBorders_+3A_exclu">exclu</code></td>
<td>
<p>NULL or vector with column numbers in gray</p>
</td></tr>
<tr><td><code id="ringBorders_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+imageTogray">imageTogray</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the smoothed grays and the identified
ring borders (see <code><a href="#topic+grayDarker">grayDarker</a></code>,
<code><a href="#topic+graySmoothed">graySmoothed</a></code>, and
<code><a href="#topic+linearDetect">linearDetect</a></code>).</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image sample in folder of package
## measuRing:
image1 &lt;- system.file("P105_a.tif", package="measuRing")        
## column numbers in gray matrix to be included/avoided:
Toinc &lt;- c(196,202,387,1564) 
Toexc &lt;- c(21,130,197,207,1444,1484)        
##(not run) the ring borders:
borders &lt;- ringBorders(image1,inclu = Toinc,exclu = Toexc)
str(borders)
##(not run) Plot of smoothed grays with the ring borders:
Smooth &lt;- ts(borders[,1])
inclupix &lt;- subset(borders,borders%in%TRUE)
inclucol &lt;- as.numeric(rownames(inclupix))
xyborders &lt;- data.frame(column=inclucol,smooth=inclupix[,1])
y.lim &lt;- c(-0.05,0.05)
main. &lt;- 'Ring borders'
{plot(Smooth,xlab = 'Column',ylab = 'Smoothed gray',
      main=main.,col = 'darkgoldenrod1')
 points(xyborders[,1],xyborders[,2],pch=19,cex=0.5,col='orangered')}
</code></pre>

<hr>
<h2 id='ringDetect'>Single Detection of TRWs</h2><span id='topic+ringDetect'></span>

<h3>Description</h3>

<p>This function assists in the detection of TRW (mm) in a scanned
image (.tif or .png) or gray matrix, evaluating other required
functions and plotting the outputs in graphics devices. The
function can be combined with <code><a href="#topic+ringSelect">ringSelect</a></code> to visually
detected TRWs. Nevertheless, the complete measurement procedure of
TRW with the package can be performed by <code><a href="#topic+multiDetect">multiDetect</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ringDetect(image, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ringDetect_+3A_image">image</code></td>
<td>
<p><code>character</code> or
<code>matrix</code>. Vector of path to
the image section or a gray matrix
such as that produced by
<code><a href="#topic+imageTogray">imageTogray</a></code>.</p>
</td></tr>
<tr><td><code id="ringDetect_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other
functions, see section of Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scanned sample should
correspond to a horizontal window of wood
with the bark side located towards the left
area of the image, and the pit side towards
the right. The image section may not
necessarily contain both bark and pit, see
images of the Examples. The image should
contain Red, Gren, and Blue channels (rgb)
and be compressed in any of two file
formats: tif or png. These are easily
obtained by scanning wood samples with a
conventional scanner and extracting a
horizontal image section. Five functions
are internally implemented:
<code><a href="#topic+plotSegments">plotSegments</a></code>,
<code><a href="#topic+dataSegments">dataSegments</a></code>,
<code><a href="#topic+ringWidths">ringWidths</a></code>,
<code><a href="#topic+ringBorders">ringBorders</a></code>,
and/or<code><a href="#topic+imageTogray">imageTogray</a></code>. These are
controlled using the following arguments:
</p>
 <ul>
<li><p><code>ppi = NULL</code>: image
resolution in points per inch. If
<code>NULL</code> the <code>ppi</code> is extracted
from the image attributes. If the
<code>ppi</code> is not embedded in the image,
then thos argument should be provided;
</p>
</li>
<li><p><code>rgb = c(0.3,0.6,0.1)</code>: vector of
three fractions, all of them adding to one,
to combine the rgb into a gray
matrix. Defaults correspond to the
rgb-standard in the luminosity function
(Russ, 2006): green light contributes the
most to the intensity perceived by humans,
and blue light the least; </p>
</li>
<li><p><code>p.row
= 1</code>: Proportion of rows in the central
portion of the gray matrix to be processed;
</p>
</li>
<li><p>last.yr = NULL: <code>NULL</code> or
<code>integer</code>. Year of formation of the
newest ring. If <code>NULL</code> then the rings
are numbered from one (right) to the number
of detected rings
(left);</p>
</li>
<li><p><code>auto.det = TRUE</code>:
<code>logical</code>. If TRUE then an algorithm
for automatic detection is implemented, see
<code><a href="#topic+linearDetect">linearDetect</a></code>;
</p>
</li>
<li><p><code>darker = TRUE</code>:
<code>logical</code>. If <code>TRUE</code> then the
algorithm uses the negative extremes on
smoothed grays to detect the ring
borders. If <code>FALSE</code> the positive
extremes are used instead;
</p>
</li>
<li><p><code>origin = 0</code>: An origin along
central portion of the smoothed gray to
find the ring borders. This value could
help to avoid noisy areas during the visual
detection process; </p>
</li>
<li><p><code>inclu =
NULL</code>: <code>NULL</code> or vector with column
numbers in the gray matrix, other than
those automatically detected, to be
considered as ring borders.  If <code>NULL</code>
no column numbers are included;
</p>
</li>
<li><p><code>exclu = NULL</code>: <code>NULL</code> or
vector with column numbers in gray matrix
of those ring borders to be excluded from
the analysis. If <code>NULL</code>, no ring
borders are excluded; </p>
</li>
<li><p><code>plot =
TRUE</code>: <code>logical</code>. If <code>TRUE</code> then
a plot is produced; </p>
</li>
<li><p><code>segs = 1</code>:
Number of image segments to be plotted;
</p>
</li>
<li><p><code>ratio = NULL</code>: <code>NULL</code> or
<code>numeric</code> vector of two values
representing the aspect ratio of the plots
(height, and width). If <code>NULL</code> default
in <code><a href="graphics.html#topic+par">par</a></code> is used;
</p>
</li>
<li><p><code>marker = NULL</code>: <code>NULL</code> or
<code>integer</code> vector with any value from 1
to 10. The rings are averaged with those
rings on either side of it and the averages
are scaled from ten (the narrowest possible
ring) to one (the broadest ring). The
narrow rings with averages larger than
<code>marker</code> as well as other
chronological markers (decades, centuries,
and millennia), are highlighted with red
pinpricks; </p>
</li>
<li><p><code>col.marker = 'red'</code>:
color of the markers; </p>
</li>
<li><p><code>tit =
TRUE</code>: <code>logical</code> or
<code>character</code>. A title for the plots. If
<code>TRUE</code> the main title is the image
name. For more than 1 segment the main
title ends with the segment number. This
argument does not work in
<code><a href="#topic+multiDetect">multiDetect</a></code>.</p>
</li></ul>
<p> If
users run R from Interactive Development
Environments (IDE) aiming to segment the
image section (<code>segs &gt; 1</code>), they
should be sure that such environments
support multiple graphics devices. If the
argument <code>image</code> is a gray matrix,
then other arguments passed to
<code><a href="#topic+imageTogray">imageTogray</a></code> will be
ignored. The function can be combined with
<code><a href="#topic+ringSelect">ringSelect</a></code> to visually
include/exclude ring borders in the plot
output, see examples in the
<code>ringSelect</code> function. See
<code><a href="#topic+multiDetect">multiDetect</a></code> for recursive
implementation of this function.
</p>
<p>references&lt;&lt; </p>
<ul>
<li><p> Lara W.,
F. Bravo, and S. Carlos. 2015. measuRing:
An R package to measure tree-ring widths
from scanned images.  Dendrochronologia,
34: 43-50; </p>
</li>
<li><p> Russ, J.C., 2006. The
Image Processing Handbook, Fifth
Edition. CRC Press, Boca Raton, 817 pp.</p>
</li></ul>


<h3>Value</h3>

<p>list of data frames with ring widths and ring
borders such as these produced by
<code><a href="#topic+ringWidths">ringWidths</a></code>, and <code><a href="#topic+ringBorders">ringBorders</a></code>.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>image1 &lt;- system.file("P105_a.tif", package="measuRing")
## (not run) Initial diagnostic:
detect1 &lt;- ringDetect(image1,segs=3)
## (not run) Updating ringDetect to chage arguments;
## and flagged rings
detect1 &lt;- update(detect1,marker=8) 
## (not run) Some noise in smoothed gray can be avoided
## by moving the origin: 
detect1 &lt;- update(detect1,origin = -0.03)
## (not run) columns 21 and 130 are not considered now.
##
## (not run) Choose other columns in gray matrix (see ringSelect);
## (not run) graphical devices from ringDetect should be active!
## (not run) Including columns:
## (uncomment and run):
## detect1 &lt;- update(detect1)
## Toinc &lt;- ringSelect(detect1)
## detect1 &lt;- update(detect1, inclu = Toinc)
## or, include the next columns: 
Toinc &lt;- c(202,387,1564) 
detect1 &lt;- update(detect1,inclu = Toinc)        
## (not run) Object detec1 is updated with Toinc;
##
## (not run)  ring borders to be excluded:
## (uncomment and run):
## detect1 &lt;- update(detect1)
## Toexc &lt;- ringSelect(detect1,any.col = FALSE)
## detect1 &lt;- update(detect1,exclu=Toexc)
## or, exclude the nex columns: 
Toexc &lt;- c(208,1444,1484)
detect1 &lt;- update(detect1,exclu = Toexc)        
##
## (not run) Final arguments:
detect2 &lt;- update(detect1,last.yr=2011,marker = 8)
str(detect2)
##
## (not run) kill previous plot:
graphics.off()
##
## (not run) Tree-ring widths and attributes:
rings &lt;- detect2$'ringWidths'
##
## (not run) Plot of the tree-ring witdths:        
maint &lt;- 'Hello ring widths!'
plot(rings,ylab = 'width (mm)',type='l',col = 'red',main=maint)
</code></pre>

<hr>
<h2 id='ringSelect'>Visual selection</h2><span id='topic+ringSelect'></span>

<h3>Description</h3>

<p>This function can include and exclude ring borders in plot outputs
from <code><a href="#topic+ringDetect">ringDetect</a></code> or <code><a href="#topic+plotSegments">plotSegments</a></code>. The
function is mapped by <code><a href="#topic+multiDetect">multiDetect</a></code> for recursive
processing of image sections.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ringSelect(rdetect, any.col = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ringSelect_+3A_rdetect">rdetect</code></td>
<td>
<p>a list containing data frames of ring widths and ring
borders such as that produced by
<code><a href="#topic+ringDetect">ringDetect</a></code>.</p>
</td></tr>
<tr><td><code id="ringSelect_+3A_any.col">any.col</code></td>
<td>
<p>logical. If FALSE only those column numbers in
gray matrix previouly identified as ring borders
can be selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns in gray matrix are either
identified and stored by left-clicking the
mouse over the central axis of a gray image
in the plot output; pixel numbers of just
added ring borders are highlighted on the
gray raster. The raphics devices are
sequentially closed by right-clicking the
mouse. After a graphics device has been
closed, the graphics device of the following
segment is activated, and visual selection
on such a new segment can be
performed. Closing the graphics devices with
other procedures will stop the selection of
ring borders. This detection process can be
recursively developed on several image
section using <code><a href="#topic+multiDetect">multiDetect</a></code>.</p>


<h3>Value</h3>

<p>vector with column numbers in gray matrix of the
identified ring borders.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>References</h3>

<p>Lara W., F. Bravo, and
S. Carlos. 2015. measuRing: An R package to
measure tree-ring widths from scanned images
Dendrochronologia, 34: 43-50.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read one image in package folder:
image1 &lt;- system.file("P105_a.tif", package="measuRing")
## (not run) Initial diagnostic:
detect1 &lt;- ringDetect(image1,segs=2,marker=7)
##
## (not run) Choose other columns in gray matrix (see ringSelect);
## (not run) graphical devices from ringDetect should be active!
## (not run) Including columns:
##
## (uncomment and run):
## Toinc &lt;- ringSelect(detect1)
## detect1 &lt;- update(detect1, inclu = Toinc)
##
## (not run)  ring borders to be excluded:
## (uncomment and run):
## Toexc &lt;- ringSelect(detect1,any.col = FALSE)
## detect1 &lt;- update(detect1, exclu=Toexc)
## (not run) kill previous plot:
graphics.off()
</code></pre>

<hr>
<h2 id='ringWidths'>Ring widths </h2><span id='topic+ringWidths'></span>

<h3>Description</h3>

<p>This function can compute the ring widths (mm) from the ring
borders detected on an image section.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ringWidths(image, last.yr = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ringWidths_+3A_image">image</code></td>
<td>
<p>character or matrix. Either path of an image section
or an array representing a gray matrix.</p>
</td></tr>
<tr><td><code id="ringWidths_+3A_last.yr">last.yr</code></td>
<td>
<p>year of formation of the newest ring. If
NULL then the rings are numbered from one
(right) to the number of detected rings
(left).</p>
</td></tr>
<tr><td><code id="ringWidths_+3A_...">...</code></td>
<td>
<p>arguments to be passed to two functions:
<code><a href="#topic+ringBorders">ringBorders</a></code>, and/or
<code><a href="#topic+imageTogray">imageTogray</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with the ring widths.</p>


<h3>Author(s)</h3>

<p>Wilson Lara, Carlos Sierra, Felipe Bravo</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (not run) Read one image section:
image1 &lt;- system.file("P105_a.tif", package="measuRing")       
## (not run) columns in gray matrix to be included/excluded:
Toinc &lt;- c(196,202,387,1564) 
Toexc &lt;- c(21,130,197,207,1444,1484)
## (not run) tree-ring widths
rwidths &lt;- ringWidths(image1,inclu = Toinc,exclu = Toexc,last.yr=NULL)
str(rwidths)
##plot of computed tree-ring widths:
maint &lt;- 'Hello ring widths!'
plot(rwidths,type='l',col = 'red',main = maint,
     xlab = 'Year',ylab = 'Width (mm)')    
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
