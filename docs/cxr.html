<!DOCTYPE html><html><head><title>Help for package cxr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cxr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cxr-package'><p>cxr: A Toolbox for Modelling Species Coexistence in R</p></a></li>
<li><a href='#abundance'><p>Abundance measurements</p></a></li>
<li><a href='#abundance_projection'><p>Project abundances from population dynamics models</p></a></li>
<li><a href='#avg_fitness_diff'><p>Average fitness differences</p></a></li>
<li><a href='#BH_er_lambdacov_global_effectcov_global_responsecov_global'><p>Effect response Beverton-Holt model with covariate effects on lambda, effect, and response</p></a></li>
<li><a href='#BH_er_lambdacov_none_effectcov_none_responsecov_none'><p>Effect response model without covariate effects</p></a></li>
<li><a href='#BH_pm_alpha_global_lambdacov_none_alphacov_none'><p>Beverton-Holt model with a global alpha and no covariate effects</p></a></li>
<li><a href='#BH_pm_alpha_none_lambdacov_none_alphacov_none'><p>Beverton-Holt model with no alphas and no covariate effects</p></a></li>
<li><a href='#BH_pm_alpha_pairwise_lambdacov_global_alphacov_global'><p>Beverton-Holt model with pairwise alphas and global covariate effects on lambda and alpha</p></a></li>
<li><a href='#BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Beverton-Holt model with pairwise alphas, covariate effects on lambda,</p>
and pairwise covariate effects on alpha</a></li>
<li><a href='#BH_pm_alpha_pairwise_lambdacov_none_alphacov_none'><p>Beverton-Holt model with pairwise alphas and no covariate effects</p></a></li>
<li><a href='#BH_project_alpha_global_lambdacov_none_alphacov_none'><p>Beverton-Holt model for projecting abundances,</p>
with a global alpha and no covariate effects</a></li>
<li><a href='#BH_project_alpha_none_lambdacov_none_alphacov_none'><p>Beverton-Holt model for projecting abundances,</p>
with no alpha and no covariate effects</a></li>
<li><a href='#BH_project_alpha_pairwise_lambdacov_global_alphacov_global'><p>Beverton-Holt model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Beverton-Holt model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#BH_project_alpha_pairwise_lambdacov_none_alphacov_none'><p>Beverton-Holt model for projecting abundances,</p>
with specific alpha values and no covariate effects</a></li>
<li><a href='#build_param'><p>Build param structure</p></a></li>
<li><a href='#calculate_densities'><p>Obtain species densities from transition matrices</p></a></li>
<li><a href='#competitive_ability'><p>Competitive ability among pairs of species</p></a></li>
<li><a href='#cxr_er_bootstrap'><p>standard error estimates for effect and response parameters</p></a></li>
<li><a href='#cxr_er_fit'><p>General optimization for effect-response models</p></a></li>
<li><a href='#cxr_generate_test_data'><p>Generate simulated interaction data</p></a></li>
<li><a href='#cxr_pm_bootstrap'><p>Standard error estimates for model parameters</p></a></li>
<li><a href='#cxr_pm_fit'><p>General optimization for population models</p></a></li>
<li><a href='#cxr_pm_multifit'><p>Multi-species parameter optimization</p></a></li>
<li><a href='#densities_to_df'><p>Converts a densities list to a tidy dataframe</p></a></li>
<li><a href='#fill_demography_matrix'><p>Fill the vec-permutation demography matrix</p></a></li>
<li><a href='#fill_dispersal_matrix'><p>Fill the vec-permutation dispersal matrix</p></a></li>
<li><a href='#fill_transition_matrix'><p>Fill a transition matrix</p></a></li>
<li><a href='#fitness_ratio'><p>Fitness ratio among two or more species</p></a></li>
<li><a href='#generate_vital_rate_coefs'><p>Generate coefficients for obtaining vital rates</p></a></li>
<li><a href='#glm_example_coefs'><p>Generalized linear model coefficients</p></a></li>
<li><a href='#LV_er_lambdacov_global_effectcov_global_responsecov_global'><p>Effect response Lotka-Volterra model with covariate effects on lambda, effect, and response</p></a></li>
<li><a href='#LV_er_lambdacov_none_effectcov_none_responsecov_none'><p>Effect response Lotka-Volterra model without covariate effects</p></a></li>
<li><a href='#LV_pm_alpha_global_lambdacov_none_alphacov_none'><p>Lotka-Volterra model with a global alpha and no covariate effects</p></a></li>
<li><a href='#LV_pm_alpha_none_lambdacov_none_alphacov_none'><p>Lotka-Volterra model with no alphas and no covariate effects</p></a></li>
<li><a href='#LV_pm_alpha_pairwise_lambdacov_global_alphacov_global'><p>Lotka-Volterra model with pairwise alphas and global covariate effects on lambda and alpha</p></a></li>
<li><a href='#LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Lotka-Volterra model with pairwise alphas, covariate effects on lambda,</p>
and pairwise covariate effects on alpha</a></li>
<li><a href='#LV_pm_alpha_pairwise_lambdacov_none_alphacov_none'><p>Lotka-Volterra model with pairwise alphas and no covariate effects</p></a></li>
<li><a href='#LV_project_alpha_global_lambdacov_none_alphacov_none'><p>Lotka-Volterra model for projecting abundances,</p>
with a global alpha and no covariate effects</a></li>
<li><a href='#LV_project_alpha_none_lambdacov_none_alphacov_none'><p>Model for projecting abundances,</p>
with no alpha and no covariate effects</a></li>
<li><a href='#LV_project_alpha_pairwise_lambdacov_global_alphacov_global'><p>Lotka-Volterra model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Lotka-Volterra model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#LV_project_alpha_pairwise_lambdacov_none_alphacov_none'><p>Lotka-Volterra model for projecting abundances,</p>
with specific alpha values and no covariate effects</a></li>
<li><a href='#LW_er_lambdacov_global_effectcov_global_responsecov_global'><p>Effect response Law-Watkinson model with covariate effects on lambda, effect, and response</p></a></li>
<li><a href='#LW_er_lambdacov_none_effectcov_none_responsecov_none'><p>Effect response Law-Watkinson model without covariate effects</p></a></li>
<li><a href='#LW_pm_alpha_global_lambdacov_none_alphacov_none'><p>Law-Watkinson model with a global alpha and no covariate effects</p></a></li>
<li><a href='#LW_pm_alpha_none_lambdacov_none_alphacov_none'><p>Law-Watkinson model with no alphas and no covariate effects</p></a></li>
<li><a href='#LW_pm_alpha_pairwise_lambdacov_global_alphacov_global'><p>Law-Watkinson model with pairwise alphas and global covariate effects on lambda and alpha</p></a></li>
<li><a href='#LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Law-Watkinson model with pairwise alphas, covariate effects on lambda,</p>
and pairwise covariate effects on alpha</a></li>
<li><a href='#LW_pm_alpha_pairwise_lambdacov_none_alphacov_none'><p>Law-Watkinson model with pairwise alphas and no covariate effects</p></a></li>
<li><a href='#LW_project_alpha_global_lambdacov_none_alphacov_none'><p>Law-Watkinson model for projecting abundances,</p>
with a global alpha and no covariate effects</a></li>
<li><a href='#LW_project_alpha_none_lambdacov_none_alphacov_none'><p>Model for projecting abundances,</p>
with no alpha and no covariate effects</a></li>
<li><a href='#LW_project_alpha_pairwise_lambdacov_global_alphacov_global'><p>Law-Watkinson model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Law-Watkinson model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#LW_project_alpha_pairwise_lambdacov_none_alphacov_none'><p>Law-Watkinson model for projecting abundances,</p>
with specific alpha values and no covariate effects</a></li>
<li><a href='#metapopulation_example_param'><p>Metapopulation dynamics coefficients</p></a></li>
<li><a href='#neigh_list'><p>neighbours and fitness observations</p></a></li>
<li><a href='#niche_overlap'><p>Niche overlap between two species</p></a></li>
<li><a href='#RK_er_lambdacov_global_effectcov_global_responsecov_global'><p>Effect response Beverton-Holt model with covariate effects on lambda, effect, and response</p></a></li>
<li><a href='#RK_er_lambdacov_none_effectcov_none_responsecov_none'><p>Effect response Ricker model without covariate effects</p></a></li>
<li><a href='#RK_pm_alpha_global_lambdacov_none_alphacov_none'><p>Ricker model with a global alpha and no covariate effects</p></a></li>
<li><a href='#RK_pm_alpha_none_lambdacov_none_alphacov_none'><p>Ricker model with no alphas and no covariate effects</p></a></li>
<li><a href='#RK_pm_alpha_pairwise_lambdacov_global_alphacov_global'><p>Ricker model with pairwise alphas and global covariate effects on lambda and alpha</p></a></li>
<li><a href='#RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Ricker model with pairwise alphas, covariate effects on lambda,</p>
and pairwise covariate effects on alpha</a></li>
<li><a href='#RK_pm_alpha_pairwise_lambdacov_none_alphacov_none'><p>Ricker model with pairwise alphas and no covariate effects</p></a></li>
<li><a href='#RK_project_alpha_global_lambdacov_none_alphacov_none'><p>Ricker model for projecting abundances,</p>
with a global alpha and no covariate effects</a></li>
<li><a href='#RK_project_alpha_none_lambdacov_none_alphacov_none'><p>Model for projecting abundances,</p>
with no alpha and no covariate effects</a></li>
<li><a href='#RK_project_alpha_pairwise_lambdacov_global_alphacov_global'><p>Ricker model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'><p>Ricker model for projecting abundances,</p>
with specific alpha values and global covariate effects on alpha and lambda</a></li>
<li><a href='#RK_project_alpha_pairwise_lambdacov_none_alphacov_none'><p>Ricker model for projecting abundances,</p>
with specific alpha values and no covariate effects</a></li>
<li><a href='#salinity_list'><p>Salinity measurements</p></a></li>
<li><a href='#spatial_sampling'><p>spatial arrangement of the observations</p></a></li>
<li><a href='#species_fitness'><p>Fitness of a species</p></a></li>
<li><a href='#species_rates'><p>Species germination and survival rates</p></a></li>
<li><a href='#summary.cxr_er_fit'><p>CXR summary method for effect response model fits</p></a></li>
<li><a href='#summary.cxr_pm_fit'><p>CXR summary method for population model fits</p></a></li>
<li><a href='#summary.cxr_pm_multifit'><p>CXR summary method for multispecies fits</p></a></li>
<li><a href='#vec_permutation_matrices'><p>Generate templates for dispersal, demography, and permutation matrices</p></a></li>
<li><a href='#vital_rate'><p>Vital rate calculation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Toolbox for Modelling Species Coexistence in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Recent developments in modern coexistence theory have
    advanced our understanding on how species are able to persist and
    co-occur with other species at varying abundances. However, applying
    this mathematical framework to empirical data is still challenging,
    precluding a larger adoption of the theoretical tools developed by
    empiricists. This package provides a complete toolbox for modelling
    interaction effects between species, and calculate fitness and niche
    differences.  The functions are flexible, may accept covariates, and
    different fitting algorithms can be used.  A full description of the
    underlying methods is available in García-Callejas, D., Godoy, O., and
    Bartomeus, I. (2020) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13443">doi:10.1111/2041-210X.13443</a>&gt;.  Furthermore, the
    package provides a series of functions to calculate dynamics for
    stage-structured populations across sites.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RadicalCommEcol/cxr">https://github.com/RadicalCommEcol/cxr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RadicalCommEcol/cxr/issues">https://github.com/RadicalCommEcol/cxr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, mvtnorm, optimx, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BB, DEoptimR, dfoptim, dplyr, GenSA, ggplot2, knitr,
magrittr, minqa, nloptr, rmarkdown, stringr, testthat (&ge;
0.8.0), tidyr, ucminf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 10:31:24 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Garcia-Callejas
    <a href="https://orcid.org/0000-0001-6982-476X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Ignasi Bartomeus <a href="https://orcid.org/0000-0001-7893-4389"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Oscar Godoy <a href="https://orcid.org/0000-0003-4988-6626"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Maxime Lancelot [ctb],
  Maria Paniw [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Garcia-Callejas &lt;david.garcia.callejas@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-26 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cxr-package'>cxr: A Toolbox for Modelling Species Coexistence in R</h2><span id='topic+cxr'></span><span id='topic+cxr-package'></span>

<h3>Description</h3>

<p>Recent developments in modern coexistence theory have advanced our understanding on how species are able to persist and co-occur with other species at varying abundances. However, applying this mathematical framework to empirical data is still challenging, precluding a larger adoption of the theoretical tools developed by empiricists. This package provides a complete toolbox for modelling interaction effects between species, and calculate fitness and niche differences. The functions are flexible, may accept covariates, and different fitting algorithms can be used. A full description of the underlying methods is available in García-Callejas, D., Godoy, O., and Bartomeus, I. (2020) <a href="https://doi.org/10.1111/2041-210X.13443">doi:10.1111/2041-210X.13443</a>. Furthermore, the package provides a series of functions to calculate dynamics for stage-structured populations across sites.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Garcia-Callejas <a href="mailto:david.garcia.callejas@gmail.com">david.garcia.callejas@gmail.com</a> (<a href="https://orcid.org/0000-0001-6982-476X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Ignasi Bartomeus <a href="mailto:nacho.bartomeus@gmail.com">nacho.bartomeus@gmail.com</a> (<a href="https://orcid.org/0000-0001-7893-4389">ORCID</a>)
</p>
</li>
<li><p> Oscar Godoy <a href="mailto:ogodoy.re@gmail.com">ogodoy.re@gmail.com</a> (<a href="https://orcid.org/0000-0003-4988-6626">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Maxime Lancelot [contributor]
</p>
</li>
<li><p> Maria Paniw [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/RadicalCommEcol/cxr">https://github.com/RadicalCommEcol/cxr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/RadicalCommEcol/cxr/issues">https://github.com/RadicalCommEcol/cxr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abundance'>Abundance measurements</h2><span id='topic+abundance'></span>

<h3>Description</h3>

<p>A dataset containing abundances for each plant species,
where each species was sampled at its developmental peak.
</p>

<ul>
<li><p> plot: one of 9 plots of the study area
</p>
</li>
<li><p> subplot: one of 36 1x1 m subplots of each plot
</p>
</li>
<li><p> species: plant species
</p>
</li>
<li><p> individuals: number of individuals observed
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(abundance)
</code></pre>


<h3>Format</h3>

<p>A data frame with 5184 rows and 4 variables
</p>


<h3>Note</h3>

<p>For details, see Lanuza et al. 2018 Ecology Letters.
</p>

<hr>
<h2 id='abundance_projection'>Project abundances from population dynamics models</h2><span id='topic+abundance_projection'></span>

<h3>Description</h3>

<p>The function projects a number of steps of a time-discrete model, 
with model parameters taken from a 'cxr_pm_multifit' object or as
function arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abundance_projection(
  cxr_fit = NULL,
  model_family = NULL,
  alpha_form = NULL,
  lambda_cov_form = NULL,
  alpha_cov_form = NULL,
  lambda = NULL,
  alpha_matrix = NULL,
  lambda_cov = NULL,
  alpha_cov = NULL,
  covariates = NULL,
  timesteps = 2,
  initial_abundances = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abundance_projection_+3A_cxr_fit">cxr_fit</code></td>
<td>
<p>object of type 'cxr_pm_multifit'. If this is not specified,
all parameters below are needed.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_model_family">model_family</code></td>
<td>
<p>acronym for model family. Included by default in 'cxr' are
'BH' (Beverton-Holt), 'RK' (Ricker), 'LW' (Law-Watkinson), 'LV' (Lotka-Volterra).</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_alpha_form">alpha_form</code></td>
<td>
<p>character, either &quot;none&quot;,&quot;global&quot;, or &quot;pairwise&quot;.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_lambda_cov_form">lambda_cov_form</code></td>
<td>
<p>character, either &quot;none&quot; or &quot;global&quot;.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_alpha_cov_form">alpha_cov_form</code></td>
<td>
<p>character, either &quot;none&quot;,&quot;global&quot;, or &quot;pairwise&quot;.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_lambda">lambda</code></td>
<td>
<p>named vector with lambda values for all taxa to be projected.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_alpha_matrix">alpha_matrix</code></td>
<td>
<p>square matrix with taxa names in rows and columns.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>optional named matrix with covariates in columns and taxa in rows,
representing the effect of each covariate on the lambda parameter of each taxa.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>optional list. Each element of the named list represents the effects of
a covariate over alpha values. Thus, each list element contains a square matrix 
of the same dimensions as 'alpha_matrix', as returned from the function 'cxr_pm_fit'.
Note that for alpha_cov_form = &quot;global&quot;, all columns in this matrix are the same, as there is 
a single value per species.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_covariates">covariates</code></td>
<td>
<p>matrix or dataframe with covariates in columns and timesteps in rows.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_timesteps">timesteps</code></td>
<td>
<p>number of timesteps to project.</p>
</td></tr>
<tr><td><code id="abundance_projection_+3A_initial_abundances">initial_abundances</code></td>
<td>
<p>named vector of initial abundances for all taxa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named matrix with projected abundance values for each taxa at each timestep.
</p>

<hr>
<h2 id='avg_fitness_diff'>Average fitness differences</h2><span id='topic+avg_fitness_diff'></span>

<h3>Description</h3>

<p>computes the average fitness differences among two or more species according to the formulation
of the MCT (Chesson 2012, Godoy and Levine 2014), and according to the structural approach (Saavedra et al. 2017).
For the MCT version, the average fitness ratio is decomposed in a 'demographic ratio' and a 'competitive response ratio',
the product of which is the average fitness ratio (Godoy and Levine 2014). This formulation is only valid for competitive
interaction coefficients (i.e. positive alpha values in the interaction matrix). The structural analog can be computed
for any interaction matrix, on the other hand. Note that the 'demographic ratio' is model-specific (Hart et al. 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_fitness_diff(
  cxr_multifit = NULL,
  cxr_sp1 = NULL,
  cxr_sp2 = NULL,
  pair_lambdas = NULL,
  pair_matrix = NULL,
  model_family = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_fitness_diff_+3A_cxr_multifit">cxr_multifit</code></td>
<td>
<p>cxr_pm_multifit object, with parameters for a series of species.</p>
</td></tr>
<tr><td><code id="avg_fitness_diff_+3A_cxr_sp1">cxr_sp1</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the first species.</p>
</td></tr>
<tr><td><code id="avg_fitness_diff_+3A_cxr_sp2">cxr_sp2</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the second species.</p>
</td></tr>
<tr><td><code id="avg_fitness_diff_+3A_pair_lambdas">pair_lambdas</code></td>
<td>
<p>numeric vector of length 2 giving lambda values for the two species.</p>
</td></tr>
<tr><td><code id="avg_fitness_diff_+3A_pair_matrix">pair_matrix</code></td>
<td>
<p>2x2 matrix with intra and interspecific interaction
coefficients between the two species.</p>
</td></tr>
<tr><td><code id="avg_fitness_diff_+3A_model_family">model_family</code></td>
<td>
<p>model family for which to calculate fitness differences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as in <code>niche_overlap</code> and <code>competitive_ability</code>, accepts three different parameterizations:
</p>

<ul>
<li><p> A cxr_pm_multifit object, from which average fitness differences will be computed across all species pairs.
</p>
</li>
<li><p> two cxr_pm_fit objects, one for each species.
</p>
</li>
<li><p> explicit lambda and alpha values, as well as the model family from which these parameters were obtained.
</p>
</li></ul>

<p>If using the third parameterization, the function will try to find a model-specific function
for obtaining the demographic ratio, by looking at the 'model_family' parameter.
If this specific function is not found, it will resort to the standard Lotka-Volterra
formulation (lambda in the numerator term).
Overall, we strongly suggest that you use the standard formulation ONLY if you are completely confident
that your custom model is consistent with it.
Otherwise, you should include your own formulation of the demographic ratio (see vignette 4).
</p>


<h3>Value</h3>

<p>data frame with variable number of rows, and columns specifying the different components of the MCT average fitness ratio,
as well as its structural analog. The average fitness ratio informs quantitatively about the better competitor.
If the ratio is &lt; 1, sp2 is the better competitor; if = 1, both species are equivalent competitors, if &gt; 1, sp1 is the better competitor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>avg_fitness_diff(pair_lambdas = runif(2,1,10),
                 pair_matrix = matrix(runif(4,0,1),nrow = 2),
                 model_family = "BH")
</code></pre>

<hr>
<h2 id='BH_er_lambdacov_global_effectcov_global_responsecov_global'>Effect response Beverton-Holt model with covariate effects on lambda, effect, and response</h2><span id='topic+BH_er_lambdacov_global_effectcov_global_responsecov_global'></span>

<h3>Description</h3>

<p>The function for calculating fecundity given 
effect and response values is taken from Godoy et al. (2014). 
Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_er_lambdacov_global_effectcov_global_responsecov_global(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_er_lambdacov_global_effectcov_global_responsecov_global_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,lambda_cov,effect,effect_cov,response,response_cov,sigma</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_global_effectcov_global_responsecov_global_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_global_effectcov_global_responsecov_global_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_global_effectcov_global_responsecov_global_+3A_covariates">covariates</code></td>
<td>
<p>numeric dataframe or matrix with observations 
in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;lambda_cov&quot;,&quot;effect&quot;,&quot;effect_cov&quot;,
&quot;response&quot;,&quot;response_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='BH_er_lambdacov_none_effectcov_none_responsecov_none'>Effect response model without covariate effects</h2><span id='topic+BH_er_lambdacov_none_effectcov_none_responsecov_none'></span>

<h3>Description</h3>

<p>The function for calculating fecundity given 
effect and response values is taken from Godoy et al. (2014). 
Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_er_lambdacov_none_effectcov_none_responsecov_none(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_er_lambdacov_none_effectcov_none_responsecov_none_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,effect,response,sigma.</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations.</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_none_effectcov_none_responsecov_none_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_none_effectcov_none_responsecov_none_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_none_effectcov_none_responsecov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;effect&quot;,&quot;response&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='BH_pm_alpha_global_lambdacov_none_alphacov_none'>Beverton-Holt model with a global alpha and no covariate effects</h2><span id='topic+BH_pm_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Beverton-Holt model with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_pm_alpha_global_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_pm_alpha_global_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, alpha, and sigma.</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale.</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of neighbours for each observation.
As in this model there is a single alpha argument, do not distinguish neighbour identity</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='BH_pm_alpha_none_lambdacov_none_alphacov_none'>Beverton-Holt model with no alphas and no covariate effects</h2><span id='topic+BH_pm_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Beverton-Holt model with no alphas and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_pm_alpha_none_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_pm_alpha_none_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda and sigma</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='BH_pm_alpha_pairwise_lambdacov_global_alphacov_global'>Beverton-Holt model with pairwise alphas and global covariate effects on lambda and alpha</h2><span id='topic+BH_pm_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Beverton-Holt model with pairwise alphas and global covariate effects on lambda and alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_pm_alpha_pairwise_lambdacov_global_alphacov_global(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Beverton-Holt model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha</h2><span id='topic+BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Beverton-Holt model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='BH_pm_alpha_pairwise_lambdacov_none_alphacov_none'>Beverton-Holt model with pairwise alphas and no covariate effects</h2><span id='topic+BH_pm_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Beverton-Holt model with pairwise alphas and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_pm_alpha_pairwise_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: 'lambda', 'alpha_intra' (optional), 'alpha_inter', and 'sigma'</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="BH_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='BH_project_alpha_global_lambdacov_none_alphacov_none'>Beverton-Holt model for projecting abundances,
with a global alpha and no covariate effects</h2><span id='topic+BH_project_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Beverton-Holt model for projecting abundances,
with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_project_alpha_global_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_global_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='BH_project_alpha_none_lambdacov_none_alphacov_none'>Beverton-Holt model for projecting abundances,
with no alpha and no covariate effects</h2><span id='topic+BH_project_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Beverton-Holt model for projecting abundances,
with no alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_project_alpha_none_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_none_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='BH_project_alpha_pairwise_lambdacov_global_alphacov_global'>Beverton-Holt model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+BH_project_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Beverton-Holt model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_project_alpha_pairwise_lambdacov_global_alphacov_global(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of numeric values 
with effects of each covariate over alpha.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Beverton-Holt model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Beverton-Holt model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda">lambda</code></td>
<td>
<p>named numeric lambda value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of named numeric vectors 
with effects of each covariate over alpha values.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in named columns. 
Each cell is the value of a covariate in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='BH_project_alpha_pairwise_lambdacov_none_alphacov_none'>Beverton-Holt model for projecting abundances,
with specific alpha values and no covariate effects</h2><span id='topic+BH_project_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Beverton-Holt model for projecting abundances,
with specific alpha values and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_project_alpha_pairwise_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="BH_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='build_param'>Build param structure</h2><span id='topic+build_param'></span>

<h3>Description</h3>

<p>Builds a nested list for the parameters of a given metapopulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_param(sp, sites, rates, env, num.params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_param_+3A_sp">sp</code></td>
<td>
<p>character vector with species names</p>
</td></tr>
<tr><td><code id="build_param_+3A_sites">sites</code></td>
<td>
<p>character vector with site names</p>
</td></tr>
<tr><td><code id="build_param_+3A_rates">rates</code></td>
<td>
<p>character vector, vital rate names</p>
</td></tr>
<tr><td><code id="build_param_+3A_env">env</code></td>
<td>
<p>boolean, whether environment is accounted for</p>
</td></tr>
<tr><td><code id="build_param_+3A_num.params">num.params</code></td>
<td>
<p>optional, integer giving the number of parameters to account for.
If not specified, it will include environment interactions with all species densities.
E.g. if 3 sp and env = TRUE, there will be 7 params (intercept + 6 betas)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nested list of the form 'list[[sp]][[site]]'. Each of these elements
is a NA matrix with vital rates in rows and expected parameters in columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp &lt;- c("s1","s2","s3")
sites &lt;- c("sa","sb")
rates &lt;- c("Sj","Sn","Sr","Rn","Rr","D","O")
env &lt;- TRUE
param &lt;- build_param(sp = sp,sites = sites,rates = rates,env = env)
</code></pre>

<hr>
<h2 id='calculate_densities'>Obtain species densities from transition matrices</h2><span id='topic+calculate_densities'></span>

<h3>Description</h3>

<p>Using the vec-permutation approach as defined in: 
Hunter and Caswell 2005, doi:10.1016/j.ecolmodel.2005.05.002, 
Ozgul et al. 2009, doi: 10.1086/597225
In particular, it uses the arrangement by patches, and calculates
first demography, then dispersal (Table 1 of Hunter and Caswell 2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_densities(focal.sp, vpm, current.densities)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_densities_+3A_focal.sp">focal.sp</code></td>
<td>
<p>integer, focal species</p>
</td></tr>
<tr><td><code id="calculate_densities_+3A_vpm">vpm</code></td>
<td>
<p>data structure holding all vector-permutation matrices; see 
'vec_permutation_matrices'. If not in an appropriate format, it is likely
to fail without warning.</p>
</td></tr>
<tr><td><code id="calculate_densities_+3A_current.densities">current.densities</code></td>
<td>
<p>list of length sp, each element is a matrix sites*stages. If
not in that format, it is likely to fail without warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of sites x stages, each element is the density of a given life stage
(juvenile, non-reproductive adult, reproductive adult) at a given site.
</p>

<hr>
<h2 id='competitive_ability'>Competitive ability among pairs of species</h2><span id='topic+competitive_ability'></span>

<h3>Description</h3>

<p>Computes the competitive ability among two species, as defined by Hart et al. (2018). This metric, as others in MCT, is
model-specific; the formulation for a series of Lotka-Volterra-like models is given in table A1 of Hart et al. (2018).
We include in <code>cxr</code> by default the formulation for Beverton-Holt, Ricker, Law-Watkinson, and Lotka-Volterra families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>competitive_ability(
  cxr_multifit = NULL,
  cxr_sp1 = NULL,
  cxr_sp2 = NULL,
  lambda = NULL,
  pair_matrix = NULL,
  model_family = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="competitive_ability_+3A_cxr_multifit">cxr_multifit</code></td>
<td>
<p>cxr_pm_multifit object, with parameters for a series of species.</p>
</td></tr>
<tr><td><code id="competitive_ability_+3A_cxr_sp1">cxr_sp1</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the first species.</p>
</td></tr>
<tr><td><code id="competitive_ability_+3A_cxr_sp2">cxr_sp2</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the second species.</p>
</td></tr>
<tr><td><code id="competitive_ability_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value of the focal species.</p>
</td></tr>
<tr><td><code id="competitive_ability_+3A_pair_matrix">pair_matrix</code></td>
<td>
<p>2x2 matrix with intra and interspecific interaction
coefficients between the focal and competitor species.</p>
</td></tr>
<tr><td><code id="competitive_ability_+3A_model_family">model_family</code></td>
<td>
<p>model family for which to calculate competitive ability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function, as in <code>avg_fitness_diff</code> and <code>niche_overlap</code>, accepts three different parameterizations:
</p>

<ul>
<li><p> A cxr_pm_multifit object, from which competitive ability of a focal species relative to a given competitor
will be computed across all species pairs.
</p>
</li>
<li><p> two cxr_pm_fit objects, one for a focal species and one for a competitor.
</p>
</li>
<li><p> explicit lambda and alpha values, as well as the model family from which these parameters were obtained.
</p>
</li></ul>

<p>If the third parameterization is used, the function will try to find a model-specific function
for obtaining the competitive ability, by looking at the 'model_family' parameter.
If this specific function is not found, it will resort to the standard Lotka-Volterra
formulation (lambda - 1 in the numerator term, Hart et al. 2018).
Overall, we strongly suggest that you use the standard formulation ONLY if you are completely confident
that the model from which you obtained your parameters is consistent with it.
Otherwise, you should include your own formulation of competitive ability (see vignette 4).
</p>


<h3>Value</h3>

<p>data frame with variable number of rows and three columns, specifying taxa identity and the competitive ability
of focal species (sp1) relative to the competitor (sp2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>competitive_ability(lambda = runif(1,1,10),
                              pair_matrix = matrix(runif(4,0,1),nrow = 2),
                              model_family = "BH")
</code></pre>

<hr>
<h2 id='cxr_er_bootstrap'>standard error estimates for effect and response parameters</h2><span id='topic+cxr_er_bootstrap'></span>

<h3>Description</h3>

<p>Computes bootstrap standard errors for a given effect/response function.
This function is provided for completeness, but error calculation is
integrated in the function <code>cxr_er_fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxr_er_bootstrap(
  fitness_model,
  optimization_method,
  data,
  covariates,
  init_par,
  lower_bounds,
  upper_bounds,
  fixed_parameters,
  bootstrap_samples
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxr_er_bootstrap_+3A_fitness_model">fitness_model</code></td>
<td>
<p>effect/response function, see <code>cxr_er_fit</code></p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_optimization_method">optimization_method</code></td>
<td>
<p>numerical optimization method.</p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_data">data</code></td>
<td>
<p>either a list of dataframes or a single dataframe. if 'data' is a list, each element is a dataframe with the following columns:
</p>

<ul>
<li><p> fitness: fitness metric for each observation
</p>
</li>
<li><p> neighbours: named columns giving the number of neighbours of each column
the names of the list elements are taken to be the names of the focal species.
</p>
</li></ul>

<p>If 'data' is a dataframe, it also needs a 'focal' column.
Regardless of the data structure, all focal species need to have the same number of observations (i.e. same number of rows),
and the set of neighbour species needs to be the same as the set of focal species, so that
the neighbours columns correspond to the names of the list elements or, if 'data' is a dataframe,
to the values of the 'focal' column. Future versions will relax this requirement.</p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_covariates">covariates</code></td>
<td>
<p>a data structure equivalent to 'data', in which each column are the values of a covariate.</p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_init_par">init_par</code></td>
<td>
<p>initial values for parameters</p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_lower_bounds">lower_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;, &quot;effect&quot;,&quot;response&quot;,
and optionally &quot;lambda_cov&quot;, &quot;effect_cov&quot;, &quot;response_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;, &quot;effect&quot;,&quot;response&quot;,
and optionally &quot;lambda_cov&quot;, &quot;effect_cov&quot;, &quot;response_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>list with values for fixed parameters, or NULL.</p>
</td></tr>
<tr><td><code id="cxr_er_bootstrap_+3A_bootstrap_samples">bootstrap_samples</code></td>
<td>
<p>number of bootstrap samples for error calculation. Defaults to 0, i.e. no error is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1d vector, the standard error of each parameter in init_par
</p>

<hr>
<h2 id='cxr_er_fit'>General optimization for effect-response models</h2><span id='topic+cxr_er_fit'></span>

<h3>Description</h3>

<p>Estimates parameters of user-specified models of competitive effects and responses.
NOTE: including covariates on competitive effects is still under development, in this version it is suggested not to use that feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxr_er_fit(
  data,
  model_family = c("BH"),
  covariates = NULL,
  optimization_method = c("Nelder-Mead", "BFGS", "CG", "ucminf", "L-BFGS-B", "nlm",
    "nlminb", "Rcgmin", "Rvmmin", "spg", "bobyqa", "nmkb", "hjkb", "nloptr_CRS2_LM",
    "nloptr_ISRES", "nloptr_DIRECT_L_RAND", "DEoptimR", "GenSA"),
  lambda_cov_form = c("none", "global"),
  effect_cov_form = c("none", "global"),
  response_cov_form = c("none", "global"),
  initial_values = list(lambda = 1, effect = 1, response = 1, lambda_cov = 0, effect_cov
    = 0, response_cov = 0),
  lower_bounds = NULL,
  upper_bounds = NULL,
  fixed_terms = NULL,
  bootstrap_samples = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxr_er_fit_+3A_data">data</code></td>
<td>
<p>either a list of dataframes or a single dataframe. if 'data' is a list, each element is a dataframe with the following columns:
</p>

<ul>
<li><p> fitness: fitness metric for each observation
</p>
</li>
<li><p> neighbours: named columns giving the number of neighbours of each column
the names of the list elements are taken to be the names of the focal species.
</p>
</li></ul>

<p>If 'data' is a dataframe, it also needs a 'focal' column.
Regardless of the data structure, all focal species need to have the same number of observations (i.e. same number of rows),
and the set of neighbour species needs to be the same as the set of focal species, so that
the neighbours columns correspond to the names of the list elements or, if 'data' is a dataframe,
to the values of the 'focal' column. Future versions will relax this requirement.</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_model_family">model_family</code></td>
<td>
<p>family of model to use. Available families are BH (Beverton-Holt), LV (Lotka-Volterra),
RK (Ricker), and LW (Law-Watkinson). Users may also define their own families and models (see vignette 4).</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_covariates">covariates</code></td>
<td>
<p>a data structure equivalent to 'data', in which each column are the values of a covariate.</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_optimization_method">optimization_method</code></td>
<td>
<p>numerical optimization method.</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_lambda_cov_form">lambda_cov_form</code></td>
<td>
<p>form of the covariate effects on lambda. Either &quot;none&quot; (no covariate effects) or &quot;global&quot; (one estimate per covariate).</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_effect_cov_form">effect_cov_form</code></td>
<td>
<p>form of the covariate effects on competitive effects.
Either &quot;none&quot; (no covariate effects) or &quot;global&quot; (one estimate per covariate)</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_response_cov_form">response_cov_form</code></td>
<td>
<p>form of the covariate effects on competitive responses.
Either &quot;none&quot; (no covariate effects) or &quot;global&quot; (one estimate per covariate)</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_initial_values">initial_values</code></td>
<td>
<p>list with components &quot;lambda&quot;,&quot;effect&quot;,&quot;response&quot;, and optionally
&quot;lambda_cov&quot;, &quot;effect_cov&quot;, &quot;response_cov&quot;, specifying the initial values
for numerical optimization. Single values are allowed.</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_lower_bounds">lower_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;, &quot;effect&quot;,&quot;response&quot;,
and optionally &quot;lambda_cov&quot;, &quot;effect_cov&quot;, &quot;response_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;, &quot;effect&quot;,&quot;response&quot;,
and optionally &quot;lambda_cov&quot;, &quot;effect_cov&quot;, &quot;response_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_fixed_terms">fixed_terms</code></td>
<td>
<p>optional list specifying which model parameters are fixed.</p>
</td></tr>
<tr><td><code id="cxr_er_fit_+3A_bootstrap_samples">bootstrap_samples</code></td>
<td>
<p>number of bootstrap samples for error calculation. Defaults to 0, i.e. no error is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'cxr_er_fit' which is a list with the following components:
</p>

<ul>
<li><p> model_name: string with the name of the fitness model
</p>
</li>
<li><p> model: model function
</p>
</li>
<li><p> data: data supplied
</p>
</li>
<li><p> taxa: names of the taxa fitted
</p>
</li>
<li><p> covariates: covariate data supplied
</p>
</li>
<li><p> optimization_method: optimization method used
</p>
</li>
<li><p> initial_values: list with initial values
</p>
</li>
<li><p> fixed_terms: list with fixed terms
</p>
</li>
<li><p> lambda: fitted values for lambdas, or NULL if fixed
</p>
</li>
<li><p> effect: fitted values for competitive effects, or NULL if fixed
</p>
</li>
<li><p> response: fitted values for competitive responses, or NULL if fixed
</p>
</li>
<li><p> lambda_cov: fitted values for effect of covariates on lambdas, or NULL if fixed
</p>
</li>
<li><p> effect_cov: fitted values for effect of covariates on competitive effects, or NULL if fixed
</p>
</li>
<li><p> response_cov: fitted values for effect of covariates on competitive responses, or NULL if fixed
</p>
</li>
<li><p> lambda_standard_error: standard errors for lambdas, if calculated
</p>
</li>
<li><p> effect_standard_error: standard errors for competitive effects, if calculated
</p>
</li>
<li><p> response_standard_error: standard errors for competitive responses, if calculated
</p>
</li>
<li><p> lambda_cov_standard_error: standard errors for effect of covariates on lambdas, if calculated
</p>
</li>
<li><p> effect_cov_standard_error: standard errors for effect of covariates on competitive effects, if calculated
</p>
</li>
<li><p> response_cov_standard_error: standard errors for effect of covariates on competitive responses, if calculated
</p>
</li>
<li><p> log_likelihood: log-likelihood of the fits
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fit three species at once
data("neigh_list")
# these species all have &gt;250 observations
example_sp &lt;- c("BEMA","LEMA","HOMA")
sp.pos &lt;- which(names(neigh_list) %in% example_sp)
data &lt;- neigh_list[sp.pos]
n.obs &lt;- 250
# keep only fitness and neighbours columns
for(i in 1:length(data)){
  data[[i]] &lt;- data[[i]][1:n.obs,c(2,sp.pos+2)]#2:length(data[[i]])]
}

# covariates: salinity
data("salinity_list")
salinity &lt;- salinity_list[example_sp]
# keep only salinity column
for(i in 1:length(salinity)){
  salinity[[i]] &lt;- salinity[[i]][1:n.obs,2:length(salinity[[i]])]
}

initial_values = list(lambda = 1, 
                     effect = 1, 
                     response = 1
                     # lambda_cov = 0, 
                     # effect_cov = 0, 
                     # response_cov = 0
)
lower_bounds = list(lambda = 0, 
                   effect = 0, 
                   response = 0
                   # lambda_cov = 0, 
                   # effect_cov = 0, 
                   # response_cov = 0
)
upper_bounds = list(lambda = 100, 
                    effect = 10, 
                    response = 10
                   # lambda_cov = 0, 
                   # effect_cov = 0, 
                   # response_cov = 0
)

er_3sp &lt;- cxr_er_fit(data = data,
                     model_family = "BH",
                     # fit without covariates, 
                     # as it may be very computationally expensive
                     # covariates = salinity,
                     optimization_method = "bobyqa",
                     lambda_cov_form = "none",
                     effect_cov_form = "none",
                     response_cov_form = "none",
                     initial_values = initial_values,
                     lower_bounds = lower_bounds,
                     upper_bounds = upper_bounds,
                     # syntaxis for fixed values
                     # fixed_terms = list("response"),
                     bootstrap_samples = 3)
# brief summary
summary(er_3sp)

</code></pre>

<hr>
<h2 id='cxr_generate_test_data'>Generate simulated interaction data</h2><span id='topic+cxr_generate_test_data'></span>

<h3>Description</h3>

<p>Model fitness responses to neighbours and covariates
using a Beverton-Holt functional form. This function
is fairly restricted and under development, but can be used
to generate simple test data to run the main functions of <code>cxr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxr_generate_test_data(
  focal_sp = 1,
  neigh_sp = 1,
  covariates = 0,
  observations = 10,
  alpha_form = c("pairwise", "none", "global"),
  lambda_cov_form = c("none", "global"),
  alpha_cov_form = c("none", "global", "pairwise"),
  focal_lambda = NULL,
  min_lambda = 0,
  max_lambda = 10,
  alpha = NULL,
  min_alpha = 0,
  max_alpha = 1,
  alpha_cov = NULL,
  min_alpha_cov = -1,
  max_alpha_cov = 1,
  lambda_cov = NULL,
  min_lambda_cov = -1,
  max_lambda_cov = 1,
  min_cov = 0,
  max_cov = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxr_generate_test_data_+3A_focal_sp">focal_sp</code></td>
<td>
<p>number of focal species, defaults to 1.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_neigh_sp">neigh_sp</code></td>
<td>
<p>number of neighbour species, defaults to 1.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_covariates">covariates</code></td>
<td>
<p>number of covariates, defaults to 0.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_observations">observations</code></td>
<td>
<p>number of observations, defaults to 10.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_alpha_form">alpha_form</code></td>
<td>
<p>what form does the alpha parameter take? one of &quot;none&quot; (no alpha in the model), 
&quot;global&quot; (a single alpha for all pairwise interactions), or &quot;pairwise&quot; (one alpha value for every interaction).</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_lambda_cov_form">lambda_cov_form</code></td>
<td>
<p>form of the covariate effects on lambda. Either &quot;none&quot; (no covariate effects) or &quot;global&quot; (one estimate per covariate).</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_alpha_cov_form">alpha_cov_form</code></td>
<td>
<p>form of the covariate effects on alpha. One of &quot;none&quot; (no covariate effects), &quot;global&quot; (one estimate per covariate on every alpha),
or &quot;pairwise&quot; (one estimate per covariate and pairwise alpha).</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_focal_lambda">focal_lambda</code></td>
<td>
<p>optional 1d vector with lambdas of the focal sp.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_min_lambda">min_lambda</code></td>
<td>
<p>if no focal_lambda is provided, lambdas are taken from a uniform distribution
with min_lambda and max_lambda as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_max_lambda">max_lambda</code></td>
<td>
<p>if no focal_lambda is provided, lambdas are taken from a uniform distribution
with min_lambda and max_lambda as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_alpha">alpha</code></td>
<td>
<p>optional interaction matrix, neigh_sp x neigh_sp</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_min_alpha">min_alpha</code></td>
<td>
<p>if no focal_alpha is provided, alphas are taken from a uniform distribution
with min_alpha and max_alpha as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_max_alpha">max_alpha</code></td>
<td>
<p>if no focal_alpha is provided, alphas are taken from a uniform distribution
with min_alpha and max_alpha as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>&mdash;&mdash;&mdash;-Under development&mdash;&mdash;&mdash;&mdash;-</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_min_alpha_cov">min_alpha_cov</code></td>
<td>
<p>if no focal_alpha_cov is provided, alpha_covs are taken from a uniform distribution
with min_alpha_cov and max_alpha_cov as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_max_alpha_cov">max_alpha_cov</code></td>
<td>
<p>if no focal_alpha_cov is provided, alpha_covs are taken from a uniform distribution
with min_alpha and max_alpha as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>optional matrix of neigh_sp x covariates
giving the effect of each covariate over the fecundity (lambda) of each species.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_min_lambda_cov">min_lambda_cov</code></td>
<td>
<p>if no focal_lambda_cov is provided, lambda_covs are taken from a uniform distribution
with min_lambda_cov and max_lambda_cov as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_max_lambda_cov">max_lambda_cov</code></td>
<td>
<p>if no focal_lambda_cov is provided, lambda_covs are taken from a uniform distribution
with min_lambda and max_lambda as minimum and maximum values.</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_min_cov">min_cov</code></td>
<td>
<p>minimum value for covariates</p>
</td></tr>
<tr><td><code id="cxr_generate_test_data_+3A_max_cov">max_cov</code></td>
<td>
<p>maximum value for covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two components: 'observations' is a list with as many components as focal species. 
Each component of 'observations' is a dataframe with stochastic number of neighbours and associated fitness.
The second component, 'covariates', is again a list with one component per focal species. 
Each component of 'covariates' is a dataframe with the values of each covariate for each associated observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_obs &lt;- cxr_generate_test_data(focal_sp = 2,
                                      neigh_sp = 2,
                                      alpha_form = "pairwise",
                                      lambda_cov_form = "global",
                                      alpha_cov_form = "global",
                                      covariates = 1)

</code></pre>

<hr>
<h2 id='cxr_pm_bootstrap'>Standard error estimates for model parameters</h2><span id='topic+cxr_pm_bootstrap'></span>

<h3>Description</h3>

<p>Computes bootstrap standard errors for a given population dynamics model.
This function is provided for completeness, but error calculation is
integrated in the function <code>cxr_pm_fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxr_pm_bootstrap(
  fitness_model,
  optimization_method,
  data,
  focal_column,
  covariates,
  init_par,
  lower_bounds,
  upper_bounds,
  fixed_parameters,
  bootstrap_samples
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxr_pm_bootstrap_+3A_fitness_model">fitness_model</code></td>
<td>
<p>function returning a single value to minimize, given a set of parameters and a fitness metric</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_optimization_method">optimization_method</code></td>
<td>
<p>numerical optimization method</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_data">data</code></td>
<td>
<p>dataframe with observations in rows and two sets of columns:
</p>

<ul>
<li><p> fitness: fitness metric for the focal individual
</p>
</li>
<li><p> neighbours: columns with user-defined names with number of neighbours for each group
</p>
</li></ul>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_focal_column">focal_column</code></td>
<td>
<p>optional integer value giving the position, or name, of the column
with neighbours from the same species as the focal one. This is necessary if &quot;alpha_intra&quot; is specified.</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation.</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_init_par">init_par</code></td>
<td>
<p>1d vector of initial parameters</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_lower_bounds">lower_bounds</code></td>
<td>
<p>1d vector of lower bounds</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p>1d vector of upper bounds</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters,
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, and &quot;alpha_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_pm_bootstrap_+3A_bootstrap_samples">bootstrap_samples</code></td>
<td>
<p>how many bootstrap samples to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1d vector, the standard error of each parameter in init_par
</p>

<hr>
<h2 id='cxr_pm_fit'>General optimization for population models</h2><span id='topic+cxr_pm_fit'></span>

<h3>Description</h3>

<p>Estimates parameters of user-specified population dynamics models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxr_pm_fit(
  data,
  focal_column = NULL,
  model_family,
  covariates = NULL,
  optimization_method = c("Nelder-Mead", "BFGS", "CG", "ucminf", "L-BFGS-B", "nlm",
    "nlminb", "Rcgmin", "Rvmmin", "spg", "bobyqa", "nmkb", "hjkb", "nloptr_CRS2_LM",
    "nloptr_ISRES", "nloptr_DIRECT_L_RAND", "DEoptimR", "GenSA"),
  alpha_form = c("none", "global", "pairwise"),
  lambda_cov_form = c("none", "global"),
  alpha_cov_form = c("none", "global", "pairwise"),
  initial_values = list(lambda = 0, alpha_intra = 0, alpha_inter = 0, lambda_cov = 0,
    alpha_cov = 0),
  lower_bounds = NULL,
  upper_bounds = NULL,
  fixed_terms = NULL,
  bootstrap_samples = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxr_pm_fit_+3A_data">data</code></td>
<td>
<p>dataframe with observations in rows and two sets of columns:
</p>

<ul>
<li><p> fitness: fitness metric for the focal individual
</p>
</li>
<li><p> neighbours: numeric columns with user-defined names, giving number of neighbours for each group
</p>
</li></ul>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_focal_column">focal_column</code></td>
<td>
<p>optional integer or character giving the column
with neighbours from the same species as the focal one. This field is necessary if &quot;alpha_intra&quot; is specified
in <code>initial_values</code>, <code>lower_bounds</code>, <code>upper_bounds</code>, or <code>fixed_terms</code>.</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_model_family">model_family</code></td>
<td>
<p>family of model to use. Available families are BH (Beverton-Holt), LV (Lotka-Volterra),
RK (Ricker), and LW (Law-Watkinson). Users may also define their own families and models (see vignette 4).</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_covariates">covariates</code></td>
<td>
<p>optional named matrix or dataframe with observations (rows) of any number of environmental covariates (columns).</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_optimization_method">optimization_method</code></td>
<td>
<p>numerical optimization method.</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_alpha_form">alpha_form</code></td>
<td>
<p>what form does the alpha parameter take? one of &quot;none&quot; (no alpha in the model),
&quot;global&quot; (a single alpha for all pairwise interactions), or &quot;pairwise&quot; (one alpha value for every interaction).</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_lambda_cov_form">lambda_cov_form</code></td>
<td>
<p>form of the covariate effects on lambda. Either &quot;none&quot; (no covariate effects) or &quot;global&quot; (one estimate per covariate).</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_alpha_cov_form">alpha_cov_form</code></td>
<td>
<p>form of the covariate effects on alpha. One of &quot;none&quot; (no covariate effects), &quot;global&quot; (one estimate per covariate on every alpha),
or &quot;pairwise&quot; (one estimate per covariate and pairwise alpha)</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_initial_values">initial_values</code></td>
<td>
<p>list with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, &quot;alpha_cov&quot;, specifying the initial values
for numerical optimization. Single values are allowed.</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_lower_bounds">lower_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, &quot;alpha_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, &quot;alpha_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_fixed_terms">fixed_terms</code></td>
<td>
<p>optional list of numeric vectors specifying the value of fixed model parameters, among
&quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, and &quot;alpha_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_pm_fit_+3A_bootstrap_samples">bootstrap_samples</code></td>
<td>
<p>number of bootstrap samples for error calculation. Defaults to 0, i.e. no error is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'cxr_pm_fit' which is a list with the following components:
</p>

<ul>
<li><p> model_name: string with the name of the fitness model
</p>
</li>
<li><p> model: model function
</p>
</li>
<li><p> data: data supplied
</p>
</li>
<li><p> focal_ID: name/ID of the focal taxa, if provided in 'focal_column'
</p>
</li>
<li><p> covariates: covariate data supplied
</p>
</li>
<li><p> optimization_method: optimization method used
</p>
</li>
<li><p> initial_values: list with initial values
</p>
</li>
<li><p> fixed_terms: list with fixed terms
</p>
</li>
<li><p> lambda: fitted value for lambda, or NULL if fixed
</p>
</li>
<li><p> alpha_intra: fitted value for intraspecific alpha, or NULL if fixed
</p>
</li>
<li><p> alpha_inter: fitted value for interspecific alpha, or NULL if fixed
</p>
</li>
<li><p> lambda_cov: fitted value(s) for lambda_cov, or NULL if fixed.
</p>
</li>
<li><p> alpha_cov: fitted value(s) for alpha_cov, or NULL if fixed.
These are structured as a list with one element for each covariate.
</p>
</li>
<li><p> lambda_standard_error: standard error for lambda, if computed
</p>
</li>
<li><p> alpha_intra_standard_error: standard error for intraspecific alpha, if computed
</p>
</li>
<li><p> alpha_inter_standard_error: standard error for interspecific alpha, if computed
</p>
</li>
<li><p> lambda_cov_standard_error: standard error for lambda_cov, if computed
</p>
</li>
<li><p> alpha_cov_standard_error: standard error for alpha_cov, if computed
</p>
</li>
<li><p> log_likelihood: log-likelihood of the fit
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("neigh_list")
my.sp &lt;- "BEMA"
# data for a single species, keep only fitness and neighbours columns
sp_data &lt;- neigh_list[[my.sp]][2:ncol(neigh_list[[1]])]

  sp_fit &lt;- cxr_pm_fit(data = sp_data,
                       focal_column = my.sp,
                       optimization_method = "bobyqa",
                       model_family = "BH",
                       alpha_form = "pairwise",
                       lambda_cov_form = "none",
                       alpha_cov_form = "none",
                       initial_values = list(lambda = 1,alpha_intra = 0.1,alpha_inter = 0.1),
                       lower_bounds = list(lambda = 0,alpha_intra = 0,alpha_inter = 0),
                       upper_bounds = list(lambda = 100,alpha_intra = 1,alpha_inter = 1),
                       bootstrap_samples = 3)
  summary(sp_fit)


</code></pre>

<hr>
<h2 id='cxr_pm_multifit'>Multi-species parameter optimization</h2><span id='topic+cxr_pm_multifit'></span>

<h3>Description</h3>

<p>This function is a wrapper for estimating parameters for several
focal species, instead of making separate calls to <code>cxr_pm_fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxr_pm_multifit(
  data,
  model_family = c("BH"),
  focal_column = NULL,
  covariates = NULL,
  optimization_method = c("BFGS", "CG", "Nelder-Mead", "ucminf", "L-BFGS-B", "nlm",
    "nlminb", "Rcgmin", "Rvmmin", "spg", "bobyqa", "nmkb", "hjkb", "nloptr_CRS2_LM",
    "nloptr_ISRES", "nloptr_DIRECT_L_RAND", "DEoptimR", "GenSA"),
  alpha_form = c("none", "global", "pairwise"),
  lambda_cov_form = c("none", "global"),
  alpha_cov_form = c("none", "global", "pairwise"),
  initial_values = NULL,
  lower_bounds = NULL,
  upper_bounds = NULL,
  fixed_terms = NULL,
  bootstrap_samples = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxr_pm_multifit_+3A_data">data</code></td>
<td>
<p>named list in which each component is
a dataframe with a fitness column and a number of columns representing neighbours</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_model_family">model_family</code></td>
<td>
<p>family of model to use. Available families are BH (Beverton-Holt), LV (Lotka-Volterra),
RK (Ricker), and LW (Law-Watkinson). Users may also define their own families and models (see vignette 4).</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_focal_column">focal_column</code></td>
<td>
<p>character vector with the same length as data,
giving the names of the columns representing
intraspecific observations for each species,
or numeric vector giving the position of such columns.</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_covariates">covariates</code></td>
<td>
<p>optional named list in which each component is
a dataframe with values of each covariate for each observation. The ith component
of <code>covariates</code> are the covariate values that correspond to
the ith component of <code>data</code>, so they must have the same number of observations.</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_optimization_method">optimization_method</code></td>
<td>
<p>numerical optimization method.</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_alpha_form">alpha_form</code></td>
<td>
<p>what form does the alpha parameter take? one of &quot;none&quot; (no alpha in the model),
&quot;global&quot; (a single alpha for all pairwise interactions), or &quot;pairwise&quot; (one alpha value for every interaction).</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_lambda_cov_form">lambda_cov_form</code></td>
<td>
<p>form of the covariate effects on lambda. Either &quot;none&quot; (no covariate effects) or &quot;global&quot; (one estimate per covariate).</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_alpha_cov_form">alpha_cov_form</code></td>
<td>
<p>form of the covariate effects on alpha. One of &quot;none&quot; (no covariate effects), &quot;global&quot; (one estimate per covariate on every alpha),
or &quot;pairwise&quot; (one estimate per covariate and pairwise alpha)</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_initial_values">initial_values</code></td>
<td>
<p>list with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, &quot;alpha_cov&quot;, specifying the initial values
for numerical optimization. Single values are allowed.</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_lower_bounds">lower_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, &quot;alpha_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p>optional list with single values for &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;, &quot;alpha_cov&quot;.</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_fixed_terms">fixed_terms</code></td>
<td>
<p>optional named list in which each component is
itself a list containing fixed terms for each focal species.</p>
</td></tr>
<tr><td><code id="cxr_pm_multifit_+3A_bootstrap_samples">bootstrap_samples</code></td>
<td>
<p>number of bootstrap samples for error calculation. Defaults to 0, i.e. no error is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'cxr_pm_multifit' which is a list with the following components:
</p>

<ul>
<li><p> model_name: string with the name of the fitness model
</p>
</li>
<li><p> model: model function
</p>
</li>
<li><p> data: data supplied
</p>
</li>
<li><p> taxa: names of the taxa fitted
</p>
</li>
<li><p> covariates: covariate data supplied
</p>
</li>
<li><p> optimization_method: optimization method used
</p>
</li>
<li><p> initial_values: list with initial values
</p>
</li>
<li><p> fixed_terms: list with fixed terms
</p>
</li>
<li><p> lambda: fitted values for lambda, or NULL if fixed
</p>
</li>
<li><p> alpha_intra: fitted values for alpha_intra, or NULL if fixed
</p>
</li>
<li><p> alpha_inter: fitted values for alpha_inter, or NULL if fixed
</p>
</li>
<li><p> lambda_cov: fitted values for lambda_cov, or NULL if fixed
</p>
</li>
<li><p> alpha_cov: fitted values for alpha_cov, or NULL if fixed
</p>
</li>
<li><p> lambda_standard_error: standard errors for lambda, if computed
</p>
</li>
<li><p> alpha_standard_error: standard errors for alpha, if computed
</p>
</li>
<li><p> lambda_cov_standard_error: standard errors for lambda_cov, if computed
</p>
</li>
<li><p> alpha_cov_standard_error: standard errors for alpha_cov, if computed
</p>
</li>
<li><p> log_likelihood: log-likelihoods of the fits
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># fit three species at once
data("neigh_list")
data &lt;- neigh_list[1:3]
# keep only fitness and neighbours columns
for(i in 1:length(data)){
  data[[i]] &lt;- data[[i]][,2:length(data[[i]])]
}
# be explicit about the focal species
focal.sp &lt;- names(data)
# covariates: salinity
data("salinity_list")
salinity &lt;- salinity_list[1:3]
# keep only salinity column
for(i in 1:length(salinity)){
  salinity[[i]] &lt;- data.frame(salinity = salinity[[i]][,2:length(salinity[[i]])])
}

  fit_3sp &lt;- cxr_pm_multifit(data = data,
                             optimization_method = "bobyqa",
                             model_family = "BH",
                             focal_column = focal.sp,
                             covariates = salinity,
                             alpha_form = "pairwise",
                             lambda_cov_form = "global",
                             alpha_cov_form = "global",
                             initial_values = list(lambda = 1,
                                                   alpha_intra = 0.1,
                                                   alpha_inter = 0.1,
                                                   lambda_cov = 0.1, 
                                                   alpha_cov = 0.1),
                             lower_bounds = list(lambda = 0.01,
                                                 alpha_intra = 0,
                                                 alpha_inter = 0,
                                                 lambda_cov = 0, 
                                                 alpha_cov = 0),
                             upper_bounds = list(lambda = 100,
                                                 alpha_intra = 1,
                                                 alpha_inter = 1,
                                                 lambda_cov = 1, 
                                                 alpha_cov = 1),
                             bootstrap_samples = 3)
  # brief summary
  summary(fit_3sp)
  # interaction matrix
  fit_3sp$alpha_matrix

</code></pre>

<hr>
<h2 id='densities_to_df'>Converts a densities list to a tidy dataframe</h2><span id='topic+densities_to_df'></span>

<h3>Description</h3>

<p>Converts a densities list to a tidy dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densities_to_df(densities)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densities_to_df_+3A_densities">densities</code></td>
<td>
<p>list, species (optionally x year) with each element holding 
a sites x stages matrix. This function assumes three life stages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with columns species-stage-site(-year)-density
</p>

<hr>
<h2 id='fill_demography_matrix'>Fill the vec-permutation demography matrix</h2><span id='topic+fill_demography_matrix'></span>

<h3>Description</h3>

<p>Fill for a given species, across all sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_demography_matrix(focal.sp, vpm, transition_matrices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_demography_matrix_+3A_focal.sp">focal.sp</code></td>
<td>
<p>integer, focal species.</p>
</td></tr>
<tr><td><code id="fill_demography_matrix_+3A_vpm">vpm</code></td>
<td>
<p>data structure holding all vector-permutation matrices; see 
'vec_permutation_matrices'. If not in an appropriate format, it is likely
to fail without warning.</p>
</td></tr>
<tr><td><code id="fill_demography_matrix_+3A_transition_matrices">transition_matrices</code></td>
<td>
<p>nested list species x sites, in which each element
holds a 3x3 transition matrix. If not in that format, it is likely to fail
without warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vec-permutation demography matrix for a given species across sites.
</p>

<hr>
<h2 id='fill_dispersal_matrix'>Fill the vec-permutation dispersal matrix</h2><span id='topic+fill_dispersal_matrix'></span>

<h3>Description</h3>

<p>Fill for a given species, all sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_dispersal_matrix(
  focal.sp,
  num.sites,
  param,
  vpm,
  env = NULL,
  current.densities
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_dispersal_matrix_+3A_focal.sp">focal.sp</code></td>
<td>
<p>integer, focal species</p>
</td></tr>
<tr><td><code id="fill_dispersal_matrix_+3A_num.sites">num.sites</code></td>
<td>
<p>integer, how many sites</p>
</td></tr>
<tr><td><code id="fill_dispersal_matrix_+3A_param">param</code></td>
<td>
<p>param nested list,see 'build_param' function</p>
</td></tr>
<tr><td><code id="fill_dispersal_matrix_+3A_vpm">vpm</code></td>
<td>
<p>data structure holding all vector-permutation matrices; see 
'vec_permutation_matrices'</p>
</td></tr>
<tr><td><code id="fill_dispersal_matrix_+3A_env">env</code></td>
<td>
<p>optional numeric, environmental forcing for a given timestep</p>
</td></tr>
<tr><td><code id="fill_dispersal_matrix_+3A_current.densities">current.densities</code></td>
<td>
<p>list of length sp, each element is a matrix sites*stages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dispersal matrix, stages*sites
</p>

<hr>
<h2 id='fill_transition_matrix'>Fill a transition matrix</h2><span id='topic+fill_transition_matrix'></span>

<h3>Description</h3>

<p>Calculates the elements of a site-specific transition matrix for a given sp.
Note that here, and through all functions, we fix three life stages.
Also note that 'param' and 'env' must match, as for the 'vital_rate' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_transition_matrix(focal.sp, site, param, env = NULL, current.densities)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_transition_matrix_+3A_focal.sp">focal.sp</code></td>
<td>
<p>integer, species</p>
</td></tr>
<tr><td><code id="fill_transition_matrix_+3A_site">site</code></td>
<td>
<p>integer, site</p>
</td></tr>
<tr><td><code id="fill_transition_matrix_+3A_param">param</code></td>
<td>
<p>param structure (see 'build_param' function)</p>
</td></tr>
<tr><td><code id="fill_transition_matrix_+3A_env">env</code></td>
<td>
<p>optional numeric, environmental forcing for a given timestep</p>
</td></tr>
<tr><td><code id="fill_transition_matrix_+3A_current.densities">current.densities</code></td>
<td>
<p>list of length sp, each element is a matrix site*stages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3x3 transition matrix
</p>

<hr>
<h2 id='fitness_ratio'>Fitness ratio among two or more species</h2><span id='topic+fitness_ratio'></span>

<h3>Description</h3>

<p>Fitness ratio among two or more species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitness_ratio(
  effect_response_fit = NULL,
  fitness_sp1 = NULL,
  fitness_sp2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitness_ratio_+3A_effect_response_fit">effect_response_fit</code></td>
<td>
<p>cxr_er_fit object</p>
</td></tr>
<tr><td><code id="fitness_ratio_+3A_fitness_sp1">fitness_sp1</code></td>
<td>
<p>numeric value representing the fitness (a.k.a. competitive ability) of the first taxa</p>
</td></tr>
<tr><td><code id="fitness_ratio_+3A_fitness_sp2">fitness_sp2</code></td>
<td>
<p>numeric value representing the fitness (a.k.a. competitive ability) of the second taxa</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a matrix with fitness ratios for all pairs of fitted species, or a single numeric value.
The matrix elements represent the ratios of species in columns over species in rows, and conversely, 
the numeric value represents the ratio of sp1 over sp2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitness_ratio(fitness_sp1 = 0.6, fitness_sp2 = 0.3)
</code></pre>

<hr>
<h2 id='generate_vital_rate_coefs'>Generate coefficients for obtaining vital rates</h2><span id='topic+generate_vital_rate_coefs'></span>

<h3>Description</h3>

<p>Any vital rate is a function of several parameters, potentially including
interactions or environmental effects. This function generates the coefficients
for these parameters, so that users do not have to introduce them all manually
in a 'param' list. Coefficients can be generated from a random sampling of
a normal distribution with specified mean and standard deviation, 
or they can be retrieved from a model object that accepts a 'tidy' function
from the broom/broom.mixed packages. This is because coefficients for 
vital rates can be understood as coefficients from statistical regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_vital_rate_coefs(
  param,
  sp = NULL,
  sites = NULL,
  vital.rate = NULL,
  vr.coef = NULL,
  mean.coef = NULL,
  sd.coef = NULL,
  glm.object = NULL,
  glm.coef.equivalence = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_vital_rate_coefs_+3A_param">param</code></td>
<td>
<p>the original list with the structure of species, sites, 
vital rates to calculate, and parameters affecting them. See the function 'build_param'</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_sp">sp</code></td>
<td>
<p>number or character of the species to calculate coefficients for. If empty, all species are assumed.</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_sites">sites</code></td>
<td>
<p>number or character of the sites to calculate coefficients for. If empty, all sites are assumed.</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_vital.rate">vital.rate</code></td>
<td>
<p>character giving the vital rate to calculate coefficients for. If empty, all vital rates are assumed.</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_vr.coef">vr.coef</code></td>
<td>
<p>character giving a specific coefficient to calculate. If empty, all coefficients are assumed.</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_mean.coef">mean.coef</code></td>
<td>
<p>optional numeric value, mean for sampling coefficient values</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_sd.coef">sd.coef</code></td>
<td>
<p>optional numeric value, standard deviation for sampling coefficient values</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_glm.object">glm.object</code></td>
<td>
<p>optional model object/coef table</p>
</td></tr>
<tr><td><code id="generate_vital_rate_coefs_+3A_glm.coef.equivalence">glm.coef.equivalence</code></td>
<td>
<p>if a glm table is provided and its names differ from the 'param' data structure, 
you can include a named list in which names are the names from 'param' and its elements are the equivalent names from the glm table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the current version, we assume that the model coefficients come from a
logistic regression with binomial family. Otherwise, the function will probably not fail,
but the coefficients will not be interpretable and the results in terms of obtaining the actual
vital rates from these will be meaningless.
</p>
<p>Also note that you need to take care manually of the signs of the coefficients,
if entered through mean/sd pairs.
</p>


<h3>Value</h3>

<p>the updated parameter list
</p>

<hr>
<h2 id='glm_example_coefs'>Generalized linear model coefficients</h2><span id='topic+glm_example_coefs'></span>

<h3>Description</h3>

<p>A table with coefficients from a GLM to serve as an example for importing
into the data structure of the metapopulation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glm_example_coefs)
</code></pre>


<h3>Format</h3>

<p>A named numerical matrix of 8 rows and 4 columns
</p>

<hr>
<h2 id='LV_er_lambdacov_global_effectcov_global_responsecov_global'>Effect response Lotka-Volterra model with covariate effects on lambda, effect, and response</h2><span id='topic+LV_er_lambdacov_global_effectcov_global_responsecov_global'></span>

<h3>Description</h3>

<p>Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_er_lambdacov_global_effectcov_global_responsecov_global(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_er_lambdacov_global_effectcov_global_responsecov_global_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,lambda_cov,effect,effect_cov,response,response_cov,sigma</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_global_effectcov_global_responsecov_global_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_global_effectcov_global_responsecov_global_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_global_effectcov_global_responsecov_global_+3A_covariates">covariates</code></td>
<td>
<p>numeric dataframe or matrix with observations 
in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;lambda_cov&quot;,&quot;effect&quot;,&quot;effect_cov&quot;,
&quot;response&quot;,&quot;response_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LV_er_lambdacov_none_effectcov_none_responsecov_none'>Effect response Lotka-Volterra model without covariate effects</h2><span id='topic+LV_er_lambdacov_none_effectcov_none_responsecov_none'></span>

<h3>Description</h3>

<p>Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_er_lambdacov_none_effectcov_none_responsecov_none(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_er_lambdacov_none_effectcov_none_responsecov_none_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,effect,response,sigma.</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations.</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_none_effectcov_none_responsecov_none_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_none_effectcov_none_responsecov_none_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_none_effectcov_none_responsecov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;effect&quot;,&quot;response&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LV_pm_alpha_global_lambdacov_none_alphacov_none'>Lotka-Volterra model with a global alpha and no covariate effects</h2><span id='topic+LV_pm_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Lotka-Volterra model with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_pm_alpha_global_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_pm_alpha_global_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, alpha, and sigma.</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale.</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of neighbours for each observation.
As in this model there is a single alpha argument, do not distinguish neighbour identity</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LV_pm_alpha_none_lambdacov_none_alphacov_none'>Lotka-Volterra model with no alphas and no covariate effects</h2><span id='topic+LV_pm_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>This model, in all families, is simply given by lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_pm_alpha_none_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_pm_alpha_none_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda and sigma</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LV_pm_alpha_pairwise_lambdacov_global_alphacov_global'>Lotka-Volterra model with pairwise alphas and global covariate effects on lambda and alpha</h2><span id='topic+LV_pm_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Lotka-Volterra model with pairwise alphas and global covariate effects on lambda and alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_pm_alpha_pairwise_lambdacov_global_alphacov_global(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Lotka-Volterra model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha</h2><span id='topic+LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Lotka-Volterra model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LV_pm_alpha_pairwise_lambdacov_none_alphacov_none'>Lotka-Volterra model with pairwise alphas and no covariate effects</h2><span id='topic+LV_pm_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Lotka-Volterra model with pairwise alphas and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_pm_alpha_pairwise_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: 'lambda', 'alpha_intra' (optional), 'alpha_inter', and 'sigma'</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="LV_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LV_project_alpha_global_lambdacov_none_alphacov_none'>Lotka-Volterra model for projecting abundances,
with a global alpha and no covariate effects</h2><span id='topic+LV_project_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Lotka-Volterra model for projecting abundances,
with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_project_alpha_global_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_global_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LV_project_alpha_none_lambdacov_none_alphacov_none'>Model for projecting abundances,
with no alpha and no covariate effects</h2><span id='topic+LV_project_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Model for projecting abundances,
with no alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_project_alpha_none_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_none_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LV_project_alpha_pairwise_lambdacov_global_alphacov_global'>Lotka-Volterra model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+LV_project_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Lotka-Volterra model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_project_alpha_pairwise_lambdacov_global_alphacov_global(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of numeric values 
with effects of each covariate over alpha.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Lotka-Volterra model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Lotka-Volterra model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda">lambda</code></td>
<td>
<p>named numeric lambda value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of named numeric vectors 
with effects of each covariate over alpha values.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in named columns. 
Each cell is the value of a covariate in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LV_project_alpha_pairwise_lambdacov_none_alphacov_none'>Lotka-Volterra model for projecting abundances,
with specific alpha values and no covariate effects</h2><span id='topic+LV_project_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Lotka-Volterra model for projecting abundances,
with specific alpha values and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LV_project_alpha_pairwise_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LV_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LW_er_lambdacov_global_effectcov_global_responsecov_global'>Effect response Law-Watkinson model with covariate effects on lambda, effect, and response</h2><span id='topic+LW_er_lambdacov_global_effectcov_global_responsecov_global'></span>

<h3>Description</h3>

<p>Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_er_lambdacov_global_effectcov_global_responsecov_global(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_er_lambdacov_global_effectcov_global_responsecov_global_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,lambda_cov,effect,effect_cov,response,response_cov,sigma</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_global_effectcov_global_responsecov_global_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_global_effectcov_global_responsecov_global_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_global_effectcov_global_responsecov_global_+3A_covariates">covariates</code></td>
<td>
<p>numeric dataframe or matrix with observations 
in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;lambda_cov&quot;,&quot;effect&quot;,&quot;effect_cov&quot;,
&quot;response&quot;,&quot;response_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LW_er_lambdacov_none_effectcov_none_responsecov_none'>Effect response Law-Watkinson model without covariate effects</h2><span id='topic+LW_er_lambdacov_none_effectcov_none_responsecov_none'></span>

<h3>Description</h3>

<p>Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_er_lambdacov_none_effectcov_none_responsecov_none(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_er_lambdacov_none_effectcov_none_responsecov_none_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,effect,response,sigma.</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations.</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_none_effectcov_none_responsecov_none_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_none_effectcov_none_responsecov_none_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_none_effectcov_none_responsecov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;effect&quot;,&quot;response&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LW_pm_alpha_global_lambdacov_none_alphacov_none'>Law-Watkinson model with a global alpha and no covariate effects</h2><span id='topic+LW_pm_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Law-Watkinson model with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_pm_alpha_global_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_pm_alpha_global_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, alpha, and sigma.</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale.</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of neighbours for each observation.
As in this model there is a single alpha argument, do not distinguish neighbour identity</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LW_pm_alpha_none_lambdacov_none_alphacov_none'>Law-Watkinson model with no alphas and no covariate effects</h2><span id='topic+LW_pm_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>This model, in all families, is simply given by lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_pm_alpha_none_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_pm_alpha_none_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda and sigma</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LW_pm_alpha_pairwise_lambdacov_global_alphacov_global'>Law-Watkinson model with pairwise alphas and global covariate effects on lambda and alpha</h2><span id='topic+LW_pm_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Law-Watkinson model with pairwise alphas and global covariate effects on lambda and alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_pm_alpha_pairwise_lambdacov_global_alphacov_global(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Law-Watkinson model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha</h2><span id='topic+LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Law-Watkinson model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LW_pm_alpha_pairwise_lambdacov_none_alphacov_none'>Law-Watkinson model with pairwise alphas and no covariate effects</h2><span id='topic+LW_pm_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Law-Watkinson model with pairwise alphas and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_pm_alpha_pairwise_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: 'lambda', 'alpha_intra' (optional), 'alpha_inter', and 'sigma'</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="LW_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='LW_project_alpha_global_lambdacov_none_alphacov_none'>Law-Watkinson model for projecting abundances,
with a global alpha and no covariate effects</h2><span id='topic+LW_project_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Law-Watkinson model for projecting abundances,
with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_project_alpha_global_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_global_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LW_project_alpha_none_lambdacov_none_alphacov_none'>Model for projecting abundances,
with no alpha and no covariate effects</h2><span id='topic+LW_project_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Model for projecting abundances,
with no alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_project_alpha_none_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_none_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LW_project_alpha_pairwise_lambdacov_global_alphacov_global'>Law-Watkinson model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+LW_project_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Law-Watkinson model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_project_alpha_pairwise_lambdacov_global_alphacov_global(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of numeric values 
with effects of each covariate over alpha.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Law-Watkinson model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Law-Watkinson model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda">lambda</code></td>
<td>
<p>named numeric lambda value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of named numeric vectors 
with effects of each covariate over alpha values.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in named columns. 
Each cell is the value of a covariate in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='LW_project_alpha_pairwise_lambdacov_none_alphacov_none'>Law-Watkinson model for projecting abundances,
with specific alpha values and no covariate effects</h2><span id='topic+LW_project_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Law-Watkinson model for projecting abundances,
with specific alpha values and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LW_project_alpha_pairwise_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="LW_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='metapopulation_example_param'>Metapopulation dynamics coefficients</h2><span id='topic+metapopulation_example_param'></span>

<h3>Description</h3>

<p>A nested list containing vital rate coefficients for projecting
metapopulation dynamics.
The first level of the list has 3 elements, one for each species modelled.
The second level of the list has 2 elements, one for each site modelled.
For each combination species-site, there is a data.frame of eight rows -
one per each vital rate, and eight columns - one per coefficient, that
correspond to the coefficients of a GLM. These are named as <code>alpha</code>,<code>beta1</code>,
etc, in the data.frame, and correspond to the intercept, environmental effect,
effects of each of the three species' density, and environment:density interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(metapopulation_example_param)
</code></pre>


<h3>Format</h3>

<p>A nested list with 3x2 elements, each of which a dataframe
of 8 rows and 8 numeric columns
</p>

<hr>
<h2 id='neigh_list'>neighbours and fitness observations</h2><span id='topic+neigh_list'></span>

<h3>Description</h3>

<p>A dataset containing fitness and neighbours
for plant individuals of 17 species.
The dataset is a named list with 16 elements,
each of which is a dataframe with the following columns:
</p>

<ul>
<li><p> obs_ID: unique identifier for each observation
</p>
</li>
<li><p> fitness: number of viable seeds of the focal individual
</p>
</li>
<li><p> 17 columns indicating the number of neighbours from each plant sp.
in a radius of 7.5 cm from the focal individual
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(neigh_list)
</code></pre>


<h3>Format</h3>

<p>A list with 17 elements, each of which a dataframe
of variable number of rows and 18 columns
</p>


<h3>Note</h3>

<p>For details, see Lanuza et al. 2018 Ecology Letters.
</p>

<hr>
<h2 id='niche_overlap'>Niche overlap between two species</h2><span id='topic+niche_overlap'></span>

<h3>Description</h3>

<p>quoting Godoy et al. (2014):
reflects the average degree to which species limit individuals of their own species relative to competitors.
Low niche overlap causes species to have greater per capita growth rates when rare than when common.
If species limit individuals of their own species and their competitors equally, then niche overlap is 1,
and coexistence is not possible unless species are otherwise identical.
At the other extreme, if species have no interspecific effects, then niche overlap is 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niche_overlap(
  cxr_multifit = NULL,
  cxr_sp1 = NULL,
  cxr_sp2 = NULL,
  pair_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niche_overlap_+3A_cxr_multifit">cxr_multifit</code></td>
<td>
<p>cxr_pm_multifit object, with parameters for a series of species.</p>
</td></tr>
<tr><td><code id="niche_overlap_+3A_cxr_sp1">cxr_sp1</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the first species.</p>
</td></tr>
<tr><td><code id="niche_overlap_+3A_cxr_sp2">cxr_sp2</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the second species.</p>
</td></tr>
<tr><td><code id="niche_overlap_+3A_pair_matrix">pair_matrix</code></td>
<td>
<p>2x2 matrix with intra and interspecific interaction
coefficients between the two species.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Niche overlap has a common functional form, in the context of Modern Coexistence Theory (MCT),
for a series of models, including those specified in table A1 of
Hart et al. (2018) Journal of Ecology 106, 1902-1909.
Other model families may not adhere to the general definition.
</p>
<p>Furthermore, the MCT definition only accounts for competitive interactions (i.e. positive alpha coefficients
in these models). An alternative definition is given in Saavedra et al. (2017) Ecological Monographs 87,470-486.
In this 'structural approach', positive interactions are allowed. Incidentally, both approaches yield
qualitatively similar, but not equivalent, results for purely competitive matrices.
</p>
<p>In all cases, these definitions only apply to models whose feasible equilibrium point can be described by a
linear equation (see Saavedra et al. 2017, Hart et al. 2018 for details).
</p>
<p>This function calculates niche overlap among two or more taxa, using both the MCT and the structural formulation.
The function, as in <code>avg_fitness_diff</code> and <code>competitive_ability</code>, accepts three different parameterizations:
</p>

<ul>
<li><p> A cxr_pm_multifit object, from which niche overlap will be computed across all species pairs.
</p>
</li>
<li><p> two cxr_pm_fit objects, one for each species.
</p>
</li>
<li><p> explicit lambda and alpha values, as well as the model family from which these parameters were obtained.
</p>
</li></ul>

<p>If negative interactions are present, the MCT niche overlap will be NA.
The cxr objects may be calculated with user-defined model families. If this is the case, or
if simply a 2x2 matrix is provided, the niche overlap metrics will be calculated and
a warning will be raised.
</p>


<h3>Value</h3>

<p>either a dataframe with as many rows as species, or a single named numeric vector,
containing niche overlap values for the MCT (modern coexistence theory) and SA (structural approach)
formulations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>niche_overlap(pair_matrix = matrix(c(0.33,0.12,0.2,0.4),nrow = 2))

</code></pre>

<hr>
<h2 id='RK_er_lambdacov_global_effectcov_global_responsecov_global'>Effect response Beverton-Holt model with covariate effects on lambda, effect, and response</h2><span id='topic+RK_er_lambdacov_global_effectcov_global_responsecov_global'></span>

<h3>Description</h3>

<p>Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_er_lambdacov_global_effectcov_global_responsecov_global(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_er_lambdacov_global_effectcov_global_responsecov_global_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,lambda_cov,effect,effect_cov,response,response_cov,sigma</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_global_effectcov_global_responsecov_global_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_global_effectcov_global_responsecov_global_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_global_effectcov_global_responsecov_global_+3A_covariates">covariates</code></td>
<td>
<p>numeric dataframe or matrix with observations 
in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_global_effectcov_global_responsecov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;lambda_cov&quot;,&quot;effect&quot;,&quot;effect_cov&quot;,
&quot;response&quot;,&quot;response_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='RK_er_lambdacov_none_effectcov_none_responsecov_none'>Effect response Ricker model without covariate effects</h2><span id='topic+RK_er_lambdacov_none_effectcov_none_responsecov_none'></span>

<h3>Description</h3>

<p>Note that, as e and r are not pair-specific, all species parameters are fit in the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_er_lambdacov_none_effectcov_none_responsecov_none(
  par,
  fitness,
  target,
  density,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_er_lambdacov_none_effectcov_none_responsecov_none_+3A_par">par</code></td>
<td>
<p>1d vector with initial parameters in the order: 
lambda,effect,response,sigma.</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector with fitness observations.</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_none_effectcov_none_responsecov_none_+3A_target">target</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 1 if
a species is focal for a given observation, 0 otherwise.</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_none_effectcov_none_responsecov_none_+3A_density">density</code></td>
<td>
<p>matrix with species in rows, observations in columns. Value is 
density of each sp as neighbour for each observation.</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_none_effectcov_none_responsecov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_er_lambdacov_none_effectcov_none_responsecov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;effect&quot;,&quot;response&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='RK_pm_alpha_global_lambdacov_none_alphacov_none'>Ricker model with a global alpha and no covariate effects</h2><span id='topic+RK_pm_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Ricker model with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_pm_alpha_global_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_pm_alpha_global_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, alpha, and sigma.</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale.</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_global_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of neighbours for each observation.
As in this model there is a single alpha argument, do not distinguish neighbour identity</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_global_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='RK_pm_alpha_none_lambdacov_none_alphacov_none'>Ricker model with no alphas and no covariate effects</h2><span id='topic+RK_pm_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>This model, in all families, is simply given by lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_pm_alpha_none_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_pm_alpha_none_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda and sigma</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_none_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_none_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='RK_pm_alpha_pairwise_lambdacov_global_alphacov_global'>Ricker model with pairwise alphas and global covariate effects on lambda and alpha</h2><span id='topic+RK_pm_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Ricker model with pairwise alphas and global covariate effects on lambda and alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_pm_alpha_pairwise_lambdacov_global_alphacov_global(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_global_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Ricker model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha</h2><span id='topic+RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Ricker model with pairwise alphas, covariate effects on lambda, 
and pairwise covariate effects on alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: lambda, lambda_cov, alpha, alpha_cov, and sigma</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>optional matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;,&quot;lambda_cov&quot;,&quot;alpha_cov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='RK_pm_alpha_pairwise_lambdacov_none_alphacov_none'>Ricker model with pairwise alphas and no covariate effects</h2><span id='topic+RK_pm_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Ricker model with pairwise alphas and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_pm_alpha_pairwise_lambdacov_none_alphacov_none(
  par,
  fitness,
  neigh_intra_matrix = NULL,
  neigh_inter_matrix,
  covariates,
  fixed_parameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_par">par</code></td>
<td>
<p>1d vector of initial parameters: 'lambda', 'alpha_intra' (optional), 'alpha_inter', and 'sigma'</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fitness">fitness</code></td>
<td>
<p>1d vector of fitness observations, in log scale</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_intra_matrix">neigh_intra_matrix</code></td>
<td>
<p>optional matrix of one column, number of intraspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_neigh_inter_matrix">neigh_inter_matrix</code></td>
<td>
<p>matrix of arbitrary columns, number of interspecific neighbours for each observation</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model</p>
</td></tr>
<tr><td><code id="RK_pm_alpha_pairwise_lambdacov_none_alphacov_none_+3A_fixed_parameters">fixed_parameters</code></td>
<td>
<p>optional list specifying values of fixed parameters, 
with components &quot;lambda&quot;,&quot;alpha_intra&quot;,&quot;alpha_inter&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='RK_project_alpha_global_lambdacov_none_alphacov_none'>Ricker model for projecting abundances,
with a global alpha and no covariate effects</h2><span id='topic+RK_project_alpha_global_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Ricker model for projecting abundances,
with a global alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_project_alpha_global_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_global_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_global_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_global_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_global_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='RK_project_alpha_none_lambdacov_none_alphacov_none'>Model for projecting abundances,
with no alpha and no covariate effects</h2><span id='topic+RK_project_alpha_none_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Model for projecting abundances,
with no alpha and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_project_alpha_none_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_none_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_none_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_none_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_none_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='RK_project_alpha_pairwise_lambdacov_global_alphacov_global'>Ricker model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+RK_project_alpha_pairwise_lambdacov_global_alphacov_global'></span>

<h3>Description</h3>

<p>Ricker model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_project_alpha_pairwise_lambdacov_global_alphacov_global(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of numeric values 
with effects of each covariate over alpha.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_global_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in columns. Each cell is the value of a covariate
in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'>Ricker model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda</h2><span id='topic+RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise'></span>

<h3>Description</h3>

<p>Ricker model for projecting abundances,
with specific alpha values and global covariate effects on alpha and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda">lambda</code></td>
<td>
<p>named numeric lambda value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>numeric vector with interspecific alpha values.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>numeric vector with effects of covariates over lambda.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>named list of named numeric vectors 
with effects of each covariate over alpha values.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_global_alphacov_pairwise_+3A_covariates">covariates</code></td>
<td>
<p>matrix with observations in rows and covariates in named columns. 
Each cell is the value of a covariate in a given observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='RK_project_alpha_pairwise_lambdacov_none_alphacov_none'>Ricker model for projecting abundances,
with specific alpha values and no covariate effects</h2><span id='topic+RK_project_alpha_pairwise_lambdacov_none_alphacov_none'></span>

<h3>Description</h3>

<p>Ricker model for projecting abundances,
with specific alpha values and no covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK_project_alpha_pairwise_lambdacov_none_alphacov_none(
  lambda,
  alpha_intra,
  alpha_inter,
  lambda_cov,
  alpha_cov,
  abundance,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda">lambda</code></td>
<td>
<p>numeric lambda value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_intra">alpha_intra</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_inter">alpha_inter</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_abundance">abundance</code></td>
<td>
<p>named numeric vector of abundances in the previous timestep.</p>
</td></tr>
<tr><td><code id="RK_project_alpha_pairwise_lambdacov_none_alphacov_none_+3A_covariates">covariates</code></td>
<td>
<p>included for compatibility, not used in this model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric abundance projected one timestep
</p>

<hr>
<h2 id='salinity_list'>Salinity measurements</h2><span id='topic+salinity_list'></span>

<h3>Description</h3>

<p>A list containing salinity values associated to the data from 'neigh_list'.
The list has 17 elements, one for each focal species considered.
Each element of the list is a dataframe with 2 columns:
</p>

<ul>
<li><p> obs_ID: unique identifier of each observation
</p>
</li>
<li><p> salinity: salinity measurement for that observation,
in accumulated microsiemens/m2
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(salinity_list)
</code></pre>


<h3>Format</h3>

<p>A list with 17 elements, each of which a dataframe
of variable number of rows and 2 numeric columns
</p>


<h3>Note</h3>

<p>For details, see Lanuza et al. 2018 Ecology Letters.
</p>

<hr>
<h2 id='spatial_sampling'>spatial arrangement of the observations</h2><span id='topic+spatial_sampling'></span>

<h3>Description</h3>

<p>A dataset giving the spatial arrangement of observations.
The dataset is a list of 16 elements following the structure of
'neigh_list'. Each list component is a dataframe
with columns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spatial_sampling)
</code></pre>


<h3>Format</h3>

<p>A list with 16 elements, each of which a dataframe
of variable number of rows and 18 columns
</p>


<h3>Details</h3>

          
<ul>
<li><p> obs_ID: unique identifier for each observation
</p>
</li>
<li><p> plot: one of 9 plots of 8.5 x 8.5 m
</p>
</li>
<li><p> subplot: one of 36 subplots of 1x1 m within each plot
</p>
</li></ul>



<h3>Note</h3>

<p>For details, see Lanuza et al. 2018 Ecology Letters.
</p>

<hr>
<h2 id='species_fitness'>Fitness of a species</h2><span id='topic+species_fitness'></span>

<h3>Description</h3>

<p>Calculates the fitness of a species sensu Godoy et al. (2014).Note that its definition is model-specific, 
i.e. it depends on the model family from which interaction coefficients were estimated.
The function given here assumes a community of n-species, so that species fitness is calculated according to a 
general competitive response (r) substituting the 2-sp denominator terms of table A1 of Hart et al. 2018. 
This competitive response can be calculated for a series of species with the function 'cxr_er_fit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_fitness(
  effect_response_fit = NULL,
  lambda = NULL,
  competitive_response = NULL,
  model_family = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species_fitness_+3A_effect_response_fit">effect_response_fit</code></td>
<td>
<p>cxr_er_fit object with valid lambda and response terms.</p>
</td></tr>
<tr><td><code id="species_fitness_+3A_lambda">lambda</code></td>
<td>
<p>per capita fecundity of the species in the absence of competition.</p>
</td></tr>
<tr><td><code id="species_fitness_+3A_competitive_response">competitive_response</code></td>
<td>
<p>parameter reflecting the species' sensitivity to competition.</p>
</td></tr>
<tr><td><code id="species_fitness_+3A_model_family">model_family</code></td>
<td>
<p>model family for which to calculate species fitness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thus, the function accepts two sets of parameters. First, a 'cxr_er_fit' object returned from that function. 
In this case, species fitness will be calculated for all focal taxa included in the 'cxr_er_fit' object.
</p>
<p>Otherwise, users may enter a specification of the model to use, 
as well as lambda and competitive response parameters of a single species.
</p>
<p>If no model family is provided, or a model family for which there is no associated 'XX_species_fitness'
function, the function resorts to the standard Lotka-Volterra formulation (Hart et al. 2018). 
Overall, we strongly suggest that you use the standard formulation ONLY if you are completely confident 
that the model from which you obtained your parameters is consistent with it. 
Otherwise, you should include your own formulation of species fitness (see vignette 4).
</p>


<h3>Value</h3>

<p>single numeric value/vector, species fitness of one or several taxa
</p>

<hr>
<h2 id='species_rates'>Species germination and survival rates</h2><span id='topic+species_rates'></span>

<h3>Description</h3>

<p>A dataset containing germination and survival rates for 17 plant species. 
It includes columns with the scientific names and their associated codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(species_rates)
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 rows and 4 variables
</p>


<h3>Details</h3>

      
<ul>
<li><p> species: binomial name
</p>
</li>
<li><p> code: four-letter code used in other datasets
</p>
</li>
<li><p> germination: germination rate
</p>
</li>
<li><p> seed.survival: annual survival of ungerminated seed in the soil
</p>
</li></ul>



<h3>Note</h3>

<p>For details, see Lanuza et al. 2018 Ecology Letters.
</p>

<hr>
<h2 id='summary.cxr_er_fit'>CXR summary method for effect response model fits</h2><span id='topic+summary.cxr_er_fit'></span>

<h3>Description</h3>

<p>CXR summary method for effect response model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cxr_er_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cxr_er_fit_+3A_object">object</code></td>
<td>
<p>a <code>cxr_er_fit</code> object, from the function with the same name</p>
</td></tr>
<tr><td><code id="summary.cxr_er_fit_+3A_...">...</code></td>
<td>
<p>other arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>console output
</p>

<hr>
<h2 id='summary.cxr_pm_fit'>CXR summary method for population model fits</h2><span id='topic+summary.cxr_pm_fit'></span>

<h3>Description</h3>

<p>CXR summary method for population model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cxr_pm_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cxr_pm_fit_+3A_object">object</code></td>
<td>
<p>a <code>cxr_pm_fit</code> object, from the function with the same name</p>
</td></tr>
<tr><td><code id="summary.cxr_pm_fit_+3A_...">...</code></td>
<td>
<p>other arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>console output
</p>

<hr>
<h2 id='summary.cxr_pm_multifit'>CXR summary method for multispecies fits</h2><span id='topic+summary.cxr_pm_multifit'></span>

<h3>Description</h3>

<p>CXR summary method for multispecies fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cxr_pm_multifit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cxr_pm_multifit_+3A_object">object</code></td>
<td>
<p>a <code>cxr_pm_multifit</code> object, from the function with the same name</p>
</td></tr>
<tr><td><code id="summary.cxr_pm_multifit_+3A_...">...</code></td>
<td>
<p>other arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>console output
</p>

<hr>
<h2 id='vec_permutation_matrices'>Generate templates for dispersal, demography, and permutation matrices</h2><span id='topic+vec_permutation_matrices'></span>

<h3>Description</h3>

<p>this follows the vec-permutation approach
as defined in: 
Hunter and Caswell 2005, doi:10.1016/j.ecolmodel.2005.05.002, 
Ozgul et al. 2009, doi: 10.1086/597225
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_permutation_matrices(num.sp, num.sites, num.stages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_permutation_matrices_+3A_num.sp">num.sp</code></td>
<td>
<p>integer, number of species</p>
</td></tr>
<tr><td><code id="vec_permutation_matrices_+3A_num.sites">num.sites</code></td>
<td>
<p>integer, number of sites</p>
</td></tr>
<tr><td><code id="vec_permutation_matrices_+3A_num.stages">num.stages</code></td>
<td>
<p>integer, number of stages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nested list, of the form 'list[[type]][[sp]]', where 'type' is 
demography, dispersal, or permutation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of demographic stages - this should be always fixed to 3 for 
# compatibility with other functions
num.stages &lt;- 3
num.sp &lt;- 4
num.sites &lt;- 5
vpm &lt;- vec_permutation_matrices(num.sp,num.sites,num.stages)
</code></pre>

<hr>
<h2 id='vital_rate'>Vital rate calculation</h2><span id='topic+vital_rate'></span>

<h3>Description</h3>

<p>Calculates vital rates from their effect sizes and terms. This
is equivalent to predicting from a binomial glm with
given coefficients.
In this version, the user needs to ensure that 'param' and 'env' match,
i.e. that if the 'param' list is defined with environmental forcing, it is
passed here, and viceversa. In future versions I may implement checks for that
here, but for now, be aware that it will fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vital_rate(vr, sp, site, param, env = NULL, densities)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vital_rate_+3A_vr">vr</code></td>
<td>
<p>integer or char, vital rate to obtain, from the ones defined in 'param'.
So far, valid names are &quot;Sj&quot;,&quot;Sn&quot;,&quot;Sr&quot;,&quot;Rn&quot;,&quot;Rr&quot;,&quot;D&quot;,&quot;Ds,&quot;O&quot;.</p>
</td></tr>
<tr><td><code id="vital_rate_+3A_sp">sp</code></td>
<td>
<p>integer or char, species</p>
</td></tr>
<tr><td><code id="vital_rate_+3A_site">site</code></td>
<td>
<p>intger or char, site</p>
</td></tr>
<tr><td><code id="vital_rate_+3A_param">param</code></td>
<td>
<p>param nested list (see 'build_param')</p>
</td></tr>
<tr><td><code id="vital_rate_+3A_env">env</code></td>
<td>
<p>optional numeric, environmental forcing</p>
</td></tr>
<tr><td><code id="vital_rate_+3A_densities">densities</code></td>
<td>
<p>densities of all sp in the site, including individuals from
all three life stages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
