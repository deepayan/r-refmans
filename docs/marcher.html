<!DOCTYPE html><html lang="en"><head><title>Help for package marcher</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {marcher}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#marcher-package'><p>Migration and Range Change Analysis in R</p></a></li>
<li><a href='#estimate_shift'><p>Estimating range shifts</p></a></li>
<li><a href='#fitNSD'><p>Test range shift using net-squared displacement</p></a></li>
<li><a href='#getArea'><p>Compute area</p></a></li>
<li><a href='#getCov'><p>Estimation Helper Functions</p></a></li>
<li><a href='#getLikelihood'><p>Estimate likelihoods and AICs</p></a></li>
<li><a href='#getMu'><p>Obtain mean vector for a range shift process</p></a></li>
<li><a href='#getRSI'><p>Compute Range Shift Index</p></a></li>
<li><a href='#getTau'><p>Compute time scale parameters</p></a></li>
<li><a href='#locate_shift'><p>Interactive locating of range shifting</p></a></li>
<li><a href='#Michela'><p>Movement track of Michela, a roe deer</p></a></li>
<li><a href='#plot.shiftfit'><p>Plot results of an range-shift fit</p></a></li>
<li><a href='#quickfit'><p>Quick fit of one-step migration</p></a></li>
<li><a href='#scan_track'><p>scan_track</p></a></li>
<li><a href='#selectModel'><p>Select residual model</p></a></li>
<li><a href='#simulate_shift'><p>Simulate MOUF process</p></a></li>
<li><a href='#SimulatedTracks'><p>Simulated range shift tracks</p></a></li>
<li><a href='#test_rangeshift'><p>Range shift hypothesis tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Migration and Range Change Estimation in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-2</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for likelihood-based estimation, model selection and testing of two- and three-range shift and migration models for animal movement data as described in Gurarie et al. (2017) &lt;<a href="https://doi.org/10.1111%2F1365-2656.12674">doi:10.1111/1365-2656.12674</a>&gt;.  Provided movement data (X, Y and Time), including irregularly sampled data, functions estimate the time, duration and location of one or two range shifts, as well as the ranging area and auto-correlation structure of the movment.  Tests assess, for example, whether the shift was "significant", and whether a two-shift migration was a true return migration.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Matrix, graphics, grDevices, plyr, mvtnorm,
RColorBrewer, minpack.lm, zoo, numDeriv, magrittr, scales</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EliGurarie/marcher/issues">https://github.com/EliGurarie/marcher/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, lubridate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-04-12 02:31:07 UTC; Farid</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliezer Gurarie [aut, cre],
  Farid Cheraghi [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eliezer Gurarie &lt;egurarie@umd.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-04-12 14:26:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='marcher-package'>Migration and Range Change Analysis in R</h2><span id='topic+marcher'></span><span id='topic+marcher-package'></span>

<h3>Description</h3>

<p>A collection of functions for performing a migration and range change analysis (MRSA) as described in by Gurarie et al. (2017).  The key features are estimation of precise times, distances, and locations of a one or two step range shift in movement data.
</p>


<h3>Details</h3>

<p>Some key functions for using <code>marcher</code> are:
</p>
<p>1. <code><a href="#topic+estimate_shift">estimate_shift</a></code> Estimate a range shift process.
</p>
<p>2. <code><a href="#topic+simulate_shift">simulate_shift</a></code> Simulate a range shift process.
</p>
<p>3. <code><a href="#topic+plot.shiftfit">plot.shiftfit</a></code> Visualize a range shift process.
</p>
<p>4. <code><a href="#topic+test_rangeshift">test_rangeshift</a></code> Test whether a range shift occurred.
</p>
<p>5. <code><a href="#topic+test_return">test_return</a></code> Test whether a migration was a return migration.
</p>
<p>6. <code><a href="#topic+test_stopover">test_stopover</a></code> Test whether a stopover occurred during a migration.
</p>
<p>Several simulated datasets are in the <code><a href="#topic+SimulatedTracks">SimulatedTracks</a></code> data object.  
</p>
<p>One roe deer (<em>Capreolus capreolus</em>) track is in the <code><a href="#topic+Michela">Michela</a></code> object.
</p>
<p>See the respective help files and <code>vignette("marcher")</code> for more details and examples.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eliezer Gurarie <a href="mailto:egurarie@umd.edu">egurarie@umd.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Farid Cheraghi
</p>
</li></ul>



<h3>References</h3>

<p>Gurarie, E., F. Cagnacci, W. Peters, C. Fleming, J. Calabrese, T. Mueller and W. Fagan (2017)  A framework for modeling range shifts and migrations: asking whether, whither, when, and will it return. <em>Journal of Animal Ecology</em>. DOI: 10.1111/1365-2656.12674
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/EliGurarie/marcher/issues">https://github.com/EliGurarie/marcher/issues</a>
</p>
</li></ul>


<hr>
<h2 id='estimate_shift'>Estimating range shifts</h2><span id='topic+estimate_shift'></span><span id='topic+estimate.mouf.nls'></span><span id='topic+getP.nls'></span><span id='topic+geMu.nls'></span>

<h3>Description</h3>

<p>Estimation and helper functions for nls fit of migration model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_shift(T, X, Y, n.clust = 2, p.m0 = NULL, dt0 = min(5,
  diff(range(T))/20), method = c("ar", "like")[1], CI = TRUE, nboot = 100,
  model = NULL, area.direct = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_shift_+3A_t">T</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_x">X</code></td>
<td>
<p>x coordinate</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_y">Y</code></td>
<td>
<p>y coordinate</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_n.clust">n.clust</code></td>
<td>
<p>the number of ranges to estimate.  Two is relatively easy and robust, and three works fairly will (with good initial guesses).  More can be prohibitively slow.</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_p.m0">p.m0</code></td>
<td>
<p>initial parameter guesses - a named vector with (e.g.) elements x1, x2, y1, y2, t1, dt.  It helps if this is close - the output of <code><a href="#topic+quickfit">quickfit</a></code> can be helpful, as can plotting the curve and using <code><a href="graphics.html#topic+locator">locator</a></code>. If left as NULL, the function will make some guesses for you - starting with <code>quickfit</code>.</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_dt0">dt0</code></td>
<td>
<p>initial guess for duration of migration</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_method">method</code></td>
<td>
<p>one of 'ar' or 'like' (case insenstive), whether or not to use the AR equivalence method (faster, needs regular data - with some tolerance for gaps) or Likelihood method, which is slower but robust for irregular data.</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_ci">CI</code></td>
<td>
<p>whether or not to estimate confidence intervals</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_model">model</code></td>
<td>
<p>one of &quot;MWN&quot;, &quot;MOU&quot; or &quot;MOUF&quot; (case insensitive).  By default, the algorithm selects the best one according to AIC using the <code><a href="#topic+selectModel">selectModel</a></code> function.</p>
</td></tr>
<tr><td><code id="estimate_shift_+3A_area.direct">area.direct</code></td>
<td>
<p>passed as direct argument to getArea</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm minimizes the square of the distance of the locations from a double-headed hockeystick curve, then estimates the times scale using the ARMA/AR models.  Confidence intervals are obtained by bootstrapping the data and reestimating. See example and vignette for implementation.
</p>


<h3>Value</h3>

<p>a list with the following elements
</p>
<table role = "presentation">
<tr><td><code>T</code>, <code>X</code>, <code>Y</code></td>
<td>
<p>Longitude coordinate with NA at prediction times</p>
</td></tr> 
<tr><td><code>p.hat</code></td>
<td>
<p>Point estimates of parameters</p>
</td></tr>
<tr><td><code>p.CI</code></td>
<td>
<p>Data frame of parameter estimates with (approximate) confidence intervals.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>One of &quot;wn&quot;, &quot;ou&quot; or &quot;ouf&quot; - the selected model for the residuals.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The hessian of the mean parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load simulated tracks
data(SimulatedTracks)

# white noise fit
MWN.fit &lt;- with(MWN.sim, estimate_shift(T=T, X=X, Y=Y))
summary(MWN.fit)
plot(MWN.fit)

if(interactive()){
# OUF fit
MOUF.fit &lt;- with(MOUF.sim.random, 
                estimate_shift(T=T, X=X, Y=Y, 
                               model = "ouf", 
                               method = "like"))
summary(MOUF.fit)
plot(MOUF.fit)

# Three range fit:
# it is helpful to have some initital values for these parameters 
# because the automated quickfit() method is unreliable for three ranges
# in the example, we set a seed that seems to work
# set.seed(1976)

 MOU.3range.fit &lt;- with(MOU.3range, 
                       estimate_shift(T=T, X=X, Y=Y, 
                                      model = "ou", 
                                      method = "ar", 
                                      n.clust = 3))
 summary(MOU.3range.fit)
 plot(MOU.3range.fit)
}
</code></pre>

<hr>
<h2 id='fitNSD'>Test range shift using net-squared displacement</h2><span id='topic+fitNSD'></span>

<h3>Description</h3>

<p>Test range shift using net-squared displacement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitNSD(T, X, Y, plotme = FALSE, setpar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitNSD_+3A_t">T</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="fitNSD_+3A_x">X</code></td>
<td>
<p>x coordinate</p>
</td></tr>
<tr><td><code id="fitNSD_+3A_y">Y</code></td>
<td>
<p>y coordinate</p>
</td></tr>
<tr><td><code id="fitNSD_+3A_plotme">plotme</code></td>
<td>
<p>whether or not to plot the result</p>
</td></tr>
<tr><td><code id="fitNSD_+3A_setpar">setpar</code></td>
<td>
<p>whether or not to run par(mfrow = c(1,2)) before plotting</p>
</td></tr>
<tr><td><code id="fitNSD_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test below assumes that the net squared displacement (NSD) for a migrating organism is well characterized by the logistic formula: E(NSD(t)) =  a / (1 + exp [(b-t)/c] as described in border=ger and Fryxell (2012).  In practice, the square root of the NSD, i.e., the linear displacement, is fitted to the square root of the formula assuming Gaussian residuals with constant variance 's'.  A likelihood ratio test against a null model of no-dispersal is provided at a 95% significance level.
</p>


<h3>Value</h3>

<p>a list with a vector of four parameter estimates, and a vector with test statistics (likelihood, AIC and p.values)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate and compare two range shifts 
A &lt;- 20
T &lt;- 1:100
tau &lt;- c(tau.z = 2, tau.v = 0)

# large disperal
Mu &lt;- getMu(T, c(x1 = 0, y1 = 0, x2 = 4, y2 = 4, t1 = 40, dt = 20))
XY.sim &lt;- simulate_shift(T, tau = tau, Mu, A=A)
with(XY.sim, scan_track(time = T, x = X, y = Y))
with(XY.sim, fitNSD(T, X, Y, plotme=TRUE))


# no disperal
Mu &lt;- getMu(T, c(x1 = 0, y1 = 0, x2 = 0, y2 = 0, t1 = 40, dt = 20))
XY.sim &lt;- simulate_shift(T, tau = tau, Mu, A=A)
with(XY.sim, scan_track(time = T, x = X, y = Y))
with(XY.sim, fitNSD(T,X,Y, plotme=TRUE))

</code></pre>

<hr>
<h2 id='getArea'>Compute area</h2><span id='topic+getArea'></span>

<h3>Description</h3>

<p>Compute predicted area at given alpha level (e.g. 50% or 90%) of a migration model fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArea(p, T, X, Y, alpha = 0.95, model = c("wn", "ou", "ouf")[1],
  direct = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getArea_+3A_p">p</code></td>
<td>
<p>estimated mouf parameter vector (tau.z, tau.v, t1, dt, x1, y1, x2, y2)</p>
</td></tr>
<tr><td><code id="getArea_+3A_t">T</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="getArea_+3A_x">X</code></td>
<td>
<p>x coordinate</p>
</td></tr>
<tr><td><code id="getArea_+3A_y">Y</code></td>
<td>
<p>y coordinate</p>
</td></tr>
<tr><td><code id="getArea_+3A_alpha">alpha</code></td>
<td>
<p>proportion of area used to be computed</p>
</td></tr>
<tr><td><code id="getArea_+3A_model">model</code></td>
<td>
<p>one of &quot;wn&quot;, &quot;ou&quot;, &quot;ouf&quot; - whether or not the velocity autocorrelation needs to be taken into account.</p>
</td></tr>
<tr><td><code id="getArea_+3A_direct">direct</code></td>
<td>
<p>whether or not to compute the area directly (i.e. fitting a symmetric bivariate normal to the residuals) or to account for the autocorrelation.  The default behavior (NULL) computes directly for the &quot;wn&quot; model, and uses the autocorrelation (which is slower) only if the estmated spatial time scale is greater that 1/30 of the total time range.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For sufficient data (i.e. where the range in the times is much greater than the ) This function estimates the (symmetric) 95% area of use from a bivariate Gaussian
</p>

<hr>
<h2 id='getCov'>Estimation Helper Functions</h2><span id='topic+getCov'></span><span id='topic+mvrnorm2'></span>

<h3>Description</h3>

<p>functions which provide the theoretical covariance [getCov()] and area [getArea()] for specific models and parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCov(t1, t2, model, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCov_+3A_t1">t1</code></td>
<td>
<p>time 1</p>
</td></tr>
<tr><td><code id="getCov_+3A_t2">t2</code></td>
<td>
<p>time 2</p>
</td></tr>
<tr><td><code id="getCov_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="getCov_+3A_p">p</code></td>
<td>
<p>vector of the auto-correlation parameters i.e. p = c(tau.z, tau.v)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getCov(t1, t2, model, p)</code> calculates the covariance matrix for different models. <code>mvrnorm2</code> is a slightly more efficient multivariate normal function.
</p>

<hr>
<h2 id='getLikelihood'>Estimate likelihoods and AICs</h2><span id='topic+getLikelihood'></span><span id='topic+getLikelihood.res'></span><span id='topic+getAIC.nls'></span>

<h3>Description</h3>

<p>Estimate likelihoods and AIC for several possible migration models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLikelihood(p, T, X, Y, model = c("mouf", "mou", "mwn", "ouf", "ou",
  "wn")[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLikelihood_+3A_p">p</code></td>
<td>
<p>initial parameters: [tau.z, tau.v, t1, t2, x1, x2, y1, y2]</p>
</td></tr>
<tr><td><code id="getLikelihood_+3A_t">T</code>, <code id="getLikelihood_+3A_x">X</code>, <code id="getLikelihood_+3A_y">Y</code></td>
<td>
<p>time,x and y coordinates</p>
</td></tr>
<tr><td><code id="getLikelihood_+3A_model">model</code></td>
<td>
<p>&quot;wn&quot;, &quot;ou&quot;, &quot;ouf&quot;, &quot;mou&quot; or &quot;mouf&quot;,  - whether or not to estimate tau.v</p>
</td></tr>
</table>

<hr>
<h2 id='getMu'>Obtain mean vector for a range shift process</h2><span id='topic+getMu'></span><span id='topic+getMu_multi'></span>

<h3>Description</h3>

<p>Obtain a mean vector for a movement with one (<code>getMu</code>) or more (<code>getMu_multi</code>) range shifts.  This function is mainly used within the likelihood of range shift processes, but is also useful for simulating processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMu(T, p.m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMu_+3A_t">T</code></td>
<td>
<p>vector of times</p>
</td></tr>
<tr><td><code id="getMu_+3A_p.m">p.m</code></td>
<td>
<p>mean parameters. A named vector with elements t1, dt, x1, y1, x2, y2, for a single-shift process.  For multiple (n) shifts, the paramaters are numbered: (x1, x2 ... xn), (y1, y2 ... yn), (t1 .. t[n-1]), (dt1 ... dt[n-1])</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_shift">simulate_shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- 1:100
p.m &lt;- c(x1 = 0, y1 = 0, x2 = 10, y2 = 20, t1 = 45, dt = 55)
scan_track(time = T, x=getMu(T, p.m))
</code></pre>

<hr>
<h2 id='getRSI'>Compute Range Shift Index</h2><span id='topic+getRSI'></span>

<h3>Description</h3>

<p>The range shift index is a dimensionless measure of the distance of the centroids of two ranges divided by the diameter of the 95% area. This function uses the 95% confidence intervals from a range shift fit to calculate a point estimate and 95% confidence intervals of the RSI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRSI(FIT, n1 = 1, n2 = 2, nboot = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRSI_+3A_fit">FIT</code></td>
<td>
<p>a rnage shift object, outputted by <code><a href="#topic+estimate_shift">estimate_shift</a></code></p>
</td></tr>
<tr><td><code id="getRSI_+3A_n1">n1</code></td>
<td>
<p>the indices of the ranges to estimate from and to, i.e., for single shift, 1 and 2.  For three ranges (two shifts) it can be 1 and 2, 2 and 3, or 1 and 3 - if the ultimate shift is the one of interest.</p>
</td></tr>
<tr><td><code id="getRSI_+3A_n2">n2</code></td>
<td>
<p>see n1</p>
</td></tr>
<tr><td><code id="getRSI_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame reporting the distance traveled, the RSI and respective bootstrapped confidence intervals.
</p>

<hr>
<h2 id='getTau'>Compute time scale parameters</h2><span id='topic+getTau'></span>

<h3>Description</h3>

<p>A mostly internal function that takes the &quot;residuals&quot; of a range-shift process and estimates </p>
<p style="text-align: center;"><code class="reqn">\tau_z</code>
</p>
<p> and, if necessary, </p>
<p style="text-align: center;"><code class="reqn">\tau_v</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTau(Z.res, T = T, model = c("wn", "ou", "ouf")[1], tau0 = NULL,
  CI = FALSE, method = c("like", "ar")[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTau_+3A_z.res">Z.res</code></td>
<td>
<p>complex vector of isotropic Gaussian, possibly autocorrelated time series of points</p>
</td></tr>
<tr><td><code id="getTau_+3A_t">T</code></td>
<td>
<p>time vector</p>
</td></tr>
<tr><td><code id="getTau_+3A_model">model</code></td>
<td>
<p>one of  <code>"wn"</code> (white noise),  <code>"ou"</code> or <code>"ouf"</code> (case insensitive), denoting, respectively, no autocorrelation, position autocorrelation, or velocity and position autocorrelation.  If <code>model = NULL</code> and <code>method = "ar"</code>, the algorithm will select a model using AIC comparisons of the three. If the selected model iswhite noise, the function will return 0's for both parameters.</p>
</td></tr>
<tr><td><code id="getTau_+3A_tau0">tau0</code></td>
<td>
<p>initial values of parameter estimates - a named vector: <code>c(tau.z = tau0[1], tau.v = tau0[2])</code></p>
</td></tr>
<tr><td><code id="getTau_+3A_ci">CI</code></td>
<td>
<p>whether or not to compute the confidence intervals (temporarily only available for <code>like</code> method).</p>
</td></tr>
<tr><td><code id="getTau_+3A_method">method</code></td>
<td>
<p>either <code>"like"</code> or <code>"ar"</code>.  The former refers to the likelihood method - it is most general (i.e. works with irregular sampling). The latter refers to the auto-rgressive model equivalence, which is faster but only works with regular sampling.</p>
</td></tr>
</table>

<hr>
<h2 id='locate_shift'>Interactive locating of range shifting</h2><span id='topic+locate_shift'></span>

<h3>Description</h3>

<p>Plots an x-y, time-x, time-y track of a potential migration process and prompts the user to click on the figure to obtain initial estimates of range centroids and timing of start and end of migrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_shift(time, x, y, n.clust = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate_shift_+3A_time">time</code></td>
<td>
<p>time (can be a <code><a href="base.html#topic+POSIXt">POSIXt</a></code>)</p>
</td></tr>
<tr><td><code id="locate_shift_+3A_x">x</code></td>
<td>
<p>x and y coordinates.  Can be two separate vectors OR a complex &quot;x&quot; OR a two-column matrix/date-frame.</p>
</td></tr>
<tr><td><code id="locate_shift_+3A_y">y</code></td>
<td>
<p>see x</p>
</td></tr>
<tr><td><code id="locate_shift_+3A_n.clust">n.clust</code></td>
<td>
<p>number of ranges (either 2 or 3)</p>
</td></tr>
<tr><td><code id="locate_shift_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to plot functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of initial estimates: 
if <code>n.clust = 2</code>, c(x1, x2, y1, y2, t1, dt) 
if <code>n.clust = 3</code>, c(x1, x2, x3, y1, y2, y3, t1, t2, dt1, dt2)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickfit">quickfit</a></code>, code<a href="graphics.html#topic+locator">locator</a>
</p>

<hr>
<h2 id='Michela'>Movement track of Michela, a roe deer</h2><span id='topic+Michela'></span>

<h3>Description</h3>

<p>GPS tracks of one roe deer (<em>Capreolus capreolus</em>) in the Italian alps. 
This deer performs two seasonal migrations, from a wintering ground to a summering ground, 
back its wintering ground.  For several ways to analyze these data, see examples in the 
<a href="#topic+marcher">marcher</a> vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Michela)
</code></pre>


<h3>Format</h3>

<p>Data frame containing movements of roe deer with the following columns:
</p>

<dl>
<dt>id</dt><dd><p>ID of animal</p>
</dd>
<dt>name</dt><dd><p>Names - for mnemonic convenience - of Italian authors.</p>
</dd>
<dt>x,y</dt><dd><p>In Easting Westing</p>
</dd>
<dt>latitude, longitude</dt><dd></dd>
<dt>time</dt><dd><p>POSIXct object</p>
</dd>
<dt>day</dt><dd><p>Day of year, counting from January 1 of the first year of observations 
(thus day 367 is January 2 or the following year).</p>
</dd></dl>


<h3>References</h3>

<p>For more details, see: <a href="Eurodeer.org">Eurodeer.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Michela)
with(Michela, scan_track(time = time, x = x, y = y))

</code></pre>

<hr>
<h2 id='plot.shiftfit'>Plot results of an range-shift fit</h2><span id='topic+plot.shiftfit'></span>

<h3>Description</h3>

<p>Plotting functions for illustrating the results of a range-shift fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'shiftfit'
plot(x, ns = c(n.sims = 1000, n.times = 100, n.bins = 10),
  plot.ts = TRUE, stretch = 0, pt.cex = 0.8, pt.col = "antiquewhite",
  CI.cols = NULL, layout = NULL, par = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.shiftfit_+3A_x">x</code></td>
<td>
<p>a fitted range shift object, i.e. output of the <code><a href="#topic+estimate_shift">estimate_shift</a></code></p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_ns">ns</code></td>
<td>
<p>a vector of 3 simulation values, useful for smoothing the bars in the dumbbell plot.  For smoothing, it might be recommended to increase the first value, <code>n.sims</code> - the number of draws from the fitted migation process.</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_plot.ts">plot.ts</code></td>
<td>
<p>whether or not to plot the time series as well</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_stretch">stretch</code></td>
<td>
<p>an extra parameter to extend the bars on the dumbbells (in real distance units).</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_pt.cex">pt.cex</code></td>
<td>
<p>point character expansion.</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_pt.col">pt.col</code></td>
<td>
<p>points color.</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_ci.cols">CI.cols</code></td>
<td>
<p>three shading colors, from lightest to darkest. The default is a sequence of blues.</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_layout">layout</code></td>
<td>
<p>the default layout places the x-y plot on the left and - if <code>plot.ts==TRUE</code> - the respective 1-d time series on the right.</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_par">par</code></td>
<td>
<p>graphics window parameters that, by default, look nice with the default layout.</p>
</td></tr>
<tr><td><code id="plot.shiftfit_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to plot function (e.g. labels, title, etc.)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load simulated tracks
data(SimulatedTracks)

# white noise fit
MWN.fit &lt;- with(MWN.sim, estimate_shift(T=T, X=X, Y=Y))
summary(MWN.fit)
plot(MWN.fit)

if(interactive()){
# OUF fit
MOUF.fit &lt;- with(MOUF.sim.random, 
                estimate_shift(T=T, X=X, Y=Y, 
                               model = "ouf", 
                               method = "like"))
summary(MOUF.fit)
plot(MOUF.fit)

# Three range fit:
# it is helpful to have some initital values for these parameters 
# because the automated quickfit() method is unreliable for three ranges
# in the example, we set a seed that seems to work
# set.seed(1976)

 MOU.3range.fit &lt;- with(MOU.3range, 
                       estimate_shift(T=T, X=X, Y=Y, 
                                      model = "ou", 
                                      method = "ar", 
                                      n.clust = 3))
 summary(MOU.3range.fit)
 plot(MOU.3range.fit)
}
</code></pre>

<hr>
<h2 id='quickfit'>Quick fit of one-step migration</h2><span id='topic+quickfit'></span>

<h3>Description</h3>

<p>Using k-means clustering to get quick fits of 2 or 3 cluster centers in X-Y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickfit(T, X, Y, dt = 1, n.clust = 2, plotme = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickfit_+3A_t">T</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="quickfit_+3A_x">X</code></td>
<td>
<p>x coordinate of movement</p>
</td></tr>
<tr><td><code id="quickfit_+3A_y">Y</code></td>
<td>
<p>y coordinate of movement</p>
</td></tr>
<tr><td><code id="quickfit_+3A_dt">dt</code></td>
<td>
<p>duration of migration (arbitrarily = 1)</p>
</td></tr>
<tr><td><code id="quickfit_+3A_n.clust">n.clust</code></td>
<td>
<p>number of clusters (2 or 3)</p>
</td></tr>
<tr><td><code id="quickfit_+3A_plotme">plotme</code></td>
<td>
<p>whether or not to plot the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does estimates the locations and times of migration, but not the duration (dt).  It is most useful for obtaining a &quot;null&quot; estimate for seeding the likelihood estimation.
</p>


<h3>Value</h3>

<p>a named vector of initial estimates: 
</p>

<ul>
<li><p>if <code>n.clust = 2</code> returns <code>t1, dt, x1, y1, x2, y2</code> 
</p>
</li>
<li><p>if <code>n.clust = 3</code> returns <code>t1, dt1, t2, dt2, x1, y1, x2, y2, x3, y3</code> </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>require(marcher)

## Load simulated data
data(SimulatedTracks)

# plot the MOU simulation
scan_track(MOU.sim)

# quick fit - setting dt = 10
(pm.0 &lt;- with(MOU.sim, quickfit(T, X, Y, dt = 10)))

# interactive locator process
if(interactive()){
 (with(MOU.sim, locate_shift(T, X, Y)))
}

# fit the model
fit &lt;- with(MOU.sim, estimate_shift(T, X, Y))

## Three cluster example

# plot the three range shift simulation
scan_track(MOU.3range)

# quick fit 
## (note - this may not always work!)
with(MOU.3range, quickfit(T, X, Y, dt = 10, n.clust = 3))

if(interactive()){
  with(MOU.3range, locate_shift(T, X, Y, n.clust = 3))
}
</code></pre>

<hr>
<h2 id='scan_track'>scan_track</h2><span id='topic+scan_track'></span>

<h3>Description</h3>

<p>Plotting x-y, time-x, time-y scan of a track.  This function will take x, y, and time coordinates or a <code>track</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_track(track = NULL, time, x, y = NULL, layout = NULL,
  auto.par = NULL, col = 1, alpha = 0.5, cex = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan_track_+3A_track">track</code></td>
<td>
<p>a <code>track</code> class object, or any data-frame that contains (at least) three columns labeled &quot;T&quot;, &quot;X&quot; and &quot;Y&quot;</p>
</td></tr>
<tr><td><code id="scan_track_+3A_time">time</code></td>
<td>
<p>time (can be a <code><a href="base.html#topic+POSIXt">POSIXt</a></code>)</p>
</td></tr>
<tr><td><code id="scan_track_+3A_x">x</code></td>
<td>
<p>x Coordinate. x,y coordiantes an be two separate vectors OR a complex &quot;x&quot; OR a two-column matrix/date-frame.</p>
</td></tr>
<tr><td><code id="scan_track_+3A_y">y</code></td>
<td>
<p>y coordinate.</p>
</td></tr>
<tr><td><code id="scan_track_+3A_layout">layout</code></td>
<td>
<p>the default layout places the x-y plot on the left and the respective 1-d time series on the right.</p>
</td></tr>
<tr><td><code id="scan_track_+3A_auto.par">auto.par</code></td>
<td>
<p>by default, uses a decent looking default layout.  Otherwise can be a <code><a href="graphics.html#topic+par">par</a></code> list, or, e.g. FALSE to keep externally defined settings.</p>
</td></tr>
<tr><td><code id="scan_track_+3A_col">col</code></td>
<td>
<p>color vector t</p>
</td></tr>
<tr><td><code id="scan_track_+3A_alpha">alpha</code></td>
<td>
<p>intensity of the color</p>
</td></tr>
<tr><td><code id="scan_track_+3A_cex">cex</code></td>
<td>
<p>character expansion of the points</p>
</td></tr>
<tr><td><code id="scan_track_+3A_...">...</code></td>
<td>
<p>options to be passed to plot functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Roe deer data

data(Michela)
par(bty="l", mar = c(0,4,0,2), oma=c(4,0,4,0), xpd=NA) 
with(Michela, scan_track(time = time, x = x, y = y, main="Michela"))

## Simulated track

time &lt;- 1:200
Mean &lt;- getMu(T = time, p.m = c(x1 = 0, y1 = 0, x2 = 10, y2 = 10, t1 = 90, dt = 20))
SimTrack &lt;- simulate_shift(T = time, tau = c(tau.z = 5), mu = Mean, A = 40)
with(SimTrack, scan_track(time = T, x = X, y = Y))

# OR (because SimTrack is a "track")
scan_track(SimTrack)
</code></pre>

<hr>
<h2 id='selectModel'>Select residual model</h2><span id='topic+selectModel'></span>

<h3>Description</h3>

<p>Given a complex vector of movement residuals, will use AIC to select the order of the autocorrelation, i.e. white noise (WN), position autocorrelation (OU), or position and velocity autocorrelation (OUF)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectModel(Z.res, T = NULL, method = c("ar", "like")[1],
  showtable = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectModel_+3A_z.res">Z.res</code></td>
<td>
<p>complex vector of residuals</p>
</td></tr>
<tr><td><code id="selectModel_+3A_t">T</code></td>
<td>
<p>time vector (only needed for method = 'like')</p>
</td></tr>
<tr><td><code id="selectModel_+3A_method">method</code></td>
<td>
<p>One of 'ar' or 'like' - whether to use the AR equivalence (faster, but needs to be regular) or likelihood estimation.</p>
</td></tr>
<tr><td><code id="selectModel_+3A_showtable">showtable</code></td>
<td>
<p>whether to return the AIC values of the respective models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string - <code>'wn'</code>, <code>'ou'</code> or <code>'ouf'</code>.  Optionally also the AIC table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(marcher)

# white noise example
Z1 &lt;- rnorm(100) + 1i*rnorm(100)

# OU example
T &lt;- 1:100
p.s2 &lt;- c(tau.z = 5, tau.v = 0)
S2 &lt;- outer(T, T, getCov, p=p.s2, model="ou")
Z2 &lt;- mvrnorm2(n = 1, mu = rep(0,length(T)), S2) + 
     1i * mvrnorm2(n = 1, mu = rep(0,length(T)),  S2)

# OUF example
p.s3 &lt;- c(tau.z = 5, tau.v = 2)
S3 &lt;- outer(T, T, getCov, p=p.s3, model="ouf")
Z3 &lt;- mvrnorm2(n = 1, mu = rep(0,length(T)), S3) + 
  1i * mvrnorm2(n = 1, mu = rep(0,length(T)),  S3)


# plot all three
par(mfrow=c(1,3), mar = c(2,2,2,2))
plot(Z1, asp=1, type="o")
plot(Z2, asp=1, type="o")
plot(Z3, asp=1, type="o")

# select models using 'ar' method (results might vary!)

selectModel(Z1, T = T, method = "ar", showtable = TRUE)
selectModel(Z2, T = T, method = "ar", showtable = TRUE)
selectModel(Z3, T = T, method = "ar", showtable = TRUE)

selectModel(Z1, T = T, method = "like", showtable = TRUE)
selectModel(Z2, T = T, method = "like", showtable = TRUE)
selectModel(Z3, T = T, method = "like", showtable = TRUE)

# repeat using irregular times (requiring "like" method)

T &lt;- cumsum(rexp(100))

# white noise example
p.s1 &lt;- c(tau.z = 0, tau.v = 0)
S1 &lt;- outer(T, T, getCov, p=p.s1, model="wn")
Z1 &lt;- mvrnorm2(n = 1, mu = rep(0,length(T)), S1) + 
  1i * mvrnorm2(n = 1, mu = rep(0,length(T)),  S1)

# OU example
p.s2 &lt;- c(tau.z = 5, tau.v = 0)
S2 &lt;- outer(T, T, getCov, p=p.s2, model="ou")
Z2 &lt;- mvrnorm2(n = 1, mu = rep(0,length(T)), S2) + 
  1i * mvrnorm2(n = 1, mu = rep(0,length(T)),  S2)

# OUF example
p.s3 &lt;- c(tau.z = 5, tau.v = 2)
S3 &lt;- outer(T, T, getCov, p=p.s3, model="ouf")
Z3 &lt;- mvrnorm2(n = 1, mu = rep(0,length(T)), S3) + 
  1i * mvrnorm2(n = 1, mu = rep(0,length(T)),  S3)

Z.list &lt;- list(Z1, Z2, Z3)

# plot
par(mfrow=c(1,3), mar = c(2,2,2,2))
lapply(Z.list, function(z) plot(z, asp=1, type="o"))

# select model
lapply(Z.list, function(z) selectModel(z, T = T, method = "like", showtable = TRUE))
</code></pre>

<hr>
<h2 id='simulate_shift'>Simulate MOUF process</h2><span id='topic+simulate_shift'></span>

<h3>Description</h3>

<p>Simulate MOUF process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_shift(T, tau = NULL, mu, A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_shift_+3A_t">T</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="simulate_shift_+3A_tau">tau</code></td>
<td>
<p>variance parameters - named vector with 'tau.z' and 'tau.v'</p>
</td></tr>
<tr><td><code id="simulate_shift_+3A_mu">mu</code></td>
<td>
<p>mean vector - typically output of <code><a href="#topic+getMu">getMu</a></code>. Can also be any complex or a two-column matrix, or a multi-column matrix with some named columns &quot;x&quot; and &quot;y&quot; (case-insensitive)).</p>
</td></tr>
<tr><td><code id="simulate_shift_+3A_a">A</code></td>
<td>
<p>95% area parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with Time, X, and Y columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMu">getMu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(marcher)

# 95% home range area
A &lt;- 20
# distance of migration
D &lt;- 100
# centers of attraction
x1 &lt;- 0; y1 &lt;- 0
x2 &lt;- sqrt(D); y2 &lt;- sqrt(D)
# time scales
tau.z &lt;- 5
tau.v &lt;- 0.5

t1 &lt;- 90
dt &lt;- 20

# mean parameters (t1,dt)
mus &lt;- c(t1=t1,dt=dt,x1=x1,y1=y1,x2=x2,y2=y2)
# time-scale parameters
taus &lt;- c(tau.z = tau.z, tau.v = tau.v)

# generate and plot mean vector
T &lt;- 1:200
Mu &lt;- getMu(T, mus)

# simulate and plot MOUF process
SimTrack &lt;- simulate_shift(T, tau=taus, Mu, A=A)
with(SimTrack, scan_track(time=T,x=X,y=Y))
</code></pre>

<hr>
<h2 id='SimulatedTracks'>Simulated range shift tracks</h2><span id='topic+SimulatedTracks'></span><span id='topic+MOU.3range'></span><span id='topic+MOU.sim'></span><span id='topic+MOUF.sim'></span><span id='topic+MOUF.sim.random'></span><span id='topic+MWN.sim'></span>

<h3>Description</h3>

<p>Five simulated tracks: <code>MWN.sim</code>,  <code>MOU.sim</code>, <code>MOUF.sim</code> are simulated two-range shifts with different levels of position and velocity autocorrelation, <code>MOUF.sim.random</code> which has 100 observations random times, and <code>MOU.3range</code> which is a MOU process with two range shifts (and 200 observations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SimulatedTracks")
</code></pre>


<h3>Format</h3>

<p>Each of these is a data frame with 100 observations of 
three numeric variables (except for MOU.3range, which has 200 observations).  
The columns are: <code>T</code>, <code>X</code>, <code>Y</code>.</p>


<h3>Details</h3>

<p>The data frames are also <code>track</code> class object frame.
</p>

<dl>
<dt>MOU.3range</dt><dd><p>Simulated migratory Ornstein-Uhlenbeck with 3 range</p>
</dd>
<dt>MOU.sim</dt><dd><p>Simulated migratory Ornstein-Uhlenbeck</p>
</dd>
<dt>MOUF.sim</dt><dd><p>Simulated migratory Ornstein-Uhlenbeck Flemming</p>
</dd>
<dt>MOUF.sim.random</dt><dd><p>Simulated migratory Ornstein-Uhlenbeck Flemming at random or arbitrary times of observation</p>
</dd>
<dt>MWN.sim</dt><dd><p>Simulated migratory white noise ranging model</p>
</dd>
</dl>



<h3>Source</h3>

<p>Code to simulate tracks like these are provided in the marcher vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SimulatedTracks)
scan_track(MWN.sim)
scan_track(MOU.sim)
scan_track(MOUF.sim)
scan_track(MOUF.sim.random)
scan_track(MOU.3range)
</code></pre>

<hr>
<h2 id='test_rangeshift'>Range shift hypothesis tests</h2><span id='topic+test_rangeshift'></span><span id='topic+test_return'></span><span id='topic+test_stopover'></span>

<h3>Description</h3>

<p>Three tests for three hypotheses to test on fitted range shifts: Was the range shift significant?  Did an animal that performed two consecutive seasonal migrations return to the same location it began?  Was there a stopover during a migration?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_rangeshift(FIT, verbose = TRUE)

test_return(FIT, verbose = TRUE)

test_stopover(FIT, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_rangeshift_+3A_fit">FIT</code></td>
<td>
<p>a fitted range shift (output of <code><a href="#topic+estimate_shift">estimate_shift</a></code>)</p>
</td></tr>
<tr><td><code id="test_rangeshift_+3A_verbose">verbose</code></td>
<td>
<p>whether to print verbose message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs a summary of the test results and returns a list of test results including: 
</p>

<ul>
<li><p><code>aic.table</code> an AIC table comparing models
</p>
</li>
<li><p><code>lrt</code> a likelihood ratio test statistic
</p>
</li>
<li><p><code>df</code> degrees of freedom for the l.r.t.
</p>
</li>
<li><p><code>p.value</code> a p.value for the l.r.t.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>test_rangeshift</code>: Compare a two range fitted model to a null model of no range shift.
</p>
</li>
<li> <p><code>test_return</code>: Compares a three range fitted model in which the first and third ranges have the same centroid against a model where the first and third centroid are different.
</p>
</li>
<li> <p><code>test_stopover</code>: Compare a three range model with an apparent stopover (shorter intermediate range), and see if a more parsimonious model excludes the stopover.
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
