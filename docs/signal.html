<!DOCTYPE html><html><head><title>Help for package signal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {signal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#signal-package'>
<p>Signal processing</p></a></li>
<li><a href='#an'><p> Complex unit phasor of the given angle in degrees.</p></a></li>
<li><a href='#Arma'><p> Create an autoregressive moving average (ARMA) model.</p></a></li>
<li><a href='#bilinear'><p> Bilinear transformation</p></a></li>
<li><a href='#butter'><p> Generate a Butterworth filter.</p></a></li>
<li><a href='#buttord'><p> Butterworth filter order and cutoff</p></a></li>
<li><a href='#cheb1ord'><p> Chebyshev type-I filter order and cutoff</p></a></li>
<li><a href='#chebwin'><p> Dolph-Chebyshev window coefficients</p></a></li>
<li><a href='#cheby1'><p> Generate a Chebyshev filter.</p></a></li>
<li><a href='#chirp'><p> A chirp signal</p></a></li>
<li><a href='#conv'><p> Convolution</p></a></li>
<li><a href='#decimate'><p> Decimate or downsample a signal</p></a></li>
<li><a href='#ellip'><p> Elliptic or Cauer filter</p></a></li>
<li><a href='#ellipord'><p> Elliptic filter order and cutoff</p></a></li>
<li><a href='#fftfilt'><p> Filters with an FIR filter using the FFT</p></a></li>
<li><a href='#filter'><p>Filter a signal</p></a></li>
<li><a href='#FilterOfOrder'><p> Filter of given order and specifications.</p></a></li>
<li><a href='#filtfilt'><p> Forward and reverse filter a signal</p></a></li>
<li><a href='#fir1'><p> FIR filter generation</p></a></li>
<li><a href='#fir2'><p> FIR filter generation</p></a></li>
<li><a href='#freqs'><p> s-plane frequency response</p></a></li>
<li><a href='#freqz'><p> z-plane frequency response</p></a></li>
<li><a href='#grpdelay'><p> Group delay of a filter or model</p></a></li>
<li><a href='#ifft'><p> Inverse FFT</p></a></li>
<li><a href='#impz'><p> Impulse-response characteristics</p></a></li>
<li><a href='#interp'><p> Interpolate / Increase the sample rate</p></a></li>
<li><a href='#interp1'><p> Interpolation</p></a></li>
<li><a href='#kaiser'><p> Kaiser window</p></a></li>
<li><a href='#kaiserord'><p> Parameters for an FIR filter from a Kaiser window</p></a></li>
<li><a href='#levinson'><p> Durbin-Levinson Recursion</p></a></li>
<li><a href='#Ma'><p> Create a moving average (MA) model</p></a></li>
<li><a href='#medfilt1'><p> Median filter</p></a></li>
<li><a href='#pchip'><p> Piecewise cubic hermite interpolation</p></a></li>
<li><a href='#poly'><p> Polynomial given roots</p></a></li>
<li><a href='#polyval'><p> Evaluate a polynomial</p></a></li>
<li><a href='#remez'><p> Parks-McClellan optimal FIR filter design</p></a></li>
<li><a href='#resample'><p> Change the sampling rate of a signal</p></a></li>
<li><a href='#roots'><p>Roots of a polynomial</p></a></li>
<li><a href='#sftrans'><p> Transform filter band edges</p></a></li>
<li><a href='#sgolay'><p> Savitzky-Golay smoothing filters</p></a></li>
<li><a href='#sgolayfilt'><p> Apply a Savitzky-Golay smoothing filter</p></a></li>
<li><a href='#signal-internal'><p>Internal or uncommented functions</p></a></li>
<li><a href='#specgram'><p> Spectrogram plot</p></a></li>
<li><a href='#spencer'><p> Spencer filter</p></a></li>
<li><a href='#unwrap'><p> Unwrap radian phases</p></a></li>
<li><a href='#wav'><p>Example wav file</p></a></li>
<li><a href='#Windowing functions'><p> Windowing functions</p></a></li>
<li><a href='#Zpg'><p> Zero-pole-gain model</p></a></li>
<li><a href='#zplane'><p> Pole-zero plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Signal Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pracma</td>
</tr>
<tr>
<td>Enhances:</td>
<td>matlab</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of signal processing functions originally written for 'Matlab' and 'Octave'.
  Includes filter generation utilities, filtering functions,
  resampling routines, and visualization of filter models. It also
  includes interpolation functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 10:01:26 UTC; ligges</td>
</tr>
<tr>
<td>Author:</td>
<td>Uwe Ligges [aut, cre] (new maintainer),
  Tom Short [aut] (port to R),
  Paul Kienzle [aut] (majority of the original sources),
  Sarah Schnackenberg [ctb] (various test cases and bug fixes),
  David Billinghurst [ctb],
  Hans-Werner Borchers [ctb],
  Andre Carezia [ctb],
  Pascal Dupuis [ctb],
  John W. Eaton [ctb],
  E. Farhi [ctb],
  Kai Habel [ctb],
  Kurt Hornik [ctb],
  Sebastian Krey [ctb],
  Bill Lash [ctb],
  Friedrich Leisch [ctb],
  Olaf Mersmann [ctb],
  Paulo Neis [ctb],
  Jaakko Ruohio [ctb],
  Julius O. Smith III [ctb],
  Doug Stewart [ctb],
  Andreas Weingessel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Uwe Ligges &lt;ligges@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 11:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='signal-package'>
Signal processing 
</h2><span id='topic+signal-package'></span><span id='topic+signal'></span>

<h3>Description</h3>

<p>A set of generally Matlab/Octave-compatible signal processing
functions. Includes filter generation utilities, filtering functions,
resampling routines, and visualization of filter models. It also
includes interpolation functions and some Matlab compatibility
functions.
</p>


<h3>Details</h3>

<p>The main routines are:
</p>
<p><em>Filtering:</em> filter, fftfilt, filtfilt, medfilt1, sgolay, sgolayfilt
</p>
<p><em>Resampling:</em> interp, resample, decimate
</p>
<p><em>IIR filter design:</em> bilinear, butter, buttord, cheb1ord, cheb2ord,
cheby1, cheby2, ellip, ellipord, sftrans
</p>
<p><em>FIR filter design:</em> fir1, fir2, remez, kaiserord, spencer
</p>
<p><em>Interpolation:</em> interp1, pchip
</p>
<p><em>Compatibility routines and utilities:</em> ifft, sinc,
postpad, chirp, poly, polyval
</p>
<p><em>Windowing:</em> bartlett, blackman, boxcar, flattopwin, gausswin,
hamming, hanning, triang
</p>
<p><em>Analysis and visualization:</em> freqs, freqz, impz, zplane, grpdelay, specgram
</p>
<p>Most of the functions accept Matlab-compatible argument lists, but many
are generic functions and can accept simpler argument lists.
</p>
<p>For a complete list, use <code>library(help="signal")</code>.
</p>


<h3>Author(s)</h3>

<p>Most of these routines were translated from Octave Forge routines. The
main credit goes to the original Octave authors:
</p>
<p>Paul Kienzle, John W. Eaton, Kurt Hornik, Andreas Weingessel, Kai
Habel, Julius O. Smith III, Bill Lash, Andr√© Carezia, Paulo Neis,
David Billinghurst, Friedrich Leisch
</p>
<p>Translations by Tom Short <a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a> 
(who maintained the package until 2009).
</p>
<p>Current maintainer is Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Category:Signal_processing">https://en.wikipedia.org/wiki/Category:Signal_processing</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>
<p>Package <code><a href="matlab.html#topic+matlab-package">matlab</a></code> by P. Roebuck
</p>
<p>For Matlab/Octave conversion and compatibility, see <a href="https://mathesaurus.sourceforge.net/octave-r.html">https://mathesaurus.sourceforge.net/octave-r.html</a>
by Vidar Bronken Gundersen and <a href="https://cran.r-project.org/doc/contrib/R-and-octave.txt">https://cran.r-project.org/doc/contrib/R-and-octave.txt</a> by Robin Hankin. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The R implementation of these routines can be called "matlab-style",
bf &lt;- butter(5, 0.2)
freqz(bf$b, bf$a)
## or "R-style" as:
freqz(bf)

## make a Chebyshev type II filter:
ch &lt;- cheby2(5, 20, 0.2) 
freqz(ch, Fs = 100)  # frequency plot for a sample rate = 100 Hz

zplane(ch) # look at the poles and zeros

## apply the filter to a signal
t &lt;- seq(0, 1, by = 0.01)                     # 1 second sample, Fs = 100 Hz
x &lt;- sin(2*pi*t*2.3) + 0.25*rnorm(length(t))  # 2.3 Hz sinusoid+noise
z &lt;- filter(ch, x)  # apply filter
plot(t, x, type = "l")
lines(t, z, col = "red")

# look at the group delay as a function of frequency
grpdelay(ch, Fs = 100)
</code></pre>

<hr>
<h2 id='an'> Complex unit phasor of the given angle in degrees.  </h2><span id='topic+an'></span>

<h3>Description</h3>

<p>Complex unit phasor of the given angle in degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  an(degrees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="an_+3A_degrees">degrees</code></td>
<td>
<p> Angle in degrees. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a utility function to make it easier to specify phasor values
as a magnitude times an angle in degrees. 
</p>


<h3>Value</h3>

<p>A complex value or array of <code>exp(1i*degrees*pi/180)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  120*an(30) + 125*an(-160)
</code></pre>

<hr>
<h2 id='Arma'> Create an autoregressive moving average (ARMA) model. </h2><span id='topic+Arma'></span><span id='topic+as.Arma'></span><span id='topic+as.Arma.Arma'></span><span id='topic+as.Arma.Zpg'></span><span id='topic+as.Arma.Ma'></span>

<h3>Description</h3>

<p>Returns an ARMA model. The model could represent a filter or system model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arma(b, a)

## S3 method for class 'Zpg'
as.Arma(x, ...)

## S3 method for class 'Arma'
as.Arma(x, ...)

## S3 method for class 'Ma'
as.Arma(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arma_+3A_b">b</code></td>
<td>
<p> moving average (MA) polynomial coefficients. </p>
</td></tr>
<tr><td><code id="Arma_+3A_a">a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients. </p>
</td></tr>
<tr><td><code id="Arma_+3A_x">x</code></td>
<td>
<p> model or filter to be converted to an ARMA representation. </p>
</td></tr>
<tr><td><code id="Arma_+3A_...">...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ARMA model is defined by:
</p>
<p style="text-align: center;"><code class="reqn">a(L)y(t) =  b(L)x(t)</code>
</p>

<p>The ARMA model can define an analog or digital model. The AR and MA
polynomial coefficients follow the Matlab/Octave convention where the
coefficients are in decreasing order of the polynomial (the opposite of
the definitions for filter from the stats package and polyroot from the
base package). For an analog model,
</p>
<p style="text-align: center;"><code class="reqn">H(s) = \frac{b_1s^{m-1} + b_2s^{m-2} + \dots + b_m}{a_1s^{n-1} +
    a_2s^{n-2} + \dots + a_n}</code>
</p>

<p>For a z-plane digital model,
</p>
<p style="text-align: center;"><code class="reqn">H(z) = \frac{b_1 + b_2z^{-1} + \dots + b_mz^{-m+1}}{a_1 + a_2z^{-1} + \dots + a_nz^{-n+1}}</code>
</p>

<p><code>as.Arma</code> converts from other forms, including <code>Zpg</code> and <code>Ma</code>. 
</p>


<h3>Value</h3>

<p>A list of class <code>Arma</code> with the following list elements:
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Tom Short, EPRI Solutions, Inc., (<a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a>) </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+as.Zpg">as.Zpg</a></code>, <code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, and various
filter-generation functions like <code><a href="#topic+butter">butter</a></code> and
<code><a href="#topic+cheby1">cheby1</a></code> that return Arma models.</p>


<h3>Examples</h3>

<pre><code class='language-R'>filt &lt;- Arma(b = c(1, 2, 1)/3, a = c(1, 1))
zplane(filt)
</code></pre>

<hr>
<h2 id='bilinear'> Bilinear transformation </h2><span id='topic+bilinear'></span><span id='topic+bilinear.default'></span><span id='topic+bilinear.Zpg'></span><span id='topic+bilinear.Arma'></span>

<h3>Description</h3>

<p>Transform a s-plane filter specification into a z-plane
specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
bilinear(Sz, Sp, Sg, T, ...)

## S3 method for class 'Zpg'
bilinear(Sz, T, ...)

## S3 method for class 'Arma'
bilinear(Sz, T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bilinear_+3A_sz">Sz</code></td>
<td>
<p> In the generic case, a model to be transformed. In the
default case, a vector containing the zeros in a pole-zero-gain model. </p>
</td></tr>
<tr><td><code id="bilinear_+3A_sp">Sp</code></td>
<td>
<p> a vector containing the poles in a pole-zero-gain model. </p>
</td></tr>
<tr><td><code id="bilinear_+3A_sg">Sg</code></td>
<td>
<p> a vector containing the gain in a pole-zero-gain model. </p>
</td></tr>
<tr><td><code id="bilinear_+3A_t">T</code></td>
<td>
<p> the sampling frequency represented in the z plane. </p>
</td></tr>
<tr><td><code id="bilinear_+3A_...">...</code></td>
<td>
<p> Arguments passed to the generic function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a piecewise flat filter design, you can transform it
from the s-plane to the z-plane while maintaining the band edges by
means of the bilinear transform.  This maps the left hand side of the
s-plane into the interior of the unit circle.  The mapping is highly
non-linear, so you must design your filter with band edges in the
s-plane positioned at <code class="reqn">2/T tan(w*T/2)</code> so that they will be positioned
at w after the bilinear transform is complete.
</p>
<p>The bilinear transform is:
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{1 + sT/2}{1 - sT/2}</code>
</p>

<p style="text-align: center;"><code class="reqn">s = \frac{T}{2}\frac{z - 1}{z + 1}</code>
</p>

<p>Please note that a pole and a zero at the same place exactly cancel.
This is significant since the bilinear transform creates numerous
extra poles and zeros, most of which cancel. Those which do not
cancel have a &ldquo;fill-in&rdquo; effect, extending the shorter of the sets to
have the same number of as the longer of the sets of poles and zeros
(or at least split the difference in the case of the band pass
filter). There may be other opportunistic cancellations, but it will
not check for them.
</p>
<p>Also note that any pole on the unit circle or beyond will result in
an unstable filter. Because of cancellation, this will only happen
if the number of poles is smaller than the number of zeros. The
analytic design methods all yield more poles than zeros, so this will
not be a problem.
</p>


<h3>Value</h3>

<p>For the default case or for <code>bilinear.Zpg</code>, an object of class
&ldquo;Zpg&rdquo;, containing the list elements:
</p>
<table>
<tr><td><code>zero</code></td>
<td>
<p> complex vector of the zeros of the transformed model </p>
</td></tr>
<tr><td><code>pole</code></td>
<td>
<p> complex vector of the poles of the transformed model </p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p> gain of the transformed model </p>
</td></tr>
</table>
<p>For <code>bilinear.Arma</code>, an object of class
&ldquo;Arma&rdquo;, containing the list elements:
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p> Proakis &amp; Manolakis (1992). <em>Digital Signal Processing</em>. New York:
Macmillan Publishing Company.
</p>
<p><a href="https://en.wikipedia.org/wiki/Bilinear_transform">https://en.wikipedia.org/wiki/Bilinear_transform</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Zpg">Zpg</a></code>, <code><a href="#topic+sftrans">sftrans</a></code>,
<code><a href="#topic+Arma">Arma</a></code></p>

<hr>
<h2 id='butter'> Generate a Butterworth filter. </h2><span id='topic+butter'></span><span id='topic+butter.default'></span><span id='topic+butter.FilterOfOrder'></span>

<h3>Description</h3>

<p>Generate Butterworth filter polynomial coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
butter(n, W, type = c("low", "high", "stop", "pass"),
plane = c("z", "s"), ...)

## S3 method for class 'FilterOfOrder'
butter(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butter_+3A_n">n</code></td>
<td>
<p> filter order or generic filter model</p>
</td></tr>
<tr><td><code id="butter_+3A_w">W</code></td>
<td>
<p> critical frequencies of the filter. <code>W</code> must be a
scalar for low-pass and high-pass filters, and <code>W</code> must be a
two-element vector <code>c(low, high)</code> specifying the lower and
upper bands. For digital filters, <code>W</code> must be between 0 and 1
where 1 is the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="butter_+3A_type">type</code></td>
<td>
<p> Filter type, one of <code>"low"</code> for a low-pass filter,
<code>"high"</code> for a high-pass filter, <code>"stop"</code> for a stop-band (band-reject)
filter, or <code>"pass"</code> for a pass-band filter. </p>
</td></tr>
<tr><td><code id="butter_+3A_plane">plane</code></td>
<td>
 <p><code>"z"</code> for a digital filter or <code>"s"</code> for an
analog filter. </p>
</td></tr>
<tr><td><code id="butter_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code>butter</code>,
overriding those given by <code>n</code> of class <code>FilterOfOrder</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>butter</code> is generic, it can be extended to accept other
inputs, using <code>"buttord"</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>An <code>Arma</code> object with list elements:
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Modified by Doug Stewart. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p> Proakis &amp; Manolakis (1992). <em>Digital Signal Processing</em>. New
York: Macmillan Publishing Company.
</p>
<p><a href="https://en.wikipedia.org/wiki/Butterworth_filter">https://en.wikipedia.org/wiki/Butterworth_filter</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+cheby1">cheby1</a></code>,
<code><a href="#topic+ellip">ellip</a></code>, and <code><a href="#topic+buttord">buttord</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  bf &lt;- butter(4, 0.1)
  freqz(bf)
  zplane(bf)
</code></pre>

<hr>
<h2 id='buttord'> Butterworth filter order and cutoff </h2><span id='topic+buttord'></span>

<h3>Description</h3>

<p>Compute butterworth filter order and cutoff for the desired response
characteristics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>buttord(Wp, Ws, Rp, Rs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buttord_+3A_wp">Wp</code>, <code id="buttord_+3A_ws">Ws</code></td>
<td>
<p> pass-band and stop-band edges. For a low-pass or
high-pass filter, <code>Wp</code> and <code>Ws</code> are scalars. For a
band-pass or band-rejection filter, both are vectors of length
2. For a low-pass filter, <code>Wp &lt; Ws</code>. For a
high-pass filter, <code>Ws &gt; Wp</code>. For a band-pass (<code>Ws[1] &lt; Wp[1] &lt; Wp[2] &lt;
    Ws[2]</code>) or band-reject (<code>Wp[1] &lt; Ws[1] &lt; Ws[2] &lt; Wp[2]</code>)
filter design, <code>Wp</code> gives the edges of the pass band, and <code>Ws</code> gives
the edges of the stop band. Frequencies are normalized to [0,1],
corresponding to the range [0, Fs/2]. </p>
</td></tr>
<tr><td><code id="buttord_+3A_rp">Rp</code></td>
<td>
<p> allowable decibels of ripple in the pass band. </p>
</td></tr>
<tr><td><code id="buttord_+3A_rs">Rs</code></td>
<td>
<p> minimum attenuation in the stop band in dB. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deriving the order and cutoff is based on:
</p>
<p style="text-align: center;"><code class="reqn">|H(W)|^2 = \frac{1}{1+(W/Wc)^{2n}} = 10^{-R/10}</code>
</p>

<p>With some algebra, you can solve simultaneously for <code>Wc</code> and <code>n</code> given
<code>Ws</code>, <code>Rs</code> and <code>Wp</code>, <code>Rp</code>. For high-pass filters, subtracting the band edges
from Fs/2, performing the test, and swapping the resulting <code>Wc</code> back
works beautifully. For bandpass- and bandstop-filters, this process
significantly overdesigns. Artificially dividing <code>n</code> by 2 in this case
helps a lot, but it still overdesigns.
</p>


<h3>Value</h3>

<p>An object of class <code>FilterOfOrder</code> with the following list elements:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p> filter order </p>
</td></tr>
<tr><td><code>Wc</code></td>
<td>
<p> cutoff frequency </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> filter type, one of &ldquo;low&rdquo;, &ldquo;high&rdquo;, &ldquo;stop&rdquo;, or &ldquo;pass&rdquo; </p>
</td></tr>
</table>
<p>This object can be passed directly to <code>butter</code> to compute filter coefficients.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle,
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+butter">butter</a></code>, <code><a href="#topic+FilterOfOrder">FilterOfOrder</a></code>, <code><a href="#topic+cheb1ord">cheb1ord</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>Fs &lt;- 10000
btord &lt;- buttord(1000/(Fs/2), 1200/(Fs/2), 0.5, 29)
plot(c(0, 1000, 1000, 0, 0), c(0, 0, -0.5, -0.5, 0),
     type = "l", xlab = "Frequency (Hz)", ylab = "Attenuation (dB)")
bt &lt;- butter(btord)
plot(c(0, 1000, 1000, 0, 0), c(0, 0, -0.5, -0.5, 0),
     type = "l", xlab = "Frequency (Hz)", ylab = "Attenuation (dB)",
     col = "red", ylim = c(-10,0), xlim = c(0,2000))
hf &lt;- freqz(bt, Fs = Fs)
lines(hf$f, 20*log10(abs(hf$h)))

</code></pre>

<hr>
<h2 id='cheb1ord'> Chebyshev type-I filter order and cutoff </h2><span id='topic+cheb1ord'></span>

<h3>Description</h3>

<p>Compute discrete Chebyshev type-I filter order and cutoff for the desired response
characteristics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheb1ord(Wp, Ws, Rp, Rs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheb1ord_+3A_wp">Wp</code>, <code id="cheb1ord_+3A_ws">Ws</code></td>
<td>
<p> pass-band and stop-band edges. For a low-pass or
high-pass filter, <code>Wp</code> and <code>Ws</code> are scalars. For a
band-pass or band-rejection filter, both are vectors of length
2. For a low-pass filter, <code>Wp &lt; Ws</code>. For a
high-pass filter, <code>Ws &gt; Wp</code>. For a band-pass (<code>Ws[1] &lt; Wp[1] &lt; Wp[2] &lt;
    Ws[2]</code>) or band-reject (<code>Wp[1] &lt; Ws[1] &lt; Ws[2] &lt; Wp[2]</code>)
filter design, <code>Wp</code> gives the edges of the pass band, and <code>Ws</code> gives
the edges of the stop band. Frequencies are normalized to [0,1],
corresponding to the range [0, Fs/2]. </p>
</td></tr>
<tr><td><code id="cheb1ord_+3A_rp">Rp</code></td>
<td>
<p> allowable decibels of ripple in the pass band. </p>
</td></tr>
<tr><td><code id="cheb1ord_+3A_rs">Rs</code></td>
<td>
<p> minimum attenuation in the stop band in dB. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>FilterOfOrder</code> with the following list elements:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p> filter order </p>
</td></tr>
<tr><td><code>Wc</code></td>
<td>
<p> cutoff frequency </p>
</td></tr>
<tr><td><code>Rp</code></td>
<td>
<p> allowable decibels of ripple in the pass band </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> filter type, one of &ldquo;low&rdquo;, &ldquo;high&rdquo;, &ldquo;stop&rdquo;, or &ldquo;pass&rdquo; </p>
</td></tr>
</table>
<p>This object can be passed directly to <code>cheby1</code> to compute filter coefficients.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle,
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a> and by Laurent S. Mazet. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cheby1">cheby1</a></code>, <code><a href="#topic+FilterOfOrder">FilterOfOrder</a></code>, <code><a href="#topic+buttord">buttord</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>Fs &lt;- 10000
chord &lt;- cheb1ord(1000/(Fs/2), 1200/(Fs/2), 0.5, 29)
plot(c(0, 1000, 1000, 0, 0), c(0, 0, -0.5, -0.5, 0),
     type = "l", xlab = "Frequency (Hz)", ylab = "Attenuation (dB)")
ch1 &lt;- cheby1(chord)
plot(c(0, 1000, 1000, 0, 0), c(0, 0, -0.5, -0.5, 0),
     type = "l", xlab = "Frequency (Hz)", ylab = "Attenuation (dB)",
     col = "red", ylim = c(-10,0), xlim = c(0,2000))
hf &lt;- freqz(ch1, Fs = Fs)
lines(hf$f, 20*log10(abs(hf$h)))
</code></pre>

<hr>
<h2 id='chebwin'> Dolph-Chebyshev window coefficients </h2><span id='topic+chebwin'></span>

<h3>Description</h3>

<p>Returns the filter coefficients of the n-point Dolph-Chebyshev window
with a given attenuation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chebwin(n, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chebwin_+3A_n">n</code></td>
<td>
<p> length of the filter; number of coefficients to generate. </p>
</td></tr>
<tr><td><code id="chebwin_+3A_at">at</code></td>
<td>
<p> dB of attenuation in the stop-band of the corresponding
Fourier transform. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The window is described in frequency domain by the expression:
</p>
<p style="text-align: center;"><code class="reqn"> W(k) = \frac{Cheb(n-1, \beta * cos(pi * k/n))}{Cheb(n-1, \beta)}</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">\beta = cosh(1/(n-1) * acosh(10^{at/20}))</code>
</p>

<p>and <code class="reqn">Cheb(m,x)</code> denoting the <code class="reqn">m</code>-th order Chebyshev polynomial calculated
at the point <code class="reqn">x</code>.
</p>
<p>Note that the denominator in <code class="reqn">W(k)</code> above is not computed, and after
the inverse Fourier transform the window is scaled by making its
maximum value unitary.
</p>


<h3>Value</h3>

<p>An array of length <code>n</code> with the filter coefficients. 
</p>


<h3>Author(s)</h3>

<p>Original Octave version by Andr√© Carezia, <a href="mailto:acarezia@uol.com.br">acarezia@uol.com.br</a>. Conversion to R by Tom Short.</p>


<h3>References</h3>

<p>Peter Lynch, &ldquo;The Dolph-Chebyshev Window: A Simple Optimal Filter&rdquo;,
Monthly Weather Review, Vol. 125, pp. 655-660, April 1997.
<a href="http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf">http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf</a>
</p>
<p>C. Dolph, &ldquo;A current distribution for broadside arrays which
optimizes the relationship between beam width and side-lobe level&rdquo;,
Proc. IEEE, 34, pp. 335-348.
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+kaiser">kaiser</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(chebwin(50, 100))
</code></pre>

<hr>
<h2 id='cheby1'> Generate a Chebyshev filter. </h2><span id='topic+cheby1'></span><span id='topic+cheby1.default'></span><span id='topic+cheby1.FilterOfOrder'></span><span id='topic+cheby2'></span><span id='topic+cheby2.default'></span><span id='topic+cheby2.FilterOfOrder'></span>

<h3>Description</h3>

<p>Generate a Chebyshev type I or type II filter coefficients with specified dB of pass band ripple.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
cheby1(n, Rp, W, type = c("low", "high", "stop",
"pass"), plane = c("z", "s"), ...)

## S3 method for class 'FilterOfOrder'
cheby1(n, Rp = n$Rp, W = n$Wc, type = n$type, ...)

## Default S3 method:
cheby2(n, Rp, W, type = c("low", "high", "stop",
"pass"), plane = c("z", "s"), ...)

## S3 method for class 'FilterOfOrder'
cheby2(n, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheby1_+3A_n">n</code></td>
<td>
<p> filter order or generic filter model</p>
</td></tr>
<tr><td><code id="cheby1_+3A_rp">Rp</code></td>
<td>
<p> dB of pass band ripple </p>
</td></tr>
<tr><td><code id="cheby1_+3A_w">W</code></td>
<td>
<p> critical frequencies of the filter. <code>W</code> must be a
scalar for low-pass and high-pass filters, and <code>W</code> must be a
two-element vector <code>c(low, high)</code> specifying the lower and
upper bands. For digital filters, <code>W</code> must be between 0 and 1
where 1 is the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="cheby1_+3A_type">type</code></td>
<td>
<p> Filter type, one of <code>"low"</code> for a low-pass filter,
<code>"high"</code> for a high-pass filter, <code>"stop"</code> for a stop-band (band-reject)
filter, or <code>"pass"</code> for a pass-band filter. </p>
</td></tr>
<tr><td><code id="cheby1_+3A_plane">plane</code></td>
<td>
 <p><code>"z"</code> for a digital filter or <code>"s"</code> for an
analog filter. </p>
</td></tr>
<tr><td><code id="cheby1_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code>cheby1</code> or <code>cheby2</code>,
overriding those given by <code>n</code> of class <code>FilterOfOrder</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>cheby1</code> and <code>cheby2</code> are generic, they can be extended to accept other
inputs, using <code>"cheb1ord"</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>An <code>Arma</code> object with list elements:
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td></tr>
</table>
<p>For <code>cheby1</code>, the ARMA model specifies a type-I Chebyshev filter,
and for <code>cheby2</code>, a type-II Chebyshev filter.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Modified by Doug Stewart. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p> Parks &amp; Burrus (1987). <em>Digital Filter Design</em>. New York: John Wiley &amp; Sons, Inc.
</p>
<p><a href="https://en.wikipedia.org/wiki/Chebyshev_filter">https://en.wikipedia.org/wiki/Chebyshev_filter</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code>,
<code><a href="#topic+ellip">ellip</a></code>, and <code><a href="#topic+cheb1ord">cheb1ord</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # compare the frequency responses of 5th-order Butterworth and Chebyshev filters.
  bf &lt;- butter(5, 0.1)
  cf &lt;- cheby1(5, 3, 0.1)
  bfr &lt;- freqz(bf)
  cfr &lt;- freqz(cf)
  plot(bfr$f/pi, 20 * log10(abs(bfr$h)), type = "l", ylim = c(-40, 0),
       xlim = c(0, .5), xlab = "Frequency", ylab = c("dB"))
  lines(cfr$f/pi, 20 * log10(abs(cfr$h)), col = "red")
  # compare type I and type II Chebyshev filters.
  c1fr &lt;- freqz(cheby1(5, .5, 0.5))
  c2fr &lt;- freqz(cheby2(5, 20, 0.5))
  plot(c1fr$f/pi, abs(c1fr$h), type = "l", ylim = c(0, 1),
       xlab = "Frequency", ylab = c("Magnitude"))
  lines(c2fr$f/pi, abs(c2fr$h), col = "red")
</code></pre>

<hr>
<h2 id='chirp'> A chirp signal </h2><span id='topic+chirp'></span>

<h3>Description</h3>

<p>Generate a chirp signal.  A chirp signal is a frequency swept cosine wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chirp(t, f0 = 0, t1 = 1, f1 = 100, 
      form = c("linear", "quadratic", "logarithmic"), phase = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chirp_+3A_t">t</code></td>
<td>
<p> array of times at which to evaluate the chirp signal. </p>
</td></tr>
<tr><td><code id="chirp_+3A_f0">f0</code></td>
<td>
<p> frequency at time t=0. </p>
</td></tr>
<tr><td><code id="chirp_+3A_t1">t1</code></td>
<td>
<p> time, s. </p>
</td></tr>
<tr><td><code id="chirp_+3A_f1">f1</code></td>
<td>
<p> frequency at time t=t1. </p>
</td></tr>
<tr><td><code id="chirp_+3A_form">form</code></td>
<td>
<p> shape of frequency sweep, one of <code>"linear"</code>, <code>"quadratic"</code>,
or <code>"logarithmic"</code>. </p>
</td></tr>
<tr><td><code id="chirp_+3A_phase">phase</code></td>
<td>
<p> phase shift at t=0. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>'linear'</code> is:
</p>
<p style="text-align: center;"><code class="reqn">f(t) = (f1-f0)*(t/t1) + f0</code>
</p>

<p><code>'quadratic'</code> is:
</p>
<p style="text-align: center;"><code class="reqn">f(t) = (f1-f0)*(t/t1)^2 + f0</code>
</p>

<p><code>'logarithmic'</code> is:
</p>
<p style="text-align: center;"><code class="reqn">f(t) = (f1-f0)^{t/t1} + f0</code>
</p>



<h3>Value</h3>

<p>Chirp signal, an array the same length as <code>t</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle.
Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+specgram">specgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>ch &lt;- chirp(seq(0, 0.6, len=5000))
plot(ch, type = "l")

# Shows a quadratic chirp of 400 Hz at t=0 and 100 Hz at t=10
# Time goes from -2 to 15 seconds.
specgram(chirp(seq(-2, 15, by=0.001), 400, 10, 100, "quadratic"))

# Shows a logarithmic chirp of 200 Hz at t=0 and 500 Hz at t=2
# Time goes from 0 to 5 seconds at 8000 Hz.
specgram(chirp(seq(0, 5, by=1/8000), 200, 2, 500, "logarithmic"))
</code></pre>

<hr>
<h2 id='conv'> Convolution </h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>A Matlab/Octave compatible convolution function that uses the Fast Fourier
Transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_x">x</code>, <code id="conv_+3A_y">y</code></td>
<td>
<p> numeric sequences to be convolved. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs <code>x</code> and <code>y</code> are post padded with zeros as follows:
</p>
<p><code>ifft(fft(postpad(x, n) * fft(postpad(y, n))))</code>
</p>
<p>where <code>n = length(x) + length(y) - 1</code>
</p>


<h3>Value</h3>

<p>An array of length equal to <code>length(x) + length(y) - 1</code>.
If <code>x</code> and <code>y</code> are polynomial coefficient vectors,
<code>conv</code> returns the coefficients of the product polynomial.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+convolve">convolve</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>,
<code><a href="#topic+ifft">ifft</a></code>, <code><a href="#topic+fftfilt">fftfilt</a></code>, <code><a href="#topic+poly">poly</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>conv(c(1,2,3), c(1,2))
conv(c(1,2), c(1,2,3))
conv(c(1,-2), c(1,2))
</code></pre>

<hr>
<h2 id='decimate'> Decimate or downsample a signal </h2><span id='topic+decimate'></span>

<h3>Description</h3>

<p>Downsample a signal by a factor, using an FIR or IIR filter.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimate(x, q, n = if (ftype == "iir") 8 else 30, ftype = "iir")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimate_+3A_x">x</code></td>
<td>
<p> signal to be decimated. </p>
</td></tr>
<tr><td><code id="decimate_+3A_q">q</code></td>
<td>
<p> integer factor to downsample by. </p>
</td></tr>
<tr><td><code id="decimate_+3A_n">n</code></td>
<td>
<p> filter order used in the downsampling. </p>
</td></tr>
<tr><td><code id="decimate_+3A_ftype">ftype</code></td>
<td>
<p> filter type, <code>"iir"</code> or <code>"fir"</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, an order 8 Chebyshev type I
filter is used or a 30-point FIR filter if <code>ftype</code> is <code>'fir'</code>.  Note
that <code>q</code> must be an integer for this rate change method.
</p>
<p>Makes use of the <code><a href="#topic+filtfilt">filtfilt</a></code> function with all its limitations.
</p>


<h3>Value</h3>

<p>The decimated signal, an array of length <code>ceiling(length(x) / q)</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+resample">resample</a></code>, <code><a href="#topic+interp">interp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># The signal to decimate starts away from zero, is slowly varying
# at the start and quickly varying at the end, decimate and plot.
# Since it starts away from zero, you will see the boundary
# effects of the antialiasing filter clearly.  You will also see
# how it follows the curve nicely in the slowly varying early
# part of the signal, but averages the curve in the quickly
# varying late part of the signal.
t &lt;- seq(0, 2, by = 0.01)
x &lt;- chirp(t, 2, 0.5, 10, 'quadratic') + sin(2*pi*t*0.4)
y &lt;- decimate(x, 4)   # factor of 4 decimation
plot(t, x, type = "l")
lines(t[seq(1,length(t), by = 4)], y, col = "blue")
</code></pre>

<hr>
<h2 id='ellip'> Elliptic or Cauer filter </h2><span id='topic+ellip'></span><span id='topic+ellip.default'></span><span id='topic+ellip.FilterOfOrder'></span>

<h3>Description</h3>

<p>Generate an Elliptic or Cauer filter (discrete and continuous).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ellip(n, Rp, Rs, W, type = c("low", "high", "stop",
"pass"), plane = c("z", "s"), ...)

## S3 method for class 'FilterOfOrder'
ellip(n, Rp = n$Rp, Rs = n$Rs, W = n$Wc, type = n$type, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellip_+3A_n">n</code></td>
<td>
<p> filter order or generic filter model</p>
</td></tr>
<tr><td><code id="ellip_+3A_rp">Rp</code></td>
<td>
<p> dB of pass band ripple </p>
</td></tr>
<tr><td><code id="ellip_+3A_rs">Rs</code></td>
<td>
<p> dB of stop band ripple </p>
</td></tr>
<tr><td><code id="ellip_+3A_w">W</code></td>
<td>
<p> critical frequencies of the filter. <code>W</code> must be a
scalar for low-pass and high-pass filters, and <code>W</code> must be a
two-element vector <code>c(low, high)</code> specifying the lower and
upper bands. For digital filters, <code>W</code> must be between 0 and 1
where 1 is the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="ellip_+3A_type">type</code></td>
<td>
<p> Filter type, one of <code>"low"</code> for a low-pass filter,
<code>"high"</code> for a high-pass filter, <code>"stop"</code> for a stop-band (band-reject)
filter, or <code>"pass"</code> for a pass-band filter. </p>
</td></tr>
<tr><td><code id="ellip_+3A_plane">plane</code></td>
<td>
 <p><code>"z"</code> for a digital filter or <code>"s"</code> for an
analog filter. </p>
</td></tr>
<tr><td><code id="ellip_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code>ellip</code>,
overriding those given by <code>n</code> of class <code>FilterOfOrder</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>ellip</code> is generic, it can be extended to accept other
inputs, using <code>"ellipord"</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>An <code>Arma</code> object with list elements:
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Paulo Neis
<a href="mailto:p_neis@yahoo.com.br">p_neis@yahoo.com.br</a>.
Modified by Doug Stewart. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p> Oppenheim, Alan V., <em>Discrete Time Signal Processing</em>,
Hardcover, 1999.
</p>
<p>Parente Ribeiro, E., Notas de aula da disciplina TE498 -  Processamento 
Digital de Sinais, UFPR, 2001/2002.
</p>
<p><a href="https://en.wikipedia.org/wiki/Elliptic_filter">https://en.wikipedia.org/wiki/Elliptic_filter</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code>,
<code><a href="#topic+cheby1">cheby1</a></code>, and <code><a href="#topic+ellipord">ellipord</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # compare the frequency responses of 5th-order Butterworth and elliptic filters.
  bf &lt;- butter(5, 0.1)
  ef &lt;- ellip(5, 3, 40, 0.1)
  bfr &lt;- freqz(bf)
  efr &lt;- freqz(ef)
  plot(bfr$f, 20 * log10(abs(bfr$h)), type = "l", ylim = c(-50, 0),
       xlab = "Frequency, radians", ylab = c("dB"))
  lines(efr$f, 20 * log10(abs(efr$h)), col = "red")
</code></pre>

<hr>
<h2 id='ellipord'> Elliptic filter order and cutoff </h2><span id='topic+ellipord'></span>

<h3>Description</h3>

<p>Compute discrete elliptic filter order and cutoff for the desired response
characteristics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipord(Wp, Ws, Rp, Rs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipord_+3A_wp">Wp</code>, <code id="ellipord_+3A_ws">Ws</code></td>
<td>
<p> pass-band and stop-band edges. For a low-pass or
high-pass filter, <code>Wp</code> and <code>Ws</code> are scalars. For a
band-pass or band-rejection filter, both are vectors of length
2. For a low-pass filter, <code>Wp &lt; Ws</code>. For a
high-pass filter, <code>Ws &gt; Wp</code>. For a band-pass (<code>Ws[1] &lt; Wp[1] &lt; Wp[2] &lt;
    Ws[2]</code>) or band-reject (<code>Wp[1] &lt; Ws[1] &lt; Ws[2] &lt; Wp[2]</code>)
filter design, <code>Wp</code> gives the edges of the pass band, and <code>Ws</code> gives
the edges of the stop band. Frequencies are normalized to [0,1],
corresponding to the range [0, Fs/2]. </p>
</td></tr>
<tr><td><code id="ellipord_+3A_rp">Rp</code></td>
<td>
<p> allowable decibels of ripple in the pass band. </p>
</td></tr>
<tr><td><code id="ellipord_+3A_rs">Rs</code></td>
<td>
<p> minimum attenuation in the stop band in dB. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>FilterOfOrder</code> with the following list elements:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p> filter order </p>
</td></tr>
<tr><td><code>Wc</code></td>
<td>
<p> cutoff frequency </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> filter type, one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>, or <code>"pass"</code> </p>
</td></tr>
<tr><td><code>Rp</code></td>
<td>
<p> dB of pass band ripple </p>
</td></tr>
<tr><td><code>Rs</code></td>
<td>
<p> dB of stop band ripple </p>
</td></tr>
</table>
<p>This object can be passed directly to <code>ellip</code> to compute discrete filter coefficients.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paulo Neis
<a href="mailto:p_neis@yahoo.com.br">p_neis@yahoo.com.br</a>.
Modified by Doug Stewart. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>Lamar, Marcus Vinicius, Notas de aula da disciplina TE 456 - Circuitos Analogicos II, UFPR, 2001/2002.
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code>,
<code><a href="#topic+cheby1">cheby1</a></code>, and <code><a href="#topic+ellipord">ellipord</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Fs &lt;- 10000
elord &lt;- ellipord(1000/(Fs/2), 1200/(Fs/2), 0.5, 29)
plot(c(0, 1000, 1000, 0, 0), c(0, 0, -0.5, -0.5, 0),
     type = "l", xlab = "Frequency (Hz)", ylab = "Attenuation (dB)")
el1 &lt;- ellip(elord)
plot(c(0, 1000, 1000, 0, 0), c(0, 0, -0.5, -0.5, 0),
     type = "l", xlab = "Frequency (Hz)", ylab = "Attenuation (dB)",
     col = "red", ylim = c(-35,0), xlim = c(0,2000))
lines(c(5000, 1200, 1200, 5000, 5000), c(-1000, -1000, -29, -29, -1000),
      col = "red")
hf &lt;- freqz(el1, Fs = Fs)
lines(hf$f, 20*log10(abs(hf$h)))
</code></pre>

<hr>
<h2 id='fftfilt'> Filters with an FIR filter using the FFT </h2><span id='topic+fftfilt'></span><span id='topic+filter.FftFilter'></span><span id='topic+FftFilter'></span>

<h3>Description</h3>

<p>Filters with an FIR filter using the FFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftfilt(b, x, n = NULL)

FftFilter(b, n)

## S3 method for class 'FftFilter'
filter(filt, x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftfilt_+3A_b">b</code></td>
<td>
<p> the moving-average (MA) coefficients of
an FIR filter.</p>
</td></tr>
<tr><td><code id="fftfilt_+3A_x">x</code></td>
<td>
<p> the input signal to be filtered. </p>
</td></tr>
<tr><td><code id="fftfilt_+3A_n">n</code></td>
<td>
<p> if given, the length of the FFT window for the overlap-add method. </p>
</td></tr>
<tr><td><code id="fftfilt_+3A_filt">filt</code></td>
<td>
<p> filter to apply to the signal.</p>
</td></tr>
<tr><td><code id="fftfilt_+3A_...">...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>n</code> is not specified explicitly, we do not use the overlap-add
method at all because loops are really slow. Otherwise, we only
ensure that the number of points in the FFT is the smallest power
of two larger than <code>n</code> and <code>length(b)</code>.</p>


<h3>Value</h3>

<p>For <code>fftfilt</code>, the filtered signal, the same length as the input
signal <code>x</code>.
</p>
<p>For <code>FftFilter</code>, a filter of class <code>FftFilter</code> that can be
used with <code>filter</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Kurt Hornik and John W. Eaton.
Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="#topic+filtfilt">filtfilt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- seq(0, 1, len = 100)                     # 1 second sample
x &lt;- sin(2*pi*t*2.3) + 0.25*rnorm(length(t))  # 2.3 Hz sinusoid+noise
z &lt;- fftfilt(rep(1, 10)/10, x) # apply 10-point averaging filter
plot(t, x, type = "l")
lines(t, z, col = "red")

</code></pre>

<hr>
<h2 id='filter'>Filter a signal</h2><span id='topic+filter'></span><span id='topic+filter.default'></span><span id='topic+filter.Arma'></span><span id='topic+filter.Ma'></span><span id='topic+filter.Zpg'></span>

<h3>Description</h3>

<p>Generic filtering function. The default is to filter with an ARMA
filter of given coefficients. The default filtering operation follows
Matlab/Octave conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
filter(filt, a, x, init, init.x, init.y, ...)

## S3 method for class 'Arma'
filter(filt, x, ...)

## S3 method for class 'Ma'
filter(filt, x, ...)

## S3 method for class 'Zpg'
filter(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_filt">filt</code></td>
<td>
<p> For the default case, the moving-average coefficients of
an ARMA filter (normally called &lsquo;b&rsquo;). Generically, <code>filt</code>
specifies an arbitrary filter operation.</p>
</td></tr>
<tr><td><code id="filter_+3A_a">a</code></td>
<td>
<p> the autoregressive (recursive) coefficients of an ARMA filter. </p>
</td></tr>
<tr><td><code id="filter_+3A_x">x</code></td>
<td>
<p> the input signal to be filtered. </p>
</td></tr>
</table>
<p>init, init.x, init.y
</p>
<table>
<tr><td><code id="filter_+3A_init">init</code>, <code id="filter_+3A_init.x">init.x</code>, <code id="filter_+3A_init.y">init.y</code></td>
<td>
<p>allows to supply initial data for the filter - this allows to filter very large timeseries in pieces.</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default filter is an ARMA filter defined as:
</p>
<p style="text-align: center;"><code class="reqn">a_1y_n + a_2y_{n-1} + \dots + a_ny_1 = b_1x_n +
  b_2x_{m-1} + \dots + b_mx_1</code>
</p>

<p>The default filter calls <code>stats:::filter</code>, so it returns a
time-series object. 
</p>
<p>Since <code>filter</code> is generic, it can be extended to call other filter types.
</p>


<h3>Value</h3>

<p>The filtered signal, normally of the same length of the input signal <code>x</code>.
</p>


<h3>Author(s)</h3>

<p> Tom Short, EPRI Solutions, Inc., (<a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a>) </p>


<h3>References</h3>

 
<p><a href="https://en.wikipedia.org/wiki/Digital_filter">https://en.wikipedia.org/wiki/Digital_filter</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+filter">filter</a></code> in the <span class="pkg">stats</span> package, <code><a href="#topic+Arma">Arma</a></code>,
<code><a href="#topic+fftfilt">fftfilt</a></code>, <code><a href="#topic+filtfilt">filtfilt</a></code>, and <code><a href="stats.html#topic+runmed">runmed</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>bf &lt;- butter(3, 0.1)                          # 10 Hz low-pass filter
t &lt;- seq(0, 1, len = 100)                     # 1 second sample
x &lt;- sin(2*pi*t*2.3) + 0.25*rnorm(length(t))  # 2.3 Hz sinusoid+noise
z &lt;- filter(bf, x) # apply filter
plot(t, x, type = "l")
lines(t, z, col = "red")

</code></pre>

<hr>
<h2 id='FilterOfOrder'> Filter of given order and specifications. </h2><span id='topic+FilterOfOrder'></span>

<h3>Description</h3>

<p>IIR filter specifications, including order, frequency cutoff, type, and possibly
others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterOfOrder(n, Wc, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterOfOrder_+3A_n">n</code></td>
<td>
<p> filter order </p>
</td></tr>
<tr><td><code id="FilterOfOrder_+3A_wc">Wc</code></td>
<td>
<p> cutoff frequency </p>
</td></tr>
<tr><td><code id="FilterOfOrder_+3A_type">type</code></td>
<td>
<p> filter type, normally one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>, or <code>"pass"</code> </p>
</td></tr>
<tr><td><code id="FilterOfOrder_+3A_...">...</code></td>
<td>
<p> other filter description characteristics, possibly
including <code>Rp</code> for dB of pass band ripple or <code>Rs</code> for dB
of stop band ripple, depending on filter type (Chebyshev, etc.). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filter is 
</p>


<h3>Value</h3>

<p>A list of class <code>FilterOfOrder</code> with the following elements
(repeats of the input arguments):
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p> filter order </p>
</td></tr>
<tr><td><code>Wc</code></td>
<td>
<p> cutoff frequency </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> filter type, normally one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>, or <code>"pass"</code> </p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> other filter description characteristics, possibly
including <code>Rp</code> for dB of pass band ripple or <code>Rs</code> for dB
of stop band ripple, depending on filter type (Chebyshev, etc.). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Tom Short </p>


<h3>References</h3>

<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code> and <code><a href="#topic+buttord">buttord</a></code>
<code><a href="#topic+cheby1">cheby1</a></code> and <code><a href="#topic+cheb1ord">cheb1ord</a></code>, and
<code><a href="#topic+ellip">ellip</a></code> and <code><a href="#topic+ellipord">ellipord</a></code></p>

<hr>
<h2 id='filtfilt'> Forward and reverse filter a signal </h2><span id='topic+filtfilt'></span><span id='topic+filtfilt.default'></span><span id='topic+filtfilt.Arma'></span><span id='topic+filtfilt.Ma'></span><span id='topic+filtfilt.Zpg'></span>

<h3>Description</h3>

<p>Using two passes, forward and reverse filter a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
filtfilt(filt, a, x, ...)

## S3 method for class 'Arma'
filtfilt(filt, x, ...)

## S3 method for class 'Ma'
filtfilt(filt, x, ...)

## S3 method for class 'Zpg'
filtfilt(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtfilt_+3A_filt">filt</code></td>
<td>
<p> For the default case, the moving-average coefficients of
an ARMA filter (normally called &lsquo;b&rsquo;). Generically, <code>filt</code>
specifies an arbitrary filter operation.</p>
</td></tr>
<tr><td><code id="filtfilt_+3A_a">a</code></td>
<td>
<p> the autoregressive (recursive) coefficients of an ARMA filter. </p>
</td></tr>
<tr><td><code id="filtfilt_+3A_x">x</code></td>
<td>
<p> the input signal to be filtered. </p>
</td></tr>
<tr><td><code id="filtfilt_+3A_...">...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This corrects for phase
distortion introduced by a one-pass filter, though it does square the
magnitude response in the process. That's the theory at least.  In
practice the phase correction is not perfect, and magnitude response
is distorted, particularly in the stop band.
</p>
<p>In this version, we zero-pad the end of the signal to give the reverse
filter time to ramp up to the level at the end of the signal.
Unfortunately, the degree of padding required is dependent on the
nature of the filter and not just its order, so this function needs
some work yet - and is in the state of the year 2000 version of the Octave code.
</p>
<p>Since <code>filtfilt</code> is generic, it can be extended to call other filter types.
</p>


<h3>Value</h3>

<p>The filtered signal, normally the same length as the input signal <code>x</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle,
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Arma">Arma</a></code>,
<code><a href="#topic+fftfilt">fftfilt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bf &lt;- butter(3, 0.1)                        # 10 Hz low-pass filter
t &lt;- seq(0, 1, len = 100)                   # 1 second sample
x &lt;- sin(2*pi*t*2.3) + 0.25*rnorm(length(t))# 2.3 Hz sinusoid+noise
y &lt;- filtfilt(bf, x)
z &lt;- filter(bf, x) # apply filter
plot(t, x)
points(t, y, col="red")
points(t, z, col="blue")
legend("bottomleft", legend = c("data", "filtfilt", "filter"), 
       pch = 1, col = c("black", "red", "blue"), bty = "n")
</code></pre>

<hr>
<h2 id='fir1'> FIR filter generation </h2><span id='topic+fir1'></span>

<h3>Description</h3>

<p>FIR filter coefficients for a filter with the given order and frequency cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fir1(n, w, type = c("low", "high", "stop", "pass", "DC-0", "DC-1"), 
     window = hamming(n + 1), scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fir1_+3A_n">n</code></td>
<td>
<p> order of the filter (1 less than the length of the filter) </p>
</td></tr>
<tr><td><code id="fir1_+3A_w">w</code></td>
<td>
<p> band edges, strictly increasing vector in the range [0,
1], where 1 is the Nyquist frequency. A scalar for highpass or
lowpass filters, a vector pair for
bandpass or bandstop, or a vector for an alternating pass/stop filter. </p>
</td></tr>
<tr><td><code id="fir1_+3A_type">type</code></td>
<td>
<p> character specifying filter type, one of <code>"low"</code> for a low-pass filter,
<code>"high"</code> for a high-pass filter, <code>"stop"</code> for a stop-band (band-reject)
filter, <code>"pass"</code> for a pass-band filter, <code>"DC-0"</code> for a
bandpass as the first band of a multiband filter, or <code>"DC-1"</code> for a
bandstop as the first band of a multiband filter. </p>
</td></tr>
<tr><td><code id="fir1_+3A_window">window</code></td>
<td>
<p> smoothing window. The returned filter is the same shape as the smoothing window. </p>
</td></tr>
<tr><td><code id="fir1_+3A_scale">scale</code></td>
<td>
<p> whether to normalize or not. Use <code>TRUE</code> or <code>'scale'</code> to set
the magnitude of the center of the first passband to 1, and
<code>FALSE</code> or <code>'noscale'</code> to not normalize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The FIR filter coefficients, an array of <code>length(n+1)</code>, of class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle,
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Fir_filter">https://en.wikipedia.org/wiki/Fir_filter</a> 
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Ma">Ma</a></code>,
<code><a href="#topic+fftfilt">fftfilt</a></code>, <code><a href="#topic+fir2">fir2</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>freqz(fir1(40, 0.3))
freqz(fir1(10, c(0.3, 0.5), "stop"))
freqz(fir1(10, c(0.3, 0.5), "pass"))
</code></pre>

<hr>
<h2 id='fir2'> FIR filter generation </h2><span id='topic+fir2'></span>

<h3>Description</h3>

<p>FIR filter coefficients for a filter with the given order and frequency cutoffs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fir2(n, f, m, grid_n = 512, ramp_n = grid_n/20, window = hamming(n + 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fir2_+3A_n">n</code></td>
<td>
<p> order of the filter (1 less than the length of the filter) </p>
</td></tr>
<tr><td><code id="fir2_+3A_f">f</code></td>
<td>
<p> band edges, strictly increasing vector in the range [0,
1] where 1 is the Nyquist frequency. The first element must be 0 and
the last element must be 1.
If elements are identical, it indicates a jump in frequency response. </p>
</td></tr>
<tr><td><code id="fir2_+3A_m">m</code></td>
<td>
<p> magnitude at band edges, a vector of <code>length(f)</code>. </p>
</td></tr>
<tr><td><code id="fir2_+3A_grid_n">grid_n</code></td>
<td>
<p> length of ideal frequency response function
defaults to 512, should be a power of 2 bigger than <code>n</code>. </p>
</td></tr>
<tr><td><code id="fir2_+3A_ramp_n">ramp_n</code></td>
<td>
<p> transition width for jumps in filter response
defaults to <code>grid_n/20</code>. A wider ramp gives wider transitions
but has better stopband characteristics. </p>
</td></tr>
<tr><td><code id="fir2_+3A_window">window</code></td>
<td>
<p> smoothing window. The returned filter is the same shape as the smoothing window. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The FIR filter coefficients, an array of <code>length(n+1)</code>, of class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle,
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Ma">Ma</a></code>,
<code><a href="#topic+fftfilt">fftfilt</a></code>, <code><a href="#topic+fir1">fir1</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- c(0, 0.3, 0.3, 0.6, 0.6, 1)
m &lt;- c(0, 0, 1, 1/2, 0, 0)
fh &lt;- freqz(fir2(100, f, m))
op &lt;- par(mfrow = c(1, 2))
plot(f, m, type = "b", ylab = "magnitude", xlab = "Frequency")
lines(fh$f / pi, abs(fh$h), col = "blue")
# plot in dB:
plot(f, 20*log10(m+1e-5), type = "b", ylab = "dB", xlab = "Frequency")
lines(fh$f / pi, 20*log10(abs(fh$h)), col = "blue")
par(op)
</code></pre>

<hr>
<h2 id='freqs'> s-plane frequency response </h2><span id='topic+freqs'></span><span id='topic+freqs.default'></span><span id='topic+freqs.Arma'></span><span id='topic+freqs.Ma'></span><span id='topic+plot.freqs'></span><span id='topic+print.freqs'></span><span id='topic+freqs_plot'></span><span id='topic+freqs_plot.default'></span><span id='topic+freqs_plot.freqs'></span>

<h3>Description</h3>

<p>Compute the s-plane frequency response of an ARMA model (IIR filter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
freqs(filt = 1, a = 1, W, ...)

## S3 method for class 'Arma'
freqs(filt, ...)

## S3 method for class 'Ma'
freqs(filt, ...)

## S3 method for class 'freqs'
print(x, ...)

## S3 method for class 'freqs'
plot(x, ...)

## Default S3 method:
freqs_plot(w, h, ...) 

## S3 method for class 'freqs'
freqs_plot(w, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqs_+3A_filt">filt</code></td>
<td>
<p> for the default case, the moving-average coefficients of
an ARMA model or filter. Generically, <code>filt</code>
specifies an arbitrary model or filter operation.</p>
</td></tr>
<tr><td><code id="freqs_+3A_a">a</code></td>
<td>
<p> the autoregressive (recursive) coefficients of an ARMA filter. </p>
</td></tr>
<tr><td><code id="freqs_+3A_w">W</code></td>
<td>
<p> the frequencies at which to evaluate the model. </p>
</td></tr>
<tr><td><code id="freqs_+3A_w">w</code></td>
<td>
<p> for the default case, the array of frequencies. Generically, <code>w</code>
specifies an object from which to plot a frequency response. </p>
</td></tr>
<tr><td><code id="freqs_+3A_h">h</code></td>
<td>
<p> a complex array of frequency responses at the given frequencies. </p>
</td></tr>
<tr><td><code id="freqs_+3A_x">x</code></td>
<td>
<p> object to be plotted. </p>
</td></tr>
<tr><td><code id="freqs_+3A_...">...</code></td>
<td>
<p> additional arguments passed through to <code>plot</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When results of <code>freqs</code> are printed, <code>freqs_plot</code> will be
called to display frequency plots of magnitude and phase. As with
<code>lattice</code> plots, automatic printing does not work inside loops and
function calls, so explicit calls to <code>print</code> are
needed there.
</p>


<h3>Value</h3>

<p>For <code>freqs</code> list of class <code>freqs</code> with items:
</p>
<table>
<tr><td><code>H</code></td>
<td>
<p> array of frequencies. </p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p> complex array of frequency responses at those frequencies.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Julius O. Smith III. Conversion to R by Tom Short. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+freqz">freqz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(1, 2)
a &lt;- c(1, 1)
w &lt;- seq(0, 4, length=128)
freqs(b, a, w)
</code></pre>

<hr>
<h2 id='freqz'> z-plane frequency response </h2><span id='topic+freqz'></span><span id='topic+freqz.default'></span><span id='topic+freqz.Arma'></span><span id='topic+freqz.Ma'></span><span id='topic+freqz_plot'></span><span id='topic+freqz_plot.default'></span><span id='topic+freqz_plot.freqz'></span><span id='topic+plot.freqz'></span><span id='topic+print.freqz'></span>

<h3>Description</h3>

<p>Compute the z-plane frequency response of an ARMA model or IIR filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
freqz(filt = 1, a = 1, n = 512, region = NULL, Fs = 2 * pi, ...)

## S3 method for class 'Arma'
freqz(filt, ...)

## S3 method for class 'Ma'
freqz(filt, ...)

## S3 method for class 'freqz'
print(x, ...)

## S3 method for class 'freqz'
plot(x, ...)

## Default S3 method:
freqz_plot(w, h, ...) 

## S3 method for class 'freqz'
freqz_plot(w, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqz_+3A_filt">filt</code></td>
<td>
<p> for the default case, the moving-average coefficients of
an ARMA model or filter. Generically, <code>filt</code>
specifies an arbitrary model or filter operation.</p>
</td></tr>
<tr><td><code id="freqz_+3A_a">a</code></td>
<td>
<p> the autoregressive (recursive) coefficients of an ARMA filter. </p>
</td></tr>
<tr><td><code id="freqz_+3A_n">n</code></td>
<td>
<p> number of points at which to evaluate the frequency response. </p>
</td></tr>
<tr><td><code id="freqz_+3A_region">region</code></td>
<td>
 <p><code>'half'</code> (the default) to evaluate around the upper half of the
unit circle or <code>'whole'</code> to evaluate around the entire unit circle. </p>
</td></tr>
<tr><td><code id="freqz_+3A_fs">Fs</code></td>
<td>
<p> sampling frequency in Hz. If not specified, the frequencies
are in radians. </p>
</td></tr>
<tr><td><code id="freqz_+3A_w">w</code></td>
<td>
<p> for the default case, the array of frequencies. Generically,
<code>w</code> specifies an object from which to plot a frequency response. </p>
</td></tr>
<tr><td><code id="freqz_+3A_h">h</code></td>
<td>
<p> a complex array of frequency responses at the given
frequencies. </p>
</td></tr>
<tr><td><code id="freqz_+3A_x">x</code></td>
<td>
<p> object to be plotted. </p>
</td></tr>
<tr><td><code id="freqz_+3A_...">...</code></td>
<td>
<p> for methods of <code>freqz</code>, arguments are passed to
the default method. For <code>freqz_plot</code>, additional arguments are
passed through to <code>plot</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fastest computation, <code>n</code> should factor into a small number of
small primes.
</p>
<p>When results of <code>freqz</code> are printed, <code>freqz_plot</code> will be
called to display frequency plots of magnitude and phase. As with
<code>lattice</code> plots, automatic printing does not work inside loops and
function calls, so explicit calls to <code>print</code> or <code>plot</code> are
needed there.
</p>


<h3>Value</h3>

<p>For <code>freqz</code> list of class <code>freqz</code> with items:
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p> complex array of frequency responses at those frequencies.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p> array of frequencies. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by John W. Eaton. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+freqs">freqs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(1, 0, -1)
a &lt;- c(1, 0, 0, 0, 0.25)
freqz(b, a)
</code></pre>

<hr>
<h2 id='grpdelay'> Group delay of a filter or model </h2><span id='topic+grpdelay'></span><span id='topic+grpdelay.default'></span><span id='topic+grpdelay.Arma'></span><span id='topic+grpdelay.Ma'></span><span id='topic+grpdelay.Zpg'></span><span id='topic+plot.grpdelay'></span><span id='topic+print.grpdelay'></span>

<h3>Description</h3>

<p>The group delay of a filter or model. The group delay is the time
delay for a sinusoid at a given frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
grpdelay(filt, a = 1, n = 512, whole = FALSE, Fs = NULL, ...)

## S3 method for class 'Arma'
grpdelay(filt, ...)

## S3 method for class 'Ma'
grpdelay(filt, ...)

## S3 method for class 'Zpg'
grpdelay(filt, ...)

## S3 method for class 'grpdelay'
plot(x, xlab = if(x$HzFlag) 'Hz' else 'radian/sample', 
    ylab = 'Group delay (samples)', type = "l", ...)

## S3 method for class 'grpdelay'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grpdelay_+3A_filt">filt</code></td>
<td>
<p> for the default case, the moving-average coefficients of
an ARMA model or filter. Generically, <code>filt</code>
specifies an arbitrary model or filter operation.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_a">a</code></td>
<td>
<p> the autoregressive (recursive) coefficients of an ARMA filter. </p>
</td></tr>
<tr><td><code id="grpdelay_+3A_n">n</code></td>
<td>
<p> number of points at which to evaluate the frequency response. </p>
</td></tr>
<tr><td><code id="grpdelay_+3A_whole">whole</code></td>
<td>
<p><code>FALSE</code> (the default) to evaluate
around the upper half of the
unit circle or <code>TRUE</code> to evaluate around the entire unit circle. </p>
</td></tr>
<tr><td><code id="grpdelay_+3A_fs">Fs</code></td>
<td>
<p> sampling frequency in Hz. If not specified, the frequencies
are in radians. </p>
</td></tr>
<tr><td><code id="grpdelay_+3A_x">x</code></td>
<td>
<p> object to be plotted. </p>
</td></tr>
<tr><td><code id="grpdelay_+3A_xlab">xlab</code>, <code id="grpdelay_+3A_ylab">ylab</code>, <code id="grpdelay_+3A_type">type</code></td>
<td>
<p>as in <code><a href="graphics.html#topic+plot">plot</a></code>, but with more 
sensible defaults.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_...">...</code></td>
<td>
<p> for methods of <code>grpdelay</code>, arguments are passed to
the default method. For <code>plot.grpdelay</code>, additional arguments
are passed through to <code>plot</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fastest computation, <code>n</code> should factor into a small number of
small primes.
</p>
<p>If the denominator of the computation becomes too small, the group delay
is set to zero.  (The group delay approaches infinity when
there are poles or zeros very close to the unit circle in the z plane.)
</p>
<p>When results of <code>grpdelay</code> are printed, the group delay will be
plotted. As with <code>lattice</code> plots, automatic printing does not work
inside loops and function calls, so explicit calls to <code>print</code> or
<code>plot</code> are needed there.
</p>


<h3>Value</h3>

<p>A list of class <code>grpdelay</code> with items:
</p>
<table>
<tr><td><code>gd</code></td>
<td>
<p> the group delay, in units of samples.  It can be converted
to seconds by multiplying by the sampling period (or dividing by
the sampling rate <code>Fs</code>).</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p> frequencies at which the group delay was calculated.</p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p> number of points at which the group delay was calculated.</p>
</td></tr>
<tr><td><code>HzFlag</code></td>
<td>
 <p><code>TRUE</code> for frequencies in Hz, <code>FALSE</code> for frequencies in radians.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Julius O. Smith III and Paul Kienzle. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p><a href="https://ccrma.stanford.edu/~jos/filters/Numerical_Computation_Group_Delay.html">https://ccrma.stanford.edu/~jos/filters/Numerical_Computation_Group_Delay.html</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Group_delay">https://en.wikipedia.org/wiki/Group_delay</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+freqz">freqz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two Zeros and Two Poles
b &lt;- poly(c(1/0.9*exp(1i*pi*0.2), 0.9*exp(1i*pi*0.6)))
a &lt;- poly(c(0.9*exp(-1i*pi*0.6), 1/0.9*exp(-1i*pi*0.2)))
gpd &lt;- grpdelay(b, a, 512, whole = TRUE, Fs = 1)
print(gpd)
plot(gpd)
</code></pre>

<hr>
<h2 id='ifft'> Inverse FFT </h2><span id='topic+ifft'></span>

<h3>Description</h3>

<p>Matlab/Octave-compatible inverse FFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifft(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifft_+3A_x">x</code></td>
<td>
<p> the input array. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses <code>fft</code> from the stats package as follows:
</p>
<p><code>fft(x, inverse = TRUE)/length(x)</code>
</p>
<p>Note that it does not attempt to make the results real.
</p>


<h3>Value</h3>

<p>The inverse FFT of the input, the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p> Tom Short </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+fft">fft</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ifft(fft(1:4))
</code></pre>

<hr>
<h2 id='impz'> Impulse-response characteristics </h2><span id='topic+impz'></span><span id='topic+impz.default'></span><span id='topic+impz.Arma'></span><span id='topic+impz.Ma'></span><span id='topic+print.impz'></span><span id='topic+plot.impz'></span>

<h3>Description</h3>

<p>Impulse-response characteristics of a discrete filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
impz(filt, a = 1, n = NULL, Fs = 1, ...)

## S3 method for class 'Arma'
impz(filt, ...)

## S3 method for class 'Ma'
impz(filt, ...)

## S3 method for class 'impz'
plot(x, xlab = "Time, msec", ylab = "", type = "l",
    main = "Impulse response", ...)

## S3 method for class 'impz'
print(x, xlab = "Time, msec", ylab = "", type = "l",
    main = "Impulse response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impz_+3A_filt">filt</code></td>
<td>
<p> for the default case, the moving-average coefficients of
an ARMA model or filter. Generically, <code>filt</code>
specifies an arbitrary model or filter operation.</p>
</td></tr>
<tr><td><code id="impz_+3A_a">a</code></td>
<td>
<p> the autoregressive (recursive) coefficients of an ARMA filter. </p>
</td></tr>
<tr><td><code id="impz_+3A_n">n</code></td>
<td>
<p> number of points at which to evaluate the frequency response. </p>
</td></tr>
<tr><td><code id="impz_+3A_fs">Fs</code></td>
<td>
<p> sampling frequency in Hz. If not specified, the frequencies
are in per unit. </p>
</td></tr>
<tr><td><code id="impz_+3A_...">...</code></td>
<td>
<p> for methods of <code>impz</code>, arguments are passed to
the default method. For <code>plot.impz</code>, additional arguments are
passed through to <code>plot</code>. </p>
</td></tr>
<tr><td><code id="impz_+3A_x">x</code></td>
<td>
<p> object to be plotted. </p>
</td></tr>
<tr><td><code id="impz_+3A_xlab">xlab</code>, <code id="impz_+3A_ylab">ylab</code>, <code id="impz_+3A_main">main</code></td>
<td>
<p>axis labels anmd main title with sensible defaults.</p>
</td></tr>
<tr><td><code id="impz_+3A_type">type</code></td>
<td>
<p>as in <code><a href="graphics.html#topic+plot">plot</a></code>, uses lines to connect the points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When results of <code>impz</code> are printed, the impulse response will be
plotted. As with
<code>lattice</code> plots, automatic printing does not work inside loops and
function calls, so explicit calls to <code>print</code> or <code>plot</code> are
needed there.
</p>


<h3>Value</h3>

<p>For <code>impz</code>, a list of class <code>impz</code> with items:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> impulse response signal. </p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p> time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Kurt Hornik and John W. Eaton.
Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p><a href="https://en.wikipedia.org/wiki/Impulse_response">https://en.wikipedia.org/wiki/Impulse_response</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+freqz">freqz</a></code>, <code><a href="#topic+zplane">zplane</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>bt &lt;- butter(5, 0.3)
impz(bt)
impz(ellip(5, 0.5, 30, 0.3))
</code></pre>

<hr>
<h2 id='interp'> Interpolate / Increase the sample rate </h2><span id='topic+interp'></span>

<h3>Description</h3>

<p>Upsample a signal by a constant factor by using an FIR filter to
interpolate between points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp(x, q, n = 4, Wc = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_+3A_x">x</code></td>
<td>
<p> the signal to be upsampled. </p>
</td></tr>
<tr><td><code id="interp_+3A_q">q</code></td>
<td>
<p> the integer factor to increase the sampling rate by. </p>
</td></tr>
<tr><td><code id="interp_+3A_n">n</code></td>
<td>
<p> the FIR filter length. </p>
</td></tr>
<tr><td><code id="interp_+3A_wc">Wc</code></td>
<td>
<p> the FIR filter cutoff frequency. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses an order <code>2*q*n+1</code> FIR filter to interpolate between samples.
</p>


<h3>Value</h3>

<p>The upsampled signal, an array of length <code>q * length(x)</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p><a href="https://en.wikipedia.org/wiki/Upsampling">https://en.wikipedia.org/wiki/Upsampling</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fir1">fir1</a></code>, <code><a href="#topic+resample">resample</a></code>, <code><a href="#topic+interp1">interp1</a></code>, <code><a href="#topic+decimate">decimate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># The graph shows interpolated signal following through the
# sample points of the original signal.
t &lt;- seq(0, 2, by = 0.01)
x &lt;- chirp(t, 2, 0.5, 10, 'quadratic') + sin(2*pi*t*0.4)
y &lt;- interp(x[seq(1, length(x), by = 4)], 4, 4, 1) # interpolate a sub-sample
plot(t, x, type = "l")
idx &lt;- seq(1,length(t),by = 4)
lines(t, y[1:length(t)], col = "blue")
points(t[idx], y[idx], col = "blue", pch = 19)
</code></pre>

<hr>
<h2 id='interp1'> Interpolation </h2><span id='topic+interp1'></span>

<h3>Description</h3>

<p>Interpolation methods, including linear, spline, and cubic interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp1(x, y, xi, method = c("linear", "nearest", "pchip", "cubic", "spline"), 
        extrap = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp1_+3A_x">x</code>, <code id="interp1_+3A_y">y</code></td>
<td>
<p> vectors giving the coordinates of the points to be
interpolated. <code>x</code> is assumed to be strictly monotonic.</p>
</td></tr>
<tr><td><code id="interp1_+3A_xi">xi</code></td>
<td>
<p> points at which to interpolate. </p>
</td></tr>
<tr><td><code id="interp1_+3A_method">method</code></td>
<td>
<p> one of <code>"linear"</code>, <code>"nearest"</code>, <code>"pchip"</code>, <code>"cubic"</code>, <code>"spline"</code>. </p>
</td></tr>
<tr><td><code id="interp1_+3A_extrap">extrap</code></td>
<td>
<p> if <code>TRUE</code> or <code>'extrap'</code>, then extrapolate values beyond
the endpoints. If <code>extrap</code> is a number, replace values beyond the
endpoints with that number (defaults to <code>NA</code>).  </p>
</td></tr>
<tr><td><code id="interp1_+3A_...">...</code></td>
<td>
<p> for <code>method='spline'</code>, additional arguments passed to <code>splinefun</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods of interpolation are available:
</p>
<p><code>'nearest'</code>: return nearest neighbour
</p>
<p><code>'linear'</code>: linear interpolation from nearest neighbours
</p>
<p><code>'pchip'</code>: piecewise cubic hermite interpolating polynomial
</p>
<p><code>'cubic'</code>: cubic interpolation from four nearest neighbours
</p>
<p><code>'spline'</code>: cubic spline interpolation&ndash;smooth first and second
derivatives throughout the curve
</p>


<h3>Value</h3>

<p>The interpolated signal, an array of <code>length(xi)</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="#topic+filter">filter</a></code>,
<code><a href="#topic+resample">resample</a></code>, <code><a href="#topic+interp">interp</a></code>, <code><a href="stats.html#topic+spline">spline</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>xf &lt;- seq(0, 11, length=500)
yf &lt;- sin(2*pi*xf/5)
#xp &lt;- c(0:1,3:10)
#yp &lt;- sin(2*pi*xp/5)
xp &lt;- c(0:10)
yp &lt;- sin(2*pi*xp/5)
extrap &lt;- TRUE
lin  &lt;- interp1(xp, yp, xf, 'linear', extrap = extrap)
spl  &lt;- interp1(xp, yp, xf, 'spline', extrap = extrap)
pch  &lt;- interp1(xp, yp, xf, 'pchip', extrap = extrap)
cub  &lt;- interp1(xp, yp, xf, 'cubic', extrap = extrap)
near &lt;- interp1(xp, yp, xf, 'nearest', extrap = extrap)
plot(xp, yp, xlim = c(0, 11))
lines(xf, lin, col = "red")
lines(xf, spl, col = "green")
lines(xf, pch, col = "orange")
lines(xf, cub, col = "blue")
lines(xf, near, col = "purple")
</code></pre>

<hr>
<h2 id='kaiser'> Kaiser window </h2><span id='topic+kaiser'></span>

<h3>Description</h3>

<p>Returns the filter coefficients of the n-point Kaiser window with
parameter beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kaiser(n, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kaiser_+3A_n">n</code></td>
<td>
<p> filter order. </p>
</td></tr>
<tr><td><code id="kaiser_+3A_beta">beta</code></td>
<td>
<p> bessel shape parameter; larger <code>beta</code> gives narrower
windows.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of filter coefficients of <code>length(n)</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Kurt Hornik. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>Oppenheim, A. V., Schafer, R. W., and Buck, J. R. (1999). <em>Discrete-time signal processing</em>. Upper Saddle River, N.J.: Prentice Hall.
</p>
<p><a href="https://en.wikipedia.org/wiki/Kaiser_window">https://en.wikipedia.org/wiki/Kaiser_window</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+hamming">hamming</a></code>, <code><a href="#topic+kaiserord">kaiserord</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(kaiser(101, 2), type = "l", ylim = c(0,1))
lines(kaiser(101, 10), col = "blue")
lines(kaiser(101, 50), col = "green")
</code></pre>

<hr>
<h2 id='kaiserord'> Parameters for an FIR filter from a Kaiser window </h2><span id='topic+kaiserord'></span>

<h3>Description</h3>

<p>Returns the parameters needed for fir1 to produce a filter of the
desired specification from a Kaiser window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kaiserord(f, m, dev, Fs = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kaiserord_+3A_f">f</code></td>
<td>
<p> frequency bands, given as pairs, with the first half of the
first pair assumed to start at 0 and the last half of the last
pair assumed to end at 1.  It is important to separate the
band edges, since narrow transition regions require large order
filters. </p>
</td></tr>
<tr><td><code id="kaiserord_+3A_m">m</code></td>
<td>
<p> magnitude within each band.  Should be non-zero for pass band
and zero for stop band.  All passbands must have the same
magnitude, or you will get the error that pass and stop bands
must be strictly alternating. </p>
</td></tr>
<tr><td><code id="kaiserord_+3A_dev">dev</code></td>
<td>
<p> deviation within each band.  Since all bands in the resulting
filter have the same deviation, only the minimum deviation is
used.  In this version, a single scalar will work just as well. </p>
</td></tr>
<tr><td><code id="kaiserord_+3A_fs">Fs</code></td>
<td>
<p> sampling rate.  Used to convert the frequency specification into
the [0, 1], where 1 corresponds to the Nyquist frequency, Fs/2. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>FilterOfOrder</code> with the following list elements:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p> filter order </p>
</td></tr>
<tr><td><code>Wc</code></td>
<td>
<p> cutoff frequency </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> filter type, one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>, <code>"pass"</code>,
<code>"DC-0"</code>, or <code>"DC-1"</code> </p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p> shape parameter </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>Oppenheim, A. V., Schafer, R. W., and Buck, J. R. (1999). 
<em>Discrete-time signal processing</em>. Upper Saddle River, N.J.: Prentice Hall.
</p>
<p><a href="https://en.wikipedia.org/wiki/Kaiser_window">https://en.wikipedia.org/wiki/Kaiser_window</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+hamming">hamming</a></code>, <code><a href="#topic+kaiser">kaiser</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>Fs &lt;- 11025
op &lt;- par(mfrow = c(2, 2), mar = c(3, 3, 1, 1))
for (i in 1:4) {
  switch(i,
    "1" = {
        bands &lt;- c(1200, 1500)
        mag &lt;- c(1, 0)
        dev &lt;- c(0.1, 0.1)
    },
    "2" = {
        bands &lt;- c(1000, 1500)
        mag &lt;- c(0, 1)
        dev &lt;- c(0.1, 0.1)
    },
    "3" = {
        bands &lt;- c(1000, 1200, 3000, 3500)
        mag &lt;- c(0, 1, 0)
        dev &lt;- 0.1
    },
    "4" = {
        bands &lt;- 100 * c(10, 13, 15, 20, 30, 33, 35, 40)
        mag &lt;- c(1, 0, 1, 0, 1)
        dev &lt;- 0.05
    })
}

  kaisprm &lt;- kaiserord(bands, mag, dev, Fs)
  with(kaisprm, {
    d &lt;&lt;- max(1, trunc(n/10))
    if (mag[length(mag)]==1 &amp;&amp; (d %% 2) == 1)
      d &lt;&lt;- d+1
    f1 &lt;&lt;- freqz(fir1(n, Wc, type, kaiser(n+1, beta), 'noscale'), 
        Fs = Fs)
    f2 &lt;&lt;- freqz(fir1(n-d, Wc, type, kaiser(n-d+1, beta), 'noscale'), 
        Fs = Fs)
  })                                                               
  plot(f1$f,abs(f1$h), col = "blue", type = "l", 
       xlab = "", ylab = "")
  lines(f2$f,abs(f2$h), col = "red")
  legend("right", paste("order", c(kaisprm$n-d, kaisprm$n)), 
         col = c("red", "blue"), lty = 1, bty = "n")
  b &lt;- c(0, bands, Fs/2)
  for (i in seq(2, length(b), by=2)) {
    hi &lt;- mag[i/2] + dev[1]
    lo &lt;- max(mag[i/2] - dev[1], 0)
    lines(c(b[i-1], b[i], b[i], b[i-1], b[i-1]), c(hi, hi, lo, lo, hi))
  }
par(op)
</code></pre>

<hr>
<h2 id='levinson'> Durbin-Levinson Recursion </h2><span id='topic+levinson'></span>

<h3>Description</h3>

<p>Perform Durbin-Levinson recursion on a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levinson(x, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levinson_+3A_x">x</code></td>
<td>
<p> Input signal. </p>
</td></tr>
<tr><td><code id="levinson_+3A_p">p</code></td>
<td>
<p> Lag (defaults to <code>length(x)</code> or <code>nrow(x)</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the Durbin-Levinson algorithm to solve:
</p>
<p><code>toeplitz(acf(1:p)) * y = -acf(2:p+1).</code>
</p>
<p>The solution [1, y'] is the denominator of an all pole filter
approximation to the signal x which generated the autocorrelation
function acf.  
</p>
<p>acf is the autocorrelation function for lags 0 to p.
</p>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>The denominator filter coefficients.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Variance of the white noise = square of the numerator constant.</p>
</td></tr>
<tr><td><code>ref</code></td>
<td>
<p>Reflection coefficients = coefficients of the lattice
implementation of the filter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a> based on yulewalker.m
by Friedrich Leisch <a href="mailto:Friedrich.Leisch@boku.ac.at">Friedrich.Leisch@boku.ac.at</a>. 
Conversion to R by Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a>.
</p>


<h3>References</h3>

<p>Steven M. Kay and Stanley Lawrence Marple Jr.:
<em>Spectrum analysis &ndash; a modern perspective</em>,
Proceedings of the IEEE, Vol 69, pp 1380-1419, Nov., 1981
</p>
<p>Octave <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>

<hr>
<h2 id='Ma'> Create a moving average (MA) model </h2><span id='topic+Ma'></span>

<h3>Description</h3>

<p>Returns a moving average MA model. The model could represent a filter or system model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ma(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ma_+3A_b">b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the MA polynomial coefficients of class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p> Tom Short, EPRI Solutions, Inc., (<a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a>) </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+Arma">Arma</a></code>
</p>

<hr>
<h2 id='medfilt1'> Median filter </h2><span id='topic+medfilt1'></span><span id='topic+MedianFilter'></span><span id='topic+filter.MedianFilter'></span>

<h3>Description</h3>

<p>Deprecated! Performs an n-point running median. For Matlab/Octave compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medfilt1(x, n = 3, ...)

MedianFilter(n = 3)

## S3 method for class 'MedianFilter'
filter(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medfilt1_+3A_x">x</code></td>
<td>
<p> signal to be filtered. </p>
</td></tr>
<tr><td><code id="medfilt1_+3A_n">n</code></td>
<td>
<p> size of window on which to perform the median.  </p>
</td></tr>
<tr><td><code id="medfilt1_+3A_filt">filt</code></td>
<td>
<p> filter to apply to the signal. </p>
</td></tr>
<tr><td><code id="medfilt1_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code>runmed</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>medfilt1</code> is a wrapper for <code>runmed</code>.
</p>


<h3>Value</h3>

<p>For <code>medfilt1</code>, the filtered signal of
<code>length(x)</code>.
</p>
<p>For <code>MedianFilter</code>, a class of &ldquo;MedianFilter&rdquo; that can be used
with <code>filter</code> to apply a median filter to a signal.
</p>


<h3>Author(s)</h3>

<p> Tom Short. </p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Median_filter">https://en.wikipedia.org/wiki/Median_filter</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+runmed">runmed</a></code>, <code><a href="stats.html#topic+median">median</a></code>, <code><a href="#topic+filter">filter</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- seq(0, 1, len=100)                            # 1 second sample
x &lt;- sin(2*pi*t*2.3) + 0.25*rlnorm(length(t), 0.5) # 2.3 Hz sinusoid+noise
plot(t, x, type = "l")
# 3-point filter
lines(t, medfilt1(x), col="red", lwd=2) 
# 7-point filter
lines(t, filter(MedianFilter(7), x), col = "blue", lwd=2) # another way to call it
</code></pre>

<hr>
<h2 id='pchip'> Piecewise cubic hermite interpolation </h2><span id='topic+pchip'></span>

<h3>Description</h3>

<p>Piecewise cubic hermite interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pchip(x, y, xi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pchip_+3A_x">x</code>, <code id="pchip_+3A_y">y</code></td>
<td>
<p> vectors giving the coordinates of the points to be
interpolated. <code>x</code> must be strictly monotonic
(either increasing or decreasing).</p>
</td></tr>
<tr><td><code id="pchip_+3A_xi">xi</code></td>
<td>
<p> points at which to interpolate. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code>spline</code>, <code>pchip</code> preserves the monotonicity of
<code>x</code> and <code>y</code>.
</p>


<h3>Value</h3>

<p>Normally, the interpolated signal, an array of <code>length(xi)</code>.
</p>
<p>if <code>xi == NULL</code>, a list of class <code>pp</code>, a piecewise
polynomial representation with the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> breaks between intervals. </p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p> a matrix with <code>n</code> times <code>d</code> rows and <code>k</code>
columns. The ith row of <code>P</code>, <code>P[i,]</code>, contains the coefficients 
for the polynomial over the ith interval, ordered from highest to 
lowest. There must be one row for each interval in <code>x</code>. </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p> number of intervals (<code>length(x) - 1</code>). </p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p> polynomial order. </p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p> number of polynomials. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>Fritsch, F. N. and Carlson, R. E., &ldquo;Monotone Piecewise Cubic
Interpolation&rdquo;, <em>SIAM Journal on Numerical Analysis</em>, vol. 17, pp. 238-246, 1980.
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+spline">spline</a></code>, <code><a href="#topic+interp1">interp1</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>xf &lt;- seq(0, 11, length=500)
yf &lt;- sin(2*pi*xf/5)
xp &lt;- c(0:10)
yp &lt;- sin(2*pi*xp/5)
pch  &lt;- pchip(xp, yp, xf)
plot(xp, yp, xlim = c(0, 11))
lines(xf, pch, col = "orange")
</code></pre>

<hr>
<h2 id='poly'> Polynomial given roots </h2><span id='topic+poly'></span>

<h3>Description</h3>

<p>Coefficients of a polynomial when roots are given or the
characteristic polynomial of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_+3A_x">x</code></td>
<td>
<p> a vector or matrix. For a vector, it specifies the roots of
the polynomial. For a matrix, the characteristic polynomial is found. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of the coefficients of the polynomial in order from highest to lowest
polynomial power.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Kurt Hornik. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+polyval">polyval</a></code>, <code><a href="#topic+roots">roots</a></code>, <code><a href="#topic+conv">conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poly(c(1, -1))
poly(roots(1:3))
poly(matrix(1:9, 3, 3))
</code></pre>

<hr>
<h2 id='polyval'> Evaluate a polynomial </h2><span id='topic+polyval'></span>

<h3>Description</h3>

<p>Evaluate a polynomial at given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyval(coef, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyval_+3A_coef">coef</code></td>
<td>
<p> coefficients of the polynomial, defined in decreasing power. </p>
</td></tr>
<tr><td><code id="polyval_+3A_z">z</code></td>
<td>
<p> the points at which to evaluate the polynomial. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of <code>length(z)</code>, the polynomial evaluated at each element
of <code>z</code>.
</p>


<h3>Author(s)</h3>

<p> Tom Short </p>


<h3>See Also</h3>

 <p><code><a href="#topic+poly">poly</a></code>, <code><a href="#topic+roots">roots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>polyval(c(1, 0, -2), 1:3)  # s^2 - 2 
</code></pre>

<hr>
<h2 id='remez'> Parks-McClellan optimal FIR filter design </h2><span id='topic+remez'></span>

<h3>Description</h3>

<p>Parks-McClellan optimal FIR filter design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remez(n, f, a, w = rep(1.0, length(f) / 2),
      ftype = c('bandpass', 'differentiator', 'hilbert'),
      density = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remez_+3A_n">n</code></td>
<td>
<p> order of the filter (1 less than the length of the filter) </p>
</td></tr>
<tr><td><code id="remez_+3A_f">f</code></td>
<td>
<p> frequency at the band edges in the range (0, 1), with 1
being the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="remez_+3A_a">a</code></td>
<td>
<p> amplitude at the band edges. </p>
</td></tr>
<tr><td><code id="remez_+3A_w">w</code></td>
<td>
<p> weighting applied to each band. </p>
</td></tr>
<tr><td><code id="remez_+3A_ftype">ftype</code></td>
<td>
<p> options are: <code>'bandpass'</code>, <code>'differentiator'</code>, and <code>'hilbert'</code>. </p>
</td></tr>
<tr><td><code id="remez_+3A_density">density</code></td>
<td>
<p> determines how accurately the filter will be
constructed. The minimum value is 16, but higher numbers are
slower to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The FIR filter coefficients, an array of <code>length(n+1)</code>, of class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle. Conversion to R by Tom
Short. It uses C routines developed by Jake Janovetz.</p>


<h3>References</h3>

<p>Rabiner, L. R., McClellan, J. H., and Parks, T. W., &ldquo;FIR Digital Filter
Design Techniques Using Weighted Chebyshev Approximations&rdquo;, IEEE Proceedings,
vol. 63, pp. 595 - 610, 1975.
</p>
<p><a href="https://en.wikipedia.org/wiki/Fir_filter">https://en.wikipedia.org/wiki/Fir_filter</a> 
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Ma">Ma</a></code>,
<code><a href="#topic+fftfilt">fftfilt</a></code>, <code><a href="#topic+fir1">fir1</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- remez(15, c(0, 0.3, 0.4, 1), c(1, 1, 0, 0))
freqz(f1)
</code></pre>

<hr>
<h2 id='resample'> Change the sampling rate of a signal </h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Resample using bandlimited interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, p, q = 1, d = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p> signal to be resampled. </p>
</td></tr>
<tr><td><code id="resample_+3A_p">p</code>, <code id="resample_+3A_q">q</code></td>
<td>
 <p><code>p/q</code> specifies the factor to resample by. </p>
</td></tr>
<tr><td><code id="resample_+3A_d">d</code></td>
<td>
<p> distance. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>p</code> and <code>q</code> do
not need to be integers since this routine does not use a polyphase
rate change algorithm, but instead uses bandlimited interpolation,
wherein the continuous time signal is estimated by summing the sinc
functions of the nearest neighbouring points up to distance <code>d</code>.
</p>
<p>Note that resample computes all samples up to but not including time n+1. 
If you are increasing the sample rate, this means that it will
generate samples beyond the end of the time range of the original
signal. That is why <code>xf</code> must go all the way to 10.95 in the example below.
</p>
<p>Nowadays, the signal version in Matlab and Octave contain more modern code for 
resample that has not been ported to the signal R package (yet).
</p>


<h3>Value</h3>

<p>The resampled signal, an array of length <code>ceiling(length(x) * p / q)</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>J. O. Smith and P. Gossett (1984). A flexible sampling-rate
conversion method. In ICASSP-84, Volume II, pp. 19.4.1-19.4.2. 
New York: IEEE Press.
</p>
<p><a href="https://doi.org/10.1109/ICASSP.1984.1172555">doi:10.1109/ICASSP.1984.1172555</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+decimate">decimate</a></code>, <code><a href="#topic+interp">interp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>xf &lt;- seq(0, 10.95, by=0.05)
yf &lt;- sin(2*pi*xf/5)
xp &lt;- 0:10
yp &lt;- sin(2*pi*xp/5)
r &lt;- resample(yp, xp[2], xf[2])
title("confirm that the resampled function matches the original")
plot(xf, yf, type = "l", col = "blue")
lines(xf, r[1:length(xf)], col = "red")
points(xp,yp, pch = 19, col = "blue")
legend("bottomleft", c("Original", "Resample", "Data"),
       col = c("blue", "red", "blue"),
       pch = c(NA, NA, 19),
       lty = c(1, 1, NA), bty = "n")
</code></pre>

<hr>
<h2 id='roots'>Roots of a polynomial</h2><span id='topic+roots'></span>

<h3>Description</h3>

<p>Roots of a polynomial</p>


<h3>Usage</h3>

<pre><code class='language-R'>roots(x, method = c("polyroot", "eigen"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roots_+3A_x">x</code></td>
<td>
<p>Polynomial coefficients with coefficients given in order from highest to lowest
polynomial power. This is the Matlab/Octave convention; it is
opposite of the convention used by <code>polyroot</code>.</p>
</td></tr>
<tr><td><code id="roots_+3A_method">method</code></td>
<td>
<p>Either &ldquo;polyroot&rdquo; (default) which uses <code><a href="base.html#topic+polyroot">polyroot</a></code> for its computations internally 
(and is typically more accurate) or &ldquo;eigen&rdquo; which uses eigenvalues of the companion matrix for its computation. 
The latter returns complex values in case of real valued solutions in less cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A complex array with the roots of the polynomial.
</p>


<h3>Author(s)</h3>

<p>Original Octave version by Kurt Hornik. Conversion to R by Tom Short.</p>


<h3>References</h3>

<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+polyroot">polyroot</a></code>, <code><a href="#topic+polyval">polyval</a></code>, <code><a href="#topic+poly">poly</a></code>, <code><a href="#topic+conv">conv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>roots(1:3)
polyroot(3:1) # should be the same
poly(roots(1:3))

roots(1:3, method="eigen") # using eigenvalues
</code></pre>

<hr>
<h2 id='sftrans'> Transform filter band edges </h2><span id='topic+sftrans'></span><span id='topic+sftrans.default'></span><span id='topic+sftrans.Arma'></span><span id='topic+sftrans.Ma'></span><span id='topic+sftrans.Zpg'></span>

<h3>Description</h3>

<p>Transform band edges of a generic lowpass filter to a filter with
different band edges and to other filter types (high pass, band pass, or
band stop).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
sftrans(Sz, Sp, Sg, W, stop = FALSE, ...)

## S3 method for class 'Arma'
sftrans(Sz, W, stop = FALSE, ...)

## S3 method for class 'Zpg'
sftrans(Sz, W, stop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sftrans_+3A_sz">Sz</code></td>
<td>
<p> In the generic case, a model to be transformed. In the
default case, a vector containing the zeros in a pole-zero-gain model. </p>
</td></tr>
<tr><td><code id="sftrans_+3A_sp">Sp</code></td>
<td>
<p> a vector containing the poles in a pole-zero-gain model. </p>
</td></tr>
<tr><td><code id="sftrans_+3A_sg">Sg</code></td>
<td>
<p> a vector containing the gain in a pole-zero-gain model. </p>
</td></tr>
<tr><td><code id="sftrans_+3A_w">W</code></td>
<td>
<p> critical frequencies of the target filter specified in
radians. <code>W</code> must be a
scalar for low-pass and high-pass filters, and <code>W</code> must be a
two-element vector <code>c(low, high)</code> specifying the lower and
upper bands. </p>
</td></tr>
<tr><td><code id="sftrans_+3A_stop">stop</code></td>
<td>
 <p><code>FALSE</code> for a low-pass or band-pass filter,
<code>TRUE</code> for a high-pass or band-stop filter. </p>
</td></tr>
<tr><td><code id="sftrans_+3A_...">...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a low pass filter represented by poles and zeros in the
splane, you can convert it to a low pass, high pass, band pass or 
band stop by transforming each of the poles and zeros individually.
The following summarizes the transformations:
</p>
<p>Low-Pass Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C S/Fc</code>
</p>


<table>
<tr>
 <td style="text-align: left;">
Zero at x           </td><td style="text-align: left;"> Pole at x         </td>
</tr>
<tr>
 <td style="text-align: left;">
zero: <code class="reqn">F_c x/C</code>  </td><td style="text-align: left;"> <code class="reqn">F_c x/C</code></td>
</tr>
<tr>
 <td style="text-align: left;"> 
gain: <code class="reqn">C/F_c</code>    </td><td style="text-align: left;"> <code class="reqn">F_c/C</code>  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
</td>
</tr>

</table>

<p>High-Pass Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C F_c/S</code>
</p>


<table>
<tr>
 <td style="text-align: left;">
Zero at x           </td><td style="text-align: left;"> Pole at x   </td>
</tr>
<tr>
 <td style="text-align: left;">
zero: <code class="reqn">F_c C/x</code>  </td><td style="text-align: left;"> <code class="reqn">F_c C/x</code></td>
</tr>
<tr>
 <td style="text-align: left;">
pole: <code class="reqn">0</code>       </td><td style="text-align: left;"> <code class="reqn">0</code>     </td>
</tr>
<tr>
 <td style="text-align: left;"> 
gain: <code class="reqn">-x</code>      </td><td style="text-align: left;"> <code class="reqn">-1/x</code>  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
</td>
</tr>

</table>

<p>Band-Pass Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C \frac{S^2+F_hF_l}{S(F_h-F_l)}</code>
</p>


<table>
<tr>
 <td style="text-align: left;">
Zero at x                         </td><td style="text-align: left;"> Pole at x                 </td>
</tr>
<tr>
 <td style="text-align: left;">
zero: <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code></td><td style="text-align: left;"> <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
pole: <code class="reqn">0</code>                     </td><td style="text-align: left;"> <code class="reqn">0</code>                   </td>
</tr>
<tr>
 <td style="text-align: left;"> 
gain: <code class="reqn">C/(F_h-F_l)</code>           </td><td style="text-align: left;"> <code class="reqn">(F_h-F_l)/C</code>         </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">b = x/C (F_h-F_l)/2</code>         </td><td style="text-align: left;"> <code class="reqn">b=x/C (F_h-F_l)/2</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Band-Stop Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C \frac{S(F_h-F_l)}{S^2+F_hF_l}</code>
</p>


<table>
<tr>
 <td style="text-align: left;">
Zero at x                         </td><td style="text-align: left;"> Pole at x                 </td>
</tr>
<tr>
 <td style="text-align: left;">
zero: <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code></td><td style="text-align: left;"> <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
pole: <code class="reqn">\pm \sqrt(-F_hF_l)</code>     </td><td style="text-align: left;"> <code class="reqn">\pm \sqrt(-F_hF_l)</code>      </td>
</tr>
<tr>
 <td style="text-align: left;"> 
gain: <code class="reqn">-x</code>                    </td><td style="text-align: left;"> <code class="reqn">-1/x</code>                </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">b = C/x (F_h-F_l)/2</code>         </td><td style="text-align: left;"> <code class="reqn">b=C/x (F_h-F_l)/2</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Bilinear Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; \frac{2}{T} \frac{z-1}{z+1}</code>
</p>


<table>
<tr>
 <td style="text-align: left;">
Zero at x                       </td><td style="text-align: left;"> Pole at x               </td>
</tr>
<tr>
 <td style="text-align: left;">
zero: <code class="reqn">(2+xT)/(2-xT)</code>       </td><td style="text-align: left;"> <code class="reqn">(2+xT)/(2-xT)</code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
pole: <code class="reqn">-1</code>                  </td><td style="text-align: left;"> <code class="reqn">-1</code>                </td>
</tr>
<tr>
 <td style="text-align: left;"> 
gain: <code class="reqn">(2-xT)/T</code>            </td><td style="text-align: left;"> <code class="reqn">(2-xT)/T</code>          </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where <code class="reqn">C</code> is the cutoff frequency of the initial lowpass filter, <code class="reqn">F_c</code> is
the edge of the target low/high pass filter and <code class="reqn">[F_l,F_h]</code> are the edges
of the target band pass/stop filter.  With abundant tedious algebra,
you can derive the above formulae yourself by substituting the
transform for <code class="reqn">S</code> into <code class="reqn">H(S)=S-x</code> for a zero at <code class="reqn">x</code> or <code class="reqn">H(S)=1/(S-x)</code> for a
pole at <code class="reqn">x</code>, and converting the result into the form:
</p>
<p style="text-align: center;"><code class="reqn">H(S) = g \mbox{prod}(S-Xi) / \mbox{prod}(S-Xj)</code>
</p>

<p>Please note that a pole and a zero at the same place exactly cancel.
This is significant for High Pass, Band Pass and Band Stop filters
which create numerous extra poles and zeros, most of which cancel.
Those which do not cancel have a &lsquo;fill-in&rsquo; effect, extending the 
shorter of the sets to have the same number of as the longer of the
sets of poles and zeros (or at least split the difference in the case
of the band pass filter).  There may be other opportunistic
cancellations, but it does not check for them.
</p>
<p>Also note that any pole on the unit circle or beyond will result in
an unstable filter.  Because of cancellation, this will only happen
if the number of poles is smaller than the number of zeros and the
filter is high pass or band pass.  The analytic design methods all
yield more poles than zeros, so this will not be a problem.
</p>


<h3>Value</h3>

<p>For the default case or for <code>sftrans.Zpg</code>, an object of class
&ldquo;Zpg&rdquo;, containing the list elements:
</p>
<table>
<tr><td><code>zero</code></td>
<td>
<p> complex vector of the zeros of the transformed model</p>
</td></tr>
<tr><td><code>pole</code></td>
<td>
<p> complex vector of the poles of the transformed model</p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p> gain of the transformed model</p>
</td></tr>
</table>
<p>For <code>sftrans.Arma</code>, an object of class
&ldquo;Arma&rdquo;, containing the list elements:
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p> Proakis &amp; Manolakis (1992). <em>Digital Signal Processing</em>. New York:
Macmillan Publishing Company.
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Zpg">Zpg</a></code>, <code><a href="#topic+bilinear">bilinear</a></code>,
<code><a href="#topic+Arma">Arma</a></code></p>

<hr>
<h2 id='sgolay'> Savitzky-Golay smoothing filters </h2><span id='topic+sgolay'></span>

<h3>Description</h3>

<p>Computes the filter coefficients for all Savitzky-Golay smoothing
filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgolay(p, n, m = 0, ts = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgolay_+3A_p">p</code></td>
<td>
<p> filter order. </p>
</td></tr>
<tr><td><code id="sgolay_+3A_n">n</code></td>
<td>
<p> filter length (must be odd). </p>
</td></tr>
<tr><td><code id="sgolay_+3A_m">m</code></td>
<td>
<p> return the m-th derivative of the filter coefficients.</p>
</td></tr>
<tr><td><code id="sgolay_+3A_ts">ts</code></td>
<td>
<p> time scaling factor. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The early rows of the result <code>F</code> smooth based on future values and later rows
smooth based on past values, with the middle row using half future
and half past.  In particular, you can use row <code>i</code> to estimate <code>x[k]</code>
based on the <code>i-1</code> preceding values and the <code>n-i</code> following values of x
values as <code>y[k] = F[i,] * x[(k-i+1):(k+n-i)]</code>.
</p>
<p>Normally, you would apply the first <code>(n-1)/2</code> rows to the first <code>k</code>
points of the vector, the last <code>k</code> rows to the last <code>k</code> points of the
vector and middle row to the remainder, but for example if you were
running on a realtime system where you wanted to smooth based on the
all the data collected up to the current time, with a lag of five
samples, you could apply just the filter on row <code>n-5</code> to your window
of length <code>n</code> each time you added a new sample.
</p>


<h3>Value</h3>

<p>An square matrix with dimensions <code>length(n)</code> that is of
class <code>'sgolayFilter'</code> (so it can be used with <code>filter</code>).</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Modified by Pascal Dupuis. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian
P. Flannery, <em>Numerical Recipes in C: The Art of Scientific Computing</em> ,
2nd edition, Cambridge Univ. Press, N.Y., 1992.
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sgolayfilt">sgolayfilt</a></code>, <code><a href="#topic+filter">filter</a></code></p>

<hr>
<h2 id='sgolayfilt'> Apply a Savitzky-Golay smoothing filter </h2><span id='topic+sgolayfilt'></span><span id='topic+filter.sgolayFilter'></span>

<h3>Description</h3>

<p>Smooth data with a Savitzky-Golay smoothing filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgolayfilt(x, p = 3, n = p + 3 - p%%2, m = 0, ts = 1)

## S3 method for class 'sgolayFilter'
filter(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgolayfilt_+3A_x">x</code></td>
<td>
<p> signal to be filtered. </p>
</td></tr>
<tr><td><code id="sgolayfilt_+3A_p">p</code></td>
<td>
<p> filter order. </p>
</td></tr>
<tr><td><code id="sgolayfilt_+3A_n">n</code></td>
<td>
<p> filter length (must be odd). </p>
</td></tr>
<tr><td><code id="sgolayfilt_+3A_m">m</code></td>
<td>
<p> return the m-th derivative of the filter coefficients.</p>
</td></tr>
<tr><td><code id="sgolayfilt_+3A_ts">ts</code></td>
<td>
<p> time scaling factor. </p>
</td></tr>
<tr><td><code id="sgolayfilt_+3A_filt">filt</code></td>
<td>
<p> filter characteristics (normally generated by <code>sgolay</code>). </p>
</td></tr>
<tr><td><code id="sgolayfilt_+3A_...">...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These filters are particularly good at preserving lineshape while
removing high frequency squiggles. 
</p>


<h3>Value</h3>

<p>The filtered signal, of <code>length(x)</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Modified by Pascal Dupuis. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sgolay">sgolay</a></code>, <code><a href="#topic+filter">filter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare a 5 sample averager, an order-5 butterworth lowpass
# filter (cutoff 1/3) and sgolayfilt(x, 3, 5), the best cubic
# estimated from 5 points.
bf &lt;- butter(5,1/3)
x &lt;- c(rep(0,15), rep(10, 10), rep(0, 15))
sg &lt;- sgolayfilt(x)
plot(sg, type="l")
lines(filtfilt(rep(1, 5)/5,1,x), col = "red") # averaging filter
lines(filtfilt(bf,x), col = "blue")           # butterworth
points(x, pch = "x")                          # original data
</code></pre>

<hr>
<h2 id='signal-internal'>Internal or uncommented functions</h2><span id='topic+ellipke'></span><span id='topic+fractdiff'></span><span id='topic+logseq'></span><span id='topic+ncauer'></span><span id='topic+cheb'></span><span id='topic+postpad'></span><span id='topic+sinc'></span><span id='topic+mkpp'></span><span id='topic+ppval'></span>

<h3>Description</h3>

<p>Internal or barely commented functions not exported from the Namespace.
</p>


<h3>Details</h3>

<pre>
# MOSTLY MATLAB/OCTAVE COMPATIBLE UTILITIES
  fractdiff(x, d) # Fractional differences
  postpad(x, n)   # pad \code{x} with zeros at the end for a total length \code{n}
                  # truncates if length(x) &lt; n
  sinc(x)         # sin(pi * x) / (pi * x)

# MATLAB-INCOMPATIBLE UTILITIES
  logseq(from, to, n = 500) # like \code{linspace} but equally spaced logarithmically

# MAINLY INTERNAL, BUT MATLAB COMPATIBLE
  mkpp(x, P, d = round(NROW(P)/pp$n)) # used by \code{pchip}
  ## Construct a piece-wise polynomial structure from sample points x and
  ## coefficients P. 
  ppval(pp, xi) # used by \code{pchip}
  ## Evaluate piece-wise polynomial pp and points xi.
  ncauer(Rp, Rs, n) # used by \code{ellip}
  ellipke(m, Nmax)  # used by \code{ellip}
  cheb(n, x) # nth-order Chebyshev polynomial calculated at x
             # used by \code{chebwin}
</pre>

<hr>
<h2 id='specgram'> Spectrogram plot </h2><span id='topic+specgram'></span><span id='topic+plot.specgram'></span><span id='topic+print.specgram'></span>

<h3>Description</h3>

<p>Generate a spectrogram for the signal. This chops the signal into
overlapping slices, windows each slice and applies a Fourier
transform to determine the frequency components at that slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specgram(x, n = min(256, length(x)), Fs = 2, window = hanning(n),
         overlap = ceiling(length(window)/2))

## S3 method for class 'specgram'
plot(x, col = gray(0:512 / 512), xlab="time", ylab="frequency", ...)

## S3 method for class 'specgram'
print(x, col = gray(0:512 / 512), xlab="time", ylab="frequency", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specgram_+3A_x">x</code></td>
<td>
<p> the vector of samples. </p>
</td></tr>
<tr><td><code id="specgram_+3A_n">n</code></td>
<td>
<p> the size of the Fourier transform window. </p>
</td></tr>
<tr><td><code id="specgram_+3A_fs">Fs</code></td>
<td>
<p> the sample rate, Hz. </p>
</td></tr>
<tr><td><code id="specgram_+3A_window">window</code></td>
<td>
<p> shape of the fourier transform window, defaults to
<code>hanning(n)</code>. The window length for a hanning window can be
specified instead. </p>
</td></tr>
<tr><td><code id="specgram_+3A_overlap">overlap</code></td>
<td>
<p> overlap with previous window, defaults to half the
window length.</p>
</td></tr>
<tr><td><code id="specgram_+3A_col">col</code></td>
<td>
<p>color scale used for the underlying <code><a href="graphics.html#topic+image">image</a></code> function.</p>
</td></tr>
<tr><td><code id="specgram_+3A_xlab">xlab</code>, <code id="specgram_+3A_ylab">ylab</code></td>
<td>
<p>axis labels with sensible defaults.</p>
</td></tr>
<tr><td><code id="specgram_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the underlying plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When results of <code>specgram</code> are printed, a spectrogram will be plotted.
As with
<code>lattice</code> plots, automatic printing does not work inside loops and
function calls, so explicit calls to <code>print</code> or <code>plot</code> are
needed there.
</p>
<p>The choice of window defines the time-frequency resolution. In
speech for example, a wide window shows more harmonic detail while a
narrow window averages over the harmonic detail and shows more
formant structure. The shape of the window is not so critical so long
as it goes gradually to zero on the ends.
</p>
<p>Step size (which is window length minus overlap) controls the
horizontal scale of the spectrogram. Decrease it to stretch, or
increase it to compress. Increasing step size will reduce time
resolution, but decreasing it will not improve it much beyond the
limits imposed by the window size (you do gain a little bit,
depending on the shape of your window, as the peak of the window
slides over peaks in the signal energy). The range 1-5 msec is good
for speech.
</p>
<p>FFT length controls the vertical scale. Selecting an FFT length
greater than the window length does not add any information to the
spectrum, but it is a good way to interpolate between frequency
points which can make for prettier spectrograms.
</p>
<p>After you have generated the spectral slices, there are a number of
decisions for displaying them. First the phase information is
discarded and the energy normalized:
</p>
<p><code>S = abs(S); S = S/max(S)</code>
</p>
<p>Then the dynamic range of the signal is chosen. Since information in
speech is well above the noise floor, it makes sense to eliminate any
dynamic range at the bottom end. This is done by taking the max of
the magnitude and some minimum energy such as minE=-40dB. Similarly,
there is not much information in the very top of the range, so
clipping to a maximum energy such as maxE=-3dB makes sense:
</p>
<p><code>S = max(S, 10^(minE/10)); S = min(S, 10^(maxE/10))</code>
</p>
<p>The frequency range of the FFT is from 0 to the Nyquist frequency of
one half the sampling rate. If the signal of interest is band
limited, you do not need to display the entire frequency range. In
speech for example, most of the signal is below 4 kHz, so there is no
reason to display up to the Nyquist frequency of 10 kHz for a 20 kHz
sampling rate. In this case you will want to keep only the first 40%
of the rows of the returned <code>S</code> and <code>f</code>. More generally, to display the
frequency range <code>[minF, maxF]</code>, you could use the following row index:
</p>
<p><code>idx = (f &gt;= minF &amp; f &lt;= maxF)</code>
</p>
<p>Then there is the choice of colormap. A brightness varying colormap
such as copper or bone gives good shape to the ridges and valleys. A
hue varying colormap such as jet or hsv gives an indication of the
steepness of the slopes. The final spectrogram is displayed in log
energy scale and by convention has low frequencies on the bottom of
the image.
</p>


<h3>Value</h3>

<p>For <code>specgram</code> list of class <code>specgram</code> with items:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p> complex output of the FFT, one row per slice. </p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p> the frequency indices corresponding to the rows of S.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p> the time indices corresponding to the columns of S.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="graphics.html#topic+image">image</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>specgram(chirp(seq(-2, 15, by = 0.001), 400, 10, 100, 'quadratic'))
specgram(chirp(seq(0, 5, by = 1/8000), 200, 2, 500, "logarithmic"), Fs = 8000)

data(wav)  # contains wav$rate, wav$sound
Fs &lt;- wav$rate
step &lt;- trunc(5*Fs/1000)             # one spectral slice every 5 ms
window &lt;- trunc(40*Fs/1000)          # 40 ms data window
fftn &lt;- 2^ceiling(log2(abs(window))) # next highest power of 2
spg &lt;- specgram(wav$sound, fftn, Fs, window, window-step)
S &lt;- abs(spg$S[2:(fftn*4000/Fs),])   # magnitude in range 0&lt;f&lt;=4000 Hz.
S &lt;- S/max(S)         # normalize magnitude so that max is 0 dB.
S[S &lt; 10^(-40/10)] &lt;- 10^(-40/10)    # clip below -40 dB.
S[S &gt; 10^(-3/10)] &lt;- 10^(-3/10)      # clip above -3 dB.
image(t(20*log10(S)), axes = FALSE)  #, col = gray(0:255 / 255))
</code></pre>

<hr>
<h2 id='spencer'> Spencer filter </h2><span id='topic+spencer'></span><span id='topic+spencerFilter'></span>

<h3>Description</h3>

<p>Spencer's 15-point moving average filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spencer(x)

spencerFilter()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spencer_+3A_x">x</code></td>
<td>
<p> signal to be filtered. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>spencer</code>, the filtered signal. For <code>spencerFilter</code>, a
vector of filter coefficients with class <code>Ma</code> that can be passed
to <code>filter</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Friedrich Leisch. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+Ma">Ma</a></code></p>

<hr>
<h2 id='unwrap'> Unwrap radian phases </h2><span id='topic+unwrap'></span>

<h3>Description</h3>

<p>Unwrap radian phases by adding multiples of 2*pi as appropriate to
remove jumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap(a, tol = pi, dim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_+3A_a">a</code></td>
<td>
<p> vector of phase angles in radians. </p>
</td></tr>
<tr><td><code id="unwrap_+3A_tol">tol</code></td>
<td>
<p> tolerance for removing phase jumps. </p>
</td></tr>
<tr><td><code id="unwrap_+3A_dim">dim</code></td>
<td>
<p> dimension with which to apply the phase unwrapping. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the unwrapped phase angles.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Bill Lash. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phase &lt;- c(seq(0, 2*pi, length=500), seq(0, 2*pi, length=500))
plot(phase, type = "l", ylim = c(0, 4*pi))
lines(unwrap(phase), col = "blue")
</code></pre>

<hr>
<h2 id='wav'>Example wav file</h2><span id='topic+wav'></span>

<h3>Description</h3>

<p>Example wav file audio waveshape from Octave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wav)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
$ sound: num [1, 1:17380] -0.000275 -0.00061 -0.000397 -0.000793 -0.000305 ...
$ rate : int 22050
$ bits : int 16
- attr(*, &quot;class&quot;)= chr &quot;Sample&quot;
</p>


<h3>Details</h3>

<p>Sound samples are in Element &ldquo;sound&rdquo; while &ldquo;rate&rdquo; is the sampling rate (in Hz)
and &ldquo;bits&rdquo; the resolution of the underlying Wave file.</p>


<h3>Source</h3>

<p>Octave</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wav)
str(wav)
</code></pre>

<hr>
<h2 id='Windowing+20functions'> Windowing functions </h2><span id='topic+bartlett'></span><span id='topic+blackman'></span><span id='topic+boxcar'></span><span id='topic+flattopwin'></span><span id='topic+gausswin'></span><span id='topic+hamming'></span><span id='topic+hanning'></span><span id='topic+triang'></span>

<h3>Description</h3>

<p>A variety of generally Matlab/Octave compatible filter generation
functions, including Bartlett, Blackman, Hamming, Hanning, and
triangular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartlett(n) 
blackman(n) 
boxcar(n) 
flattopwin(n, sym = c('symmetric', 'periodic')) 
gausswin(n, w = 2.5) 
hamming(n) 
hanning(n) 
triang(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Windowing+2B20functions_+3A_n">n</code></td>
<td>
<p> length of the filter; number of coefficients to generate. </p>
</td></tr>
<tr><td><code id="Windowing+2B20functions_+3A_w">w</code></td>
<td>
<p> the reciprocal of the standard deviation for
<code>gausswin</code>. Use larger <code>a</code> for a narrower window. </p>
</td></tr>
<tr><td><code id="Windowing+2B20functions_+3A_sym">sym</code></td>
<td>
 <p><code>'symmetric'</code> for a symmetric window, <code>'periodic'</code> for a
periodic window. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>triang</code>, unlike the bartlett window, does not go to zero at the
edges of the window.  For odd <code>n</code>, <code>triang(n)</code> is equal to
<code>bartlett(n+2)</code> except for the zeros at the edges of the window.
</p>
<p>A main use of <code>flattopwin</code> is for calibration, due
to its negligible amplitude errors. This window has low pass-band ripple, but high bandwidth. 
</p>


<h3>Value</h3>

<p>Filter coefficients.
</p>


<h3>Author(s)</h3>

<p> Original Octave versions by Paul Kienzle (<code>boxcar</code>,
<code>gausswin</code>, <code>triang</code>) and Andreas Weingessel
(<code>bartlett</code>, <code>blackman</code>, <code>hamming</code>, <code>hanning</code>).
Conversion to R by Tom Short. </p>


<h3>References</h3>

      
<p>Oppenheim, A.V., and Schafer, R.W., <em>Discrete-Time Signal Processing</em>, Upper Saddle River, NJ: Prentice-Hall, 1999.
</p>
<p>Gade, S., Herlufsen, H. (1987) &ldquo;Use of weighting functions in DFT/FFT
analysis (Part I)&rdquo;, <em>Bruel &amp; Kjaer Technical Review</em> No. 3.
</p>
<p><a href="https://en.wikipedia.org/wiki/Windowed_frame">https://en.wikipedia.org/wiki/Windowed_frame</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+fftfilt">fftfilt</a></code>,
<code><a href="#topic+filtfilt">filtfilt</a></code>, <code><a href="#topic+fir1">fir1</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 51
op &lt;- par(mfrow = c(3,3))
plot(bartlett(n), type = "l", ylim = c(0,1))
plot(blackman(n), type = "l", ylim = c(0,1))
plot(boxcar(n), type = "l", ylim = c(0,1))
plot(flattopwin(n), type = "l", ylim = c(0,1))
plot(gausswin(n, 5), type = "l", ylim = c(0,1))
plot(hanning(n), type = "l", ylim = c(0,1))
plot(hamming(n), type = "l", ylim = c(0,1))
plot(triang(n), type = "l", ylim = c(0,1))
par(op)
</code></pre>

<hr>
<h2 id='Zpg'> Zero-pole-gain model </h2><span id='topic+Zpg'></span><span id='topic+as.Zpg'></span><span id='topic+as.Zpg.Arma'></span><span id='topic+as.Zpg.Ma'></span><span id='topic+as.Zpg.Zpg'></span>

<h3>Description</h3>

<p>Zero-pole-gain model of an ARMA filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zpg(zero, pole, gain)

## S3 method for class 'Arma'
as.Zpg(x, ...)

## S3 method for class 'Ma'
as.Zpg(x, ...)

## S3 method for class 'Zpg'
as.Zpg(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zpg_+3A_zero">zero</code></td>
<td>
<p> complex vector of the zeros of the model.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_pole">pole</code></td>
<td>
<p> complex vector of the poles of the model.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_gain">gain</code></td>
<td>
<p> gain of the model.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_x">x</code></td>
<td>
<p> model to be converted.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_...">...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.Zpg</code> converts from other forms, including <code>Arma</code> and <code>Ma</code>. 
</p>


<h3>Value</h3>

<p>An object of class &ldquo;Zpg&rdquo;, containing the list elements:
</p>
<table>
<tr><td><code>zero</code></td>
<td>
<p> complex vector of the zeros of the model.</p>
</td></tr>
<tr><td><code>pole</code></td>
<td>
<p> complex vector of the poles of the model.</p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p> gain of the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Tom Short </p>


<h3>See Also</h3>

 <p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+bilinear">bilinear</a></code> </p>

<hr>
<h2 id='zplane'> Pole-zero plot </h2><span id='topic+zplane'></span><span id='topic+zplane.default'></span><span id='topic+zplane.Arma'></span><span id='topic+zplane.Ma'></span><span id='topic+zplane.Zpg'></span>

<h3>Description</h3>

<p>Plot the poles and zeros of a model or filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
zplane(filt, a, ...)

## S3 method for class 'Arma'
zplane(filt, ...)

## S3 method for class 'Ma'
zplane(filt, ...)

## S3 method for class 'Zpg'
zplane(filt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zplane_+3A_filt">filt</code></td>
<td>
<p> for the default case, the moving-average coefficients of
an ARMA model or filter. Generically, <code>filt</code>
specifies an arbitrary model or filter operation.</p>
</td></tr>
<tr><td><code id="zplane_+3A_a">a</code></td>
<td>
<p> the autoregressive (recursive) coefficients of an ARMA filter. </p>
</td></tr>
<tr><td><code id="zplane_+3A_...">...</code></td>
<td>
<p> Additional arguments passed to <code>plot</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Poles are marked with an &lsquo;x&rsquo;, and zeros are marked with an &lsquo;o&rsquo;.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p> Tom Short </p>


<h3>References</h3>

<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Pole-zero_plot">https://en.wikipedia.org/wiki/Pole-zero_plot</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+freqz">freqz</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>filt &lt;- ellip(5, 0.5, 20, .2)
zplane(filt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
