<!DOCTYPE html><html lang="en"><head><title>Help for package tinyVAST</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tinyVAST}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_predictions'><p>Add predictions to data-list</p></a></li>
<li><a href='#bering_sea'><p>Survey domain for the eastern and northern Bering Sea surveys</p></a></li>
<li><a href='#bering_sea_pollock_ages'><p>Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea</p></a></li>
<li><a href='#bering_sea_pollock_vast'><p>Estimated proportion-at-age for Alaska pollock using VAST</p></a></li>
<li><a href='#cAIC'><p>Calculate conditional AIC</p></a></li>
<li><a href='#classify_variables'><p>Classify variables path</p></a></li>
<li><a href='#condition_and_density'><p>Condition and density example</p></a></li>
<li><a href='#deviance_explained'><p>Calculate deviance explained</p></a></li>
<li><a href='#Families'><p>Additional families</p></a></li>
<li><a href='#integrate_output'><p>Integration for target variable</p></a></li>
<li><a href='#logLik.tinyVAST'><p>Extract the (marginal) log-likelihood of a tinyVAST model</p></a></li>
<li><a href='#make_dsem_ram'><p>Make a RAM (Reticular Action Model)</p></a></li>
<li><a href='#make_eof_ram'><p>Make a RAM (Reticular Action Model)</p></a></li>
<li><a href='#make_sem_ram'><p>Make a RAM (Reticular Action Model) from a SEM (structural equation model)</p></a></li>
<li><a href='#parse_path'><p>Parse path</p></a></li>
<li><a href='#predict.tinyVAST'><p>Predict using vector autoregressive spatio-temporal model</p></a></li>
<li><a href='#print.tinyVAST'><p>print summary of tinyVAST model</p></a></li>
<li><a href='#red_snapper'><p>Presence/absence, count, and biomass data for red snapper</p></a></li>
<li><a href='#red_snapper_shapefile'><p>Shapefile for red snapper analysis</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reload_model'><p>Reload a previously fitted model</p></a></li>
<li><a href='#residuals.tinyVAST'><p>Calculate deviance or response residuals for tinyVAST</p></a></li>
<li><a href='#rmvnorm_prec'><p>Multivariate Normal Random Deviates using Sparse Precision</p></a></li>
<li><a href='#rotate_pca'><p>Rotate factors to match Principal-Components Analysis</p></a></li>
<li><a href='#salmon_returns'><p>North Pacific salmon returns</p></a></li>
<li><a href='#sample_variable'><p>Sample from predictive distribution of a variable</p></a></li>
<li><a href='#sea_ice'><p>Arctic September sea ice concentrations</p></a></li>
<li><a href='#sfnetwork_evaluator'><p>Construct projection matrix for stream network</p></a></li>
<li><a href='#sfnetwork_mesh'><p>Make mesh for stream network</p></a></li>
<li><a href='#simulate_sfnetwork'><p>Simulate GMRF for stream network</p></a></li>
<li><a href='#simulate.tinyVAST'><p>Simulate new data from a fitted model</p></a></li>
<li><a href='#summary.tinyVAST'><p>summarize tinyVAST</p></a></li>
<li><a href='#tinyVAST'><p>Fit vector autoregressive spatio-temporal model</p></a></li>
<li><a href='#tinyVASTcontrol'><p>Control parameters for tinyVAST</p></a></li>
<li><a href='#vcov.tinyVAST'><p>Extract Variance-Covariance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Spatio-Temporal Models using Structural Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits a wide variety of multivariate spatio-temporal models
    with simultaneous and lagged interactions among variables (including
    vector autoregressive spatio-temporal ('VAST') dynamics)
    for areal, continuous, or network spatial domains.  
    It includes time-variable, space-variable, and space-time-variable 
    interactions using dynamic structural equation models ('DSEM') 
    as expressive interface, and the 'mgcv' package to specify splines 
    via the formula interface.  See Thorson et al. (2024)
    &lt;<a href="https://doi.org/10.48550%2FarXiv.2401.10193">doi:10.48550/arXiv.2401.10193</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>corpcor, fmesher, igraph, Matrix (&ge; 1.3.0), methods, mgcv,
sem, sf, sfnetworks, TMB (&ge; 1.9.17), units, checkmate, abind,
sdmTMB</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dsem (&ge; 1.1.0), ggplot2, knitr, lattice, mvtnorm, pdp,
rmarkdown, rnaturalearth, rnaturalearthdata, testthat, tweedie,
viridisLite, visreg, plyr, DHARMa, glmmTMB, tibble</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, TMB</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://vast-lib.github.io/tinyVAST/">https://vast-lib.github.io/tinyVAST/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vast-lib/tinyVAST/issues">https://github.com/vast-lib/tinyVAST/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-10 17:36:28 UTC; James.Thorson</td>
</tr>
<tr>
<td>Author:</td>
<td>James T. Thorson <a href="https://orcid.org/0000-0001-7415-1010"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sean C. Anderson <a href="https://orcid.org/0000-0001-9563-1937"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James T. Thorson &lt;James.Thorson@noaa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-13 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_predictions'>Add predictions to data-list</h2><span id='topic+add_predictions'></span>

<h3>Description</h3>

<p>Given user-provided <code>newdata</code>, expand the object <code>tmb_data</code>
to include predictions corresponding to those new observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_predictions(object, newdata, remove_origdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_predictions_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code>.</p>
</td></tr>
<tr><td><code id="add_predictions_+3A_newdata">newdata</code></td>
<td>
<p>New data-frame of independent variables used to predict the response.</p>
</td></tr>
<tr><td><code id="add_predictions_+3A_remove_origdata">remove_origdata</code></td>
<td>
<p>Whether to remove original-data to allow faster evaluation.
<code>remove_origdata=TRUE</code> eliminates information about the distribution
for random effects, and cannot be combined with epsilon bias-correction.
WARNING:  feature is experimental and subject to change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object <code>fit$tmb_inputs$tmb_data</code> representing data used during fitting,
but with updated values for slots associated with predictions, where this
updated object can be recompiled by TMB to provide predictions
</p>

<hr>
<h2 id='bering_sea'>Survey domain for the eastern and northern Bering Sea surveys</h2><span id='topic+bering_sea'></span>

<h3>Description</h3>

<p>Shapefile defining the spatial domain for the eastern and northern
Bering Sea bottom trawl surveys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bering_sea)
</code></pre>

<hr>
<h2 id='bering_sea_pollock_ages'>Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea</h2><span id='topic+bering_sea_pollock_ages'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test model-based age expansion, using density=
dependence corrected survey catch rates after first=stage expansion
from the bottom trawl survey for ages 1-15, conducted by
by the Alaska Fisheries Science Center, including annual surveys in the eastern
Bering Sea 1982-2019 and 2021-2023, as well as the northern Bering Sea
in 1982/85/88/91 and 2010/17/18/19/21/22/23.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bering_sea_pollock_ages)
</code></pre>

<hr>
<h2 id='bering_sea_pollock_vast'>Estimated proportion-at-age for Alaska pollock using VAST</h2><span id='topic+bering_sea_pollock_vast'></span>

<h3>Description</h3>

<p>Estimated proporrtion-at-age for Alaska pollock using the
package VAST, for comparison with output using tinyVAST.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bering_sea_pollock_vast)
</code></pre>

<hr>
<h2 id='cAIC'>Calculate conditional AIC</h2><span id='topic+cAIC'></span>

<h3>Description</h3>

<p>Calculates the conditional Akaike Information criterion (cAIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cAIC(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cAIC_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cAIC is designed to optimize the expected out-of-sample predictive
performance for new data that share the same random effects as the in-sample
(fitted) data, e.g., spatial interpolation.  In this sense, it should be a
fast approximation to optimizing the model structure based on k-fold
cross-validation.
</p>
<p>By contrast, <code><a href="stats.html#topic+AIC">AIC()</a></code> calculates the marginal Akaike Information Criterion,
which is designed to optimize expected predictive performance for new data
that have new random effects, e.g., extrapolation, or inference about
generative parameters.
</p>
<p>Both cAIC and EDF are calculated using Eq. 6 of Zheng, Cadigan, and Thorson
(2024).
</p>
<p>For models that include profiled fixed effects, these profiles are turned
off.
</p>


<h3>Value</h3>

<p>cAIC value
</p>


<h3>References</h3>

<p>Zheng, N., Cadigan, N., &amp; Thorson, J. T. (2024).
A note on numerical evaluation of conditional Akaike information for
nonlinear mixed-effects models (arXiv:2411.14185). arXiv.
<a href="https://doi.org/10.48550/arXiv.2411.14185">doi:10.48550/arXiv.2411.14185</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( red_snapper )
red_snapper = droplevels(subset(red_snapper, Data_type=="Biomass_KG"))

# Define mesh
mesh = fmesher::fm_mesh_2d( red_snapper[,c('Lon','Lat')],
                           cutoff = 1 )

# define formula with a catchability covariate for gear
formula = Response_variable ~ factor(Year) + offset(log(AreaSwept_km2))

# make variable column
red_snapper$var = "logdens"
# fit using tinyVAST
fit = tinyVAST( data = red_snapper,
                formula = formula,
                sem = "logdens &lt;-&gt; logdens, sd_space",
                space_columns = c("Lon",'Lat'),
                spatial_graph = mesh,
                family = tweedie(link="log"),
                variable_column = "var",
                control = tinyVASTcontrol( getsd = FALSE,
                                           profile = "alpha_j" ) )

cAIC(fit) # conditional AIC
AIC(fit) # marginal AIC

</code></pre>

<hr>
<h2 id='classify_variables'>Classify variables path</h2><span id='topic+classify_variables'></span>

<h3>Description</h3>

<p><code>classify_variables</code> is copied from <code>sem:::classifyVariables</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_variables(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify_variables_+3A_model">model</code></td>
<td>
<p>syntax for structural equation model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Copied from package <code>sem</code> under licence GPL (&gt;= 2) with permission from John Fox
</p>


<h3>Value</h3>

<p>Tagged-list defining exogenous and endogenous variables
</p>

<hr>
<h2 id='condition_and_density'>Condition and density example</h2><span id='topic+condition_and_density'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test a bivariate model for morphometric condition
(i.e., residuals in a weight-at-length relationship) and density for fishes, using
the same example as was provided as a wiki example for VAST.
Data are from <a href="https://doi.org/10.3354/meps13213">doi:10.3354/meps13213</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(condition_and_density)
</code></pre>

<hr>
<h2 id='deviance_explained'>Calculate deviance explained</h2><span id='topic+deviance_explained'></span>

<h3>Description</h3>

<p><code>deviance_explained</code> fits a null model, calculates the deviance relative to
a saturated model for both the original and the null model, and uses these
to calculate the proportion of deviance explained.
</p>
<p>This implementation conditions upon the maximum likelihood estimate of fixed effects
and the empirical Bayes (&quot;plug-in&quot;) prediction of random effects.  It can
be described as &quot;conditional deviance explained&quot;. A state-space model that
estimates measurement error variance approaching zero (i.e., collapses to
a process-error-only model) will have a conditional deviance explained
that approaches 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviance_explained(x, null_formula, null_delta_formula = ~1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance_explained_+3A_x">x</code></td>
<td>
<p>output from <code style="white-space: pre;">&#8288;\code{tinyVAST()}&#8288;</code></p>
</td></tr>
<tr><td><code id="deviance_explained_+3A_null_formula">null_formula</code></td>
<td>
<p>formula for the null model.  If missing, it uses
<code>null_formula = response ~ 1</code>. For multivariate models, it
might make sense to use <code>null_formula = response ~ category</code></p>
</td></tr>
<tr><td><code id="deviance_explained_+3A_null_delta_formula">null_delta_formula</code></td>
<td>
<p>formula for the null model for the delta component.
If missing, it uses
<code>null_formula = response ~ 1</code>. For multivariate models, it
might make sense to use <code>null_delta_formula = response ~ category</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the proportion of conditional deviance explained.
</p>

<hr>
<h2 id='Families'>Additional families</h2><span id='topic+Families'></span><span id='topic+delta_lognormal'></span><span id='topic+delta_gamma'></span>

<h3>Description</h3>

<p>Additional families compatible with <code><a href="#topic+tinyVAST">tinyVAST()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_lognormal(link1, link2 = "log", type = c("standard", "poisson-link"))

delta_gamma(link1, link2 = "log", type = c("standard", "poisson-link"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Families_+3A_link1">link1</code></td>
<td>
<p>Link for first part of delta/hurdle model.</p>
</td></tr>
<tr><td><code id="Families_+3A_link2">link2</code></td>
<td>
<p>Link for second part of delta/hurdle model.</p>
</td></tr>
<tr><td><code id="Families_+3A_type">type</code></td>
<td>
<p>Delta/hurdle family type. <code>"standard"</code> for a classic hurdle
model. <code>"poisson-link"</code> for a Poisson-link delta model (Thorson 2018).</p>
</td></tr>
<tr><td><code id="Families_+3A_link">link</code></td>
<td>
<p>Link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements common to standard R family objects including <code>family</code>,
<code>link</code>, <code>linkfun</code>, and <code>linkinv</code>. Delta/hurdle model families also have
elements <code>delta</code> (logical) and <code>type</code> (standard vs. Poisson-link).
</p>


<h3>References</h3>

<p><em>Poisson-link delta families</em>:
</p>
<p>Thorson, J.T. 2018. Three problems with the conventional delta-model for
biomass sampling data, and a computationally efficient alternative. Canadian
Journal of Fisheries and Aquatic Sciences, 75(9), 1369-1382.
<a href="https://doi.org/10.1139/cjfas-2017-0266">doi:10.1139/cjfas-2017-0266</a>
</p>
<p><em>Poisson-link delta families</em>:
</p>
<p>Thorson, J.T. 2018. Three problems with the conventional delta-model for
biomass sampling data, and a computationally efficient alternative. Canadian
Journal of Fisheries and Aquatic Sciences, 75(9), 1369-1382.
<a href="https://doi.org/10.1139/cjfas-2017-0266">doi:10.1139/cjfas-2017-0266</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta_lognormal()
delta_gamma()
</code></pre>

<hr>
<h2 id='integrate_output'>Integration for target variable</h2><span id='topic+integrate_output'></span>

<h3>Description</h3>

<p>Calculates an estimator for a derived quantity by summing across multiple predictions.
This can be used to approximate an integral when estimating area-expanded abundance,
abundance-weighting a covariate to calculate distribution shifts,
and/or weighting one model variable by another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_output(
  object,
  newdata,
  area,
  type = rep(1, nrow(newdata)),
  weighting_index,
  covariate,
  getsd = TRUE,
  bias.correct = TRUE,
  apply.epsilon = FALSE,
  intern = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integrate_output_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code>.</p>
</td></tr>
<tr><td><code id="integrate_output_+3A_newdata">newdata</code></td>
<td>
<p>New data-frame of independent variables used to predict the response,
where a total value is calculated by combining across these individual predictions.
If these locations are randomly drawn from a specified spatial domain, then
<code>integrate_output</code> applies midpoint integration to approximate the
total over that area.  If locations are drawn sysmatically from a domain,
then <code>integrate_output</code> is applying a midpoint approximation to the integral.</p>
</td></tr>
<tr><td><code id="integrate_output_+3A_area">area</code></td>
<td>
<p>vector of values used for area-weighted expansion of
estimated density surface for each row of <code>newdata</code>
with length of <code>nrow(newdata)</code>.</p>
</td></tr>
<tr><td><code id="integrate_output_+3A_type">type</code></td>
<td>
<p>Integer-vector indicating what type of expansion to apply to
each row of <code>newdata</code>, with length of <code>nrow(newdata)</code>.
</p>

<dl>
<dt><code>type=1</code></dt><dd><p>Area-weighting: weight predictor by argument <code>area</code></p>
</dd>
<dt><code>type=2</code></dt><dd><p>Abundance-weighted covariate: weight <code>covariate</code> by
proportion of total in each row of <code>newdata</code></p>
</dd>
<dt><code>type=3</code></dt><dd><p>Abundance-weighted variable: weight predictor by
proportion of total in a prior row of <code>newdata</code>.
This option is used to weight a prediction for
one category based on predicted proportional density of another category, e.g.,
to calculate abundance-weighted condition in a bivariate model.</p>
</dd>
<dt><code>type=4</code></dt><dd><p>Abundance-expanded variable: weight predictor by
density in a prior row of <code>newdata</code>.
This option is used to weight a prediction for
one category based on predicted density of another category, e.g.,
to calculate abundance-expanded consumption in a bivariate model.</p>
</dd>
<dt><code>type=0</code></dt><dd><p>Exclude from weighting: give weight of zero for
a given row of <code>newdata</code>. Including a row of <code>newdata</code> with
<code>type=0</code> is useful, e.g., when calculating abundance at that
location, where the eventual index uses abundance as weighting term
but without otherwise using the predicted density in calculating a total
value.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="integrate_output_+3A_weighting_index">weighting_index</code></td>
<td>
<p>integer-vector used to indicate a previous row
that is used to calculate a weighted average that is then
applied to the given row of <code>newdata</code>. Only used for when <code>type=3</code>.</p>
</td></tr>
<tr><td><code id="integrate_output_+3A_covariate">covariate</code></td>
<td>
<p>numeric-vector used to provide a covariate
that is used in expansion, e.g., to provide positional
coordinates when calculating the abundance-weighted centroid with respect
to that coordinate. Only used for when <code>type=2</code>.</p>
</td></tr>
<tr><td><code id="integrate_output_+3A_getsd">getsd</code></td>
<td>
<p>logical indicating whether to get the standard error, where
<code>getsd=FALSE</code> is faster during initial exploration</p>
</td></tr>
<tr><td><code id="integrate_output_+3A_bias.correct">bias.correct</code></td>
<td>
<p>logical indicating if bias correction should be applied using
standard methods in <code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code></p>
</td></tr>
<tr><td><code id="integrate_output_+3A_apply.epsilon">apply.epsilon</code></td>
<td>
<p>Apply epsilon bias correction using a manual calculation
rather than using the conventional method in <a href="TMB.html#topic+sdreport">TMB::sdreport</a>?
See details for more information.</p>
</td></tr>
<tr><td><code id="integrate_output_+3A_intern">intern</code></td>
<td>
<p>Do Laplace approximation on C++ side? Passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analysts will often want to calculate some value by combining the predicted response at multiple
locations, and potentially from multiple variables in a multivariate analysis.
This arises in a univariate model, e.g., when calculating the integral under a predicted
density function, which is approximated using a midpoint or Monte Carlo approximation
by calculating the linear predictors at each location <code>newdata</code>,
applying the inverse-link-trainsformation,
and calling this predicted response <code>mu_g</code>.  Total abundance is then be approximated
by multiplying <code>mu_g</code> by the area associated with each midpoint or Monte Carlo
approximation point (supplied by argument <code>area</code>),
and summing across these area-expanded values.
</p>
<p>In more complicated cases, an analyst can then use <code>covariate</code>
to calculate the weighted average
of a covariate for each midpoint location. For example, if the covariate is
positional coordinates or depth/elevation, then <code>type=2</code>
measures shifts in the average habitat utilization with respect to that covariate.
Alternatively, an analyst fitting a multivariate model might weight one variable
based on another using <code>weighting_index</code>, e.g.,
to calculate abundance-weighted average condition, or
predator-expanded stomach contents.
</p>
<p>In practice, spatial integration in a multivariate model requires two passes through the rows of
<code>newdata</code> when calculating a total value.  In the following, we
write equations using C++ indexing conventions such that indexing starts with 0,
to match the way that <code>integrate_output</code> expects indices to be supplied.
Given inverse-link-transformed predictor <code class="reqn"> \mu_g </code>,
function argument <code>type</code> as <code class="reqn"> type_g </code>
function argument <code>area</code> as <code class="reqn"> a_g </code>,
function argument <code>covariate</code> as <code class="reqn"> x_g </code>,
function argument <code>weighting_index</code> as <code style="white-space: pre;">&#8288;\eqn{ h_g }&#8288;</code>
function argument <code>weighting_index</code> as <code style="white-space: pre;">&#8288;\eqn{ h_g }&#8288;</code>
the first pass calculates:
</p>
<p style="text-align: center;"><code class="reqn"> \nu_g = \mu_g a_g </code>
</p>

<p>where the total value from this first pass is calculated as:
</p>
<p style="text-align: center;"><code class="reqn"> \nu^* = \sum_{g=0}^{G-1} \nu_g </code>
</p>

<p>The second pass then applies a further weighting, which depends upon <code class="reqn"> type_g </code>,
and potentially upon <code class="reqn"> x_g </code> and <code class="reqn"> h_g </code>.
</p>
<p>If <code class="reqn">type_g = 0</code> then <code class="reqn">\phi_g = 0</code>
</p>
<p>If <code class="reqn">type_g = 1</code> then <code class="reqn">\phi_g = \nu_g</code>
</p>
<p>If <code class="reqn">type_g = 2</code> then <code class="reqn">\phi_g = x_g \frac{\nu_g}{\nu^*} </code>
</p>
<p>If <code class="reqn">type_g = 3</code> then <code class="reqn">\phi_g = \frac{\nu_{h_g}}{\nu^*} \mu_g </code>
</p>
<p>If <code class="reqn">type_g = 4</code> then <code class="reqn">\phi_g = \nu_{h_g} \mu_g </code>
</p>
<p>Finally, the total value from this second pass is calculated as:
</p>
<p style="text-align: center;"><code class="reqn"> \phi^* = \sum_{g=0}^{G-1} \phi_g </code>
</p>

<p>and <code class="reqn">\phi^*</code> is outputted by <code>integrate_output</code>,
along with a standard error and potentially using
the epsilon bias-correction estimator to correct for skewness and retransformation
bias.
</p>
<p>Standard bias-correction using <code>bias.correct=TRUE</code> can be slow, and in
some cases it might be faster to do <code>apply.epsilon=TRUE</code> and <code>intern=TRUE</code>.
However, that option is somewhat experimental, and a user might want to confirm
that the two options give identical results. Similarly, using <code>bias.correct=TRUE</code>
will still calculate the standard-error, whereas using
<code>apply.epsilon=TRUE</code> and <code>intern=TRUE</code> will not.
</p>


<h3>Value</h3>

<p>A vector containing the plug-in estimate, standard error, the epsilon bias-corrected
estimate if available, and the standard error for the bias-corrected estimator.
Depending upon settings, one or more of these will be <code>NA</code> values, and the
function can be repeatedly called to get multiple estimators and/or statistics.
</p>

<hr>
<h2 id='logLik.tinyVAST'>Extract the (marginal) log-likelihood of a tinyVAST model</h2><span id='topic+logLik.tinyVAST'></span>

<h3>Description</h3>

<p>Extract the (marginal) log-likelihood of a tinyVAST model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tinyVAST'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.tinyVAST_+3A_object">object</code></td>
<td>
<p>output from <code>tinyVAST</code></p>
</td></tr>
<tr><td><code id="logLik.tinyVAST_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>logLik</code> with attributes
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>log-likelihood</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>number of parameters</p>
</td></tr>
</table>

<hr>
<h2 id='make_dsem_ram'>Make a RAM (Reticular Action Model)</h2><span id='topic+make_dsem_ram'></span>

<h3>Description</h3>

<p><code>make_dsem_ram</code> converts SEM arrow notation to <code>ram</code> describing SEM parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dsem_ram(
  dsem,
  times,
  variables,
  covs = NULL,
  quiet = FALSE,
  remove_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dsem_ram_+3A_dsem">dsem</code></td>
<td>
<p>dynamic structural equation model structure,
passed to either <code><a href="sem.html#topic+specifyModel">specifyModel</a></code>
or <code><a href="sem.html#topic+specifyEquations">specifyEquations</a></code> and then parsed to control
the set of path coefficients and variance-covariance parameters</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_times">times</code></td>
<td>
<p>A character vector listing the set of times in order</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_variables">variables</code></td>
<td>
<p>A character vector listing the set of variables</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_covs">covs</code></td>
<td>
<p>optional: a character vector of one or more elements, with each element
giving a string of variable names, separated by commas. Variances and covariances
among all variables in each such string are added to the model. For confirmatory
factor analysis models specified via <code>cfa</code>, <code>covs</code> defaults to all of
the factors in the model, thus specifying all variances and covariances among these factors.
<em>Warning</em>: <code>covs="x1, x2"</code> and <code>covs=c("x1", "x2")</code> are <em>not</em>
equivalent: <code>covs="x1, x2"</code> specifies the variance of <code>x1</code>, the variance
of <code>x2</code>, <em>and</em> their covariance, while <code>covs=c("x1", "x2")</code> specifies
the variance of <code>x1</code> and the variance of <code>x2</code> <em>but not</em> their covariance.</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_quiet">quiet</code></td>
<td>
<p>Boolean indicating whether to print messages to terminal</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_remove_na">remove_na</code></td>
<td>
<p>Boolean indicating whether to remove NA values from RAM (default) or not.
<code>remove_NA=FALSE</code> might be useful for exploration and diagnostics for
advanced users</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>RAM specification using arrow-and-lag notation</strong>
</p>
<p>Each line of the RAM specification for <code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> consists of four (unquoted) entries,
separated by commas:
</p>

<dl>
<dt>1. Arrow specification:</dt><dd><p>This is a simple formula, of the form
<code>A -&gt; B</code> or, equivalently, <code>B &lt;- A</code> for a regression
coefficient (i.e., a single-headed or directional arrow);
<code>A &lt;-&gt; A</code> for a variance or <code>A &lt;-&gt; B</code> for a covariance
(i.e., a double-headed or bidirectional arrow). Here, <code>A</code> and
<code>B</code> are variable names in the model. If a name does not correspond
to an observed variable, then it is assumed to be a latent variable.
Spaces can appear freely in an arrow specification, and
there can be any number of hyphens in the arrows, including zero: Thus,
e.g., <code>A-&gt;B</code>, <code>A --&gt; B</code>, and <code>A&gt;B</code> are all legitimate
and equivalent.</p>
</dd>
<dt>2. Lag (using positive values):</dt><dd><p>An integer specifying whether the linkage
is simultaneous (<code>lag=0</code>) or lagged (e.g., <code>X -&gt; Y, 1, XtoY</code>
indicates that X in time T affects Y in time T+1), where
only one-headed arrows can be lagged. Using positive values to indicate lags
then matches the notational convention used in package <span class="pkg">dynlm</span>.</p>
</dd>
<dt>3. Parameter name:</dt><dd><p>The name of the regression coefficient, variance,
or covariance specified by the arrow. Assigning the same name to two or
more arrows results in an equality constraint. Specifying the parameter name
as <code>NA</code> produces a fixed parameter.</p>
</dd>
<dt>4. Value:</dt><dd><p>start value for a free parameter or value of a fixed parameter.
If given as <code>NA</code> (or simply omitted), the model is provide a default
starting value.</p>
</dd>
</dl>

<p>Lines may end in a comment following #. The function extends code copied from package
<code>sem</code> under licence GPL (&gt;= 2) with permission from John Fox.
</p>
<p><strong>Simultaneous autoregressive process for simultaneous and lagged effects</strong>
</p>
<p>This text then specifies linkages in a multivariate time-series model for variables <code class="reqn">\mathbf X</code>
with dimensions <code class="reqn">T \times C</code> for <code class="reqn">T</code> times and <code class="reqn">C</code> variables.
<code>make_dsem_ram</code> then parses this text to build a path matrix <code class="reqn">\mathbf P</code> with
dimensions <code class="reqn">TC \times TC</code>, where <code class="reqn">\rho_{k_2,k_1}</code>
represents the impact of <code class="reqn">x_{t_1,c_1}</code> on <code class="reqn">x_{t_2,c_2}</code>, where <code class="reqn">k_1=T c_1+t_1</code>
and <code class="reqn">k_2=T c_2+t_2</code>.  This path matrix defines a simultaneous equation
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{vec}(\mathbf X) = \mathbf P \mathrm{vec}(\mathbf X) + \mathrm{vec}(\mathbf \Delta)</code>
</p>

<p>where <code class="reqn">\mathbf \Delta</code> is a matrix of exogenous errors with covariance <code class="reqn">\mathbf{V = \Gamma \Gamma}^t</code>,
where <code class="reqn">\mathbf \Gamma</code> is the Cholesky of exogenous covariance.  This
simultaneous autoregressive (SAR) process then results in <code class="reqn">\mathbf X</code> having covariance:
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{Cov}(\mathbf X) = \mathbf{(I - P)}^{-1} \mathbf{\Gamma \Gamma}^t \mathbf{((I - P)}^{-1})^t </code>
</p>

<p>Usefully, it is also easy to compute the inverse-covariance (precision) matrix <code class="reqn">\mathbf{Q = V}^{-1}</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{Q} = (\mathbf{\Gamma}^{-1} \mathbf{(I - P)})^t \mathbf{\Gamma}^{-1} \mathbf{(I - P)} </code>
</p>

<p><strong>Example: univariate and first-order autoregressive model</strong>
</p>
<p>This simultaneous autoregressive (SAR) process across variables and times
allows the user to specify both simultaneous effects (effects among variables within
year <code class="reqn">T</code>) and lagged effects (effects among variables among years <code class="reqn">T</code>).
As one example, consider a univariate and first-order autoregressive process where <code class="reqn">T=4</code>.
with independent errors.  This is specified by passing <code> dsem = X -&gt; X, 1, rho; X &lt;-&gt; X, 0, sigma </code> to <code>make_dsem_ram</code>.
This is then parsed to a RAM:
</p>

<table>
<tr>
 <td style="text-align: right;">
<strong>heads</strong> </td><td style="text-align: right;"> <strong>to</strong> </td><td style="text-align: right;"> <strong>from</strong> </td><td style="text-align: right;"> <strong>paarameter</strong> </td><td style="text-align: right;"> <strong>start</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> NA </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> NA </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;">  1 </td><td style="text-align: right;"> NA </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> NA </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;">  2 </td><td style="text-align: right;"> NA </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> NA </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> NA
</td>
</tr>

</table>

<p>Rows of this RAM where <code>heads=1</code> are then interpreted to construct the path matrix <code class="reqn">\mathbf P</code>:
</p>
<div class="sourceCode"><pre>\deqn{ \mathbf P = \begin{bmatrix}
    0 &amp; 0 &amp; 0 &amp; 0 \
    \rho &amp; 0 &amp; 0 &amp; 0 \
    0 &amp; \rho &amp; 0 &amp; 0 \
    0 &amp; 0 &amp; \rho &amp; 0\
    \end{bmatrix} }
</pre></div>
<p>While rows where <code>heads=2</code> are interpreted to construct the Cholesky of exogenous covariance <code class="reqn">\mathbf \Gamma</code>:
</p>
<div class="sourceCode"><pre>\deqn{ \mathbf \Gamma = \begin{bmatrix}
    \sigma &amp; 0 &amp; 0 &amp; 0 \
    0 &amp; \sigma &amp; 0 &amp; 0 \
    0 &amp; 0 &amp; \sigma &amp; 0 \
    0 &amp; 0 &amp; 0 &amp; \sigma\
    \end{bmatrix} }
</pre></div>
<p>with two estimated parameters <code class="reqn">\mathbf \beta = (\rho, \sigma) </code>. This then results in covariance:
</p>
<div class="sourceCode"><pre>\deqn{ \mathrm{Cov}(\mathbf X) = \sigma^2 \begin{bmatrix}
    1 &amp; \rho^1 &amp; \rho^2 &amp; \rho^3 \
    \rho^1 &amp; 1 &amp; \rho^1 &amp; \rho^2 \
    \rho^2 &amp; \rho^1 &amp; 1 &amp; \rho^1 \
    \rho^3 &amp; \rho^2 &amp; \rho^1 &amp; 1\
    \end{bmatrix} }
</pre></div>
<p>Similarly, the arrow-and-lag notation can be used to specify a SAR representing
a conventional structural equation model (SEM), cross-lagged (a.k.a. vector autoregressive)
models (VAR), dynamic factor analysis (DFA), or many other time-series models.
</p>


<h3>Value</h3>

<p>A reticular action module (RAM) describing dependencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate AR1
dsem = "
  X -&gt; X, 1, rho
  X &lt;-&gt; X, 0, sigma
"
make_dsem_ram( dsem=dsem, variables="X", times=1:4 )

# Univariate AR2
dsem = "
  X -&gt; X, 1, rho1
  X -&gt; X, 2, rho2
  X &lt;-&gt; X, 0, sigma
"
make_dsem_ram( dsem=dsem, variables="X", times=1:4 )

# Bivariate VAR
dsem = "
  X -&gt; X, 1, XtoX
  X -&gt; Y, 1, XtoY
  Y -&gt; X, 1, YtoX
  Y -&gt; Y, 1, YtoY
  X &lt;-&gt; X, 0, sdX
  Y &lt;-&gt; Y, 0, sdY
"
make_dsem_ram( dsem=dsem, variables=c("X","Y"), times=1:4 )

# Dynamic factor analysis with one factor and two manifest variables
# (specifies a random-walk for the factor, and miniscule residual SD)
dsem = "
  factor -&gt; X, 0, loadings1
  factor -&gt; Y, 0, loadings2
  factor -&gt; factor, 1, NA, 1
  X &lt;-&gt; X, 0, NA, 0           # No additional variance
  Y &lt;-&gt; Y, 0, NA, 0           # No additional variance
"
make_dsem_ram( dsem=dsem, variables=c("X","Y","factor"), times=1:4 )

# ARIMA(1,1,0)
dsem = "
  factor -&gt; factor, 1, rho1 # AR1 component
  X -&gt; X, 1, NA, 1          # Integrated component
  factor -&gt; X, 0, NA, 1
  X &lt;-&gt; X, 0, NA, 0         # No additional variance
"
make_dsem_ram( dsem=dsem, variables=c("X","factor"), times=1:4 )

# ARIMA(0,0,1)
dsem = "
  factor -&gt; X, 0, NA, 1
  factor -&gt; X, 1, rho1     # MA1 component
  X &lt;-&gt; X, 0, NA, 0        # No additional variance
"
make_dsem_ram( dsem=dsem, variables=c("X","factor"), times=1:4 )

</code></pre>

<hr>
<h2 id='make_eof_ram'>Make a RAM (Reticular Action Model)</h2><span id='topic+make_eof_ram'></span>

<h3>Description</h3>

<p><code>make_eof_ram</code> converts SEM arrow notation to <code>ram</code> describing SEM parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_eof_ram(
  times,
  variables,
  n_eof,
  remove_na = TRUE,
  standard_deviations = "unequal"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_eof_ram_+3A_times">times</code></td>
<td>
<p>A character vector listing the set of times in order</p>
</td></tr>
<tr><td><code id="make_eof_ram_+3A_variables">variables</code></td>
<td>
<p>A character vector listing the set of variables</p>
</td></tr>
<tr><td><code id="make_eof_ram_+3A_n_eof">n_eof</code></td>
<td>
<p>Number of EOF modes of variability to estimate</p>
</td></tr>
<tr><td><code id="make_eof_ram_+3A_remove_na">remove_na</code></td>
<td>
<p>Boolean indicating whether to remove NA values from RAM (default) or not.
<code>remove_NA=FALSE</code> might be useful for exploration and diagnostics for
advanced users</p>
</td></tr>
<tr><td><code id="make_eof_ram_+3A_standard_deviations">standard_deviations</code></td>
<td>
<p>One of <code>"equal"</code>, <code>"unequal"</code>, or a numeric vector
indicating fixed values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reticular action module (RAM) describing dependencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two EOFs for two variables
make_eof_ram( times = 2010:2020, variables = c("pollock","cod"), n_eof=2 )

</code></pre>

<hr>
<h2 id='make_sem_ram'>Make a RAM (Reticular Action Model) from a SEM (structural equation model)</h2><span id='topic+make_sem_ram'></span>

<h3>Description</h3>

<p><code>make_sem_ram</code> converts SEM arrow notation to <code>ram</code> describing SEM parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sem_ram(sem, variables, quiet = FALSE, covs = variables)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_sem_ram_+3A_sem">sem</code></td>
<td>
<p>structural equation model structure, passed to either <code><a href="sem.html#topic+specifyModel">specifyModel</a></code>
or <code><a href="sem.html#topic+specifyEquations">specifyEquations</a></code> and then parsed to control
the set of path coefficients and variance-covariance parameters</p>
</td></tr>
<tr><td><code id="make_sem_ram_+3A_variables">variables</code></td>
<td>
<p>A character vector listing the set of variables</p>
</td></tr>
<tr><td><code id="make_sem_ram_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code>, the default, then the number of input lines is reported and
a message is printed suggesting that <code>specifyEquations</code> or <code>cfa</code> be used.</p>
</td></tr>
<tr><td><code id="make_sem_ram_+3A_covs">covs</code></td>
<td>
<p>optional: a character vector of one or more elements, with each element
giving a string of variable names, separated by commas. Variances and covariances
among all variables in each such string are added to the model. For confirmatory
factor analysis models specified via <code>cfa</code>, <code>covs</code> defaults to all of
the factors in the model, thus specifying all variances and covariances among these factors.
<em>Warning</em>: <code>covs="x1, x2"</code> and <code>covs=c("x1", "x2")</code> are <em>not</em>
equivalent: <code>covs="x1, x2"</code> specifies the variance of <code>x1</code>, the variance
of <code>x2</code>, <em>and</em> their covariance, while <code>covs=c("x1", "x2")</code> specifies
the variance of <code>x1</code> and the variance of <code>x2</code> <em>but not</em> their covariance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3-class <code>"sem_ram"</code> containing:
</p>

<dl>
<dt><code>model</code></dt><dd><p>Output from <code><a href="sem.html#topic+specifyEquations">specifyEquations</a></code> or <code><a href="sem.html#topic+specifyModel">specifyModel</a></code>
that defines paths and parameters</p>
</dd>
<dt><code>ram</code></dt><dd><p>reticular action module (RAM) describing dependencies</p>
</dd>
</dl>


<hr>
<h2 id='parse_path'>Parse path</h2><span id='topic+parse_path'></span>

<h3>Description</h3>

<p><code>parse_path</code> is copied from <code>sem::parse.path</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_path(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_path_+3A_path">path</code></td>
<td>
<p>character string indicating a one-headed or two-headed path
in a structural equation model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Copied from package <code>sem</code> under licence GPL (&gt;= 2) with permission from John Fox
</p>


<h3>Value</h3>

<p>Tagged-list defining variables and direction for a specified path coefficient
</p>

<hr>
<h2 id='predict.tinyVAST'>Predict using vector autoregressive spatio-temporal model</h2><span id='topic+predict.tinyVAST'></span>

<h3>Description</h3>

<p>Predicts values given new covariates using a <span class="pkg">tinyVAST</span> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tinyVAST'
predict(
  object,
  newdata,
  remove_origdata = FALSE,
  what = c("mu_g", "p_g", "palpha_g", "pgamma_g", "pepsilon_g", "pomega_g", "pdelta_g",
    "pxi_g", "p2_g", "palpha2_g", "pgamma2_g", "pepsilon2_g", "pomega2_g", "pdelta2_g",
    "pxi2_g"),
  se.fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tinyVAST_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.tinyVAST_+3A_newdata">newdata</code></td>
<td>
<p>New data-frame of independent variables used to predict the response.</p>
</td></tr>
<tr><td><code id="predict.tinyVAST_+3A_remove_origdata">remove_origdata</code></td>
<td>
<p>Whether to eliminate the original data
from the TMB object, thereby speeding up the TMB object construction.  However, this
also eliminates information about random-effect variance, and is not
appropriate when requesting predictive standard errors or epsilon
bias-correction.</p>
</td></tr>
<tr><td><code id="predict.tinyVAST_+3A_what">what</code></td>
<td>
<p>What REPORTed object to output, where
<code>mu_g</code> is the inverse-linked transformed predictor including both linear components,
<code>p_g</code> is the first linear predictor,
<code>palpha_g</code> is the first predictor from fixed covariates in <code>formula</code>,
<code>pgamma_g</code> is the first predictor from random covariates in <code>formula</code> (e.g., splines),
<code>pomega_g</code> is the first predictor from spatial variation,
<code>pepsilon_g</code> is the first predictor from spatio-temporal variation,
<code>pxi_g</code> is the first predictor from spatially varying coefficients,
<code>p2_g</code> is the second linear predictor,
<code>palpha2_g</code> is the second predictor from fixed covariates in <code>formula</code>,
<code>pgamma2_g</code> is the second predictor from random covariates in <code>formula</code> (e.g., splines),
<code>pomega2_g</code> is the second predictor from spatial variation,
<code>pepsilon2_g</code> is the second predictor from spatio-temporal variation, and
<code>pxi2_g</code> is the second predictor from spatially varying coefficients.</p>
</td></tr>
<tr><td><code id="predict.tinyVAST_+3A_se.fit">se.fit</code></td>
<td>
<p>Calculate standard errors?</p>
</td></tr>
<tr><td><code id="predict.tinyVAST_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector with the prediction for each row of <code>newdata</code>, or a named list
with the prediction and standard error (when <code>se.fit = TRUE</code>).
</p>

<hr>
<h2 id='print.tinyVAST'>print summary of tinyVAST model</h2><span id='topic+print.tinyVAST'></span>

<h3>Description</h3>

<p>print summary of tinyVAST model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tinyVAST'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tinyVAST_+3A_x">x</code></td>
<td>
<p>output from <code>tinyVAST</code></p>
</td></tr>
<tr><td><code id="print.tinyVAST_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a named list of key model outputs and summary
statements
</p>

<hr>
<h2 id='red_snapper'>Presence/absence, count, and biomass data for red snapper</h2><span id='topic+red_snapper'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test analysis using multiple data types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(red_snapper)
</code></pre>

<hr>
<h2 id='red_snapper_shapefile'>Shapefile for red snapper analysis</h2><span id='topic+red_snapper_shapefile'></span>

<h3>Description</h3>

<p>Spatial extent used for red snapper analysis, derived from Chap-7 of <a href="https://doi.org/10.1201/9781003410294">doi:10.1201/9781003410294</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(red_snapper_shapefile)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+lognormal'></span><span id='topic+nbinom2'></span><span id='topic+nbinom1'></span><span id='topic+tweedie'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>sdmTMB</dt><dd><p><code><a href="sdmTMB.html#topic+families">lognormal</a></code>, <code><a href="sdmTMB.html#topic+families">nbinom1</a></code>, <code><a href="sdmTMB.html#topic+families">nbinom2</a></code>, <code><a href="sdmTMB.html#topic+families">tweedie</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reload_model'>Reload a previously fitted model</h2><span id='topic+reload_model'></span>

<h3>Description</h3>

<p><code>reload_model</code> allows a user to save a fitted model, reload it in a new
R terminal, and then relink the DLLs so that it functions as expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reload_model(x, check_gradient = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reload_model_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVAST">tinyVAST</a></code>, potentially with DLLs not linked</p>
</td></tr>
<tr><td><code id="reload_model_+3A_check_gradient">check_gradient</code></td>
<td>
<p>Whether to check the gradients of the reloaded model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output from <code><a href="#topic+tinyVAST">tinyVAST</a></code> with DLLs relinked
</p>

<hr>
<h2 id='residuals.tinyVAST'>Calculate deviance or response residuals for tinyVAST</h2><span id='topic+residuals.tinyVAST'></span>

<h3>Description</h3>

<p>Calculate residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tinyVAST'
residuals(object, type = c("deviance", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.tinyVAST_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code></p>
</td></tr>
<tr><td><code id="residuals.tinyVAST_+3A_type">type</code></td>
<td>
<p>which type of residuals to compute (only option is <code>"deviance"</code> or <code>"response"</code> for now)</p>
</td></tr>
<tr><td><code id="residuals.tinyVAST_+3A_...">...</code></td>
<td>
<p>Note used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector residuals, associated with each row of <code>data</code> supplied during fitting
</p>

<hr>
<h2 id='rmvnorm_prec'>Multivariate Normal Random Deviates using Sparse Precision</h2><span id='topic+rmvnorm_prec'></span>

<h3>Description</h3>

<p>This function provides a random number generator for
the multivariate normal distribution with mean equal
to <code>mean</code> and sparse precision matrix <code>Q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm_prec(Q, n = 1, mean = rep(0, nrow(Q)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmvnorm_prec_+3A_q">Q</code></td>
<td>
<p>sparse precision (inverse-covariance) matrix.</p>
</td></tr>
<tr><td><code id="rmvnorm_prec_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rmvnorm_prec_+3A_mean">mean</code></td>
<td>
<p>mean vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with dimension <code>length(mean)</code> by
<code>n</code>, containing realized draws from the specified
mean and precision
</p>

<hr>
<h2 id='rotate_pca'>Rotate factors to match Principal-Components Analysis</h2><span id='topic+rotate_pca'></span>

<h3>Description</h3>

<p>Rotate lower-triangle loadings matrix
to order factors from largest to smallest variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_pca(
  L_tf,
  x_sf = matrix(0, nrow = 0, ncol = ncol(L_tf)),
  order = c("none", "increasing", "decreasing")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_pca_+3A_l_tf">L_tf</code></td>
<td>
<p>Loadings matrix with dimension <code class="reqn">T \times F</code>.</p>
</td></tr>
<tr><td><code id="rotate_pca_+3A_x_sf">x_sf</code></td>
<td>
<p>Spatial response with dimensions <code class="reqn">S \times F</code>.</p>
</td></tr>
<tr><td><code id="rotate_pca_+3A_order">order</code></td>
<td>
<p>Options for resolving label-switching via reflecting
each factor to achieve a given order across dimension <code class="reqn">T</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the rotated loadings <code>L_tf</code>,
the inverse-rotated response matrix <code>x_sf</code>,
and the rotation <code>H</code>
</p>

<hr>
<h2 id='salmon_returns'>North Pacific salmon returns</h2><span id='topic+salmon_returns'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test multivariate second-order autoregressive
models using a simultaneous autoregressive (SAR) process across regions.
Data are from <a href="https://doi.org/10.1002/mcf2.10023">doi:10.1002/mcf2.10023</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salmon_returns)
</code></pre>

<hr>
<h2 id='sample_variable'>Sample from predictive distribution of a variable</h2><span id='topic+sample_variable'></span>

<h3>Description</h3>

<p><code>sample_variable</code> samples from the joint distribution of random and fixed effects to approximate the predictive distribution for a variable
</p>
<p>Using <code>sample_fixed=TRUE</code> (the default) in <code><a href="#topic+sample_variable">sample_variable</a></code> propagates variance in both fixed and random effects, while
using <code>sample_fixed=FALSE</code> does not.
Sampling fixed effects will sometimes cause numerical under- or overflow (i.e., output values of <code>NA</code>) in cases when
variance parameters are estimated imprecisely.  In these cases, the multivariate normal approximation being used is a poor
representation of the tail probabilities, and results in some samples with implausibly high (or negative) variances,
such that the associated random effects then have implausibly high magnitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_variable(
  x,
  variable_name = "mu_i",
  n_samples = 100,
  sample_fixed = TRUE,
  seed = 123456
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_variable_+3A_x">x</code></td>
<td>
<p>output from <code style="white-space: pre;">&#8288;\code{tinyVAST()}&#8288;</code></p>
</td></tr>
<tr><td><code id="sample_variable_+3A_variable_name">variable_name</code></td>
<td>
<p>name of variable available in report using <code>Obj$report()</code> or parameters using <code>Obj$env$parList()</code></p>
</td></tr>
<tr><td><code id="sample_variable_+3A_n_samples">n_samples</code></td>
<td>
<p>number of samples from the joint predictive distribution for fixed and random effects.  Default is 100, which is slow.</p>
</td></tr>
<tr><td><code id="sample_variable_+3A_sample_fixed">sample_fixed</code></td>
<td>
<p>whether to sample fixed and random effects, <code>sample_fixed=TRUE</code> as by default, or just sample random effects, <code>sample_fixed=FALSE</code></p>
</td></tr>
<tr><td><code id="sample_variable_+3A_seed">seed</code></td>
<td>
<p>integer used to set random-number seed when sampling variables, as passed to <code>set.seed(.)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with a row for each <code>data</code> supplied during fitting, and
<code>n_samples</code> columns, where each column in a vector of samples
for a requested quantity given sampled uncertainty in fixed and/or random effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(101)
 x = runif(n = 100, min = 0, max = 2*pi)
 y = 1 + sin(x) + 0.1 * rnorm(100)

 # Do fit with getJointPrecision=TRUE
 fit = tinyVAST( formula = y ~ s(x),
                 data = data.frame(x=x,y=y),
                 control = tinyVASTcontrol(getJointPrecision = TRUE) )

 # samples from distribution for the mean
 sample_variable(fit)

</code></pre>

<hr>
<h2 id='sea_ice'>Arctic September sea ice concentrations</h2><span id='topic+sea_ice'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test empirical orthogonal function
generalized linear latent variable model (EOF-GLLVM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sea_ice)
</code></pre>

<hr>
<h2 id='sfnetwork_evaluator'>Construct projection matrix for stream network</h2><span id='topic+sfnetwork_evaluator'></span>

<h3>Description</h3>

<p>Make sparse matrix to project from stream-network nodes
to user-supplied points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfnetwork_evaluator(stream, loc, tolerance = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfnetwork_evaluator_+3A_stream">stream</code></td>
<td>
<p><span class="pkg">sfnetworks</span> object representing stream network</p>
</td></tr>
<tr><td><code id="sfnetwork_evaluator_+3A_loc">loc</code></td>
<td>
<p><span class="pkg">sf</span> object representing points to which are being projected</p>
</td></tr>
<tr><td><code id="sfnetwork_evaluator_+3A_tolerance">tolerance</code></td>
<td>
<p>error-check tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sparse interpolation matrix, with rows for each row of <code>data</code>
supplied during fitting and columns for each spatial random effect.
</p>

<hr>
<h2 id='sfnetwork_mesh'>Make mesh for stream network</h2><span id='topic+sfnetwork_mesh'></span>

<h3>Description</h3>

<p>make an object representing spatial information required
to specify a stream-network spatial domain, similar in usage to
<code>link[fmesher]{fm_mesh_2d}</code> for a 2-dimensional continuous domain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfnetwork_mesh(stream)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfnetwork_mesh_+3A_stream">stream</code></td>
<td>
<p><span class="pkg">sfnetworks</span> object representing stream network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object (list) of class <code>sfnetwork_mesh</code>. Elements include:
</p>

<dl>
<dt>N</dt><dd><p>The number of random effects used to represent the network</p>
</dd>
<dt>table</dt><dd><p>a table containing a description of parent nodes (from),
childen nodes (to), and the distance separating them</p>
</dd>
<dt>stream</dt><dd><p>copy of the stream network object passed as argument</p>
</dd>
</dl>


<hr>
<h2 id='simulate_sfnetwork'>Simulate GMRF for stream network</h2><span id='topic+simulate_sfnetwork'></span>

<h3>Description</h3>

<p>Simulate values from a GMRF using a tail-up exponential
model on a stream network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_sfnetwork(sfnetwork_mesh, theta, n = 1, what = c("samples", "Q"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_sfnetwork_+3A_sfnetwork_mesh">sfnetwork_mesh</code></td>
<td>
<p>Output from <code><a href="#topic+sfnetwork_mesh">sfnetwork_mesh</a></code></p>
</td></tr>
<tr><td><code id="simulate_sfnetwork_+3A_theta">theta</code></td>
<td>
<p>Decorrelation rate</p>
</td></tr>
<tr><td><code id="simulate_sfnetwork_+3A_n">n</code></td>
<td>
<p>number of simulated GMRFs</p>
</td></tr>
<tr><td><code id="simulate_sfnetwork_+3A_what">what</code></td>
<td>
<p>Whether to return the simulated GMRF or its precision matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of simulated values for a Gaussian Markov random field
arising from a stream-network spatial domain, with row for each spatial random
effect and <code>n</code> columns, using the sparse precision matrix
defined in Charsley et al. (2023)
</p>


<h3>References</h3>

<p>Charsley, A. R., Gruss, A., Thorson, J. T., Rudd, M. B., Crow, S. K.,
David, B., Williams, E. K., &amp; Hoyle, S. D. (2023). Catchment-scale
stream network spatio-temporal models, applied to the freshwater stages
of a diadromous fish species, longfin eel (Anguilla dieffenbachii).
Fisheries Research, 259, 106583. <a href="https://doi.org/10.1016/j.fishres.2022.106583">doi:10.1016/j.fishres.2022.106583</a>
</p>

<hr>
<h2 id='simulate.tinyVAST'>Simulate new data from a fitted model</h2><span id='topic+simulate.tinyVAST'></span>

<h3>Description</h3>

<p><code>simulate.tinyVAST</code> is an S3 method for producing a matrix of simulations from
a fitted model. It can be used with the <span class="pkg">DHARMa</span> package
among other uses.  Code is modified from the version in sdmTMB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tinyVAST'
simulate(
  object,
  nsim = 1L,
  seed = sample.int(1e+06, 1L),
  type = c("mle-eb", "mle-mvn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.tinyVAST_+3A_object">object</code></td>
<td>
<p>output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code></p>
</td></tr>
<tr><td><code id="simulate.tinyVAST_+3A_nsim">nsim</code></td>
<td>
<p>how many simulations to do</p>
</td></tr>
<tr><td><code id="simulate.tinyVAST_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="simulate.tinyVAST_+3A_type">type</code></td>
<td>
<p>How parameters should be treated. <code>"mle-eb"</code>: fixed effects
are at their maximum likelihood (MLE) estimates  and random effects are at
their empirical Bayes (EB) estimates. <code>"mle-mvn"</code>: fixed effects are at
their MLEs but random effects are taken from a single approximate sample.
This latter option is a suggested approach if these simulations will be
used for goodness of fit testing (e.g., with the DHARMa package).</p>
</td></tr>
<tr><td><code id="simulate.tinyVAST_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with row for each row of <code>data</code> in the fitted model and <code>nsim</code>
columns, containing new samples from the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
x = seq(0, 2*pi, length=100)
y = sin(x) + 0.1*rnorm(length(x))
fit = tinyVAST( data=data.frame(x=x,y=y), formula = y ~ s(x) )
simulate(fit, nsim=100, type="mle-mvn")

if(requireNamespace("DHARMa")){
  # simulate new data conditional on fixed effects
  # and sampling random effects from their predictive distribution
  y_iz = simulate(fit, nsim=500, type="mle-mvn")

  # Visualize using DHARMa
  res = DHARMa::createDHARMa( simulatedResponse = y_iz,
                      observedResponse = y,
                      fittedPredictedResponse = fitted(fit) )
  plot(res)
}
</code></pre>

<hr>
<h2 id='summary.tinyVAST'>summarize tinyVAST</h2><span id='topic+summary.tinyVAST'></span>

<h3>Description</h3>

<p>summarize parameters from a fitted tinyVAST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tinyVAST'
summary(
  object,
  what = c("space_term", "time_term", "spacetime_term", "fixed"),
  predictor = c("one", "two"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tinyVAST_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code></p>
</td></tr>
<tr><td><code id="summary.tinyVAST_+3A_what">what</code></td>
<td>
<p>What component to summarize, whether <code>space_term</code>, <code>spacetime_term</code>, or
<code>fixed</code> for the fixed effects included in the GAM formula</p>
</td></tr>
<tr><td><code id="summary.tinyVAST_+3A_predictor">predictor</code></td>
<td>
<p>whether to get the 1st or 2nd linear predictor (the latter is
only applicable in delta models)</p>
</td></tr>
<tr><td><code id="summary.tinyVAST_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tinyVAST</code> includes three components:
</p>

<dl>
<dt>Space-variable interaction</dt><dd><p>a separable Gaussian Markov random field (GMRF)
constructed from a structural equation model (SEM) and a spatial variable</p>
</dd>
<dt>Space-variable-time interaction</dt><dd><p>a separable GMRF constructed from a
a dynamic SEM (a nonseparable time-variable interaction) and a spatial variable</p>
</dd>
<dt>Additive variation</dt><dd><p>a generalized additive model (GAM), representing exogenous
covariates </p>
</dd>
</dl>

<p>Each of these are summarized and interpreted differently, and <code>summary.tinyVAST</code>
facilitates this.
</p>
<p>Regarding the DSEM componennt, tinyVAST includes an &quot;arrow and lag&quot;
notation, which specifies the set of
path coefficients and exogenous variance parameters to be estimated. Function <code>tinyVAST</code>
then estimates the maximum likelihood value for those coefficients and parameters
by maximizing the log-marginal likelihood.
</p>
<p>However, many users will want to associate individual parameters and standard errors
with the path coefficients that were specified using the &quot;arrow and lag&quot; notation.
This task is complicated in
models where some path coefficients or variance parameters are specified to share a single value a priori,
or were assigned a name of NA and hence assumed to have a fixed value a priori (such that
these coefficients or parameters have an assigned value but no standard error).
The <code>summary</code> function therefore compiles the MLE for coefficients (including duplicating
values for any path coefficients that assigned the same value) and standard error
estimates, and outputs those in a table that associates them with the user-supplied path and parameter names.
It also outputs the z-score and a p-value arising from a two-sided Wald test (i.e.
comparing the estimate divided by standard error against a standard normal distribution).
</p>


<h3>Value</h3>

<p>A data-frame containing the estimate (and standard errors, two-sided Wald-test
z-value, and associated p-value if the standard errors are available) for
model parameters, including the fixed-effects specified via <code>formula</code>,
or the path coefficients for the spatial SEM specified via <code>space_term</code>,
the dynamic SEM specified via <code>time_term</code>, or the spatial dynamic SEM
specified via <code>spacetime_term</code>
</p>

<hr>
<h2 id='tinyVAST'>Fit vector autoregressive spatio-temporal model</h2><span id='topic+tinyVAST'></span>

<h3>Description</h3>

<p>Fits a vector autoregressive spatio-temporal (VAST) model using
a minimal feature-set and a widely used interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tinyVAST(
  formula,
  data,
  time_term = NULL,
  space_term = NULL,
  spacetime_term = NULL,
  family = gaussian(),
  space_columns = c("x", "y"),
  spatial_domain = NULL,
  time_column = "time",
  times = NULL,
  variable_column = "var",
  variables = NULL,
  distribution_column = "dist",
  delta_options = list(formula = ~1),
  spatial_varying = NULL,
  weights = NULL,
  control = tinyVASTcontrol(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tinyVAST_+3A_formula">formula</code></td>
<td>
<p>Formula with response on left-hand-side and predictors on right-hand-side,
parsed by <code>mgcv</code> and hence allowing <code>s(.)</code> for splines or <code>offset(.)</code> for
an offset.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_data">data</code></td>
<td>
<p>Data-frame of predictor, response, and offset variables.  Also includes
variables that specify space, time, variables, and the distribution for samples,
as identified by arguments <code>variable_column</code>, <code>time_column</code>, <code>space_columns</code>,
and <code>distribution_column</code>.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_time_term">time_term</code></td>
<td>
<p>Specification for time-series structural equation model structure for
constructing a time-variable interaction that defines a time-varying intercept
for each variable (i.e., applies uniformly across space).
<code>time_term=NULL</code> disables the space-variable interaction;
see <code><a href="#topic+make_dsem_ram">make_dsem_ram()</a></code> for notation.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_space_term">space_term</code></td>
<td>
<p>Specification for structural equation model structure for
constructing a space-variable interaction.
<code>space_term=NULL</code> disables the space-variable interaction;
see <code><a href="#topic+make_sem_ram">make_sem_ram()</a></code> for notation.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_spacetime_term">spacetime_term</code></td>
<td>
<p>Specification for time-series structural equation model structure
including lagged or simultaneous effects for
constructing a time-variable interaction, which is then combined in
a separable process with the spatial correlation to form a
space-time-variable interaction (i.e., the interaction occurs locally at each site).
<code>spacetime_term=NULL</code> disables the space-variable interaction; see
<code><a href="#topic+make_dsem_ram">make_dsem_ram()</a></code>  or <code><a href="#topic+make_eof_ram">make_eof_ram()</a></code>.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_family">family</code></td>
<td>
<p>A function returning a class <code>family</code>, including <code><a href="stats.html#topic+gaussian">gaussian()</a></code>,
<code><a href="#topic+lognormal">lognormal()</a></code>, <code><a href="#topic+tweedie">tweedie()</a></code>,  <code><a href="stats.html#topic+binomial">binomial()</a></code>,  <code><a href="stats.html#topic+Gamma">Gamma()</a></code>, <code><a href="stats.html#topic+poisson">poisson()</a></code>,
<code><a href="#topic+nbinom1">nbinom1()</a></code>, or <code><a href="#topic+nbinom2">nbinom2()</a></code>.
Alternatively, can be a named list of
these functions, with names that match levels of
<code>data$distribution_column</code> to allow different
families by row of data. Delta model families are possible, and see
<code><a href="#topic+families">Families</a></code> for delta-model options,</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_space_columns">space_columns</code></td>
<td>
<p>A string or character vector that indicates
the column(s) of <code>data</code> indicating the location of each sample.
When <code>spatial_domain</code> is an <code>igraph</code> object, <code>space_columns</code> is a string with
with levels matching the names of vertices of that object.
When <code>spatial_domain</code> is an <code>fmesher</code> or <code>sfnetwork</code> object,
space_columns is a character vector indicating columns of <code>data</code> with
coordinates for each sample.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_spatial_domain">spatial_domain</code></td>
<td>
<p>Object that represents spatial relationships, either using
<code><a href="fmesher.html#topic+fm_mesh_2d">fmesher::fm_mesh_2d()</a></code> to apply the SPDE method,
<code><a href="igraph.html#topic+make_empty_graph">igraph::make_empty_graph()</a></code> for independent time-series,
<code><a href="igraph.html#topic+make_graph">igraph::make_graph()</a></code> to apply a simultaneous autoregressive (SAR)
process, <code><a href="#topic+sfnetwork_mesh">sfnetwork_mesh()</a></code> for stream networks,
or <code>NULL</code> to specify a single site.  If using <code>igraph</code> then the
graph must have vertex names <code>V(graph)$name</code> that match
levels of <code>data[,'space_columns']</code></p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_time_column">time_column</code></td>
<td>
<p>A character string indicating the column of <code>data</code>
listing the time-interval for each sample, from the set of times
in argument <code>times</code>.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_times">times</code></td>
<td>
<p>A integer vector listing the set of times in order.
If <code>times=NULL</code>, then it is filled in as the vector of integers
from the minimum to maximum value of <code>data$time</code>.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_variable_column">variable_column</code></td>
<td>
<p>A character string indicating the column of <code>data</code>
listing the variable for each sample, from the set of times
in argument <code>variables</code>.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_variables">variables</code></td>
<td>
<p>A character vector listing the set of variables.
if <code>variables=NULL</code>, then it is filled in as the unique values
from <code>data$variable_columns</code>.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_distribution_column">distribution_column</code></td>
<td>
<p>A character string indicating the column of <code>data</code>
listing the distribution for each sample, from the set of names
in argument <code>family</code>.
if <code>variables=NULL</code>, then it is filled in as the unique values
from <code>data$variables</code>.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_delta_options">delta_options</code></td>
<td>
<p>a named list with slots for <code>formula</code>,
<code>space_term</code>, and <code>spacetime_term</code>. These specify options for the
second linear predictor of a delta model, and are only used (or estimable)
when a <code><a href="#topic+families">delta family</a></code> is used for some samples.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_spatial_varying">spatial_varying</code></td>
<td>
<p>a formula specifying spatially varying coefficients.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_weights">weights</code></td>
<td>
<p>A numeric vector representing optional likelihood weights for the
data likelihood. Weights do not have to sum to one and are not internally modified.
Thee weights argument needs to be a vector and not a name of the variable in the data frame.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_control">control</code></td>
<td>
<p>Output from <code><a href="#topic+tinyVASTcontrol">tinyVASTcontrol()</a></code>, used to define user
settings.</p>
</td></tr>
<tr><td><code id="tinyVAST_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tinyVAST</code> includes four basic inputs that specify the model structure:
</p>

<ul>
<li> <p><code>formula</code> specifies covariates and splines in a Generalized Additive Model;
</p>
</li>
<li> <p><code>space_term</code> specifies interactions among variables and over time, constructing
the space-variable interaction.
</p>
</li>
<li> <p><code>spacetime_term</code> specifies interactions among variables and over time, constructing
the space-time-variable interaction.
</p>
</li>
<li> <p><code>spatial_domain</code> specifies spatial correlations
</p>
</li></ul>

<p>the default <code>spacetime_term=NULL</code> and <code>space_term=NULL</code> turns off all multivariate
and temporal indexing, such that <code>spatial_domain</code> is then ignored, and the model collapses
to a generalized additive model using <code><a href="mgcv.html#topic+gam">gam</a></code>.  To specify a univariate spatial model,
the user must specify <code>spatial_domain</code> and either <code>space_term=""</code> or <code>spacetime_term=""</code>, where the latter
two are then parsed to include a single exogenous variance for the single variable</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Model type</strong> </td><td style="text-align: left;"> <strong>How to specify</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Generalized additive model </td><td style="text-align: left;"> specify <code>spatial_domain=NULL</code> <code>space_term=""</code> and <code>spacetime_term=""</code>, and then use <code>formula</code> to specify splines and covariates </td>
</tr>
<tr>
 <td style="text-align: left;">
   Dynamic structural equation model (including vector autoregressive, dynamic factor analysis, ARIMA, and structural equation models) </td><td style="text-align: left;"> specify <code>spatial_domain=NULL</code> and use <code>spacetime_term</code> to specify interactions among variables and over time </td>
</tr>
<tr>
 <td style="text-align: left;">
   Univariate spatio-temporal model, or multiple independence spatio-temporal variables </td><td style="text-align: left;"> specify <code>spatial_domain</code> and <code>spacetime_term=""</code>, where the latter is then parsed to include a single exogenous variance for the single variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   Multivariate spatial model including interactions </td><td style="text-align: left;"> specify <code>spatial_domain</code> and use <code>space_term</code> to specify spatial interactions </td>
</tr>
<tr>
 <td style="text-align: left;">
   Vector autoregressive spatio-temporal model (i.e., lag-1 interactions among variables) </td><td style="text-align: left;"> specify <code>spatial_domain</code> and use <code>spacetime_term=""</code> to specify interactions among variables and over time, where spatio-temporal variables are constructed via the separable interaction of <code>spacetime_term</code> and <code>spatial_domain</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>An object (list) of class <code>tinyVAST</code>. Elements include:
</p>

<dl>
<dt>data</dt><dd><p>Data-frame supplied during model fitting</p>
</dd>
<dt>spatial_domain</dt><dd><p>the spatial domain supplied during fitting</p>
</dd>
<dt>formula</dt><dd><p>the formula specified during model fitting</p>
</dd>
<dt>obj</dt><dd><p>The TMB object from <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</dd>
<dt>opt</dt><dd><p>The output from <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>
</dd>
<dt>opt</dt><dd><p>The report from <code>obj$report()</code></p>
</dd>
<dt>sdrep</dt><dd><p>The output from <code><a href="TMB.html#topic+sdreport">sdreport</a></code></p>
</dd>
<dt>tmb_inputs</dt><dd><p>The list of inputs passed to <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</dd>
<dt>call</dt><dd><p>A record of the function call</p>
</dd>
<dt>run_time</dt><dd><p>Total time to run model</p>
</dd>
<dt>interal</dt><dd><p>Objects useful for package function, i.e., all arguments
passed during the call</p>
</dd>
<dt>deviance_explained</dt><dd><p>output from <code><a href="#topic+deviance_explained">deviance_explained</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p>Details section of <code><a href="#topic+make_dsem_ram">make_dsem_ram()</a></code> for a summary of the math involved with constructing the DSEM, and <a href="https://doi.org/10.1111/2041-210X.14289">doi:10.1111/2041-210X.14289</a> for more background on math and inference
</p>
<p><a href="https://doi.org/10.48550/arXiv.2401.10193">doi:10.48550/arXiv.2401.10193</a> for more details on how GAM, SEM, and DSEM components are combined from a statistical and software-user perspective
</p>
<p><code><a href="#topic+summary.tinyVAST">summary.tinyVAST()</a></code> to visualize parameter estimates related to SEM and DSEM model components
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a seperable two-dimensional AR1 spatial process
n_x = n_y = 25
n_w = 10
R_xx = exp(-0.4 * abs(outer(1:n_x, 1:n_x, FUN="-")) )
R_yy = exp(-0.4 * abs(outer(1:n_y, 1:n_y, FUN="-")) )
z = mvtnorm::rmvnorm(1, sigma=kronecker(R_xx,R_yy) )

# Simulate nuissance parameter z from oscillatory (day-night) process
w = sample(1:n_w, replace=TRUE, size=length(z))
Data = data.frame( expand.grid(x=1:n_x, y=1:n_y), w=w, z=as.vector(z) + cos(w/n_w*2*pi))
Data$n = Data$z + rnorm(nrow(Data), sd=1)

# Add columns for multivariate and/or temporal dimensions
Data$var = "n"

# make SPDE mesh for spatial term
mesh = fmesher::fm_mesh_2d( Data[,c('x','y')], n=100 )

# fit model with cyclic confounder as GAM term
out = tinyVAST( data = Data,
                formula = n ~ s(w),
                spatial_domain = mesh,
                space_term = "n &lt;-&gt; n, sd_n" )

</code></pre>

<hr>
<h2 id='tinyVASTcontrol'>Control parameters for tinyVAST</h2><span id='topic+tinyVASTcontrol'></span>

<h3>Description</h3>

<p>Control parameters for tinyVAST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tinyVASTcontrol(
  nlminb_loops = 1,
  newton_loops = 0,
  eval.max = 1000,
  iter.max = 1000,
  getsd = TRUE,
  silent = getOption("tinyVAST.silent", TRUE),
  trace = getOption("tinyVAST.trace", 0),
  verbose = getOption("tinyVAST.verbose", FALSE),
  profile = c(),
  tmb_par = NULL,
  tmb_map = NULL,
  gmrf_parameterization = c("separable", "projection"),
  reml = FALSE,
  getJointPrecision = FALSE,
  calculate_deviance_explained = TRUE,
  run_model = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tinyVASTcontrol_+3A_nlminb_loops">nlminb_loops</code></td>
<td>
<p>Integer number of times to call <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_newton_loops">newton_loops</code></td>
<td>
<p>Integer number of Newton steps to do after running
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_eval.max">eval.max</code></td>
<td>
<p>Maximum number of evaluations of the objective function
allowed. Passed to <code>control</code> in <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed. Passed to <code>control</code> in
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_getsd">getsd</code></td>
<td>
<p>Boolean indicating whether to call <code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code></p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_silent">silent</code></td>
<td>
<p>Disable terminal output for inner optimizer?</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_trace">trace</code></td>
<td>
<p>Parameter values are printed every <code>trace</code> iteration
for the outer optimizer. Passed to
<code>control</code> in <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_verbose">verbose</code></td>
<td>
<p>Output additional messages about model steps during fitting?</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_profile">profile</code></td>
<td>
<p>Parameters to profile out of the likelihood (this subset will be appended to <code>random</code> with Laplace approximation disabled).</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_tmb_par">tmb_par</code></td>
<td>
<p>list of parameters for starting values, with shape identical
to <code>tinyVAST(...)$internal$parlist</code></p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_tmb_map">tmb_map</code></td>
<td>
<p>input passed to <a href="TMB.html#topic+MakeADFun">TMB::MakeADFun</a> as argument <code>map</code>, over-writing
the version <code>tinyVAST(...)$tmb_inputs$tmb_map</code> and allowing detailed control
over estimated parameters (advanced feature)</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_gmrf_parameterization">gmrf_parameterization</code></td>
<td>
<p>Parameterization to use for the Gaussian Markov
random field, where the default <code>separable</code> constructs a full-rank and
separable precision matrix, and the alternative <code>projection</code> constructs
a full-rank and IID precision for variables over time, and then projects
this using the inverse-cholesky of the precision, where this projection
allows for rank-deficient covariance.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_reml">reml</code></td>
<td>
<p>Logical: use REML (restricted maximum likelihood) estimation rather than
maximum likelihood? Internally, this adds the fixed effects to the
list of random effects to integrate over.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_getjointprecision">getJointPrecision</code></td>
<td>
<p>whether to get the joint precision matrix.  Passed
to <code><a href="TMB.html#topic+sdreport">sdreport</a></code>.</p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_calculate_deviance_explained">calculate_deviance_explained</code></td>
<td>
<p>whether to calculate proportion of deviance
explained.  See <code><a href="#topic+deviance_explained">deviance_explained()</a></code></p>
</td></tr>
<tr><td><code id="tinyVASTcontrol_+3A_run_model">run_model</code></td>
<td>
<p>whether to run the model of export TMB objects prior to compilation
(useful for debugging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object (list) of class <code>tinyVASTcontrol</code>, containing either default or
updated values supplied by the user for model settings
</p>

<hr>
<h2 id='vcov.tinyVAST'>Extract Variance-Covariance Matrix</h2><span id='topic+vcov.tinyVAST'></span>

<h3>Description</h3>

<p>extract the covariance of fixed effects, or both fixed and random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tinyVAST'
vcov(object, which = c("fixed", "random", "both"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.tinyVAST_+3A_object">object</code></td>
<td>
<p>output from <code><a href="#topic+tinyVAST">tinyVAST()</a></code></p>
</td></tr>
<tr><td><code id="vcov.tinyVAST_+3A_which">which</code></td>
<td>
<p>whether to extract the covariance among fixed effects, random effects, or both</p>
</td></tr>
<tr><td><code id="vcov.tinyVAST_+3A_...">...</code></td>
<td>
<p>ignored, for method compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix containing the estimated covariances among the parameter estimates in the model.
The dimensions dependend upon the argument <code>which</code>, to determine whether fixed, random effects,
or both are outputted.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
