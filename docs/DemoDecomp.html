<!DOCTYPE html><html lang="en"><head><title>Help for package DemoDecomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DemoDecomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#horiuchi'><p>Numeric Approximation of Continuous Decomposition</p></a></li>
<li><a href='#LTabr'><p>an abridged lifetable based on M(x)</p></a></li>
<li><a href='#ltre'><p>Caswell's LTRE method of decomposition</p></a></li>
<li><a href='#Mxc1'><p>Year 2002 death rates by cause for US males in abridged age classes</p></a></li>
<li><a href='#Mxc2'><p>Year 2002 death rates by cause for England and Wales males in abridged age classes</p></a></li>
<li><a href='#Mxc2e0abr'><p>get life expectancy at birth from an (abridged)age-cause matrix</p></a></li>
<li><a href='#Mxc2e0abrvec'><p>get life expectancy at birth from the vec of an age-cause matrix</p></a></li>
<li><a href='#R0vec'><p>R0vec Calculates net reproduction, R0, according to a given set of rates Lx,fx and a fixed</p>
proportion female of births, <code>pfem</code>.</a></li>
<li><a href='#rates1'><p>Fake data generated for horiuchi example.</p></a></li>
<li><a href='#rates2'><p>Fake data generated for horiuchi example.</p></a></li>
<li><a href='#stepwise_replacement'><p>implementation of the decomposition algorithm of stepwise replacement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Decompose Demographic Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.14.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Three general demographic decomposition methods: Pseudo-continuous decomposition proposed by Horiuchi, Wilmoth, and Pletcher (2008) &lt;<a href="https://doi.org/10.1353%2Fdem.0.0033">doi:10.1353/dem.0.0033</a>&gt;, stepwise replacement decomposition proposed by Andreev, Shkolnikov and Begun (2002) &lt;<a href="https://doi.org/10.4054%2FDemRes.2002.7.14">doi:10.4054/DemRes.2002.7.14</a>&gt;, and lifetable response experiments proposed by Caswell (1989) &lt;<a href="https://doi.org/10.1016%2F0304-3800%2889%2990019-7">doi:10.1016/0304-3800(89)90019-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack, numDeriv</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/timriffe/DemoDecomp/issues">https://github.com/timriffe/DemoDecomp/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-20 08:12:48 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Riffe [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Riffe &lt;tim.riffe@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-20 09:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='horiuchi'>Numeric Approximation of Continuous Decomposition</h2><span id='topic+horiuchi'></span>

<h3>Description</h3>

<p>This is an exact R implementation of the decomposition code in Matlab offered by the authors in
the supplementary material given here: &lt;http://www.demog.berkeley.edu/~jrw/Papers/decomp.suppl.pdf&gt;. The 
difference between <code>DecompContinuous()</code> and this function is that <code>DecompContinuousOrig</code> takes 
<code>rates1</code> and <code>rates2</code> as single vectors, rather than as matrices, and output is also returned as a
vector. This difference makes the function more flexible, but may add a step when writing the function to
be decomposed. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horiuchi(func, pars1, pars2, N, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="horiuchi_+3A_func">func</code></td>
<td>
<p>A function specified by the user. This must be able to take the vectors <code>rates1</code> or 
<code>rates2</code> as its argument, and to return the value of the function, <code>y</code>, when evaluated for 
these rates. It may also have additional arguments, not to be decomposed.</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_pars1">pars1</code></td>
<td>
<p>vector of covariates to be passed on as arguments to <code>func()</code>. Covariates
can be in any order, as long as <code>func()</code> knows what to do with them. <code>pars1</code> is for time 1 
(or population 1).</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_pars2">pars2</code></td>
<td>
<p>is the same as <code>pars2</code> but for time/population 2.</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_n">N</code></td>
<td>
<p>The number of intervals to integrate over.</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_...">...</code></td>
<td>
<p>optional parameters to pass on to <code>func()</code>. These are not decomposed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decomposition works by assuming a linear change in all parameters between <code>pars1</code> and <code>pars2</code>. At each small step approaching time 2 (the size of which is <code>1/N</code>) each parameter is moved forward along its linear trajectory. One at a time, each covariate (of which there are ages*variables of) is switched out twice, once for its value at 1/(2N) forward and once for its value at 1/(2N) backward in time. The difference between <code>func()</code> evaluated with these two rate matrices is the change in <code>y</code>attributable to that particular covariate and that particular time step. Summing over all N time steps, we get the contribution to the difference of each covariate, <code>effectmat</code>. The sum of <code>effectmat</code> should come very close to <code>func(rates2)-func(rates1)</code>. The error decreases with larger <code>N</code>, but there is not much point in having an <code>N</code> higher than 100, and 20 is usually sufficient. This ought to be able to handle a very wide variety of functions. 
</p>
<p>If <code>pars1</code> are observations from 2005 and <code>pars2</code> are observations from 2006 an <code>N</code> of 20 would imply a delta of 1/20 of a year for each integration step. Higher <code>N</code> provides finer results (a lower total residual), but takes longer to compute. In general, there are decreasing returns to higher <code>N</code>. <code>sum(effectmat)</code> ought to approximate <code>func(rates2)-func(rates1)</code>.
</p>


<h3>Value</h3>

<p>returns <code>effectmat</code>, a matrix of the variable effects that is organized in the same way as <code>pars1</code> and <code>pars2</code>.
</p>


<h3>References</h3>

<p>Andreev EM, Shkolnikov VM, Begun AZ (2002).
&ldquo;Algorithm for decomposition of differences between aggregate demographic measures and its application to life expectancies, healthy life expectancies, parity-progression ratios and total fertility rates.&rdquo;
<em>Demographic Research</em>, <b>7</b>, 499&ndash;522.
Andreev EM, Shkolnikov VM, Begun AZ (2002).
&ldquo;Algorithm for decomposition of differences between aggregate demographic measures and its application to life expectancies, healthy life expectancies, parity-progression ratios and total fertility rates.&rdquo;
<em>Demographic Research</em>, <b>7</b>, 499&ndash;522.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rates1)
data(rates2)

# we need rates1 and rates2 as vectors
rates1 &lt;- c(rates1)
rates2 &lt;- c(rates2)
# look at the function:
R0vec
# 2 things to point out:
# 1) it has an argument pfem, proportion female of births (1/(1+SRB)), 
#    that must be specified, but that we don't care about decomposing
# 2) x is a single vector. The the inside of the function needs to 
#    either refer to parts of it by indexing, as done here, or else 
#    re-assign x to various objects. In this case x[1:l] is Lx and 
#    x[(l+1):(2*l)] is Fx...
A &lt;- horiuchi(func = R0vec,
              pars1 = rates1,
              pars2 = rates2,
              N = 10,
              pfem = .4886)
# the output, A, is also a single vector. Each element corresponds 
# to the effect of changes in that particular covariate toward the 
# overall change in the function value. sum(A) should be close to
# original difference
(check1 &lt;- R0vec(rates2) - R0vec(rates1)) 
(check2 &lt;- sum(A))



# This package does not supply default plotting functions, but one 
# strategy might be the following:

# reorder A into a matrix (sideways):
A &lt;- t(matrix(A,ncol=2))
# call barplot() twice, once for positive values and again for
# negative values
Apos &lt;- A * .5 * (sign(A) + 1)      
Aneg &lt;- A * .5 * abs(sign(A) - 1)   
## Not run: 
barplot(Apos, 
        width = rep(1, length(A) / 2),
        space = 0, 
        ylim = range(A), 
        main = "A fake decomposition of R0",
        col=c("yellow","green"),
        axisnames = FALSE,
        xlim=c(0, 90), 
        ylab = "contrib to change in R0",
        cex.axis = .7)
barplot(Aneg, 
        width = rep(1, length(A) / 2),
        add = TRUE, 
        space = 0,
        col = c("yellow", "green"),
        axes = FALSE, axisnames = FALSE)
segments(seq(from=0,to=90,by=10),0,seq(from=0,to=90,by=10),-.027,lty=2,col="grey")
text(seq(from=0,to=90,by=10),-.027,seq(from=0,to=90,by=10),pos=1,xpd=T)
legend("bottomright",fill=c("yellow","green"),legend=c("contrib from change in Lx",
"contrib from change in Fx"),title="age specific contrib of changes in Fx and Lx",bg="white") 

## End(Not run)

</code></pre>

<hr>
<h2 id='LTabr'>an abridged lifetable based on M(x)</h2><span id='topic+LTabr'></span>

<h3>Description</h3>

<p>Implements the abridged lifetable formulas given in the supplementary material to Andreev et. al. (2012). An entire lifetable is calculated, but only life expectancy at birth is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LTabr(Mx, Age = c(0, 1, cumsum(rep(5, length(Mx) - 2))), radix = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LTabr_+3A_mx">Mx</code></td>
<td>
<p>numeric vector of abridged mortality rates.</p>
</td></tr>
<tr><td><code id="LTabr_+3A_age">Age</code></td>
<td>
<p>integer, abridged age lower bounds.</p>
</td></tr>
<tr><td><code id="LTabr_+3A_radix">radix</code></td>
<td>
<p>numeric. Can be anything positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chiang's a(x) is assumed in the following way: <code class="reqn">a(0) = 0.07 + 1.7 * M(0)</code>, <code class="reqn">a(1) = 1.6</code>, <code class="reqn">a(\omega) = \frac{1}{M(\omega)}</code>, and all others are assumed at mid interval. The last age is assumed open. Everything else is pretty standard.
</p>


<h3>Value</h3>

<p>numeric life expectancy at birth
</p>


<h3>References</h3>

<p>Andreev EM, Shkolnikov VM, Begun AZ (2002).
&ldquo;Algorithm for decomposition of differences between aggregate demographic measures and its application to life expectancies, healthy life expectancies, parity-progression ratios and total fertility rates.&rdquo;
<em>Demographic Research</em>, <b>7</b>, 499&ndash;522.
Andreev EM, Shkolnikov VM (2012).
&ldquo;An Excel spreadsheet for the decomposition of a difference between two values of an aggregate demographic measure by stepwise replacement running from young to old ages.&rdquo;
<em>Max Planck Institute for Demographic Research (MPIDR Technical Report TR&ndash;2012&ndash;002)</em>.
</p>

<hr>
<h2 id='ltre'>Caswell's LTRE method of decomposition</h2><span id='topic+ltre'></span>

<h3>Description</h3>

<p>Caswell's Lifetable Response Experiment (LTRE) decomposed a vector-parameterized 
function by taking derivatives of the objective function with respect to each parameter. The 
sum-product of the resulting derivative vector and the change in parameter values is a first order
approximation of the decomposition. This implementation repeats this operation <code>N</code> times as 
<code>pars1</code> warps into <code>pars2</code> over <code>N</code> steps. This allows for arbitrary precision as 
<code>N</code> increases, as in the case of the Horiuchi approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltre(func, pars1, pars2, dfunc, N = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ltre_+3A_func">func</code></td>
<td>
<p>A function specified by the user. This must be able to take the vectors <code>rates1</code> or 
<code>rates2</code> as its argument, and to return the value of the function, <code>y</code>, when evaluated for 
these rates. It may also have additional arguments, not to be decomposed.</p>
</td></tr>
<tr><td><code id="ltre_+3A_pars1">pars1</code></td>
<td>
<p>vector of covariates to be passed on as arguments to <code>func()</code>. Covariates
can be in any order, as long as <code>func()</code> knows what to do with them. <code>pars1</code> is for time 1 
(or population 1).</p>
</td></tr>
<tr><td><code id="ltre_+3A_pars2">pars2</code></td>
<td>
<p>is the same as <code>pars2</code> but for time/population 2.</p>
</td></tr>
<tr><td><code id="ltre_+3A_dfunc">dfunc</code></td>
<td>
<p>a derivative function, see details</p>
</td></tr>
<tr><td><code id="ltre_+3A_n">N</code></td>
<td>
<p>The number of intervals to integrate over.</p>
</td></tr>
<tr><td><code id="ltre_+3A_...">...</code></td>
<td>
<p>... optional parameters to pass on to <code>func()</code>. These are not decomposed. Also one can use this argument to pass optional arguments to <code>numDeriv::grad()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The case of <code>N=1</code> differentiates with respect to the arithmetic mean of <code>pars1</code> and <code>pars2</code>. The <code>...</code> argument can be used to send extra parameters to <code>func()</code> that do not get decomposed, or to specify other optional arguments to <code>numDeriv::grad()</code> for finer control. 
</p>
<p>The argument <code>dfunc</code> is optional. If given, it should be a function written to have a first argument <code>func</code>, a second argument <code>x</code>, which consists in the vector of decomposed parameters (same layout at <code>pars1</code> and <code>pars2</code>), and an option <code>...</code> argument for undecomposed parameters. Presumably if a derivative function is given then it is analytic or somehow a more parsimonious calculation than numeric derivatives. If left unspecified <code>numDeriv::grad()</code> is used.
</p>
<p>As with <code>horiuchi()</code>, the path from <code>pars1</code> to <code>pars2</code> is linear, but other paths can be induced by parameterizing <code>func()</code> differently. For example, if you want proportional change from <code>pars1</code> to <code>pars2</code> then log them, and write <code>func()</code> to first antilog before continuing. This is not zero-friendly, but in practice power transforms give close results, so you could <code>sqrt()</code> and then square inside <code>func()</code>. If you do this, then <code>dfunc()</code> must be written to account for it too, or you could stick with the default numeric gradient function.
</p>


<h3>References</h3>

<p>Caswell H (1989).
&ldquo;Analysis of life table response experiments I. Decomposition of effects on population growth rate.&rdquo;
<em>Ecological Modelling</em>, <b>46</b>(3-4), 221&ndash;237.
Caswell H (2006).
&ldquo;Matrix population models.&rdquo;
<em>Encyclopedia of Environmetrics</em>, <b>3</b>.
</p>


<h3>See Also</h3>

<p><code><a href="numDeriv.html#topic+grad">grad</a></code>
</p>

<hr>
<h2 id='Mxc1'>Year 2002 death rates by cause for US males in abridged age classes</h2><span id='topic+Mxc1'></span>

<h3>Description</h3>

<p>A matrix containing death rates for six causes (one of which is other) for abridged age classes 0-85. Ages are labelled in rows, and causes in column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc1
</code></pre>


<h3>Format</h3>

<p>A matrix with 19 rows and 6 columns
</p>


<h3>Source</h3>

<p><a href="https://www.demogr.mpg.de/papers/technicalreports/tr-2010-002-files.zip">https://www.demogr.mpg.de/papers/technicalreports/tr-2010-002-files.zip</a>
</p>

<hr>
<h2 id='Mxc2'>Year 2002 death rates by cause for England and Wales males in abridged age classes</h2><span id='topic+Mxc2'></span>

<h3>Description</h3>

<p>A matrix containing death rates for six causes (one of which is other) for abrdged age classes 0-85. Ages are labelled in rows, and causes in column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc2
</code></pre>


<h3>Format</h3>

<p>A matrix with 19 rows and 6 columns
</p>


<h3>Source</h3>

<p><a href="https://www.demogr.mpg.de/papers/technicalreports/tr-2010-002-files.zip">https://www.demogr.mpg.de/papers/technicalreports/tr-2010-002-files.zip</a>
</p>

<hr>
<h2 id='Mxc2e0abr'>get life expectancy at birth from an (abridged)age-cause matrix</h2><span id='topic+Mxc2e0abr'></span>

<h3>Description</h3>

<p>Given a matrix with abridged ages in rows and causes of death in columns, then calculate life expectancy at birth using <code>LTabr()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc2e0abr(Mxc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mxc2e0abr_+3A_mxc">Mxc</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This assumes that the marginal row sums give all-cause mortality rates. Give an other category if you need to top-up to all-cause mortality. Do not include all-cause mortality itself!
</p>


<h3>Value</h3>

<p>numeric life expectancy at birth
</p>

<hr>
<h2 id='Mxc2e0abrvec'>get life expectancy at birth from the vec of an age-cause matrix</h2><span id='topic+Mxc2e0abrvec'></span>

<h3>Description</h3>

<p>Given a vector with abridged ages stacked within causes of death, assign its dimensions, take the age marginal sums using <code>Mxc2e0abr</code>, then calculate life expectancy at birth using <code>LTabr()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc2e0abrvec(Mxcvec, dims, trans = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mxc2e0abrvec_+3A_mxcvec">Mxcvec</code></td>
<td>
<p>numeric vector, <code>c(Mxc)</code>.</p>
</td></tr>
<tr><td><code id="Mxc2e0abrvec_+3A_dims">dims</code></td>
<td>
<p>integer vector of length two, <code>c(nrow(Mxc),ncol(Mxc))</code>.</p>
</td></tr>
<tr><td><code id="Mxc2e0abrvec_+3A_trans">trans</code></td>
<td>
<p>do we need to transpose in order to arrive back to an age-cause matrix?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This assumes that the marginal row sums give all-cause mortality rates. Give an other category if you need to top-up to all-cause mortality. Do not include all-cause mortality itself! <code>length(Mxcvec)</code> must equal <code>prod(dim(Mxc))</code>. This function is meant to be fed to a generic decomposition function, such as <code>stepwise_replacement()</code>, or <code>DecompContinuousOrig()</code>.
</p>


<h3>Value</h3>

<p>numeric life expectancy at birth
</p>

<hr>
<h2 id='R0vec'>R0vec Calculates net reproduction, R0, according to a given set of rates Lx,fx and a fixed
proportion female of births, <code>pfem</code>.</h2><span id='topic+R0vec'></span>

<h3>Description</h3>

<p>This function is only provided for the examples of <code>horiuchi()</code>. 
It calculates the sum of the row products of <code>rates</code> multiplied by <code>pfem</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R0vec(x, pfem = 0.4886)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R0vec_+3A_x">x</code></td>
<td>
<p>a single vector containing Lx followed by Fx or vice versa.  Here, <code>Lx</code> is the survival 
function integrated within each age interval and with a lifetable radix of 1. <code>Fx</code> is the 
fertility function, calculated as births/ person years of exposure. <code>Fx</code> should simply contain 
zeros in ages with no fertility, OR, all vectors should be limited to reproductive ages. Both 
<code>Lx</code> and <code>Fx</code> should for this function be of the same length.</p>
</td></tr>
<tr><td><code id="R0vec_+3A_pfem">pfem</code></td>
<td>
<p>the proportion female of births. Something like .49, .48, or (1/(2.05)). This can either be specified as a single number, or it may be allowed to vary by age. For the later case, be sure to specify a value for each age (<code>length(x)/2</code> values). Default .4886.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main feature that functions need to have when specified for <code>horiuchi()</code> or <code>stepwise\_replacement()</code> is that the rates must all go into a (potentially long) vector, probably consisting in your rate vectors one after the other. Really the decomposition function does not care how things are arranged in the vector- the components of change vector that is returned from <code>horiuchi()</code> will be  arranged in exactly the same way as its input rate vectors, so as long as you know how to sort it out, and your function can extract what it needs from the vectors, then it can be specified in any way. For this particular example function, <code>R0vec()</code>, <code>x</code> must be specified with either Lx followed by Fx or vice versa. It would also be possible to redefine the function to place <code>pfem</code> in with the rates vector, <code>x</code>, which would allow this item to be decomposed too. Here it is specified separately in order to demonstrate passing on parameters to the function within <code>horiuchi()</code>.
</p>


<h3>Value</h3>

<p>the value of R0 for the given set of rates and proportion female of births.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rates1)
# take vec:
x &lt;- c(rates1)
R0vec(x)
</code></pre>

<hr>
<h2 id='rates1'>Fake data generated for horiuchi example.</h2><span id='topic+rates1'></span>

<h3>Description</h3>

<p>These are used to calculate the net reproductive ratio (NRR)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rates1
</code></pre>


<h3>Format</h3>

<p>numeric vector of hypothetical fertility and mortality rates
</p>

<dl>
<dt>Fx</dt><dd><p>age specific fertility rates at time point 1</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rates1)
data(rates2)
# nothing fancy
# compare Lx
plot(rates1[,1],type='l',col="blue")
lines(rates2[,1],col="green")
# compare Fx
plot(rates1[,2],type='l',col="blue")
lines(rates2[,2],col="green") 

## End(Not run)
</code></pre>

<hr>
<h2 id='rates2'>Fake data generated for horiuchi example.</h2><span id='topic+rates2'></span>

<h3>Description</h3>

<p>These are used to calculate the net reproductive ratio (NRR)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rates2
</code></pre>


<h3>Format</h3>

<p>numeric vector of hypothetical fertility and mortality rates
</p>

<dl>
<dt>Lx</dt><dd><p>a discrete survival function at time point 2</p>
</dd>
<dt>Fx</dt><dd><p>age specific fertility rates at time point 2</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rates1)
data(rates2)
# nothing fancy
# compare Lx
plot(rates1[,1],type='l',col="blue")
lines(rates2[,1],col="green")
# compare Fx
plot(rates1[,2],type='l',col="blue")
lines(rates2[,2],col="green") 

## End(Not run)
</code></pre>

<hr>
<h2 id='stepwise_replacement'>implementation of the decomposition algorithm of stepwise replacement</h2><span id='topic+stepwise_replacement'></span>

<h3>Description</h3>

<p>This implements the algorithm described in Andreev et al (2002), with defaults set
to approximate their recommendations for replacement ordering and result averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise_replacement(
  func,
  pars1,
  pars2,
  symmetrical = TRUE,
  direction = "up",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepwise_replacement_+3A_func">func</code></td>
<td>
<p>A function specified by the user. This must be able to take the vectors <code>pars1</code> or 
<code>pars2</code> as its argument, and to return the value of the function, <code>y</code>, when evaluated for 
these rates. It may also have additional arguments, not to be decomposed.</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_pars1">pars1</code></td>
<td>
<p>vector of covariates to be passed on as arguments to <code>func()</code>. Covariates
can be in any order, as long as <code>func()</code> knows what to do with them. <code>pars1</code> is for time 1 
(or population 1).</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_pars2">pars2</code></td>
<td>
<p>is the same as <code>pars1</code> but for time/population 2.</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_symmetrical">symmetrical</code></td>
<td>
<p>logical. default <code>TRUE</code> as recommended by authors. Shall we average the results of replacing 1 with 2 and 2 with 1?</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_direction">direction</code></td>
<td>
<p>character. One of <code>"up"</code>, <code>"down"</code>, or <code>"both"</code>. Default <code>"up"</code>, as recommended by authors.</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_...">...</code></td>
<td>
<p>optional parameters to pass on to <code>func()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>symmetrical</code> argument toggles whether or not we replace pars1 with pars2 (<code>FALSE</code>), 
or take the arithmetic average or replacement in both directions. <code>direction</code> refers to whether we go 
from the bottom up or top down, or take the arithmetic average of these when replacing vector elements. 
Although the total difference will always sum correctly, the calculated contribution from individual components 
can vary greatly depending on the order in general. Defaults are set to symmetrically replace from the bottom 
up, per the authors' suggestion.
</p>


<h3>Value</h3>

<p>a matrix of the variable effects that is organized in the same way as 
<code>pars1</code> and <code>pars2</code>.
</p>


<h3>References</h3>

<p>Horiuchi S, Wilmoth JR, Pletcher SD (2008).
&ldquo;A decomposition method based on a model of continuous change.&rdquo;
<em>Demography</em>, <b>45</b>(4), 785&ndash;801.
Andreev EM, Shkolnikov VM (2012).
&ldquo;An Excel spreadsheet for the decomposition of a difference between two values of an aggregate demographic measure by stepwise replacement running from young to old ages.&rdquo;
<em>Max Planck Institute for Demographic Research (MPIDR Technical Report TR&ndash;2012&ndash;002)</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mxc1)
data(Mxc2)
# we'll want to pass in these dimensions
dims  &lt;- dim(Mxc1)
# we need parameters in vec form
Mxc1v &lt;- c(Mxc1)
Mxc2v &lt;- c(Mxc2)
B     &lt;- stepwise_replacement(func = Mxc2e0abrvec, 
		pars1 = Mxc1v, pars2 = Mxc2v, dims = dims, 
		# authors' recommendations:
		symmetrical = TRUE, direction = "up")
dim(B) &lt;- dims
# the output, B, is also a single vector. Each element corresponds 
# to the effect of changes in that particular covariate toward the 
# overall change in the function value. sum(B) should equal the
# original difference
(check1 &lt;- Mxc2e0abr(Mxc2) - Mxc2e0abr(Mxc1))
(check2 &lt;- sum(B))


# This package does not supply default plotting functions, but one 
# strategy might be the following:
## Not run: 
Age &lt;- c(0, 1, seq(5, 85, by = 5))
matplot(Age, B, type = 'l', 
xlab = "Age", ylab = "Contrib to diff in e(0)", col = 1:6)
legend("bottomleft",lty=1:5,col=1:6, 
         legend = c("Neoplasms","Circulatory","Respiratory",
			     "Digestive","Acc/viol","Other"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
