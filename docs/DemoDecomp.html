<!DOCTYPE html><html><head><title>Help for package DemoDecomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DemoDecomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Compare'><p>Comparison decomposition results by age and cause</p></a></li>
<li><a href='#horiuchi'><p>Numeric Approximation of Continuous Decomposition</p></a></li>
<li><a href='#LTabr'><p>an abridged lifetable based on M(x)</p></a></li>
<li><a href='#Mxc1'><p>Year 2002 death rates by cause for US males in abridged age classes</p></a></li>
<li><a href='#Mxc2'><p>Year 2002 death rates by cause for England and Wales males in abridged age classes</p></a></li>
<li><a href='#Mxc2e0abr'><p>get life expectancy at birth from an (abridged)age-cause matrix</p></a></li>
<li><a href='#Mxc2e0abrvec'><p>get life expectancy at birth from the vec of an age-cause matrix</p></a></li>
<li><a href='#R0vec'><p>R0vec Calculates net reproduction, R0, according to a given set of rates Lx,fx and a fixed</p>
proportion female of births, <code>pfem</code>.</a></li>
<li><a href='#rates1'><p>Fake data generated for example.</p></a></li>
<li><a href='#rates2'><p>Fake data generated for example.</p></a></li>
<li><a href='#stepwise_replacement'><p>implementation of the decomposition algorithm of stepwise replacement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Decompose Demographic Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Riffe</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Riffe &lt;tim.riffe@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Two general demographic decomposition methods are offered: Pseudo-continuous decomposition proposed by Horiuchi, Wilmoth, and Pletcher (2008) &lt;<a href="https://doi.org/10.1353%2Fdem.0.0033">doi:10.1353/dem.0.0033</a>&gt; and stepwise replacement decomposition proposed by Andreev, Shkolnikov and Begun (2002) &lt;<a href="https://doi.org/10.4054%2FDemRes.2002.7.14">doi:10.4054/DemRes.2002.7.14</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/timriffe/DemoDecomp/issues">https://github.com/timriffe/DemoDecomp/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-13 09:19:15 UTC; tim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-14 09:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='Compare'>Comparison decomposition results by age and cause</h2><span id='topic+Compare'></span>

<h3>Description</h3>

<p>A matrix containing the contributions to the difference in life expectancy at birth between 2002 US males and England and Wales males. Ages (in rows) are in abridged categories, 0-85, and there are six causes, including other, in columns. The sum of the matrix is the difference in life expectancy at birth between the two populations. Values are based on symmetrical stepwise replacement from young to old ages only. This is just to make sure implementation is close.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Compare
</code></pre>


<h3>Format</h3>

<p>A matrix with 19 rows and 6 columns</p>


<h3>Source</h3>

<p><a href="https://www.demogr.mpg.de/en/projects_publications/publications_1904/mpidr_technical_reports/an_excel_spreadsheet_for_the_decomposition_of_a_difference_between_two_values_of_an_aggregate_4591.htm">https://www.demogr.mpg.de/en/projects_publications/publications_1904/mpidr_technical_reports/an_excel_spreadsheet_for_the_decomposition_of_a_difference_between_two_values_of_an_aggregate_4591.htm</a>
</p>

<hr>
<h2 id='horiuchi'>Numeric Approximation of Continuous Decomposition</h2><span id='topic+horiuchi'></span>

<h3>Description</h3>

<p>This is an exact R implementation of the decomposition code in Matlab offered by the authors in
the supplementary material given here: &lt;http://www.demog.berkeley.edu/~jrw/Papers/decomp.suppl.pdf&gt;. The 
difference between <code>DecompContinuous()</code> and this function is that <code>DecompContinuousOrig</code> takes 
<code>rates1</code> and <code>rates2</code> as single vectors, rather than as matrices, and output is also returned as a
vector. This difference makes the function more flexible, but may add a step when writing the function to
be decomposed. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horiuchi(func, pars1, pars2, N, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horiuchi_+3A_func">func</code></td>
<td>
<p>A function specified by the user. This must be able to take the vectors <code>rates1</code> or 
<code>rates2</code> as its argument, and to return the value of the function, <code>y</code>, when evaluated for 
these rates. It may also have additional arguments, not to be decomposed.</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_pars1">pars1</code></td>
<td>
<p>vector of covariates to be passed on as arguments to <code>func()</code>. Covariates
can be in any order, as long as <code>func()</code> knows what to do with them. <code>pars1</code> is for time 1 
(or population 1).</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_pars2">pars2</code></td>
<td>
<p>is the same as <code>pars2</code> but for time/population 2.</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_n">N</code></td>
<td>
<p>The number of intervals to integrate over.</p>
</td></tr>
<tr><td><code id="horiuchi_+3A_...">...</code></td>
<td>
<p>optional parameters to pass on to <code>func()</code>. These are not decomposed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decomposition works by assuming a linear change in all covariates between time 1 and time 2 (or population 1 and population 2). At each small time step approaching time 2 (the size of which is the inverse of <code>N</code>) each covariate is moved forward along its linear trajectory. One at a time, each covariate (of which there are ages*variables of) is switched out twice, once for its value at 1/(2N) forward and once for its value at 1/(2N) backward in time. The difference between <code>func()</code> evaluated with these two rate matrices is the change in <code>y</code>attributable to that particular covariate and that particular time step. Summing over all N time steps, we get the contribution to the difference of each covariate, <code>effectmat</code>. The sum of <code>effectmat</code> should come very close to <code>func(rates2)-func(rates1)</code>. The error decreases with larger <code>N</code>, but there is not much point in having an <code>N</code> higher than 100, and 20 is usually sufficient. This ought to be able to handle a very wide variety of functions. 
</p>
<p>If <code>pars1</code> are observations from 2005 and <code>pars2</code> are observations from 2006 an <code>N</code> of 20 would imply a delta of 1/20 of a year for each integration step. Higher <code>N</code> provides finer results (a lower total residual), but takes longer to compute. In general, there are decreasing returns to higher <code>N</code>. <code>sum(effectmat)</code> ought to approximate <code>func(rates2)-func(rates1)</code>.
</p>


<h3>Value</h3>

<p>returns <code>effectmat</code>, a matrix of the variable effects that is organized in the same way as <code>pars1</code> and <code>pars2</code>.
</p>


<h3>References</h3>

<p>Andreev EM, Shkolnikov VM and Begun AZ (2002).
&ldquo;Algorithm for decomposition of differences between aggregate demographic measures and its application to life expectancies, healthy life expectancies, parity-progression ratios and total fertility rates.&rdquo;
<em>Demographic Research</em>, <b>7</b>, pp. 499&ndash;522.
Andreev EM, Shkolnikov VM and Begun AZ (2002).
&ldquo;Algorithm for decomposition of differences between aggregate demographic measures and its application to life expectancies, healthy life expectancies, parity-progression ratios and total fertility rates.&rdquo;
<em>Demographic Research</em>, <b>7</b>, pp. 499&ndash;522.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rates1)
data(rates2)

# we need rates1 and rates2 as vectors
rates1 &lt;- c(rates1)
rates2 &lt;- c(rates2)
# look at the function:
R0vec
# 2 things to point out:
# 1) it has an argument pfem, proportion female of births (1/(1+SRB)), 
#    that must be specified, but that we don't care about decomposing
# 2) x is a single vector. The the inside of the function needs to 
#    either refer to parts of it by indexing, as done here, or else 
#    re-assign x to various objects. In this case x[1:l] is Lx and 
#    x[(l+1):(2*l)] is Fx...
A &lt;- horiuchi(func = R0vec,
              pars1 = rates1,
              pars2 = rates2,
              N = 10,
              pfem = .4886)
# the output, A, is also a single vector. Each element corresponds 
# to the effect of changes in that particular covariate toward the 
# overall change in the function value. sum(A) should be close to
# original difference
(check1 &lt;- R0vec(rates2) - R0vec(rates1)) 
(check2 &lt;- sum(A))



# This package does not supply default plotting functions, but one 
# strategy might be the following:

# reorder A into a matrix (sideways):
A &lt;- t(matrix(A,ncol=2))
# call barplot() twice, once for positive values and again for
# negative values
Apos &lt;- A * .5 * (sign(A) + 1)      
Aneg &lt;- A * .5 * abs(sign(A) - 1)   
## Not run: 
barplot(Apos, 
        width = rep(1, length(A) / 2),
        space = 0, 
        ylim = range(A), 
        main = "A fake decomposition of R0",
        col=c("yellow","green"),
        axisnames = FALSE,
        xlim=c(0, 90), 
        ylab = "contrib to change in R0",
        cex.axis = .7)
barplot(Aneg, 
        width = rep(1, length(A) / 2),
        add = TRUE, 
        space = 0,
        col = c("yellow", "green"),
        axes = FALSE, axisnames = FALSE)
segments(seq(from=0,to=90,by=10),0,seq(from=0,to=90,by=10),-.027,lty=2,col="grey")
text(seq(from=0,to=90,by=10),-.027,seq(from=0,to=90,by=10),pos=1,xpd=T)
legend("bottomright",fill=c("yellow","green"),legend=c("contrib from change in Lx",
"contrib from change in Fx"),title="age specific contrib of changes in Fx and Lx",bg="white") 

## End(Not run)

</code></pre>

<hr>
<h2 id='LTabr'>an abridged lifetable based on M(x)</h2><span id='topic+LTabr'></span>

<h3>Description</h3>

<p>Implements the abridged lifetable formulas given in the supplementary material to Andreev et. al. (2012). An entire lifetable is calculated, but only life expectancy at birth is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LTabr(Mx, Age = c(0, 1, cumsum(rep(5, length(Mx) - 2))), radix = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LTabr_+3A_mx">Mx</code></td>
<td>
<p>numeric vector of abridged mortality rates.</p>
</td></tr>
<tr><td><code id="LTabr_+3A_age">Age</code></td>
<td>
<p>integer, abridged age lower bounds.</p>
</td></tr>
<tr><td><code id="LTabr_+3A_radix">radix</code></td>
<td>
<p>numeric. Can be anything positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chiang's a(x) is assumed in the following way: <code class="reqn">a(0) = 0.07 + 1.7 * M(0)</code>, <code class="reqn">a(1) = 1.6</code>, <code class="reqn">a(\omega) = \frac{1}{M(\omega)}</code>, and all others are assumed at mid interval. The last age is assumed open. Everything else is pretty standard.
</p>


<h3>Value</h3>

<p>numeric life expectancy at birth
</p>


<h3>References</h3>

<p>Andreev EM, Shkolnikov VM and Begun AZ (2002).
&ldquo;Algorithm for decomposition of differences between aggregate demographic measures and its application to life expectancies, healthy life expectancies, parity-progression ratios and total fertility rates.&rdquo;
<em>Demographic Research</em>, <b>7</b>, pp. 499&ndash;522.
Andreev EM and Shkolnikov VM (2012).
&ldquo;An Excel spreadsheet for the decomposition of a difference between two values of an aggregate demographic measure by stepwise replacement running from young to old ages.&rdquo;
<em>Max Planck Institute for Demographic Research (MPIDR Technical Report TR&ndash;2012&ndash;002)</em>.
</p>

<hr>
<h2 id='Mxc1'>Year 2002 death rates by cause for US males in abridged age classes</h2><span id='topic+Mxc1'></span>

<h3>Description</h3>

<p>A matrix containing death rates for six causes (one of which is other) for abrdged age classes 0-85. Ages are labelled in rows, and causes in column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc1
</code></pre>


<h3>Format</h3>

<p>A matrix with 19 rows and 6 columns</p>


<h3>Source</h3>

<p><a href="https://www.demogr.mpg.de/en/projects_publications/publications_1904/mpidr_technical_reports/an_excel_spreadsheet_for_the_decomposition_of_a_difference_between_two_values_of_an_aggregate_4591.htm">https://www.demogr.mpg.de/en/projects_publications/publications_1904/mpidr_technical_reports/an_excel_spreadsheet_for_the_decomposition_of_a_difference_between_two_values_of_an_aggregate_4591.htm</a>
</p>

<hr>
<h2 id='Mxc2'>Year 2002 death rates by cause for England and Wales males in abridged age classes</h2><span id='topic+Mxc2'></span>

<h3>Description</h3>

<p>A matrix containing death rates for six causes (one of which is other) for abrdged age classes 0-85. Ages are labelled in rows, and causes in column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc2
</code></pre>


<h3>Format</h3>

<p>A matrix with 19 rows and 6 columns</p>


<h3>Source</h3>

<p><a href="https://www.demogr.mpg.de/en/projects_publications/publications_1904/mpidr_technical_reports/an_excel_spreadsheet_for_the_decomposition_of_a_difference_between_two_values_of_an_aggregate_4591.htm">https://www.demogr.mpg.de/en/projects_publications/publications_1904/mpidr_technical_reports/an_excel_spreadsheet_for_the_decomposition_of_a_difference_between_two_values_of_an_aggregate_4591.htm</a>
</p>

<hr>
<h2 id='Mxc2e0abr'>get life expectancy at birth from an (abridged)age-cause matrix</h2><span id='topic+Mxc2e0abr'></span>

<h3>Description</h3>

<p>Given a matrix with abridged ages in rows and causes of death in columns, then calculate life expectancy at birth using <code>LTabr()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc2e0abr(Mxc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mxc2e0abr_+3A_mxc">Mxc</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This assumes that the marginal row sums give all-cause mortality rates. Give an other category if you need to top-up to all-cause mortality. Do not include all-cause mortality itself!
</p>


<h3>Value</h3>

<p>numeric life expectancy at birth
</p>

<hr>
<h2 id='Mxc2e0abrvec'>get life expectancy at birth from the vec of an age-cause matrix</h2><span id='topic+Mxc2e0abrvec'></span>

<h3>Description</h3>

<p>Given a vector with abridged ages stacked within causes of death, assign its dimensions, take the age marginal sums using <code>Mxc2e0abr</code>, then calculate life expectancy at birth using <code>LTabr()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxc2e0abrvec(Mxcvec, dims, trans = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mxc2e0abrvec_+3A_mxcvec">Mxcvec</code></td>
<td>
<p>numeric vector, <code>c(Mxc)</code>.</p>
</td></tr>
<tr><td><code id="Mxc2e0abrvec_+3A_dims">dims</code></td>
<td>
<p>integer vector of length two, <code>c(nrow(Mxc),ncol(Mxc))</code>.</p>
</td></tr>
<tr><td><code id="Mxc2e0abrvec_+3A_trans">trans</code></td>
<td>
<p>do we need to transpose in order to arrive back to an age-cause matrix?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This assumes that the marginal row sums give all-cause mortality rates. Give an other category if you need to top-up to all-cause mortality. Do not include all-cause mortality itself! <code>length(Mxcvec)</code> must equal <code>prod(dim(Mxc))</code>. This function is meant to be fed to a generic decomposition function, such as <code>stepwise_replacement()</code>, or <code>DecompContinuousOrig()</code>.
</p>


<h3>Value</h3>

<p>numeric life expectancy at birth
</p>

<hr>
<h2 id='R0vec'>R0vec Calculates net reproduction, R0, according to a given set of rates Lx,fx and a fixed
proportion female of births, <code>pfem</code>.</h2><span id='topic+R0vec'></span>

<h3>Description</h3>

<p>This function is only provided for the examples of <code>horiuchi()</code>. 
It calculates the sum of the row products of <code>rates</code> multiplied by <code>pfem</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R0vec(x, pfem = 0.4886)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R0vec_+3A_x">x</code></td>
<td>
<p>a single vector containing Lx followed by Fx or vice versa.  Here, <code>Lx</code> is the survival 
function integrated within each age interval and with a lifetable radix of 1. <code>Fx</code> is the 
fertility function, calculated as births/ person years of exposure. <code>Fx</code> should simply contain 
zeros in ages with no fertility, OR, all vectors should be limited to reproductive ages. Both 
<code>Lx</code> and <code>Fx</code> should for this function be of the same length.</p>
</td></tr>
<tr><td><code id="R0vec_+3A_pfem">pfem</code></td>
<td>
<p>the proportion female of births. Something like .49, .48, or (1/(2.05)). This can either be specified as a single number, or it may be allowed to vary by age. For the later case, be sure to specify a value for each age (<code>length(x)/2</code> values). Default .4886.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main feature that functions need to have when specified for <code>horiuchi()</code> or <code>stepwise\_replacement()</code> is that the rates must all go into a (potentially long) vector, probably consisting in your rate vectors one after the other. Really the decomposition function does not care how things are arranged in the vector- the components of change vector that is returned from <code>horiuchi()</code> will be  arranged in exactly the same way as its input rate vectors, so as long as you know how to sort it out, and your function can extract what it needs from the vectors, then it can be specified in any way. For this particular example function, <code>R0vec()</code>, <code>x</code> must be specified with either Lx followed by Fx or vice versa. It would also be possible to redefine the function to place <code>pfem</code> in with the rates vector, <code>x</code>, which would allow this item to be decomposed too. Here it is specified separately in order to demonstrate passing on parameters to the function within <code>horiuchi()</code>.
</p>


<h3>Value</h3>

<p>the value of R0 for the given set of rates and proportion female of births.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rates1)
# take vec:
x &lt;- c(rates1)
R0vec(x)
</code></pre>

<hr>
<h2 id='rates1'>Fake data generated for example.</h2><span id='topic+rates1'></span>

<h3>Description</h3>

<p>The first column <code>Lx</code> is a discrete survival function for time point 1. The second column <code>Fx</code> are age specific fertility rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rates1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> with 101 rows and 2 columns.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rates1)
data(rates2)
# nothing fancy
# compare Lx
plot(rates1[,1],type='l',col="blue")
lines(rates2[,1],col="green")
# compare Fx
plot(rates1[,2],type='l',col="blue")
lines(rates2[,2],col="green") 

## End(Not run)

</code></pre>

<hr>
<h2 id='rates2'>Fake data generated for example.</h2><span id='topic+rates2'></span>

<h3>Description</h3>

<p>The first column <code>Lx</code> is a discrete survival function for time point 2. The second column <code>Fx</code> are age specific fertility rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rates2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> with 101 rows and 2 columns.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rates1)
data(rates2)
# nothing fancy
# compare Lx
plot(rates1[,1],type='l',col="blue")
lines(rates2[,1],col="green")
# compare Fx
plot(rates1[,2],type='l',col="blue")
lines(rates2[,2],col="green") 

## End(Not run)

</code></pre>

<hr>
<h2 id='stepwise_replacement'>implementation of the decomposition algorithm of stepwise replacement</h2><span id='topic+stepwise_replacement'></span>

<h3>Description</h3>

<p>This implements the algorithm described in Andreev et al (2002), with defaults set
to approximate their recommendations for replacement ordering and result averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise_replacement(func, pars1, pars2, symmetrical = TRUE,
  direction = "up", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise_replacement_+3A_func">func</code></td>
<td>
<p>A function specified by the user. This must be able to take the vectors <code>pars1</code> or 
<code>pars2</code> as its argument, and to return the value of the function, <code>y</code>, when evaluated for 
these rates. It may also have additional arguments, not to be decomposed.</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_pars1">pars1</code></td>
<td>
<p>vector of covariates to be passed on as arguments to <code>func()</code>. Covariates
can be in any order, as long as <code>func()</code> knows what to do with them. <code>pars1</code> is for time 1 
(or population 1).</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_pars2">pars2</code></td>
<td>
<p>is the same as <code>pars1</code> but for time/population 2.</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_symmetrical">symmetrical</code></td>
<td>
<p>logical. default <code>TRUE</code> as recommended by authors. Shall we average the results of replacing 1 with 2 and 2 with 1?</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_direction">direction</code></td>
<td>
<p>character. One of <code>"up"</code>, <code>"down"</code>, or <code>"both"</code>. Default <code>"up"</code>, as recommended by authors.</p>
</td></tr>
<tr><td><code id="stepwise_replacement_+3A_...">...</code></td>
<td>
<p>optional parameters to pass on to <code>func()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>symmetrical</code> argument toggles whether or not we replace pars1 with pars2 (<code>FALSE</code>), 
or take the arithmetic average or replacement in both directions. <code>direction</code> refers to whether we go 
from the bottom up or top down, or take the arithmetic average of these when replacing vector elements. 
Although the total difference will always sum correctly, the calculated contribution from individual components 
can vary greatly depending on the order in general. Defaults are set to symmetrically replace from the bottom 
up, per the authors' suggestion.
</p>


<h3>Value</h3>

<p>a matrix of the variable effects that is organized in the same way as 
<code>pars1</code> and <code>pars2</code>.
</p>


<h3>References</h3>

<p>Horiuchi S, Wilmoth JR and Pletcher SD (2008).
&ldquo;A decomposition method based on a model of continuous change.&rdquo;
<em>Demography</em>, <b>45</b>(4), pp. 785&ndash;801.
Andreev EM and Shkolnikov VM (2012).
&ldquo;An Excel spreadsheet for the decomposition of a difference between two values of an aggregate demographic measure by stepwise replacement running from young to old ages.&rdquo;
<em>Max Planck Institute for Demographic Research (MPIDR Technical Report TR&ndash;2012&ndash;002)</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mxc1)
data(Mxc2)
# we'll want to pass in these dimensions
dims  &lt;- dim(Mxc1)
# we need parameters in vec form
Mxc1v &lt;- c(Mxc1)
Mxc2v &lt;- c(Mxc2)
B     &lt;- stepwise_replacement(func = Mxc2e0abrvec, 
		pars1 = Mxc1v, pars2 = Mxc2v, dims = dims, 
		# authors' recommendations:
		symmetrical = TRUE, direction = "up")
dim(B) &lt;- dims
# the output, B, is also a single vector. Each element corresponds 
# to the effect of changes in that particular covariate toward the 
# overall change in the function value. sum(B) should equal the
# original difference
(check1 &lt;- Mxc2e0abr(Mxc2) - Mxc2e0abr(Mxc1))
(check2 &lt;- sum(B))


# This package does not supply default plotting functions, but one 
# strategy might be the following:
## Not run: 
Age &lt;- c(0, 1, seq(5, 85, by = 5))
matplot(Age, B, type = 'l', 
xlab = "Age", ylab = "Contrib to diff in e(0)", col = 1:6)
legend("bottomleft",lty=1:5,col=1:6, 
         legend = c("Neoplasms","Circulatory","Respiratory",
			     "Digestive","Acc/viol","Other"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
