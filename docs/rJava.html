<!DOCTYPE html><html><head><title>Help for package rJava</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rJava}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.jgc'>
<p>Invoke Java Garbage Collection</p></a></li>
<li><a href='#.jinstanceof'>
<p>Is a java object an instance of a given java class</p></a></li>
<li><a href='#aslist'>
<p>Converts java objects or arrays to R lists</p></a></li>
<li><a href='#clone'>
<p>Object cloner</p></a></li>
<li><a href='#Exceptions'><p>Exception handling</p></a></li>
<li><a href='#J'>
<p>High level API for accessing Java</p></a></li>
<li><a href='#jarray'>
<p>Java array handling functions</p></a></li>
<li><a href='#jarrayRef-class'><p>Class &quot;jarrayRef&quot; Reference to an array Java object</p></a></li>
<li><a href='#java-tools'><p>java tools used internally in rJava</p></a></li>
<li><a href='#JavaAccess'>
<p>Field/method operator for Java objects</p></a></li>
<li><a href='#javaImport'>
<p>Attach mechanism for java packages</p></a></li>
<li><a href='#jcall'>
<p>Call a Java method</p></a></li>
<li><a href='#jcast'>
<p>Cast a Java object to another class</p></a></li>
<li><a href='#jcastToArray'>
<p>Ensures that a given object is an array reference</p></a></li>
<li><a href='#jcheck'>
<p>Java exception handling</p></a></li>
<li><a href='#jclassName-class'><p>Class &quot;jclassName&quot; - a representation of a Java class name</p></a></li>
<li><a href='#jengine'>
<p>Java callback engineCast a Java object to another class</p></a></li>
<li><a href='#jequals'>
<p>Comparing Java References</p></a></li>
<li><a href='#jfield'>
<p>Obtains the value of a field</p></a></li>
<li><a href='#jfloat'>
<p>Wrap numeric vector as flat Java parameter</p></a></li>
<li><a href='#jfloat-class'><p>Classes &quot;jfloat&quot;, &quot;jlong&quot;, &quot;jbyte&quot; and &quot;jchar&quot; specify Java</p>
native types that are not native in R</a></li>
<li><a href='#jinit'>
<p>Initialize Java VM</p></a></li>
<li><a href='#jmemprof'>
<p>rJava memory profiler</p></a></li>
<li><a href='#jnew'>
<p>Create a Java object</p></a></li>
<li><a href='#jnull'>
<p>Java null object reference</p></a></li>
<li><a href='#jobjRef-class'><p>Class &quot;jobjRef&quot; - Reference to a Java object</p></a></li>
<li><a href='#jpackage'>
<p>Initialize an R package containing Java code</p></a></li>
<li><a href='#jrectRef-class'><p>Rectangular java arrays</p></a></li>
<li><a href='#jreflection'>
<p>Simple helper functions for Java reflection</p></a></li>
<li><a href='#jserialize'>
<p>Java object serialization</p></a></li>
<li><a href='#jsimplify'>
<p>Converts Java object to a simple scalar if possible</p></a></li>
<li><a href='#loader'>
<p>Java Class Loader</p></a></li>
<li><a href='#new'>
<p>Create a new Java object</p></a></li>
<li><a href='#rep'><p>Creates java arrays by cloning</p></a></li>
<li><a href='#rJava-internal'>
<p>Internal functions and constants</p></a></li>
<li><a href='#show'><p>Show a Java Object Reference</p></a></li>
<li><a href='#toJava'>
<p>Convert R objects to REXP references in Java</p></a></li>
<li><a href='#with.jobjRef'>
<p>with and within methods for Java objects and class names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Low-Level R to Java Interface</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Urbanek &lt;simon.urbanek@r-project.org&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Urbanek &lt;simon.urbanek@r-project.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Low-level interface to Java VM very much like .C/.Call and friends. Allows creation of objects, calling methods and accessing fields.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.rforge.net/rJava/">http://www.rforge.net/rJava/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java JDK 1.2 or higher (for JRI/REngine JDK 1.4 or
higher), GNU make</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/s-u/rJava/issues">https://github.com/s-u/rJava/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 22:25:37 UTC; rforge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 16:02:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='.jgc'>
Invoke Java Garbage Collection
</h2><span id='topic+.jgc'></span>

<h3>Description</h3>

<p><code>.jgc</code> invokes the R and Java garbage collectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jgc(R.gc = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".jgc_+3A_r.gc">R.gc</code></td>
<td>
<p>logical, if <code>TRUE</code> then <code>gc(...)</code> is called
first, if <code>FALSE</code> only Java garbage collector is called</p>
</td></tr>
<tr><td><code id=".jgc_+3A_...">...</code></td>
<td>
<p>any additional parameters passed to <code>gc()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.jgc</code> invokes the R garbage collector (unless
<code>R.gc=FALSE</code>) which removes any unused Java references and then
invokes the Java garbage collector to reclaim Java heap space.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>

<hr>
<h2 id='.jinstanceof'>
Is a java object an instance of a given java class
</h2><span id='topic++25instanceof+25'></span><span id='topic+.jinstanceof'></span>

<h3>Description</h3>

<p>Is a java object an instance of a given java class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>o %instanceof% cl
.jinstanceof( o, cl )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".jinstanceof_+3A_o">o</code></td>
<td>
<p>java object reference</p>
</td></tr>
<tr><td><code id=".jinstanceof_+3A_cl">cl</code></td>
<td>
<p>java class. This can be a character vector of length one
giving the name of the class, or another java object, or an instance
of the Class class, or a object of class <code>jclassName</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if o is an instance of cl
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Double &lt;- J("java.lang.Double")
d &lt;- new( Double, "10.2" )

# character
d %instanceof% "java.lang.Double"
d %instanceof% "java.lang.Number"

# jclassName
d %instanceof% Double

# instance of Class
Double.class &lt;- Double@jobj
d %instanceof% Double.class

# other object
other.double &lt;- new( Double, 10.2 )
d %instanceof% other.double



</code></pre>

<hr>
<h2 id='aslist'>
Converts java objects or arrays to R lists
</h2><span id='topic+as.list.jobjRef'></span><span id='topic+as.list.jarrayRef'></span><span id='topic+as.list.jrectRef'></span>

<h3>Description</h3>

<p><code>as.list</code> is implemented for java objects and java arrays
to facilitate using <code>lapply</code> calls over elements of a java array
or items of an Iterator associated with an Iterable object
</p>
<p>For java array references, <code>as.list</code> is mapped to
<code><a href="#topic+.jevalArray">.jevalArray</a></code>
</p>
<p>For java objects that implement the Iterable interface, 
the list is created by iterating over the associated iterator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jobjRef'
as.list(x, ...)
## S3 method for class 'jarrayRef'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aslist_+3A_x">x</code></td>
<td>
<p>java array or Iterable java object</p>
</td></tr>
<tr><td><code id="aslist_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list, or vector.
</p>


<h3>Note</h3>

<p>The function is not intended to be called directly. It is implemented
so that java arrays or Iterable java objects can be used as the first 
argument of <code><a href="base.html#topic+lapply">lapply</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jevalArray">.jevalArray</a></code>, <code><a href="base.html#topic+lapply">lapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # lapplying over a java array
  a &lt;- .jarray( list( 
	.jnew( "java/awt/Point", 10L, 10L ), 
	.jnew( "java/awt/Point", 30L, 30L )
  ) )
  lapply( a, function(point){ 
	with(point, { 
		(x + y ) ^ 2
	} )
  } )

# lapply over a Vector (implements Iterable)
v &lt;- .jnew("java/util/Vector")
v$add( "foo" )
v$add( .jnew("java/lang/Double", 10.2 ) )
sapply( v, function(item) item$getClass()$getName() )

</code></pre>

<hr>
<h2 id='clone'>
Object cloner
</h2><span id='topic+clone'></span><span id='topic+clone+2CjobjRef-method'></span><span id='topic+clone+2CjarrayRef-method'></span><span id='topic+clone+2CjrectRef-method'></span>

<h3>Description</h3>

<p>Generic function to clone objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clone_+3A_x">x</code></td>
<td>
<p>An object to clone</p>
</td></tr>
<tr><td><code id="clone_+3A_...">...</code></td>
<td>
<p>Further arguments, ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A clone of the object
</p>


<h3>Methods</h3>


<dl>
<dt>clone</dt><dd><p><code>signature(x = "jobjRef")</code>: clone a java object reference (must implement Cloneable) </p>
</dd>
<dt>clone</dt><dd><p><code>signature(x = "jarrayRef")</code>: clone a java rugged array (not yet implemented) </p>
</dd>
<dt>clone</dt><dd><p><code>signature(x = "jrectRef")</code>: clone a java rectangular array (not yet implemented) </p>
</dd>
</dl>



<h3>Warning</h3>

<p>The implementation of clone for java object references uses
the clone method of the Object class. The reading of its description
in the java help page is <em>strongly</em> recommended. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  p1 &lt;- .jnew("java/awt/Point" )
  p2 &lt;- clone( p1 )
  p2$move( 10L, 10L )
  p1$getX() 

  # check that p1 and p2 are not references to the same java object
  stopifnot( p1$getX() == 0 )
  stopifnot( p2$getX() == 10 )

</code></pre>

<hr>
<h2 id='Exceptions'>Exception handling</h2><span id='topic+Exceptions'></span><span id='topic++24.Throwable'></span><span id='topic++24+3C-.Throwable'></span>

<h3>Description</h3>

<p>R handling of java exception</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'Throwable'
x$name 
	## S3 replacement method for class 'Throwable'
x$name  &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exceptions_+3A_x">x</code></td>
<td>
<p>condition</p>
</td></tr>
<tr><td><code id="Exceptions_+3A_name">name</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="Exceptions_+3A_value">value</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Java exceptions are mapped to R conditions that are relayed by the
<code><a href="base.html#topic+stop">stop</a></code> function. 
</p>
<p>The R condition contains the actual exception object as the 
<code>jobj</code> item.
</p>
<p>The class name of the R condition is made of a vector 
of simple java class names, the class names without their package
path. This allows the R code to use direct handlers similar to 
direct exception handlers in java. See the example below. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Integer &lt;- J("java.lang.Integer")
tryCatch( Integer$parseInt( "10.." ), NumberFormatException = function(e){
	e$jobj$printStackTrace() 
} )

# the dollar method is also implemented for Throwable conditions, 
# so that syntactic sugar can be used on condition objects
# however, in the example below e is __not__ a jobjRef object reference
tryCatch( Integer$parseInt( "10.." ), NumberFormatException = function(e){
	e$printStackTrace() 
} )




</code></pre>

<hr>
<h2 id='J'>
High level API for accessing Java
</h2><span id='topic+J'></span>

<h3>Description</h3>

<p><code>J</code> creates a Java class reference or calls a Java method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J(class, method, ..., class.loader=.rJava.class.loader)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J_+3A_class">class</code></td>
<td>

<p>java object reference or fully qualified class name in JNI
notation (e.g &quot;java/lang/String&quot; ) or standard java notation (e.g
&quot;java.lang.String&quot;)
</p>
</td></tr>
<tr><td><code id="J_+3A_method">method</code></td>
<td>

<p>if present then <code>J</code> results in a method call, otherwise it
just creates a class name reference.
</p>
</td></tr>
<tr><td><code id="J_+3A_...">...</code></td>
<td>

<p>optional parameters that will be passed to the method (if the
<code>method</code> argument is present)
</p>
</td></tr>
<tr><td><code id="J_+3A_class.loader">class.loader</code></td>
<td>
<p>optional, custom loader to use if a class look-up
is necessary (i.e., if <code>class</code> is a string)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>J</code> is the high-level access to Java.
</p>
<p>If the <code>method</code> argument is missing then <code>code</code> must be a
class name and <code>J</code> creates a class name reference that can be
used either in a call to <code>new</code> to create a new Java object
(e.g. <code>new(J("java.lang.String"), "foo")</code>) or with <code>$</code>
operator to call a static method
(e.g. <code>J("java.lang.Double")$parseDouble("10.2")</code>.)
</p>
<p>If the <code>method</code> argument is present then it must be a string
vector of length one which defines the method to be called on the
object.
</p>


<h3>Value</h3>

<p>If <code>method</code> is missing the the returned value is an object of
the class <code>jclassName</code>. Otherwise the value is the result of
the method invocation. In the latter case Java exceptions may be
thrown and the function doesn't return.
</p>


<h3>Note</h3>

<p><code>J</code> is a high-level API which is slower than <code><a href="#topic+.jnew">.jnew</a></code>
or <code><a href="#topic+.jcall">.jcall</a></code> since it has to use reflection to find the
most suitable method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>, <code><a href="#topic+.jnew">.jnew</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (!nzchar(Sys.getenv("NOAWT"))) {
  f &lt;- new(J("java.awt.Frame"), "Hello")
  f$setVisible(TRUE)
}

J("java.lang.Double")$parseDouble("10.2")
J("java.lang.Double", "parseDouble", "10.2" )

Double &lt;- J("java.lang.Double")
Double$parseDouble( "10.2")

# String[] strings = new String[]{ "string", "array" } ;
  strings &lt;- .jarray( c("string", "array") )
# this uses the JList( Object[] ) constructor 
# even though the "strings" parameter is a String[] 
  l &lt;- new( J("javax.swing.JList"), strings)

</code></pre>

<hr>
<h2 id='jarray'>
Java array handling functions
</h2><span id='topic+.jarray'></span><span id='topic+.jevalArray'></span>

<h3>Description</h3>

<p><code>.jarray</code> takes a vector (or a list of Java references) as its
argument, creates a Java array containing the elements of the vector
(or list) and returns a reference to such newly created array.
</p>
<p><code>.jevalArray</code> takes a reference to a Java array and returns its
contents (if possible).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jarray(x, contents.class = NULL, dispatch = FALSE)
.jevalArray(obj, rawJNIRefSignature = NULL, silent = FALSE, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jarray_+3A_x">x</code></td>
<td>
<p>vector or a list of Java references</p>
</td></tr>
<tr><td><code id="jarray_+3A_contents.class">contents.class</code></td>
<td>
<p>common class of the contained objects, see
details</p>
</td></tr>
<tr><td><code id="jarray_+3A_obj">obj</code></td>
<td>
<p>Java object reference to an array that is to be evaluated</p>
</td></tr>
<tr><td><code id="jarray_+3A_rawjnirefsignature">rawJNIRefSignature</code></td>
<td>
<p>JNI signature that would be used for
conversion. If set to <code>NULL</code>, the signature is detected
automatically.</p>
</td></tr>
<tr><td><code id="jarray_+3A_silent">silent</code></td>
<td>
<p>if set to true, warnings are suppressed</p>
</td></tr>
<tr><td><code id="jarray_+3A_dispatch">dispatch</code></td>
<td>
<p>logical. If <code>TRUE</code> the code attempts to dispatch
to either a <code>jarrayRef</code> object for rugged arrays and
<code>jrectRef</code> objects for rectangular arrays, creating possibly a
multi-dimensional object in Java (e.g., when used with a matrix).</p>
</td></tr>
<tr><td><code id="jarray_+3A_simplify">simplify</code></td>
<td>
<p>if set to <code>TRUE</code> more than two-dimensional arrays
are converted to native objects (e.g., matrices) if their type and
size matches (essentially the inverse for objects created with
<code>dispatch=TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.jarray</code>: The input can be either a vector of some sort (such as
numeric, integer, logical, ...) or a list of Java references. The
contents is pushed to the Java side and a corresponding array is
created. The type of the array depends on the input vector type. For
example numeric vector creates <code>double[]</code> array, integer vector
creates <code>int[]</code> array, character vector <code>String[]</code> array and
so on. If <code>x</code> is a list, it must contain Java references only (or
<code>NULL</code>s which will be treated as <code>NULL</code> references).
</p>
<p>The <code>contents.class</code> parameter is used only if <code>x</code> is a list
of Java object references and it can specify the class that will be
used for all objects in the array. If set to <code>NULL</code> no assumption
is made and <code>java/lang/Object</code> will be used. Use with care and
only if you know what you're doing - you can always use
<code><a href="#topic+.jcast">.jcast</a></code> to cast the entire array to another type even if
you use a more general object type. One typical use is to construct
multi-dimensional arrays which mandates passing the array type as
<code>contents.class</code>.
</p>
<p>The result is a reference to the newly created array.
</p>
<p>The inverse function which fetches the elements of an array reference
is <code>.jevalArray</code>.
</p>
<p><code>.jevalArray</code> currently supports only a subset of all possible
array types. Recursive arrays are handled by returning a list of
references which can then be evaluated separately. The only exception
is <code>simplify=TRUE</code> in which case <code>.jevalArray</code> attempts to
convert multi-dimensional arrays into native R type if there is a
such. This only works for rectangular arrays of the same basic type
(i.e. the length and type of each referenced array is the same -
sometimes matrices are represented that way in Java).
</p>


<h3>Value</h3>

<p><code>.jarray</code> returns a Java array reference (<code>jarrayRef</code> or <code>jrectRef</code>) to an
array created with the supplied contents.
</p>
<p><code>.jevalArray</code> returns the contents of the array object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- .jarray(1:10)
print(a)
.jevalArray(a)
b &lt;- .jarray(c("hello","world"))
print(b)
c &lt;- .jarray(list(a,b))
print(c)
# simple .jevalArray will return a list of references
print(l &lt;- .jevalArray(c))
# to convert it back, use lapply
lapply(l, .jevalArray)

# two-dimensional array resulting in int[2][10]
d &lt;- .jarray(list(a,a),"[I")
print(d)
# use dispatch to convert a matrix to [[D
e &lt;- .jarray(matrix(1:12/2, 3), dispatch=TRUE)
print(e)
# simplify it back to a matrix
.jevalArray(e, simplify=TRUE)
</code></pre>

<hr>
<h2 id='jarrayRef-class'>Class &quot;jarrayRef&quot; Reference to an array Java object </h2><span id='topic+jarrayRef-class'></span><span id='topic++5B+2CjarrayRef-method'></span><span id='topic++5B+5B+2CjarrayRef-method'></span><span id='topic++5B+5B+3C-+2CjarrayRef-method'></span><span id='topic+head+2CjarrayRef-method'></span><span id='topic+tail+2CjarrayRef-method'></span><span id='topic+length+2CjarrayRef-method'></span><span id='topic+str+2CjarrayRef-method'></span><span id='topic+unique+2CjarrayRef-method'></span><span id='topic+duplicated+2CjarrayRef-method'></span><span id='topic+anyDuplicated+2CjarrayRef-method'></span><span id='topic+sort+2CjarrayRef-method'></span><span id='topic+rev+2CjarrayRef-method'></span><span id='topic+min+2CjarrayRef-method'></span><span id='topic+max+2CjarrayRef-method'></span><span id='topic+range+2CjarrayRef-method'></span>

<h3>Description</h3>

<p> This class is a subclass of <a href="#topic+jobjRef-class">jobjRef-class</a> 
and represents a reference to an array Java object. </p>


<h3>Objects from the Class</h3>

<p>Objects cannot be created directly, but only as the return
value of <code><a href="#topic+.jcall">.jcall</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>jsig</code>:</dt><dd><p>JNI signature of the array type</p>
</dd>
<dt><code>jobj</code>:</dt><dd><p>Internal identifier of the object</p>
</dd>
<dt><code>jclass</code>:</dt><dd><p>Inherited from <code>jobjRef</code>, but unspecified</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "jarrayRef")</code>: R indexing of java arrays </p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x = "jarrayRef")</code>: replacement method </p>
</dd>
<dt><code>head</code></dt><dd><p><code>signature(x = "jarrayRef")</code>: head of the java array </p>
</dd>
<dt><code>tail</code></dt><dd><p><code>signature(x = "jarrayRef")</code>: tail of the java array </p>
</dd>
<dt>length</dt><dd><p><code>signature(object = "jarrayRef")</code>: Number of java objects in the java array </p>
</dd>
<dt>str</dt><dd><p><code>signature(object = "jarrayRef")</code>: ... </p>
</dd>
<dt>unique</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>duplicated</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>anyDuplicated</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>sort</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>rev</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>min</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>max</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
<dt>range</dt><dd><p><code>signature(x = "jarrayRef")</code>: <em>not yet implemented</em> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+jobjRef-class">jobjRef</a>"</code>, directly.
</p>


<h3>Author(s)</h3>

<p> Simon Urbanek </p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code> or <code><a href="#topic+jobjRef-class">jobjRef</a></code>
<code><a href="#topic+jrectRef-class">jrectRef</a></code> for rectangular arrays
</p>

<hr>
<h2 id='java-tools'>java tools used internally in rJava</h2><span id='topic+java-tools'></span>

<h3>Description</h3>

<p>java tools used internally in rJava</p>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='JavaAccess'>
Field/method operator for Java objects
</h2><span id='topic++24+2CjobjRef-method'></span><span id='topic++24+2CjclassName-method'></span><span id='topic++24+3C-+2CjobjRef-method'></span><span id='topic++24+3C-+2CjclassName-method'></span><span id='topic+names+2CjobjRef-method'></span><span id='topic+names+2CjclassName-method'></span><span id='topic+names+2CjarrayRef-method'></span><span id='topic+names+2CjrectRef-method'></span><span id='topic+.DollarNames.jobjRef'></span><span id='topic+.DollarNames.jclassName'></span><span id='topic+.DollarNames.jarrayRef'></span><span id='topic+.DollarNames.jrectRef'></span>

<h3>Description</h3>

<p>The <code>$</code> operator for <code>jobjRef</code> Java object references provides convenience access to object attributes and calling Java methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'jobjRef'
   .DollarNames(x, pattern = "" )
	## S3 method for class 'jarrayRef'
 .DollarNames(x, pattern = "" )
	## S3 method for class 'jrectRef'
  .DollarNames(x, pattern = "" )
	## S3 method for class 'jclassName'
.DollarNames(x, pattern = "" )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JavaAccess_+3A_x">x</code></td>
<td>
<p>object to complete</p>
</td></tr>
<tr><td><code id="JavaAccess_+3A_pattern">pattern</code></td>
<td>
<p>pattern</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rJava provides two levels of API: low-level JNI-API in the form of <code><a href="#topic+.jcall">.jcall</a></code> function and high-level reflection API based on the <code>$</code> operator. The former is very fast, but inflexible. The latter is a convenient way to use Java-like programming at the cost of performance. The reflection API is build around the <code>$</code> operator on <code><a href="#topic+jobjRef-class">jobjRef-class</a></code> objects that allows to access Java attributes and call object methods.
</p>
<p><code>$</code> returns either the value of the attribute or calls a method, depending on which name matches first.
</p>
<p><code>$&lt;-</code> assigns a value to the corresponding Java attribute.
</p>
<p><code>names</code> and <code>.DollarNames</code> returns all fields and methods associated with the object.
Method names are followed by <code>(</code> or <code>()</code> depending on arity.
This use of names is mainly useful for code completion, it is not intended to be used programmatically.
</p>
<p>This is just a convenience API. Internally all calls are mapped into <code><a href="#topic+.jcall">.jcall</a></code> calls, therefore the calling conventions and returning objects use the same rules. For time-critical Java calls <code><a href="#topic+.jcall">.jcall</a></code> should be used directly.
</p>


<h3>Methods</h3>


<dl>
<dt><code>$</code></dt><dd><p><code>signature(x = "jobjRef")</code>: ... </p>
</dd>
<dt><code>$</code></dt><dd><p><code>signature(x = "jclassName")</code>: ... </p>
</dd>
<dt><code>$&lt;-</code></dt><dd><p><code>signature(x = "jobjRef")</code>: ... </p>
</dd>
<dt><code>$&lt;-</code></dt><dd><p><code>signature(x = "jclassName")</code>: ... </p>
</dd>
<dt><code>names</code></dt><dd><p><code>signature(x = "jobjRef")</code>: ... </p>
</dd>
<dt><code>names</code></dt><dd><p><code>signature(x = "jarrayRef")</code>: ... </p>
</dd>
<dt><code>names</code></dt><dd><p><code>signature(x = "jrectRef")</code>: ... </p>
</dd>
<dt><code>names</code></dt><dd><p><code>signature(x = "jclassName")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+J">J</a></code>, <code><a href="#topic+.jcall">.jcall</a></code>, <code><a href="#topic+.jnew">.jnew</a></code>, <code><a href="#topic+jobjRef-class">jobjRef-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

v &lt;- new(J("java.lang.String"), "Hello World!")
v$length()
v$indexOf("World")
names(v)



J("java.lang.String")$valueOf(10)

Double &lt;- J("java.lang.Double")
# the class pseudo field - instance of Class for the associated class
# similar to java Double.class
Double$class


</code></pre>

<hr>
<h2 id='javaImport'>
Attach mechanism for java packages
</h2><span id='topic+javaImport'></span>

<h3>Description</h3>

<p>The <code>javaImport</code> function creates an item on R's
search that maps names to class names references found in 
one or several &quot;imported&quot; java packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>javaImport(packages = "java.lang")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="javaImport_+3A_packages">packages</code></td>
<td>
<p>character vector containing java package paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An external pointer to a java specific <code>UserDefinedDatabase</code> object
</p>


<h3>Warning</h3>

<p>This feature is experimental. Use with caution, and don't forget to
detach.
</p>


<h3>Note</h3>

<p>Currently the list of objects in the imported package is populated
as new objects are found, <em>not</em> at creation time.
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>References</h3>

<p><em>User-Defined Tables in the R Search Path</em>. Duncan Temple Lang. December 4, 2001
<a href="https://www.omegahat.net/RObjectTables/">https://www.omegahat.net/RObjectTables/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+attach">attach</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	attach( javaImport( "java.util" ), pos = 2 , name = "java:java.util" )
	
	# now we can just do something like this 
	v &lt;- new( Vector )
	v$add( "foobar" )
	ls( pos = 2 )
	
	# or this
	m &lt;- new( HashMap )
	m$put( "foo", "bar" )
	ls( pos = 2 )
	
	# or even this :
	Collections$EMPTY_MAP

## End(Not run)
</code></pre>

<hr>
<h2 id='jcall'>
Call a Java method
</h2><span id='topic+.jcall'></span>

<h3>Description</h3>

<p><code>.jcall</code> calls a Java method with the supplied arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jcall(obj, returnSig = "V", method, ..., evalArray = TRUE,
    evalString = TRUE, check = TRUE, interface = "RcallMethod",
    simplify = FALSE, use.true.class = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jcall_+3A_obj">obj</code></td>
<td>
<p>Java object (<code>jobjRef</code> as returned by
<code><a href="#topic+.jcall">.jcall</a></code> or <code><a href="#topic+.jnew">.jnew</a></code>) or fully qualified
class name in JNI notation (e.g. <code>"java/lang/String"</code>).</p>
</td></tr>
<tr><td><code id="jcall_+3A_returnsig">returnSig</code></td>
<td>
<p>Return signature in JNI notation (e.g. &quot;V&quot; for void,
&quot;[I&quot; for <code>int[]</code> etc.). For convenience additional type
<code>"S"</code> is supported and expanded to
<code>"Ljava/lang/String;"</code>, re-mapping <code>"T"</code> to represent the
type <code>short</code>.</p>
</td></tr>
<tr><td><code id="jcall_+3A_method">method</code></td>
<td>
<p>The name of the method to be called</p>
</td></tr>
<tr><td><code id="jcall_+3A_...">...</code></td>
<td>

<p>Any parameters that will be passed to the Java method. The parameter
types are determined automatically and/or taken from the
<code>jobjRef</code> object. All named parameters are discarded.</p>
</td></tr>
<tr><td><code id="jcall_+3A_evalarray">evalArray</code></td>
<td>
<p>This flag determines whether the array return value
is evaluated (<code>TRUE</code>) or passed back as Java object reference
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="jcall_+3A_simplify">simplify</code></td>
<td>
<p>If <code>evalArray</code> is <code>TRUE</code> then this argument
is passed to <code><a href="#topic+.jevalArray">.jevalArray</a>()</code>.</p>
</td></tr>
<tr><td><code id="jcall_+3A_evalstring">evalString</code></td>
<td>
<p>This flag determines whether string result is returned
as characters or as Java object reference.</p>
</td></tr>
<tr><td><code id="jcall_+3A_check">check</code></td>
<td>
<p>If set to <code>TRUE</code> then checks for exceptions are
performed before and after the call using
<code><a href="#topic+.jcheck">.jcheck</a>(silent=FALSE)</code>. This is usually the desired
behavior, because all calls fail until an exception is cleared.</p>
</td></tr>
<tr><td><code id="jcall_+3A_interface">interface</code></td>
<td>
<p>This option is experimental and specifies the
interface used for calling the Java method; the current
implementation supports two interfaces:
</p>

<dl>
<dt><code>"RcallMethod"</code></dt><dd><p>the default interface.</p>
</dd>
<dt><code>"RcallSyncMethod"</code></dt><dd><p>synchronized call of a
method. This has similar effect as using <code>synchronize</code> in
Java.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="jcall_+3A_use.true.class">use.true.class</code></td>
<td>
<p>logical. If set to <code>TRUE</code>, the true class
of the returned object will be used instead of the declared signature.
<code>TRUE</code> allows for example to grab the actual class of an object when
the return type is an interface, or allows to grab an array when the
declared type is Object and the returned object is an array. Use <code>FALSE</code>
for efficiency when you are sure about the return type. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.jcall</code> requires exact match of argument and return types. For
higher efficiency <code>.jcall</code> doesn't perform any lookup in the
reflection tables. This means that passing subclasses of the classes
present in the method definition requires explicit casting using
<code><a href="#topic+.jcast">.jcast</a></code>. Passing <code>null</code> arguments also needs a
proper class specification with <code><a href="#topic+.jnull">.jnull</a></code>.
</p>
<p>Java types <code>long</code> and <code>float</code> have no corresponding types in
R and therefore any such parameters must be flagged as such using
<code><a href="#topic+.jfloat">.jfloat</a></code> and <code><a href="#topic+.jlong">.jlong</a></code> functions respectively.
</p>
<p>Java also distinguishes scalar and array types whereas R doesn't have
the concept of a scalar. In R a scalar is basically a vector (called
array in Java-speak) of the length 1. Therefore passing vectors of the
length 1 is ambiguous. <code>.jcall</code> assumes that any vector of the
length 1 that corresponds to a native Java type is a scalar. All other
vectors are passed as arrays. Therefore it is important to use
<code><a href="#topic+.jarray">.jarray</a></code> if an arbitrary vector (including those of the
length 1) is to be passed as an array parameter.
</p>
<p><em>Important note about encoding of character vectors:</em>
Java interface always works with strings in UTF-8 encoding, therefore
the safest way is to run R in a UTF-8 locale. If that is not
possible for some reason, rJava can be used in non-UTF-8 locales,
but care must be taken. Since R 2.7.0 it is possible to associate
encoding with strings and rJava will flag all strings it produces
with the appropriate UTF-8 tag. R will then perform corresponding
appropriate conversions where possible (at a cost of speed and
memory usage), but 3rd party code may not (e.g. older
packages). Also rJava relies on correct encoding flags for strings
passed to it and will attempt to perform conversions where
necessary. If some 3rd party code produces strings incorrectly
flagged, all bets are off.
</p>
<p>Finally, for performance reasons class, method and field names as
well as signatures are not always converted and should not contain
non-ASCII characters.
</p>


<h3>Value</h3>

<p>Returns the result of the method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jnew">.jnew</a></code>, <code><a href="#topic+.jcast">.jcast</a></code>, <code><a href="#topic+.jnull">.jnull</a></code>,
<code><a href="#topic+.jarray">.jarray</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.jcall("java/lang/System","S","getProperty","os.name")
if (!nzchar(Sys.getenv("NOAWT"))) {
  f &lt;- .jnew("java/awt/Frame","Hello")
  .jcall(f,,"setVisible",TRUE)
}
</code></pre>

<hr>
<h2 id='jcast'>
Cast a Java object to another class
</h2><span id='topic+.jcast'></span>

<h3>Description</h3>

<p><code>.jcast</code> returns a Java object reference cast to another Java class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jcast(obj, new.class = "java/lang/Object", check = FALSE, convert.array = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jcast_+3A_obj">obj</code></td>
<td>
<p>a Java object reference</p>
</td></tr>
<tr><td><code id="jcast_+3A_new.class">new.class</code></td>
<td>
<p>fully qualified class name in JNI notation
(e.g. <code>"java/lang/String"</code>). </p>
</td></tr>
<tr><td><code id="jcast_+3A_check">check</code></td>
<td>
<p>logical. If <code>TRUE</code>, it is checked that the object 
effectively is an instance of the new class. See <code><a href="#topic++25instanceof+25">%instanceof%</a></code>.
Using FALSE (the default) for this argument, rJava does not perform type check and this 
will cause an error on the first use if the cast is illegal.</p>
</td></tr>
<tr><td><code id="jcast_+3A_convert.array">convert.array</code></td>
<td>
<p>logical. If <code>TRUE</code> and the object is an array, 
it is converted into a <code>jarrayRef</code> reference. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is necessary if a argument of <code><a href="#topic+.jcall">.jcall</a></code> or
<code><a href="#topic+.jnew">.jnew</a></code> is defined as the superclass of the object to be
passed (see <code><a href="#topic+.jcall">.jcall</a></code>). The original object is not modified.
</p>
<p>The default values for the arguments <code>check</code> and <code>convert.array</code>
is <code>FALSE</code> in order to guarantee backwards compatibility, 
but it is recommended to set the arguments to <code>TRUE</code>
</p>


<h3>Value</h3>

<p>Returns a Java object reference (<code>jobjRef</code>) to the object
<code>obj</code>, changing the object class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
v &lt;- .jnew("java/util/Vector")
.jcall("java/lang/System","I","identityHashCode",.jcast(v, "java/lang/Object"))

## End(Not run)
</code></pre>

<hr>
<h2 id='jcastToArray'>
Ensures that a given object is an array reference
</h2><span id='topic+.jcastToArray'></span>

<h3>Description</h3>

<p><code>.jcastToArray</code> takes a Java object reference of any kind and
returns Java array reference if the given object is a reference to an
array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jcastToArray(obj, signature=NULL, class="", quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jcastToArray_+3A_obj">obj</code></td>
<td>
<p>Java object reference to cast or a scalar vector</p>
</td></tr>
<tr><td><code id="jcastToArray_+3A_signature">signature</code></td>
<td>
<p>array signature in JNI notation (e.g. <code>"[I"</code> for
an array of integers). If set to <code>NULL</code> (the default),
the signature is automatically determined from the object's class.</p>
</td></tr>
<tr><td><code id="jcastToArray_+3A_class">class</code></td>
<td>
<p>force the result to pose as a particular Java
class. This has the same effect as using <code><a href="#topic+.jcast">.jcast</a></code> on the
result and is provided for convenience only.</p>
</td></tr>
<tr><td><code id="jcastToArray_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, no failures are reported and the
original object is returned unmodified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes a result of a method is by definition of the class
<code>java.lang.Object</code>, but the actual referenced object may be an
array. In that case the method returns a Java object reference instead
of an array reference. In order to obtain an array reference, it is
necessary to cast such an object to an array reference - this is done
using the above <code>.jcastToArray</code> function.
</p>
<p>The input is an object reference that points to an array. Usually the
signature should be left at <code>NULL</code> such that it is determined
from the object's class. This is also a check, because if the object's
class is not an array, then the functions fails either with an error
(when <code>quiet=FALSE</code>) or by returning the original object (when
<code>quiet=TRUE</code>). If the signature is set to anything else, it is
not verified and the array reference is always created, even if it may
be invalid and unusable.
</p>
<p>For convenience <code>.jcastToArray</code> also accepts non-references in
which case it simply calls <code><a href="#topic+.jarray">.jarray</a></code>, ignoring all other
parameters.
</p>


<h3>Value</h3>

<p>Returns a Java array reference (<code>jarrayRef</code>) on success. If
<code>quiet</code> is <code>TRUE</code> then the result can also be the original
object in the case of failure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a &lt;- .jarray(1:10)
print(a)
# let's create an array containing the array
aa &lt;- .jarray(list(a))
print(aa)
ba &lt;- .jevalArray(aa)[[1]]
# it is NOT the inverse, because .jarray works on a list of objects
print(ba)
# so we need to cast the object into an array
b &lt;- .jcastToArray(ba)
# only now a and b are the same array reference
print(b)
# for convenience .jcastToArray behaves like .jarray for non-references
print(.jcastToArray(1:10/2))

## End(Not run)
</code></pre>

<hr>
<h2 id='jcheck'>
Java exception handling
</h2><span id='topic+.jcheck'></span><span id='topic+.jthrow'></span><span id='topic+.jclear'></span><span id='topic+.jgetEx'></span>

<h3>Description</h3>

<p><code>.jcheck</code> checks the Java VM for any pending exceptions and
clears them.
</p>
<p><code>.jthrow</code> throws a Java exception.
</p>
<p><code>.jgetEx</code> polls for any pending exceptions and returns the exception object.
</p>
<p><code>.jclear</code> clears a pending exception.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jcheck(silent = FALSE)

.jthrow(exception, message = NULL)
.jgetEx(clear = FALSE)
.jclear()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jcheck_+3A_silent">silent</code></td>
<td>
<p>If set to <code>FALSE</code> then Java is instructed to print
the exception on <code>stderr</code>. Note that Windows Rgui doesn't show
<code>stderr</code> so it will not appear there (as of rJava 0.5-1 some
errors that the JVM prints using the vfprintf callback are passed
to R. However, some parts are printed using <code>System.err</code> in
which case the usual redirection using the <code>System</code> class
can be used by the user).</p>
</td></tr>
<tr><td><code id="jcheck_+3A_exception">exception</code></td>
<td>
<p>is either a class name of an exception to create or a
throwable object reference that is to be thrown.</p>
</td></tr>
<tr><td><code id="jcheck_+3A_message">message</code></td>
<td>
<p>if <code>exception</code> is a class name then this parameter
specifies the string to be used as the message of the exception. This
parameter is ignored if <code>exception</code> is a reference.</p>
</td></tr>
<tr><td><code id="jcheck_+3A_clear">clear</code></td>
<td>
<p>if set to <code>TRUE</code> then the returned exception is also
cleared, otherwise the throwable is returned without clearing the
cause.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that some functions (such as <code><a href="#topic+.jnew">.jnew</a></code> or
<code><a href="#topic+.jcall">.jcall</a></code>) call <code>.jcheck</code> implicitly unless
instructed to not do so. If you want to handle Java exceptions, you
should make sure that those function don't clear the exception you may
want to catch.
</p>
<p>The exception handling is still as a very low-level and experimental,
because it requires polling of exceptions. A more elaborate system
using constructs similar to <code>try</code> ... <code>catch</code> is planned for
next major version of <code>rJava</code>.
</p>
<p><em>Warning:</em> When requesting exceptions to not be cleared
automatically, please note that the <code>show</code> method (which is
called by <code>print</code>) has a side-effect of making a Java call to get
the string representation of a Java object. This implies that it will
be impeded by any pending exceptions. Therefore exceptions obtained
through <code>.jgetEx</code> can be stored, but should not be printed
(or otherwise used in Java calls) until after the exception is
cleared. In general, all Java calls will fail (possibly silently)
until the exception is cleared.
</p>


<h3>Value</h3>

<p><code>.jcheck</code> returns <code>TRUE</code> if an exception occurred or
<code>FALSE</code> otherwise.
</p>
<p><code>.jgetEx</code> returns <code>NULL</code> if there are no pending exceptions
or an object of the class &quot;java.lang.Throwable&quot; representing the
current exception.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>, <code><a href="#topic+.jnew">.jnew</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# we try to create a bogus object and
# instruct .jnew to not clear the exception
# this will raise an exception
v &lt;- .jnew("foo/bar", check=FALSE)

# you can poll for the exception, but don't try to print it
# (see details above)
if (!is.null(e&lt;-.jgetEx())) print("Java exception was raised")

# expect TRUE result here because the exception was still not cleared
print(.jcheck(silent=TRUE))
# next invocation will be FALSE because the exception is now cleared
print(.jcheck(silent=TRUE))

# now you can print the actual expection (even after it was cleared)
print(e)

</code></pre>

<hr>
<h2 id='jclassName-class'>Class &quot;jclassName&quot; - a representation of a Java class name </h2><span id='topic+jclassName-class'></span><span id='topic+as.character+2CjclassName-method'></span>

<h3>Description</h3>

<p> This class holds a name of a class in Java. </p>


<h3>Objects from the Class</h3>

<p>Objects of this class should *not* be created directly. Instead, the
function <code><a href="#topic+J">J</a></code> should be used to create new objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Name of the class (in source code notation)</p>
</dd>
<dt><code>jobj</code>:</dt><dd><p>Object representing the class in Java</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The objects of class <code>jclassName</code> are used indirectly to be able
to create new Java objects via <code>new</code> such as
<code>new(J("java.lang.String"), "foo")</code> or to use the <code>$</code>
convenience operator on static classes, such as
<code>J("java.lang.Double")$parseDouble("10.2")</code>.
</p>

<dl>
<dt><code>as.character</code></dt><dd><p><code>signature(x = "jclassName")</code>:
returns the class name as a string vector of length one.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Simon Urbanek </p>


<h3>See Also</h3>

<p><code><a href="#topic+J">J</a></code>, <code><a href="methods.html#topic+new">new</a></code>
</p>

<hr>
<h2 id='jengine'>
Java callback engineCast a Java object to another class
</h2><span id='topic+.jengine'></span>

<h3>Description</h3>

<p><code>.jengine</code> obtains the current callback engine or starts it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jengine(start=FALSE, silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jengine_+3A_start">start</code></td>
<td>
<p>if set to <code>TRUE</code> then the callback engine is started
if it is not yet active</p>
</td></tr>
<tr><td><code id="jengine_+3A_silent">silent</code></td>
<td>
<p>if set to <code>TRUE</code> then NULL is returned if there is
no engine available. Otherwise an error is raised</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.jengine</code> can be used to detect whether the engine was started
or to start the engine.
</p>
<p>Before any callbacks from Java into R can be performed, the Java
callback engine must be initialized, loading Java/R Interface
(JRI). If JRI was not started and <code>start</code> is set to <code>TRUE</code>
then <code>.jengine</code> will load necessary classes and start
it.
</p>
<p>Note that JRI is an optional part of rJava and requires R shared
library at the moment. By default rJava will continue with
installation even if JRI cannot be built.
</p>


<h3>Value</h3>

<p>Returns a Java object reference (<code>jobjRef</code>) to the current Java
callback engine.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
.jengine(TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='jequals'>
Comparing Java References
</h2><span id='topic+.jequals'></span><span id='topic+.jcompare'></span><span id='topic++21+3D+2CANY+2CjobjRef-method'></span><span id='topic++21+3D+2CjobjRef+2CjobjRef-method'></span><span id='topic++21+3D+2CjobjRef+2CANY-method'></span><span id='topic++3D+3D+2CANY+2CjobjRef-method'></span><span id='topic++3D+3D+2CjobjRef+2CjobjRef-method'></span><span id='topic++3D+3D+2CjobjRef+2CANY-method'></span><span id='topic++3C+2CANY+2CjobjRef-method'></span><span id='topic++3C+2CjobjRef+2CjobjRef-method'></span><span id='topic++3C+2CjobjRef+2CANY-method'></span><span id='topic++3E+2CANY+2CjobjRef-method'></span><span id='topic++3E+2CjobjRef+2CjobjRef-method'></span><span id='topic++3E+2CjobjRef+2CANY-method'></span><span id='topic++3C+3D+2CANY+2CjobjRef-method'></span><span id='topic++3C+3D+2CjobjRef+2CjobjRef-method'></span><span id='topic++3C+3D+2CjobjRef+2CANY-method'></span><span id='topic++3E+3D+2CANY+2CjobjRef-method'></span><span id='topic++3E+3D+2CjobjRef+2CjobjRef-method'></span><span id='topic++3E+3D+2CjobjRef+2CANY-method'></span>

<h3>Description</h3>

<p><code>.jequals</code> function can be used to determine whether two objects
are equal. In addition, it allows mixed comparison of non-Java object
for convenience, unless strict comparison is desired.
</p>
<p>The binary operators <code>==</code> and <code>!=</code> are mapped to
(non-strict) call to <code>.jequals</code> for convenience.
</p>
<p><code>.jcompare</code> compares two objects in the sense of the 
<code>java.lang.Comparable</code> interface. 
</p>
<p>The binary operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are mapped 
to calls to <code>.jcompare</code> for convenience
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jequals(a, b, strict = FALSE)
.jcompare( a, b )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jequals_+3A_a">a</code></td>
<td>
<p>first object</p>
</td></tr>
<tr><td><code id="jequals_+3A_b">b</code></td>
<td>
<p>second object</p>
</td></tr>
<tr><td><code id="jequals_+3A_strict">strict</code></td>
<td>
<p>when set to <code>TRUE</code> then non-references save for
<code>NULL</code> are always treated as different, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.jequals</code> compares two Java objects by calling <code>equals</code>
method of one of the objects and passing the other object as its
argument. This allows Java objects to define the &lsquo;equality&rsquo; in
object-dependent way.
</p>
<p>In addition, <code>.jequals</code> allows the comparison of Java object to
other scalar R objects. This is done by creating a temporary Java
object that corresponds to the R object and using it for a call to the
<code>equals</code> method. If such conversion is not possible a warning is
produced and the result it <code>FALSE</code>. The automatic conversion
will be avoided if <code>strict</code> parameter is set to <code>TRUE</code>.
</p>
<p><code>NULL</code> values in <code>a</code> or <code>b</code> are replaced by Java
<code>null</code>-references and thus <code>.jequals(NULL,NULL)</code> is <code>TRUE</code>.
</p>
<p>If neither <code>a</code> and <code>b</code> are Java objects (with the exception
of both being <code>NULL</code>) then the result is identical to that of
<code>all.equal(a,b)</code>.
</p>
<p>Neither comparison operators nor <code>.jequals</code> supports vectors and
returns <code>FALSE</code> in that case. A warning is also issued unless
strict comparison was requested.
</p>


<h3>Value</h3>

<p><code>.jequals</code> returns <code>TRUE</code> if both object 
are considered equal, <code>FALSE</code> otherwise.
</p>
<p><code>.jcompare</code> returns the result of the <code>compareTo</code> java method
of the object a applied to b
</p>


<h3>Methods</h3>


<dl>
<dt>!=</dt><dd><p><code>signature(e1 = "ANY", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>!=</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>!=</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "ANY")</code>: ... </p>
</dd>
<dt>==</dt><dd><p><code>signature(e1 = "ANY", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>==</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>==</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "ANY")</code>: ... </p>
</dd>
<dt>&lt;</dt><dd><p><code>signature(e1 = "ANY", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&lt;</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&lt;</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "ANY")</code>: ... </p>
</dd>
<dt>&gt;</dt><dd><p><code>signature(e1 = "ANY", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&gt;</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&gt;</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "ANY")</code>: ... </p>
</dd>
<dt>&gt;=</dt><dd><p><code>signature(e1 = "ANY", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&gt;=</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&gt;=</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "ANY")</code>: ... </p>
</dd>
<dt>&lt;=</dt><dd><p><code>signature(e1 = "ANY", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&lt;=</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "jobjRef")</code>: ... </p>
</dd>
<dt>&lt;=</dt><dd><p><code>signature(e1 = "jobjRef", e2 = "ANY")</code>: ... </p>
</dd>
</dl>



<h3>Note</h3>

<p>Don't use <code>x == NULL</code> to check for
<code>null</code>-references, because <code>x</code> could be <code>NULL</code> and thus
the result would be an empty vector. Use <code><a href="#topic+is.jnull">is.jnull</a></code>
instead.
(In theory <code>is.jnull</code> and <code>x == .jnull()</code> are the the same,
but <code>is.jnull</code> is more efficient.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.jnull">is.jnull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s &lt;- .jnew("java/lang/String", "foo")
.jequals(s, "foo") # TRUE
.jequals(s, "foo", strict=TRUE) # FALSE - "foo" is not a Java object
t &lt;- s
.jequals(s, t, strict=TRUE) # TRUE

s=="foo" # TRUE



Double &lt;- J("java.lang.Double")
d1 &lt;- new( Double, 0.0 ) 
d2 &lt;- new( Double, 1.0 )
d3 &lt;- new( Double, 0.0 )

d1 &lt; d2
d1 &lt;= d3
d1 &gt;= d3
d1 &gt; d2

# cannot compare a Double and a String
try( d1 &lt; "foo" )

# but can compare a Double and an Integer
d1 &lt; 10L




</code></pre>

<hr>
<h2 id='jfield'>
Obtains the value of a field
</h2><span id='topic+.jfield'></span><span id='topic+.jfield+3C-'></span>

<h3>Description</h3>

<p><code>.jfield</code> returns the value of the specified field on an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jfield(o, sig = NULL, name, true.class = is.null(sig), convert = TRUE)
`.jfield&lt;-`(o, name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jfield_+3A_o">o</code></td>
<td>
<p>Class name or object (Java reference) whose field is to be
accessed. Static fields are supported both by specifying the class
name or using an instance.</p>
</td></tr>
<tr><td><code id="jfield_+3A_sig">sig</code></td>
<td>
<p>signature (JNI type) of the field. If set to <code>NULL</code>
rJava attempts to determine the signature using reflection. For
efficiency it is recommended to specify the signature, because
the reflection lookup is quite expensive.</p>
</td></tr>
<tr><td><code id="jfield_+3A_name">name</code></td>
<td>
<p>name of the field to access</p>
</td></tr>
<tr><td><code id="jfield_+3A_true.class">true.class</code></td>
<td>
<p>by default the class of the resulting object matches
the signature of the field. Setting this flag to <code>TRUE</code> causes
<code>.jfield</code> to use true class name of the resulting object
instead. (this flag has no effect on scalar fields)</p>
</td></tr>
<tr><td><code id="jfield_+3A_convert">convert</code></td>
<td>
<p>when set to <code>TRUE</code> all references are converted to
native types (where possible). Otherwise Java references are
returned directly.</p>
</td></tr>
<tr><td><code id="jfield_+3A_value">value</code></td>
<td>
<p>value to assign into the field. The field signature is
determined from the value in the same way that parameter signatures
are determined in <code><a href="#topic+.jcall">.jcall</a></code> - be sure to cast the value
as necessary, no automatic conversion is done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The detection of a field signature in <code>.jfield</code> using reflection
is considerably expensive (more than 3 additional method calls have to
be performed), therefore it is recommended for time-critical code to
specify the field signature beforehand.
</p>
<p>NOTE: The sequence of arguments in <code>.jfield</code> has been changed
since rJava 0.5 to be more consistent and match the sequence in
<code>.jcall</code>. Also <code>.jsimplify</code> is no longer needed as primitive
types are obtained directly.
</p>


<h3>Value</h3>

<p><code>.jfield</code>: contents of the field, <code>.jfield&lt;-</code>: modified object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
.jfield("java/lang/Boolean",, "TYPE")

## End(Not run)
</code></pre>

<hr>
<h2 id='jfloat'>
Wrap numeric vector as flat Java parameter
</h2><span id='topic+.jfloat'></span><span id='topic+.jlong'></span><span id='topic+.jbyte'></span><span id='topic+.jchar'></span><span id='topic+.jshort'></span><span id='topic+jfloat'></span><span id='topic+jlong'></span><span id='topic+jbyte'></span><span id='topic+jchar'></span><span id='topic+jshort'></span>

<h3>Description</h3>

<p><code>.jfloat</code> marks a numeric vector as an object that can be used
as parameter to Java calls that require <code>float</code> parameters.
Similarly, <code>.jlong</code> marks a numeric vector as <code>long</code>
parameter, <code>.jshort</code> as <code>short</code> and <code>.jbyte</code> as
<code>byte</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jfloat(x)
.jlong(x)
.jbyte(x)
.jchar(x)
.jshort(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jfloat_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R has no native <code>float</code> or <code>long</code> type. Numeric vectors are
stored as <code>double</code>s, hence there is no native way to pass float
numbers to Java methods. The <code>.jfloat</code> call marks a numeric
vector as having the Java type <code>float</code> by wrapping it in the
<code>jfloat</code> class. The class is still a subclass of <code>numeric</code>,
therefore all regular R operations are unaffected by this.
</p>
<p>Similarly, <code>.jlong</code> is used to mark a numeric vector as a
parameter of the <code>long</code> Java type. Please note that in general R
has no native type that will hold a <code>long</code> value, so conversion
between Java's <code>long</code> type and R's numeric is potentially lossy.
</p>
<p><code>.jbyte</code> is used when a scalar byte is to be passed to Java. Note
that byte arrays are natively passed as raw vectors, not as
<code>.jbyte</code> arrays, although non-scalar <code>.jbyte</code> is equivalent
except for using four-times as much memory.
</p>
<p><code>.jchar</code> is strictly experimental and uses integer vector as
storage class. The type <code>char</code> in Java
represents 16-bit Unicode code points (not to be confused with
<code>char</code> in C which is <code>byte</code> in Java!), see Java
documentation for details. <code>x</code> can also be a non-<code>NA</code> string
in which case <code>.jchar(x)</code> is just a shorthand for
<code>.jnew("java.lang.String", x)$toCharArray()</code> and thus performs a
Java call (unlike all other functions mentioned here).
</p>


<h3>Value</h3>

<p>Returns a numeric vector of the class <code>jfloat</code>, <code>jlong</code>,
<code>jbyte</code>, <code>jshort</code> or <code>jchar</code>
that can be used as parameter to Java calls that require
<code>float</code>, <code>long</code>, <code>byte</code>, <code>short</code> or <code>char</code>
parameters respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>, <code><a href="#topic+jfloat-class">jfloat-class</a></code>
</p>

<hr>
<h2 id='jfloat-class'>Classes &quot;jfloat&quot;, &quot;jlong&quot;, &quot;jbyte&quot; and &quot;jchar&quot; specify Java
native types that are not native in R</h2><span id='topic+jfloat-class'></span><span id='topic+jlong-class'></span><span id='topic+jbyte-class'></span><span id='topic+jchar-class'></span>

<h3>Description</h3>

<p> These classes wrap a numeric vector to be treated as
<code>float</code> or <code>long</code> argument when passed to Java and an
integer vector to be treated as <code>byte</code> or <code>char</code>. R doesn't
distinguish between <code>double</code> and <code>float</code>, but Java
does. In order to satisfy object types, numeric vectors that should be
converted to floats or long on the Java side must be wrapped in this
class. In addition <code>jbyte</code> must be used when passing scalar byte
(but not byte arrays, those are mapped into RAW vectors). Finally
<code>jchar</code> it used when mapping integer vectors into unicode Java
character vectors.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calling <code><a href="#topic+.jfloat">.jfloat</a></code>,
<code><a href="#topic+.jlong">.jlong</a></code>, <code><a href="#topic+.jbyte">.jbyte</a></code> or <code><a href="#topic+.jchar">.jchar</a></code>
respectively.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Payload</p>
</dd>
</dl>



<h3>Extends</h3>

<p>&quot;jfloat&quot; and &quot;jlong&quot;:
Class <code>"numeric"</code>, from data part.
Class <code>"vector"</code>, by class <code>"numeric"</code>.
</p>
<p>&quot;jbyte&quot; and &quot;jchar&quot;:
Class <code>"integer"</code>, from data part.
Class <code>"vector"</code>, by class <code>"integer"</code>.
</p>


<h3>Methods</h3>

<p>&quot;jfloat&quot; and &quot;jlong&quot; have no methods other than those inherited from &quot;numeric&quot;.
&quot;jbyte&quot; and &quot;jchar&quot; have no methods other than those inherited from &quot;integer&quot;.
</p>


<h3>Author(s)</h3>

<p> Simon Urbanek </p>


<h3>See Also</h3>

<p><code><a href="#topic+.jfloat">.jfloat</a></code>, <code><a href="#topic+.jlong">.jlong</a></code>, <code><a href="#topic+.jbyte">.jbyte</a></code>, <code><a href="#topic+.jchar">.jchar</a></code> and <code><a href="#topic+.jcall">.jcall</a></code>
</p>

<hr>
<h2 id='jinit'>
Initialize Java VM
</h2><span id='topic+.jinit'></span><span id='topic+.jvmState'></span>

<h3>Description</h3>

<p><code>.jinit</code> initializes the Java Virtual Machine (JVM). This
function must be called before any rJava functions can be used.
</p>
<p><code>.jvmState() returns the state of the current JVM.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jinit(classpath = NULL, parameters = getOption("java.parameters"), ...,
silent = FALSE, force.init = FALSE)
.jvmState()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jinit_+3A_classpath">classpath</code></td>
<td>
<p>Any additional classes to include in the Java class
paths (i.e. locations of Java classes to use). This path will be
prepended to paths specified in the <code>CLASSPATH</code> environment
variable. Do NOT set this system class path initializing a package,
use <code><a href="#topic+.jpackage">.jpackage</a></code> instead, see details.</p>
</td></tr>
<tr><td><code id="jinit_+3A_parameters">parameters</code></td>
<td>
<p>character vector of parameters to be passed to
the virtual machine. They are implementation dependent and apply
to JDK version 1.2 or higher only. Please note that each parameter
must be in a separate element of the array, you cannot use a
space-separated string with multiple parameters.</p>
</td></tr>
<tr><td><code id="jinit_+3A_...">...</code></td>
<td>
<p>Other optional Java initialization parameters (implementation-dependent).</p>
</td></tr>
<tr><td><code id="jinit_+3A_silent">silent</code></td>
<td>
<p>If set to <code>TRUE</code> no warnings are issued.</p>
</td></tr>
<tr><td><code id="jinit_+3A_force.init">force.init</code></td>
<td>
<p>If set to <code>TRUE</code> JVM is re-initialized even if
it is already running.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting with version 0.5 rJava provides a custom class loader that can
automatically track classes and native libraries that are provided in
R packages. Therefore R packages should NOT use <code>.jinit</code>, but
call <code><a href="#topic+.jpackage">.jpackage</a></code> instead. In addition this allows the use
of class path modifying function <code><a href="#topic+.jaddClassPath">.jaddClassPath</a></code>.
</p>
<p>Important note: if a class is found on the system class path (i.e. on
the <code>classpath</code> specified to <code>.jinit</code>) then the system class
loader is used instead of the rJava loader, which can lead to problems
with reflection and native library support is not enabled. Therefore
it is highly recommended to use <code>.jpackage</code> or
<code>.jaddClassPath</code> instead of <code>classpath</code> (save for system
classes).
</p>
<p>Stating with version 0.3-8 rJava is now capable of modifying the class
path on the fly for certain Sun-based Java virtual machines, even when
attaching to an existing VM. However, this is done by exploiting the
way ClassLoader is implemented and may fail in the future. In general
it is officially not possible to change the class path of a running
VM.
</p>
<p>At any rate, it is impossible to change any other VM parameters of a
running VM, so when using <code>.jinit</code> in a package, be generous with
limits and don't use VM parameters to unnecessarily restrict
resources (or preferably use <code><a href="#topic+.jpackage">.jpackage</a></code> instead). JVM
parameters can only be set if the initial state of the JVM is
<code>"none"</code>.
</p>
<p>There is a subtle difference between <code>"initialized"</code> and the JVM
state. It is in theory possible for <code>"initialized"</code> to be
<code>FALSE</code> and still <code>"state"</code> to be <code>"created"</code> or
<code>"attached"</code> in case where JVM was created but rJava has not been
able to initialize for other reasons, although such state should be
rare and problematic in either case. Behavior of rJava functions other
than <code>.jinit</code> and <code>.jvmState</code> is undefined unless
<code>.jvmState()$initialized</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>The return value is an integer specifying whether and how the VM was
initialized. Negative values indicate failure, zero denotes successful
initialization and positive values signify partially successful
initilization (i.e. the VM is up, but parameters or class path could
not be set due to an existing or incompatible VM).
</p>
<p><code>.jvmState</code> returns a named list with at least the following
elements:
</p>
<table>
<tr><td><code>initialized</code></td>
<td>
<p><code>TRUE</code> if rJava is initialized and has a
runing JVM, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>string representing the current state of the JVM. One of
the following values:
<code>"none"</code> if there is no JVM, <code>"created"</code> if the current
JVM has been created by rJava, <code>"attached"</code> if rJava attached
into an existing JVM (typically when R is embedded into a running
JVM via JRI), <code>"detached"</code> if there is a JVM (such as embedded
R), but rJava has not been initialized to use it, <code>"dead"</code> if
the process is about to die due to the JVM forcing en exit or
<code>"destroyed"</code> if a JVM existed before, but was destroyed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+.jpackage">.jpackage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## set heap size limit to 512MB (see java -X) and
## use "myClasses.jar" as the class path
.jinit(classpath="myClasses.jar", parameters="-Xmx512m")
.jvmState()

## End(Not run)
</code></pre>

<hr>
<h2 id='jmemprof'>
rJava memory profiler
</h2><span id='topic+.jmemprof'></span>

<h3>Description</h3>

<p><code>.jmemprof</code> enables or disables rJava memory profiling. If rJava
was compiled without memory profiling support, then a call to this
function always causes an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jmemprof(file = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jmemprof_+3A_file">file</code></td>
<td>
<p>file to write profiling information to or <code>NULL</code> to
disable profiling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>file</code> parameter must be either a filename (which will be
opened in append-mode) or &quot;-&quot; to use standard output or <code>NULL</code> to
disable profiling. An empty string &quot;&quot; is equivalent to <code>NULL</code> in
this context.
</p>
<p>Note that lots of finalizers are run only when R exists, so usually
you want to enable profiling early and let R exit to get a sensible
profile. Running gc may be helpful to get rid of references that can
be collected in R.
</p>
<p>A simple perl script is provided to analyze the result of the
profiler. Due to its simple text format, it is possible to capture
entire stdout including the profiler information to have both the
console context for the allocations and the profile. Memory profiling
is also helpful if rJava debug is enabled.
</p>
<p>Note that memory profiling support must be compiled in rJava and it is
by default compiled only if debug mode is enabled (which is not the
case by default).
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## memory profiling support is optional so only works when enabled
tryCatch(
.jmemprof("rJava.mem.profile.txt"),
error=function(e) message(e))
</code></pre>

<hr>
<h2 id='jnew'>
Create a Java object
</h2><span id='topic+.jnew'></span>

<h3>Description</h3>

<p><code>.jnew</code> create a new Java object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jnew(class, ..., check=TRUE, silent=!check, class.loader=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jnew_+3A_class">class</code></td>
<td>
<p>fully qualified class name in JNI notation (e.g. <code>"java/lang/String"</code>).</p>
</td></tr>
<tr><td><code id="jnew_+3A_...">...</code></td>
<td>

<p>Any parameters that will be passed to the corresponding
constructor. The parameter types are determined automatically and/or
taken from the <code>jobjRef</code> object. For details see
<code><a href="#topic+.jcall">.jcall</a></code>. Note that all named parameters are discarded.</p>
</td></tr>
<tr><td><code id="jnew_+3A_check">check</code></td>
<td>

<p>If set to <code>TRUE</code> then <code><a href="#topic+.jcheck">.jcheck</a></code> is invoked before
and after the call to the constructor to clear any pending Java
exceptions.</p>
</td></tr>
<tr><td><code id="jnew_+3A_silent">silent</code></td>
<td>

<p>If set to <code>FALSE</code> then <code>.jnew</code> will fail with an error if
the object cannot be created, otherwise a null-reference is returned
instead. In addition, this flag is also passed to final
<code>.jcheck</code> if <code>check</code> above is set to <code>TRUE</code>. Note
that the error handling also clears exceptions, so
<code>check=FALSE, silent=FALSE</code> is usually not a meaningful
combination.
</p>
</td></tr>
<tr><td><code id="jnew_+3A_class.loader">class.loader</code></td>
<td>
<p>optional class loader to force for loading the
class. If not set, the rJava class loader is used first. The default
Java class loader is always used as a last resort. Set to
<code>.rJava.class.loader</code> inside a package if it uses its own class
loader (see <code><a href="#topic+.jpackage">.jpackage</a></code> for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the reference (<code>jobjRef</code>) to the newly created object or
<code>null</code>-reference (see <code><a href="#topic+.jnull">.jnull</a></code>) if something went wrong.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>, <code><a href="#topic+.jnull">.jnull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f &lt;- .jnew("java/awt/Frame","Hello")
.jcall(f,,"setVisible",TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='jnull'>
Java null object reference
</h2><span id='topic+.jnull'></span><span id='topic+is.jnull'></span>

<h3>Description</h3>

<p><code>.jnull</code> returns a <code>null</code> reference of a specified class
type. The resulting object is of the class <code>jobjRef</code>.
</p>
<p><code>is.jnull</code> is an extension of <code>is.null</code> that also returns
<code>TRUE</code> if the supplied object is a <code>null</code> Java reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jnull(class = "java/lang/Object")
is.jnull(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jnull_+3A_class">class</code></td>
<td>
<p>fully qualified target class name in JNI notation
(e.g. <code>"java/lang/String"</code>).</p>
</td></tr>
<tr><td><code id="jnull_+3A_x">x</code></td>
<td>
<p>object to check</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.jnull</code> is necessary if <code>null</code> is to be passed as an
argument of <code><a href="#topic+.jcall">.jcall</a></code> or <code><a href="#topic+.jnew">.jnew</a></code>, in order to be
able to find the correct method/constructor.
</p>
<p>Example: given the following method definitions of the class <code>A</code>:
</p>

<ul>
<li> <p><code>public static void run(String a);</code>
</p>
</li>
<li> <p><code>public static void run(Double n);</code>
</p>
</li></ul>

<p>Calling <code>.jcall("A",,"run",NULL)</code> is ambiguous, because it is
unclear which method is to be used. Therefore rJava requires class
information with each argument to <code><a href="#topic+.jcall">.jcall</a></code>. If we wanted
to run the String-version, we could use
<code>.jcall("A",,"run",.jnull("java/lang/String"))</code>.
</p>
<p><code>is.jnull</code> is a test that should be used to determine whether a
given Java reference is a <code>null</code> reference.
</p>


<h3>Value</h3>

<p><code>.jnull</code> returns a Java object reference (<code>jobjRef</code>) of a
<code>null</code> object having the specified object class.
</p>
<p><code>is.jnull</code> returns <code>TRUE</code> if <code>is.null(x)</code> is
<code>TRUE</code> or if <code>x</code> is a Java <code>null</code> reference.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>, <code><a href="#topic+.jcast">.jcast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
.jcall("java/lang/System","I","identityHashCode",.jnull())

## End(Not run)
</code></pre>

<hr>
<h2 id='jobjRef-class'>Class &quot;jobjRef&quot; - Reference to a Java object </h2><span id='topic+jobjRef-class'></span>

<h3>Description</h3>

<p> This class describes a reference to an object held in a JavaVM. </p>


<h3>Objects from the Class</h3>

<p>Objects of this class should *not* be created directly. Instead, the function <code><a href="#topic+.jnew">.jnew</a></code> should be use to create new Java objects. They can also be created as results of the <code><a href="#topic+.jcall">.jcall</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>jobj</code>:</dt><dd><p>Internal identifier of the object (external pointer to be precise)</p>
</dd>
<dt><code>jclass</code>:</dt><dd><p>Java class name of the object (in JNI notation)</p>
</dd>
</dl>

<p>Java-side attributes are not accessed via slots, but the <code>$</code> operator instead.
</p>


<h3>Methods</h3>

<p>This object's Java methods are not accessed directly. Instead, <code><a href="#topic+.jcall">.jcall</a></code> JNI-API should be used for invoking Java methods. For convenience the <code>$</code> operator can be used to call methods via reflection API.
</p>


<h3>Author(s)</h3>

<p> Simon Urbanek </p>


<h3>See Also</h3>

<p><code><a href="#topic+.jnew">.jnew</a></code>, <code><a href="#topic+.jcall">.jcall</a></code>  or <code><a href="#topic+jarrayRef-class">jarrayRef-class</a></code>
</p>

<hr>
<h2 id='jpackage'>
Initialize an R package containing Java code
</h2><span id='topic+.jpackage'></span>

<h3>Description</h3>

<p><code>.jpackage</code> initializes the Java Virtual Machine (JVM) for an R
package. In addition to starting the JVM it also registers Java
classes and native code contained in the package with the JVM.
function must be called before any rJava functions can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jpackage(name, jars='*', morePaths='', nativeLibrary=FALSE,
          lib.loc=NULL, parameters = getOption("java.parameters"),
          own.loader = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jpackage_+3A_name">name</code></td>
<td>
<p>name of the package. It should correspond to the
<code>pkgname</code> parameter of <code>.onLoad</code> or <code>.First.lib</code>
function.</p>
</td></tr>
<tr><td><code id="jpackage_+3A_jars">jars</code></td>
<td>
<p>Java archives in the <code>java</code> directory of the package
that should be added to the class path. The paths must be relative
to package's <code>java</code> directory. A special value of
<code>'*'</code> adds all <code>.jar</code> files from the <code>java</code> the
directory.</p>
</td></tr>
<tr><td><code id="jpackage_+3A_morepaths">morePaths</code></td>
<td>
<p>vector listing any additional entries that should
be added to the class path.</p>
</td></tr>
<tr><td><code id="jpackage_+3A_nativelibrary">nativeLibrary</code></td>
<td>
<p>a logical determining whether rJava should look
for native code in the R package's shared object or not.</p>
</td></tr>
<tr><td><code id="jpackage_+3A_lib.loc">lib.loc</code></td>
<td>
<p>a character vector with path names of R libraries, or
<code>NULL</code> (see <code><a href="base.html#topic+system.file">system.file</a></code> and examples below).</p>
</td></tr>
<tr><td><code id="jpackage_+3A_parameters">parameters</code></td>
<td>
<p>optional JVM initialization parameters which will be
used if JVM is not initilized yet (see <code><a href="#topic+.jinit">.jinit</a></code>).</p>
</td></tr>
<tr><td><code id="jpackage_+3A_own.loader">own.loader</code></td>
<td>
<p>if <code>TRUE</code> then a new, separate class loader
will be initilized for the package and assigned to the
<code>.pkg.class.loader</code> variable in the package namespace. New
packages should make use of this feature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.jpackage</code> initializes a Java R package as follows: first the
JVM is initialized via <code><a href="#topic+.jinit">.jinit</a></code> (if it is not running
already). Then the <code>java</code> directory of the package is added to
the class path. Then <code>.jpackage</code> prepends <code>jars</code> with the
path to the <code>java</code> directory of the package and adds them to the
class path (or all <code>.jar</code> files if <code>'*'</code> was specified).
Finally the <code>morePaths</code> parameter (if set) is passed to a call
to <code><a href="#topic+.jaddClassPath">.jaddClassPath</a></code>.
</p>
<p>Therefore the easiest way to create a Java package is to add
<code>.jpackage(pkgname, lib.loc=libname)</code> in <code>.onLoad</code> or
<code>.First.lib</code>, and copy all necessary classes to a JAR file(s)
which is placed in the <code>inst/java/</code> directory of the source
package.
</p>
<p>If a package needs special Java parameters, <code>"java.parameters"</code>
option can be used to set them on initialization. Note, however, that
Java parameters can only be used during JVM initialization and other
package may have intialized JVM already.
</p>
<p>Since rJava 0.9-14 there is support of package-specific class
loaders using the <code>own.loader=TRUE</code> option. This is important for
packages that may be using classes that conflict with other packages
are therefore is highly recommended for new packages. Before this
feature, there was only one global class loader which means that the
class path was shared for all class look ups. If two packages
use the same (fully qualified) class name, even in a dependency, they
are likely to clash with each if they don't use exactly the same
version. Therefore it is safer for each package use use a private
class loader for its classes to guarantee that the only the classes
supplied with the package will be used. To do that, a package will set
<code>own.loader=TRUE</code> which instructs rJava to not change the global
loader, but instead create a separate one for the package and assign
it to <code>.rJava.class.loader</code> in the package namespace. Then if
package wants to instantiate a new class, it would use
<code>.jnew("myClass", class.loader=.rJava.class.loader)</code> to use its
own loader instead of the global one. The global loader's class path
won't be touched, so it won't find the package's classes. It is
possible to get the loader used in a package using
<code>.jclassLoader(package="foo")</code> which will return the global one if
the package has not registered its own. Similarly, to retrieve the
class path used by a package, one would use
<code>.jclassPath(.jclassLoader(package="foo"))</code>.
</p>
<p>Note that with the advent of multiple class loaders the value of the
<code>java.class.path</code> property is no longer meaningful as it can
reflect only one of the loaders.
</p>


<h3>Value</h3>

<p>The return value is an invisible TRUE if the initialization was successful.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jinit">.jinit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
.onLoad &lt;- function(libname, pkgname) {
  .jpackage(pkgname, lib.loc=libname, own.loader=TRUE)
  ## do not use, just an illustration of the concept:
  cat("my Java class path: ")
  print(.jclassPath(.jclassLoader(package=pkgname)))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='jrectRef-class'>Rectangular java arrays</h2><span id='topic+jrectRef-class'></span><span id='topic++5B+2CjrectRef-method'></span><span id='topic+length+2CjrectRef-method'></span><span id='topic+str+2CjrectRef-method'></span><span id='topic+dim+2CjrectRef-method'></span><span id='topic+dim+3C-+2CjrectRef-method'></span><span id='topic+unique+2CjrectRef-method'></span><span id='topic+duplicated+2CjrectRef-method'></span><span id='topic+anyDuplicated+2CjrectRef-method'></span><span id='topic+sort+2CjrectRef-method'></span><span id='topic+rev+2CjrectRef-method'></span><span id='topic+min+2CjrectRef-method'></span><span id='topic+max+2CjrectRef-method'></span><span id='topic+range+2CjrectRef-method'></span>

<h3>Description</h3>

<p>References to java arrays that are guaranteed to be rectangular, i.e similar
to R arrays</p>


<h3>Objects from the Class</h3>

<p>Objects of this class should *not* be created directly.
Instead, they usually come as a result of a java method call.
</p>


<h3>Slots</h3>


<dl>
<dt><code>jsig</code>:</dt><dd><p>JNI signature of the array type</p>
</dd>
<dt><code>jobj</code>:</dt><dd><p>Internal identifier of the object</p>
</dd>
<dt><code>jclass</code>:</dt><dd><p>Inherited from <code>jobjRef</code>, but unspecified</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>dimension vector of the array</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+jarrayRef-class">jarrayRef</a>"</code>, directly.
Class <code>"<a href="#topic+jobjRef-class">jobjRef</a>"</code>, by class &quot;jarrayRef&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>length</dt><dd><p><code>signature(x = "jrectRef")</code>: The number of elements in the array.
Note that if the array has more than one dimension,
it gives the number of arrays in the first dimension, and not the total
number of atomic objects in the array (like R does). This gives what would be
returned by <code>array.length</code> in java.</p>
</dd>
<dt>str</dt><dd><p><code>signature(object = "jrectRef")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "jrectRef")</code>: R indexing of rectangular java arrays </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "jrectRef")</code>: extracts the dimensions of the array </p>
</dd>
<dt>dim&lt;-</dt><dd><p><code>signature(x = "jrectRef")</code>: sets the dimensions of the array </p>
</dd>
<dt>unique</dt><dd><p><code>signature(x = "jrectRef")</code>: unique objects in the array</p>
</dd>
<dt>duplicated</dt><dd><p><code>signature(x = "jrectRef")</code>: see <code><a href="base.html#topic+duplicated">duplicated</a></code> </p>
</dd>
<dt>anyDuplicated</dt><dd><p><code>signature(x = "jrectRef")</code>: see <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code> </p>
</dd>
<dt>sort</dt><dd><p><code>signature(x = "jrectRef")</code>: returns a <em>new</em> array with elements from x in order </p>
</dd>
<dt>rev</dt><dd><p><code>signature(x = "jrectRef")</code>: returns a <em>new</em> array with elements from x reversed </p>
</dd>
<dt>min</dt><dd><p><code>signature(x = "jrectRef")</code>: the smallest object in the array (in the sense of the Comparable interface) </p>
</dd>
<dt>max</dt><dd><p><code>signature(x = "jrectRef")</code>: the biggest object in the array (in the sense of the Comparable interface) </p>
</dd>
<dt>range</dt><dd><p><code>signature(x = "jrectRef")</code>: the range of the array (in the sense of the Comparable interface) </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
v &lt;- new( J("java.util.Vector") )
v$add( "hello" )
v$add( "world" )
v$add( new( J("java.lang.Double"), "10.2" ) )
array &lt;- v$toArray()

array[ c(TRUE,FALSE,TRUE) ]
array[ 1:2 ]
array[ -3 ]

# length
length( array )


# also works as a pseudo field as in java
array$length




</code></pre>

<hr>
<h2 id='jreflection'>
Simple helper functions for Java reflection
</h2><span id='topic+.jmethods'></span><span id='topic+.jfields'></span><span id='topic+.jconstructors'></span>

<h3>Description</h3>

<p><code>.jconstructors</code> returns a character vector with all constructors for
a given class or object.
<code>.jmethods</code> returns a character vector with all methods for
a given class or object.
<code>.jfields</code> returns a character vector with all fields (aka attributes) for a given class or object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jconstructors(o, as.obj = FALSE, class.loader=.rJava.class.loader)
.jmethods(o, name = NULL, as.obj = FALSE, class.loader=.rJava.class.loader)
.jfields(o, name = NULL, as.obj = FALSE, class.loader=.rJava.class.loader)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jreflection_+3A_o">o</code></td>
<td>
<p>Name of a class (either notation is fine) or an object whose
class will be queried</p>
</td></tr>
<tr><td><code id="jreflection_+3A_name">name</code></td>
<td>
<p>string, regular expression of the method/field to look for</p>
</td></tr>
<tr><td><code id="jreflection_+3A_as.obj">as.obj</code></td>
<td>
<p>if <code>TRUE</code> then a list of Java objects is
returned, otherwise a character vector (obtained by calling
<code>toString()</code> on each entry).</p>
</td></tr>
<tr><td><code id="jreflection_+3A_class.loader">class.loader</code></td>
<td>
<p>optional, class loader to use for class look up if
needed (i.e., if <code>o</code> is a string)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There first two functions are intended to help with finding correct
signatures for methods and constructors. Since the low-level API in
rJava doesn't use reflection automatically, it is necessary to
provide a proper signature. That is somewhat easier using the above
methods.
</p>


<h3>Value</h3>

<p>Returns a character vector (if <code>as.obj</code> is <code>FALSE</code>) or a
list of Java objects. Each entry corresponds to the
<code>Constructor</code> resp. <code>Method</code> resp. <code>Field</code>
object. The string result is constructed by calling
<code>toString()</code> on the objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jcall">.jcall</a></code>, <code><a href="#topic+.jnew">.jnew</a></code>, <code><a href="#topic+.jcast">.jcast</a></code> or <code><a href="#topic++24+2CjobjRef-method">$,jobjRef-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
.jconstructors("java.util.Vector")
v &lt;- .jnew("java.util.Vector")
.jmethods(v, "add")

## End(Not run)
</code></pre>

<hr>
<h2 id='jserialize'>
Java object serialization
</h2><span id='topic+.jserialize'></span><span id='topic+.junserialize'></span><span id='topic+.jcache'></span>

<h3>Description</h3>

<p><code>.jserialize</code> serializes a Java object into raw vector using
Java serialization.
</p>
<p><code>.junserialize</code> re-constructs a Java object from its serialized
(raw-vector) form.
</p>
<p><code>.jcache</code> updates, retrieves or removes R-side object cache
which can be used for persistent storage of Java objects across
sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jserialize(o)
.junserialize(data)
.jcache(o, update=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jserialize_+3A_o">o</code></td>
<td>
<p>Java object</p>
</td></tr>
<tr><td><code id="jserialize_+3A_data">data</code></td>
<td>
<p>serialized Java object as a raw vector</p>
</td></tr>
<tr><td><code id="jserialize_+3A_update">update</code></td>
<td>
<p>must be <code>TRUE</code> (cache is updated), <code>FALSE</code>
(cache is retrieved) or <code>NULL</code> (cache is deleted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all Java objects support serialization, see Java documentation
for details. Note that Java serialization and serialization of R
objects are two entirely different mechanisms that cannot be
interchanged. <code>.jserialize</code> and <code>.junserialize</code> can
be used to access Java serialization facilities.
</p>
<p><code>.jcache</code> manipulates the R-side Java object cache associated
with a given Java reference:
</p>
<p>Java objects do not persist across sessions, because the Java
Virtual Machine (JVM) is destroyed when R is closed. All saved Java
object references will be restored as <code>null</code> references, since
the corresponding objects no longer exist (see R documentation on
serialization). However, it is possible to serialize a Java object
(if supported by the object) and store its serialized form in
R. This allows for the object to be deserialized when loaded into
another active session (but see notes below!)
</p>
<p>R-side cache consists of a serialized form of the object as raw
vector. This cache is attached to the Java object and thus will be
saved when the Java object is saved. rJava provides an automated way
of deserializing Java references if they are <code>null</code> references
and have a cache attached. This is done on-demand basis whenever a
reference to a Java object is required.
</p>
<p>Therefore packages can use <code>.jcache</code> to provide a way of
creating Java references that persist across sessions. However, they
must be very cautious in doing so. First, make sure the serialized
form is not too big. Storing whole datasets in Java serialized form
will hog immense amounts of memory on the R side and should be
avoided. In addition, be aware that the cache is just a snapshot, it
doesn't change when the referenced Java object is modified. Hence it
is most useful only for references that are not modified outside
R. Finally, internal references to other Java objects accessible
from R are not retained (see below). Most common use of
<code>.jcache</code> is with Java references that point to definitions of
methods (e.g., models) and other descriptive objects which are then
used by other, active Java classes to act upon. Caching of such
active objects is not a good idea, they should be instantiated by
functions that operate on the descriptive references instead.
</p>
<p><em>Important note:</em> the serialization of Java references does NOT
take into account any dependencies on the R side. Therefore if you
hold a reference to a Java object in R that is also referenced by
the serialized Java object on the Java side, then this relationship
cannot be retained upon restore. Instead, two copies of disjoint
objects will be created which can cause confusion and erroneous
behavior.
</p>
<p>The cache is attached to the reference external pointer and thus it
is shared with all copies of the same reference (even when changed
via <code><a href="#topic+.jcast">.jcast</a></code> etc.), but it is independent of other
references to the object obtained separately
(e.g., via <code><a href="#topic+.jcall">.jcall</a></code> or <code><a href="#topic+.jfield">.jfield</a></code>).
</p>
<p>Also note that deserialization (even automated one) requires a
running virtual machine. Therefore you must make sure that either
<code><a href="#topic+.jinit">.jinit</a></code> or <code><a href="#topic+.jpackage">.jpackage</a></code> is used before any
Java references are accessed.
</p>


<h3>Value</h3>

<p><code>.jserialize</code> returns a raw vector
</p>
<p><code>.junserialize</code> returns a Java object or <code>NULL</code> if an error
occurred (currently you may use <code>.jcheck()</code> to further
investigate the error)
</p>
<p><code>.jcache</code> returns the current cache (usually a raw vector) or
<code>NULL</code> if there is no cache.
</p>

<hr>
<h2 id='jsimplify'>
Converts Java object to a simple scalar if possible
</h2><span id='topic+.jsimplify'></span>

<h3>Description</h3>

<p><code>.jsimplify</code> attempts to convert Java objects that represent
simple scalars into corresponding scalar representation in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jsimplify(o, promote=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsimplify_+3A_o">o</code></td>
<td>
<p>arbitrary object</p>
</td></tr>
<tr><td><code id="jsimplify_+3A_promote">promote</code></td>
<td>
<p>logical, if <code>TRUE</code> then an ambiguous conversion
where the native type value would map to <code>NA</code> (e.g., Java
<code>int</code> type with value -2147483648) will be taken
to represent an actual value and will be promoted to a larger type
that can represent the value (in case of <code>int</code> promoted to
<code>double</code>). If <code>FALSE</code> then such values are assumed to
represent <code>NA</code>s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>o</code> is not a Java object reference, <code>o</code> is returned
as-is. If <code>o</code> is a reference to a scalar object (such as single
integer, number, string or boolean) then the value of that object is
returned as R vector of the corresponding type and length one.
</p>
<p>This function is used by <code><a href="#topic+.jfield">.jfield</a></code> to simplify the results
of field access if required.
</p>
<p>Currently there is no function inverse to this, the usual way to wrap
scalar values in Java references is to use <code><a href="#topic+.jnew">.jnew</a></code> as the
corresponding constructor.
</p>


<h3>Value</h3>

<p>Simple scalar or <code>o</code> unchanged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jfield">.jfield</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
i &lt;- .jnew("java/lang/Integer", as.integer(10))
print(i)
print(.jsimplify(i))

## End(Not run)
</code></pre>

<hr>
<h2 id='loader'>
Java Class Loader
</h2><span id='topic+.jaddClassPath'></span><span id='topic+.jclassPath'></span><span id='topic+.jclassLoader'></span>

<h3>Description</h3>

<p><code>.jaddClassPath</code> adds directories or JAR files to the class
path.
</p>
<p><code>.jclassPath</code> returns a vector containing the current entries in
the class path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jaddClassPath(path, class.loader=.rJava.class.loader)
.jclassPath(class.loader=.rJava.class.loader)
.jclassLoader(package=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loader_+3A_path">path</code></td>
<td>
<p>character string vector listing the paths to add to the
class path</p>
</td></tr>
<tr><td><code id="loader_+3A_class.loader">class.loader</code></td>
<td>
<p>Java class loader to use for the query of
madification. Defaults to global class loader.</p>
</td></tr>
<tr><td><code id="loader_+3A_package">package</code></td>
<td>
<p>string, name of a package or <code>NULL</code> for the global
class loader</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever a class needs to be instantiated in Java it is referred by
name which is used to locate a file with the bytecode for the
class. The mechanism to map a name to an actual bytecode to load ind
instantiate is habdled by the Java class loader. It typically keeps a
list of directories and JAR files to search for the class names.
</p>
<p>The <code>.jaddClassPath()</code> function allows the user to append new
locations to the list of places which will be searched. The function
<code>.jclassPath</code> retrieves the current sarch list from the loader.
</p>
<p>When rJava is initialized, it instantiates the global class loader
which is responsible for finding classes in functions such as
<code>.jnew()</code>. In addition to the global class loader, R packages can
create their own class loaders to avoid conflicts between packages
such that they can be sure to use their own files to look for
classes. See <code><a href="#topic+.jpackage">.jpackage</a></code> for details on how that works.
If the <code>package</code> argument is supplied <code>.jclassLoader</code> will
look in that package to see if it has a custom loader and will return
it, otherwise it returns the global loader. Note that is will fail with
an error when supplied a non-existing package name.
</p>
<p>If you want to trace issues related to missing classes, you can enable
debugging in the class loader by using the <code>setDebug</code> method, for
example: <code>.jclassLoader()$setDebug(1L)</code>
</p>


<h3>Value</h3>

<p><code>.jclassPath</code> returns a character vector listing the class path sequence.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.jpackage">.jpackage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
.jaddClassPath("/my/jars/foo.jar","/my/classes/")
print(.jclassPath())

## End(Not run)
</code></pre>

<hr>
<h2 id='new'>
Create a new Java object
</h2><span id='topic+new+2CjclassName-method'></span>

<h3>Description</h3>

<p>Creates a new Java object and invokes the constructor with given arguments.
</p>


<h3>Details</h3>

<p>The <code>new</code> method is used as the high-level API to create new
Java objects (for low-level access see <code><a href="#topic+.jnew">.jnew</a></code>). It
returns the newly created Java object.
</p>
<p><code>...</code> arguments are passed to the constructor of the class
specified as <code>J("class.name")</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new</code></dt><dd><p><code>signature(Class = "jclassName")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+.jnew">.jnew</a></code>, <code><a href="#topic+jclassName-class">jclassName-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
v &lt;- new(J("java.lang.String"), "Hello World!")
v$length()
v$indexOf("World")
names(v)

## End(Not run)
</code></pre>

<hr>
<h2 id='rep'>Creates java arrays by cloning</h2><span id='topic+rep+2CjarrayRef-method'></span><span id='topic+rep+2CjobjRef-method'></span><span id='topic+rep+2CjrectRef-method'></span>

<h3>Description</h3>

 
<p>Creates a java array by cloning a reference several times
</p>


<h3>Methods</h3>


<dl>
<dt>rep</dt><dd><p><code>signature(object = "jobjRef")</code>: ... </p>
</dd>
<dt>rep</dt><dd><p><code>signature(object = "jarrayRef")</code>: ... </p>
</dd>
<dt>rep</dt><dd><p><code>signature(object = "jrectRef")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep</a></code> or <code><a href="#topic+.jarray">.jarray</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (!nzchar(Sys.getenv("NOAWT"))) {
  p &lt;- .jnew( "java.awt.Point" )
  a &lt;- rep( p, 10 )

  stopifnot( dim(a) == c(10L ) )
  a[[1]]$move( 10L, 50L )
  stopifnot( a[[2]]$getX() == 0.0 )
}
</code></pre>

<hr>
<h2 id='rJava-internal'>
Internal functions and constants
</h2><span id='topic+rJava-internal'></span><span id='topic+.jaddLibrary'></span><span id='topic+.jclass'></span><span id='topic+.jclass.boolean'></span><span id='topic+.jclass.double'></span><span id='topic+.jclass.float'></span><span id='topic+.jclass.int'></span><span id='topic+.jclass.void'></span><span id='topic+.jclassClass'></span><span id='topic+.jclassObject'></span><span id='topic+.jclassRef'></span><span id='topic+.jclassString'></span><span id='topic+.jfindClass'></span><span id='topic+.jfirst'></span><span id='topic+.jidenticalRef'></span><span id='topic+.jinherits'></span><span id='topic+.jinit.merge.error'></span><span id='topic+.jmergeClassPath'></span><span id='topic+.jmkref'></span><span id='topic+.jniInitialized'></span><span id='topic+.joptions'></span><span id='topic+.jproperty'></span><span id='topic+.jrcall'></span><span id='topic+.jrmLibrary'></span><span id='topic+.jsetJConvertor'></span><span id='topic+.jsetRConvertor'></span><span id='topic+.jstrVal'></span><span id='topic+.jzeroRef'></span><span id='topic+.r2j'></span><span id='topic+.rJava.base.path'></span>

<h3>Description</h3>

<p>The following functions are either internal or are not officially part
of the API and therefore may changes in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.jaddLibrary(name, path, class.loader = .rJava.class.loader) 
.jclass(o, true = TRUE) 
.jclassRef(x, silent = FALSE) 
.jfindClass(cl, silent = FALSE, class.loader = .rJava.class.loader) 
.jfirst(libname, pkgname) 
.jidenticalRef(a, b) 
.jinherits(o, cl, class.loader = .rJava.class.loader) 
.jmergeClassPath(cp) 
.jmkref(jobj, jclass = "java/lang/Object") 
.joptions(...) 
.jproperty(key) 
.jrcall(o, method, ..., simplify = TRUE, class.loader = .rJava.class.loader) 
.jrmLibrary(name) 
.jsetJConvertor(java.class, fn) 
.jsetRConvertor(r.class, fn) 
.jstrVal(obj) 
.r2j(x, engine = NULL, convert = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rJava-internal_+3A_name">name</code></td>
<td>
<p>string, name of the library</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_path">path</code></td>
<td>
<p>string, path</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_class.loader">class.loader</code></td>
<td>
<p>class loader object</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_o">o</code></td>
<td>
<p>Java object</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_x">x</code></td>
<td>
<p>Java object</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_cl">cl</code></td>
<td>
<p>string, class name (or Java class name object)</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_libname">libname</code></td>
<td>
<p>string, library location</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_pkgname">pkgname</code></td>
<td>
<p>string, package name</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_a">a</code></td>
<td>
<p>Java object</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_b">b</code></td>
<td>
<p>Java object</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_cp">cp</code></td>
<td>
<p>string, class path</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_jobj">jobj</code></td>
<td>
<p>Java object</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_simplify">simplify</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_java.class">java.class</code></td>
<td>
<p>string, class name</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_fn">fn</code></td>
<td>
<p>convertor function</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_r.class">r.class</code></td>
<td>
<p>string, R class</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_obj">obj</code></td>
<td>
<p>Java object</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_engine">engine</code></td>
<td>
<p>Java engine object, if <code>NULL</code> uses the main engine</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_convert">convert</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="rJava-internal_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='show'>Show a Java Object Reference</h2><span id='topic+show+2CjobjRef-method'></span><span id='topic+str+2CjobjRef-method'></span><span id='topic+show+2CjarrayRef-method'></span><span id='topic+show+2CjclassName-method'></span>

<h3>Description</h3>

<p>Display a Java object reference in a descriptive, textual form. The
default implementation calls <code>toString</code> Java method to obtain
object's printable value and uses calls <code>show</code> on the resulting
string garnished with additional details.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "jobjRef")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "jarrayRef")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "jclassName")</code>: ... </p>
</dd>
<dt>str</dt><dd><p><code>signature(object = "jobjRef")</code>: currently identical to show </p>
</dd>
</dl>


<hr>
<h2 id='toJava'>
Convert R objects to REXP references in Java
</h2><span id='topic+toJava'></span>

<h3>Description</h3>

<p><code>toJava</code> takes an R object and creates a reference to that object
in Java. This reference can then be passed to Java methods such that
they can refer to it back in R. This is commonly used to pass functions
to Java such that Java code can call those functions later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toJava(x, engine = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toJava_+3A_x">x</code></td>
<td>
<p>R object to reference. It can be any R object and it will be
retained at least for the duration of the reference on the Java side.</p>
</td></tr>
<tr><td><code id="toJava_+3A_engine">engine</code></td>
<td>
<p>REngine in which the reference is to be created. If
&lt;code&gt;null&lt;/code&gt; then the last created engine is used. This must be
a Java object and a subclass of org.rosuda.REngine (and NOT the old
org.rosuda.JRI.Rengine!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There result is a Java reference (<code>jobjRef</code>) of the Java class
<code>REXPReference</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  .jinit()
  # requires JRI and REngine classes
  .jengine(TRUE)
  f &lt;- function() { cat("Hello!\n"); 1 }
  fref &lt;- toJava(f)
  # to use this in Java you would use something like:
  # public static REXP call(REXPReference fn) throws REngineException, REXPMismatchException {
  #	 return fn.getEngine().eval(new REXPLanguage(new RList(new REXP[] { fn })), null, false);
  # }
  # .jcall("Call","Lorg/rosuda/REngine/REXP;","call", fref)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='with.jobjRef'>
with and within methods for Java objects and class names
</h2><span id='topic+with.jobjRef'></span><span id='topic+within.jobjRef'></span><span id='topic+with.jarrayRef'></span><span id='topic+within.jarrayRef'></span><span id='topic+with.jclassName'></span><span id='topic+within.jclassName'></span>

<h3>Description</h3>

<p>Convenience wrapper that allow calling methods of 
Java object and classes from within the object (or class).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jobjRef'
with(data, expr, ...)
## S3 method for class 'jobjRef'
within(data, expr, ...)

## S3 method for class 'jarrayRef'
with(data, expr, ...)
## S3 method for class 'jarrayRef'
within(data, expr, ...)

## S3 method for class 'jclassName'
with(data, expr, ...)
## S3 method for class 'jclassName'
within(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.jobjRef_+3A_data">data</code></td>
<td>

<p>A Java object reference or a java class name. See <code><a href="#topic+J">J</a></code>
</p>
</td></tr>
<tr><td><code id="with.jobjRef_+3A_expr">expr</code></td>
<td>

<p>R expression to evaluate
</p>
</td></tr>
<tr><td><code id="with.jobjRef_+3A_...">...</code></td>
<td>

<p>ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression is evaluated in an environment 
that contains a mapping between the public fields 
and methods of the object. 
</p>
<p>The methods of the object are mapped to standard R functions
in the environment. In case of classes, only static methods
are used.
</p>
<p>The fields of the object are mapped to active bindings
(see <a href="base.html#topic+makeActiveBinding">makeActiveBinding</a>) so that they can be accessed
and modified from within the environment. For classes, only 
static fields are used.
</p>


<h3>Value</h3>

<p><code>with</code> returns the value of the expression and 
<code>within</code> returns the <code>data</code> argument
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>References</h3>

<p>the <code>java.lang.reflect</code> package: 
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (!nzchar(Sys.getenv("NOAWT"))) {
  p &lt;- .jnew( "java/awt/Point", 0L, 0L )
  with( p, {
	# x and y and now 0
	move( 10L, 10L )
	# x and y are now 10
	x &lt;- x + y
  } )

  f &lt;- within( .jnew( "javax/swing/JFrame" ) , {
	layout &lt;- .jnew( "java/awt/BorderLayout" )
	setLayout( layout )
	add( .jnew( "javax/swing/JLabel", "north" ), layout$NORTH )
	add( .jnew( "javax/swing/JLabel", "south" ), layout$SOUTH )
	add( .jnew( "javax/swing/JLabel", "west" ), layout$WEST )
	add( .jnew( "javax/swing/JLabel", "east" ), layout$EAST )
	setSize( .jnew( "java/awt/Dimension", 400L, 400L ) )
	setVisible( TRUE )
  } )
}

Double &lt;- J("java.lang.Double")
with( Double, MIN_VALUE )
with( Double, parseDouble( "10.2" ) )

## Not run: 
# inner class example

HashMap &lt;- J("java.util.HashMap")
with( HashMap, new( SimpleEntry, "key", "value" ) )
with( HashMap, SimpleEntry )

## End(Not run)

with( J("java.lang.System"), getProperty("java.home") )



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
