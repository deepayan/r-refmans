<!DOCTYPE html><html><head><title>Help for package xegaGpGene</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaGpGene}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#findCrossoverExample'><p>Prints a random example of crossover for a crossover method given</p>
a random number seed.</a></li>
<li><a href='#lFxegaGpGene'><p>Generate local functions and objects.</p></a></li>
<li><a href='#xegaGpAllCross2Gene'><p>Crossover of 2 derivation tree genes</p></a></li>
<li><a href='#xegaGpAllCrossGene'><p>Crossover of 2 derivation tree genes.</p></a></li>
<li><a href='#xegaGpCrossoverFactory'><p>Configure the crossover function of a grammar-based genetic algorithm.</p></a></li>
<li><a href='#xegaGpDecodeGene'><p>Decode a derivation tree.</p></a></li>
<li><a href='#xegaGpFilterCross2Gene'><p>Crossover of 2 derivation tree genes with node filter.</p></a></li>
<li><a href='#xegaGpFilterCrossGene'><p>Crossover of 2 derivation tree genes with node filter.</p></a></li>
<li><a href='#xegaGpGene'><p>Package xegaGpGene.</p></a></li>
<li><a href='#xegaGpInitGene'><p>Generates a gene as a random derivation tree.</p></a></li>
<li><a href='#xegaGpMutateAllGene'><p>Mutate a gene.</p></a></li>
<li><a href='#xegaGpMutateFilterGene'><p>Mutate a gene (with a node filter)</p></a></li>
<li><a href='#xegaGpMutationFactory'><p>Configure the mutation function of a genetic algorithm.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Genetic Operations for Grammar-Based Genetic Programming</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of
        the representation-dependent gene level operations of grammar-based
        genetic programming with genes which are derivation trees
        of a context-free grammar: Initialization of a gene with a 
        complete random derivation tree, decoding of a derivation tree.
        Crossover is implemented by exchanging subtrees. Depth-bounds
        for the minimal and the maximal depth of the roots of the subtrees
        exchanged by crossover can be set. 
        Mutation is implemented by replacing a subtree by a random subtree. 
        The depth of the random subtree and the insertion node are 
        configurable. For details, 
        see Geyer-Schulz (1997, ISBN:978-3-7908-0830-X).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaGpGene&amp;gt;">https://github.com/ageyerschulz/xegaGpGene&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, xegaBNF, xegaDerivationTrees, xegaSelectGene</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 08:18:23 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='findCrossoverExample'>Prints a random example of crossover for a crossover method given 
a random number seed.</h2><span id='topic+findCrossoverExample'></span>

<h3>Description</h3>

<p>The purpose of this function is to support the search 
for examples for generating unit tests for crossover 
functions whose behavior depends on random numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCrossoverExample(FUN, s, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findCrossoverExample_+3A_fun">FUN</code></td>
<td>
<p>String. Specification of crossover method.</p>
</td></tr>
<tr><td><code id="findCrossoverExample_+3A_s">s</code></td>
<td>
<p>Integer. Seed of random number generator.</p>
</td></tr>
<tr><td><code id="findCrossoverExample_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. 
If <code>TRUE</code> (default), print example to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findCrossoverExample(FUN="AllCross2Gene", s=2)
</code></pre>

<hr>
<h2 id='lFxegaGpGene'>Generate local functions and objects.</h2><span id='topic+lFxegaGpGene'></span>

<h3>Description</h3>

<p><code>lFxegaPermGene</code> is a list of functions 
which contains a definition of all local objects 
required for the use of genetic operators with the 
We refer to this object as local configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lFxegaGpGene
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 25.
</p>

<hr>
<h2 id='xegaGpAllCross2Gene'>Crossover of 2 derivation tree genes</h2><span id='topic+xegaGpAllCross2Gene'></span>

<h3>Description</h3>

<p><code>xegaGpAllCross2Gene()</code> swaps two randomly extracted 
subtrees between 2 genes. Subtrees must have the same
root in order to be compatible. The current implementation 
performs at most <code>maxtrials</code> trials to find compatible
subtrees. If this fails, the original genes are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpAllCross2Gene(ng1, ng2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpAllCross2Gene_+3A_ng1">ng1</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpAllCross2Gene_+3A_ng2">ng2</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpAllCross2Gene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crossover is controlled by one local parameter:
</p>

<ul>
<li> <p><code>lF$MaxTrials()</code>: Maximal number of trials to find 
compatible subtrees. If compatible subtrees are not 
found, the gene is returned unchanged.
</p>
</li></ul>



<h3>Value</h3>

<p>List of 2 derivation trees.
</p>


<h3>See Also</h3>

<p>Other Crossover: 
<code><a href="#topic+xegaGpAllCrossGene">xegaGpAllCrossGene</a>()</code>,
<code><a href="#topic+xegaGpFilterCross2Gene">xegaGpFilterCross2Gene</a>()</code>,
<code><a href="#topic+xegaGpFilterCrossGene">xegaGpFilterCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGpInitGene(lFxegaGpGene)
gene2&lt;-xegaGpInitGene(lFxegaGpGene)
xegaGpDecodeGene(gene1, lFxegaGpGene)
xegaGpDecodeGene(gene2, lFxegaGpGene)
newgenes&lt;-xegaGpAllCross2Gene(gene1, gene2,  lFxegaGpGene)
xegaGpDecodeGene(newgenes[[1]], lFxegaGpGene)
xegaGpDecodeGene(newgenes[[2]], lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpAllCrossGene'>Crossover of 2 derivation tree genes.</h2><span id='topic+xegaGpAllCrossGene'></span>

<h3>Description</h3>

<p><code>xegaGpAllCrossGene()</code> swaps two randomly extracted 
subtrees between 2 genes. Subtrees must have the same
root in order to be compatible. The current implementation 
performs at most <code>lF$MaxTrials()</code> 
attempts to find compatible
subtrees. If this fails, the original gene is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpAllCrossGene(ng1, ng2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpAllCrossGene_+3A_ng1">ng1</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpAllCrossGene_+3A_ng2">ng2</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpAllCrossGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crossover is controlled by one local parameter:
</p>

<ul>
<li> <p><code>lF$MaxTrials()</code>: Maximal number of trials to find 
compatible subtrees. If compatible subtrees are not 
found, the gene is returned unchanged.
</p>
</li></ul>



<h3>Value</h3>

<p>List of 1 derivation tree.
</p>


<h3>See Also</h3>

<p>Other Crossover: 
<code><a href="#topic+xegaGpAllCross2Gene">xegaGpAllCross2Gene</a>()</code>,
<code><a href="#topic+xegaGpFilterCross2Gene">xegaGpFilterCross2Gene</a>()</code>,
<code><a href="#topic+xegaGpFilterCrossGene">xegaGpFilterCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGpInitGene(lFxegaGpGene)
gene2&lt;-xegaGpInitGene(lFxegaGpGene)
xegaGpDecodeGene(gene1, lFxegaGpGene)
xegaGpDecodeGene(gene2, lFxegaGpGene)
newgene&lt;-xegaGpAllCrossGene(gene1, gene2,  lFxegaGpGene)
xegaGpDecodeGene(newgene[[1]], lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpCrossoverFactory'>Configure the crossover function of a grammar-based genetic algorithm.</h2><span id='topic+xegaGpCrossoverFactory'></span>

<h3>Description</h3>

<p><code>xegaGpCrossoverFactory()</code> implements the selection
of one of the crossover functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> Crossover functions with two kids:
</p>

<ol>
<li><p> &quot;Cross2Gene&quot;       returns <code>xegaGpAllCross2Gene()</code>.
</p>
</li>
<li><p> &quot;AllCross2Gene&quot;    returns <code>xegaGpAllCross2Gene()</code>.
</p>
</li>
<li><p> &quot;FilterCross2Gene&quot; returns <code>xegaGpFilterCross2Gene()</code>.
</p>
</li></ol>

</li>
<li><p> Crossover functions with one kid:
</p>

<ol>
<li><p> &quot;AllCrossGene&quot; returns <code>xegaGpAllCrossGene()</code>.
</p>
</li>
<li><p> &quot;FilterCrossGene&quot; returns <code>xegaGpFilterCrossGene()</code>.
</p>
</li></ol>

</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGpCrossoverFactory(method = "Cross2Gene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpCrossoverFactory_+3A_method">method</code></td>
<td>
<p>String specifying the crossover function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Crossover function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+xegaGpMutationFactory">xegaGpMutationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XGeneTwo&lt;-xegaGpCrossoverFactory("Cross2Gene")
XGeneOne&lt;-xegaGpCrossoverFactory("FilterCrossGene")
gene1&lt;-xegaGpInitGene(lFxegaGpGene)
gene2&lt;-xegaGpInitGene(lFxegaGpGene)
XGeneTwo(gene1, gene2, lFxegaGpGene)
XGeneOne(gene1, gene2, lFxegaGpGene)
</code></pre>

<hr>
<h2 id='xegaGpDecodeGene'>Decode a derivation tree.</h2><span id='topic+xegaGpDecodeGene'></span>

<h3>Description</h3>

<p><code>xegaGpDecodeGene()</code> decodes a derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpDecodeGene(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpDecodeGene_+3A_gene">gene</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpDecodeGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recursive algorithm for the decoder is imported 
from package <code>xegaDerivationTrees</code>.
</p>


<h3>Value</h3>

<p>Decoded gene. Program.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGpInitGene(lFxegaGpGene)
xegaGpDecodeGene(gene, lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpFilterCross2Gene'>Crossover of 2 derivation tree genes with node filter.</h2><span id='topic+xegaGpFilterCross2Gene'></span>

<h3>Description</h3>

<p><code>xegaGpFilterCross2Gene()</code> swaps two randomly extracted 
subtrees between 2 genes. Subtrees must have the same
root in order to be compatible. The current implementation 
performs at most <code>maxtrials</code> trials to find compatible
subtrees. If this fails, the original genes are returned.
Only nodes with a depth
between <code>lF$MinMutInsertionDepth()</code> and
<code>lF$MaxMutInsertionDepth()</code> are considered as
candidate roots of derivation trees to be swapped 
by crossover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpFilterCross2Gene(ng1, ng2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpFilterCross2Gene_+3A_ng1">ng1</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpFilterCross2Gene_+3A_ng2">ng2</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpFilterCross2Gene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crossover is controlled by three local parameters:
</p>

<ul>
<li> <p><code>lF$MinCrossDepth()</code> and 
<code>lF$MaxCrossDepth()</code> control the possible exchange points 
for subtrees. The depth of the exchange node must be 
between <code>lF$MinMutInsertionDepth()</code> and
<code>lF$MaxMutInsertionDepth()</code>.
</p>
</li>
<li> <p><code>lF$MaxTrials()</code>: Maximal number of trials to find 
compatible subtrees. If compatible subtrees are not 
found, the gene is returned unchanged.
</p>
</li></ul>



<h3>Value</h3>

<p>List of 2 derivation trees.
</p>


<h3>See Also</h3>

<p>Other Crossover: 
<code><a href="#topic+xegaGpAllCross2Gene">xegaGpAllCross2Gene</a>()</code>,
<code><a href="#topic+xegaGpAllCrossGene">xegaGpAllCrossGene</a>()</code>,
<code><a href="#topic+xegaGpFilterCrossGene">xegaGpFilterCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGpInitGene(lFxegaGpGene)
gene2&lt;-xegaGpInitGene(lFxegaGpGene)
xegaGpDecodeGene(gene1, lFxegaGpGene)
xegaGpDecodeGene(gene2, lFxegaGpGene)
newgenes&lt;-xegaGpFilterCross2Gene(gene1, gene2,  lFxegaGpGene)
xegaGpDecodeGene(newgenes[[1]], lFxegaGpGene)
xegaGpDecodeGene(newgenes[[2]], lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpFilterCrossGene'>Crossover of 2 derivation tree genes with node filter.</h2><span id='topic+xegaGpFilterCrossGene'></span>

<h3>Description</h3>

<p><code>xegaGpFilterCrossGene()</code> swaps two randomly extracted 
subtrees between 2 genes. Subtrees must have the same
root in order to be compatible. The current implementation 
performs at most <code>lF$maxtrials()</code> 
attempts to find compatible
subtrees. If this fails, the original gene is returned.
Only nodes with a depth
between <code>lF$MinMutInsertionDepth()</code> and
<code>lF$MaxMutInsertionDepth()</code> are considered as
candidate roots of derivation trees to be swapped 
by crossover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpFilterCrossGene(ng1, ng2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpFilterCrossGene_+3A_ng1">ng1</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpFilterCrossGene_+3A_ng2">ng2</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpFilterCrossGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crossover is controlled by three local parameters:
</p>

<ul>
<li> <p><code>lF$MinCrossDepth()</code> and 
<code>lF$MaxCrossDepth()</code> control the possible exchange points 
for subtrees. The depth of the exchange node must be 
between <code>lF$MinMutInsertionDepth()</code> and
<code>lF$MaxMutInsertionDepth()</code>.
</p>
</li>
<li> <p><code>lF$MaxTrials()</code>: Maximal number of trials to find 
compatible subtrees. If compatible subtrees are not 
found, the gene is returned unchanged.
</p>
</li></ul>



<h3>Value</h3>

<p>List of 1 derivation tree.
</p>


<h3>See Also</h3>

<p>Other Crossover: 
<code><a href="#topic+xegaGpAllCross2Gene">xegaGpAllCross2Gene</a>()</code>,
<code><a href="#topic+xegaGpAllCrossGene">xegaGpAllCrossGene</a>()</code>,
<code><a href="#topic+xegaGpFilterCross2Gene">xegaGpFilterCross2Gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGpInitGene(lFxegaGpGene)
gene2&lt;-xegaGpInitGene(lFxegaGpGene)
xegaGpDecodeGene(gene1, lFxegaGpGene)
xegaGpDecodeGene(gene2, lFxegaGpGene)
newgene&lt;-xegaGpFilterCrossGene(gene1, gene2,  lFxegaGpGene)
xegaGpDecodeGene(newgene[[1]], lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpGene'>Package xegaGpGene.</h2><span id='topic+xegaGpGene'></span>

<h3>Description</h3>

<p>Genetic operations for grammar-based genetic algorithms.
</p>


<h3>Details</h3>

<p>For derivation tree genes, the <code>xegaGpGene</code> package provides
</p>

<ul>
<li><p> Gene initiatilization.
</p>
</li>
<li><p> Decoding of parameters.
</p>
</li>
<li><p> Mutation functions as well as a function factory for configuration.
</p>
</li>
<li><p> Crossover functions as well as a function factory for configuration.
Crossover functions can be restricted by depth or by the non-terminal 
symbols which are allowed as roots of the subtrees which are exchanged 
between 2 genes.
We provide two families of crossover functions:
</p>

<ol>
<li><p> Crossover functions with two kids:
Crossover preserves the genetic information in the gene pool.
</p>
</li>
<li><p> Crossover functions with one kid:
These functions allow the construction of evaluation pipelines
for genes. One advantage of this is a simple control structure 
at the population level.
</p>
</li></ol>

</li></ul>



<h3>Derivation Tree Gene Representation</h3>

<p>A derivation tree gene is a named list:
</p>

<ul>
<li> <p><code>$gene1</code>:     The gene must be a complete derivation tree.
</p>
</li>
<li> <p><code>$fit</code>:       The fitness value of the gene
(for EvalGeneDet() and EvalGeneU()) or
the mean fitness (for stochastic functions
evaluated with EvalGeneStoch()).
</p>
</li>
<li> <p><code>$evaluated</code>: Boolean. Has the gene been evaluated?
</p>
</li>
<li> <p><code>$evalFail</code>:  Boolean. Has the evaluation of the gene failed?
</p>
</li>
<li> <p><code>$var</code>:       The variance of the fitness 
of all evaluations of a gene is updated
after each evaluation of a gene.
(For stochastic functions.)
</p>
</li>
<li> <p><code>$sigma</code>:     The standard deviation of the fitness of 
all evaluations of a gene.
(For stochastic functions.)
</p>
</li>
<li> <p><code>$obs:</code>       The number evaluations of a gene.
(For stochastic functions.)
</p>
</li></ul>



<h3>Abstract Interface of Problem Environment</h3>

<p>A problem environment <code>penv</code> must provide:
</p>

<ul>
<li> <p><code>$f(word, gene, lF)</code>: 
Function with a word of a language as first argument
which the fitness of the gene.
</p>
</li></ul>



<h3>Abstract Interface of Mutation Functions</h3>

<p>Each mutation function has the following function signature:
</p>
<p><code>newGene&lt;-Mutate(gene, lF)</code>
</p>
<p>All local parameters of the mutation function configured are 
expected in the local function list lF.
</p>


<h3>Local Constants of Mutation Functions</h3>

<p>The local constants of a mutation function determine the 
the behavior of the function. 
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>lF$MaxMutDepth()</code> </td><td style="text-align: center;"> 3  </td><td style="text-align: left;"> xegaGpMutateAllGene(), </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                        </td><td style="text-align: center;"> 3  </td><td style="text-align: left;"> xegaGpMutateFilterGene() </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>lF$MinMutInsertiontDepth()</code> </td><td style="text-align: center;"> 3  </td><td style="text-align: left;"> xegaGpMutateFilterGene() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>lF$MaxMutInsertiontDepth()</code> </td><td style="text-align: center;"> 4  </td><td style="text-align: left;"> xegaGpMutateFilterGene() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>



<h3>Abstract Interface of Crossover Functions</h3>

<p>The signatures of the abstract interface to the 2 families 
of crossover functions are:
</p>
<p><code>ListOfTwoGenes&lt;-Crossover2(gene1, gene2, lF)</code> 
</p>
<p><code>ListOfOneGene&lt;-Crossover(gene1, gene2, lF)</code>
</p>
<p>All local parameters of the crossover function configured are 
expected in the local function list lF.
</p>


<h3>Local Constants of Crossover Functions</h3>


<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>lF$MinCrossDepth()</code> </td><td style="text-align: center;"> 1  </td><td style="text-align: left;"> xegaGpFilterCross2Gene(),  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                          </td><td style="text-align: center;">    </td><td style="text-align: left;"> xegaGpFilterCrossGene(),  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>lF$MaxCrossDepth()</code> </td><td style="text-align: center;"> 7  </td><td style="text-align: left;"> xegaGpFilterCross2Gene(),  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                          </td><td style="text-align: center;">    </td><td style="text-align: left;"> xegaGpFilterCrossGene(),  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>lF$MaxTrials()</code>     </td><td style="text-align: center;"> 5  </td><td style="text-align: left;"> xegaGpAllCross2Gene()  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                          </td><td style="text-align: center;">    </td><td style="text-align: left;"> xegaGpAllCrossGene(),  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                          </td><td style="text-align: center;">    </td><td style="text-align: left;"> xegaGpFilter2CrossGene(),  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                          </td><td style="text-align: center;">    </td><td style="text-align: left;"> xegaGpFilterCrossGene(),  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>



<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population related functionality as well as support for 
population statistics dependent adaptive mechanisms and parallelization.
</p>
</li>
<li> 
<p>The gene layer is split in a representation independent and 
a representation dependent part:
</p>

<ol>
<li> 
<p>The representation indendent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
<code>xegaBNF</code> essentially provides a grammar compiler and 
<code>xegaDerivationTrees</code> an abstract data type for derivation trees.
</p>
</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>&lt;https://github.com/ageyerschulz/xegaGpGene&gt;
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xegaGpGene')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>


<h3>References</h3>

<p>Geyer-Schulz, Andreas (1997):
<em>Fuzzy Rule-Based Expert Systems and Genetic Machine Learning</em>,
Physica, Heidelberg.
(ISBN:978-3-7908-0830-X)
</p>

<hr>
<h2 id='xegaGpInitGene'>Generates a gene as a random derivation tree.</h2><span id='topic+xegaGpInitGene'></span>

<h3>Description</h3>

<p>For a given grammar, <code>xegaGpInitGene()</code> 
generates a gene as a random derivation tree
with a depth-bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpInitGene(lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpInitGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the derivation tree representation of 
package <code>xegaGp</code>, <em>gene</em> is a list with 
</p>

<ol>
<li> <p><code>$evaluated</code>: Boolean: TRUE if the fitness is known.
</p>
</li>
<li> <p><code>$fit</code>:       The fitness of the genotype of 
<code>$gene1</code>         
</p>
</li>
<li> <p><code>$gene1</code>:     a derivation tree.
</p>
</li></ol>

<p>This representation makes implementation of several 
code optimizations and generalizations easier.
</p>
<p>The algorithm for generating a complete derivation tree 
with a depth-bound
is imported from package <code>xegaDerivationTrees</code>.
</p>


<h3>Value</h3>

<p>Derivation tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGpInitGene(lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpMutateAllGene'>Mutate a gene.</h2><span id='topic+xegaGpMutateAllGene'></span>

<h3>Description</h3>

<p><code>xegaGpMutateAllGene()</code> 
replaces a randomly selected subtree by
a random derivation tree with the same root symbol 
with small probability.
All non-terminal nodes are considered as insertion points.
Depth-bounds are respected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpMutateAllGene(g, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpMutateAllGene_+3A_g">g</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpMutateAllGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mutation is controlled by one local parameter: 
</p>

<ol>
<li> <p><code>lF$MaxMutDepth()</code> controls the maximal depth of 
of the new random generation tree.
</p>
</li></ol>

<p>This version of the genetic operator skips the filter loop.
</p>


<h3>Value</h3>

<p>Derivation tree.
</p>


<h3>See Also</h3>

<p>Other Mutation: 
<code><a href="#topic+xegaGpMutateFilterGene">xegaGpMutateFilterGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGpInitGene(lFxegaGpGene)
xegaGpDecodeGene(gene1, lFxegaGpGene)
gene&lt;-xegaGpMutateAllGene(gene1, lFxegaGpGene)
xegaGpDecodeGene(gene, lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpMutateFilterGene'>Mutate a gene (with a node filter)</h2><span id='topic+xegaGpMutateFilterGene'></span>

<h3>Description</h3>

<p><code>xegaGpMutateGeneFilter()</code> replaces 
a randomly selected subtree by
a random derivation tree with the same root symbol 
with small probability.
Only non-terminal nodes with a depth
between <code>lF$MinMutInsertionDepth()</code> and
<code>lF$MaxMutInsertionDepth()</code> are considered 
as tree insertion points.
Depth-bounds are respected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGpMutateFilterGene(g, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpMutateFilterGene_+3A_g">g</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="xegaGpMutateFilterGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mutation is controlled by three local parameters: 
</p>

<ol>
<li> <p><code>lF$MaxMutDepth()</code> controls the maximal depth of 
of the new random generation tree.
</p>
</li>
<li> <p><code>lF$MinMutInsertionDepth()</code> and 
<code>lF$MaxMutInsertionDepth()</code> control the possible 
insertion points for the new random derivation tree.
The depth of the insertion node must be 
between <code>lF$MinMutInsertionDepth()</code> and
<code>lF$MaxMutInsertionDepth()</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>Derivation tree.
</p>


<h3>See Also</h3>

<p>Other Mutation: 
<code><a href="#topic+xegaGpMutateAllGene">xegaGpMutateAllGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGpInitGene(lFxegaGpGene)
xegaGpDecodeGene(gene1, lFxegaGpGene)
gene&lt;-xegaGpMutateFilterGene(gene1, lFxegaGpGene)
xegaGpDecodeGene(gene, lFxegaGpGene)

</code></pre>

<hr>
<h2 id='xegaGpMutationFactory'>Configure the mutation function of a genetic algorithm.</h2><span id='topic+xegaGpMutationFactory'></span>

<h3>Description</h3>

<p><code>xegaGpMutationFactory()</code> implements the selection
of one of the mutation functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;MutateGene&quot; returns <code>xegaGpMutateAllGene()</code>.
</p>
</li>
<li><p> &quot;MutateAllGene&quot; returns <code>xegaGpMutateAllGene()</code>.
</p>
</li>
<li><p> &quot;MutateFilterGene&quot; returns <code>xegaGpMutateFilterGene()</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGpMutationFactory(method = "MutateGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGpMutationFactory_+3A_method">method</code></td>
<td>
<p>String specifying the mutation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mutation function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+xegaGpCrossoverFactory">xegaGpCrossoverFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mutate&lt;-xegaGpMutationFactory("MutateGene")
gene1&lt;-xegaGpInitGene(lFxegaGpGene)
gene1
Mutate(gene1, lFxegaGpGene)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
