<!DOCTYPE html><html><head><title>Help for package spAbundance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spAbundance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abund'><p>Function for Fitting Univariate Abundance GLMMs</p></a></li>
<li><a href='#bbsData'><p>Count data for six warbler species in Pennsylvania, USA</p></a></li>
<li><a href='#bbsPredData'><p>Covariates and coordinates for prediction of relative warbler abundance in Pennsylvania, USA</p></a></li>
<li><a href='#dataNMixSim'><p>Simulated repeated count data of 6 species</p>
across 225 sites</a></li>
<li><a href='#DS'><p>Function for Fitting Single-Species Hierarchical Distance Sampling Models</p></a></li>
<li><a href='#fitted.abund'><p>Extract Model Fitted Values for abund Object</p></a></li>
<li><a href='#fitted.DS'><p>Extract Model Fitted Values for DS Object</p></a></li>
<li><a href='#fitted.lfMsAbund'><p>Extract Model Fitted Values for lfMsAbund Object</p></a></li>
<li><a href='#fitted.lfMsDS'><p>Extract Model Fitted Values for lfMsDS Object</p></a></li>
<li><a href='#fitted.lfMsNMix'><p>Extract Model Fitted Values for lfMsNMix Object</p></a></li>
<li><a href='#fitted.msAbund'><p>Extract Model Fitted Values for msAbund Object</p></a></li>
<li><a href='#fitted.msDS'><p>Extract Model Fitted Values for msDS Object</p></a></li>
<li><a href='#fitted.msNMix'><p>Extract Model Fitted Values for msNMix Object</p></a></li>
<li><a href='#fitted.NMix'><p>Extract Model Fitted Values for NMix Object</p></a></li>
<li><a href='#fitted.sfMsAbund'><p>Extract Model Fitted Values for sfMsAbund Object</p></a></li>
<li><a href='#fitted.sfMsDS'><p>Extract Model Fitted Values for sfMsDS Object</p></a></li>
<li><a href='#fitted.sfMsNMix'><p>Extract Model Fitted Values for sfMsNMix Object</p></a></li>
<li><a href='#fitted.spAbund'><p>Extract Model Fitted Values for spAbund Object</p></a></li>
<li><a href='#fitted.spDS'><p>Extract Model Fitted Values for spDS Object</p></a></li>
<li><a href='#fitted.spNMix'><p>Extract Model Fitted Values for spNMix Object</p></a></li>
<li><a href='#fitted.svcAbund'><p>Extract Model Fitted Values for svcAbund Object</p></a></li>
<li><a href='#fitted.svcMsAbund'><p>Extract Model Fitted Values for svcMsAbund Object</p></a></li>
<li><a href='#hbefCount2015'><p>Count data of 12 foliage gleaning bird species</p>
in 2015 in the Hubbard Brook Experimental Forest</a></li>
<li><a href='#lfMsAbund'><p>Function for Fitting Latent Factor Multivariate Abundance GLMMs</p></a></li>
<li><a href='#lfMsDS'><p>Function for Fitting Latent Factor Multi-Species Hierarchical Distance Sampling Models</p></a></li>
<li><a href='#lfMsNMix'><p>Function for Fitting Latent Factor Multi-species N-mixture Models</p></a></li>
<li><a href='#msAbund'><p>Function for Fitting Multivariate Abundance GLMMs</p></a></li>
<li><a href='#msDS'><p>Function for Fitting Multi-Species Hierarchical Distance Sampling Models</p></a></li>
<li><a href='#msNMix'><p>Function for Fitting Multi-species N-mixture Models</p></a></li>
<li><a href='#neonDWP'><p>Distance sampling data of 16 bird species</p>
observed in the Disney Wilderness Preserve in 2018 in Florida, USA</a></li>
<li><a href='#neonPredData'><p>Land cover covariates and coordinates at a 1ha resolution across Disney Wilderness Preserve</p></a></li>
<li><a href='#NMix'><p>Function for Fitting Single-Species N-mixture Models</p></a></li>
<li><a href='#ppcAbund'><p>Function for performing posterior predictive checks</p></a></li>
<li><a href='#predict.abund'><p>Function for prediction at new locations for univariate GLMMs</p></a></li>
<li><a href='#predict.DS'><p>Function for prediction at new locations for single-species hierarchical distance sampling models</p></a></li>
<li><a href='#predict.lfMsAbund'><p>Function for prediction at new locations for latent factor multivariate GLMMs</p></a></li>
<li><a href='#predict.lfMsDS'><p>Function for prediction at new locations for latent factor multi-species hierarchical distance sampling models</p></a></li>
<li><a href='#predict.lfMsNMix'><p>Function for prediction at new locations for latent factor multi-species N-mixture models</p></a></li>
<li><a href='#predict.msAbund'><p>Function for prediction at new locations for multivariate GLMMs</p></a></li>
<li><a href='#predict.msDS'><p>Function for prediction at new locations for multi-species hierarchical distance sampling models</p></a></li>
<li><a href='#predict.msNMix'><p>Function for prediction at new locations for multi-species N-mixture models</p></a></li>
<li><a href='#predict.NMix'><p>Function for prediction at new locations for single-species N-mixture models</p></a></li>
<li><a href='#predict.sfMsAbund'><p>Function for prediction at new locations for spatial factor multivariate GLMMs</p></a></li>
<li><a href='#predict.sfMsDS'><p>Function for prediction at new locations for spatial factor multi-species hierarchical distance sampling models</p></a></li>
<li><a href='#predict.sfMsNMix'><p>Function for prediction at new locations for spatial factor multi-species N-mixture models</p></a></li>
<li><a href='#predict.spAbund'><p>Function for prediction at new locations for univariate spatial GLMMs</p></a></li>
<li><a href='#predict.spDS'><p>Function for prediction at new locations for single-species spatially-explicit hierarchical distance sampling models</p></a></li>
<li><a href='#predict.spNMix'><p>Function for prediction at new locations for single-species spatial N-mixture models</p></a></li>
<li><a href='#predict.svcAbund'><p>Function for prediction at new locations for univariate Gaussian spatially-varying coefficient models</p></a></li>
<li><a href='#predict.svcMsAbund'><p>Function for prediction at new locations for multivariate spatially-varying coefficient GLMMs</p></a></li>
<li><a href='#sfMsAbund'><p>Function for Fitting Spatial Factor Multivariate Abundance GLMMs</p></a></li>
<li><a href='#sfMsDS'><p>Function for Fitting Spatial Factor Multi-Species Hierarchical Distance Sampling Models</p></a></li>
<li><a href='#sfMsNMix'><p>Function for Fitting Spatial Factor Multi-species N-mixture Models</p></a></li>
<li><a href='#simAbund'><p>Simulate Univariate Data for Testing GLMMs</p></a></li>
<li><a href='#simDS'><p>Simulate Single-Species Distance Sampling Data</p></a></li>
<li><a href='#simMsAbund'><p>Simulate Multivariate Data for Testing GLMMs</p></a></li>
<li><a href='#simMsDS'><p>Simulate Multi-Species Distance Sampling Data</p></a></li>
<li><a href='#simMsNMix'><p>Simulate Multi-Species Repeated Count Data with Imperfect Detection</p></a></li>
<li><a href='#simNMix'><p>Simulate Single-Species Count Data with Imperfect Detection</p></a></li>
<li><a href='#spAbund'><p>Function for Fitting Univariate Spatial Abundance GLMs</p></a></li>
<li><a href='#spDS'><p>Function for Fitting Single-Species Spatially-Explicit Hierarchical Distance Sampling Models</p></a></li>
<li><a href='#spNMix'><p>Function for Fitting Single-Species Spatial N-Mixture Models</p></a></li>
<li><a href='#summary.abund'><p>Methods for abund Object</p></a></li>
<li><a href='#summary.DS'><p>Methods for DS Object</p></a></li>
<li><a href='#summary.lfMsAbund'><p>Methods for lfMsAbund Object</p></a></li>
<li><a href='#summary.lfMsDS'><p>Methods for lfMsDS Object</p></a></li>
<li><a href='#summary.lfMsNMix'><p>Methods for lfMsNMix Object</p></a></li>
<li><a href='#summary.msAbund'><p>Methods for msAbund Object</p></a></li>
<li><a href='#summary.msDS'><p>Methods for msDS Object</p></a></li>
<li><a href='#summary.msNMix'><p>Methods for msNMix Object</p></a></li>
<li><a href='#summary.NMix'><p>Methods for NMix Object</p></a></li>
<li><a href='#summary.sfMsAbund'><p>Methods for sfMsAbund Object</p></a></li>
<li><a href='#summary.sfMsDS'><p>Methods for sfMsDS Object</p></a></li>
<li><a href='#summary.sfMsNMix'><p>Methods for sfMsNMix Object</p></a></li>
<li><a href='#summary.spAbund'><p>Methods for spAbund Object</p></a></li>
<li><a href='#summary.spDS'><p>Methods for spDS Object</p></a></li>
<li><a href='#summary.spNMix'><p>Methods for spNMix Object</p></a></li>
<li><a href='#summary.svcAbund'><p>Methods for svcAbund Object</p></a></li>
<li><a href='#summary.svcMsAbund'><p>Methods for svcMsAbund Object</p></a></li>
<li><a href='#svcAbund'><p>Function for Fitting Univariate Spatialy-Varying Coefficient GLMMs</p></a></li>
<li><a href='#svcMsAbund'><p>Function for Fitting Spatially-Varying Coefficient Multivariate Abundance GLMMs</p></a></li>
<li><a href='#waicAbund'><p>Compute Widely Applicable Information Criterion for spAbundance Model Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Univariate and Multivariate Spatial Modeling of Species
Abundance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits single-species (univariate) and multi-species (multivariate) non-spatial and spatial abundance models in a Bayesian framework using Markov Chain Monte Carlo (MCMC). Spatial models are fit using Nearest Neighbor Gaussian Processes (NNGPs). Details on NNGP models are given in Datta, Banerjee, Finley, and Gelfand (2016) &lt;<a href="https://doi.org/10.1080%2F01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>&gt; and Finley, Datta, and Banerjee (2020) &lt;<a href="https://arxiv.org/abs/2001.09111">arXiv:2001.09111</a>&gt;. Fits single-species and multi-species spatial and non-spatial versions of generalized linear mixed models (Gaussian, Poisson, Negative Binomial), N-mixture models (Royle 2004 &lt;<a href="https://doi.org/10.1111%2Fj.0006-341X.2004.00142.x">doi:10.1111/j.0006-341X.2004.00142.x</a>&gt;) and hierarchical distance sampling models (Royle, Dawson, Bates (2004) &lt;<a href="https://doi.org/10.1890%2F03-3127">doi:10.1890/03-3127</a>&gt;). Multi-species spatial models are fit using a spatial factor modeling approach with NNGPs for computational efficiency. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.jeffdoser.com/files/spabundance-web">https://www.jeffdoser.com/files/spabundance-web</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/doserjef/spAbundance/issues">https://github.com/doserjef/spAbundance/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, coda, abind, RANN, lme4, foreach, doParallel, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-22 20:23:12 UTC; jeff</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey Doser [aut, cre],
  Andrew Finley [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey Doser &lt;doserjef@msu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-22 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abund'>Function for Fitting Univariate Abundance GLMMs</h2><span id='topic+abund'></span>

<h3>Description</h3>

<p>Function for fitting univariate abundance generalized linear (mixed) models 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abund(formula, data, inits, priors, tuning,
      n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
      n.omp.threads = 1, verbose = TRUE,
      n.report = 100, n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
      n.chains = 1, save.fitted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abund_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="abund_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>z</code>, and <code>offset</code>. <code>y</code>
is a vector, matrix, or data frame of the observed count values. If a vector, 
the values represent the observed counts at each site. If multiple replicate
observations are obtained at the sites (e.g., sub-samples, repeated sampling over
multiple seasons), <code>y</code> can be specified as a matrix or data frame 
with first dimension equal to the number of 
sites (<code class="reqn">J</code>) and second dimension equal to the maximum number of 
replicates at a given site. <code>covs</code> is a list or data frame 
containing the variables used in the model. Each list element is a different
covariate, which can be site-level or observation-level. Site-level covariates
are specified as a vector of length <code class="reqn">J</code> (or column
in a data frame), while observation-level covariates
are specified as a matrix or data frame with the number of rows equal to <code class="reqn">J</code>
and number of columns equal to the maximum number of replicate observations at a 
given site. For zero-inflated Gaussian models, the tag <code>z</code> is used to specify the 
binary component of the zero-inflated model and should have the same length as <code>y</code>. 
<code>offset</code> is an offset to use in the abundance model (e.g., an area offset). 
This can be either a single value, a vector with an offset for each site (e.g., if survey area differed in size), or a site x replicate matrix if more than one count is available at a given site.</p>
</td></tr> 
<tr><td><code id="abund_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta</code>, <code>kappa</code>, <code>sigma.sq.mu</code>, and <code>tau.sq</code>. 
The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.mu</code> is 
only relevant when including random effects in the model. <code>kappa</code> is 
only relevant when <code>family = 'NB'</code>. <code>tau.sq</code> is only 
relevant when <code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>. 
See <code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="abund_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>kappa.unif</code>, <code>sigma.sq.mu.ig</code>, 
and <code>tau.sq.ig</code>. 
Abundance (<code>beta</code>) regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 100. <code>kappa</code> is the negative binomial 
over-dispersion parameter and is assumed to follow a uniform distribution. The 
hyperparameters of the uniform distribution are passed as a vector of length
two with the first and second elements corresponding to the lower and upper
bounds of the uniform distribution. <code>sigma.sq.mu</code>
are the random effect variances for any abundance
random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random effects or of length one 
if priors are the same for all random effect variances. <code>tau.sq</code> is the 
residual variance for Gaussian (or zero-inflated Gaussian) models, and it is assigned 
an inverse-Gamma prior. The hyperparameters of the inverse-Gamma are passed as a vector
of length two, with the first and second element corresponding to the shape and 
scale parameters, respectively.</p>
</td></tr>
<tr><td><code id="abund_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, 
whose value defines the initial variance of the adaptive sampler.
Valid tags are <code>beta</code>, <code>beta.star</code> (the abundance
random effect values), and <code>kappa</code>. See Roberts and Rosenthal (2009) for details.
Note that no tuning is necessary for Gaussian or zero-inflated Gaussian models.</p>
</td></tr>
<tr><td><code id="abund_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="abund_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="abund_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="abund_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial), <code>'Poisson'</code>, <code>'Gaussian'</code>, 
and <code>'zi-Gaussian'</code>.</p>
</td></tr> 
<tr><td><code id="abund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatially-explicit models.</p>
</td></tr>
<tr><td><code id="abund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="abund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="abund_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="abund_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="abund_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="abund_+3A_save.fitted">save.fitted</code></td>
<td>
<p>logical value indicating whether or not fitted values and likelihood values
should be saved in the resulting model object. If <code>save.fitted = FALSE</code>, the components
<code>y.rep.samples</code>, <code>mu.samples</code>, and <code>like.samples</code> will not be included
in the model object, and subsequent functions for calculating WAIC, fitted values, and
posterior predictive checks will not work, although they all can be calculated manually if
desired. Setting <code>save.fitted = FALSE</code> can be useful when working with very large 
data sets to minimize the amount of RAM needed when fitting and storing the model object in 
memory.</p>
</td></tr>
<tr><td><code id="abund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>abund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance overdispersion parameter. Only included when
<code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the Gaussian residual variance parameter. Only included when
<code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a two or three-dimensional array of posterior samples 
for the abundance replicate (fitted) values with dimensions 
corresponding to MCMC samples, site, and an optional third dimension of replicate.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a two or three-dimensional array of posterior samples
for the expected abundance samples with dimensions corresponding 
to MCMC samples, site, and an optional third dimension of replicate.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the model. 
Only included if random effects are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the random effects. Only included if random effects 
are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the likelihood value associated with each site. Used for calculating
WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1010)
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0, -1.5, 0.3, -0.8)
p.abund &lt;- length(beta)
mu.RE &lt;- list(levels = c(30),
	       sigma.sq.mu = c(1.3))
kappa &lt;- 0.5
sp &lt;- FALSE 
family &lt;- 'NB'
dat &lt;- simAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, 
                kappa = kappa, mu.RE = mu.RE, sp = sp, family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re

covs &lt;- list(int = X[, , 1], 
             abund.cov.1 = X[, , 2], 
             abund.cov.2 = X[, , 3], 
             abund.cov.3 = X[, , 4],
             abund.factor.1 = X.re[, , 1])

data.list &lt;- list(y = y, covs = covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 100),
                   kappa.unif = c(0.001, 10)) 
# Starting values
inits.list &lt;- list(beta = 0, kappa = kappa)

tuning &lt;- list(kappa = 0.2, beta = 0.1, beta.star = 0.2)
n.batch &lt;- 5
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- abund(formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3 + 
                         (1 | abund.factor.1),
                         data = data.list, 
                         n.batch = n.batch, 
                         batch.length = batch.length, 
                         inits = inits.list, 
                         tuning = tuning,
                         priors = prior.list, 
                         accept.rate = 0.43, 
                         n.omp.threads = 1, 
                         verbose = TRUE, 
                         n.report = 1,
                         n.burn = n.burn,
                         n.thin = n.thin,
                         n.chains = n.chains) 
summary(out)
</code></pre>

<hr>
<h2 id='bbsData'>Count data for six warbler species in Pennsylvania, USA</h2><span id='topic+bbsData'></span>

<h3>Description</h3>

<p>Count data on 6 warblers in Pennsylvania, USA in 2018. Data come from the North American
Breeding Bird Survey. Data indicate the total numer of individuals for each of 6 species
counted at 50 stops along a 40km route (95 routes in the data set). The six species included 
in the data set are: (1) American Redstart (AMRE); (2) Blackburnian Warbler (BLBW); (3)
Black-throated Blue Warbler; (4) Black-throated Green Warbler; (5) Hooded Warbler; and
(6) Magnolia Warbler. Covariate data include three bioclimatic variables derived from 
PRISM. Two landcover variables (forest cover and developed land cover) come from USGS 
Earth Resources Observation and Science (EROS) Center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bbsData)
</code></pre>


<h3>Format</h3>

<p><code>bbsData</code> is a list with three elements: 
</p>
<p><code>y</code>: a two-dimensional matrix of count data with rows corresponding
to species (6) and columns corresponding to sites (95). 
</p>
<p><code>covs</code>: a data frame with 95 rows and 8 columns consisting of 
covariates for use in modeling relative abundance.
</p>
<p><code>coords</code>: a numeric matrix with 95 rows and two columns containing the 
site coordinates. The proj4string is &quot;+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs&quot;
</p>


<h3>Source</h3>

<p>U.S. Geological Survey. Downloaded from https://www.sciencebase.gov/catalog/item/52b1dfa8e4b0d9b325230cd9 on August 25, 2023.</p>


<h3>References</h3>

<p>Daly, C., Halbleib, M., Smith, J. I., Gibson, W. P., Doggett, M. K., Taylor, G. H., Curtis, J., and
Pasteris, P. P. (2008). Physiographically sensitive mapping of climatological temperature and
precipitation across the conterminous united states. International Journal of Climatology: a
Journal of the Royal Meteorological Society, 28(15):2031–2064
</p>
<p>Ziolkowski Jr., D.J., Lutmerding, M., English, W.B., Aponte, V.I., and Hudson, M-A.R., 2023, North American Breeding Bird Survey Dataset 1966 - 2022: U.S. Geological Survey data release, https://doi.org/10.5066/P9GS9K64.
</p>
<p>Sohl, T., Reker, R., Bouchard, M., Sayler, K., Dornbierer, J., Wika, S., ... &amp; Friesz, A. (2016). Modeled historical land use and land cover for the conterminous United States. Journal of Land Use Science, 11(4), 476-499.
</p>

<hr>
<h2 id='bbsPredData'>Covariates and coordinates for prediction of relative warbler abundance in Pennsylvania, USA</h2><span id='topic+bbsPredData'></span>

<h3>Description</h3>

<p>Bioclimatic and land cover variables extracted at a 12km resolution across 
the state of Pennsylvania, USA for use in predicting relative abundance of six 
warbler species across the state. Land cover data come from USGS EROS, while 
climate data come from PRISM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bbsPredData)
</code></pre>


<h3>Format</h3>

<p><code>bbsPredData</code> is a data frame with seven columns: 
</p>
<p><code>bio2</code>: bioclim variable 2.
</p>
<p><code>bio8</code>: bioclim variable 8.
</p>
<p><code>bio18</code>: bioclim variable 18.
</p>
<p><code>forest</code>: proportion of forest cover within a 5km radius.
</p>
<p><code>devel</code>: proportion of developed land cover within a 5km radius.
</p>
<p><code>x</code>: the x coordinate of the point. The proj4strig is &quot;+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs&quot;.
</p>
<p><code>y</code>: the y coordinate of the point. The proj4string is &quot;+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs&quot;.
</p>


<h3>References</h3>

<p>Daly, C., Halbleib, M., Smith, J. I., Gibson, W. P., Doggett, M. K., Taylor, G. H., Curtis, J., and
Pasteris, P. P. (2008). Physiographically sensitive mapping of climatological temperature and
precipitation across the conterminous united states. International Journal of Climatology: a
Journal of the Royal Meteorological Society, 28(15):2031–2064
</p>
<p>Sohl, T., Reker, R., Bouchard, M., Sayler, K., Dornbierer, J., Wika, S., ... &amp; Friesz, A. (2016). Modeled historical land use and land cover for the conterminous United States. Journal of Land Use Science, 11(4), 476-499.
</p>

<hr>
<h2 id='dataNMixSim'>Simulated repeated count data of 6 species 
across 225 sites</h2><span id='topic+dataNMixSim'></span>

<h3>Description</h3>

<p>A simulated data set of repeated count data for 6 species across 225 sites with a maximum
of 3 replicate surveys performed at a given site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataNMixSim)
</code></pre>


<h3>Format</h3>

<p><code>dataNMixSim</code> is a list with four elements: 
</p>
<p><code>y</code>: a three-dimensional array of count data with 
dimensions of species (6), sites (225) and replicates (3). 
</p>
<p><code>abund.covs</code>: a numeric matrix with 225 rows and two columns consisting
of a continuous covariate and a categorical variable which may both influence
abundance of the different species.
</p>
<p><code>det.covs</code>: a list of two numeric matrices with 225 rows and 3 columns. 
Both matrices contain a continuous covariate that may affect detection probability
of the species
</p>
<p><code>coords</code>: a numeric matrix with 225 rows and two columns containing the 
site coordinates (X and Y). Note the data are generated across 
a unit square (i.e., the x and y coordinates are both between 0 and 1). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6)
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
# n.rep &lt;- rep(5, J) 
n.sp &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-1, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.4, 1.2)
# Detection
alpha.mean &lt;- c(0, 0.5, 0.8)
tau.sq.alpha &lt;- c(0.2, 1, 1.5)
p.det &lt;- length(alpha.mean)
# Random effects
mu.RE &lt;- list()
mu.RE &lt;- list(levels = c(10),
	       sigma.sq.mu = c(0.5),
               beta.indx = list(1))
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
alpha.true &lt;- alpha
sp &lt;- TRUE 
n.factors &lt;- 3
factor.model &lt;- TRUE
phi &lt;- runif(n.factors, 3/1, 3 / .2)
kappa &lt;- runif(n.sp, 0.1, 1)
family &lt;- 'Poisson'

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, alpha = alpha,
	        mu.RE = mu.RE, p.RE = p.RE, sp = sp, kappa = kappa, family = family, 
                factor.model = factor.model, phi = phi, 
                cov.model = 'exponential', n.factors = n.factors)
table(dat$N)
apply(dat$N, 1, sum)

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
X.re &lt;- dat$X.re
X.p.re &lt;- dat$X.p.re
coords &lt;- dat$coords
dimnames(coords)[[2]] &lt;- c('X', 'Y')

# Package all data into a list
abund.covs &lt;- cbind(X, X.re)
colnames(abund.covs) &lt;- c('int', 'abund.cov.1', 'abund.factor.1')
abund.covs &lt;- abund.covs[, -1]
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
		 det.cov.2 = X.p[, , 3]) 
dataNMixSim &lt;- list(y = y, 
		    abund.covs = abund.covs, 
		    det.covs = det.covs, 
                    coords = coords)
</code></pre>

<hr>
<h2 id='DS'>Function for Fitting Single-Species Hierarchical Distance Sampling Models</h2><span id='topic+DS'></span>

<h3>Description</h3>

<p>Function for fitting single-sepcies hierarchical distance sampling models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DS(abund.formula, det.formula, data, inits, priors, tuning,
   n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
   transect = 'line', det.func = 'halfnormal',
   n.omp.threads = 1, verbose = TRUE,
   n.report = 100, n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
   n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DS_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="DS_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="DS_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>dist.breaks</code>, and <code>offset</code>. <code>y</code>
is a matrix or data frame of the observed count values, 
with first dimension equal to the number of 
sites (<code class="reqn">J</code>) and second dimension equal to the number of 
distance bins. <code>covs</code> is a matrix or data frame
containing the variables used in the the abundance and/or the detection
portion of the model, with
<code class="reqn">J</code> rows for each column (variable). <code>dist.breaks</code> is a vector of 
distances that denote the breakpoints of the distance bands. <code>dist.breaks</code> should
have length equal to the number of columns in <code>y</code> plus one. <code>offset</code> is an 
offset that can be used to scale estimates from abundance per transect to density per 
some desired unit of measure. This can be either a single value or a vector with an offset
value for each site (e.g., if transects differ in length)</p>
</td></tr>
<tr><td><code id="DS_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>N</code>, <code>beta</code>, <code>alpha</code>, <code>kappa</code>, 
<code>sigma.sq.mu</code>, and <code>sigma.sq.p</code>. The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.mu</code> and <code>sigma.sq.p</code> are 
only relevant when including random effects in the abundance and 
detection portion of the distance sampling model, respectively. <code>kappa</code> is 
only relevant when <code>family = 'NB'</code>. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="DS_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>kappa.unif</code>, 
<code>sigma.sq.mu.ig</code>, and <code>sigma.sq.p.ig</code>. 
Abundance (<code>beta</code>) and detection (<code>alpha</code>) 
regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 100. <code>kappa</code> is the negative binomial 
dispersion parameter and is assumed to follow a uniform distribution. The 
hyperparameters of the uniform distribution are passed as a vector of length
two with the first and second elements corresponding to the lower and upper
bounds of the uniform distribution. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts/slopes or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="DS_+3A_tuning">tuning</code></td>
<td>
<p>a single numeric value representing the initial variance of the
adaptive sampler for <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="DS_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="DS_+3A_batch.length">batch.length</code></td>
<td>
<p>the number of MCMC samples in each batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="DS_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="DS_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr> 
<tr><td><code id="DS_+3A_transect">transect</code></td>
<td>
<p>the type of transect. Currently supports line transects (<code>'line'</code>) or
circular transects (i.e., point counts; <code>'point'</code>).</p>
</td></tr>
<tr><td><code id="DS_+3A_det.func">det.func</code></td>
<td>
<p>the detection model used to describe how detection probability varies
with distance. In other software, this is often referred to as the key function. Currently
supports two functions: half normal (<code>'halfnormal'</code>) and negative exponential
(<code>'negexp'</code>).</p>
</td></tr>
<tr><td><code id="DS_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="DS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="DS_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="DS_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="DS_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="DS_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="DS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>DS</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance dispersion parameter. Only included when
<code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent abundance values. Note that these values always
represent transect-level abundance, even when an offset is 
supplied.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent expected abundance values. When an offset is 
supplied in the <code>data</code> object, these correspond to expected 
abundance per unit area (i.e., density).</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a three-dimensional array of fitted values. 
Array dimensions correspond to MCMC samples, sites, and distance band.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>a three-dimensional array of cell-specific detection
probabilities. Array dimensions correspond to MCMC samples, sites, and distance band.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Royle, J. A., Dawson, D. K., &amp; Bates, S. (2004). Modeling 
abundance effects in distance sampling. Ecology, 85(6), 1591-1597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Abundance coefficients
beta &lt;- c(1.0, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta)
# Detection coefficients
alpha &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
sp &lt;- FALSE 
family &lt;- 'NB'
kappa &lt;- 0.1
offset &lt;- 1.8
transect &lt;- 'point'

dat &lt;- simDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
             beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
             mu.RE = mu.RE, p.RE = p.RE, sp = sp,
             sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
             offset = offset, transect = transect)

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
dist.breaks &lt;- dat$dist.breaks

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  offset = offset)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 10),
                   alpha.normal = list(mean = 0,
                                       var = 10), 
                   kappa.unif = c(0, 100)) 
# Starting values
inits.list &lt;- list(alpha = 0,
                   beta = 0,
                   kappa = 1)
# Tuning values
tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.2) 

out &lt;- DS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
          det.formula = ~ det.cov.1,
          data = data.list, 
          n.batch = 10, 
          batch.length = 25, 
          inits = inits.list, 
          family = 'NB',
          det.func = 'halfnormal', 
          transect = 'point', 
          tuning = tuning,
          priors = prior.list, 
          accept.rate = 0.43, 
          n.omp.threads = 1, 
          verbose = TRUE, 
          n.report = 100,
          n.burn = 100,
          n.thin = 1,
          n.chains = 1) 
summary(out)
</code></pre>

<hr>
<h2 id='fitted.abund'>Extract Model Fitted Values for abund Object</h2><span id='topic+fitted.abund'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted GLMM (<code>abund</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'abund'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.abund_+3A_object">object</code></td>
<td>
<p>object of class <code>abund</code>.</p>
</td></tr>
<tr><td><code id="fitted.abund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>abund</code>. 
</p>


<h3>Value</h3>

<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates
</p>

<hr>
<h2 id='fitted.DS'>Extract Model Fitted Values for DS Object</h2><span id='topic+fitted.DS'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and cell-specific detection probabilities from a hierarchical distance sampling (<code>DS</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DS'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.DS_+3A_object">object</code></td>
<td>
<p>object of class <code>DS</code>.</p>
</td></tr>
<tr><td><code id="fitted.DS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>DS</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and distance bin.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>A three-dimensional numeric array of cell-specific detection probability values. Values correspond to the probability of detecting an individual within a given distance band at a given location. Array dimensions correspond to MCMC samples, sites, and distance band.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.lfMsAbund'>Extract Model Fitted Values for lfMsAbund Object</h2><span id='topic+fitted.lfMsAbund'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted latent factor multivariate GLMM (<code>lfMsAbund</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsAbund'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lfMsAbund_+3A_object">object</code></td>
<td>
<p>object of class <code>lfMsAbund</code>.</p>
</td></tr>
<tr><td><code id="fitted.lfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>lfMsAbund</code>. 
</p>


<h3>Value</h3>

<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.
</p>

<hr>
<h2 id='fitted.lfMsDS'>Extract Model Fitted Values for lfMsDS Object</h2><span id='topic+fitted.lfMsDS'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and cell-specific detection probabilities from a latent factor multi-species hierarchical distance sampling (<code>lfMsDS</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsDS'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lfMsDS_+3A_object">object</code></td>
<td>
<p>object of class <code>lfMsDS</code>.</p>
</td></tr>
<tr><td><code id="fitted.lfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>lfMsDS</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and distance bin.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>A four-dimensional numeric array of cell-specific detection probability values. Values correspond to the probability of detecting an individual within a given distance band at a given location. Array dimensions correspond to MCMC samples, species, sites, and distance band.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.lfMsNMix'>Extract Model Fitted Values for lfMsNMix Object</h2><span id='topic+fitted.lfMsNMix'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted latent factor multi-species N-mixture (<code>lfMsNMix</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsNMix'
fitted(object, type = 'marginal', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lfMsNMix_+3A_object">object</code></td>
<td>
<p>object of class <code>lfMsNMix</code>.</p>
</td></tr>
<tr><td><code id="fitted.lfMsNMix_+3A_type">type</code></td>
<td>
<p>a character string indicating whether fitted values should be generated conditional on the estimated latent abundance values (<code>type = 'conditional'</code>) estimated during the model or based on the marginal expected abundance values (<code>type = 'marginal'</code>).</p>
</td></tr>
<tr><td><code id="fitted.lfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>lfMsNMix</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.msAbund'>Extract Model Fitted Values for msAbund Object</h2><span id='topic+fitted.msAbund'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted multivariate GLMM (<code>msAbund</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msAbund'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.msAbund_+3A_object">object</code></td>
<td>
<p>object of class <code>msAbund</code>.</p>
</td></tr>
<tr><td><code id="fitted.msAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>msAbund</code>. 
</p>


<h3>Value</h3>

<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.
</p>

<hr>
<h2 id='fitted.msDS'>Extract Model Fitted Values for msDS Object</h2><span id='topic+fitted.msDS'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and cell-specific detection probabilities from a multi-species hierarchical distance sampling (<code>msDS</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msDS'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.msDS_+3A_object">object</code></td>
<td>
<p>object of class <code>msDS</code>.</p>
</td></tr>
<tr><td><code id="fitted.msDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>msDS</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and distance bin.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>A four-dimensional numeric array of cell-specific detection probability values. Values correspond to the probability of detecting an individual within a given distance band at a given location. Array dimensions correspond to MCMC samples, species, sites, and distance band.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.msNMix'>Extract Model Fitted Values for msNMix Object</h2><span id='topic+fitted.msNMix'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted multi-species N-mixture (<code>msNMix</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msNMix'
fitted(object, type = 'marginal', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.msNMix_+3A_object">object</code></td>
<td>
<p>object of class <code>msNMix</code>.</p>
</td></tr>
<tr><td><code id="fitted.msNMix_+3A_type">type</code></td>
<td>
<p>a character string indicating whether fitted values should be generated conditional on the estimated latent abundance values (<code>type = 'conditional'</code>) estimated during the model or based on the marginal expected abundance values (<code>type = 'marginal'</code>).</p>
</td></tr>
<tr><td><code id="fitted.msNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>msNMix</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.NMix'>Extract Model Fitted Values for NMix Object</h2><span id='topic+fitted.NMix'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted N-mixture (<code>NMix</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMix'
fitted(object, type = 'marginal', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.NMix_+3A_object">object</code></td>
<td>
<p>object of class <code>NMix</code>.</p>
</td></tr>
<tr><td><code id="fitted.NMix_+3A_type">type</code></td>
<td>
<p>a character string indicating whether fitted values should be generated conditional on the estimated latent abundance values (<code>type = 'conditional'</code>) estimated during the model or based on the marginal expected abundance values (<code>type = 'marginal'</code>).</p>
</td></tr>
<tr><td><code id="fitted.NMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>NMix</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A three-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.sfMsAbund'>Extract Model Fitted Values for sfMsAbund Object</h2><span id='topic+fitted.sfMsAbund'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted spatial factor multivariate GLMM (<code>sfMsAbund</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsAbund'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.sfMsAbund_+3A_object">object</code></td>
<td>
<p>object of class <code>sfMsAbund</code>.</p>
</td></tr>
<tr><td><code id="fitted.sfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>sfMsAbund</code>. 
</p>


<h3>Value</h3>

<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.
</p>

<hr>
<h2 id='fitted.sfMsDS'>Extract Model Fitted Values for sfMsDS Object</h2><span id='topic+fitted.sfMsDS'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and cell-specific detection probabilities from a spatial factor multi-species hierarchical distance sampling (<code>sfMsDS</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsDS'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.sfMsDS_+3A_object">object</code></td>
<td>
<p>object of class <code>sfMsDS</code>.</p>
</td></tr>
<tr><td><code id="fitted.sfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>sfMsDS</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and distance bin.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>A four-dimensional numeric array of cell-specific detection probability values. Values correspond to the probability of detecting an individual within a given distance band at a given location. Array dimensions correspond to MCMC samples, species, sites, and distance band.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.sfMsNMix'>Extract Model Fitted Values for sfMsNMix Object</h2><span id='topic+fitted.sfMsNMix'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted spatial factor multi-species N-mixture (<code>sfMsNMix</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsNMix'
fitted(object, type = 'marginal', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.sfMsNMix_+3A_object">object</code></td>
<td>
<p>object of class <code>sfMsNMix</code>.</p>
</td></tr>
<tr><td><code id="fitted.sfMsNMix_+3A_type">type</code></td>
<td>
<p>a character string indicating whether fitted values should be generated conditional on the estimated latent abundance values (<code>type = 'conditional'</code>) estimated during the model or based on the marginal expected abundance values (<code>type = 'marginal'</code>).</p>
</td></tr>
<tr><td><code id="fitted.sfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>sfMsNMix</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.spAbund'>Extract Model Fitted Values for spAbund Object</h2><span id='topic+fitted.spAbund'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted spatial GLMM (<code>spAbund</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spAbund'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.spAbund_+3A_object">object</code></td>
<td>
<p>object of class <code>spAbund</code>.</p>
</td></tr>
<tr><td><code id="fitted.spAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>spAbund</code>. 
</p>


<h3>Value</h3>

<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates
</p>

<hr>
<h2 id='fitted.spDS'>Extract Model Fitted Values for spDS Object</h2><span id='topic+fitted.spDS'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and cell-specific detection probabilities from a spatial hierarchical distance sampling (<code>spDS</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spDS'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.spDS_+3A_object">object</code></td>
<td>
<p>object of class <code>spDS</code>.</p>
</td></tr>
<tr><td><code id="fitted.spDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>spDS</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and distance bin.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>A three-dimensional numeric array of cell-specific detection probability values. Values correspond to the probability of detecting an individual within a given distance band at a given location. Array dimensions correspond to MCMC samples, sites, and distance band.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.spNMix'>Extract Model Fitted Values for spNMix Object</h2><span id='topic+fitted.spNMix'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted spatial N-mixture (<code>spNMix</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spNMix'
fitted(object, type = 'marginal', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.spNMix_+3A_object">object</code></td>
<td>
<p>object of class <code>spNMix</code>.</p>
</td></tr>
<tr><td><code id="fitted.spNMix_+3A_type">type</code></td>
<td>
<p>a character string indicating whether fitted values should be generated conditional on the estimated latent abundance values (<code>type = 'conditional'</code>) estimated during the model or based on the marginal expected abundance values (<code>type = 'marginal'</code>).</p>
</td></tr>
<tr><td><code id="fitted.spNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>spNMix</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A three-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.svcAbund'>Extract Model Fitted Values for svcAbund Object</h2><span id='topic+fitted.svcAbund'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted spatially-varying coefficient GLMM (<code>svcAbund</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcAbund'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcAbund_+3A_object">object</code></td>
<td>
<p>object of class <code>svcAbund</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>svcAbund</code>. 
</p>


<h3>Value</h3>

<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates
</p>

<hr>
<h2 id='fitted.svcMsAbund'>Extract Model Fitted Values for svcMsAbund Object</h2><span id='topic+fitted.svcMsAbund'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted multivatiate spatially-varying coefficient GLMM (<code>svcMsAbund</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcMsAbund'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcMsAbund_+3A_object">object</code></td>
<td>
<p>object of class <code>svcMsAbund</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>svcMsAbund</code>. 
</p>


<h3>Value</h3>

<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.
</p>

<hr>
<h2 id='hbefCount2015'>Count data of 12 foliage gleaning bird species
in 2015 in the Hubbard Brook Experimental Forest</h2><span id='topic+hbefCount2015'></span>

<h3>Description</h3>

<p>Repeated count data of 12 foliage gleaning bird species in 2015 in the 
Hubbard Brook Experimental Forest (HBEF) in New Hampshire, USA. Data were collected at 373
sites over three replicate point counts each of 10 minutes in length, with a detection 
radius of 100m. Some sites were not visited for all three replicates. The 12 species
included in the data set are as follows: (1) AMRE: American Redstart; (2) BAWW: 
Black-and-white Warbler; (3) BHVI: Blue-headed Vireo; (4) BLBW: Blackburnian Warbler; 
(5) BLPW: Blackpoll Warbler; (6) BTBW: Black-throated Blue Warbler; (7) BTNW: 
BLack-throated Green Warbler; (8) CAWA: Canada Warbler; (9) MAWA: Magnolia Warbler; 
(10) NAWA: Nashville Warbler; (11) OVEN: Ovenbird; (12) REVI: Red-eyed Vireo. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hbefCount2015)
</code></pre>


<h3>Format</h3>

<p><code>hbefCount2015</code> is a list with four elements: 
</p>
<p><code>y</code>: a three-dimensional array of count data with 
dimensions of species (12), sites (373) and replicates (3). 
</p>
<p><code>abund.covs</code>: a data frame with 373 rows and one column consisting of the 
elevation at each site.
</p>
<p><code>det.covs</code>: a list of two numeric matrices with 373 rows and 3 columns. 
The first element is the day of year when the survey was 
conducted for a given site and replicate. The second element is the
time of day when the survey was conducted. 
</p>
<p><code>coords</code>: a numeric matrix with 373 rows and two columns containing the 
site coordinates (Easting and Northing) in UTM Zone 19. The proj4string is
&quot;+proj=utm +zone=19 +units=m +datum=NAD83&quot;.
</p>


<h3>Source</h3>

<p>Rodenhouse, N. and S. Sillett. 2019. Valleywide Bird Survey, Hubbard Brook 
Experimental Forest, 1999-2016 (ongoing) ver 3. Environmental Data Initiative. 
<a href="https://doi.org/10.6073/pasta/faca2b2cf2db9d415c39b695cc7fc217">doi:10.6073/pasta/faca2b2cf2db9d415c39b695cc7fc217</a> 
(Accessed 2021-09-07)</p>


<h3>References</h3>

<p>Doser, J. W., Leuenberger, W., Sillett, T. S., Hallworth, M. T. &amp; Zipkin, E. F. (2022). 
Integrated community occupancy models: A framework to assess occurrence and biodiversity 
dynamics using multiple data sources. Methods in Ecology and Evolution, 00, 1-14. <a href="https://doi.org/10.1111/2041-210X.13811">doi:10.1111/2041-210X.13811</a>
</p>

<hr>
<h2 id='lfMsAbund'>Function for Fitting Latent Factor Multivariate Abundance GLMMs</h2><span id='topic+lfMsAbund'></span>

<h3>Description</h3>

<p>Function for fitting multivariate generalized linear (mixed) models with species
correlations (i.e., an abundance-based joint species distribution model). We 
use a factor modeling approach for dimension reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfMsAbund(formula, data, inits, priors, tuning, n.factors,
          n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
          n.omp.threads = 1, verbose = TRUE, n.report = 100, 
          n.burn = round(.10 * n.batch * batch.length), n.thin = 1, n.chains = 1,
          save.fitted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfMsAbund_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>coords</code>, <code>z</code>, and <code>offset</code>. 
<code>y</code> is a two or three-dimensional array of observed count data. The
first dimension of the array is equal to the 
number of species and the second dimension is equal to the number of sites. If
specified as a three-dimensional array, the third dimension corresponds to 
replicate observations at each site (e.g., sub-samples, repeated sampling 
over multiple seasons). <code>covs</code> is a list or data frame 
containing the variables used in the model. If a data frame, each row 
of <code>covs</code> is a site and each column is a variable. 
If specified as a list, each list element is a different
covariate, which can be site-level or observation-level. Site-level covariates
are specified as a vector of length <code class="reqn">J</code>, while observation-level covariates
are specified as a matrix or data frame with the number of rows equal to <code class="reqn">J</code>
and number of columns equal to the maximum number of replicate observations at a 
given site. <code>coords</code> is a matrix or data frame with two 
columns that contain the spatial coordinates of each 
site. Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system. For zi-Gaussian models, the tag <code>z</code> is used to specify the 
binary component of the zi-Gaussian model and should have the same dimensions as <code>y</code>. <code>offset</code> 
is an offset to use in the abundance model (e.g., an area offset). 
This can be either a single value, a vector with an offset for each site (e.g., if survey 
area differed in size), or a site x replicate matrix if more than one count is available 
at a given site.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta.comm</code>, <code>beta</code>, 
<code>tau.sq.beta</code>, <code>sigma.sq.mu</code>, <code>kappa</code>, <code>lambda</code>, <code>w</code>, <code>tau.sq</code>. 
<code>kappa</code> is only specified if <code>family = 'NB'</code>, <code>tau.sq</code>
is only specified for Gaussian and zi-Gaussian models,
and <code>sigma.sq.mu</code> is only specified if random effects are included in <code>formula</code>. 
The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>tau.sq.beta.ig</code>, <code>sigma.sq.mu</code>, 
<code>kappa.unif</code>, <code>tau.sq.ig</code>. Community-level (<code>beta.comm</code>) 
regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances to 100. Community-level variance parameters 
(<code>tau.sq.beta</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. <code>sigma.sq.mu</code> are the random 
effect variances random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters. <code>tau.sq</code> is the 
species-specific residual variance for Gaussian (or zi-Gaussian) models, and it is assigned 
an inverse-Gamma prior. The hyperparameters of the inverse-Gamma are passed as a list 
of length two, with the first and second element corresponding to the shape and 
scale parameters, respectively, which are each specified as vectors of length
equal to the number of species or a single value if priors are the same for all species.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, whose
whose value defines the initial variance of the adaptive sampler.
Valid tags are <code>beta</code>, <code>beta.star</code> (the abundance
random effect values), <code>kappa</code>, <code>lambda</code> (the latent factor loadings), 
and <code>w</code> (the latent factors). See Roberts and Rosenthal (2009) for details. 
Note that no tuning is necessary for Gaussian or zi-Gaussian models.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the latent factor model approach.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the
total number of species in the community, which will lead to substantial
decreases in computation time. However, the value can be anywhere
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial), <code>'Poisson'</code>, <code>'Gaussian'</code>, 
and <code>'zi-Gaussian'</code>.</p>
</td></tr> 
<tr><td><code id="lfMsAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_save.fitted">save.fitted</code></td>
<td>
<p>logical value indicating whether or not fitted values and likelihood values
should be saved in the resulting model object. If <code>save.fitted = FALSE</code>, the components
<code>y.rep.samples</code>, <code>mu.samples</code>, and <code>like.samples</code> will not be included
in the model object, and subsequent functions for calculating WAIC, fitted values, and
posterior predictive checks will not work, although they all can be calculated manually if
desired. Setting <code>save.fitted = FALSE</code> can be useful when working with very large 
data sets to minimize the amount of RAM needed when fitting and storing the model object in 
memory.</p>
</td></tr>
<tr><td><code id="lfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lfMsAbund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the Gaussian residual variance parameter. Only included when
<code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent factor loadings.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each latent factor. Array dimensions correspond
to MCMC sample, latent factor, then site.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the fitted (replicate) values for each species with dimensions corresponding
to MCMC sample, species, site, and replicate.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the expected abundance values for each species with dimensions
corresponding to MCMC samples, species, site, and replicate.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
# Random effects (two random intercepts)
mu.RE &lt;- list(levels = c(10, 15),
              sigma.sq.mu = c(0.43, 0.5))
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- FALSE
kappa &lt;- runif(n.sp, 0.1, 1)
factor.model &lt;- TRUE
n.factors &lt;- 3

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, 
                  n.sp = n.sp, beta = beta, mu.RE = mu.RE, 
                  sp = sp, kappa = kappa, family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
coords &lt;- dat$coords

# Package all data into a list
covs &lt;- list(int = X[, , 1],
             abund.cov.1 = X[, , 2],
             abund.factor.1 = X.re[, , 1],
             abund.factor.2 = X.re[, , 2])
data.list &lt;- list(y = y, covs = covs, coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   kappa.unif = list(a = 0, b = 10),
                   tau.sq.beta.ig = list(a = .1, b = .1))
inits.list &lt;- list(beta.comm = 0, beta = 0, kappa = 0.5,
                   tau.sq.beta = 1)
tuning.list &lt;- list(kappa = 0.3, beta = 0.1, beta.star = 0.1, 
                    lambda = 0.5, w = 0.5)

# Small
n.batch &lt;- 2
batch.length &lt;- 25
n.burn &lt;- 20
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- lfMsAbund(formula = ~ abund.cov.1 + (1 | abund.factor.1) + 
                             (1 | abund.factor.2),
                 data = data.list,
                 n.batch = n.batch,
                 inits = inits.list,
                 priors = prior.list,
                 tuning = tuning.list,
                 batch.length = batch.length,
                 n.factors = n.factors,
                 n.omp.threads = 3,
                 verbose = TRUE,
                 n.report = 1,
                 n.burn = n.burn,
                 n.thin = n.thin,
                 n.chains = n.chains)
summary(out)
</code></pre>

<hr>
<h2 id='lfMsDS'>Function for Fitting Latent Factor Multi-Species Hierarchical Distance Sampling Models</h2><span id='topic+lfMsDS'></span>

<h3>Description</h3>

<p>Function for fitting latent factor multi-species hierarchical distance sampling models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfMsDS(abund.formula, det.formula, data, inits, priors,  
       tuning, n.factors, n.batch, batch.length, accept.rate = 0.43, 
       family = 'Poisson', transect = 'line', det.func = 'halfnormal', 
       n.omp.threads = 1, verbose = TRUE, n.report = 100, 
       n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
       n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfMsDS_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>coords</code>, 
<code>dist.breaks</code>, and <code>offset</code>. <code>y</code>
is a three-dimensional array of observed count data with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>covs</code> is a matrix or data frame containing the variables 
used in the abundance and/or the detection portion of the model, with
<code class="reqn">J</code> rows for each column (variable). <code>dist.breaks</code> is a vector of 
distances that denote the breakpoints of the distance bands. <code>dist.breaks</code> should
have length equal to the third dimension of <code>y</code> plus one. <code>offset</code> is an 
offset that can be used to scale estimates from abundance per transect to density per 
some desired unit of measure. This can be either a single value or a vector with an offset
value for each site (e.g., if transects differ in length). <code>coords</code> is a matrix
or data frame with two columns that contain the spatial coordinates of each site. 
Note that <code>spAbundance</code> assumes coordinates are specified in a projected
coordinate system.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.mu</code>, 
<code>sigma.sq.p</code>, <code>kappa</code>, <code>N</code>, <code>lambda</code>, <code>w</code>. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are only relevant when including random effects in the 
abundance and detection portion of the model, respectively. <code>kappa</code> is
only relevant when <code>family = 'NB'</code>.
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.mu.ig</code>, 
<code>sigma.sq.p.ig</code>, and <code>kappa.unif</code>. Community-level abundance 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances are set to 100.
Community-level variance parameters for abundance (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, whose
value defines the initial variance of the adaptive sampler. 
Valid tags are <code>beta</code>, <code>alpha</code>, <code>lambda</code> (the latent factor loadings), 
<code>w</code> (the latent factors), <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the latent factor model approach.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the
total number of species in the community, which will lead to substantial
decreases in computation time. However, the value can be anywhere
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_transect">transect</code></td>
<td>
<p>the type of transect. Currently supports line transects (<code>'line'</code>) or
circular transects (i.e., point counts; <code>'point'</code>).</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_det.func">det.func</code></td>
<td>
<p>the detection model used to describe how detection probability varies
with distance. In other software, this is often referred to as the key function. Currently
supports two functions: half normal (<code>'halfnormal'</code>) and negative exponential
(<code>'negexp'</code>).</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="lfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lfMsDS</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent factor loadings.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each latent factor.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent abundance values for each species. Note that these values
always represent transect-level abundance, even when an offset is 
supplied. Array dimensions correspond to MCMC sample, species, and site.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent expected abundance values for each species. When an offset
is supplied in the <code>data</code> object, these correspond to expected
abundance per unit area (i.e., density). Array dimensions correspond to 
MCMC sample, species, and site.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a four-dimensional array of fitted values. 
Array dimensions correspond to MCMC samples, species, sites, and distance band.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>a four-dimensional array of cell-specific detection
probabilities. Array dimensions correspond to MCMC samples, species, 
sites, and distance band.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size
from spatially replicated counts. Biometrics, 60(1), 108-115.
</p>
<p>Sollmann, R., Gardner, B., Williams, K. A., Gilbert, A. T., 
&amp; Veit, R. R. (2016). A hierarchical distance sampling model to 
estimate abundance and covariate associations of species 
and communities. Methods in Ecology and Evolution, 7(5), 529-537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(210)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Number of species
n.sp &lt;- 5
# Community-level abundance coefficients
beta.mean &lt;- c(-1, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 0.3, 0.5, 0.4)
# Detection coefficients
alpha.mean &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha.mean)
tau.sq.alpha &lt;- c(0.1, 0.2)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- FALSE 
family &lt;- 'Poisson'
kappa &lt;- runif(n.sp, 0.3, 3) 
offset &lt;- pi * .8^2
transect &lt;- 'line'
factor.model &lt;- TRUE
n.factors &lt;- 3

dat &lt;- simMsDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
               n.sp = n.sp, beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
               mu.RE = mu.RE, p.RE = p.RE, sp = sp, cov.model = cov.model,
               sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
               offset = offset, transect = transect, factor.model = factor.model, 
               n.factors = n.factors)

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
coords &lt;- dat$coords
dist.breaks &lt;- dat$dist.breaks

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  coords = coords,
                  offset = offset)

# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 10),
                   alpha.comm.normal = list(mean = 0, var = 10), 
                   kappa.unif = list(0, 100), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1)) 
# Starting values
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, kappa = 1)

tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.8, lambda = 1, w = 1) 

n.batch &lt;- 4 
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- lfMsDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
	      det.formula = ~ det.cov.1,
	      data = data.list, 
	      n.batch = n.batch, 
	      batch.length = batch.length, 
	      inits = inits.list, 
	      family = 'Poisson',
	      det.func = 'halfnormal', 
	      transect = transect, 
	      tuning = tuning,
	      n.factors = n.factors,
	      priors = prior.list, 
	      accept.rate = 0.43, 
	      n.omp.threads = 1, 
	      verbose = TRUE, 
	      n.report = 10,
	      n.burn = n.burn,
	      n.thin = n.thin,
	      n.chains = n.chains) 
summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='lfMsNMix'>Function for Fitting Latent Factor Multi-species N-mixture Models</h2><span id='topic+lfMsNMix'></span>

<h3>Description</h3>

<p>Function for fitting multi-species N-mixture models with species correlations (i.e., an abundance-based joint species distribution model with imperfect detection). We use a factor modeling approach for dimension reduction. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfMsNMix(abund.formula, det.formula, data, inits, priors,  
         tuning, n.factors, n.batch, batch.length, accept.rate = 0.43, 
         family = 'Poisson', n.omp.threads = 1, verbose = TRUE, n.report = 100, 
         n.burn = round(.10 * n.samples), n.thin = 1, 
         n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfMsNMix_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>abund.covs</code>, <code>det.covs</code>, <code>coords</code>, and <code>offset</code>. <code>y</code>
is a three-dimensional array of observed count data with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>abund.covs</code> is a matrix or data frame containing the variables 
used in the abundance portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site. <code>coords</code> is a matrix
or data frame with two columns that contain the spatial coordinates of each 
site. Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system. <code>offset</code>
is an offset to use in the abundance model (e.g., an area offset). This can be either a single
value or a vector with an offset for each site (e.g., if survey area differed in size).</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.mu</code>, 
<code>sigma.sq.p</code>, <code>lambda</code>, <code>w</code>, 
<code>kappa</code>, and <code>N</code>. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are only relevant when including random effects in the 
abundance and detection portion of the model, respectively. <code>kappa</code> is
only relevant when <code>family = 'NB'</code>.
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.mu.ig</code>, 
<code>sigma.sq.p.ig</code>, and <code>kappa.unif</code>. Community-level abundance 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances for the abundance
coefficients are set to 100 and for the detection coefficients are set to 2.72. 
Community-level variance parameters for abundance (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random effects or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, 
whose value defines the initial variance of the adaptive sampler. 
Valid tags are <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), 
<code>lambda</code> (the latent factor loadings), <code>w</code> (the latent factors), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the latent factor model approach.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the
total number of species in the community, which will lead to substantial
decreases in computation time. However, the value can be anywhere
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="lfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lfMsNMix</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent factor loadings.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each latent factor.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent abundance values for each species.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent expected abundance values for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection probability
estimated values are not included in the model object, but can be extracted
using <code>fitted()</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size
from spatially replicated counts. Biometrics, 60(1), 108-115.
</p>
<p>Yamaura, Y., Royle, J. A., Shimada, N., Asanuma, S., Sato, T., 
Taki, H., &amp; Makino, S. I. (2012). Biodiversity of man-made open habitats 
in an underused country: a class of multispecies abundance models for 
count data. Biodiversity and Conservation, 21(6), 1365-1380.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(5, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
# Abundance 
beta.mean &lt;- c(0, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
# Detection
alpha.mean &lt;- c(0, 0.5, 0.8)
tau.sq.alpha &lt;- c(0.2, 1, 1.5)
p.det &lt;- length(alpha.mean)
# Random effects
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
n.factors &lt;- 3

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, alpha = alpha,
                 mu.RE = mu.RE, p.RE = p.RE, sp = FALSE, family = 'Poisson', 
                 factor.model = TRUE, n.factors = n.factors)

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
X.re &lt;- dat$X.re
X.p.re &lt;- dat$X.p.re
coords &lt;- dat$coords

# Package all data into a list
abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')
det.covs &lt;- list(det.cov.1 = as.data.frame(X.p[, , 2]),
                 det.cov.2 = as.data.frame(X.p[, , 3]))
data.list &lt;- list(y = y,
                  abund.covs = abund.covs,
                  det.covs = det.covs, 
                  coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = rep(0, p.abund), 
                                           var = rep(100, p.abund)),
                   alpha.comm.normal = list(mean = rep(0, p.det),
                                            var = rep(2.72, p.det)),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
inits.list &lt;- list(beta.comm = 0, alpha.comm = 0,
                   beta = 0, alpha = 0,
                   tau.sq.beta = 0.5, tau.sq.alpha = 0.5,
                   N = apply(y, c(1, 2), max, na.rm = TRUE))
tuning.list &lt;- list(beta = 0.5, alpha = 0.5, lambda = 0.5, w = 0.5)

n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 0 
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- lfMsNMix(abund.formula = ~ abund.cov.1,
                det.formula = ~ det.cov.1 + det.cov.2,
                data = data.list,
                n.batch = n.batch,
                inits = inits.list,
                priors = prior.list,
                tuning = tuning.list,
                batch.length = batch.length,
                n.omp.threads = 1,
                n.factors = n.factors,
                verbose = TRUE,
                n.report = 1,
                n.burn = n.burn,
                n.thin = n.thin,
                n.chains = n.chains)

summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='msAbund'>Function for Fitting Multivariate Abundance GLMMs</h2><span id='topic+msAbund'></span>

<h3>Description</h3>

<p>The function <code>msAbund</code> fits multivariate abundance GLMMs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msAbund(formula, data, inits, priors, tuning, 
        n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
        n.omp.threads = 1, verbose = TRUE, n.report = 100, 
        n.burn = round(.10 * n.batch * batch.length), n.thin = 1, n.chains = 1,
        save.fitted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msAbund_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="msAbund_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>z</code>, and <code>offset</code>. 
<code>y</code> is a two or three-dimensional array of observed count data. The
first dimension of the array is equal to the 
number of species and the second dimension is equal to the number of sites. If
specified as a three-dimensional array, the third dimension corresponds to 
replicate observations at each site (e.g., sub-samples, repeated sampling 
over multiple seasons). <code>covs</code> is a list or data frame
containing the variables used in the model. If a data frame, each row 
of <code>covs</code> is a site and each column is a variable. If a list, 
each list element is a different covariate, which 
can be site-level or observation-level. Site-level covariates
are specified as a vector of length <code class="reqn">J</code>, while observation-level covariates
are specified as a matrix or data frame with the number of rows equal to <code class="reqn">J</code>
and number of columns equal to the maximum number of replicate observations at a 
given site. For zero-inflated Gaussian models, the tag <code>z</code> is used to specify the 
binary component of the model and should have the same dimensions as <code>y</code>. <code>offset</code> 
is an offset to use in the abundance model (e.g., an area offset). 
This can be either a single value, a vector with an offset for each site (e.g., if survey area 
differed in size), or a site x replicate matrix if more than one count is available at a given site.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta.comm</code>, <code>beta</code>, 
<code>tau.sq.beta</code>, <code>sigma.sq.mu</code>, <code>kappa</code>, <code>tau.sq</code>. 
<code>kappa</code> is only specified if <code>family = 'NB'</code>, <code>tau.sq</code> is only
specified for Gaussian or zero-inflated Gaussian models, 
and <code>sigma.sq.mu</code> is only specified if random effects are included in <code>formula</code>. 
The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>tau.sq.beta.ig</code>, <code>sigma.sq.mu</code>, 
<code>kappa.unif</code>, <code>tau.sq.ig</code>. Community-level (<code>beta.comm</code>) 
regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances to 100. Community-level variance parameters 
(<code>tau.sq.beta</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. <code>sigma.sq.mu</code> are the random 
effect variances random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters. <code>tau.sq</code> is the 
species-specific residual variance for Gaussian (or zero-inflated Gaussian) models, and it is assigned 
an inverse-Gamma prior. The hyperparameters of the inverse-Gamma are passed as a list 
of length two, with the first and second element corresponding to the shape and 
scale parameters, respectively, which are each specified as vectors of length
equal to the number of species or a single value if priors are the same for all species.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, 
whose value defines the initial variance of the adaptive sampler.
Valid tags are <code>beta</code>, <code>beta.star</code> (the abundance
random effect values), and <code>kappa</code>. See Roberts and Rosenthal (2009) for details. 
Note that no tuning is necessary for Gaussian or zero-inflated Gaussian models.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial), <code>'Poisson'</code>, <code>'Gaussian'</code>, 
and <code>'zi-Gaussian'</code>.</p>
</td></tr> 
<tr><td><code id="msAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_save.fitted">save.fitted</code></td>
<td>
<p>logical value indicating whether or not fitted values and likelihood values
should be saved in the resulting model object. If <code>save.fitted = FALSE</code>, the components
<code>y.rep.samples</code>, <code>mu.samples</code>, and <code>like.samples</code> will not be included
in the model object, and subsequent functions for calculating WAIC, fitted values, and
posterior predictive checks will not work, although they all can be calculated manually if
desired. Setting <code>save.fitted = FALSE</code> can be useful when working with very large 
data sets to minimize the amount of RAM needed when fitting and storing the model object in 
memory.</p>
</td></tr>
<tr><td><code id="msAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>msAbund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the Gaussian residual variance parameter. Only included when
<code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the fitted (replicate) values for each species with dimensions corresponding
to MCMC sample, species, site, and replicate.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the expected abundance values for each species with dimensions
corresponding to MCMC samples, species, site, and replicate.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
# Random effects (two random intercepts)
mu.RE &lt;- list(levels = c(10, 15),
              sigma.sq.mu = c(0.43, 0.5))
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- FALSE
kappa &lt;- runif(n.sp, 0.1, 1)

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta,
                  mu.RE = mu.RE, sp = sp, kappa = kappa, family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re

# Package all data into a list
covs &lt;- list(int = X[, , 1],
             abund.cov.1 = X[, , 2],
             abund.factor.1 = X.re[, , 1],
             abund.factor.2 = X.re[, , 2])
data.list &lt;- list(y = y, covs = covs)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   kappa.unif = list(a = 0, b = 10),
                   tau.sq.beta.ig = list(a = .1, b = .1))
inits.list &lt;- list(beta.comm = 0,
                   beta = 0,
                   kappa = 0.5,
                   tau.sq.beta = 1)
tuning.list &lt;- list(kappa = 0.3, beta = 0.1, beta.star = 0.1)

# Small
n.batch &lt;- 2
batch.length &lt;- 25
n.burn &lt;- 20
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- msAbund(formula = ~ abund.cov.1 + (1 | abund.factor.1) + 
                           (1 | abund.factor.2),
               data = data.list,
               n.batch = n.batch,
               inits = inits.list,
               priors = prior.list,
               tuning = tuning.list,
               batch.length = batch.length,
               n.omp.threads = 3,
               verbose = TRUE,
               n.report = 1,
               n.burn = n.burn,
               n.thin = n.thin,
               n.chains = n.chains)
summary(out)
</code></pre>

<hr>
<h2 id='msDS'>Function for Fitting Multi-Species Hierarchical Distance Sampling Models</h2><span id='topic+msDS'></span>

<h3>Description</h3>

<p>Function for fitting multi-species hierarchical distance sampling models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msDS(abund.formula, det.formula, data, inits, priors,  
     tuning, n.batch, batch.length, accept.rate = 0.43, 
     family = 'Poisson', transect = 'line', det.func = 'halfnormal', 
     n.omp.threads = 1, verbose = TRUE, n.report = 100, 
     n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
     n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msDS_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="msDS_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="msDS_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, and <code>dist.breaks</code>, and <code>offset</code>. <code>y</code>
is a three-dimensional array of observed count data with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>covs</code> is a matrix or data frame containing the variables 
used in the abundance and/or the detection portion of the model, with
<code class="reqn">J</code> rows for each column (variable). <code>dist.breaks</code> is a vector of 
distances that denote the breakpoints of the distance bands. <code>dist.breaks</code> should
have length equal to the third dimension of <code>y</code> plus one. <code>offset</code> is an 
offset that can be used to scale estimates from abundance per transect to density per 
some desired unit of measure. This can be either a single value or a vector with an offset
value for each site (e.g., if transects differ in length)</p>
</td></tr>
<tr><td><code id="msDS_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.mu</code>, 
<code>sigma.sq.p</code>, <code>kappa</code>, and <code>N</code>. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are only relevant when including random effects in the 
abundance and detection portion of the model, respectively. <code>kappa</code> is
only relevant when <code>family = 'NB'</code>.
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="msDS_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.mu.ig</code>, 
<code>sigma.sq.p.ig</code>, and <code>kappa.unif</code>. Community-level abundance 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances are set to 100.
Community-level variance parameters for abundance (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random effects or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters.</p>
</td></tr>
<tr><td><code id="msDS_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, whose
whose value defines the initial variance of the adaptive sampler. 
Valid tags are <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msDS_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msDS_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msDS_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msDS_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="msDS_+3A_transect">transect</code></td>
<td>
<p>the type of transect. Currently supports line transects (<code>'line'</code>) or
circular transects (i.e., point counts; <code>'point'</code>).</p>
</td></tr>
<tr><td><code id="msDS_+3A_det.func">det.func</code></td>
<td>
<p>the detection model used to describe how detection probability varies
with distance. In other software, this is often referred to as the key function. Currently
supports two functions: half normal (<code>'halfnormal'</code>) and negative exponential
(<code>'negexp'</code>).</p>
</td></tr>
<tr><td><code id="msDS_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="msDS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="msDS_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="msDS_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="msDS_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="msDS_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="msDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>msDS</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent abundance values for each species. Note that these values
always represent transect-level abundance, even when an offset is 
supplied. Array dimensions correspond to MCMC sample, species, and site.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent expected abundance values for each species. When an offset
is supplied in the <code>data</code> object, these correspond to expected
abundance per unit area (i.e., density). Array dimensions correspond to 
MCMC samples, species, and site.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a four-dimensional array of fitted values. 
Array dimensions correspond to MCMC samples, species, sites, and distance band.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>a four-dimensional array of cell-specific detection
probabilities. Array dimensions correspond to MCMC samples, species, 
sites, and distance band.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size
from spatially replicated counts. Biometrics, 60(1), 108-115.
</p>
<p>Sollmann, R., Gardner, B., Williams, K. A., Gilbert, A. T., 
&amp; Veit, R. R. (2016). A hierarchical distance sampling model to 
estimate abundance and covariate associations of species 
and communities. Methods in Ecology and Evolution, 7(5), 529-537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(210)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Number of species
n.sp &lt;- 5
# Community-level abundance coefficients
beta.mean &lt;- c(-1, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 0.3, 0.5, 0.4)
# Detection coefficients
alpha.mean &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha.mean)
tau.sq.alpha &lt;- c(0.1, 0.2)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- FALSE 
family &lt;- 'Poisson'
kappa &lt;- runif(n.sp, 0.3, 3) 
offset &lt;- pi * .8^2
transect &lt;- 'line'
factor.model &lt;- FALSE

dat &lt;- simMsDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
               n.sp = n.sp, beta = beta, alpha = alpha, det.func = det.func, 
               mu.RE = mu.RE, p.RE = p.RE, sp = sp, cov.model = cov.model,
               sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
               offset = offset, transect = transect, factor.model = factor.model)

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
dist.breaks &lt;- dat$dist.breaks

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  offset = offset)

# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 10),
                   alpha.comm.normal = list(mean = 0,
                                            var = 10), 
                   kappa.unif = list(0, 100), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1)) 
# Starting values
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, kappa = 1)

tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.8) 

n.batch &lt;- 4 
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- msDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
            det.formula = ~ det.cov.1,
            data = data.list, 
            n.batch = n.batch, 
            batch.length = batch.length, 
            inits = inits.list, 
            family = 'Poisson',
            det.func = 'halfnormal', 
            transect = transect, 
            tuning = tuning,
            priors = prior.list, 
            accept.rate = 0.43, 
            n.omp.threads = 1, 
            verbose = TRUE, 
            n.report = 10,
            n.burn = n.burn,
            n.thin = n.thin,
            n.chains = n.chains) 
summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='msNMix'>Function for Fitting Multi-species N-mixture Models</h2><span id='topic+msNMix'></span>

<h3>Description</h3>

<p>Function for fitting multi-species N-mixture models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msNMix(abund.formula, det.formula, data, inits, priors,  
       tuning, n.batch, batch.length, accept.rate = 0.43, 
       family = 'Poisson', n.omp.threads = 1, verbose = TRUE, n.report = 100, 
       n.burn = round(.10 * n.samples), n.thin = 1, 
       n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msNMix_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="msNMix_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="msNMix_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>abund.covs</code>, <code>det.covs</code>, and <code>offset</code>. <code>y</code>
is a three-dimensional array of observed count data with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>abund.covs</code> is a matrix or data frame containing the variables 
used in the abundance portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site. <code>offset</code>
is an offset to use in the abundance model (e.g., an area offset). This can be either a single
value or a vector with an offset for each site (e.g., if survey area differed in size).</p>
</td></tr>
<tr><td><code id="msNMix_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.mu</code>, 
<code>sigma.sq.p</code>, <code>kappa</code>, and <code>N</code>. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are only relevant when including random effects in the 
abundance and detection portion of the model, respectively. <code>kappa</code> is
only relevant when <code>family = 'NB'</code>.
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.mu.ig</code>, 
<code>sigma.sq.p.ig</code>, and <code>kappa.unif</code>. Community-level abundance 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances for the abundance
coefficients are set to 100 and for the detection coefficients are set to 2.72. 
Community-level variance parameters for abundance (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts/slopes or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name,
whose value defines the initial variance of the adaptive sampler. 
Valid tags are <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="msNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>msNMix</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent abundance values for each species.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent expected abundance values for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection probability
estimated values are not included in the model object, but can be extracted
using <code>fitted()</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size
from spatially replicated counts. Biometrics, 60(1), 108-115.
</p>
<p>Yamaura, Y., Royle, J. A., Shimada, N., Asanuma, S., Sato, T., 
Taki, H., &amp; Makino, S. I. (2012). Biodiversity of man-made open habitats 
in an underused country: a class of multispecies abundance models for 
count data. Biodiversity and Conservation, 21(6), 1365-1380.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(5, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
# Abundance 
beta.mean &lt;- c(0, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
# Detection
alpha.mean &lt;- c(0, 0.5, 0.8)
tau.sq.alpha &lt;- c(0.2, 1, 1.5)
p.det &lt;- length(alpha.mean)
# Random effects
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, alpha = alpha,
                 mu.RE = mu.RE, p.RE = p.RE, sp = FALSE, family = 'Poisson')

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
X.re &lt;- dat$X.re
X.p.re &lt;- dat$X.p.re

# Package all data into a list
abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')
det.covs &lt;- list(det.cov.1 = as.data.frame(X.p[, , 2]),
                 det.cov.2 = as.data.frame(X.p[, , 3]))
data.list &lt;- list(y = y,
                  abund.covs = abund.covs,
                  det.covs = det.covs)
prior.list &lt;- list(beta.comm.normal = list(mean = rep(0, p.abund), 
                                           var = rep(100, p.abund)),
                   alpha.comm.normal = list(mean = rep(0, p.det),
                                            var = rep(2.72, p.det)),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
inits.list &lt;- list(beta.comm = 0, alpha.comm = 0,
                   beta = 0, alpha = 0,
                   tau.sq.beta = 0.5, tau.sq.alpha = 0.5,
                   N = apply(y, c(1, 2), max, na.rm = TRUE))
tuning.list &lt;- list(beta = 0.5, alpha = 0.5)

n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 0 
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- msNMix(abund.formula = ~ abund.cov.1,
              det.formula = ~ det.cov.1 + det.cov.2,
              data = data.list,
              n.batch = n.batch,
              inits = inits.list,
              priors = prior.list,
              tuning = tuning.list,
              batch.length = batch.length,
              n.omp.threads = 1,
              verbose = TRUE,
              n.report = 1,
              n.burn = n.burn,
              n.thin = n.thin,
              n.chains = n.chains)

summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='neonDWP'>Distance sampling data of 16 bird species  
observed in the Disney Wilderness Preserve in 2018 in Florida, USA</h2><span id='topic+neonDWP'></span>

<h3>Description</h3>

<p>Distance sampling data of 16 bird species in 2018 in the Disney Wilderness Preserve 
in Florida, USA. These data were collected as part of the National Ecological 
Observatory Network (NEON). Data were collected at 90 sites where observers recorded
the number of all bird species observed during a six minute, unlimited radius point count survey once
during the breeding season. Distance of each individual bird to the observer was 
recorded using a laser rangefinder. For modeling, we binned the distance measurements into 
4 distance bins, and only used observations within 250m. The 16 species included in the data set are as follows: 
(1) EATO (Eastern Towhee); (2) EAME (Eastern Meadowlark); (3) AMCR (American Crow);
(4) BACS (Bachman's Sparrow); (5) CARW (Carolina Wren); (6) COGD (Common Ground Dove); 
(7) CONI (Common Nighthawk); (8) COYE (Common Yellowthroat); (9) EABL (Eastern Bluebird);
(10) GCFL (Great-crested Flycatcher); (11) MODO (Mourning Dover); (12) NOCA (Northern Cardinal);
(13) NOMO (Northern Mockingbird); (14) RBWO (Red-bellied Woodpecker); (15) RHWO (Red-headed Woodpecker); 
(16) WEVI (White-eyed Vireo).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neonDWP)
</code></pre>


<h3>Format</h3>

<p><code>neonDWP</code> is a list with five elements: 
</p>
<p><code>y</code>: a three-dimensional array of distance sampling data with 
dimensions of species (16), sites (90) and distance bin (4). 
</p>
<p><code>covs</code>: a data frame with 90 rows and four columns consisting of 
covariates for use in modeling abundance and/or detection.
</p>
<p><code>dist.breaks</code>: a vector of five values indicating the break points 
of the four distance bands in the data.
</p>
<p><code>offset</code>: an offset used to scale the 250m radius point count surveys 
to ha, such that resulting estimates will be the number of individuals 
per ha.
</p>
<p><code>coords</code>: a numeric matrix with 373 rows and two columns containing the 
site coordinates (Easting and Northing) in UTM Zone 17N. The EPSG is 32617. 
</p>


<h3>Note</h3>

<p>These data were updated on November 28, 2023 (v0.1.1), and thus any analyses run 
with the data from v0.1.0 will not give the same results. The data were updated after
NEON discovered an error in how the bird count data was associated with the spatial 
locations of each site. These data have been updated following the procedures
outlined at <a href="https://www.neonscience.org/impact/observatory-blog/bird-point-ids-within-grids-were-transposed-resulting-inaccurate-point">https://www.neonscience.org/impact/observatory-blog/bird-point-ids-within-grids-were-transposed-resulting-inaccurate-point</a>.</p>


<h3>Source</h3>

<p>NEON (National Ecological Observatory Network). Breeding landbird point 
counts (DP1.10003.001), RELEASE-2023. https://doi.org/10.48443/00pg-vm19. 
Dataset accessed from https://data.neonscience.org on May 25, 2023</p>


<h3>References</h3>

<p>Barnett, D. T., Duffy, P. A., Schimel, D. S., Krauss, R. E., Irvine, K. M., 
Davis, F. W.,Gross, J. E., Azuaje, E. I., Thorpe, A. S., Gudex-Cross, D., et al. (2019). 
The terrestrial organism and biogeochemistry spatial sampling design for 
the national ecological observatory network. Ecosphere, 10(2):e02540.
</p>

<hr>
<h2 id='neonPredData'>Land cover covariates and coordinates at a 1ha resolution across Disney Wilderness Preserve</h2><span id='topic+neonPredData'></span>

<h3>Description</h3>

<p>Land cover covariates (forest cover and grassland cover) extracted at 
a 1km resolution across the Disney Wildnerss Preserve for use in predicting density 
across the park. Land cover data come from USGS EROS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neonPredData)
</code></pre>


<h3>Format</h3>

<p><code>neonPredData</code> is a data frame with four columns: 
</p>
<p><code>forest</code>: proportion of forest cover within 1km radius.
</p>
<p><code>grass</code>: proportion of grassland cover within 1km radius.
</p>
<p><code>Easting</code>: the x coordinate of the point. The EPSG is 32617 (UTM Zone 17N).
</p>
<p><code>Northing</code>: the y coordinate of the point. The EPSG is 32617 (UTM Zone 17N).
</p>


<h3>Source</h3>

<p>USGS Earth Resources Observation and Science Ceneter https://www.usgs.gov/centers/eros</p>

<hr>
<h2 id='NMix'>Function for Fitting Single-Species N-mixture Models</h2><span id='topic+NMix'></span>

<h3>Description</h3>

<p>Function for fitting single-species N-mixture models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMix(abund.formula, det.formula, data, inits, priors, tuning,
     n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
     n.omp.threads = 1, verbose = TRUE,
     n.report = 100, n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
     n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMix_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="NMix_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="NMix_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>abund.covs</code>, <code>det.covs</code>, and <code>offset</code>. <code>y</code>
is a matrix or data frame of the observed count values, 
with first dimension equal to the number of 
sites (<code class="reqn">J</code>) and second dimension equal to the maximum number of 
replicates at a given site. <code>abund.covs</code> is a matrix or data frame
containing the variables used in the abundance portion of the model, with
<code class="reqn">J</code> rows for each column (variable). <code>det.covs</code> is a list of
variables included in the detection portion of the model. Each list element
is a different detection covariate, which can be site-level or 
observational-level. Site-level covariates are specified as a vector 
of length <code class="reqn">J</code> while observation-level covariates are specified 
as a matrix or data frame with the number of rows equal to <code class="reqn">J</code> and 
number of columns equal to the maximum number of replicates at a given site. <code>offset</code>
is an offset to use in the abundance model (e.g., an area offset). This can be either a single
value or a vector with an offset for each site (e.g., if survey area differed in size).</p>
</td></tr>
<tr><td><code id="NMix_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>N</code>, <code>beta</code>, <code>alpha</code>, <code>kappa</code>, 
<code>sigma.sq.mu</code>, and <code>sigma.sq.p</code>. The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.mu</code> and <code>sigma.sq.p</code> are 
only relevant when including random effects in the abundance and 
detection portion of the model, respectively. <code>kappa</code> is 
only relevant when <code>family = 'NB'</code>. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="NMix_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>kappa.unif</code>, 
<code>sigma.sq.mu.ig</code>, and <code>sigma.sq.p.ig</code>. 
Abundance (<code>beta</code>) and detection (<code>alpha</code>) 
regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 100 for the abundance coefficients
and 2.72 for the detection coefficients. <code>kappa</code> is the negative binomial 
dispersion parameter and is assumed to follow a uniform distribution. The 
hyperparameters of the uniform distribution are passed as a vector of length
two with the first and second elements corresponding to the lower and upper
bounds of the uniform distribution. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts/slopes or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="NMix_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, 
whose value defines the initial variance of the adaptive sampler. 
Valid tags are <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="NMix_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="NMix_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="NMix_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="NMix_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr> 
<tr><td><code id="NMix_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="NMix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="NMix_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and MCMC progress.</p>
</td></tr>
<tr><td><code id="NMix_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="NMix_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="NMix_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="NMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>NMix</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance dispersion parameter. Only included when
<code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent abundance values</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent expected abundance values</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size 
from spatially replicated counts. Biometrics, 60(1), 108-115.
<a href="https://doi.org/10.1111/j.0006-341X.2004.00142.x">doi:10.1111/j.0006-341X.2004.00142.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1010)
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0, -1.5)
p.abund &lt;- length(beta)
alpha &lt;- c(0.5, 1.2, -0.5)
p.det &lt;- length(alpha)
mu.RE &lt;- list()
p.RE &lt;- list()
phi &lt;- 3/.6
sigma.sq &lt;- 2
kappa &lt;- 0.3
sp &lt;- FALSE 
cov.model &lt;- 'exponential'
dist &lt;- 'NB'
dat &lt;- simNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
               kappa = kappa, mu.RE = mu.RE, p.RE = p.RE, sp = sp, 
               phi = phi, sigma.sq = sigma.sq, cov.model = cov.model, 
               family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p

abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')

det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])

data.list &lt;- list(y = y, 
                  abund.covs = abund.covs,
                  det.covs = det.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.abund), 
                                      var = rep(100, p.abund)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)), 
                   kappa.unif = c(0, 10)) 
# Starting values
inits.list &lt;- list(alpha = 0,
                   beta = 0,
                   kappa = kappa, 
                   N = apply(y, 1, max, na.rm = TRUE))

n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 50
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- NMix(abund.formula = ~ abund.cov.1,
            det.formula = ~ det.cov.1 + det.cov.2, 
            data = data.list, 
            n.batch = n.batch, 
            batch.length = batch.length, 
            inits = inits.list, 
            priors = prior.list, 
            accept.rate = 0.43, 
            n.omp.threads = 1, 
            verbose = TRUE, 
            n.report = 1,
            n.burn = n.burn,
            n.thin = n.thin,
            n.chains = n.chains) 
</code></pre>

<hr>
<h2 id='ppcAbund'>Function for performing posterior predictive checks</h2><span id='topic+ppcAbund'></span>

<h3>Description</h3>

<p>Function for performing posterior predictive checks on <code>spAbundance</code> model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppcAbund(object, fit.stat, group, type = 'marginal', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppcAbund_+3A_object">object</code></td>
<td>
<p>an object of class <code>NMix</code>, <code>spNMix</code>, 
<code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>,
<code>abund</code>, <code>spAbund</code>, <code>msAbund</code>, 
<code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>DS</code>, <code>spDS</code>, 
<code>msDS</code>, <code>lfMsDS</code>, <code>sfMsDS</code>.</p>
</td></tr>
<tr><td><code id="ppcAbund_+3A_fit.stat">fit.stat</code></td>
<td>
<p>a quoted keyword that specifies the fit statistic
to use in the posterior predictive check. Supported fit statistics are
<code>"freeman-tukey"</code> and <code>"chi-squared"</code>.</p>
</td></tr>
<tr><td><code id="ppcAbund_+3A_group">group</code></td>
<td>
<p>a positive integer indicating the way to group the
abundance data for the posterior predictive check. Value 
0 will not group the data and use the raw counts, 
1 will group values by row (site), and value 2 will group values by 
column (replicate).</p>
</td></tr> 
<tr><td><code id="ppcAbund_+3A_type">type</code></td>
<td>
<p>a character string indicating whether fitted values should be generated conditional on the estimated latent abundance values (<code>type = 'conditional'</code>) estimated during the model or based on the marginal expected abundance values (<code>type = 'marginal'</code>). This is only relevant for N-mixture models.</p>
</td></tr>
<tr><td><code id="ppcAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ppcAbund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>fit.y</code></td>
<td>
<p>a numeric vector of posterior samples for the 
fit statistic calculated on the observed data when <code>object</code> is 
of class <code>NMix</code>, <code>spNMix</code>, <code>abund</code>, <code>spAbund</code>, <code>DS</code>, or <code>spDS</code>. 
When <code>object</code> is of class <code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>,
<code>msAbund</code>, <code>lfMsAbund</code>, <code>sfMsAbund</code>, 
<code>msDS</code>, <code>lfMsDS</code>, <code>sfMsDS</code>, 
this is a numeric matrix with rows corresponding to posterior samples
and columns corresponding to species.</p>
</td></tr>
<tr><td><code>fit.y.rep</code></td>
<td>
<p>a numeric vector of posterior samples for the 
fit statistic calculated on a replicate data set generated from the 
model when <code>object</code> is of class <code>NMix</code>, <code>spNMix</code>, <code>abund</code>, 
<code>spAbund</code>, <code>DS</code>, <code>spDS</code>. When <code>object</code> is of 
class <code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>, <code>msAbund</code>, 
<code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>msDS</code>, <code>lfMsDS</code>, <code>sfMsDS</code>,
this is a numeric matrix with rows corresponding to posterior samples
and columns corresponding to species.</p>
</td></tr>
<tr><td><code>fit.y.group.quants</code></td>
<td>
<p>a matrix consisting of posterior quantiles
for the fit statistic using the observed data for each unique element
the fit statistic is calculated for (i.e., observations when group = 0, sites when group = 1,
replicates when group = 2) when <code>object</code> is of class <code>NMix</code>, <code>spNMix</code>, 
<code>abund</code>, <code>spAbund</code>, <code>DS</code>, or <code>spDS</code>. 
When <code>object</code> is of class <code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>, 
<code>msAbund</code>, <code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>msDS</code>, 
<code>lfMsDS</code>, <code>sfMsDS</code>, this is a three-dimensional
array with the additional dimension corresponding to species.</p>
</td></tr>
<tr><td><code>fit.y.rep.group.quants</code></td>
<td>
<p>a matrix consisting of posterior quantiles
for the fit statistic using the model replicated data for each unique element
the fit statistic is calculated for (i.e., observations when group = 0, sites when group = 1, 
replicates when group = 2) when <code>object</code> is of class <code>NMix</code>, <code>spNMix</code>, 
<code>abund</code>, <code>spAbund</code>, <code>DS</code>, <code>spDS</code>. 
When <code>object</code> is of class <code>msNMix</code>, <code>sfMsNMix</code>, <code>msAbund</code>, 
<code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>msDS</code>, <code>lfMsDS</code>, 
<code>sfMsDS</code>, this is a three-dimensional
array with the additional dimension corresponding to species.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
standard extractor functions. 
</p>


<h3>Note</h3>

<p><code>ppcAbund</code> will return an error for Gaussian or zero-inflated Gaussian models. 
For Gaussian models, standard residual diagnostics can be used to assess model fit.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1010)
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0, -1.5)
p.abund &lt;- length(beta)
alpha &lt;- c(0.5, 1.2, -0.5)
p.det &lt;- length(alpha)
mu.RE &lt;- list()
p.RE &lt;- list()
phi &lt;- 3/.6
sigma.sq &lt;- 2
kappa &lt;- 0.3
sp &lt;- FALSE 
cov.model &lt;- 'exponential'
dist &lt;- 'NB'
dat &lt;- simNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
               kappa = kappa, mu.RE = mu.RE, p.RE = p.RE, sp = sp, 
               phi = phi, sigma.sq = sigma.sq, cov.model = cov.model, 
               family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p

abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')

det.covs &lt;- list(det.cov.1 = X.p[, , 2], det.cov.2 = X.p[, , 3])

data.list &lt;- list(y = y, abund.covs = abund.covs,
                  det.covs = det.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.abund), 
                                      var = rep(100, p.abund)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)), 
                   kappa.unif = c(0, 10)) 
# Starting values
inits.list &lt;- list(alpha = 0, beta = 0, kappa = kappa, 
                   N = apply(y, 1, max, na.rm = TRUE))


tuning &lt;- 0.5
n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 50
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- NMix(abund.formula = ~ abund.cov.1,
            det.formula = ~ det.cov.1 + det.cov.2, 
            data = data.list, 
            n.batch = n.batch, 
            batch.length = batch.length, 
            inits = inits.list, 
            priors = prior.list, 
            accept.rate = 0.43, 
            n.omp.threads = 1, 
            verbose = TRUE, 
            n.report = 1,
            n.burn = n.burn,
            n.thin = n.thin,
            n.chains = n.chains) 

# Posterior predictive check
ppc.out &lt;- ppcAbund(out, fit.stat = 'chi-squared', group = 0)
summary(ppc.out)
</code></pre>

<hr>
<h2 id='predict.abund'>Function for prediction at new locations for univariate GLMMs</h2><span id='topic+predict.abund'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'abund'.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'abund'
predict(object, X.0, ignore.RE = FALSE, z.0.samples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.abund_+3A_object">object</code></td>
<td>
<p>an object of class abund</p>
</td></tr>
<tr><td><code id="predict.abund_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, replicate, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>abund</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>abund</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>abund</code>. See example below. If there is only one replicate per location, the design matrix can be a two-dimensional matrix instead of a three-dimensional array.</p>
</td></tr>
<tr><td><code id="predict.abund_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove unstructured random effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.abund_+3A_z.0.samples">z.0.samples</code></td>
<td>
<p>a matrix with rows corresponding to MCMC samples and columns corresponding to prediction locations containing the full posterior samples of the predicted binary portion of a zero-inflated Gaussian model. In the context of abundance models, this typically corresponds to estimates of the presence or absence of the species at the location. When using <code>spOccupancy</code> to generate the first stage samples of the zero-inflated Gaussian model, this is the object contained in the <code>z.0.samples</code> object of the predition function for the spOccupancy object. Ignored for all model types other than zero-inflated Gaussian.</p>
</td></tr>
<tr><td><code id="predict.abund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.abund</code>. The list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
expected abundance values with dimensions corresponding to posterior predictive
sample, site, and replicate. When there is no replication, this will be a two-dimensional
matrix. Note if an offset was used when fitting the model with <code>abund</code>, the abundance
values are reported per unit of the offset.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
abundance values with dimensions corresponding to posterior predictive sample, site, 
and replicate. When there is no replication, this will be a two-dimensional matrix.
These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1010)
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
n.rep &lt;- sample(1, J, replace = TRUE)
beta &lt;- c(0, -1.5, 0.3, -0.8)
p.abund &lt;- length(beta)
mu.RE &lt;- list()
kappa &lt;- 0.5
sp &lt;- FALSE 
family &lt;- 'NB'
dat &lt;- simAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, 
                kappa = kappa, mu.RE = mu.RE, sp = sp, family = 'NB')

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , ]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])

abund.covs &lt;- list(int = X[, , 1], 
                   abund.cov.1 = X[, , 2], 
                   abund.cov.2 = X[, , 3], 
                   abund.cov.3 = X[, , 4])

data.list &lt;- list(y = y, covs = abund.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 100),
                   kappa.unif = c(0.001, 10)) 
# Starting values
inits.list &lt;- list(beta = 0, kappa = kappa)

n.batch &lt;- 5
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- abund(formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
             data = data.list, 
             n.batch = n.batch, 
             batch.length = batch.length, 
             inits = inits.list, 
             priors = prior.list, 
             accept.rate = 0.43, 
             n.omp.threads = 1, 
             verbose = TRUE, 
             n.report = 1,
             n.burn = n.burn,
             n.thin = n.thin,
             n.chains = n.chains) 

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov', 'abund.cov.2', 'abund.cov.3')
out.pred &lt;- predict(out, X.0)
mu.0.quants &lt;- apply(out.pred$mu.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(dat$mu[pred.indx], mu.0.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(mu.0.quants), max(mu.0.quants)))
segments(dat$mu[pred.indx], mu.0.quants[1, ], dat$mu[pred.indx], mu.0.quants[3, ])
lines(dat$mu[pred.indx], dat$mu[pred.indx])
</code></pre>

<hr>
<h2 id='predict.DS'>Function for prediction at new locations for single-species hierarchical distance sampling models</h2><span id='topic+predict.DS'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'DS'. Prediction is possible for both the latent abundance state as well as detection. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DS'
predict(object, X.0, ignore.RE = FALSE, type = 'abundance', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.DS_+3A_object">object</code></td>
<td>
<p>an object of class DS</p>
</td></tr>
<tr><td><code id="predict.DS_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>DS</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>DS</code>. Column names of all variables must match the names of variables used when fitting the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.DS_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random abundance (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.DS_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict latent abundance and expected abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.DS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.DS</code>. When <code>type = 'abundance'</code>, the list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
expected abundance values, or expected abundance per unit area (i.e., density) values
when an offset was used when fitting the model with <code>DS()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>sigma.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for sigma 
(the parameter controlling detection probability).</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Abundance coefficients
beta &lt;- c(1.0, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta)
# Detection coefficients
alpha &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
sp &lt;- FALSE 
family &lt;- 'NB'
kappa &lt;- 0.1
offset &lt;- 1.8
transect &lt;- 'point'

dat &lt;- simDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
             beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
             mu.RE = mu.RE, p.RE = p.RE, sp = sp, family = family, 
             offset = offset, transect = transect)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, ]
dist.breaks &lt;- dat$dist.breaks

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  offset = offset)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 10),
                   alpha.normal = list(mean = 0,
                                       var = 10), 
                   kappa.unif = c(0, 100)) 
# Starting values
inits.list &lt;- list(alpha = 0,
                   beta = 0,
                   kappa = 1)
# Tuning values
tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.2) 

out &lt;- DS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
          det.formula = ~ det.cov.1,
          data = data.list, 
          n.batch = 10, 
          batch.length = 25, 
          inits = inits.list, 
          family = 'NB',
          det.func = 'halfnormal', 
          transect = 'point', 
          tuning = tuning,
          priors = prior.list, 
          accept.rate = 0.43, 
          n.omp.threads = 1, 
          verbose = TRUE, 
          n.report = 100,
          n.burn = 100,
          n.thin = 1,
          n.chains = 1) 
summary(out)

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3')
out.pred &lt;- predict(out, X.0)
mu.0.quants &lt;- apply(out.pred$mu.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(dat$mu[pred.indx], mu.0.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(mu.0.quants), max(mu.0.quants)))
segments(dat$mu[pred.indx], mu.0.quants[1, ], dat$mu[pred.indx], mu.0.quants[3, ])
lines(dat$mu[pred.indx], dat$mu[pred.indx])
</code></pre>

<hr>
<h2 id='predict.lfMsAbund'>Function for prediction at new locations for latent factor multivariate GLMMs</h2><span id='topic+predict.lfMsAbund'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'lfMsAbund'.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsAbund'
predict(object, X.0, coords.0, ignore.RE = FALSE, z.0.samples, include.w = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lfMsAbund_+3A_object">object</code></td>
<td>
<p>an object of class lfMsAbund</p>
</td></tr>
<tr><td><code id="predict.lfMsAbund_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This can be either a two-dimensional matrix with rows corresponding to sites and columns corresponding to covariates, or can be a three-dimensional array, with dimensions corresponding to site, replicate, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>lfMsAbund</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>lfMsAbund</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>lfMsAbund</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.lfMsAbund_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. 
Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.lfMsAbund_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove unstructured random effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.lfMsAbund_+3A_z.0.samples">z.0.samples</code></td>
<td>
<p>a three-dimensional array with dimensions corresponding to MCMC samples, species, and prediction locations. The array contains the full posterior samples of the predicted binary portion of a Gaussian zero-inflated model. In the context of abundance models, this typically corresponds to estimates of the presence or absence of each species at the location. When using <code>spOccupancy</code> to generate the first stage samples of the zi-Gaussian model, this is the object contained in the <code>z.0.samples</code> object of the predition function for the spOccupancy object. Ignored for all model types other than zi-Gaussian.</p>
</td></tr>
<tr><td><code id="predict.lfMsAbund_+3A_include.w">include.w</code></td>
<td>
<p>a logical value used to indicate whether the latent random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords.0</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.lfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.lfMsAbund</code>. The list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
expected abundance values with dimensions corresponding to posterior predictive
sample, species, site, and replicate. Note if an offset was used when fitting the model
with <code>lfMsAbund</code>, the abundance values are reported per unit of the offset.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
abundance values with dimensions corresponding to posterior predictive sample, species, site, 
and replicate. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent factors.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
mu.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- FALSE
kappa &lt;- runif(n.sp, 0.1, 1)
factor.model &lt;- TRUE
n.factors &lt;- 3

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta,
                  mu.RE = mu.RE, sp = sp, kappa = kappa, family = 'NB', 
                  factor.model = factor.model, n.factors = n.factors)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
# Prediction values
y.0 &lt;- dat$y[, pred.indx, , drop = FALSE]
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
coords.0 &lt;- dat$coords[pred.indx, ]

# Package all data into a list
covs &lt;- list(int = X[, , 1],
             abund.cov.1 = X[, , 2])
data.list &lt;- list(y = y, covs = covs, coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   kappa.unif = list(a = 0, b = 10),
                   tau.sq.beta.ig = list(a = .1, b = .1))
inits.list &lt;- list(beta.comm = 0,
                   beta = 0,
                   kappa = 0.5,
                   tau.sq.beta = 1)
tuning.list &lt;- list(kappa = 0.3, beta = 0.1, lambda = 0.5, w = 0.5)

# Small
n.batch &lt;- 2
batch.length &lt;- 25
n.burn &lt;- 20
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- lfMsAbund(formula = ~ abund.cov.1,
                 data = data.list,
                 n.batch = n.batch,
                 inits = inits.list,
                 priors = prior.list,
                 tuning = tuning.list,
                 batch.length = batch.length,
                 n.omp.threads = 1,
                 n.factors = 1,
                 verbose = TRUE,
                 n.report = 1,
                 n.burn = n.burn,
                 n.thin = n.thin,
                 n.chains = n.chains)

# Predict at new locations
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.lfMsDS'>Function for prediction at new locations for latent factor multi-species hierarchical distance sampling models</h2><span id='topic+predict.lfMsDS'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'lfMsDS'. Prediction is possible for both the latent abundance state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsDS'
predict(object, X.0, coords.0, ignore.RE = FALSE, 
        type = 'abundance', include.w = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lfMsDS_+3A_object">object</code></td>
<td>
<p>an object of class lfMsDS</p>
</td></tr>
<tr><td><code id="predict.lfMsDS_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>lfMsDS</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>lfMsDS</code>. Column names must match the names of the variables used to fit the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.lfMsDS_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.lfMsDS_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.lfMsDS_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict expected abundance and latent abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.lfMsDS_+3A_include.w">include.w</code></td>
<td>
<p>a logical value used to indicate whether the latent random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords.0</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.lfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.lfMsDS</code>. When <code>type = 'abundance'</code>, the list consists of:  
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
expected abundance values, or expected abundance values per unit area (i.e., density)
values when an offset was used when fitting the model with <code>lfMsDS()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>sigma.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for
sigma (the parameter controlling detection probability).</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(210)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Number of species
n.sp &lt;- 5
# Community-level abundance coefficients
beta.mean &lt;- c(-1, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 0.3, 0.5, 0.4)
# Detection coefficients
alpha.mean &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha.mean)
tau.sq.alpha &lt;- c(0.1, 0.2)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- FALSE 
family &lt;- 'NB'
kappa &lt;- runif(n.sp, 0.3, 3) 
offset &lt;- pi * .8^2
transect &lt;- 'line'
factor.model &lt;- TRUE
n.factors &lt;- 3

dat &lt;- simMsDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
               n.sp = n.sp, beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
               mu.RE = mu.RE, p.RE = p.RE, sp = sp, cov.model = cov.model,
               sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
               offset = offset, transect = transect, factor.model = factor.model, 
               n.factors = n.factors)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , drop = FALSE]
X.p.0 &lt;- dat$X.p[pred.indx, , drop = FALSE]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
dist.breaks &lt;- dat$dist.breaks

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  coords = coords,
                  offset = offset)

# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 10),
                   alpha.comm.normal = list(mean = 0,
                                            var = 10), 
                   kappa.unif = list(0, 100), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1)) 
# Starting values
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, kappa = 1)

tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.8, lambda = 1, w = 1) 

n.batch &lt;- 4 
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- lfMsDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
              det.formula = ~ det.cov.1,
              data = data.list, 
              n.batch = n.batch, 
              batch.length = batch.length, 
              inits = inits.list, 
              family = 'Poisson',
              det.func = 'halfnormal', 
              transect = transect, 
              tuning = tuning,
              n.factors = n.factors,
              priors = prior.list, 
              accept.rate = 0.43, 
              n.omp.threads = 1, 
              verbose = TRUE, 
              n.report = 10,
              n.burn = n.burn,
              n.thin = n.thin,
              n.chains = n.chains) 
summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3')
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.lfMsNMix'>Function for prediction at new locations for latent factor multi-species N-mixture models</h2><span id='topic+predict.lfMsNMix'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'lfMsNMix'. Prediction is possible for both the latent abundance state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsNMix'
predict(object, X.0, coords.0, ignore.RE = FALSE, 
        type = 'abundance', include.w = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lfMsNMix_+3A_object">object</code></td>
<td>
<p>an object of class lfMsNMix</p>
</td></tr>
<tr><td><code id="predict.lfMsNMix_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>lfMsNMix</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>lfMsNMix</code>. Column names must match the names of the variables used to fit the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.lfMsNMix_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system. This is not a required argument, but can be used if some of the prediction sites are the same sites as those used to fit the data, in which case the latent factors estimated during model fitting can be used to improve the predictions. If predicting at different sites than those used to fit the data, this argument will not have any influence on model results.</p>
</td></tr>
<tr><td><code id="predict.lfMsNMix_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.lfMsNMix_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict expected abundance and latent abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.lfMsNMix_+3A_include.w">include.w</code></td>
<td>
<p>a logical value used to indicate whether the latent random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords.0</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.lfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.lfMsNMix</code>. When <code>type = 'abundance'</code>, the list consists of:  
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
expected abundance values. Note these will be per unit area if an offset was used when 
fitting the model with <code>lfMsNMix()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
# Abundance
beta.mean &lt;- c(0.2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
family &lt;- 'Poisson'
n.factors &lt;- 3

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, alpha = alpha,
                 sp = FALSE, family = 'Poisson', factor.model = TRUE, 
                 n.factors = n.factors)
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
mu.0 &lt;- dat$psi[, pred.indx]
coords.0 &lt;- dat$coords[pred.indx, ]
# Package all data into a list
abund.covs &lt;- X[, 2, drop = FALSE]
colnames(abund.covs) &lt;- c('abund.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  abund.covs = abund.covs,
                  det.covs = det.covs, 
                  coords = coords)

# Occupancy initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
# Initial values
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   N = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning values
tuning &lt;- list(beta = 0.3, alpha = 0.3, lambda = 0.5, w = 0.5)
n.batch &lt;- 4
batch.length &lt;- 25
accept.rate &lt;- 0.43

out &lt;- lfMsNMix(abund.formula = ~ abund.cov, 
                det.formula = ~ det.cov.1 + det.cov.2, 
                data = data.list, 
                inits = inits.list, 
                family = 'Poisson', 
                n.factors = n.factors,
                n.batch = n.batch,
                batch.length = batch.length, 
                accept.rate = 0.43,
                tuning = tuning,
                priors = prior.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                n.report = 1)

summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.msAbund'>Function for prediction at new locations for multivariate GLMMs</h2><span id='topic+predict.msAbund'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'msAbund'.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msAbund'
predict(object, X.0, ignore.RE = FALSE, z.0.samples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.msAbund_+3A_object">object</code></td>
<td>
<p>an object of class msAbund</p>
</td></tr>
<tr><td><code id="predict.msAbund_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This can be either a two-dimensional matrix with rows corresponding to sites and columns corresponding to covariates, or can be a three-dimensional array, with dimensions corresponding to site, replicate, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>msAbund</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>msAbund</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>msAbund</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.msAbund_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove unstructured random effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.msAbund_+3A_z.0.samples">z.0.samples</code></td>
<td>
<p>a three-dimensional array with dimensions corresponding to MCMC samples, species, and prediction locations. The array contains the full posterior samples of the predicted binary portion of a Gaussian zero-inflated model. In the context of abundance models, this typically corresponds to estimates of the presence or absence of each species at the location. When using <code>spOccupancy</code> to generate the first stage samples of the zi-Gaussian model, this is the object contained in the <code>z.0.samples</code> object of the predition function for the spOccupancy object. Ignored for all model types other than zi-Gaussian.</p>
</td></tr>
<tr><td><code id="predict.msAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.msAbund</code>. The list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
expected abundance values with dimensions corresponding to posterior predictive
sample, species, site, and replicate. Note if an offset was used when fitting the model with 
<code>msAbund</code>, the abundance values are reported per unit of the offset.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
abundance values with dimensions corresponding to posterior predictive sample, species, site, 
and replicate. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
mu.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- FALSE
kappa &lt;- runif(n.sp, 0.1, 1)

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta,
                  mu.RE = mu.RE, sp = sp, kappa = kappa, family = 'NB')

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction values
y.0 &lt;- dat$y[, pred.indx, , drop = FALSE]
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]

# Package all data into a list
covs &lt;- list(int = X[, , 1], abund.cov.1 = X[, , 2])
data.list &lt;- list(y = y, covs = covs)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   kappa.unif = list(a = 0, b = 10),
                   tau.sq.beta.ig = list(a = .1, b = .1))
inits.list &lt;- list(beta.comm = 0,
                   beta = 0,
                   kappa = 0.5,
                   tau.sq.beta = 1)
tuning.list &lt;- list(kappa = 0.3, beta = 0.1)

# Small
n.batch &lt;- 2
batch.length &lt;- 25
n.burn &lt;- 20
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- msAbund(formula = ~ abund.cov.1,
               data = data.list,
               n.batch = n.batch,
               inits = inits.list,
               priors = prior.list,
               tuning = tuning.list,
               batch.length = batch.length,
               n.omp.threads = 1,
               verbose = TRUE,
               n.report = 1,
               n.burn = n.burn,
               n.thin = n.thin,
               n.chains = n.chains)

# Predict at new locations
out.pred &lt;- predict(out, X.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.msDS'>Function for prediction at new locations for multi-species hierarchical distance sampling models</h2><span id='topic+predict.msDS'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'msDS'. Prediction is possible for both the latent abundance state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msDS'
predict(object, X.0, ignore.RE = FALSE, type = 'abundance', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.msDS_+3A_object">object</code></td>
<td>
<p>an object of class msDS</p>
</td></tr>
<tr><td><code id="predict.msDS_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>msDS</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>msDS</code>. Column names must match the names of the variables used to fit the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.msDS_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.msDS_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict expected abundance and latent abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.msDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.msDS</code>. When <code>type = 'abundance'</code>, the list consists of:  
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
expected abundance values, or expected abundance values per unit area (i.e., density)
values when an offset was used when fitting the model with <code>msDS()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>sigma.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for
sigma (the parameter controlling detection probability).</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(210)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Number of species
n.sp &lt;- 5
# Community-level abundance coefficients
beta.mean &lt;- c(-1, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 0.3, 0.5, 0.4)
# Detection coefficients
alpha.mean &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha.mean)
tau.sq.alpha &lt;- c(0.1, 0.2)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- FALSE 
family &lt;- 'Poisson'
kappa &lt;- runif(n.sp, 0.3, 3) 
offset &lt;- pi * .8^2
transect &lt;- 'line'
factor.model &lt;- FALSE

dat &lt;- simMsDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
               n.sp = n.sp, beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
               mu.RE = mu.RE, p.RE = p.RE, sp = sp, cov.model = cov.model,
               sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
               offset = offset, transect = transect, factor.model = factor.model)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , drop = FALSE]
X.p.0 &lt;- dat$X.p[pred.indx, , drop = FALSE]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
dist.breaks &lt;- dat$dist.breaks

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  offset = offset)

# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 10),
		   alpha.comm.normal = list(mean = 0,
			               var = 10), 
                   kappa.unif = list(0, 100), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1)) 
# Starting values
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
		   alpha = 0, kappa = 1)

tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.8) 

n.batch &lt;- 4 
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- msDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
            det.formula = ~ det.cov.1,
            data = data.list, 
            n.batch = n.batch, 
            batch.length = batch.length, 
            inits = inits.list, 
            family = 'Poisson',
            det.func = 'halfnormal', 
            transect = transect, 
            tuning = tuning,
            priors = prior.list, 
            accept.rate = 0.43, 
            n.omp.threads = 1, 
            verbose = TRUE, 
            n.report = 10,
            n.burn = n.burn,
            n.thin = n.thin,
            n.chains = n.chains) 
summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3')
out.pred &lt;- predict(out, X.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.msNMix'>Function for prediction at new locations for multi-species N-mixture models</h2><span id='topic+predict.msNMix'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'msNMix'. Prediction is possible for both the latent abundance state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msNMix'
predict(object, X.0, ignore.RE = FALSE, type = 'abundance', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.msNMix_+3A_object">object</code></td>
<td>
<p>an object of class msNMix</p>
</td></tr>
<tr><td><code id="predict.msNMix_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>msNMix</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>msNMix</code>. Column names must match the names of the variables used to fit the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.msNMix_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.msNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
<tr><td><code id="predict.msNMix_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict expected abundance and latent abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.msNMix</code>. When <code>type = 'abundance'</code>, the list consists of:  
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
expected abundance values. Note these will be per unit area if an offset was used when 
fitting the model with <code>msNMix()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
# Abundance
beta.mean &lt;- c(0.2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
family &lt;- 'Poisson'

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, alpha = alpha,
                 sp = FALSE, family = 'Poisson')
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
mu.0 &lt;- dat$psi[, pred.indx]
# Package all data into a list
abund.covs &lt;- X[, 2, drop = FALSE]
colnames(abund.covs) &lt;- c('abund.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  abund.covs = abund.covs,
                  det.covs = det.covs)

# Occupancy initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
# Initial values
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   N = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning values
tuning &lt;- list(beta = 0.3, alpha = 0.3)
n.batch &lt;- 4
batch.length &lt;- 25
accept.rate &lt;- 0.43

out &lt;- msNMix(abund.formula = ~ abund.cov, 
              det.formula = ~ det.cov.1 + det.cov.2, 
              data = data.list, 
              inits = inits.list, 
              family = 'Poisson', 
              n.batch = n.batch,
              batch.length = batch.length, 
              accept.rate = 0.43,
              tuning = tuning,
              priors = prior.list, 
              n.omp.threads = 1, 
              verbose = TRUE, 
              n.report = 1)

summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.NMix'>Function for prediction at new locations for single-species N-mixture models</h2><span id='topic+predict.NMix'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'NMix'. Prediction is possible for both the latent abundance state as well as detection. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMix'
predict(object, X.0, ignore.RE = FALSE, type = 'abundance', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.NMix_+3A_object">object</code></td>
<td>
<p>an object of class NMix</p>
</td></tr>
<tr><td><code id="predict.NMix_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>NMix</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>NMix</code>. Column names of all variables must match the names of variables used when fitting the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.NMix_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random abundance (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.NMix_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict latent abundance and expected abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.NMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.NMix</code>. When <code>type = 'abundance'</code>, the list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
expected abundance values. Note these will be per unit area if an offset
was used when fitting the model with <code>NMix()</code></p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, 2)
p.abund &lt;- length(beta)
alpha &lt;- c(0, 1)
p.det &lt;- length(alpha)
dat &lt;- simNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
               sp = FALSE)
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]

# Package all data into a list
abund.covs &lt;- X[, 2, drop = FALSE]
colnames(abund.covs) &lt;- c('abund.cov')
det.covs &lt;- list(det.cov = X.p[, , 2])
data.list &lt;- list(y = y, 
                  abund.covs = abund.covs,
                  det.covs = det.covs)
# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.abund),
                                      var = rep(100, p.abund)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)), 
                   kappa.unif = c(0.001, 10))
# Initial values
inits.list &lt;- list(alpha = rep(0, p.det),
                   beta = rep(0, p.abund),
                   kappa = 0.5,
                   N = apply(y, 1, max, na.rm = TRUE))

n.batch &lt;- 10
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- NMix(abund.formula = ~ abund.cov, 
            det.formula = ~ det.cov,
            data = data.list, 
            inits = inits.list,
            n.batch = n.batch, 
            batch.length = batch.length,
            family = 'Poisson',
            priors = prior.list,
            n.omp.threads = 1,
            verbose = TRUE,
            n.report = 1, 
            n.burn = n.burn, 
            n.thin = n.thin, 
            n.chains = n.chains)

summary(out)

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov')
out.pred &lt;- predict(out, X.0)
mu.0.quants &lt;- apply(out.pred$mu.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(dat$mu[pred.indx], mu.0.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(mu.0.quants), max(mu.0.quants)))
segments(dat$mu[pred.indx], mu.0.quants[1, ], dat$mu[pred.indx], mu.0.quants[3, ])
lines(dat$mu[pred.indx], dat$mu[pred.indx])
</code></pre>

<hr>
<h2 id='predict.sfMsAbund'>Function for prediction at new locations for spatial factor multivariate GLMMs</h2><span id='topic+predict.sfMsAbund'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'sfMsAbund'.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsAbund'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, ignore.RE = FALSE, 
        z.0.samples, include.sp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sfMsAbund_+3A_object">object</code></td>
<td>
<p>an object of class sfMsAbund</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This can be either a two-dimensional matrix with rows corresponding to sites and columns corresponding to covariates, or can be a three-dimensional array, with dimensions corresponding to site, replicate, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>sfMsAbund</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>sfMsAbund</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>sfMsAbund</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. 
Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove unstructured random effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_z.0.samples">z.0.samples</code></td>
<td>
<p>a three-dimensional array with dimensions corresponding to MCMC samples, species, and prediction locations. The array contains the full posterior samples of the predicted binary portion of a zero-inflated Gaussian model. In the context of abundance models, this typically corresponds to estimates of the presence or absence of each species at the location. When using <code>spOccupancy</code> to generate the first stage samples of the zero-inflated Gaussian model, this is the object contained in the <code>z.0.samples</code> object of the predition function for the spOccupancy object. Ignored for all model types other than zero-inflated Gaussian.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_include.sp">include.sp</code></td>
<td>
<p>a logical value used to indicate whether spatial random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords.0</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.sfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.sfMsAbund</code>. The list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
expected abundance values with dimensions corresponding to posterior predictive
sample, species, site, and replicate. Note if an offset was used when fitting the model 
with <code>sfMsAbund</code>, the abundance values are reported per unit of the offset.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
abundance values with dimensions corresponding to posterior predictive sample, species, site, 
and replicate. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent factors. Array dimensions correspond to MCMC sample, latent factor, and site.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
mu.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- TRUE 
kappa &lt;- runif(n.sp, 0.1, 1)
factor.model &lt;- TRUE
n.factors &lt;- 3
cov.model &lt;- 'spherical'
phi &lt;- runif(n.factors, 3 / 1, 3 / .1)

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta,
                  mu.RE = mu.RE, sp = sp, kappa = kappa, family = 'NB', 
                  factor.model = factor.model, n.factors = n.factors, 
                  phi = phi, cov.model = cov.model)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
# Prediction values
y.0 &lt;- dat$y[, pred.indx, , drop = FALSE]
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
coords.0 &lt;- dat$coords[pred.indx, ]

# Package all data into a list
covs &lt;- list(int = X[, , 1], abund.cov.1 = X[, , 2])
data.list &lt;- list(y = y, covs = covs, coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   kappa.unif = list(a = 0, b = 10),
                   phi.unif = list(a = 3 / 1, b = 3 / .1),
                   tau.sq.beta.ig = list(a = .1, b = .1))
inits.list &lt;- list(beta.comm = 0,
                   beta = 0,
                   kappa = 0.5,
                   phi = 3 / .5,
                   tau.sq.beta = 1)
tuning.list &lt;- list(kappa = 0.3, beta = 0.1, lambda = 0.5, w = 0.5, 
                    phi = 1)

# Small
n.batch &lt;- 2
batch.length &lt;- 25
n.burn &lt;- 20
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- sfMsAbund(formula = ~ abund.cov.1,
                 data = data.list,
                 n.batch = n.batch,
                 inits = inits.list,
                 priors = prior.list,
                 tuning = tuning.list,
                 batch.length = batch.length,
                 n.omp.threads = 1,
                 n.factors = 1,
                 verbose = TRUE,
                 n.neighbors = 5, 
                 n.report = 1,
                 n.burn = n.burn,
                 n.thin = n.thin,
                 n.chains = n.chains)

# Predict at new locations
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.sfMsDS'>Function for prediction at new locations for spatial factor multi-species hierarchical distance sampling models</h2><span id='topic+predict.sfMsDS'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'sfMsDS'. Prediction is possible for both the latent abundance state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsDS'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, ignore.RE = FALSE, 
        type = 'abundance', include.sp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sfMsDS_+3A_object">object</code></td>
<td>
<p>an object of class sfMsDS</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>sfMsDS</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>sfMsDS</code>. Column names must match the names of the variables used to fit the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict expected abundance and latent abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_include.sp">include.sp</code></td>
<td>
<p>a logical value used to indicate whether spatial random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.sfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.sfMsDS</code>. When <code>type = 'abundance'</code>, the list consists of:  
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
expected abundance values, or expected abundance values per unit area (i.e., density)
values when an offset was used when fitting the model with <code>sfMsDS()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
spatial latent factors.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>sigma.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for
sigma (the parameter controlling detection probability).</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(210)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Number of species
n.sp &lt;- 5
# Community-level abundance coefficients
beta.mean &lt;- c(-1, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 0.3, 0.5, 0.4)
# Detection coefficients
alpha.mean &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha.mean)
tau.sq.alpha &lt;- c(0.1, 0.2)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- TRUE 
family &lt;- 'Poisson'
kappa &lt;- runif(n.sp, 0.3, 3) 
offset &lt;- pi * .8^2
transect &lt;- 'line'
factor.model &lt;- TRUE
n.factors &lt;- 3
phi &lt;- runif(n.factors, 3 / 1, 3 / .2)
cov.model &lt;- 'exponential'

dat &lt;- simMsDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
               n.sp = n.sp, beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
               mu.RE = mu.RE, p.RE = p.RE, sp = sp, cov.model = cov.model,
               sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
               offset = offset, transect = transect, factor.model = factor.model, 
               n.factors = n.factors)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , drop = FALSE]
X.p.0 &lt;- dat$X.p[pred.indx, , drop = FALSE]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
dist.breaks &lt;- dat$dist.breaks


covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  coords = coords,
                  offset = offset)

# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 10),
                   alpha.comm.normal = list(mean = 0, var = 10), 
                   kappa.unif = list(0, 100), 
                   phi.unif = list(3 / 1, 3 / .1),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1)) 
# Starting values
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, kappa = 1, phi = 3 / .5)

tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.8, lambda = 1, w = 1, phi = 0.8) 

n.batch &lt;- 4 
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- sfMsDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
              det.formula = ~ det.cov.1,
              data = data.list, 
              n.batch = n.batch, 
              batch.length = batch.length, 
              inits = inits.list, 
              family = 'Poisson',
              det.func = 'halfnormal', 
              transect = transect, 
              tuning = tuning,
              cov.model = 'exponential', 
              NNGP = TRUE,
              n.neighbors = 5,
              n.factors = n.factors,
              priors = prior.list, 
              accept.rate = 0.43, 
              n.omp.threads = 1, 
              verbose = TRUE, 
              n.report = 10,
              n.burn = n.burn,
              n.thin = n.thin,
              n.chains = n.chains) 
summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3')
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.sfMsNMix'>Function for prediction at new locations for spatial factor multi-species N-mixture models</h2><span id='topic+predict.sfMsNMix'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'sfMsNMix'. Prediction is possible for both the latent abundance state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsNMix'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, 
        ignore.RE = FALSE, type = 'abundance', 
        include.sp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sfMsNMix_+3A_object">object</code></td>
<td>
<p>an object of class sfMsNMix</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>sfMsNMix</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>sfMsNMix</code>. Column names must match the names of the variables used to fit the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict expected abundance and latent abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_include.sp">include.sp</code></td>
<td>
<p>a logical value used to indicate whether spatial random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords.0</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.sfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.sfMsNMix</code>. When <code>type = 'abundance'</code>, the list consists of:  
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
expected abundance values. Note these will be per unit area if an offset was used when 
fitting the model with <code>sfMsNMix()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
spatial latent factors.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
# Abundance
beta.mean &lt;- c(0.2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
family &lt;- 'Poisson'
n.factors &lt;- 3
phi &lt;- runif(n.factors, 3 / 1, 3 / .1)

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, 
                 beta = beta, alpha = alpha, sp = TRUE, 
                 family = 'Poisson', factor.model = TRUE, 
                 n.factors = n.factors, phi = phi, cov.model = 'exponential')
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
mu.0 &lt;- dat$psi[, pred.indx]
coords.0 &lt;- dat$coords[pred.indx, ]
# Package all data into a list
abund.covs &lt;- X[, 2, drop = FALSE]
colnames(abund.covs) &lt;- c('abund.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  abund.covs = abund.covs,
                  det.covs = det.covs, 
                  coords = coords)

# Initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1), 
                   phi.unif = list(a = 3 / 1, 3 / .1))
# Initial values
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   phi = 3 / .5,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   N = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning values
tuning &lt;- list(beta = 0.3, alpha = 0.3, lambda = 0.5, w = 0.5, phi = 1.5)
n.batch &lt;- 4
batch.length &lt;- 25
accept.rate &lt;- 0.43

out &lt;- sfMsNMix(abund.formula = ~ abund.cov, 
                det.formula = ~ det.cov.1 + det.cov.2, 
                data = data.list, 
                inits = inits.list, 
                family = 'Poisson', 
                n.factors = n.factors,
                n.batch = n.batch,
                batch.length = batch.length, 
                accept.rate = 0.43,
                cov.model = 'exponential', 
                n.neighbors = 5,
                tuning = tuning,
                priors = prior.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                n.report = 1)

summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.spAbund'>Function for prediction at new locations for univariate spatial GLMMs</h2><span id='topic+predict.spAbund'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'spAbund'.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spAbund'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, 
        ignore.RE = FALSE, z.0.samples, include.sp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spAbund_+3A_object">object</code></td>
<td>
<p>an object of class spAbund</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, replicate, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the spAbundance portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>spAbund</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>spAbund</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>spAbund</code>. See example below. If there is only one replicate per location, the design matrix can be a two-dimensional matrix instead of a three-dimensional array.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. 
Note that <code>spAbundance</code> assumes coordinates are specified in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove unstructured random effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_z.0.samples">z.0.samples</code></td>
<td>
<p>a matrix with rows corresponding to MCMC samples and columns corresponding to prediction locations containing the full posterior samples of the predicted binary portion of a zero-inflated Gaussian model. In the context of abundance models, this typically corresponds to estimates of the presence or absence of the species at the location. When using <code>spOccupancy</code> to generate the first stage samples of the zero-inflated Gaussian model, this is the object contained in the <code>z.0.samples</code> object of the predition function for the spOccupancy object. Ignored for all model types other than zero-inflated Gaussian.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_include.sp">include.sp</code></td>
<td>
<p>a logical value used to indicate whether spatial random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords.0</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.spAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.spAbund</code>. The list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
expected spAbundance values with dimensions corresponding to posterior predictive
sample, site, and replicate. Note if an offset was used when fitting the model 
with <code>spAbund</code>, the abundance values are reported per unit of the offset.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
spAbundance values with dimensions corresponding to posterior predictive sample, site, 
and replicate. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent spatial random effects.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1010)
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
n.rep &lt;- sample(1, J, replace = TRUE)
beta &lt;- c(0, -1.5, 0.3, -0.8)
p.spAbund &lt;- length(beta)
mu.RE &lt;- list()
kappa &lt;- 0.5
sp &lt;- TRUE 
sigma.sq &lt;- 0.5
phi &lt;- 3 / .5
family &lt;- 'NB'
cov.model = 'exponential'
dat &lt;- simAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, 
                kappa = kappa, mu.RE = mu.RE, sp = sp, family = 'NB', 
                sigma.sq = sigma.sq, phi = phi, cov.model = cov.model)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , ]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])

abund.covs &lt;- list(int = X[, , 1], 
                   abund.cov.1 = X[, , 2], 
                   abund.cov.2 = X[, , 3], 
                   abund.cov.3 = X[, , 4])

data.list &lt;- list(y = y, covs = abund.covs, coords = coords)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 100),
                   kappa.unif = c(0.001, 10)) 
# Starting values
inits.list &lt;- list(beta = 0, kappa = kappa)

n.batch &lt;- 5
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- spAbund(formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
               data = data.list, 
               n.batch = n.batch, 
               batch.length = batch.length, 
               inits = inits.list, 
               priors = prior.list, 
               accept.rate = 0.43, 
               n.neighbors = 5,
               cov.model = cov.model,
               n.omp.threads = 1, 
               verbose = TRUE, 
               n.report = 1,
               n.burn = n.burn,
               n.thin = n.thin,
               n.chains = n.chains) 

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov', 'abund.cov.2', 'abund.cov.3')
out.pred &lt;- predict(out, X.0, coords.0)
mu.0.quants &lt;- apply(out.pred$mu.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(dat$mu[pred.indx], mu.0.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(mu.0.quants), max(mu.0.quants)))
segments(dat$mu[pred.indx], mu.0.quants[1, ], dat$mu[pred.indx], mu.0.quants[3, ])
lines(dat$mu[pred.indx], dat$mu[pred.indx])
</code></pre>

<hr>
<h2 id='predict.spDS'>Function for prediction at new locations for single-species spatially-explicit hierarchical distance sampling models</h2><span id='topic+predict.spDS'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'spDS'. Prediction is possible for both the latent abundance state as well as detection. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spDS'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, ignore.RE = FALSE, 
        type = 'abundance', include.sp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spDS_+3A_object">object</code></td>
<td>
<p>an object of class spDS</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>spDS</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>spDS</code>. Column names of all variables must match the names of variables used when fitting the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random abundance (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict latent abundance and expected abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_include.sp">include.sp</code></td>
<td>
<p>a logical value used to indicate whether spatial random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.spDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.spDS</code>. When <code>type = 'abundance'</code>, the list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
expected abundance values, or expected abundance per unit area (i.e., density) values
when an offset was used when fitting the model with <code>spDS()</code>.</p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code></p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent spatial random effects.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>sigma.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for sigma 
(the parameter controlling detection probability).</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Abundance coefficients
beta &lt;- c(1.0, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta)
# Detection coefficients
alpha &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
sp &lt;- TRUE
phi &lt;- 3 / .5
sigma.sq &lt;- 0.8
cov.model &lt;- 'exponential'
family &lt;- 'NB'
kappa &lt;- 0.1
offset &lt;- 1.8
transect &lt;- 'point'

dat &lt;- simDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
             beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
             mu.RE = mu.RE, p.RE = p.RE, sp = sp, family = family, 
             offset = offset, transect = transect, phi = phi, sigma.sq = sigma.sq,
             cov.model = cov.model)
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, ]
dist.breaks &lt;- dat$dist.breaks
coords &lt;- dat$coords[-pred.indx, ]
coords.0 &lt;- dat$coords[pred.indx, ]

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  coords = coords,
                  offset = offset)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 10),
                   alpha.normal = list(mean = 0,
                                       var = 10), 
                   kappa.unif = c(0, 100), 
                   phi.unif = c(3 / 1, 3 / .1),
                   sigma.sq.ig = c(2, 1)) 
# Starting values
inits.list &lt;- list(alpha = 0,
                   beta = 0,
                   kappa = 1, 
                   phi = 3 / .5, 
                   sigma.sq = 1)
# Tuning values
tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.2, phi = 1, w = 1) 

out &lt;- spDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
            det.formula = ~ det.cov.1,
            data = data.list, 
            n.batch = 10, 
            batch.length = 25, 
            inits = inits.list, 
            family = 'NB',
            det.func = 'halfnormal', 
            transect = 'point', 
            cov.model = 'exponential', 
            NNGP = TRUE,
            n.neighbors = 5,
            tuning = tuning,
            priors = prior.list, 
            accept.rate = 0.43, 
            n.omp.threads = 1, 
            verbose = TRUE, 
            n.report = 100,
            n.burn = 100,
            n.thin = 1,
            n.chains = 1) 
summary(out)

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3')
out.pred &lt;- predict(out, X.0, coords.0)
mu.0.quants &lt;- apply(out.pred$mu.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(dat$mu[pred.indx], mu.0.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(mu.0.quants), max(mu.0.quants)))
segments(dat$mu[pred.indx], mu.0.quants[1, ], dat$mu[pred.indx], mu.0.quants[3, ])
lines(dat$mu[pred.indx], dat$mu[pred.indx])
</code></pre>

<hr>
<h2 id='predict.spNMix'>Function for prediction at new locations for single-species spatial N-mixture models</h2><span id='topic+predict.spNMix'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'spNMix'. Prediction is possible for both the latent abundance state as well as detection. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spNMix'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, ignore.RE = FALSE, 
        type = 'abundance', include.sp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spNMix_+3A_object">object</code></td>
<td>
<p>an object of class spNMix</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the abundance (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>spNMix</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>spNMix</code>. Column names of all variables must match the names of variables used when fitting the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random abundance (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'abundance' to predict latent abundance and expected abundance values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_include.sp">include.sp</code></td>
<td>
<p>a logical value used to indicate whether spatial random effects should be included in the predictions. By default, this is set to <code>TRUE</code>. If set to <code>FALSE</code>, predictions are given using the covariates and any unstructured random effects in the model. If <code>FALSE</code>, the <code>coords</code> argument is not required.</p>
</td></tr>
<tr><td><code id="predict.spNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.spNMix</code>. When <code>type = 'abundance'</code>, the list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
expected abundance values. Note these will be per unit area if an offset
was used when fitting the model with <code>NMix()</code></p>
</td></tr>
<tr><td><code>N.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent abundance values. These will be in the same units as <code>mu.0.samples</code>.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent spatial random effects.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(200)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0.5, 1.5)
p.abund &lt;- length(beta)
alpha &lt;- c(0.5, 1.2, -0.5)
p.det &lt;- length(alpha)
mu.RE &lt;- list()
p.RE &lt;- list()
phi &lt;- runif(1, 3 / 1, 3 / .1)
sigma.sq &lt;- runif(1, 0.2, 1.5)
kappa &lt;- 0.5
sp &lt;- TRUE
cov.model &lt;- 'exponential'
dat &lt;- simNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
               kappa = kappa, mu.RE = mu.RE, p.RE = p.RE, sp = sp,
               phi = phi, sigma.sq = sigma.sq, cov.model = cov.model,
               family = 'NB')

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .5), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Abundance covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
mu.0 &lt;- dat$mu[pred.indx]
w.0 &lt;- dat$w[pred.indx]

abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')

det.covs &lt;- list(det.cov.1 = X.p[, , 2], det.cov.2 = X.p[, , 3])

data.list &lt;- list(y = y,
                  abund.covs = abund.covs,
                  det.covs = det.covs,
                  coords = coords)

# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.abund),
                                      var = rep(100, p.abund)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)),
                   kappa.unif = c(0, 10))
# Starting values
inits.list &lt;- list(alpha = alpha,
                   beta = beta,
                   kappa = kappa,
                   phi = 3 / 0.5,
                   sigma.sq = 1,
                   N = apply(y, 1, max, na.rm = TRUE))
# Tuning values
tuning.list &lt;- list(phi = 0.5, kappa = 0.5, beta = 0.1, alpha = 0.1, w = 0.1)


n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- spNMix(abund.formula = ~ abund.cov.1,
              det.formula = ~ det.cov.1 + det.cov.2,
              data = data.list,
              n.batch = n.batch,
              batch.length = batch.length,
              inits = inits.list,
              priors = prior.list,
              NNGP = TRUE,
              cov.model = 'spherical',
              n.neighbors = 10,
              accept.rate = 0.43,
              n.omp.threads = 1,
              verbose = TRUE,
              n.report = 1,
              n.burn = n.burn,
              n.thin = n.thin,
              n.chains = n.chains)
summary(out)

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'abund.cov')
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.svcAbund'>Function for prediction at new locations for univariate Gaussian spatially-varying coefficient models</h2><span id='topic+predict.svcAbund'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'svcAbund'. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcAbund'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, ignore.RE = FALSE, 
        z.0.samples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcAbund_+3A_object">object</code></td>
<td>
<p>an object of class svcAbund</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>svcAbund</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>svcAbund</code>. Column names of all variables must match the names of variables used when fitting the model (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove unstructured random effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_z.0.samples">z.0.samples</code></td>
<td>
<p>a matrix with rows corresponding to MCMC samples and columns corresponding to prediction locations containing the full posterior samples of the predicted binary portion of a zero-inflated Gaussian model. In the context of abundance models, this typically corresponds to estimates of the presence or absence of the species at the location. When using <code>spOccupancy</code> to generate the first stage samples of the zero-inflated Gaussian model, this is the object contained in the <code>z.0.samples</code> object of the predition function for th spOccupancy object. Ignored for all model types other than zero-inflated Gaussian.</p>
</td></tr>
<tr><td><code id="predict.svcAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.svcAbund</code>. When <code>type = 'abundance'</code>, the list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
expected abundance values.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
abundance values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the spatially-varying coefficients, with dimensions corresponding to MCMC iteration, 
coefficient, and site.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 10 
J.y &lt;- 10
J &lt;- J.x * J.y
# Occurrence --------------------------
beta &lt;- c(10, 0.5, -0.2, 0.75)
p &lt;- length(beta)
mu.RE &lt;- list()
# Spatial parameters ------------------
sp &lt;- TRUE
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.4, 4)
phi &lt;- runif(p.svc, 3/1, 3/0.7)
tau.sq &lt;- 2

# Get all the data
dat &lt;- simAbund(J.x = J.x, J.y = J.y, beta = beta, tau.sq = tau.sq,
                mu.RE = mu.RE, sp = sp, svc.cols = svc.cols, family = 'Gaussian',
                cov.model = cov.model, sigma.sq = sigma.sq, phi = phi)

# Prep the data for spAbundance -------------------------------------------
y &lt;- dat$y
X &lt;- dat$X
coords &lt;- dat$coords

# Subset data for prediction if desired
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y.0 &lt;- y[pred.indx, drop = FALSE]
X.0 &lt;- X[pred.indx, , drop = FALSE]
coords.0 &lt;- coords[pred.indx, ]
y &lt;- y[-pred.indx, drop = FALSE]
X &lt;- X[-pred.indx, , drop = FALSE]
coords &lt;- coords[-pred.indx, ]

# Package all data into a list
covs &lt;- cbind(X)
colnames(covs) &lt;- c('int', 'cov.1', 'cov.2', 'cov.3')

# Data list bundle
data.list &lt;- list(y = y, covs = covs, coords = coords)
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 1000),
                   sigma.sq.ig = list(a = 2, b = 1), tau.sq = c(2, 1),
                   sigma.sq.mu.ig = list(a = 2, b = 1),
                   phi.unif = list(a = 3 / 1, b = 3 / 0.1))

# Starting values
inits.list &lt;- list(beta = 0, alpha = 0,
                   sigma.sq = 1, phi = phi, tau.sq = 2, sigma.sq.mu = 0.5)
# Tuning
tuning.list &lt;- list(phi = 1)

n.batch &lt;- 10
batch.length &lt;- 25
n.burn &lt;- 100
n.thin &lt;- 1
n.chains &lt;- 3

out &lt;- svcAbund(formula = ~ cov.1 + cov.2 + cov.3,
                svc.cols = svc.cols,
                data = data.list,
                n.batch = n.batch,
                batch.length = batch.length,
                inits = inits.list,
                priors = prior.list,
                accept.rate = 0.43,
                family = 'Gaussian',
                cov.model = "exponential",
                tuning = tuning.list,
                n.omp.threads = 1,
                verbose = TRUE,
                NNGP = TRUE,
                n.neighbors = 5,
                n.report = 25,
                n.burn = n.burn,
                n.thin = n.thin,
                n.chains = n.chains)

# Predict at new values ---------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0)

mu.0.means &lt;- apply(out.pred$mu.0.samples, 2, mean)
mu.0 &lt;- dat$mu[pred.indx]
plot(mu.0, mu.0.means, pch = 19)
abline(0, 1)
</code></pre>

<hr>
<h2 id='predict.svcMsAbund'>Function for prediction at new locations for multivariate spatially-varying coefficient GLMMs</h2><span id='topic+predict.svcMsAbund'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'svcMsAbund'.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcMsAbund'
predict(object, X.0, coords.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, ignore.RE = FALSE, 
        z.0.samples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcMsAbund_+3A_object">object</code></td>
<td>
<p>an object of class svcMsAbund</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This can be either a two-dimensional matrix with rows corresponding to sites and columns corresponding to covariates, or can be a three-dimensional array, with dimensions corresponding to site, replicate, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>svcMsAbund</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>svcMsAbund</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>svcMsAbund</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. 
Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove unstructured random effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_z.0.samples">z.0.samples</code></td>
<td>
<p>a three-dimensional array with dimensions corresponding to MCMC samples, species, and prediction locations. The array contains the full posterior samples of the predicted binary portion of a zero-inflated Gaussian model. In the context of abundance models, this typically corresponds to estimates of the presence or absence of each species at the location. When using <code>spOccupancy</code> to generate the first stage samples of the zero-inflated Gaussian model, this is the object contained in the <code>z.0.samples</code> object of the predition function for the spOccupancy object. Ignored for all model types other than zero-inflated Gaussian.</p>
</td></tr>
<tr><td><code id="predict.svcMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.svcMsAbund</code>. The list consists of: 
</p>
<table>
<tr><td><code>mu.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
expected abundance values with dimensions corresponding to posterior predictive
sample, species, site, and replicate.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a three or four-dimensional object of posterior predictive samples for the
abundance values with dimensions corresponding to posterior predictive sample, species, site, 
and replicate.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a four-dimensional array of posterior predictive samples for the
spatial factors for each spatially-varying coefficient. Dimensions correspond to MCMC sample, 
spatial factor, site, and spatially varying coefficient.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random effect corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- rep(1, J)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
mu.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- TRUE 
factor.model &lt;- TRUE
n.factors &lt;- 2
svc.cols &lt;- c(1, 2)
cov.model &lt;- 'spherical'
tau.sq &lt;- runif(n.sp, 0.1, 2)
phi &lt;- runif(n.factors * length(svc.cols), 3 / 1, 3 / .1)

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta,
                  mu.RE = mu.RE, sp = sp, family = 'Gaussian', tau.sq = tau.sq,
                  factor.model = factor.model, n.factors = n.factors, 
                  phi = phi, cov.model = cov.model, svc.cols = svc.cols)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , drop = FALSE]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
# Prediction values
y.0 &lt;- dat$y[, pred.indx, drop = FALSE]
X.0 &lt;- dat$X[pred.indx, , drop = FALSE]
coords.0 &lt;- dat$coords[pred.indx, ]

# Package all data into a list
covs &lt;- data.frame(abund.cov.1 = X[, 2])
data.list &lt;- list(y = y, covs = covs, coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   tau.sq.ig = list(a = .01, b = .01),
                   phi.unif = list(a = 3 / 1, b = 3 / .1),
                   tau.sq.beta.ig = list(a = .1, b = .1))
inits.list &lt;- list(beta.comm = 0,
                   beta = 0,
                   kappa = 0.5,
                   tau.sq = 1, 
                   phi = 3 / .5,
                   tau.sq.beta = 1)
tuning.list &lt;- list(kappa = 0.3, beta = 0.1, lambda = 0.5, w = 0.5, 
                    phi = 1)

# Small
n.batch &lt;- 2
batch.length &lt;- 25
n.burn &lt;- 20
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- svcMsAbund(formula = ~ abund.cov.1,
                  data = data.list,
                  n.batch = n.batch,
                  inits = inits.list,
                  priors = prior.list,
                  tuning = tuning.list,
                  batch.length = batch.length,
                  n.omp.threads = 1,
                  svc.cols = c(1, 2),
                  n.factors = n.factors,
                  cov.model = 'exponential',
                  family = 'Gaussian',
                  verbose = TRUE,
                  n.neighbors = 5, 
                  n.report = 1,
                  n.burn = n.burn,
                  n.thin = n.thin,
                  n.chains = n.chains)

# Predict at new locations
out.pred &lt;- predict(out, X.0, coords.0)
str(out.pred)
</code></pre>

<hr>
<h2 id='sfMsAbund'>Function for Fitting Spatial Factor Multivariate Abundance GLMMs</h2><span id='topic+sfMsAbund'></span>

<h3>Description</h3>

<p>The function <code>sfMsAbund</code> fits multivariate spatial abundance GLMMs with species correlations (i.e., a spatially-explicit abundace-based joint species distribution model). We use  a spatial factor modeling approach. Currently, models are implemented using a Nearest Neighbor Gaussian Process. Future development may allow for running the models using full Gaussian Processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfMsAbund(formula, data, inits, priors,  
          tuning, cov.model = 'exponential', NNGP = TRUE, 
          n.neighbors = 15, search.type = 'cb', n.factors,
          n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
          n.omp.threads = 1, verbose = TRUE, n.report = 100, 
          n.burn = round(.10 * n.batch * batch.length), n.thin = 1, n.chains = 1,
          save.fitted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfMsAbund_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>z</code>, <code>coords</code>, and <code>offset</code>. 
<code>y</code> is a two or three-dimensional array of observed count data. The
first dimension of the array is equal to the 
number of species and the second dimension is equal to the number of sites. If
specified as a three-dimensional array, the third dimension corresponds to 
replicate observations at each site (e.g., sub-samples, repeated sampling 
over multiple seasons). <code>covs</code> is a list 
containing the variables used in the model. If a data frame, each row 
of <code>covs</code> is a site and each column is a variable. 
If a list, each list element is a different
covariate, which can be site-level or observation-level. Site-level covariates
are specified as a vector of length <code class="reqn">J</code>, while observation-level covariates
are specified as a matrix or data frame with the number of rows equal to <code class="reqn">J</code>
and number of columns equal to the maximum number of replicate observations at a 
given site. <code>coords</code> is a 
<code class="reqn">J \times 2</code> matrix of the observation coordinates. Note that 
<code>spAbundance</code> assumes coordinates are specified in a projected coordinate system. 
For zero-inflated Gaussian models, the tag <code>z</code> is used to specify the 
binary component of the model and should have the same dimensions as <code>y</code>. 
<code>offset</code> is an offset to use in the abundance model (e.g., an area offset). 
This can be either a single value, a vector with an offset for each site (e.g., if survey 
area differed in size), or a site x replicate matrix if more than one count is available 
at a given site.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta.comm</code>, <code>beta</code>, 
<code>tau.sq.beta</code>, <code>sigma.sq.mu</code>, <code>kappa</code>,
<code>phi</code>, <code>lambda</code>, <code>nu</code>, and <code>tau.sq</code>. <code>nu</code> is only specified if 
<code>cov.model = "matern"</code>, <code>kappa</code> is only specified if <code>family = 'NB'</code>, 
<code>tau.sq</code> is only specified for Gaussian and zero-inflated Gaussian models,
and <code>sigma.sq.mu</code> is only specified if random effects are included in <code>formula</code>. 
The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>tau.sq.beta.ig</code>, <code>sigma.sq.mu</code>, 
<code>kappa.unif</code>, <code>phi.unif</code>, <code>nu.unif</code>, and <code>tau.sq.ig</code>. 
Community-level (<code>beta.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances to 100. Community-level variance parameters 
(<code>tau.sq.beta</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. The spatial factor model fits <code>n.factors</code> independent
spatial processes. The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors</code> corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factors. The priors for the factor loadings matrix <code>lambda</code> are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>n.sp x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).
<code>sigma.sq.mu</code> are the random 
effect variances random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters. <code>tau.sq</code> is the 
species-specific residual variance for Gaussian (or zero-inflated Gaussian) models, and it is assigned 
an inverse-Gamma prior. The hyperparameters of the inverse-Gamma are passed as a list 
of length two, with the first and second element corresponding to the shape and 
scale parameters, respectively, which are each specified as vectors of length
equal to the number of species or a single value if priors are the same for all species.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_tuning">tuning</code></td>
<td>
<p>a single numeric value representing the initial variance of the
adaptive sampler for <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>kappa</code>, <code>phi</code>, <code>lambda</code>. 
See Roberts and Rosenthal (2009) for details. Note that only <code>phi</code> and <code>nu</code>
are tuned for Gaussian or zero-inflated Gaussian models.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. For spatial factor models, only 
<code>NNGP = TRUE</code> is currently supported.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor model approach. 
Typically, the number of factors is set to be small (e.g., 4-5) relative to the 
total number of species in the community, which will lead to substantial 
decreases in computation time. However, the value can be anywhere 
between 1 and the number of species in the modeled community.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for the abundance. Currently 
supports <code>'NB'</code> (negative binomial), <code>'Poisson'</code> (Poisson), <code>'Gaussian'</code> (Gaussian), 
and <code>'zi-Gaussian'</code> (zero-inflated Gaussian).</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_save.fitted">save.fitted</code></td>
<td>
<p>logical value indicating whether or not fitted values and likelihood values
should be saved in the resulting model object. If <code>save.fitted = FALSE</code>, the components
<code>y.rep.samples</code>, <code>mu.samples</code>, and <code>like.samples</code> will not be included
in the model object, and subsequent functions for calculating WAIC, fitted values, and
posterior predictive checks will not work, although they all can be calculated manually if
desired. Setting <code>save.fitted = FALSE</code> can be useful when working with very large 
data sets to minimize the amount of RAM needed when fitting and storing the model object in 
memory.</p>
</td></tr>
<tr><td><code id="sfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sfMsAbund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the Gaussian residual variance parameter. Only included when
<code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the spatial correlation parameters.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent spatial factor loadings.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the fitted (replicate) values for each species with dimensions corresponding
to MCMC sample, species, site, and replicate.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the expected abundance values for each species with dimensions
corresponding to MCMC samples, species, site, and replicate.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each latent factor. Array dimensions correspond
to MCMC sample, latent factor, then site.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
# Random effects (two random intercepts)
mu.RE &lt;- list(levels = c(10, 15),
              sigma.sq.mu = c(0.43, 0.5))
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- TRUE
n.factors &lt;- 2
factor.model &lt;- TRUE
phi &lt;- runif(n.factors, 3/1, 3 / .1)
kappa &lt;- runif(n.sp, 0.1, 1)

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta,
                  mu.RE = mu.RE, sp = sp, kappa = kappa, family = 'NB',
                  factor.model = factor.model, phi = phi,
                  cov.model = 'exponential', n.factors = n.factors)

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
coords &lt;- dat$coords

# Package all data into a list
covs &lt;- list(int = X[, , 1],
             abund.cov.1 = X[, , 2],
             abund.factor.1 = X.re[, , 1],
             abund.factor.2 = X.re[, , 2])
data.list &lt;- list(y = y, covs = covs, coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   kappa.unif = list(a = 0, b = 10),
                   phi.unif = list(a = 3 / 1, b = 3 / .1),
                   tau.sq.beta.ig = list(a = .1, b = .1))
inits.list &lt;- list(beta.comm = 0, beta = 0, kappa = 0.5,
                   tau.sq.beta = 1, phi = 3 / 0.5)

# Small
n.batch &lt;- 2
batch.length &lt;- 25
n.burn &lt;- 20
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- sfMsAbund(formula = ~ abund.cov.1 + (1 | abund.factor.1) + 
                             (1 | abund.factor.2),
                 data = data.list,
                 n.batch = n.batch,
                 inits = inits.list,
                 priors = prior.list,
                 NNGP = TRUE,
                 cov.model = 'exponential',
                 n.neighbors = 5,
                 n.factors = n.factors,
                 batch.length = batch.length,
                 n.omp.threads = 3,
                 verbose = TRUE,
                 n.report = 1,
                 n.burn = n.burn,
                 n.thin = n.thin,
                 n.chains = n.chains)
summary(out)

</code></pre>

<hr>
<h2 id='sfMsDS'>Function for Fitting Spatial Factor Multi-Species Hierarchical Distance Sampling Models</h2><span id='topic+sfMsDS'></span>

<h3>Description</h3>

<p>Function for fitting spatial factor multi-species hierarchical distance sampling models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfMsDS(abund.formula, det.formula, data, inits, priors,  
       tuning, cov.model = 'exponential', NNGP = TRUE, 
       n.neighbors = 15, search.type = 'cb', n.factors, 
       n.batch, batch.length, accept.rate = 0.43, 
       family = 'Poisson', transect = 'line', det.func = 'halfnormal', 
       n.omp.threads = 1, verbose = TRUE, n.report = 100, 
       n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
       n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfMsDS_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>coords</code>, 
<code>dist.breaks</code>, and <code>offset</code>. <code>y</code>
is a three-dimensional array of observed count data with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>covs</code> is a matrix or data frame containing the variables 
used in the abundance and/or the detection portion of the model, with
<code class="reqn">J</code> rows for each column (variable). <code>dist.breaks</code> is a vector of 
distances that denote the breakpoints of the distance bands. <code>dist.breaks</code> should
have length equal to the third dimension of <code>y</code> plus one. <code>offset</code> is an 
offset that can be used to scale estimates from abundance per transect to density per 
some desired unit of measure. This can be either a single value or a vector with an offset
value for each site (e.g., if transects differ in length). <code>coords</code> is a matrix
or data frame with two columns that contain the spatial coordinates of each site. 
Note that <code>spAbundance</code> assumes coordinates are specified in a projected
coordinate system.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.mu</code>, 
<code>sigma.sq.p</code>, <code>phi</code>, <code>nu</code>, <code>lambda</code>, <code>w</code>, 
<code>kappa</code>, and <code>N</code>. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are only relevant when including random effects in the 
abundance and detection portion of the model, respectively. <code>kappa</code> is
only relevant when <code>family = 'NB'</code>. <code>nu</code> is only relevant if 
<code>cov.model = "matern"</code>.
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.mu.ig</code>, 
<code>sigma.sq.p.ig</code>, <code>kappa.unif</code>, 
<code>phi.unif</code>, and <code>nu.unif</code>. Community-level abundance 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances are set to 100.
Community-level variance parameters for abundance (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random effects or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters. 
The spatial factor model fits <code>n.factors</code> independent
spatial processes. The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors</code> corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factors. The priors for the factor loadings matrix <code>lambda</code> are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>n.sp x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, 
whose value defines the initial variance of the adaptive sampler. 
Valid tags are <code>beta</code>, <code>alpha</code>, <code>lambda</code> (the latent factor loadings), 
<code>w</code> (the latent factors), <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations. Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP.  See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only NNGP is supported,
functionality for a Gaussian Process be addded in future package development.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the latent factor model approach.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the
total number of species in the community, which will lead to substantial
decreases in computation time. However, the value can be anywhere
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_transect">transect</code></td>
<td>
<p>the type of transect. Currently supports line transects (<code>'line'</code>) or
circular transects (i.e., point counts; <code>'point'</code>).</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_det.func">det.func</code></td>
<td>
<p>the detection model used to describe how detection probability varies
with distance. In other software, this is often referred to as the key function. Currently
supports two functions: half normal (<code>'halfnormal'</code>) and negative exponential
(<code>'negexp'</code>).</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="sfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sfMsDS</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the spatial correlation parameters for each spatial factor.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the spatial factor loadings.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each spatial factor. Array dimensions correspond
to MCMC sample, spatial factor, then site.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent abundance values for each species. Note that these values
always represent transect-level abundance, even when an offset is 
supplied. Array dimensions correspond to MCMC sample, species, then site.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent expected abundance values for each species. When an offset
is supplied in the <code>data</code> object, these correspond to expected
abundance per unit area (i.e., density). Array dimensions correspond to 
MCMC sample, species, then site.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a four-dimensional array of fitted values. 
Array dimensions correspond to MCMC samples, species, sites, and distance band.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>a four-dimensional array of cell-specific detection
probabilities. Array dimensions correspond to MCMC samples, species, 
sites, and distance band.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size
from spatially replicated counts. Biometrics, 60(1), 108-115.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Sollmann, R., Gardner, B., Williams, K. A., Gilbert, A. T., 
&amp; Veit, R. R. (2016). A hierarchical distance sampling model to 
estimate abundance and covariate associations of species 
and communities. Methods in Ecology and Evolution, 7(5), 529-537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(210)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Number of species
n.sp &lt;- 5
# Community-level abundance coefficients
beta.mean &lt;- c(-1, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 0.3, 0.5, 0.4)
# Detection coefficients
alpha.mean &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha.mean)
tau.sq.alpha &lt;- c(0.1, 0.2)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- TRUE 
family &lt;- 'Poisson'
kappa &lt;- runif(n.sp, 0.3, 3) 
offset &lt;- pi * .8^2
transect &lt;- 'line'
factor.model &lt;- TRUE
n.factors &lt;- 3
phi &lt;- runif(n.factors, 3 / 1, 3 / .2)
cov.model &lt;- 'exponential'

dat &lt;- simMsDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
               n.sp = n.sp, beta = beta, alpha = alpha, det.func = det.func, 
               mu.RE = mu.RE, p.RE = p.RE, sp = sp, cov.model = cov.model,
               sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
               offset = offset, transect = transect, factor.model = factor.model, 
               n.factors = n.factors)

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
coords &lt;- dat$coords
dist.breaks &lt;- dat$dist.breaks

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  coords = coords,
                  offset = offset)

# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 10),
                   alpha.comm.normal = list(mean = 0, var = 10), 
                   kappa.unif = list(0, 100), 
                   phi.unif = list(3 / 1, 3 / .1),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1)) 
# Starting values
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, kappa = 1, phi = 3 / .5)

tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.8, lambda = 1, w = 1, phi = 0.8) 

n.batch &lt;- 4 
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- sfMsDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
              det.formula = ~ det.cov.1,
              data = data.list, 
              n.batch = n.batch, 
              batch.length = batch.length, 
              inits = inits.list, 
              family = 'Poisson',
              det.func = 'halfnormal', 
              transect = transect, 
              tuning = tuning,
              cov.model = 'exponential', 
              NNGP = TRUE,
              n.neighbors = 5,
              n.factors = n.factors,
              priors = prior.list, 
              accept.rate = 0.43, 
              n.omp.threads = 1, 
              verbose = TRUE, 
              n.report = 10,
              n.burn = n.burn,
              n.thin = n.thin,
              n.chains = n.chains) 
summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='sfMsNMix'>Function for Fitting Spatial Factor Multi-species N-mixture Models</h2><span id='topic+sfMsNMix'></span>

<h3>Description</h3>

<p>Function for fitting spatial multi-species N-mixture models with species correlations (i.e., an abundance-based spatially-explicit joint species distribution model with imperfect detection). We use Nearest Neighbor Gaussian Processes and a spatial factor modeling approach to achieve dimension reducition. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfMsNMix(abund.formula, det.formula, data, inits, priors,  
         tuning, cov.model = 'exponential', NNGP = TRUE, n.neighbors = 15, 
         search.type = 'cb', n.factors, n.batch, batch.length, accept.rate = 0.43, 
         family = 'Poisson', n.omp.threads = 1, verbose = TRUE, n.report = 100, 
         n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
         n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfMsNMix_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>abund.covs</code>, <code>det.covs</code>, <code>coords</code>, and <code>offset</code>. <code>y</code>
is a three-dimensional array of observed count data with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>abund.covs</code> is a matrix or data frame containing the variables 
used in the abundance portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site. <code>coords</code> is a matrix
or data frame with two columns that contain the spatial coordinates of each 
site. Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system. <code>offset</code>
is an offset to use in the abundance model (e.g., an area offset). This can be either a single
value or a vector with an offset for each site (e.g., if survey area differed in size).</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.mu</code>, 
<code>sigma.sq.p</code>, <code>phi</code>, <code>nu</code>, <code>lambda</code>, <code>w</code>, 
<code>kappa</code>, and <code>N</code>. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are only relevant when including random effects in the 
abundance and detection portion of the model, respectively. <code>kappa</code> is
only relevant when <code>family = 'NB'</code>. <code>nu</code> is only relevant if 
<code>cov.model = "matern"</code>.
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.mu.ig</code>, 
<code>sigma.sq.p.ig</code>, <code>kappa.unif</code>, 
<code>phi.unif</code>, and <code>nu.unif</code>. Community-level abundance 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances for the abundance
coefficients are set to 100 and for the detection coefficients are set to 2.72. 
Community-level variance parameters for abundance (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random effects or of length one 
if priors are the same for all random effect variances. <code>kappa</code> is the 
negative binomial dispersion parameter for each species and is assumed to 
follow a uniform distribution. The hyperparameters of the uniform distribution
are passed as a list of length two with first and second elements corresponding to the
lower and upper bounds of the uniform distribution, respectively, which are each 
specified as vectors of length equal to the number of species or of length one
if priors are the same for all species-specific dispersion parameters. 
The spatial factor model fits <code>n.factors</code> independent
spatial processes. The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors</code> corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factors. The priors for the factor loadings matrix <code>lambda</code> are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>n.sp x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations. Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter name, 
whose value defines the initial variance of the adaptive sampler. 
Valid tags are <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values), 
<code>phi</code>, <code>nu</code>, <code>lambda</code> (the latent factor loadings), 
<code>w</code> (the latent factors), and 
<code>kappa</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP.  See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only NNGP is supported,
functionality for a Gaussian Process may be added in future package development.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor model approach.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the
total number of species in the community, which will lead to substantial
decreases in computation time. However, the value can be anywhere
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="sfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sfMsNMix</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the spatial factor loadings.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the spatial correlation parameters for each spatial factor.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each latent factor.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance dispersion parameters. Only included
when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent abundance values for each species.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent expected abundance values for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection probability
estimated values are not included in the model object, but can be extracted
using <code>fitted()</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size
from spatially replicated counts. Biometrics, 60(1), 108-115.
</p>
<p>Yamaura, Y., Royle, J. A., Shimada, N., Asanuma, S., Sato, T., 
Taki, H., &amp; Makino, S. I. (2012). Biodiversity of man-made open habitats 
in an underused country: a class of multispecies abundance models for 
count data. Biodiversity and Conservation, 21(6), 1365-1380.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(5, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
# Abundance 
beta.mean &lt;- c(0, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
# Detection
alpha.mean &lt;- c(0, 0.5, 0.8)
tau.sq.alpha &lt;- c(0.2, 1, 1.5)
p.det &lt;- length(alpha.mean)
# Random effects
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
n.factors &lt;- 3
phi &lt;- runif(n.factors, 3 / 1, 3 / .2)

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, alpha = alpha,
                 mu.RE = mu.RE, p.RE = p.RE, family = 'Poisson', 
                 factor.model = TRUE, n.factors = n.factors, sp = TRUE, phi = phi,
                 cov.model = 'exponential')

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
X.re &lt;- dat$X.re
X.p.re &lt;- dat$X.p.re
coords &lt;- dat$coords

# Package all data into a list
abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')
det.covs &lt;- list(det.cov.1 = as.data.frame(X.p[, , 2]),
                 det.cov.2 = as.data.frame(X.p[, , 3]))
data.list &lt;- list(y = y,
                  abund.covs = abund.covs,
                  det.covs = det.covs, 
                  coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = rep(0, p.abund), 
                                           var = rep(100, p.abund)),
                   alpha.comm.normal = list(mean = rep(0, p.det),
                                            var = rep(2.72, p.det)),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1), 
                   phi.unif = list(a = 3 / 1, 3 / .1))
inits.list &lt;- list(beta.comm = 0, alpha.comm = 0,
                   beta = 0, alpha = 0,
                   tau.sq.beta = 0.5, tau.sq.alpha = 0.5,
                   N = apply(y, c(1, 2), max, na.rm = TRUE))
tuning.list &lt;- list(beta = 0.5, alpha = 0.5, lambda = 0.5, w = 0.5, 
                    phi = 1)

n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 0 
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- sfMsNMix(abund.formula = ~ abund.cov.1,
                det.formula = ~ det.cov.1 + det.cov.2,
                data = data.list,
                n.batch = n.batch,
                inits = inits.list,
                priors = prior.list,
                tuning = tuning.list,
                batch.length = batch.length,
                n.omp.threads = 1,
                n.factors = n.factors,
                cov.model = 'exponential', 
                n.neighbors = 5,
                verbose = TRUE,
                n.report = 1,
                n.burn = n.burn,
                n.thin = n.thin,
                n.chains = n.chains)

summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='simAbund'>Simulate Univariate Data for Testing GLMMs</h2><span id='topic+simAbund'></span>

<h3>Description</h3>

<p>The function <code>simAbund</code> simulates univariate data without imperfect detection for simulation studies, power assessments, or function testing related to GLMMs. Data can be optionally simulated with a spatial Gaussian Process in the model. Non-spatial random effects can also be included in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simAbund(J.x, J.y, n.rep, n.rep.max, beta, kappa, tau.sq, mu.RE = list(), 
         offset = 1, sp = FALSE, svc.cols = 1, cov.model, sigma.sq, phi, nu, 
         family = 'Poisson', z, x.positive = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simAbund_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simAbund_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simAbund_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric vector of length <code class="reqn">J = J.x \times J.y</code> indicating the number of replicate surveys at each of the <code class="reqn">J</code> sites.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a single numeric value indicating the maximum number of replicate surveys. This is an optional argument, with its default value set to <code>max(n.rep)</code>. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simAbund_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the abundance model.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_kappa">kappa</code></td>
<td>
<p>a single numeric value containing the dispersion parameter for the abundance portion of the model. Only relevant when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_tau.sq">tau.sq</code></td>
<td>
<p>a single numeric value containing the residual variance parameter of the Gaussian distribution. Only relevant when <code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_mu.re">mu.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.mu</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.mu</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. A third optional tage is <code>beta.indx</code>, which is a numeric vector with length equal to the number of distinct random intercepts. The values in <code>beta.indx</code> denote the intercept/covariate for which you wish to simulate a random intercept/slope. Numeric values correspond to the intercept/covaraite in <code>beta</code>. If <code>mu.RE</code> is not specified, no random effects are included in the abundance portion of the model.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_offset">offset</code></td>
<td>
<p>either a single numeric value, a vector of length <code>J</code>, or a site by replicate matrix that contains the offset for each data point in the data set.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simAbund_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the abundance data.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial decay parameter. Ignored when <code>sp = FALSE</code>. </p>
</td></tr>
<tr><td><code id="simAbund_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>.</p>
</td></tr> 
<tr><td><code id="simAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for the data. Currently
supports <code>'NB'</code> (negative binomial), <code>'Poisson'</code>, <code>'Gaussian'</code>, and
<code>'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_z">z</code></td>
<td>
<p>a vector of length <code>J</code> containing the binary presence/absence portion of a zero-inflated Gaussian model. Only relevant when <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code id="simAbund_+3A_x.positive">x.positive</code></td>
<td>
<p>a logical value indicating whether the simulated covariates should be simulated as random standard normal covariates (<code>x.positive = FALSE</code>) or restricted to positive values using a uniform distribution with lower bound 0 and upper bound 1 (<code>x.positive = TRUE</code>).</p>
</td></tr>
<tr><td><code id="simAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a three-dimensional numeric design array of covariates with dimensions corresponding to sites, replicates, and number of covariates (including an intercept) for the model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a matrix of the spatial random effects. Only used to simulate data when <code>sp = TRUE</code>. If simulating data with spatially-varying coefficients, the number of columns equals the number of spatially-varying coefficients and each row corresponds to a site.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a <code>J x max(n.rep)</code> matrix of the expected abundance values for each site and replicate survey.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>J x max(n.rep)</code> matrix of the raw count data for each site and replicate combination.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric three-dimensional array containing the levels of any abundance random effect included in the model. Only relevant when abundance random effects are specified in <code>mu.RE</code>.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric vector that contains the simulated abundance random effects for each given level of the random effects included in the abundance model. Only relevant when abundance random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(401)
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0, -1.5, 0.3, -0.8)
p.abund &lt;- length(beta)
mu.RE &lt;- list(levels = c(30), sigma.sq.mu = c(1.3))
kappa &lt;- 0.5
sp &lt;- FALSE 
family &lt;- 'NB'
dat &lt;- simAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, 
                kappa = kappa, mu.RE = mu.RE, sp = sp, family = 'NB')
</code></pre>

<hr>
<h2 id='simDS'>Simulate Single-Species Distance Sampling Data</h2><span id='topic+simDS'></span>

<h3>Description</h3>

<p>The function <code>simDS</code> simulates single-species distance sampling data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the abundance portion of the model. Non-spatial random effects can also be included in the detection or abundance portions of the distance sampling model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simDS(J.x, J.y, n.bins, bin.width, beta, alpha, det.func, transect = 'line', 
      kappa, mu.RE = list(), p.RE = list(), offset = 1, 
      sp = FALSE, cov.model, sigma.sq, phi, nu, family = 'Poisson', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simDS_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simDS_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simDS_+3A_n.bins">n.bins</code></td>
<td>
<p>a single numeric value indicating the number of distance bins from which to generate data.</p>
</td></tr>
<tr><td><code id="simDS_+3A_bin.width">bin.width</code></td>
<td>
<p>a vector of length <code>n.bins</code> indicating the length of each bin. Lengths can be different for each distance bin or the same across bins.</p>
</td></tr>
<tr><td><code id="simDS_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the abundance portion of the single-species distance sampling model.</p>
</td></tr>
<tr><td><code id="simDS_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the detection portion of the single-species distance sampling model.</p>
</td></tr>
<tr><td><code id="simDS_+3A_det.func">det.func</code></td>
<td>
<p>the detection model used to describe how detection probability varies
with distance. In other software, this is often referred to as the key function. Currently
supports two functions: half normal (<code>'halfnormal'</code>) and negative exponential
(<code>'negexp'</code>).</p>
</td></tr>
<tr><td><code id="simDS_+3A_transect">transect</code></td>
<td>
<p>the type of transect. Currently supports line transects (<code>'line'</code>) or
circular transects (i.e., point counts; <code>'point'</code>).</p>
</td></tr>
<tr><td><code id="simDS_+3A_kappa">kappa</code></td>
<td>
<p>a single numeric value containing the dispersion parameter for the abundance portion of the hierarchical distance sampling model. Only relevant when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code id="simDS_+3A_mu.re">mu.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the abundance portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.mu</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.mu</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the abundance portion of the model.</p>
</td></tr>
<tr><td><code id="simDS_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model.</p>
</td></tr>
<tr><td><code id="simDS_+3A_offset">offset</code></td>
<td>
<p>either a single numeric value or a vector of length <code>J</code> that contains the offset for each location in the data set.</p>
</td></tr>
<tr><td><code id="simDS_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit HDS model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simDS_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent abundance values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simDS_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simDS_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial decay parameter. Ignored when <code>sp = FALSE</code>. </p>
</td></tr>
<tr><td><code id="simDS_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>.</p>
</td></tr> 
<tr><td><code id="simDS_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="simDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times p.abund</code> numeric design matrix for the abundance portion of the model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a <code class="reqn">J \times p.abund</code> numeric design matrix for the detection portion of the model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a <code class="reqn">J \times 1</code> matrix of the spatial random effects. Only used to simulate data when <code>sp = TRUE</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a <code class="reqn">J \times 1</code> matrix of the expected abundance values for each site.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>a length <code class="reqn">J</code> vector of the latent abundances at each site.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p> a length J vector of the detection probabilities at each site.</p>
</td></tr>
<tr><td><code>pi.full</code></td>
<td>
<p>a <code>J x n.bins + 1</code> vector of the cell-specific detection probabilities for each site, where the last column indicates the probability of not detecting an individual at that site.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>J x max(n.bins)</code> matrix of the raw count data for each site and distance bin.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a numeric matrix containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any abundance random effect included in the model. Only relevant when abundance random effects are specified in <code>mu.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric vector that contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric vector that contains the simulated abundance random effects for each given level of the random effects included in the HDS model. Only relevant when abundance random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(110)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Abundance coefficients
beta &lt;- c(1.0, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta)
# Detection coefficients
alpha &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
sp &lt;- FALSE 
family &lt;- 'NB'
kappa &lt;- 0.1
offset &lt;- 1.8
transect &lt;- 'point'

dat &lt;- simDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
             beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
             mu.RE = mu.RE, p.RE = p.RE, sp = sp,
             sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
             offset = offset, transect = transect)
</code></pre>

<hr>
<h2 id='simMsAbund'>Simulate Multivariate Data for Testing GLMMs</h2><span id='topic+simMsAbund'></span>

<h3>Description</h3>

<p>The function <code>simMsAbund</code> simulates multivariate data without imperfect detection for simulation studies, power assessments, or function testing related to GLMMs. Data can be optionally simulated with a spatial Gaussian Process in the model, as well as an option to allow for species correlations using a factor modeling approach. Non-spatial random effects can also be included in the abundance portions of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMsAbund(J.x, J.y, n.rep, n.rep.max, n.sp, beta, kappa, tau.sq, mu.RE = list(), 
           offset = 1, sp = FALSE, cov.model, svc.cols = 1,
           sigma.sq, phi, nu, family = 'Poisson',
           factor.model = FALSE, n.factors, z, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simMsAbund_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric vector of length <code class="reqn">J = J.x \times J.y</code> indicating the number of replicate surveys at each of the <code class="reqn">J</code> sites.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a single numeric value indicating the maximum number of replicate surveys. This is an optional argument, with its default value set to <code>max(n.rep)</code>. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_n.sp">n.sp</code></td>
<td>
<p>a single numeric value indicating the number of species to simulate count data.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_beta">beta</code></td>
<td>
<p>a numeric matrix with <code>n.sp</code> rows containing the intercept and regression coefficient parameters for the model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr> 
<tr><td><code id="simMsAbund_+3A_kappa">kappa</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the dispersion parameter for the model for each species. Only relevant when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_tau.sq">tau.sq</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the residual variance parameters for the model for each species. Only relevant for Gaussian or zero-inflated Gaussian models.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_mu.re">mu.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.mu</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.mu</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the model.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_offset">offset</code></td>
<td>
<p>either a single numeric value, a vector of length <code>J</code>, or a site by replicate matrix that contains the offset for each data point in the data set.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the abundance values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial variance parameter for each species. Ignored when <code>sp = FALSE</code> or when <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_phi">phi</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial decay parameter for each species. Ignored when <code>sp = FALSE</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial smoothness parameter for each species. Only used when <code>sp = TRUE</code> and <code>cov.model = 'matern'</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr> 
<tr><td><code id="simMsAbund_+3A_factor.model">factor.model</code></td>
<td>
<p>a logical value indicating whether to simulate data following a factor modeling approach that explicitly incoporates species correlations. If <code>sp = TRUE</code>, the latent factors are simulated from independent spatial processes. If <code>sp = FALSE</code>, the latent factors are simulated from standard normal distributions.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_n.factors">n.factors</code></td>
<td>
<p>a single numeric value specifying the number of latent factors to use to simulate the data if <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_z">z</code></td>
<td>
<p>a matrix with <code>n.sp</code> rows and <code>J</code> columns containing the binary presence/absence portion of a zero-inflated Gaussian model for each species. Only relevant when <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code id="simMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a three-dimensional numeric design array of covariates with dimensions corresponding to sites, replicates, and number of covariates (including an intercept) for the model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a list of <code class="reqn">N \times J</code> matrices of the spatially-varying coefficients for each species. Each element of the list corresponds to a different spatially-varying coefficient. Only used to simulate data when <code>sp = TRUE</code>. If <code>factor.model = TRUE</code>, the first dimension of each matrix is <code>n.factors</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a <code>n.sp x J</code> matrix of the mean abundances for each species at each site.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>n.sp x J x max(n.rep)</code> array of the raw count data for each species at each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any abundance random effect included in the model. Only relevant when abundance random effects are specified in <code>mu.RE</code>.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated abundance random effects for each given level of the random effects included in the abundance model. Only relevant when abundance random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(408)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, size = J, replace = TRUE)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(-2, 0.5)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2)
# Random effects (two random intercepts)
mu.RE &lt;- list(levels = c(10, 15),
              sigma.sq.mu = c(0.43, 0.5))
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- TRUE
n.factors &lt;- 2
factor.model &lt;- TRUE
phi &lt;- runif(n.factors, 3/1, 3 / .1)
kappa &lt;- runif(n.sp, 0.1, 1)

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta,
                  mu.RE = mu.RE, sp = sp, kappa = kappa, family = 'NB',
                  factor.model = factor.model, phi = phi,
                  cov.model = 'spherical', n.factors = n.factors)
</code></pre>

<hr>
<h2 id='simMsDS'>Simulate Multi-Species Distance Sampling Data</h2><span id='topic+simMsDS'></span>

<h3>Description</h3>

<p>The function <code>simMsDS</code> simulates multi-species distance sampling data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the abundance portion of the model, as well as an option to allow for species correlations using a factor modeling approach. Non-spatial random effects can also be included in the detection or abundance portions of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMsDS(J.x, J.y, n.bins, bin.width, n.sp, beta, alpha, 
        det.func, transect = 'line', kappa, mu.RE = list(), 
        p.RE = list(), offset = 1, sp = FALSE, cov.model, 
        sigma.sq, phi, nu, family = 'Poisson',
        factor.model = FALSE, n.factors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simMsDS_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsDS_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsDS_+3A_n.bins">n.bins</code></td>
<td>
<p>a single numeric value indicating the number of distance bins from which to generate data.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_bin.width">bin.width</code></td>
<td>
<p>a vector of length <code>n.bins</code> indicating the length of each bin. Lengths can be different for each distance bin or the same across bins.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_n.sp">n.sp</code></td>
<td>
<p>a single numeric value indicating the number of species to simulate count data.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_beta">beta</code></td>
<td>
<p>a numeric matrix with <code>n.sp</code> rows containing the intercept and regression coefficient parameters for the abundance portion of the multi-species hierarchical distance sampling (HDS) model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr> 
<tr><td><code id="simMsDS_+3A_alpha">alpha</code></td>
<td>
<p>a numeric matrix with <code>n.sp</code> rows containing the intercept and regression coefficient parameters for the detection portion of the multi-species HDS model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_det.func">det.func</code></td>
<td>
<p>the detection model used to describe how detection probability varies
with distance. In other software, this is often referred to as the key function. Currently
supports two functions: half normal (<code>'halfnormal'</code>) and negative exponential
(<code>'negexp'</code>).</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_transect">transect</code></td>
<td>
<p>the type of transect. Currently supports line transects (<code>'line'</code>) or
circular transects (i.e., point counts; <code>'point'</code>).</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_kappa">kappa</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the dispersion parameter for the abundance portion of the HDS model for each species. Only relevant when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_mu.re">mu.RE</code></td>
<td>
<p>a list used to specify the non-spatial random effects included in the abundance portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.mu</code>. <code>levels</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the number of levels there are in each effect. <code>sigma.sq.mu</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the abundance portion of the model. An optional third tag, <code>beta.indx</code>, is a list that contains integers denoting the corresponding value of <code>beta</code> that each random effect corresponds to. This allows specification of random intercepts as well as slopes. By default, all effects are assumed to be random intercepts.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the non-spatial random effects included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the number of levels there are in each effects. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model. An optional third tag, <code>alpha.indx</code>, is a list that contains integers denoting the corresponding value of <code>alpha</code> that each random effect corresponds to. This allows specification of random intercepts as well as slopes. By default, all effects are assumed to be random intercepts.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_offset">offset</code></td>
<td>
<p>either a single numeric value or a vector of length <code>J</code> that contains the offset for each location in the data set.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent abundance values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial variance parameter for each species. Ignored when <code>sp = FALSE</code> or when <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_phi">phi</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial decay parameter for each species. Ignored when <code>sp = FALSE</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial smoothness parameter for each species. Only used when <code>sp = TRUE</code> and <code>cov.model = 'matern'</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr> 
<tr><td><code id="simMsDS_+3A_factor.model">factor.model</code></td>
<td>
<p>a logical value indicating whether to simulate data following a factor modeling approach that explicitly incoporates species correlations. If <code>sp = TRUE</code>, the latent factors are simulated from independent spatial processes. If <code>sp = FALSE</code>, the latent factors are simulated from standard normal distributions.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_n.factors">n.factors</code></td>
<td>
<p>a single numeric value specifying the number of latent factors to use to simulate the data if <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="simMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times p.abund</code> numeric design matrix for the abundance portion of the model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a <code class="reqn">J \times p.abund</code> numeric design matrix for the detection portion of the model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a <code class="reqn">N \times J</code> matrix of the spatial random effects for each species. Only used to simulate data when <code>sp = TRUE</code>. If <code>factor.model = TRUE</code>, the first dimension is <code>n.factors</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a <code>n.sp x J</code> matrix of the expected abundances for each species at each site.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>a <code>n.sp x J</code> matrix of the latent occurrence states for each species at each site.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a <code>n.sp x J x max(n.rep)</code> array of the detection probabilities for each species at each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>n.sp x J x max(n.rep)</code> array of the raw distance sampling data for each species at each site and and distance bin.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a numeric matrix containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any abundance random effect included in the model. Only relevant when abundance random effects are specified in <code>mu.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated abundance random effects for each given level of the random effects included in the abundance model. Only relevant when abundance random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Number of species
n.sp &lt;- 5
# Community-level abundance coefficients
beta.mean &lt;- c(-1, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 0.3, 0.5, 0.4)
# Detection coefficients
alpha.mean &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha.mean)
tau.sq.alpha &lt;- c(0.1, 0.2)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- FALSE 
family &lt;- 'NB'
kappa &lt;- runif(n.sp, 0.3, 3) 
offset &lt;- pi * .8^2
transect &lt;- 'line'
factor.model &lt;- FALSE

dat &lt;- simMsDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
               n.sp = n.sp, beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
               mu.RE = mu.RE, p.RE = p.RE, sp = sp, cov.model = cov.model,
               sigma.sq = sigma.sq, phi = phi, nu = nu, family = family, 
               offset = offset, transect = transect, factor.model = factor.model)
</code></pre>

<hr>
<h2 id='simMsNMix'>Simulate Multi-Species Repeated Count Data with Imperfect Detection</h2><span id='topic+simMsNMix'></span>

<h3>Description</h3>

<p>The function <code>simMsNMix</code> simulates multi-species count data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the abundance portion of the model, as well as an option to allow for species correlations using a factor modeling approach. Non-spatial random effects can also be included in the detection or abundance portions of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMsNMix(J.x, J.y, n.rep, n.rep.max, n.sp, beta, alpha, kappa, mu.RE = list(), 
          p.RE = list(), offset = 1, sp = FALSE, cov.model, 
          sigma.sq, phi, nu, family = 'Poisson',
          factor.model = FALSE, n.factors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simMsNMix_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric vector of length <code class="reqn">J = J.x \times J.y</code> indicating the number of repeat visits at each of the <code class="reqn">J</code> sites.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a single numeric value indicating the maximum number of replicate surveys. This is an optional argument, with its default value set to <code>max(n.rep)</code>. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_n.sp">n.sp</code></td>
<td>
<p>a single numeric value indicating the number of species to simulate count data.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_beta">beta</code></td>
<td>
<p>a numeric matrix with <code>n.sp</code> rows containing the intercept and regression coefficient parameters for the abundance portion of the multi-species N-mixture model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr> 
<tr><td><code id="simMsNMix_+3A_alpha">alpha</code></td>
<td>
<p>a numeric matrix with <code>n.sp</code> rows containing the intercept and regression coefficient parameters for the detection portion of the multi-species N-mixture model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_kappa">kappa</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the dispersion parameter for the abundance portion of the N-mixture model for each species. Only relevant when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_mu.re">mu.RE</code></td>
<td>
<p>a list used to specify the non-spatial random effects included in the abundance portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.mu</code>. <code>levels</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the number of levels there are in each effect. <code>sigma.sq.mu</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the abundance portion of the model. An optional third tag, <code>beta.indx</code>, is a list that contains integers denoting the corresponding value of <code>beta</code> that each random effect corresponds to. This allows specification of random intercepts as well as slopes. By default, all effects are assumed to be random intercepts.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the non-spatial random effects included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the number of levels there are in each effects. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model. An optional third tag, <code>alpha.indx</code>, is a list that contains integers denoting the corresponding value of <code>alpha</code> that each random effect corresponds to. This allows specification of random intercepts as well as slopes. By default, all effects are assumed to be random intercepts.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_offset">offset</code></td>
<td>
<p>either a single numeric value or a vector of length <code>J</code> that contains the offset for each location in the data set.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent abundance values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial variance parameter for each species. Ignored when <code>sp = FALSE</code> or when <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_phi">phi</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial decay parameter for each species. Ignored when <code>sp = FALSE</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length <code>n.sp</code> containing the spatial smoothness parameter for each species. Only used when <code>sp = TRUE</code> and <code>cov.model = 'matern'</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr> 
<tr><td><code id="simMsNMix_+3A_factor.model">factor.model</code></td>
<td>
<p>a logical value indicating whether to simulate data following a factor modeling approach that explicitly incoporates species correlations. If <code>sp = TRUE</code>, the latent factors are simulated from independent spatial processes. If <code>sp = FALSE</code>, the latent factors are simulated from standard normal distributions.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_n.factors">n.factors</code></td>
<td>
<p>a single numeric value specifying the number of latent factors to use to simulate the data if <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="simMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times p.abund</code> numeric design matrix for the abundance portion of the model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a three-dimensional numeric array with dimensions corresponding to sites, repeat visits, and number of detection regression coefficients. This is the design matrix used for the detection portion of the N-mixture model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a <code class="reqn">N \times J</code> matrix of the spatial random effects for each species. Only used to simulate data when <code>sp = TRUE</code>. If <code>factor.model = TRUE</code>, the first dimension is <code>n.factors</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a <code>n.sp x J</code> matrix of the expected abundances for each species at each site.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>a <code>n.sp x J</code> matrix of the latent occurrence states for each species at each site.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a <code>n.sp x J x max(n.rep)</code> array of the detection probabilities for each species at each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>n.sp x J x max(n.rep)</code> array of the raw count data for each species at each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a three-dimensional numeric array containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any abundance random effect included in the model. Only relevant when abundance random effects are specified in <code>mu.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated abundance random effects for each given level of the random effects included in the abundance model. Only relevant when abundance random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
n.sp &lt;- 10
# Community-level covariate effects
# Abundance 
beta.mean &lt;- c(0.2, -0.15)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2)
tau.sq.alpha &lt;- c(0.2, 0.3)
p.det &lt;- length(alpha.mean)
mu.RE &lt;- list(levels = c(10, 12), 
              sigma.sq.mu = c(1.5, 0.3), 
              beta.indx = list(1, 2))
p.RE &lt;- list(levels = c(15, 10), 
             sigma.sq.p = c(0.8, 0.5), 
             alpha.indx = list(1, 2))
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
alpha &lt;- matrix(NA, nrow = n.sp, ncol = p.det)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(n.sp, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
factor.model &lt;- TRUE
n.factors &lt;- 3
# Spatial parameters if desired
phi &lt;- runif(n.factors, 3/1, 3/.1)
sp &lt;- TRUE
family &lt;- 'Poisson'

dat &lt;- simMsNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, 
                alpha = alpha, mu.RE = mu.RE, p.RE = p.RE, sp = TRUE, 
                cov.model = 'exponential', phi = phi, factor.model = factor.model,
                n.factors = n.factors, family = family)
</code></pre>

<hr>
<h2 id='simNMix'>Simulate Single-Species Count Data with Imperfect Detection</h2><span id='topic+simNMix'></span>

<h3>Description</h3>

<p>The function <code>simNMix</code> simulates single-species count data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the abundance portion of the model. Non-spatial random intercepts/slopes can also be included in the detection or abundance portions of the N-mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNMix(J.x, J.y, n.rep, n.rep.max, beta, alpha, kappa, mu.RE = list(), 
        p.RE = list(), offset = 1, sp = FALSE, cov.model, sigma.sq, phi, nu, 
        family = 'Poisson', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simNMix_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simNMix_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate count data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simNMix_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric vector of length <code class="reqn">J = J.x \times J.y</code> indicating the number of repeat visits at each of the <code class="reqn">J</code> sites.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a single numeric value indicating the maximum number of replicate surveys. This is an optional argument, with its default value set to <code>max(n.rep)</code>. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simNMix_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the abundance portion of the single-species N-mixture model.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the detection portion of the single-species N-mixture model.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_kappa">kappa</code></td>
<td>
<p>a single numeric value containing the dispersion parameter for the abundance portion of the N-mixture model. Only relevant when <code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_mu.re">mu.RE</code></td>
<td>
<p>a list used to specify the non-spatial random effects included in the abundance portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.mu</code>. <code>levels</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the number of levels there are in each effect. <code>sigma.sq.mu</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the abundance portion of the model. An optional third tag, <code>beta.indx</code>, is a list that contains integers denoting the corresponding value of <code>beta</code> that each random effect corresponds to. This allows specification of random intercepts as well as slopes. By default, all effects are assumed to be random intercepts.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the non-spatial random effects included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the number of levels there are in each effects. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random effects to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model. An optional third tag, <code>alpha.indx</code>, is a list that contains integers denoting the corresponding value of <code>alpha</code> that each random effect corresponds to. This allows specification of random intercepts as well as slopes. By default, all effects are assumed to be random intercepts.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_offset">offset</code></td>
<td>
<p>either a single numeric value or a vector of length <code>J</code> that contains the offset for each location in the data set.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit N-mixture model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent abundance values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial decay parameter. Ignored when <code>sp = FALSE</code>. </p>
</td></tr>
<tr><td><code id="simNMix_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>.</p>
</td></tr> 
<tr><td><code id="simNMix_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="simNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times p.abund</code> numeric design matrix for the abundance portion of the model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a three-dimensional numeric array with dimensions corresponding to sites, repeat visits, and number of detection regression coefficients. This is the design matrix used for the detection portion of the N-mixture model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a <code class="reqn">J \times 1</code> matrix of the spatial random effects. Only used to simulate data when <code>sp = TRUE</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a <code class="reqn">J \times 1</code> matrix of the expected abundance values for each site.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>a length <code class="reqn">J</code> vector of the latent abundances at each site.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a <code>J x max(n.rep)</code> matrix of the detection probabilities for each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>J x max(n.rep)</code> matrix of the raw count data for each site and replicate combination.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a three-dimensional numeric array containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any abundance random effect included in the model. Only relevant when abundance random effects are specified in <code>mu.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric vector that contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric vector that contains the simulated abundance random effects for each given level of the random effects included in the N-mixture model. Only relevant when abundance random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 10
J.y &lt;- 10
n.rep &lt;- rep(4, J.x * J.y)
beta &lt;- c(0.5, -0.15)
alpha &lt;- c(0.7, 0.4)
kappa &lt;- 0.5
phi &lt;- 3 / .6
sigma.sq &lt;- 2
mu.RE &lt;- list(levels = 10, sigma.sq.mu = 1.2)
p.RE &lt;- list(levels = 15, sigma.sq.p = 0.8)
dat &lt;- simNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
               kappa = kappa, mu.RE = mu.RE, p.RE = p.RE, sp = TRUE, 
               cov.model = 'spherical', sigma.sq = sigma.sq, phi = phi, 
               family = 'NB')
</code></pre>

<hr>
<h2 id='spAbund'>Function for Fitting Univariate Spatial Abundance GLMs</h2><span id='topic+spAbund'></span>

<h3>Description</h3>

<p>The function <code>spAbund</code> fits univariate spatial abundance GLMs.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spAbund(formula, data, inits, priors, tuning,
        cov.model = 'exponential', NNGP = TRUE, 
        n.neighbors = 15, search.type = 'cb',
        n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
        n.omp.threads = 1, verbose = TRUE, n.report = 100, 
        n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
        n.chains = 1, save.fitted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spAbund_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spAbund_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>z</code>, <code>coords</code>, and <code>offset</code>. <code>y</code>
is a vector, matrix, or data frame of the observed count values. If a vector, 
the values represent the observed counts at each site. If multiple replicate
observations are obtained at the sites (e.g., sub-samples, repeated sampling over
multiple seasons), <code>y</code> can be specified as a matrix or data frame 
with first dimension equal to the number of 
sites (<code class="reqn">J</code>) and second dimension equal to the maximum number of 
replicates at a given site. <code>covs</code> is either a data frame or list 
containing the variables used in the model. When only fitting a model with site-level 
data, <code>covs</code> can be specified as a data frame, with each row corresponding to 
site and each column corresponding to a variable. When multiple abundance values
are available at a site, <code>covs</code> is specified as a list, where each list element is a different
covariate, which can be site-level or observation-level. Site-level covariates
are specified as a vector of length <code class="reqn">J</code>, while observation-level covariates
are specified as a matrix or data frame with the number of rows equal to <code class="reqn">J</code>
and number of columns equal to the maximum number of replicate observations at a 
given site. <code>coords</code> is a <code class="reqn">J \times 2</code> matrix of the observation coordinates. 
Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system. For zero-inflated Gaussian models, the tag <code>z</code> is
used to specify the binary component of the zero-inflated model and should have the same
length as <code>y</code>. <code>offset</code> is an offset to use in the abundance model (e.g., an area offset). 
This can be either a single value, a vector with an offset for each site (e.g., if survey area differed in size), or a site x replicate matrix if more than one count is available at a given site.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, <code>nu</code>, <code>kappa</code>, <code>sigma.sq.mu</code>, <code>tau.sq</code>. 
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, <code>sigma.sq.mu</code>
is only specified if there are random effects in <code>formula</code>, and
<code>kappa</code> is only specified when <code>family = 'NB'</code>. 
<code>tau.sq</code> is only specified when <code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>.
The value portion of each tag is the parameter's initial value. See <code>priors</code>
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>nu.unif</code>, <code>kappa.unif</code>,
<code>sigma.sq.mu.ig</code>, <code>tau.sq.ig</code>. Abundance (<code>beta</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length
one if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances are set to 100. The 
spatial variance parameter, <code>sigma.sq</code>, is assumed to follow an 
inverse-Gamma distribution. The spatial decay <code>phi</code>, spatial 
smoothness <code>nu</code>, and negative binomial dispersion <code>kappa</code>
parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code> 
are passed as a vector of length two, with the first and second 
elements corresponding to the <em>shape</em> and <em>scale</em>, respectively. 
The hyperparameters of the Uniform are also passed as a vector of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively. <code>sigma.sq.mu</code>
are the random effect variances for any random effects, and are assumed to follow an 
inverse-Gamma distribution. The hyperparameters of
the inverse-Gamma distribution are passed as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, 
respectively, which are each specified as vectors of length equal to the 
number of random effects or of length one if priors are the same for all
random effect variances. <code>tau.sq</code> is the residual variance 
for Gaussian (or zero-inflated Gaussian) models, and it is assigned 
an inverse-Gamma prior. The hyperparameters of the inverse-Gamma are passed as a vector
of length two, with the first and second element corresponding to the shape and 
scale parameters, respectively.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_tuning">tuning</code></td>
<td>
<p>a single numeric value representing the initial variance of the
adaptive sampler for <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>kappa</code>, <code>phi</code>, 
and <code>nu</code>. See Roberts and Rosenthal (2009) for details. Note that only <code>phi</code> 
and <code>nu</code> are the only parameters that require tuning for a Gaussian or 
zero-inflated Gaussian model.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only NNGP is supported,
functionality for a full GP may be addded in future package development.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="spAbund_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial), <code>'Poisson'</code>, <code>'Gaussian'</code>, 
and <code>'zi-Gaussian'</code>.</p>
</td></tr> 
<tr><td><code id="spAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples in each chain to discard as burn-in. By default, the first 
10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of MCMC chains to run in sequence.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_save.fitted">save.fitted</code></td>
<td>
<p>logical value indicating whether or not fitted values and likelihood values
should be saved in the resulting model object. If <code>save.fitted = FALSE</code>, the components
<code>y.rep.samples</code>, <code>mu.samples</code>, and <code>like.samples</code> will not be included
in the model object, and subsequent functions for calculating WAIC, fitted values, and
posterior predictive checks will not work, although they all can be calculated manually if
desired. Setting <code>save.fitted = FALSE</code> can be useful when working with very large 
data sets to minimize the amount of RAM needed when fitting and storing the model object in 
memory.</p>
</td></tr>
<tr><td><code id="spAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spAbund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance dispersion parameter. Only included when
<code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the Gaussian residual variance parameter. Only included when
<code>family = 'Gaussian'</code> or <code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a two or three-dimensional object of posterior samples 
for the abundance replicate (fitted) values with dimensions 
corresponding to MCMC samples, site, and replicate.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a two or -three-dimensional array of posterior samples
for the expected abundance samples with dimensions corresponding 
to MCMC samples, site, and replicate.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for latent spatial random effects.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the model. 
Only included if random effects are specified in 
<code>formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the likelihood value associated with each site. Used for calculating
WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0, -1.5, 0.3, -0.8)
p.abund &lt;- length(beta)
mu.RE &lt;- list(levels = c(50, 45),
              sigma.sq.mu = c(1.3, 0.5), 
              beta.indx = c(1, 2))
phi &lt;- 3/.6
sigma.sq &lt;- 2
kappa &lt;- 0.2
sp &lt;- TRUE 
cov.model &lt;- 'exponential'
family &lt;- 'NB'
dat &lt;- simAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, 
                kappa = kappa, mu.RE = mu.RE, sp = sp, phi = phi, 
                sigma.sq = sigma.sq, cov.model = cov.model, family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
coords &lt;- dat$coords

covs &lt;- list(int = X[, , 1], 
             abund.cov.1 = X[, , 2], 
             abund.cov.2 = X[, , 3], 
             abund.cov.3 = X[, , 4],
             abund.factor.1 = X.re[, , 1], 
             abund.factor.2 = X.re[, , 2])

data.list &lt;- list(y = y, covs = covs, coords = coords)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 100),
                   phi.unif = c(3 / 1, 3 / .1),
                   sigma.sq.ig = c(2, 1),
                   kappa.unif = c(0.001, 10)) 
# Starting values
inits.list &lt;- list(beta = beta, kappa = kappa, sigma.sq = sigma.sq, phi = phi)

tuning &lt;- list(phi = 0.3, kappa = 0.05, beta = 0.1, beta.star = 0.1, w = 0.1) 
n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 20 
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- spAbund(formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3 +
                           (1 | abund.factor.1) + (abund.cov.1 | abund.factor.2),
               data = data.list, 
               n.batch = n.batch, 
               batch.length = batch.length, 
               inits = inits.list, 
               tuning = tuning,
               priors = prior.list, 
               NNGP = TRUE, 
               cov.model = 'exponential',
               search.type = 'cb',
               n.neighbors = 5,
               accept.rate = 0.43, 
               n.omp.threads = 1, 
               verbose = TRUE, 
               n.report = 1,
               n.burn = n.burn,
               n.thin = n.thin,
               n.chains = n.chains) 
summary(out)
</code></pre>

<hr>
<h2 id='spDS'>Function for Fitting Single-Species Spatially-Explicit Hierarchical Distance Sampling Models</h2><span id='topic+spDS'></span>

<h3>Description</h3>

<p>Function for fitting single-sepcies spatially-explicit hierarchical distance sampling models. Spatial models are fit using Nearest Neighbor Gaussian Processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spDS(abund.formula, det.formula, data, inits, priors, tuning,
     cov.model = 'exponential', NNGP = TRUE,
     n.neighbors = 15, search.type = 'cb',
     n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
     transect = 'line', det.func = 'halfnormal',
     n.omp.threads = 1, verbose = TRUE,
     n.report = 100, n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
     n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spDS_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spDS_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spDS_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>coords</code>, <code>dist.breaks</code>, and <code>offset</code>. <code>y</code>
is a matrix or data frame of the observed count values, 
with first dimension equal to the number of 
sites (<code class="reqn">J</code>) and second dimension equal to the number of 
distance bins. <code>covs</code> is a matrix or data frame
containing the variables used in the abundance and/or the detection
portion of the model, with
<code class="reqn">J</code> rows for each column (variable). <code>dist.breaks</code> is a vector of 
distances that denote the breakpoints of the distance bands. <code>dist.breaks</code> should
have length equal to the number of columns in <code>y</code> plus one. <code>offset</code> is an 
offset that can be used to scale estimates from abundance per transect to density per 
some desired unit of measure. This can be either a single value or a vector with an offset
value for each site (e.g., if transects differ in length). 
<code>coords</code> is a <code class="reqn">J \times 2</code> matrix of the observation coordinates. 
Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system. </p>
</td></tr>
<tr><td><code id="spDS_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>N</code>, <code>beta</code>, <code>alpha</code>, <code>kappa</code>, 
<code>sigma.sq</code>, <code>phi</code>, <code>w</code>, <code>nu</code>,
<code>sigma.sq.mu</code>, and <code>sigma.sq.p</code>. The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.mu</code> and <code>sigma.sq.p</code> are 
only relevant when including random effects in the abundance and 
detection portion of the abundance model, respectively. <code>kappa</code> is 
only relevant when <code>family = 'NB'</code>. <code>nu</code> is only 
specified if <code>cov.model = "matern"</code>. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="spDS_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>kappa.unif</code>, 
<code>phi.unif</code>, <code>sigma.sq.ig</code>, <code>nu.unif</code>, 
<code>sigma.sq.mu.ig</code>, and <code>sigma.sq.p.ig</code>. 
Abundance (<code>beta</code>) and detection (<code>alpha</code>) 
regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 100. The spatial variance parameter, 
<code>sigma.sq</code>, is assumed to follow an 
inverse-Gamma distribution. The spatial decay <code>phi</code>, spatial 
smoothness <code>nu</code>, and negative binomial dispersion <code>kappa</code>
parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code> 
are passed as a vector of length two, with the first and second 
elements corresponding to the <em>shape</em> and <em>scale</em>, respectively. 
The hyperparameters of the Uniform are also passed as a vector of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts/slopes or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="spDS_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations. Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="spDS_+3A_tuning">tuning</code></td>
<td>
<p>a single numeric value representing the initial variance of the
adaptive sampler for <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values),
<code>kappa</code>, <code>phi</code>, <code>nu</code>, and <code>w</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spDS_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP.  See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only NNGP is supported,
functionality for a Gaussian Process may be addded in future package development.</p>
</td></tr>
<tr><td><code id="spDS_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="spDS_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid.</p>
</td></tr>
<tr><td><code id="spDS_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spDS_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spDS_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spDS_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr> 
<tr><td><code id="spDS_+3A_transect">transect</code></td>
<td>
<p>the type of transect. Currently supports line transects (<code>'line'</code>) or
circular transects (i.e., point counts; <code>'point'</code>).</p>
</td></tr>
<tr><td><code id="spDS_+3A_det.func">det.func</code></td>
<td>
<p>the detection model used to describe how detection probability varies
with distance. In other software, this is often referred to as the key function. Currently
supports two functions: half normal (<code>'halfnormal'</code>) and negative exponential
(<code>'negexp'</code>).</p>
</td></tr>
<tr><td><code id="spDS_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="spDS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="spDS_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="spDS_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="spDS_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="spDS_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="spDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spDS</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance dispersion parameter. Only included when
<code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent abundance values. Note that these values always
represent transect-level abundance, even when an offset is 
supplied.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent expected abundance values. When an offset is 
supplied in the <code>data</code> object, these correspond to expected 
abundance per unit area (i.e., density).</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for latent spatial random effects.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a three-dimensional array of fitted values. 
Array dimensions correspond to MCMC samples, sites, and distance band.</p>
</td></tr>
<tr><td><code>pi.samples</code></td>
<td>
<p>a three-dimensional array of cell-specific detection
probabilities. Array dimensions correspond to MCMC samples, sites, and distance band.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Royle, J. A., Dawson, D. K., &amp; Bates, S. (2004). Modeling 
abundance effects in distance sampling. Ecology, 85(6), 1591-1597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
# Number of distance bins from which to simulate data. 
n.bins &lt;- 5
# Length of each bin. This should be of length n.bins
bin.width &lt;- c(.10, .10, .20, .3, .1)
# Abundance coefficients
beta &lt;- c(1.0, 0.2, 0.3, -0.2)
p.abund &lt;- length(beta)
# Detection coefficients
alpha &lt;- c(-1.0, -0.3)
p.det &lt;- length(alpha)
# Detection decay function
det.func &lt;- 'halfnormal'
mu.RE &lt;- list()
p.RE &lt;- list()
sp &lt;- TRUE
phi &lt;- 3 / .5
sigma.sq &lt;- 0.8
cov.model &lt;- 'exponential'
family &lt;- 'NB'
kappa &lt;- 0.1
offset &lt;- 1.8
transect &lt;- 'point'

dat &lt;- simDS(J.x = J.x, J.y = J.y, n.bins = n.bins, bin.width = bin.width,
             beta = beta, alpha = alpha, det.func = det.func, kappa = kappa, 
             mu.RE = mu.RE, p.RE = p.RE, sp = sp,
             offset = offset, transect = transect, phi = phi, sigma.sq = sigma.sq,
             cov.model = cov.model)

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
dist.breaks &lt;- dat$dist.breaks
coords &lt;- dat$coords

covs &lt;- cbind(X, X.p)
colnames(covs) &lt;- c('int.abund', 'abund.cov.1', 'abund.cov.2', 'abund.cov.3', 
                    'int.det', 'det.cov.1')

data.list &lt;- list(y = y, 
                  covs = covs,
                  dist.breaks = dist.breaks, 
                  coords = coords,
                  offset = offset)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 10),
                   alpha.normal = list(mean = 0,
                                       var = 10), 
                   kappa.unif = c(0, 100), 
                   phi.unif = c(3 / 1, 3 / .1),
                   sigma.sq.ig = c(2, 1)) 
# Starting values
inits.list &lt;- list(alpha = 0,
                   beta = 0,
                   kappa = 1, 
                   phi = 3 / .5, 
                   sigma.sq = 1)
# Tuning values
tuning &lt;- list(beta = 0.1, alpha = 0.1, beta.star = 0.3, alpha.star = 0.1, 
               kappa = 0.2, phi = 1, w = 1) 

out &lt;- spDS(abund.formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3,
            det.formula = ~ det.cov.1,
            data = data.list, 
            n.batch = 10, 
            batch.length = 25, 
            inits = inits.list, 
            family = 'NB',
            det.func = 'halfnormal', 
            transect = 'point', 
            cov.model = 'exponential', 
            NNGP = TRUE,
	    n.neighbors = 5,
            tuning = tuning,
            priors = prior.list, 
            accept.rate = 0.43, 
            n.omp.threads = 1, 
            verbose = TRUE, 
            n.report = 100,
            n.burn = 100,
            n.thin = 1,
            n.chains = 1) 
summary(out)
</code></pre>

<hr>
<h2 id='spNMix'>Function for Fitting Single-Species Spatial N-Mixture Models</h2><span id='topic+spNMix'></span>

<h3>Description</h3>

<p>The function <code>spNMix</code> fits single-species spatial N-mixture models. Spatial models are fit using Nearest Neighbor Gaussian Processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spNMix(abund.formula, det.formula, data, inits, priors, tuning,
       cov.model = 'exponential', NNGP = TRUE, 
       n.neighbors = 15, search.type = 'cb',
       n.batch, batch.length, accept.rate = 0.43, family = 'Poisson',
       n.omp.threads = 1, verbose = TRUE, n.report = 100, 
       n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
       n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spNMix_+3A_abund.formula">abund.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the abundance portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and random slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spNMix_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and random slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spNMix_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>abund.covs</code>, <code>det.covs</code>, <code>offset</code>, and <code>coords</code>. 
<code>y</code> is the count data matrix or data frame with 
first dimension equal to the number of sites (<code class="reqn">J</code>) and second 
dimension equal to the maximum number of replicates at a given site. 
<code>abund.covs</code> is a matrix or data frame containing the variables used 
in the abundance portion of the model, with <code class="reqn">J</code> rows for each column 
(variable). <code>det.covs</code> is a list of variables included in the 
detection portion of the model. Each list element is a different detection 
covariate, which can be site-level or observational-level. Site-level 
covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified 
as a matrix or data frame with the number of rows equal to <code class="reqn">J</code> and 
number of columns equal to the maximum number of replicates at a given site. 
<code>coords</code> is a <code class="reqn">J \times 2</code> matrix of the observation coordinates. 
Note that <code>spAbundance</code> assumes coordinates are specified 
in a projected coordinate system. <code>offset</code> is an offset to use in 
the abundance model (e.g., an area offset). This can be either a single value or a 
vector with an offset for each site (e.g., if survey area differed in size).</p>
</td></tr>
<tr><td><code id="spNMix_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>N</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, <code>nu</code>, <code>kappa</code>, <code>sigma.sq.mu</code>, <code>sigma.sq.p</code>. 
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, <code>sigma.sq.p</code>
is only specified if there are random effects in <code>det.formula</code>, <code>sigma.sq.mu</code>
is only specified if there are random effects in <code>abund.formula</code>, and
<code>kappa</code> is only specified when <code>family = 'NB'</code>. 
The value portion of each tag is the parameter's initial value. See <code>priors</code>
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>nu.unif</code>, <code>kappa.unif</code>,
<code>sigma.sq.mu.ig</code>, and <code>sigma.sq.p.ig</code>. Abundance 
(<code>beta</code>) and detection (<code>alpha</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length
one if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances for abundance coefficients
are set to 100 and for detection coefficients set to 2.72. The 
spatial variance parameter, <code>sigma.sq</code>, is assumed to follow an 
inverse-Gamma distribution. The spatial decay <code>phi</code>, spatial 
smoothness <code>nu</code>, and negative binomial dispersion <code>kappa</code>
parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code> 
are passed as a vector of length two, with the first and second 
elements corresponding to the <em>shape</em> and <em>scale</em>, respectively. 
The hyperparameters of the Uniform are also passed as a vector of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively. <code>sigma.sq.mu</code> and 
<code>sigma.sq.p</code> are the random effect variances for any abundance or 
detection random effects, respectively, and are assumed to follow an 
inverse-Gamma distribution. The hyperparameters of
the inverse-Gamma distribution are passed as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, 
respectively, which are each specified as vectors of length equal to the 
number of random intercepts/slopes or of length one if priors are the same for all
random effect variances.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations. Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_tuning">tuning</code></td>
<td>
<p>a single numeric value representing the initial variance of the
adaptive sampler for <code>beta</code>, <code>alpha</code>, <code>beta.star</code> (the abundance 
random effect values), <code>alpha.star</code> (the detection random effect values),
<code>kappa</code>, <code>phi</code>, <code>nu</code>, and <code>w</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP.  See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only NNGP is supported,
functionality for a Gaussian Process may be addded in future package development.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_family">family</code></td>
<td>
<p>the distribution to use for the latent abundance process. Currently 
supports <code>'NB'</code> (negative binomial) and <code>'Poisson'</code>.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples in each chain to discard as burn-in. By default, the first 
10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of MCMC chains to run in sequence.</p>
</td></tr>
<tr><td><code id="spNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spNMix</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>kappa.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance dispersion parameter. Only included when
<code>family = 'NB'</code>.</p>
</td></tr>
<tr><td><code>N.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent abundance values</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent expected abundance values</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for latent spatial random effects.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts/slopes included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the detection portion 
of the model. Only included if random effects are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random effects 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability values are not included in the model object, but can be 
extracted using <code>fitted()</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Royle, J. A. (2004). N‐mixture models for estimating population size 
from spatially replicated counts. Biometrics, 60(1), 108-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(350)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 15
J.y &lt;- 15 
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0.5, 1.5)
p.abund &lt;- length(beta)
alpha &lt;- c(0.5, 1.2, -0.5)
p.det &lt;- length(alpha)
mu.RE &lt;- list()
p.RE &lt;- list()
phi &lt;- runif(1, 3 / 1, 3 / .1)
sigma.sq &lt;- runif(1, 0.2, 1.5) 
kappa &lt;- 0.5
sp &lt;- TRUE 
cov.model &lt;- 'exponential'
dat &lt;- simNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
               kappa = kappa, mu.RE = mu.RE, p.RE = p.RE, sp = sp, 
               phi = phi, sigma.sq = sigma.sq, cov.model = cov.model, 
               family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
coords &lt;- dat$coords

abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')

det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3]) 

data.list &lt;- list(y = y, 
                  abund.covs = abund.covs,
                  det.covs = det.covs, 
                  coords = coords)

# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.abund), 
                                      var = rep(100, p.abund)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)), 
                   kappa.unif = c(0, 10)) 
# Starting values
inits.list &lt;- list(alpha = alpha,
                   beta = beta,
                   kappa = kappa, 
                   w = rep(0, J),
                   phi = 3 / 0.5,
                   sigma.sq = 1,
                   N = apply(y, 1, max, na.rm = TRUE))
# Tuning values 
tuning.list &lt;- list(phi = 0.5, kappa = 0.5, beta = 0.1, alpha = 0.1, w = 0.1)


n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- spNMix(abund.formula = ~ abund.cov.1,
              det.formula = ~ det.cov.1 + det.cov.2, 
              data = data.list, 
              n.batch = n.batch, 
              batch.length = batch.length, 
              inits = inits.list, 
              priors = prior.list, 
              NNGP = TRUE,
              cov.model = 'spherical',
              n.neighbors = 10,
              accept.rate = 0.43, 
              n.omp.threads = 1, 
              verbose = TRUE, 
              n.report = 1,
              n.burn = n.burn,
              n.thin = n.thin,
              n.chains = n.chains)
summary(out)
</code></pre>

<hr>
<h2 id='summary.abund'>Methods for abund Object</h2><span id='topic+summary.abund'></span><span id='topic+print.abund'></span><span id='topic+plot.abund'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted univariate GLMMs (<code>abund</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'abund'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'abund'
print(x, ...)
## S3 method for class 'abund'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.abund_+3A_object">object</code>, <code id="summary.abund_+3A_x">x</code></td>
<td>
<p>object of class <code>abund</code>.</p>
</td></tr>
<tr><td><code id="summary.abund_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.abund_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.abund_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "tau.sq"</code>.</p>
</td></tr>
<tr><td><code id="summary.abund_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.abund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>abund</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>abund</code> object.
</p>

<hr>
<h2 id='summary.DS'>Methods for DS Object</h2><span id='topic+summary.DS'></span><span id='topic+print.DS'></span><span id='topic+plot.DS'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species hierarchiacl distance sampling (<code>DS</code>) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DS'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'DS'
print(x, ...)
## S3 method for class 'DS'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.DS_+3A_object">object</code>, <code id="summary.DS_+3A_x">x</code></td>
<td>
<p>object of class <code>DS</code>.</p>
</td></tr>
<tr><td><code id="summary.DS_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.DS_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.DS_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "alpha", "alpha.star", "sigma.sq.p"</code>.</p>
</td></tr>
<tr><td><code id="summary.DS_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.DS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>DS</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>DS</code> object.
</p>

<hr>
<h2 id='summary.lfMsAbund'>Methods for lfMsAbund Object</h2><span id='topic+summary.lfMsAbund'></span><span id='topic+print.lfMsAbund'></span><span id='topic+plot.lfMsAbund'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted latent factor multivariate abundance GLMMs (<code>lfMsAbund</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsAbund'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'lfMsAbund'
print(x, ...)
## S3 method for class 'lfMsAbund'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lfMsAbund_+3A_object">object</code>, <code id="summary.lfMsAbund_+3A_x">x</code></td>
<td>
<p>object of class <code>lfMsAbund</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsAbund_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsAbund_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.lfMsAbund_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.lfMsAbund_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "tau.sq", "beta.comm", 
                     "tau.sq.beta", "lambda"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsAbund_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.lfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>lfMsAbund</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>lfMsAbund</code> object.
</p>

<hr>
<h2 id='summary.lfMsDS'>Methods for lfMsDS Object</h2><span id='topic+summary.lfMsDS'></span><span id='topic+print.lfMsDS'></span><span id='topic+plot.lfMsDS'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted latent factor multi-species hierarchical distance sampling (<code>lfMsDS</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsDS'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'lfMsDS'
print(x, ...)
## S3 method for class 'lfMsDS'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lfMsDS_+3A_object">object</code>, <code id="summary.lfMsDS_+3A_x">x</code></td>
<td>
<p>object of class <code>lfMsDS</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsDS_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsDS_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.lfMsDS_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.lfMsDS_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", "lambda"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsDS_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.lfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>lfMsDS</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>lfMsDS</code> object.
</p>

<hr>
<h2 id='summary.lfMsNMix'>Methods for lfMsNMix Object</h2><span id='topic+summary.lfMsNMix'></span><span id='topic+print.lfMsNMix'></span><span id='topic+plot.lfMsNMix'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted latent factor multi-species N-mixture (<code>lfMsNMix</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsNMix'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'lfMsNMix'
print(x, ...)
## S3 method for class 'lfMsNMix'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lfMsNMix_+3A_object">object</code>, <code id="summary.lfMsNMix_+3A_x">x</code></td>
<td>
<p>object of class <code>lfMsNMix</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsNMix_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsNMix_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.lfMsNMix_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.lfMsNMix_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", "lambda"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsNMix_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.lfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>lfMsNMix</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>lfMsNMix</code> object.
</p>

<hr>
<h2 id='summary.msAbund'>Methods for msAbund Object</h2><span id='topic+summary.msAbund'></span><span id='topic+print.msAbund'></span><span id='topic+plot.msAbund'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multivariate abundance GLMMs (<code>msAbund</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msAbund'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'msAbund'
print(x, ...)
## S3 method for class 'msAbund'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.msAbund_+3A_object">object</code>, <code id="summary.msAbund_+3A_x">x</code></td>
<td>
<p>object of class <code>msAbund</code>.</p>
</td></tr>
<tr><td><code id="summary.msAbund_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.msAbund_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.msAbund_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.msAbund_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "tau.sq", "beta.comm", 
                     "tau.sq.beta"</code>.</p>
</td></tr>
<tr><td><code id="summary.msAbund_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.msAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>msAbund</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>msAbund</code> object.
</p>

<hr>
<h2 id='summary.msDS'>Methods for msDS Object</h2><span id='topic+summary.msDS'></span><span id='topic+print.msDS'></span><span id='topic+plot.msDS'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species hierarchical distance sampling (<code>msDS</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msDS'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'msDS'
print(x, ...)
## S3 method for class 'msDS'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.msDS_+3A_object">object</code>, <code id="summary.msDS_+3A_x">x</code></td>
<td>
<p>object of class <code>msDS</code>.</p>
</td></tr>
<tr><td><code id="summary.msDS_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.msDS_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.msDS_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.msDS_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha"</code>.</p>
</td></tr>
<tr><td><code id="summary.msDS_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.msDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>msDS</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>msDS</code> object.
</p>

<hr>
<h2 id='summary.msNMix'>Methods for msNMix Object</h2><span id='topic+summary.msNMix'></span><span id='topic+print.msNMix'></span><span id='topic+plot.msNMix'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species N-mixture (<code>msNMix</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msNMix'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'msNMix'
print(x, ...)
## S3 method for class 'msNMix'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.msNMix_+3A_object">object</code>, <code id="summary.msNMix_+3A_x">x</code></td>
<td>
<p>object of class <code>msNMix</code>.</p>
</td></tr>
<tr><td><code id="summary.msNMix_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.msNMix_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.msNMix_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.msNMix_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha"</code>.</p>
</td></tr>
<tr><td><code id="summary.msNMix_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.msNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>msNMix</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>msNMix</code> object.
</p>

<hr>
<h2 id='summary.NMix'>Methods for NMix Object</h2><span id='topic+summary.NMix'></span><span id='topic+print.NMix'></span><span id='topic+plot.NMix'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species N-mixture (<code>NMix</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMix'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'NMix'
print(x, ...)
## S3 method for class 'NMix'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NMix_+3A_object">object</code>, <code id="summary.NMix_+3A_x">x</code></td>
<td>
<p>object of class <code>NMix</code>.</p>
</td></tr>
<tr><td><code id="summary.NMix_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.NMix_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.NMix_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", 
		     "alpha", "alpha.star", "sigma.sq.p"</code>.</p>
</td></tr>
<tr><td><code id="summary.NMix_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.NMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>NMix</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>NMix</code> object.
</p>

<hr>
<h2 id='summary.sfMsAbund'>Methods for sfMsAbund Object</h2><span id='topic+summary.sfMsAbund'></span><span id='topic+print.sfMsAbund'></span><span id='topic+plot.sfMsAbund'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted spatial factor multivariate abundance GLMMs (<code>sfMsAbund</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsAbund'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'sfMsAbund'
print(x, ...)
## S3 method for class 'sfMsAbund'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sfMsAbund_+3A_object">object</code>, <code id="summary.sfMsAbund_+3A_x">x</code></td>
<td>
<p>object of class <code>sfMsAbund</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsAbund_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsAbund_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.sfMsAbund_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.sfMsAbund_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "tau.sq", "beta.comm", 
                     "tau.sq.beta", "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsAbund_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.sfMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>sfMsAbund</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>sfMsAbund</code> object.
</p>

<hr>
<h2 id='summary.sfMsDS'>Methods for sfMsDS Object</h2><span id='topic+summary.sfMsDS'></span><span id='topic+print.sfMsDS'></span><span id='topic+plot.sfMsDS'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted spatial multi-species hierarchical distance sampling (<code>sfMsDS</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsDS'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'sfMsDS'
print(x, ...)
## S3 method for class 'sfMsDS'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sfMsDS_+3A_object">object</code>, <code id="summary.sfMsDS_+3A_x">x</code></td>
<td>
<p>object of class <code>sfMsDS</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsDS_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsDS_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.sfMsDS_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.sfMsDS_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsDS_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.sfMsDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>sfMsDS</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>sfMsDS</code> object.
</p>

<hr>
<h2 id='summary.sfMsNMix'>Methods for sfMsNMix Object</h2><span id='topic+summary.sfMsNMix'></span><span id='topic+print.sfMsNMix'></span><span id='topic+plot.sfMsNMix'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted spatial factor multi-species N-mixture (<code>sfMsNMix</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsNMix'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'sfMsNMix'
print(x, ...)
## S3 method for class 'sfMsNMix'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sfMsNMix_+3A_object">object</code>, <code id="summary.sfMsNMix_+3A_x">x</code></td>
<td>
<p>object of class <code>sfMsNMix</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsNMix_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsNMix_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.sfMsNMix_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.sfMsNMix_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsNMix_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.sfMsNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>sfMsNMix</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>sfMsNMix</code> object.
</p>

<hr>
<h2 id='summary.spAbund'>Methods for spAbund Object</h2><span id='topic+summary.spAbund'></span><span id='topic+print.spAbund'></span><span id='topic+plot.spAbund'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted univariate spatially-explicit GLMMs (<code>spAbund</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spAbund'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'spAbund'
print(x, ...)
## S3 method for class 'spAbund'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spAbund_+3A_object">object</code>, <code id="summary.spAbund_+3A_x">x</code></td>
<td>
<p>object of class <code>spAbund</code>.</p>
</td></tr>
<tr><td><code id="summary.spAbund_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.spAbund_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.spAbund_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "tau.sq", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.spAbund_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.spAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>spAbund</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>spAbund</code> object.
</p>

<hr>
<h2 id='summary.spDS'>Methods for spDS Object</h2><span id='topic+summary.spDS'></span><span id='topic+print.spDS'></span><span id='topic+plot.spDS'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species spatial hierarchiacl distance sampling (<code>spDS</code>) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spDS'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'spDS'
print(x, ...)
## S3 method for class 'spDS'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spDS_+3A_object">object</code>, <code id="summary.spDS_+3A_x">x</code></td>
<td>
<p>object of class <code>spDS</code>.</p>
</td></tr>
<tr><td><code id="summary.spDS_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.spDS_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.spDS_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "alpha", "alpha.star", "sigma.sq.p", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.spDS_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.spDS_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>spDS</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>spDS</code> object.
</p>

<hr>
<h2 id='summary.spNMix'>Methods for spNMix Object</h2><span id='topic+summary.spNMix'></span><span id='topic+print.spNMix'></span><span id='topic+plot.spNMix'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species spatial N-mixture (<code>spNMix</code>) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spNMix'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'spNMix'
print(x, ...)
## S3 method for class 'spNMix'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spNMix_+3A_object">object</code>, <code id="summary.spNMix_+3A_x">x</code></td>
<td>
<p>object of class <code>spNMix</code>.</p>
</td></tr>
<tr><td><code id="summary.spNMix_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.spNMix_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.spNMix_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "alpha", "alpha.star", "sigma.sq.p", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.spNMix_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.spNMix_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>spNMix</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>spNMix</code> object.
</p>

<hr>
<h2 id='summary.svcAbund'>Methods for svcAbund Object</h2><span id='topic+summary.svcAbund'></span><span id='topic+print.svcAbund'></span><span id='topic+plot.svcAbund'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted univariate spatially-varying coefficient GLMMs (<code>svcAbund</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcAbund'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcAbund'
print(x, ...)
## S3 method for class 'svcAbund'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcAbund_+3A_object">object</code>, <code id="summary.svcAbund_+3A_x">x</code></td>
<td>
<p>object of class <code>svcAbund</code>.</p>
</td></tr>
<tr><td><code id="summary.svcAbund_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcAbund_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcAbund_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "tau.sq", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcAbund_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcAbund</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcAbund</code> object.
</p>

<hr>
<h2 id='summary.svcMsAbund'>Methods for svcMsAbund Object</h2><span id='topic+summary.svcMsAbund'></span><span id='topic+print.svcMsAbund'></span><span id='topic+plot.svcMsAbund'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multivariate spatially-varying coefficient abundance GLMMs (<code>svcMsAbund</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcMsAbund'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcMsAbund'
print(x, ...)
## S3 method for class 'svcMsAbund'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcMsAbund_+3A_object">object</code>, <code id="summary.svcMsAbund_+3A_x">x</code></td>
<td>
<p>object of class <code>svcMsAbund</code>.</p>
</td></tr>
<tr><td><code id="summary.svcMsAbund_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcMsAbund_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcMsAbund_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcMsAbund_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.mu", "tau.sq", "beta.comm", 
                     "tau.sq.beta", "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcMsAbund_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcMsAbund</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcMsAbund</code> object.
</p>

<hr>
<h2 id='svcAbund'>Function for Fitting Univariate Spatialy-Varying Coefficient GLMMs</h2><span id='topic+svcAbund'></span>

<h3>Description</h3>

<p>The function <code>svcAbund</code> fits univariate spatially-varying coefficient GLMMs.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcAbund(formula, data, inits, priors, tuning,
         svc.cols = 1, cov.model = 'exponential', NNGP = TRUE, 
         n.neighbors = 15, search.type = 'cb', n.batch,
         batch.length, accept.rate = 0.43, family = 'Gaussian',
         n.omp.threads = 1, verbose = TRUE, n.report = 100, 
         n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
         n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcAbund_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>coords</code>, and <code>z</code> (for 
<code>family = 'zi-Gaussian'</code> only. <code>y</code>
is a vector of the observed count values, where the values 
represent the observed values at each site. <code>covs</code> is a list, matrix, or data
frame of covariates used in the model, where each column (or list element) represents a 
different covariate. <code>coords</code> is a <code class="reqn">J \times 2</code> matrix of the observation coordinates.
Note that <code>svcAbundance</code> assumes coordinates are specified 
in a projected coordinate system. <code>z</code> is used for fitting a zero-inflated 
Gaussian model. It is a vector where each value indicates the binary 
component of the model. In the context of abundance models, this can be 
thought of as the component of the model that indicates whether the species is 
present at each location, and then the supplied values in <code>y</code> are the 
observed abundance values at those locations where <code>z = 1</code>.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, <code>nu</code>, <code>tau.sq</code>, <code>sigma.sq.mu</code>. 
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, <code>sigma.sq.mu</code>
is only specified if there are random effects in <code>formula</code>, and
The value portion of each tag is the parameter's initial value. See <code>priors</code>
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>nu.unif</code>, <code>tau.sq.ig</code>,
<code>sigma.sq.mu.ig</code>. Abundance (<code>beta</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length
one if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances are set to 100. The 
spatial variance parameter, <code>sigma.sq</code>, and the Gaussian 
residual variance parameter, <code>tau.sq</code>, are assumed to follow an 
inverse-Gamma distribution. The spatial decay <code>phi</code> and spatial 
smoothness <code>nu</code>, parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code> 
is passed as a list of length two with the first and second elements corresponding
to the shape and scale parameters of the inverse-Gamma distribution either for
each spatially-varying coefficient, or a single value if assumign the same values
for all spatially-varying coefficients. The hyperparameters of the inverse-Gamma for 
<code>tau.sq</code> is passed as a vector of length two, with the first and second 
elements corresponding to the <em>shape</em> and <em>scale</em>, respectively. 
The hyperparameters of the Uniform are also passed as a list of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively, for each SVC or a single value
if giving the same prior for each SVC. <code>sigma.sq.mu</code>
are the random effect variances for any random effects, and are assumed to follow an 
inverse-Gamma distribution. The hyperparameters of
the inverse-Gamma distribution are passed as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, 
respectively, which are each specified as vectors of length equal to the 
number of random effects or of length one if priors are the same for all
random effect variances.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified), or it can
be specified as a character vector with names corresponding to variable
names in <code>occ.covs</code> (for the intercept, use '(Intercept)'). <code>svc.cols</code>
default argument of 1 results in a univariate spatial GLMM analogous to
<code>spAbund</code> (assuming an intercept is included in the model).</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_tuning">tuning</code></td>
<td>
<p>a single numeric value representing the initial variance of the
adaptive sampler for <code>phi</code> and <code>nu</code>. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only NNGP is supported,
functionality for a full GP may be addded in future package development.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcAbund_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for abundance. Currently, spatially-varying 
coefficient models are available for <code>family = 'Gaussian'</code> and 
<code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples in each chain to discard as burn-in. By default, the first 
10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of MCMC chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcAbund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the residual variance parameter.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the abundance replicate (fitted) values with dimensions 
corresponding to MCMC samples and site.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the expected abundance samples with dimensions corresponding 
to MCMC samples and site.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the spatially-varying coefficients with dimensions corresponding
to MCMC sample, SVC, and site.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the model. 
Only included if random effects are specified in 
<code>formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the likelihood value associated with each site. Used for calculating
WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Abundance ---------------------------
beta &lt;- c(5, 0.5, -0.2, 0.75)
p &lt;- length(beta)
mu.RE &lt;- list()
mu.RE &lt;- list(levels = c(35, 40),
              sigma.sq.mu = c(0.7, 1.5),
              beta.indx = list(1, 1))
# Spatial parameters ------------------
sp &lt;- TRUE
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.4, 4)
phi &lt;- runif(p.svc, 3/1, 3/0.6)
tau.sq &lt;- 2
z &lt;- rbinom(J, 1, 0.5)

# Get all the data
dat &lt;- simAbund(J.x = J.x, J.y = J.y, beta = beta, tau.sq = tau.sq,
                mu.RE = mu.RE, sp = sp, svc.cols = svc.cols, 
                family = 'zi-Gaussian', cov.model = cov.model, 
                sigma.sq = sigma.sq, phi = phi, z = z)
# Get data in format for spAbundance --------------------------------------
y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
coords &lt;- dat$coords

# Package all data into a list
covs &lt;- cbind(X, X.re)
colnames(covs) &lt;- c('int', 'cov.1', 'cov.2', 'cov.3', 'factor.1', 'factor.2')

# Data list bundle
data.list &lt;- list(y = y, covs = covs, coords = coords, z = z)
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 1000),
                   sigma.sq.ig = list(a = 2, b = 1), tau.sq = c(2, 1),
                   sigma.sq.mu.ig = list(a = 2, b = 1),
                   phi.unif = list(a = 3 / 1, b = 3 / 0.1))

# Starting values
inits.list &lt;- list(beta = 0, alpha = 0,
                   sigma.sq = 1, phi = 3 / 0.5, 
                   tau.sq = 2, sigma.sq.mu = 0.5)
# Tuning
tuning.list &lt;- list(phi = 1)

n.batch &lt;- 10
batch.length &lt;- 25
n.burn &lt;- 100
n.thin &lt;- 1

out &lt;- svcAbund(formula = ~ cov.1 + cov.2 + cov.3 + 
                            (1 | factor.1) + (1 | factor.2),
                svc.cols = c(1, 2),
                data = data.list,
                n.batch = n.batch,
                batch.length = batch.length,
                inits = inits.list,
                priors = prior.list,
                accept.rate = 0.43,
                family = 'zi-Gaussian',
                cov.model = "exponential",
                tuning = tuning.list,
                n.omp.threads = 1,
                verbose = TRUE,
                NNGP = TRUE,
                n.neighbors = 5,
                n.report = 25,
                n.burn = n.burn,
                n.thin = n.thin,
                n.chains = 3)
</code></pre>

<hr>
<h2 id='svcMsAbund'>Function for Fitting Spatially-Varying Coefficient Multivariate Abundance GLMMs</h2><span id='topic+svcMsAbund'></span>

<h3>Description</h3>

<p>The function <code>svcMsAbund</code> fits multivariate spatially-varying coefficient GLMs with species correlations (i.e., a spatially-explicit abundace-based joint species distribution model). We use  a spatial factor modeling approach. Models are implemented using a Nearest Neighbor Gaussian Process.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcMsAbund(formula, data, inits, priors, tuning,
           svc.cols = 1, cov.model = 'exponential', NNGP = TRUE, 
           n.neighbors = 15, search.type = 'cb', n.factors,
           n.batch, batch.length, accept.rate = 0.43, family = 'Gaussian',
           n.omp.threads = 1, verbose = TRUE, n.report = 100, 
           n.burn = round(.10 * n.batch * batch.length), n.thin = 1, n.chains = 1,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcMsAbund_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
and slopes are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>coords</code>, and <code>z</code>. 
<code>y</code> is a matrix with sites corresponding to species and columns
corresponding to sites. <code>covs</code> is a list, matrix, or data
frame of covariates used in the model, where each column (or list element) 
represents a different covariate. <code>coords</code> is a 
<code class="reqn">J \times 2</code> matrix of the observation coordinates. Note that 
<code>spAbundance</code> assumes coordinates are specified in a projected coordinate system. 
For zero-inflated Gaussian models, the tag <code>z</code> is used to specify the 
binary component of the model and should have the same dimensions as <code>y</code>.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta.comm</code>, <code>beta</code>, 
<code>tau.sq.beta</code>, <code>sigma.sq.mu</code>, 
<code>phi</code>, <code>lambda</code>, <code>nu</code>, and <code>tau.sq</code>. <code>nu</code> is only specified if 
<code>cov.model = "matern"</code>, <code>tau.sq</code> is only 
specified for Gaussian and zero-inflated Gaussian models,
and <code>sigma.sq.mu</code> is only specified if random effects are included in <code>formula</code>. 
The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>tau.sq.beta.ig</code>, <code>sigma.sq.mu</code>, 
<code>phi.unif</code>, <code>nu.unif</code>, and <code>tau.sq.ig</code>. 
Community-level (<code>beta.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances to 100. Community-level variance parameters 
(<code>tau.sq.beta</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. If desired, the species-specific regression coefficients
(<code>beta</code>) can also be estimated indepdendently by specifying the 
tag <code>independent.betas = TRUE</code>. If specified, this will not estimate species-specific
coefficients as random effects from a common-community-level distribution, and rather
the values of <code>beta.comm</code> and <code>tau.sq.beta</code> will be fixed at the 
specified initial values. This is equivalent to specifying a Gaussian, independent
prior for each of the species-specific effects. 
The spatial factor model fits <code>n.factors</code> independent
spatial processes. The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor and spatially-varying coefficient 
are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length equal to the number of spatial factors
times the number of spatially-varying coefficients corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factors and spatially-varying coefficients. 
The priors for the factor loadings matrix <code>lambda</code> are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>n.sp x n.factors</code> matrix 
for each spatially-varying coefficient are fixed at 0 and the 
diagonal elements are fixed at 1. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).
<code>sigma.sq.mu</code> are the random 
effect variances random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. <code>tau.sq</code> is the 
species-specific residual variance for Gaussian (or zero-inflated Gaussian) models, and it is assigned 
an inverse-Gamma prior. The hyperparameters of the inverse-Gamma are passed as a list 
of length two, with the first and second element corresponding to the shape and 
scale parameters, respectively, which are each specified as vectors of length
equal to the number of species or a single value if priors are the same for all species.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_tuning">tuning</code></td>
<td>
<p>a single numeric value representing the initial variance of the
adaptive sampler for <code>phi</code> and <code>nu</code>. 
See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be 
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an 
integer vector with values indicating the order of covariates specified 
in the model formula (with 1 being the intercept if specified), or it can 
be specified as a character vector with names corresponding to variable 
names in <code>occ.covs</code> (for the intercept, use <code>'(Intercept)'</code>). <code>svc.cols</code>
default argument of 1 results in a spatial factor model analogous to 
<code>sfMsAbund</code> (assuming an intercept is included in the model).</p>
</td></tr> 
<tr><td><code id="svcMsAbund_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. For spatial factor models, only 
<code>NNGP = TRUE</code> is currently supported.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor
model approach for each spatially-varying coefficient. 
Typically, the number of factors is set to be small (e.g., 4-5) relative to the 
total number of species in the community, which will lead to substantial 
decreases in computation time. However, the value can be anywhere 
between 1 and the number of species in the modeled community.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_family">family</code></td>
<td>
<p>the distribution to use for abundance. Currently, spatially-varying 
coefficient models are available for <code>family = 'Gaussian'</code> and 
<code>family = 'zi-Gaussian'</code>.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcMsAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcMsAbund</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level abundance regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the Gaussian residual variance parameter.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the spatial correlation parameters.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent spatial factor loadings for each spatially-varying
coefficient.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the fitted (replicate) values for each species with dimensions corresponding
to MCMC sample, species, site, and replicate.</p>
</td></tr>
<tr><td><code>mu.samples</code></td>
<td>
<p>a three or four-dimensional array of posterior samples for
the expected abundance values for each species with dimensions
corresponding to MCMC samples, species, site, and replicate.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for 
the latent spatial random effects for each spatial factor within each 
spatially-varying coefficient. Dimensions correspond to MCMC sample, 
factor, site, and spatially-varying coefficient.</p>
</td></tr>
<tr><td><code>sigma.sq.mu.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random effects included in the abundance portion
of the model. Only included if random effects are specified in 
<code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the abundance random effects. Only included if random effects 
are specified in <code>abund.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(332)
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- rep(1, J)
n.sp &lt;- 6
# Community-level covariate effects
beta.mean &lt;- c(0, 0.25, 0.6)
p.abund &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.2, 1.2, 0.4)
# Random effects
mu.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = n.sp, ncol = p.abund)
for (i in 1:p.abund) {
  beta[, i] &lt;- rnorm(n.sp, beta.mean[i], sqrt(tau.sq.beta[i]))
}
sp &lt;- TRUE 
svc.cols &lt;- c(1, 2)
n.factors &lt;- 2
q.p.svc &lt;- length(svc.cols) * n.factors
factor.model &lt;- TRUE
phi &lt;- runif(q.p.svc, 3/1, 3 / .4)
tau.sq &lt;- runif(n.sp, 0.1, 5)
cov.model &lt;- 'exponential'
family &lt;- 'Gaussian'

dat &lt;- simMsAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, n.sp = n.sp, beta = beta, 
                  mu.RE = mu.RE, sp = sp, tau.sq = tau.sq, family = family, 
                  factor.model = factor.model, phi = phi, 
                  cov.model = cov.model, n.factors = n.factors, 
                  svc.cols = svc.cols)

y &lt;- dat$y
X &lt;- dat$X
coords &lt;- dat$coords

covs &lt;- data.frame(abund.cov.1 = X[, 2],
                   abund.cov.2 = X[, 3])
data.list &lt;- list(y = y, covs = covs, coords = coords)
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 100),
                   tau.sq.ig = list(a = 2, b = 2), 
		   phi.unif = list(a = 3 / 1, b = 3 / .1), 
                   tau.sq.beta.ig = list(a = .1, b = .1)) 
inits.list &lt;- list(beta.comm = 0, 
                   beta = 0, 
                   tau.sq = 1,
                   tau.sq.beta = 1,
                   phi = 3 / 0.5)
tuning.list &lt;- list(phi = 0.5)

n.batch &lt;- 5
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- svcMsAbund(formula = ~ abund.cov.1 + abund.cov.2,
                  data = data.list, 
                  n.batch = n.batch, 
                  inits = inits.list, 
                  priors = prior.list, 
                  tuning = tuning.list,
                  NNGP = TRUE, 
                  svc.cols = c(1, 2),
                  family = 'Gaussian',
                  cov.model = 'exponential', 
                  n.neighbors = 5, 
                  n.factors = n.factors, 
                  batch.length = batch.length, 
                  n.omp.threads = 1,
                  verbose = TRUE, 
                  n.report = 20, 
                  n.burn = n.burn, 
                  n.thin = n.thin, 
                  n.chains = n.chains)
summary(out)
</code></pre>

<hr>
<h2 id='waicAbund'>Compute Widely Applicable Information Criterion for spAbundance Model Objects</h2><span id='topic+waicAbund'></span>

<h3>Description</h3>

<p>Function for computing the Widely Applicable Information Criterion 
(WAIC; Watanabe 2010) for <code>spAbundance</code> model objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waicAbund(object, N.max, by.species = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waicAbund_+3A_object">object</code></td>
<td>
<p>an object of class <code>NMix</code>, <code>spNMix</code>, <code>msNMix</code>, 
<code>lfMsNMix</code>, <code>sfMsNMix</code>, <code>abund</code>, <code>spAbund</code>, 
<code>msAbund</code>, <code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>DS</code>, <code>spDS</code>, 
<code>msDS</code>, <code>lfMsDS</code>, <code>sfMsDS</code>.</p>
</td></tr>
<tr><td><code id="waicAbund_+3A_n.max">N.max</code></td>
<td>
<p>values indicating the upper limit on the latent abundance 
values when calculating WAIC for N-mixture models or hierarchical distance sampling models. 
For single-species models, this can be a single value or a vector of 
different values for each site. For multi-species models, this can be a 
single value, a vector of values for each species, or a species by site matrix
for a separate value for each species/site combination. 
Defaults to ten plus the largest abundance value for each site/species 
in the posterior samples <code>object$N.samples</code>.</p>
</td></tr>
<tr><td><code id="waicAbund_+3A_by.species">by.species</code></td>
<td>
<p>a logical value indicating whether or not WAIC should be
reported individually for each species (<code>TRUE</code>) or summed across
the entire community (<code>FALSE</code>) for multi-species models. Ignored for 
single species models.</p>
</td></tr>
<tr><td><code id="waicAbund_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effective number of parameters is calculated following the recommendations
of Gelman et al. (2014).
</p>


<h3>Value</h3>

<p>Returns a vector with three elements corresponding to 
estimates of the expected log pointwise predictive density (elpd), the 
effective number of parameters (pD), and the WAIC. If calculating WAIC
for a multi-species model and <code>by.species = TRUE</code>, this will be a 
data frame with rows corresponding to the different species.
</p>


<h3>Note</h3>

<p>When fitting zero-inflated Gaussian models, the WAIC is only calculated for the 
non-zero values. If fitting a first stage model with 
<code>spOccupancy</code> to the binary portion of the 
zero-inflated model, you can use the <code>spOccupancy::waicOcc</code> function to 
calculate WAIC for the binary component. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross
validation and widely applicable information criterion in 
singular learning theory. <em>Journal of Machine Learning Research</em>, 
11:3571-3594.
</p>
<p>Gelman, A., J. B. Carlin, H. S. Stern, D. B. Dunson, A. Vehtari, 
and D. B. Rubin. (2013). Bayesian Data Analysis. 3rd edition. 
CRC Press, Taylor and Francis Group
</p>
<p>Gelman, A., J. Hwang, and A. Vehtari (2014). Understanding predictive
information criteria for Bayesian models. <em>Statistics and Computing</em>, 
24:997-1016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1010)
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0, -1.5, 0.3, -0.8)
p.abund &lt;- length(beta)
mu.RE &lt;- list(levels = c(30), sigma.sq.mu = c(1.3))
kappa &lt;- 0.5
sp &lt;- FALSE 
family &lt;- 'NB'
dat &lt;- simAbund(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, 
                kappa = kappa, mu.RE = mu.RE, sp = sp, family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re

abund.covs &lt;- list(int = X[, , 1], 
                   abund.cov.1 = X[, , 2], 
                   abund.cov.2 = X[, , 3], 
                   abund.cov.3 = X[, , 4],
                   abund.factor.1 = X.re[, , 1])

data.list &lt;- list(y = y, covs = abund.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 100),
                   kappa.unif = c(0.001, 10)) 
# Starting values
inits.list &lt;- list(beta = 0, kappa = kappa)

n.batch &lt;- 5
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- abund(formula = ~ abund.cov.1 + abund.cov.2 + abund.cov.3 + 
                         (1 | abund.factor.1),
             data = data.list, 
             n.batch = n.batch, 
             batch.length = batch.length, 
             inits = inits.list, 
             priors = prior.list, 
             accept.rate = 0.43, 
             n.omp.threads = 1, 
             verbose = TRUE, 
             n.report = 1,
             n.burn = n.burn,
             n.thin = n.thin,
             n.chains = n.chains) 

# Calculate WAIC
waicAbund(out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
