<!DOCTYPE html><html><head><title>Help for package osmextract</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {osmextract}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#osmextract-package'><p>osmextract: Download and Import Open Street Map Data Extracts</p></a></li>
<li><a href='#bbbike_zones'><p>An sf object of geographical zones taken from bbbike.org</p></a></li>
<li><a href='#geofabrik_zones'><p>An sf object of geographical zones taken from geofabrik.de</p></a></li>
<li><a href='#oe_clean'><p>Clean download directory</p></a></li>
<li><a href='#oe_download'><p>Download a file given a url</p></a></li>
<li><a href='#oe_download_directory'><p>Return the download directory used by the package</p></a></li>
<li><a href='#oe_find'><p>Get the path of .pbf and .gpkg files associated with an input OSM extract</p></a></li>
<li><a href='#oe_get'><p>Find, download, translate and read OSM extracts from several providers</p></a></li>
<li><a href='#oe_get_boundary'><p>Get the administrative boundary for a given place</p></a></li>
<li><a href='#oe_get_keys'><p>Return keys and (optionally) values stored in &quot;other_tags&quot; column</p></a></li>
<li><a href='#oe_get_network'><p>Import transport networks used by a specific mode of transport</p></a></li>
<li><a href='#oe_match'><p>Match input place with a url</p></a></li>
<li><a href='#oe_match_pattern'><p>Check patterns in the provider's databases</p></a></li>
<li><a href='#oe_providers'><p>Summary of available providers</p></a></li>
<li><a href='#oe_read'><p>Read a .pbf or .gpkg object from file or url</p></a></li>
<li><a href='#oe_search'><p>Search for a place and return an sf data frame locating it</p></a></li>
<li><a href='#oe_update'><p>Update all the .osm.pbf files saved in a directory</p></a></li>
<li><a href='#oe_vectortranslate'><p>Translate a .osm.pbf file into .gpkg format</p></a></li>
<li><a href='#openstreetmap_fr_zones'><p>An sf object of geographical zones taken from download.openstreetmap.fr</p></a></li>
<li><a href='#read_poly'><p>Read a <code>.poly</code> file.</p></a></li>
<li><a href='#test_zones'><p>An sf object of geographical zones taken from download.openstreetmap.fr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Download and Import Open Street Map Data Extracts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Match, download, convert and import Open Street Map data extracts 
    obtained from several providers. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/osmextract/">https://docs.ropensci.org/osmextract/</a>,
<a href="https://github.com/ropensci/osmextract">https://github.com/ropensci/osmextract</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/osmextract/issues">https://github.com/ropensci/osmextract/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf (&ge; 0.8.1), utils, tools, httr, jsonlite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.2), knitr, rmarkdown, covr, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en_GB</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/build/copy-method:</td>
<td>link</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-30 09:10:23 UTC; user</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrea Gilardi <a href="https://orcid.org/0000-0002-9424-7439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Robin Lovelace <a href="https://orcid.org/0000-0001-5679-6536"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Barry Rowlingson <a href="https://orcid.org/0000-0002-8586-6625"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Salva Fernández [rev] (Salva reviewed the package (v. 0.1) for
    rOpenSci, see
    &lt;https://github.com/ropensci/software-review/issues/395&gt;),
  Nicholas Potter [rev] (Nicholas reviewed the package (v. 0.1) for
    rOpenSci, see
    &lt;https://github.com/ropensci/software-review/issues/395&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrea Gilardi &lt;andrea.gilardi@polimi.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-30 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='osmextract-package'>osmextract: Download and Import Open Street Map Data Extracts</h2><span id='topic+osmextract'></span><span id='topic+osmextract-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Match, download, convert and import Open Street Map data extracts obtained from several providers.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrea Gilardi <a href="mailto:andrea.gilardi@polimi.it">andrea.gilardi@polimi.it</a> (<a href="https://orcid.org/0000-0002-9424-7439">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Robin Lovelace (<a href="https://orcid.org/0000-0001-5679-6536">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Barry Rowlingson (<a href="https://orcid.org/0000-0002-8586-6625">ORCID</a>) [contributor]
</p>
</li>
<li><p> Salva Fernández (Salva reviewed the package (v. 0.1) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/395&gt;) [reviewer]
</p>
</li>
<li><p> Nicholas Potter (Nicholas reviewed the package (v. 0.1) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/395&gt;) [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/osmextract/">https://docs.ropensci.org/osmextract/</a>
</p>
</li>
<li> <p><a href="https://github.com/ropensci/osmextract">https://github.com/ropensci/osmextract</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/osmextract/issues">https://github.com/ropensci/osmextract/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bbbike_zones'>An sf object of geographical zones taken from bbbike.org</h2><span id='topic+bbbike_zones'></span>

<h3>Description</h3>

<p>Start bicycle routing for... everywhere!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbbike_zones
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 237 rows and
6 columns:
</p>

<dl>
<dt>name</dt><dd><p>The, usually English, long-form name of the city.</p>
</dd>
<dt>pbf</dt><dd><p>Link to the latest <code>.osm.pbf</code> file for this region.</p>
</dd>
<dt>pbf_file_size</dt><dd><p>Size of the pbf file in bytes.</p>
</dd>
<dt>id</dt><dd><p>A unique identifier. It contains letters, numbers and potentially
the characters &quot;-&quot; and &quot;/&quot;.</p>
</dd>
<dt>level</dt><dd><p>An integer code always equal to 3 (since the bbbike data
represent non-hierarchical geographical zones). This is used only for
matching operations in case of spatial input. The oe_* functions will
select the geographical area closest to the input place with the highest
&quot;level&quot;. See <a href="#topic+geofabrik_zones">geofabrik_zones</a> for an example of a (proper) hierarchical
structure.</p>
</dd>
<dt>geometry</dt><dd><p>The <code>sfg</code> for that geographical region, rectangular. See
also <code>oe_get_boundary()</code> to extract the proper geographical boundaries.</p>
</dd>
</dl>



<h3>Details</h3>

<p>An <code>sf</code> object containing the URLs, names, and file_size of the OSM extracts
stored at <a href="https://download.bbbike.org/osm/bbbike/">https://download.bbbike.org/osm/bbbike/</a>.
</p>


<h3>Source</h3>

<p><a href="https://download.bbbike.org/osm/">https://download.bbbike.org/osm/</a>
</p>


<h3>See Also</h3>

<p>Other provider's-database: 
<code><a href="#topic+geofabrik_zones">geofabrik_zones</a></code>,
<code><a href="#topic+openstreetmap_fr_zones">openstreetmap_fr_zones</a></code>
</p>

<hr>
<h2 id='geofabrik_zones'>An sf object of geographical zones taken from geofabrik.de</h2><span id='topic+geofabrik_zones'></span>

<h3>Description</h3>

<p>An <code>sf</code> object containing the URLs, names and file-sizes of the OSM
extracts stored at <a href="https://download.geofabrik.de/">https://download.geofabrik.de/</a>. You can read more
details about these data at the following link:
<a href="https://download.geofabrik.de/technical.html">https://download.geofabrik.de/technical.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geofabrik_zones
</code></pre>


<h3>Format</h3>

<p>An sf object with 476 rows and
9 columns:
</p>

<dl>
<dt>id</dt><dd><p>A unique identifier. It contains letters, numbers and potentially
the characters &quot;-&quot; and &quot;/&quot;.</p>
</dd>
<dt>name</dt><dd><p>The, usually English, long-form name of the area.</p>
</dd>
<dt>parent</dt><dd><p>The identifier of the next larger excerpts that contains this
one, if present.</p>
</dd>
<dt>level</dt><dd><p>An integer code between 1 and 4. If level = 1, then the zone
corresponds to one of the continents (Africa, Antarctica, Asia, Australia
and Oceania, Central America, Europe, North America, and South America) or
the Russian Federation. If level = 2, then the zone corresponds to the
continent's subregions (i.e. the countries such as Italy, Great Britain,
Spain, USA, Mexico, Belize, Morocco, Peru and so on). There are also some
exceptions that correspond to the Special Sub Regions (according to the
Geofabrik definition), which are: South Africa (includes Lesotho), Alps,
Britain and Ireland, Germany + Austria + Switzerland, US Midwest, US
Northeast, US Pacific, US South, US West, and all US states. Level = 3L
corresponds to the subregions of each state (or each level 2 zone). For
example, the West Yorkshire, which is a subregion of England, is a level 3
zone. Finally, level = 4 correspond to the subregions of the third level
and it is mainly related to some small areas in Germany. This field is used
only for matching operations in case of spatial input.</p>
</dd>
<dt>iso3166-1_alpha2</dt><dd><p>A character vector of two-letter <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO3166-1 codes</a>. This will be set
on the smallest extract that still fully (or mostly) contains the entity
with that code; e.g. the code &quot;DE&quot; will be given for the Germany extract
and not for Europe even though Europe contains Germany. If an extract
covers several countries and no per-country extracts are available (e.g.
Israel and Palestine), then several ISO codes will be given (such as &quot;PS
IL&quot; for &quot;Palestine and Israel&quot;).</p>
</dd>
<dt>iso3166_2</dt><dd><p>A character vector of usually five-character <a href="https://en.wikipedia.org/wiki/ISO_3166-2">ISO3166-2 codes</a>. The same rules as above
apply. Some entities have both an <em>iso3166-1</em> and <em>iso3166-2</em> code. For
example, the <em>iso3166_2</em> code of each US State is &quot;US - &quot; plus the code of
the state.</p>
</dd>
<dt>pbf</dt><dd><p>Link to the latest <code>.osm.pbf</code> file for this region.</p>
</dd>
<dt>pbf_file_size</dt><dd><p>Size of the <code>.pbf</code> file in bytes.</p>
</dd>
<dt>geometry</dt><dd><p>The <code>sfg</code> for that geographical region. These are not the
country boundaries, but a buffer around countries. Check
<code>oe_get_boundary()</code> to extract the geographical boundaries.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://download.geofabrik.de/">https://download.geofabrik.de/</a>
</p>


<h3>See Also</h3>

<p>Other provider's-database: 
<code><a href="#topic+bbbike_zones">bbbike_zones</a></code>,
<code><a href="#topic+openstreetmap_fr_zones">openstreetmap_fr_zones</a></code>
</p>

<hr>
<h2 id='oe_clean'>Clean download directory</h2><span id='topic+oe_clean'></span>

<h3>Description</h3>

<p>This functions is a wrapper around <code>unlink()</code> that can be used to delete all
<code>.osm.pbf</code> and <code>.gpkg</code> files in a given directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_clean(download_directory = oe_download_directory(), force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_clean_+3A_download_directory">download_directory</code></td>
<td>
<p>The directory where the <code>.osm.pbf</code> and <code>.gpkg</code>
files are saved. Default value is <code>oe_download_directory()</code>.</p>
</td></tr>
<tr><td><code id="oe_clean_+3A_force">force</code></td>
<td>
<p>Internal option. It can be used to skip the checks run at the
beginning of the function and force the removal of all <code>pbf</code>/<code>gpkg</code> files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same as <code>unlink()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Warning: the following removes all files in oe_download_directory()
## Not run: 
oe_clean()
## End(Not run)
</code></pre>

<hr>
<h2 id='oe_download'>Download a file given a url</h2><span id='topic+oe_download'></span>

<h3>Description</h3>

<p>This function is used to download a file given a URL. It focuses on OSM
extracts with <code>.osm.pbf</code> format stored by one of the providers implemented in
the package. The URL is specified through the parameter <code>file_url</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_download(
  file_url,
  provider = NULL,
  file_basename = basename(file_url),
  download_directory = oe_download_directory(),
  file_size = NA,
  force_download = FALSE,
  max_file_size = 5e+08,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_download_+3A_file_url">file_url</code></td>
<td>
<p>A URL pointing to a <code>.osm.pbf</code> file that should be
downloaded.</p>
</td></tr>
<tr><td><code id="oe_download_+3A_provider">provider</code></td>
<td>
<p>Which provider stores the file? If <code>NULL</code> (the default), it
may be inferred from the URL, but it must be specified for non-standard
cases. See details and examples.</p>
</td></tr>
<tr><td><code id="oe_download_+3A_file_basename">file_basename</code></td>
<td>
<p>The basename of the file. The default behaviour is to
auto-generate it from the URL using <code>basename()</code>.</p>
</td></tr>
<tr><td><code id="oe_download_+3A_download_directory">download_directory</code></td>
<td>
<p>Where to download the file containing the OSM data?
By default this is equal to <code><a href="#topic+oe_download_directory">oe_download_directory()</a></code>, which is equal to
<code><a href="base.html#topic+tempdir">tempdir()</a></code> and it changes each time you restart R. You can set a
persistent <code>download_directory</code> by adding the following to your <code>.Renviron</code>
file (e.g. with <code>edit_r_environ</code> function in <code>usethis</code> package):
<code style="white-space: pre;">&#8288;OSMEXT_DOWNLOAD_DIRECTORY=/path/to/osm/data&#8288;</code>.</p>
</td></tr>
<tr><td><code id="oe_download_+3A_file_size">file_size</code></td>
<td>
<p>How big is the file? Optional. <code>NA</code> by default. If it's
bigger than <code>max_file_size</code> and the function is run in interactive mode,
then an interactive menu is displayed, asking for permission for
downloading the file.</p>
</td></tr>
<tr><td><code id="oe_download_+3A_force_download">force_download</code></td>
<td>
<p>Should the <code>.osm.pbf</code> file be updated if it has already
been downloaded? <code>FALSE</code> by default. This parameter is used to update old
<code>.osm.pbf</code> files.</p>
</td></tr>
<tr><td><code id="oe_download_+3A_max_file_size">max_file_size</code></td>
<td>
<p>The maximum file size to download without asking in
interactive mode. Default: <code>5e+8</code>, half a gigabyte.</p>
</td></tr>
<tr><td><code id="oe_download_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the function prints informative messages.
Starting from <code>sf</code> version
<a href="https://r-spatial.github.io/sf/news/index.html#version-0-9-6-2020-09-13">0.9.6</a>,
if <code>quiet</code> is equal to <code>FALSE</code>, then vectortranslate operations will
display a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs several checks before actually downloading a new
file to avoid overloading the OSM providers. The first step is the
definition of the file's path associated to the input <code>file_url</code>. The path
is created by pasting together the <code>download_directory</code>, the name of chosen
provider (which may be inferred from the URL) and the <code>basename()</code> of the
URL. For example, if <code>file_url</code> is equal to
<code>"https://download.geofabrik.de/europe/italy-latest.osm.pbf"</code>, and
<code>download_directory = "/tmp"</code>, then the path is built as
<code>"/tmp/geofabrik_italy-latest.osm.pbf"</code>. Thereafter, the function checks
the existence of that file and, if it founds it, then it returns the path.
The parameter <code>force_download</code> is used to modify this behaviour. If there
is no file associated with the new path, then the function downloads a new
file using <code><a href="utils.html#topic+download.file">download.file()</a></code> with <code>mode = "wb"</code>, and, again, it returns the
path.
</p>


<h3>Value</h3>

<p>A character string representing the file's path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(its_match = oe_match("ITS Leeds", quiet = TRUE))

## Not run: 
oe_download(
  file_url = its_match$url,
  file_size = its_match$file_size,
  provider = "test",
  download_directory = tempdir()
)
iow_url = oe_match("Isle of Wight")
oe_download(
  file_url = iow_url$url,
  file_size = iow_url$file_size,
  download_directory = tempdir()
)
Sucre_url = oe_match("Sucre", provider = "bbbike")
oe_download(
  file_url = Sucre_url$url,
  file_size = Sucre_url$file_size,
  download_directory = tempdir()
)
## End(Not run)
</code></pre>

<hr>
<h2 id='oe_download_directory'>Return the download directory used by the package</h2><span id='topic+oe_download_directory'></span>

<h3>Description</h3>

<p>By default, the download directory is equal to <code>tempdir()</code>. You can set a
persistent download directory by adding the following command to your
<code>.Renviron</code> file (e.g. with <code>edit_r_environ</code> function in <code>usethis</code> package):
<code style="white-space: pre;">&#8288;OSMEXT_DOWNLOAD_DIRECTORY=/path/to/osm/data&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_download_directory()
</code></pre>


<h3>Value</h3>

<p>A character vector representing the path for the download directory
used by the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oe_download_directory()
</code></pre>

<hr>
<h2 id='oe_find'>Get the path of .pbf and .gpkg files associated with an input OSM extract</h2><span id='topic+oe_find'></span>

<h3>Description</h3>

<p>This function takes a <code>place</code> name and returns the path of <code>.pbf</code>/<code>.gpkg</code>
files associated with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_find(
  place,
  provider = "geofabrik",
  download_directory = oe_download_directory(),
  download_if_missing = FALSE,
  return_pbf = TRUE,
  return_gpkg = TRUE,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_find_+3A_place">place</code></td>
<td>
<p>Description of the geographical area that should be matched with
a <code>.osm.pbf</code> file. Can be either a length-1 character vector, an
<code>sf</code>/<code>sfc</code>/<code>bbox</code> object, or a numeric vector of coordinates with length 2.
In the last case, it is assumed that the EPSG code is 4326 specified as
c(LON, LAT), while you can use any CRS with <code>sf</code>/<code>sfc</code>/<code>bbox</code> objects. See
Details and Examples in <code><a href="#topic+oe_match">oe_match()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_find_+3A_provider">provider</code></td>
<td>
<p>Which provider should be used to download the data? Available
providers can be found with the following command: <code><a href="#topic+oe_providers">oe_providers()</a></code>. For
<code><a href="#topic+oe_get">oe_get()</a></code> and <code><a href="#topic+oe_match">oe_match()</a></code>, if <code>place</code> is equal to <code style="white-space: pre;">&#8288;ITS Leeds&#8288;</code>, then
<code>provider</code> is set equal to <code>test</code>. This is just for simple examples and
internal tests.</p>
</td></tr>
<tr><td><code id="oe_find_+3A_download_directory">download_directory</code></td>
<td>
<p>Directory where the files downloaded by osmextract
are stored. By default it is equal to <code><a href="#topic+oe_download_directory">oe_download_directory()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_find_+3A_download_if_missing">download_if_missing</code></td>
<td>
<p>Attempt to download the file if it cannot be
found? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="oe_find_+3A_return_pbf">return_pbf</code></td>
<td>
<p>Logical of length 1. If <code>TRUE</code>, the function returns the
path of the pbf file that matches the input <code>place</code>.</p>
</td></tr>
<tr><td><code id="oe_find_+3A_return_gpkg">return_gpkg</code></td>
<td>
<p>Logical of length 1. If <code>TRUE</code>, the function returns the
path of the gpkg file that matches the input <code>place</code>.</p>
</td></tr>
<tr><td><code id="oe_find_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the function prints informative messages.
Starting from <code>sf</code> version
<a href="https://r-spatial.github.io/sf/news/index.html#version-0-9-6-2020-09-13">0.9.6</a>,
if <code>quiet</code> is equal to <code>FALSE</code>, then vectortranslate operations will
display a progress bar.</p>
</td></tr>
<tr><td><code id="oe_find_+3A_...">...</code></td>
<td>
<p>Extra arguments that are passed to <code><a href="#topic+oe_match">oe_match()</a></code> and <code><a href="#topic+oe_get">oe_get()</a></code>.
Please note that you cannot modify the argument <code>download_only</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matching between the existing files (saved in the directory
specified by <code>download_directory</code> parameter) and the input <code>place</code> is
performed using <code>list.files()</code>, setting the <code>pattern</code> argument equal to the
basename of the URL associated to the input <code>place</code>. For example, if you
specify <code>place = "Isle of Wight"</code>, then the input is matched (via
<code><a href="#topic+oe_match">oe_match()</a></code>) with the URL of Isle of Wight's <code>.osm.pbf</code> file, and the
files are selected using a pattern equal to the basename of that URL.
</p>
<p>If there is no file in the <code>download_directory</code> that can be matched with the
basename of the URL and <code>download_if_missing</code> parameter is equal to <code>TRUE</code>, then the
function tries to download and read a new file from the chosen
provider (<code>geofabrik</code> is the default provider). If <code>download_if_missing</code>
parameter is equal to <code>FALSE</code> (default value), then the function stops with
an error.
</p>
<p>By default, this function returns the path of <code>.pbf</code> and <code>.gpkg</code> files
associated with the input place (if any). You can exclude one of the two
formats setting the arguments <code>return_pbf</code> or <code>return_gpkg</code> to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A character vector of length one (or two) representing the path(s) of
the <code>.pbf</code>/<code>.gpkg</code> files associated with the input <code>place</code>. The files are
sorted in alphabetical order which implies that if both formats are present
in the <code>download_directory</code>, then the <code>.gpkg</code> file is returned first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the ITS file to tempdir() to make sure that the examples do not
# require internet connection. You can skip the next 4 lines (and start
# directly with oe_get_keys) when running the examples locally.

res = file.copy(
  from = system.file("its-example.osm.pbf", package = "osmextract"),
  to = file.path(tempdir(), "test_its-example.osm.pbf"),
  overwrite = TRUE
)
res = oe_get("ITS Leeds", quiet = TRUE, download_directory = tempdir())
oe_find("ITS Leeds", provider = "test", download_directory = tempdir())
oe_find(
  "ITS Leeds", provider = "test",
  download_directory = tempdir(), return_gpkg = FALSE
)

## Not run: 
oe_find("Isle of Wight", download_directory = tempdir())
oe_find("Malta", download_if_missing = TRUE, download_directory = tempdir())
oe_find(
  "Leeds",
  provider = "bbbike",
  download_if_missing = TRUE,
  download_directory = tempdir(),
  return_pbf = FALSE
)
## End(Not run)

# Remove .pbf and .gpkg files in tempdir
oe_clean(tempdir())
</code></pre>

<hr>
<h2 id='oe_get'>Find, download, translate and read OSM extracts from several providers</h2><span id='topic+oe_get'></span>

<h3>Description</h3>

<p>This function is used to find, download, translate and read OSM extracts
obtained from several providers. It is a wrapper around <code><a href="#topic+oe_match">oe_match()</a></code> and
<code><a href="#topic+oe_read">oe_read()</a></code>. Check the introductory vignette, the examples and the help pages
of the wrapped functions to understand the details behind all parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_get(
  place,
  layer = "lines",
  ...,
  provider = "geofabrik",
  match_by = "name",
  max_string_dist = 1,
  level = NULL,
  download_directory = oe_download_directory(),
  force_download = FALSE,
  max_file_size = 5e+08,
  vectortranslate_options = NULL,
  osmconf_ini = NULL,
  extra_tags = NULL,
  force_vectortranslate = FALSE,
  boundary = NULL,
  boundary_type = c("spat", "clipsrc"),
  download_only = FALSE,
  skip_vectortranslate = FALSE,
  never_skip_vectortranslate = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_get_+3A_place">place</code></td>
<td>
<p>Description of the geographical area that should be matched with
a <code>.osm.pbf</code> file. Can be either a length-1 character vector, an
<code>sf</code>/<code>sfc</code>/<code>bbox</code> object, or a numeric vector of coordinates with length 2.
In the last case, it is assumed that the EPSG code is 4326 specified as
c(LON, LAT), while you can use any CRS with <code>sf</code>/<code>sfc</code>/<code>bbox</code> objects. See
Details and Examples in <code><a href="#topic+oe_match">oe_match()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_layer">layer</code></td>
<td>
<p>Which <code>layer</code> should be read in? Typically <code>points</code>, <code>lines</code>
(the default), <code>multilinestrings</code>, <code>multipolygons</code> or <code>other_relations</code>. If
you specify an ad-hoc query using the argument <code>query</code> (see introductory
vignette and examples), then <code>oe_get()</code> and <code>oe_read()</code> will read the layer
specified in the query and ignore <code>layer</code>. See also
<a href="https://github.com/ropensci/osmextract/issues/122">#122</a>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_...">...</code></td>
<td>
<p>(Named) arguments that will be passed to <code><a href="sf.html#topic+st_read">sf::st_read()</a></code>, like
<code>query</code>, <code>wkt_filter</code> or <code>stringsAsFactors</code>.  Check the introductory
vignette to understand how to create your own (SQL-like) queries.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_provider">provider</code></td>
<td>
<p>Which provider should be used to download the data? Available
providers can be found with the following command: <code><a href="#topic+oe_providers">oe_providers()</a></code>. For
<code><a href="#topic+oe_get">oe_get()</a></code> and <code><a href="#topic+oe_match">oe_match()</a></code>, if <code>place</code> is equal to <code style="white-space: pre;">&#8288;ITS Leeds&#8288;</code>, then
<code>provider</code> is set equal to <code>test</code>. This is just for simple examples and
internal tests.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_match_by">match_by</code></td>
<td>
<p>Which column of the provider's database should be used for
matching the input <code>place</code> with a <code>.osm.pbf</code> file? The default is <code>"name"</code>.
Check Details and Examples in <code><a href="#topic+oe_match">oe_match()</a></code> to understand how this parameter
works. Ignored if <code>place</code> is not a character vector since the matching is
performed through a spatial operation.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_max_string_dist">max_string_dist</code></td>
<td>
<p>Numerical value greater or equal than 0. What is the
maximum distance in fuzzy matching (i.e. Approximate String Distance, see
<code><a href="utils.html#topic+adist">adist()</a></code>) between input <code>place</code> and <code>match_by</code> column to tolerate before
testing alternative providers or looking for geographical matching with
Nominatim API? This parameter is set equal to 0 if <code>match_by</code> is equal to
<code>iso3166_1_alpha2</code> or <code>iso3166_2</code>. Check Details and Examples in
<code><a href="#topic+oe_match">oe_match()</a></code> to understand why this parameter is important. Ignored if
<code>place</code> is not a character vector since the matching is performed through a
spatial operation.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_level">level</code></td>
<td>
<p>An integer representing the desired hierarchical level in case
of spatial matching. For the <code>geofabrik</code> provider, for example, <code>1</code>
corresponds with continent-level datasets, <code>2</code> for countries, <code>3</code>
corresponds to regions and <code>4</code> to subregions. Hence, we could approximately
say that smaller administrative units correspond to bigger levels. If
<code>NULL</code>, the default, the <code style="white-space: pre;">&#8288;oe_*&#8288;</code> functions will select the highest available
level. See Details and Examples in <code>oe_match()</code>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_download_directory">download_directory</code></td>
<td>
<p>Where to download the file containing the OSM data?
By default this is equal to <code><a href="#topic+oe_download_directory">oe_download_directory()</a></code>, which is equal to
<code><a href="base.html#topic+tempdir">tempdir()</a></code> and it changes each time you restart R. You can set a
persistent <code>download_directory</code> by adding the following to your <code>.Renviron</code>
file (e.g. with <code>edit_r_environ</code> function in <code>usethis</code> package):
<code style="white-space: pre;">&#8288;OSMEXT_DOWNLOAD_DIRECTORY=/path/to/osm/data&#8288;</code>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_force_download">force_download</code></td>
<td>
<p>Should the <code>.osm.pbf</code> file be updated if it has already
been downloaded? <code>FALSE</code> by default. This parameter is used to update old
<code>.osm.pbf</code> files.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_max_file_size">max_file_size</code></td>
<td>
<p>The maximum file size to download without asking in
interactive mode. Default: <code>5e+8</code>, half a gigabyte.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_vectortranslate_options">vectortranslate_options</code></td>
<td>
<p>Options passed to the <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>
argument <code>options</code>. Set by default. Check details in the introductory
vignette and the help page of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_osmconf_ini">osmconf_ini</code></td>
<td>
<p>The configuration file. See documentation at
<a href="https://gdal.org/drivers/vector/osm.html">gdal.org</a>. Check details in the
introductory vignette and the help page of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>. Set by
default.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_extra_tags">extra_tags</code></td>
<td>
<p>Which additional columns, corresponding to OSM tags, should
be in the resulting dataset? <code>NULL</code> by default. Check the introductory
vignette and the help pages of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code> and <code><a href="#topic+oe_get_keys">oe_get_keys()</a></code>.
Ignored when <code>osmconf_ini</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_force_vectortranslate">force_vectortranslate</code></td>
<td>
<p>Boolean. Force the original <code>.pbf</code> file to be
translated into a <code>.gpkg</code> file, even if a <code>.gpkg</code> with the same name
already exists? <code>FALSE</code> by default. If tags in <code>extra_tags</code> match data in
previously translated <code>.gpkg</code> files no translation occurs (see
<a href="https://github.com/ropensci/osmextract/issues/173">#173</a> for details).
Check the introductory vignette and the help page of
<code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_boundary">boundary</code></td>
<td>
<p>An <code>sf</code>/<code>sfc</code>/<code>bbox</code> object that will be used to create a
spatial filter during the vectortranslate operations. The type of filter
can be chosen using the argument <code>boundary_type</code>.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_boundary_type">boundary_type</code></td>
<td>
<p>A character vector of length 1 specifying the type of
spatial filter. The <code>spat</code> filter selects only those features that
intersect a given area, while <code>clipsrc</code> also clips the geometries. Check
the examples and also <a href="https://gdal.org/programs/ogr2ogr.html">here</a> for
more details.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_download_only">download_only</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, then the function only returns the
path where the matched file is stored, instead of reading it. <code>FALSE</code> by
default.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_skip_vectortranslate">skip_vectortranslate</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, then the function skips all
vectortranslate operations and it reads (or simply returns the path) of the
<code>.osm.pbf</code> file. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="oe_get_+3A_never_skip_vectortranslate">never_skip_vectortranslate</code></td>
<td>
<p>Boolean. This is used in case the user
passed its own <code>.ini</code> file or vectortranslate options (since, in those
case, it's too difficult to determine if an existing <code>.gpkg</code> file was
generated following the same options.)</p>
</td></tr>
<tr><td><code id="oe_get_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the function prints informative messages.
Starting from <code>sf</code> version
<a href="https://r-spatial.github.io/sf/news/index.html#version-0-9-6-2020-09-13">0.9.6</a>,
if <code>quiet</code> is equal to <code>FALSE</code>, then vectortranslate operations will
display a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm that we use for importing an OSM extract data into R
is divided into 4 steps: 1) match the input <code>place</code> with the url of a
<code>.pbf</code> file; 2) download the <code>.pbf</code> file; 3) convert it into <code>.gpkg</code> format
and 4) read-in the <code>.gpkg</code> file. The function <code>oe_match()</code> is used to
perform the first operation and the function <code>oe_read()</code> (which is a
wrapper around <code>oe_download()</code>, <code>oe_vectortranslate()</code> and <code>sf::st_read()</code>)
performs the other three operations.
</p>


<h3>Value</h3>

<p>An <code>sf</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oe_match">oe_match()</a></code>, <code><a href="#topic+oe_download">oe_download()</a></code>, <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>, and
<code><a href="#topic+oe_read">oe_read()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy ITS file to tempdir so that the examples do not require internet
# connection. You can skip the next 4 lines when running the examples
# locally.

its_pbf = file.path(tempdir(), "test_its-example.osm.pbf")
file.copy(
  from = system.file("its-example.osm.pbf", package = "osmextract"),
  to = its_pbf,
  overwrite = TRUE
)

# Match, download (not really) and convert OSM extracts associated to a simple test.
its = oe_get("ITS Leeds", download_directory = tempdir())
class(its)
unique(sf::st_geometry_type(its))

# Get another layer from ITS Leeds extract
its_points = oe_get("ITS Leeds", layer = "points", download_directory = tempdir())
unique(sf::st_geometry_type(its_points))

# Get the .osm.pbf and .gpkg files paths
oe_get(
  "ITS Leeds", download_only = TRUE, quiet = TRUE,
  download_directory = tempdir()
)
oe_get(
  "ITS Leeds", download_only = TRUE, skip_vectortranslate = TRUE,
  quiet = TRUE, download_directory = tempdir()
)
# See also ?oe_find()

# Add additional tags
its_with_oneway = oe_get(
  "ITS Leeds", extra_tags = "oneway",
  download_directory = tempdir()
)
names(its_with_oneway)
table(its_with_oneway$oneway, useNA = "ifany")

# Use the query argument to get only oneway streets:
q = "SELECT * FROM 'lines' WHERE oneway == 'yes'"
its_oneway = oe_get("ITS Leeds", query = q, download_directory = tempdir())
its_oneway[, c(1, 3, 9)]

# Apply a spatial filter during the vectortranslate operations
its_poly = sf::st_sfc(
  sf::st_polygon(
    list(rbind(
      c(-1.55577, 53.80850),
      c(-1.55787, 53.80926),
      c(-1.56096, 53.80891),
      c(-1.56096, 53.80736),
      c(-1.55675, 53.80658),
      c(-1.55495, 53.80749),
      c(-1.55577, 53.80850)
    ))
  ),
  crs = 4326
)
its_spat = oe_get("ITS Leeds", boundary = its_poly, download_directory = tempdir())
its_clipped = oe_get(
  "ITS Leeds", boundary = its_poly, boundary_type = "clipsrc",
  quiet = TRUE, download_directory = tempdir()
)

plot(sf::st_geometry(its), reset = FALSE, col = "lightgrey")
plot(sf::st_boundary(its_poly), col = "black", add = TRUE)
plot(sf::st_boundary(sf::st_as_sfc(sf::st_bbox(its_poly))), col = "black", add = TRUE)
plot(sf::st_geometry(its_spat), add = TRUE, col = "darkred")
plot(sf::st_geometry(its_clipped), add = TRUE, col = "orange")

# More complex examples
## Not run: 
west_yorkshire = oe_get("West Yorkshire")
# If you run it again, the function will not download the file
# or convert it again
west_yorkshire = oe_get("West Yorkshire")
# Match with place name
oe_get("Milan") # Warning: the .pbf file is 400MB
oe_get("Vatican City") # Check all providers
oe_get("Zurich") # Use Nominatim API for geolocating places

# Match with coordinates (any EPSG)
milan_duomo = sf::st_sfc(sf::st_point(c(1514924, 5034552)), crs = 3003)
oe_get(milan_duomo, quiet = FALSE) # Warning: the .pbf file is 400MB
# Match with numeric coordinates (EPSG = 4326)
oe_match(c(9.1916, 45.4650), quiet = FALSE)

# Check also alternative providers
baku = oe_get(place = "Baku")

# Other examples:
oe_get("RU", match_by = "iso3166_1_alpha2", quiet = FALSE)
# The following example mimics read_sf
oe_get("Andora", stringsAsFactors = FALSE, quiet = TRUE, as_tibble = TRUE)
## End(Not run)

# Remove .pbf and .gpkg files in tempdir
oe_clean(tempdir())
</code></pre>

<hr>
<h2 id='oe_get_boundary'>Get the administrative boundary for a given place</h2><span id='topic+oe_get_boundary'></span>

<h3>Description</h3>

<p>This function can be used to obtain polygon/multipolygon objects representing
an administrative boundary. The objects are extracted from the
<code>multipolygons</code> layer of a given OSM extract.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_get_boundary(place, name = place, exact = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_get_boundary_+3A_place">place</code></td>
<td>
<p>Description of the geographical area that should be matched with
a <code>.osm.pbf</code> file. Can be either a length-1 character vector, an
<code>sf</code>/<code>sfc</code>/<code>bbox</code> object, or a numeric vector of coordinates with length 2.
In the last case, it is assumed that the EPSG code is 4326 specified as
c(LON, LAT), while you can use any CRS with <code>sf</code>/<code>sfc</code>/<code>bbox</code> objects. See
Details and Examples in <code><a href="#topic+oe_match">oe_match()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_get_boundary_+3A_name">name</code></td>
<td>
<p>A character vector of length 1 that describes the relevant area.
By default, this is equal to <code>place</code>, but this parameter can be tuned to
obtain more granular results starting from the same OSM extract. See
examples. It must be always set when the <code>place</code> argument is specified
using numeric or spatial objects.</p>
</td></tr>
<tr><td><code id="oe_get_boundary_+3A_exact">exact</code></td>
<td>
<p>Boolean of length 1. If <code>TRUE</code>, then the function returns only
those features where the field <code>name</code> is exactly equal to <code>name</code>. If
<code>FALSE</code>, it performs a (case-sensitive) pattern matching.</p>
</td></tr>
<tr><td><code id="oe_get_boundary_+3A_...">...</code></td>
<td>
<p>Further arguments (e.g. <code>quiet</code> or <code>force_vectortranslate</code>) that
are passed to <code>oe_get()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function may return an empty result when the corresponding GPKG file
already exists and contains partial results. In that case, you can try
running the function setting <code>never_skip_vectortranslate = TRUE</code>.
</p>


<h3>Value</h3>

<p>An <code>sf</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
my_cols = sf.colors(5, categorical = TRUE)
gabon = oe_get_boundary("Gabon", quiet = TRUE) # country
libreville = oe_get_boundary("Gabon", "Libreville", quiet = TRUE) # capital

opar = par(mar = rep(0, 4))
plot(st_geometry(st_boundary(gabon)), reset = FALSE, col = "grey")
plot(st_geometry(libreville), add = TRUE, col = my_cols[1])

# Exact match
komo = oe_get_boundary("Gabon", "Komo", quiet = TRUE)
# Pattern matching
komo_pt = oe_get_boundary("Gabon", "Komo", exact = FALSE, quiet = TRUE)
plot(st_geometry(komo), add = TRUE, col = my_cols[2])
plot(st_geometry(komo_pt), add = TRUE, col = my_cols[3:5])
par(opar)

# Get all boundaries
(oe_get_boundary("Gabon", name = "%", exact = FALSE, quiet = TRUE)[, 1:2])

# If the basic approach doesn't work, i.e.
oe_get_boundary("Leeds")

# try to consider larger regions, i.e.
oe_get_boundary("West Yorkshire", "Leeds")

## End(Not run)
</code></pre>

<hr>
<h2 id='oe_get_keys'>Return keys and (optionally) values stored in &quot;other_tags&quot; column</h2><span id='topic+oe_get_keys'></span><span id='topic+oe_get_keys.default'></span><span id='topic+oe_get_keys.character'></span><span id='topic+oe_get_keys.sf'></span><span id='topic+print.oe_key_values_list'></span>

<h3>Description</h3>

<p>This function returns the OSM keys and (optionally) the values stored in the
<code>other_tags</code> field. See Details. In both cases, the keys are sorted according
to the number of occurrences, which means that the most common keys are
stored first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_get_keys(
  zone,
  layer = "lines",
  values = FALSE,
  which_keys = NULL,
  download_directory = oe_download_directory()
)

## Default S3 method:
oe_get_keys(
  zone,
  layer = "lines",
  values = FALSE,
  which_keys = NULL,
  download_directory = oe_download_directory()
)

## S3 method for class 'character'
oe_get_keys(
  zone,
  layer = "lines",
  values = FALSE,
  which_keys = NULL,
  download_directory = oe_download_directory()
)

## S3 method for class 'sf'
oe_get_keys(
  zone,
  layer = "lines",
  values = FALSE,
  which_keys = NULL,
  download_directory = oe_download_directory()
)

## S3 method for class 'oe_key_values_list'
print(x, n = getOption("oe_max_print_keys", 10L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_get_keys_+3A_zone">zone</code></td>
<td>
<p>An <code>sf</code> object with an <code>other_tags</code> field or a character vector
(of length 1) that can be linked to or pointing to a <code>.osm.pbf</code> or <code>.gpkg</code>
file with an <code>other_tags</code> field. Character vectors are linked to <code>.osm.pbf</code>
files using <code>oe_find()</code>.</p>
</td></tr>
<tr><td><code id="oe_get_keys_+3A_layer">layer</code></td>
<td>
<p>Which <code>layer</code> should be read in? Typically <code>points</code>, <code>lines</code>
(the default), <code>multilinestrings</code>, <code>multipolygons</code> or <code>other_relations</code>. If
you specify an ad-hoc query using the argument <code>query</code> (see introductory
vignette and examples), then <code>oe_get()</code> and <code>oe_read()</code> will read the layer
specified in the query and ignore <code>layer</code>. See also
<a href="https://github.com/ropensci/osmextract/issues/122">#122</a>.</p>
</td></tr>
<tr><td><code id="oe_get_keys_+3A_values">values</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then function returns the keys and the
corresponding values, otherwise only the keys. Defaults to <code>FALSE. </code></p>
</td></tr>
<tr><td><code id="oe_get_keys_+3A_which_keys">which_keys</code></td>
<td>
<p>Character vector used to subset only some keys and
corresponding values. Ignored if <code>values</code> is <code>FALSE</code>. See examples.</p>
</td></tr>
<tr><td><code id="oe_get_keys_+3A_download_directory">download_directory</code></td>
<td>
<p>Path of the directory that stores the <code>.osm.pbf</code>
files. Only relevant when <code>zone</code> is as a character vector that must be
matched to a file via <code>oe_find()</code>. Ignored unless <code>zone</code> is a character
vector.</p>
</td></tr>
<tr><td><code id="oe_get_keys_+3A_x">x</code></td>
<td>
<p>object of class <code>oe_key_values_list</code></p>
</td></tr>
<tr><td><code id="oe_get_keys_+3A_n">n</code></td>
<td>
<p>Maximum number of keys (and corresponding values) to print; can be
set globally by <code>options(oe_max_print_keys=...)</code>. Default value is 10.</p>
</td></tr>
<tr><td><code id="oe_get_keys_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OSM data are typically documented using several
<a href="https://wiki.openstreetmap.org/wiki/Tags"><code>tags</code></a>, i.e. pairs of two
items, namely a <code>key</code> and a <code>value</code>. The conversion between <code>.osm.pbf</code> and
<code>.gpkg</code> formats is governed by a <code>CONFIG</code> file that lists which tags must
be explicitly added to the <code>.gpkg</code> file. All the other keys are
automatically stored using an <code>other_tags</code> field with a syntax compatible
with the PostgreSQL HSTORE type. See
<a href="https://gdal.org/drivers/vector/osm.html#driver-capabilities">here</a> for
more details.
</p>
<p>When the argument <code>values</code> is <code>TRUE</code>, then the function returns a named
list of class <code>oe_key_values_list</code> that, for each key, summarises the
corresponding values. The key-value pairs are stored using the following
format: <code style="white-space: pre;">&#8288;list(key1 = c("value1", "value1", "value2", ...), key2 = c("value1", ...) ...)&#8288;</code>. We decided to implement an ad-hoc method for
printing objects of class <code>oe_key_values_list</code> using the following
structure:</p>
<pre>key1 = {#value1 = n1; #value2 = n2; #value3 = n3,
  ...} key2 = {#value1 = n1; #value2 = n2; ...} key3 = {#value1 = n1} ...</pre>
<p>where <code>n1</code> denotes the number of times that value1 is repeated, <code>n2</code>
denotes the number of times that value2 is repeated and so on. Also the
values are listed according to the number of occurrences in decreasing
order. By default, the function prints only the ten most common keys, but
the number can be adjusted using the option <code>oe_max_print_keys</code>.
</p>
<p>Finally, the <code>hstore_get_value()</code> function can be used inside the <code>query</code>
argument in <code>oe_get()</code> to extract one particular tag from an existing file.
Check the introductory vignette and see examples.
</p>


<h3>Value</h3>

<p>If the argument <code>values</code> is <code>FALSE</code> (the default), then the function
returns a character vector with the names of all keys stored in the
<code>other_tags</code> field. If <code>values</code> is <code>TRUE</code>, then the function returns named
list which stores all keys and the corresponding values. In the latter
case, the returned object has class <code>oe_key_values_list</code> and we defined an
ad-hoc printing method. See Details.
</p>


<h3>See Also</h3>

<p><code>oe_vectortranslate()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the ITS file to tempdir() to make sure that the examples do not
# require internet connection. You can skip the next 4 lines (and start
# directly with oe_get_keys) when running the examples locally.

its_pbf = file.path(tempdir(), "test_its-example.osm.pbf")
file.copy(
  from = system.file("its-example.osm.pbf", package = "osmextract"),
  to = its_pbf,
  overwrite = TRUE
)

# Get keys
oe_get_keys("ITS Leeds", download_directory = tempdir())

# Get keys and values
oe_get_keys("ITS Leeds", values = TRUE, download_directory = tempdir())

# Subset some keys
oe_get_keys(
  "ITS Leeds", values = TRUE, which_keys = c("surface", "lanes"),
  download_directory = tempdir()
)

# Print all (non-NA) values for a given set of keys
res = oe_get_keys("ITS Leeds", values = TRUE, download_directory = tempdir())
res["surface"]

# Get keys from an existing sf object
its = oe_get("ITS Leeds", download_directory = tempdir())
oe_get_keys(its, values = TRUE)

# Get keys from a character vector pointing to a file (might be faster than
# reading the complete file and then filter it)
its_path = oe_get(
  "ITS Leeds", download_only = TRUE,
  download_directory = tempdir(), quiet = TRUE
)
oe_get_keys(its_path, values = TRUE)

# Add a key to an existing .gpkg file without repeating the
# vectortranslate operations
its = oe_get("ITS Leeds", download_directory = tempdir())
colnames(its)
its_extra = oe_read(
  its_path,
  query = "SELECT *, hstore_get_value(other_tags, 'oneway') AS oneway FROM lines",
  quiet = TRUE
)
colnames(its_extra)

# The following fails since there is no points layer in the .gpkg file
## Not run: 
oe_get_keys(its_path, layer = "points")
## End(Not run)

# Add layer and read keys
its_path = oe_get(
  "ITS Leeds", layer = "points", download_only = TRUE,
  download_directory = tempdir(), quiet = TRUE
)
oe_get_keys(its_path, layer = "points")

# Remove .pbf and .gpkg files in tempdir
rm(its_pbf, res, its_path, its, its_extra)
oe_clean(tempdir())
</code></pre>

<hr>
<h2 id='oe_get_network'>Import transport networks used by a specific mode of transport</h2><span id='topic+oe_get_network'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code>oe_get()</code> and can be used to import a road
network given a <code>place</code> and a mode of transport. Check the Details for a
precise description of the procedures used to filter the OSM ways according
to each each mode of transport.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_get_network(place, mode = c("cycling", "driving", "walking"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_get_network_+3A_place">place</code></td>
<td>
<p>Description of the geographical area that should be matched with
a <code>.osm.pbf</code> file. Can be either a length-1 character vector, an
<code>sf</code>/<code>sfc</code>/<code>bbox</code> object, or a numeric vector of coordinates with length 2.
In the last case, it is assumed that the EPSG code is 4326 specified as
c(LON, LAT), while you can use any CRS with <code>sf</code>/<code>sfc</code>/<code>bbox</code> objects. See
Details and Examples in <code><a href="#topic+oe_match">oe_match()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_get_network_+3A_mode">mode</code></td>
<td>
<p>A character string of length one denoting the desired mode of
transport. Can be abbreviated. Currently <code>cycling</code> (the default), <code>driving</code>
and <code>walking</code> are supported.</p>
</td></tr>
<tr><td><code id="oe_get_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>oe_get()</code> such as <code>boundary</code> or
<code>force_download</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of usable transport network was taken from the Python
packages
<a href="https://github.com/gboeing/osmnx/blob/main/osmnx/_downloader.py">osmnx</a> and
<a href="https://pyrosm.readthedocs.io/en/latest/">pyrosm</a> and several other
documents found online, i.e.
<a href="https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Access_restrictions">https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Access_restrictions</a>,
<a href="https://wiki.openstreetmap.org/wiki/Key:access">https://wiki.openstreetmap.org/wiki/Key:access</a>. See also the discussion
in <a href="https://github.com/ropensci/osmextract/issues/153">https://github.com/ropensci/osmextract/issues/153</a>.
</p>
<p>The <code>cycling</code> mode of transport (i.e. the default value for <code>mode</code>
parameter) selects the OSM ways that meet the following conditions:
</p>

<ul>
<li><p> The <code>highway</code> tag is not missing;
</p>
</li>
<li><p> The <code>highway</code> tag is not equal to <code>abandoned</code>, <code>bus_guideway</code>, <code>byway</code>,
<code>construction</code>, <code>corridor</code>, <code>elevator</code>, <code>fixme</code>, <code>escalator</code>, <code>gallop</code>,
<code>historic</code>, <code>no</code>, <code>planned</code>, <code>platform</code>, <code>proposed</code>, <code>raceway</code> or
<code>steps</code>;
</p>
</li>
<li><p> The <code>highway</code> tag is not equal to <code>motorway</code>, <code>motorway_link</code>,
<code>footway</code>, <code>bridleway</code> or <code>pedestrian</code> unless the tag <code>bicycle</code> is equal
to <code>yes</code>, <code>designated</code>, <code>permissive</code> or <code>destination</code> (see
<a href="https://wiki.openstreetmap.org/wiki/Bicycle#Bicycle_Restrictions">here</a>
for more details);
</p>
</li>
<li><p> The <code>access</code> tag is not equal to <code>private</code> or <code>no</code>;
</p>
</li>
<li><p> The <code>bicycle</code> tag is not equal to <code>no</code>, <code>use_sidepath</code>, <code>private</code>, or
<code>restricted</code>;
</p>
</li>
<li><p> The <code>service</code> tag does not contain the string <code>private</code> (i.e.
<code>private</code>, <code>private_access</code> and similar);
</p>
</li></ul>

<p>The <code>walking</code> mode of transport selects the OSM ways that meet the
following conditions:
</p>

<ul>
<li><p> The <code>highway</code> tag is not missing;
</p>
</li>
<li><p> The <code>highway</code> tag is not equal to <code>abandoned</code>, <code>bus_guideway</code>,
<code>byway</code>, <code>construction</code>, <code>corridor</code>, <code>elevator</code>, <code>fixme</code>,
<code>escalator</code>, <code>gallop</code>, <code>historic</code>, <code>no</code>, <code>planned</code>, <code>platform</code>, <code>proposed</code>,
<code>raceway</code>, <code>motorway</code> or <code>motorway_link</code>;
</p>
</li>
<li><p> The <code>highway</code> tag is not equal to <code>cycleway</code> unless the <code>foot</code> tag is
equal to <code>yes</code>;
</p>
</li>
<li><p> The <code>access</code> tag is not equal to <code>private</code> or <code>no</code>;
</p>
</li>
<li><p> The <code>foot</code> tag is not equal to <code>no</code>, <code>use_sidepath</code>, <code>private</code>, or
<code>restricted</code>;
</p>
</li>
<li><p> The <code>service</code> tag does not contain the string <code>private</code>
(i.e. <code>private</code>, <code>private_access</code> and similar).
</p>
</li></ul>

<p>The <code>driving</code> mode of transport selects the OSM ways that meet the
following conditions:
</p>

<ul>
<li><p> The <code>highway</code> tag is not missing;
</p>
</li>
<li><p> The <code>highway</code> tag is not equal to <code>abandoned</code>,
<code>bus_guideway</code>, <code>byway</code>, <code>construction</code>, <code>corridor</code>, <code>elevator</code>, <code>fixme</code>,
<code>escalator</code>, <code>gallop</code>, <code>historic</code>, <code>no</code>, <code>planned</code>, <code>platform</code>, <code>proposed</code>,
<code>cycleway</code>, <code>pedestrian</code>, <code>bridleway</code>, <code>path</code>, or <code>footway</code>;
</p>
</li>
<li><p> The <code>access</code> tag is not equal to <code>private</code> or <code>no</code>;
</p>
</li>
<li><p> The <code>service</code> tag does not contain the string <code>private</code> (i.e. <code>private</code>,
<code>private_access</code> and similar).
</p>
</li></ul>

<p>Feel free to create a new issue in the <a href="https://github.com/ropensci/osmextract">github repo</a> if you want to suggest
modifications to the current filters or propose new values for alternative
modes of transport.
</p>


<h3>Value</h3>

<p>An <code>sf</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oe_get">oe_get()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the ITS file to tempdir() to make sure that the examples do not
# require internet connection. You can skip the next 4 lines (and start
# directly with oe_get_keys) when running the examples locally.

its_pbf = file.path(tempdir(), "test_its-example.osm.pbf")
file.copy(
  from = system.file("its-example.osm.pbf", package = "osmextract"),
  to = its_pbf,
  overwrite = TRUE
)

# default value returned by OSM
its = oe_get(
  "ITS Leeds", quiet = TRUE, download_directory = tempdir()
)
plot(its["highway"], lwd = 2, key.pos = 4, key.width = lcm(2.75))
# walking mode of transport
its_walking = oe_get_network(
  "ITS Leeds", mode = "walking",
  download_directory = tempdir(), quiet = TRUE
)
plot(its_walking["highway"], lwd = 2, key.pos = 4, key.width = lcm(2.75))
# driving mode of transport
its_driving = oe_get_network(
  "ITS Leeds", mode = "driving",
  download_directory = tempdir(), quiet = TRUE
)
plot(its_driving["highway"], lwd = 2, key.pos = 4, key.width = lcm(2.75))

# Remove .pbf and .gpkg files in tempdir
oe_clean(tempdir())
</code></pre>

<hr>
<h2 id='oe_match'>Match input place with a url</h2><span id='topic+oe_match'></span><span id='topic+oe_match.default'></span><span id='topic+oe_match.bbox'></span><span id='topic+oe_match.sf'></span><span id='topic+oe_match.sfc'></span><span id='topic+oe_match.numeric'></span><span id='topic+oe_match.character'></span>

<h3>Description</h3>

<p>This function is used to match an input <code>place</code> with the URL of a <code>.osm.pbf</code>
file (and its file-size, if present). The URLs are stored in several
provider's databases. See <code><a href="#topic+oe_providers">oe_providers()</a></code> and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_match(place, ...)

## Default S3 method:
oe_match(place, ...)

## S3 method for class 'bbox'
oe_match(place, ...)

## S3 method for class 'sf'
oe_match(place, ...)

## S3 method for class 'sfc'
oe_match(place, provider = "geofabrik", level = NULL, quiet = FALSE, ...)

## S3 method for class 'numeric'
oe_match(place, provider = "geofabrik", quiet = FALSE, ...)

## S3 method for class 'character'
oe_match(
  place,
  provider = "geofabrik",
  quiet = FALSE,
  match_by = "name",
  max_string_dist = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_match_+3A_place">place</code></td>
<td>
<p>Description of the geographical area that should be matched with
a <code>.osm.pbf</code> file. Can be either a length-1 character vector, an
<code>sf</code>/<code>sfc</code>/<code>bbox</code> object, or a numeric vector of coordinates with length 2.
In the last case, it is assumed that the EPSG code is 4326 specified as
c(LON, LAT), while you can use any CRS with <code>sf</code>/<code>sfc</code>/<code>bbox</code> objects. See
Details and Examples in <code><a href="#topic+oe_match">oe_match()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_match_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="oe_match_+3A_provider">provider</code></td>
<td>
<p>Which provider should be used to download the data? Available
providers can be found with the following command: <code><a href="#topic+oe_providers">oe_providers()</a></code>. For
<code><a href="#topic+oe_get">oe_get()</a></code> and <code><a href="#topic+oe_match">oe_match()</a></code>, if <code>place</code> is equal to <code style="white-space: pre;">&#8288;ITS Leeds&#8288;</code>, then
<code>provider</code> is set equal to <code>test</code>. This is just for simple examples and
internal tests.</p>
</td></tr>
<tr><td><code id="oe_match_+3A_level">level</code></td>
<td>
<p>An integer representing the desired hierarchical level in case
of spatial matching. For the <code>geofabrik</code> provider, for example, <code>1</code>
corresponds with continent-level datasets, <code>2</code> for countries, <code>3</code>
corresponds to regions and <code>4</code> to subregions. Hence, we could approximately
say that smaller administrative units correspond to bigger levels. If
<code>NULL</code>, the default, the <code style="white-space: pre;">&#8288;oe_*&#8288;</code> functions will select the highest available
level. See Details and Examples in <code>oe_match()</code>.</p>
</td></tr>
<tr><td><code id="oe_match_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the function prints informative messages.
Starting from <code>sf</code> version
<a href="https://r-spatial.github.io/sf/news/index.html#version-0-9-6-2020-09-13">0.9.6</a>,
if <code>quiet</code> is equal to <code>FALSE</code>, then vectortranslate operations will
display a progress bar.</p>
</td></tr>
<tr><td><code id="oe_match_+3A_match_by">match_by</code></td>
<td>
<p>Which column of the provider's database should be used for
matching the input <code>place</code> with a <code>.osm.pbf</code> file? The default is <code>"name"</code>.
Check Details and Examples in <code><a href="#topic+oe_match">oe_match()</a></code> to understand how this parameter
works. Ignored if <code>place</code> is not a character vector since the matching is
performed through a spatial operation.</p>
</td></tr>
<tr><td><code id="oe_match_+3A_max_string_dist">max_string_dist</code></td>
<td>
<p>Numerical value greater or equal than 0. What is the
maximum distance in fuzzy matching (i.e. Approximate String Distance, see
<code><a href="utils.html#topic+adist">adist()</a></code>) between input <code>place</code> and <code>match_by</code> column to tolerate before
testing alternative providers or looking for geographical matching with
Nominatim API? This parameter is set equal to 0 if <code>match_by</code> is equal to
<code>iso3166_1_alpha2</code> or <code>iso3166_2</code>. Check Details and Examples in
<code><a href="#topic+oe_match">oe_match()</a></code> to understand why this parameter is important. Ignored if
<code>place</code> is not a character vector since the matching is performed through a
spatial operation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input place is specified as a spatial object (either <code>sf</code> or <code>sfc</code>),
then the function will return a geographical area that completely contains
the object (or an error). The argument <code>level</code> (which must be specified as an
integer between 1 and 4, extreme values included) is used to select between
multiple geographically nested areas. We could roughly say that smaller
administrative units correspond to higher levels. Check the help page of the
chosen provider for more details on <code>level</code> field. By default, <code>level = NULL</code>, which means that <code>oe_match()</code> will return the area corresponding to
the highest available level. If there is no geographical area at the desired
level, then the function will return an error. If there are multiple areas at
the same <code>level</code> intersecting the input place, then the function will return
the area whose centroid is closest to the input place.
</p>
<p>If the input place is specified as a character vector and there are multiple
plausible matches between the input place and the <code>match_by</code> column, then the
function will return a warning and it will select the first match. See
Examples. On the other hand, if the approximate string distance between the
input <code>place</code> and the best match in <code>match_by</code> column is greater than
<code>max_string_dist</code>, then the function will look for exact matches (i.e.
<code>max_string_dist = 0</code>) in the other supported providers. If it finds an exact
match, then it will return the corresponding URL. Otherwise, if <code>match_by</code> is
equal to <code>"name"</code>, then it will try to geolocate the input <code>place</code> using the
<a href="https://nominatim.org/release-docs/develop/api/Overview/">Nominatim API</a>,
and then it will perform a spatial matching operation (see Examples and
introductory vignette), while, if <code>match_by != "name"</code>, then it will return
an error.
</p>
<p>The fields <code>iso3166_1_alpha2</code> and <code>iso3166_2</code> are used by Geofabrik provider
to perform matching operations using <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 alpha-2</a> and <a href="https://en.wikipedia.org/wiki/ISO_3166-2">ISO 3166-2</a> codes. See
<a href="#topic+geofabrik_zones">geofabrik_zones</a> for more details.
</p>


<h3>Value</h3>

<p>A list with two elements, named <code>url</code> and <code>file_size</code>. The first
element is the URL of the <code>.osm.pbf</code> file associated with the input
<code>place</code>, while the second element is the size of the file in bytes (which
may be <code>NULL</code> or <code>NA</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oe_providers">oe_providers()</a></code> and <code><a href="#topic+oe_match_pattern">oe_match_pattern()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The simplest example:
oe_match("Italy")

# The default provider is "geofabrik", but we can change that:
oe_match("Leeds", provider = "bbbike")

# By default, the matching operations are performed through the column
# "name" in the provider's database but this can be a problem. Hence,
# you can perform the matching operations using other columns:
oe_match("RU", match_by = "iso3166_1_alpha2")
# Run oe_providers() for reading a short description of all providers and
# check the help pages of the corresponding databases to learn which fields
# are present.

# You can always increase the max_string_dist argument, but it can be
# dangerous:
oe_match("London", max_string_dist = 3, quiet = FALSE)

# Match the input zone using an sfc object:
milan_duomo = sf::st_sfc(sf::st_point(c(1514924, 5034552)), crs = 3003)
oe_match(milan_duomo, quiet = FALSE)
leeds = sf::st_sfc(sf::st_point(c(430147.8, 433551.5)), crs = 27700)
oe_match(leeds, provider = "bbbike")

# If you specify more than one sfg object, then oe_match will select the OSM
# extract that covers all areas
milan_leeds = sf::st_sfc(
  sf::st_point(c(9.190544, 45.46416)), # Milan
  sf::st_point(c(-1.543789, 53.7974)), # Leeds
  crs = 4326
)
oe_match(milan_leeds)

# Match the input zone using a numeric vector of coordinates
# (in which case crs = 4326 is assumed)
oe_match(c(9.1916, 45.4650)) # Milan, Duomo using CRS = 4326

# The following returns a warning since Berin is matched both
# with Benin and Berlin
oe_match("Berin", quiet = FALSE)

# If the input place does not match any zone in the chosen provider, then the
# function will test the other providers:
oe_match("Leeds")

# If the input place cannot be exactly matched with any zone in any provider,
# then the function will try to geolocate the input and then it will perform a
# spatial match:
## Not run: 
oe_match("Milan")
## End(Not run)

# The level parameter can be used to select smaller or bigger geographical
# areas during spatial matching
yak = c(-120.51084, 46.60156)
## Not run: 
oe_match(yak, level = 3) # error
oe_match(yak, level = 2) # by default, level is equal to the maximum value
oe_match(yak, level = 1)
## End(Not run)
</code></pre>

<hr>
<h2 id='oe_match_pattern'>Check patterns in the provider's databases</h2><span id='topic+oe_match_pattern'></span><span id='topic+oe_match_pattern.numeric'></span><span id='topic+oe_match_pattern.sf'></span><span id='topic+oe_match_pattern.bbox'></span><span id='topic+oe_match_pattern.sfc'></span><span id='topic+oe_match_pattern.character'></span>

<h3>Description</h3>

<p>This function is used to explore all provider's databases and look for
matches. This function can be useful in combination with <code><a href="#topic+oe_match">oe_match()</a></code> and
<code><a href="#topic+oe_get">oe_get()</a></code> for an exploratory analysis and an easy match. See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_match_pattern(pattern, ...)

## S3 method for class 'numeric'
oe_match_pattern(pattern, full_row = FALSE, ...)

## S3 method for class 'sf'
oe_match_pattern(pattern, full_row = FALSE, ...)

## S3 method for class 'bbox'
oe_match_pattern(pattern, full_row = FALSE, ...)

## S3 method for class 'sfc'
oe_match_pattern(pattern, full_row = FALSE, ...)

## S3 method for class 'character'
oe_match_pattern(pattern, match_by = "name", full_row = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_match_pattern_+3A_pattern">pattern</code></td>
<td>
<p>Description of the pattern. Can be either a length-1 character
vector, an <code>sf</code>/<code>sfc</code>/<code>bbox</code> object, or a numeric vector of coordinates
with length 2. In the last case, it is assumed that the EPSG code is 4326
specified as c(LON, LAT), while you can use any CRS with <code>sf</code>/<code>sfc</code>/<code>bbox</code>
objects.</p>
</td></tr>
<tr><td><code id="oe_match_pattern_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="oe_match_pattern_+3A_full_row">full_row</code></td>
<td>
<p>Boolean. Return all columns for the matching rows? <code>FALSE</code> by
default.</p>
</td></tr>
<tr><td><code id="oe_match_pattern_+3A_match_by">match_by</code></td>
<td>
<p>Name of the column in the provider's database that will be
used to find the match in case of character input. In all the other cases,
the match is performed using a spatial overlay operation and the output
returns the values stored in the <code>name</code> column (or even the full <code>sf</code>
object when <code>full_row</code> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors or <code>sf</code> objects (according to the value
of the parameter <code>full_row</code>). If no OSM zone can be matched with the input
string, then the function returns an empty list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oe_match_pattern("Yorkshire")

res = oe_match_pattern("Yorkshire", full_row = TRUE)
lapply(res, function(x) sf::st_drop_geometry(x)[, 1:3])

oe_match_pattern(c(9, 45)) # long/lat for Milan, Italy
</code></pre>

<hr>
<h2 id='oe_providers'>Summary of available providers</h2><span id='topic+oe_providers'></span>

<h3>Description</h3>

<p>This function is used to display a short summary of the major characteristics
of the databases associated to all available providers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_providers(quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_providers_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the function prints informative messages.
Starting from <code>sf</code> version
<a href="https://r-spatial.github.io/sf/news/index.html#version-0-9-6-2020-09-13">0.9.6</a>,
if <code>quiet</code> is equal to <code>FALSE</code>, then vectortranslate operations will
display a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 4 columns representing the name of each available
provider, the name of the corresponding database and the number of features
and fields.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oe_providers()
</code></pre>

<hr>
<h2 id='oe_read'>Read a .pbf or .gpkg object from file or url</h2><span id='topic+oe_read'></span>

<h3>Description</h3>

<p>This function is used to read a <code>.pbf</code> or <code>.gpkg</code> object from file or URL. It
is a wrapper around <code><a href="#topic+oe_download">oe_download()</a></code>, <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>, and
<code><a href="sf.html#topic+st_read">sf::st_read()</a></code>, creating an easy way to download, convert, and read a <code>.pbf</code>
or <code>.gpkg</code> file. Check the introductory vignette and the help pages of the
wrapped function for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_read(
  file_path,
  layer = "lines",
  ...,
  provider = NULL,
  download_directory = oe_download_directory(),
  file_size = NULL,
  force_download = FALSE,
  max_file_size = 5e+08,
  download_only = FALSE,
  skip_vectortranslate = FALSE,
  vectortranslate_options = NULL,
  osmconf_ini = NULL,
  extra_tags = NULL,
  force_vectortranslate = FALSE,
  never_skip_vectortranslate = FALSE,
  boundary = NULL,
  boundary_type = c("spat", "clipsrc"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_read_+3A_file_path">file_path</code></td>
<td>
<p>A URL or the path to a <code>.pbf</code> or <code>.gpkg</code> file. If a URL,
then it must be specified using HTTP/HTTPS protocol.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_layer">layer</code></td>
<td>
<p>Which <code>layer</code> should be read in? Typically <code>points</code>, <code>lines</code>
(the default), <code>multilinestrings</code>, <code>multipolygons</code> or <code>other_relations</code>. If
you specify an ad-hoc query using the argument <code>query</code> (see introductory
vignette and examples), then <code>oe_get()</code> and <code>oe_read()</code> will read the layer
specified in the query and ignore <code>layer</code>. See also
<a href="https://github.com/ropensci/osmextract/issues/122">#122</a>.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_...">...</code></td>
<td>
<p>(Named) arguments that will be passed to <code><a href="sf.html#topic+st_read">sf::st_read()</a></code>, like
<code>query</code>, <code>wkt_filter</code> or <code>stringsAsFactors</code>.  Check the introductory
vignette to understand how to create your own (SQL-like) queries.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_provider">provider</code></td>
<td>
<p>Which provider should be used to download the data? Available
providers can be found with the following command: <code><a href="#topic+oe_providers">oe_providers()</a></code>. For
<code><a href="#topic+oe_get">oe_get()</a></code> and <code><a href="#topic+oe_match">oe_match()</a></code>, if <code>place</code> is equal to <code style="white-space: pre;">&#8288;ITS Leeds&#8288;</code>, then
<code>provider</code> is set equal to <code>test</code>. This is just for simple examples and
internal tests.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_download_directory">download_directory</code></td>
<td>
<p>Where to download the file containing the OSM data?
By default this is equal to <code><a href="#topic+oe_download_directory">oe_download_directory()</a></code>, which is equal to
<code><a href="base.html#topic+tempdir">tempdir()</a></code> and it changes each time you restart R. You can set a
persistent <code>download_directory</code> by adding the following to your <code>.Renviron</code>
file (e.g. with <code>edit_r_environ</code> function in <code>usethis</code> package):
<code style="white-space: pre;">&#8288;OSMEXT_DOWNLOAD_DIRECTORY=/path/to/osm/data&#8288;</code>.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_file_size">file_size</code></td>
<td>
<p>How big is the file? Optional. <code>NA</code> by default. If it's
bigger than <code>max_file_size</code> and the function is run in interactive mode,
then an interactive menu is displayed, asking for permission to download
the file.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_force_download">force_download</code></td>
<td>
<p>Should the <code>.osm.pbf</code> file be updated if it has already
been downloaded? <code>FALSE</code> by default. This parameter is used to update old
<code>.osm.pbf</code> files.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_max_file_size">max_file_size</code></td>
<td>
<p>The maximum file size to download without asking in
interactive mode. Default: <code>5e+8</code>, half a gigabyte.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_download_only">download_only</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, then the function only returns the
path where the matched file is stored, instead of reading it. <code>FALSE</code> by
default.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_skip_vectortranslate">skip_vectortranslate</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, then the function skips all
vectortranslate operations and it reads (or simply returns the path) of the
<code>.osm.pbf</code> file. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_vectortranslate_options">vectortranslate_options</code></td>
<td>
<p>Options passed to the <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>
argument <code>options</code>. Set by default. Check details in the introductory
vignette and the help page of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_osmconf_ini">osmconf_ini</code></td>
<td>
<p>The configuration file. See documentation at
<a href="https://gdal.org/drivers/vector/osm.html">gdal.org</a>. Check details in the
introductory vignette and the help page of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>. Set by
default.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_extra_tags">extra_tags</code></td>
<td>
<p>Which additional columns, corresponding to OSM tags, should
be in the resulting dataset? <code>NULL</code> by default. Check the introductory
vignette and the help pages of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code> and <code><a href="#topic+oe_get_keys">oe_get_keys()</a></code>.
Ignored when <code>osmconf_ini</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_force_vectortranslate">force_vectortranslate</code></td>
<td>
<p>Boolean. Force the original <code>.pbf</code> file to be
translated into a <code>.gpkg</code> file, even if a <code>.gpkg</code> with the same name
already exists? <code>FALSE</code> by default. If tags in <code>extra_tags</code> match data in
previously translated <code>.gpkg</code> files no translation occurs (see
<a href="https://github.com/ropensci/osmextract/issues/173">#173</a> for details).
Check the introductory vignette and the help page of
<code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_never_skip_vectortranslate">never_skip_vectortranslate</code></td>
<td>
<p>Boolean. This is used in case the user
passed its own <code>.ini</code> file or vectortranslate options (since, in those
case, it's too difficult to determine if an existing <code>.gpkg</code> file was
generated following the same options.)</p>
</td></tr>
<tr><td><code id="oe_read_+3A_boundary">boundary</code></td>
<td>
<p>An <code>sf</code>/<code>sfc</code>/<code>bbox</code> object that will be used to create a
spatial filter during the vectortranslate operations. The type of filter
can be chosen using the argument <code>boundary_type</code>.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_boundary_type">boundary_type</code></td>
<td>
<p>A character vector of length 1 specifying the type of
spatial filter. The <code>spat</code> filter selects only those features that
intersect a given area, while <code>clipsrc</code> also clips the geometries. Check
the examples and also <a href="https://gdal.org/programs/ogr2ogr.html">here</a> for
more details.</p>
</td></tr>
<tr><td><code id="oe_read_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the function prints informative messages.
Starting from <code>sf</code> version
<a href="https://r-spatial.github.io/sf/news/index.html#version-0-9-6-2020-09-13">0.9.6</a>,
if <code>quiet</code> is equal to <code>FALSE</code>, then vectortranslate operations will
display a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>provider</code>, <code>download_directory</code>, <code>file_size</code>,
<code>force_download</code>, and <code>max_file_size</code> are ignored if <code>file_path</code> points to
an existing <code>.pbf</code> or <code>.gpkg</code> file.
</p>
<p>Please note that you cannot add any field to an existing <code>.gpkg</code> file using
the argument <code>extra_tags</code> without rerunning the vectortranslate process on
the corresponding <code>.pbf</code> file. On the other hand, you can extract some of
the tags in <code>other_tags</code> field as new columns. See examples and
<code><a href="#topic+oe_get_keys">oe_get_keys()</a></code> for more details.
</p>


<h3>Value</h3>

<p>An <code>sf</code> object or, when <code>download_only</code> argument equals <code>TRUE</code>, a
character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read an existing .pbf file. First we need to copy a .pbf file into a
# temporary directory
its_pbf = file.path(tempdir(), "test_its-example.osm.pbf")
file.copy(
  from = system.file("its-example.osm.pbf", package = "osmextract"),
  to = its_pbf
)
oe_read(its_pbf)

# Read a new layer
oe_read(its_pbf, layer = "points")

# The following example shows how to add new tags
names(oe_read(its_pbf, extra_tags = c("oneway", "ref"), quiet = TRUE))

# Read an existing .gpkg file. This file was created internally by oe_read().
its_gpkg = file.path(tempdir(), "test_its-example.gpkg")
oe_read(its_gpkg)

# You cannot add any new layer to an existing .gpkg file but you can extract
# some of the tags in other_tags. Check oe_get_keys() for more details.
names(oe_read(its_gpkg, extra_tags = c("maxspeed"))) # doesn't work
# Instead, use the query argument
names(oe_read(
  its_gpkg,
  quiet = TRUE,
  query =
  "SELECT *,
  hstore_get_value(other_tags, 'maxspeed') AS maxspeed
  FROM lines
  "
))

# Read from a URL
my_url = "https://github.com/ropensci/osmextract/raw/master/inst/its-example.osm.pbf"
# Please note that if you read from a URL which is not linked to one of the
# supported providers, you need to specify the provider parameter:
## Not run: 
oe_read(my_url, provider = "test", quiet = FALSE)
## End(Not run)

# Remove .pbf and .gpkg files in tempdir
oe_clean(tempdir())
</code></pre>

<hr>
<h2 id='oe_search'>Search for a place and return an sf data frame locating it</h2><span id='topic+oe_search'></span>

<h3>Description</h3>

<p>This (only internal and experimental) function provides a simple
interface to the <a href="https://nominatim.openstreetmap.org">nominatim</a> service for
finding the geographical location of place names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_search(
  place,
  base_url = "https://nominatim.openstreetmap.org",
  destfile = tempfile(fileext = ".geojson"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_search_+3A_place">place</code></td>
<td>
<p>Text string containing the name of a place the location of
which is to be found, such as <code>"Leeds"</code> or <code>"Milan"</code>.</p>
</td></tr>
<tr><td><code id="oe_search_+3A_base_url">base_url</code></td>
<td>
<p>The URL of the nominatim server to use. The main
open server hosted by OpenStreetMap is the default.</p>
</td></tr>
<tr><td><code id="oe_search_+3A_destfile">destfile</code></td>
<td>
<p>The name of the destination file where the output
of the search query, a <code>.geojson</code> file, should be saved.</p>
</td></tr>
<tr><td><code id="oe_search_+3A_...">...</code></td>
<td>
<p>Extra arguments that are passed to <code>sf::st_read</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object corresponding to the input place. The <code>sf</code> object is
read by <code>sf::st_read()</code> and it is based on a <code>geojson</code> file returned by
Nominatim API.
</p>

<hr>
<h2 id='oe_update'>Update all the .osm.pbf files saved in a directory</h2><span id='topic+oe_update'></span>

<h3>Description</h3>

<p>This function is used to re-download all <code>.osm.pbf</code> files stored in
<code>download_directory</code> that were firstly downloaded through <code><a href="#topic+oe_get">oe_get()</a></code>. See
Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_update(
  download_directory = oe_download_directory(),
  quiet = FALSE,
  delete_gpkg = TRUE,
  max_file_size = 5e+08,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_update_+3A_download_directory">download_directory</code></td>
<td>
<p>Character string of the path of the directory
where the <code>.osm.pbf</code> files are saved.</p>
</td></tr>
<tr><td><code id="oe_update_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code> the function prints informative
messages. See Details.</p>
</td></tr>
<tr><td><code id="oe_update_+3A_delete_gpkg">delete_gpkg</code></td>
<td>
<p>Boolean. if <code>TRUE</code> the function deletes the old <code>.gpkg</code>
files. We added this parameter to minimize the probability of accidentally
reading-in old and not-synchronized <code>.gpkg</code> files. See Details. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="oe_update_+3A_max_file_size">max_file_size</code></td>
<td>
<p>The maximum file size to download without asking in
interactive mode. Default: <code>5e+8</code>, half a gigabyte.</p>
</td></tr>
<tr><td><code id="oe_update_+3A_...">...</code></td>
<td>
<p>Additional parameter that will be passed to <code><a href="#topic+oe_get">oe_get()</a></code> (such as
<code>stringsAsFactors</code> or <code>query</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to re-download <code>.osm.pbf</code> files that are
stored in a directory (specified by <code>download_directory</code> param) and that
were firstly downloaded through <code><a href="#topic+oe_get">oe_get()</a></code> . The name of the files must
begin with the name of one of the supported providers (see
<code><a href="#topic+oe_providers">oe_providers()</a></code>) and it must end with <code>.osm.pbf</code>. All other
files in the directory that do not match this format are ignored.
</p>
<p>The process for re-downloading the <code>.osm.pbf</code> files is performed using the
function <code><a href="#topic+oe_get">oe_get()</a></code> . The appropriate provider is determined by looking at
the first word in the path of the <code>.osm.pbf</code> file. The place is determined
by looking at the second word in the file path and the matching is
performed through the <code>id</code> column in the provider's database. So, for
example, the path <code>geofabrik_italy-latest-update.osm.pbf</code> will be matched
with the provider <code>"geofabrik"</code> and the geographical zone <code>italy</code> through
the column <code>id</code> in <code>geofabrik_zones</code>.
</p>
<p>The parameter <code>delete_gpkg</code> is used to delete all <code>.gpkg</code> files in
<code>download_directory</code>. We decided to set its default value to <code>TRUE</code> to
minimize the possibility of reading-in old and non-synchronized <code>.gpkg</code>
files. If you set <code>delete_gpkg = FALSE</code>, then you need to manually
reconvert all files using <code><a href="#topic+oe_get">oe_get()</a></code> or <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code> .
</p>
<p>If you set the parameter <code>quiet</code> to <code>FALSE</code>, then the function will print
some useful messages regarding the characteristics of the files before and
after updating them. More precisely, it will print the output of the
columns <code>size</code>, <code>mtime</code> and <code>ctime</code> from <code><a href="base.html#topic+file.info">file.info()</a></code>. Please note that
the meaning of <code>mtime</code> and <code>ctime</code> depends on the OS and the file system.
Check <code><a href="base.html#topic+file.info">file.info()</a></code>.
</p>


<h3>Value</h3>

<p>The path(s) of the <code>.osm.pbf</code> file(s) that were updated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set up a fake directory with .pbf and .gpkg files
fake_dir = tempdir()
# Fill the directory
oe_get("Andorra", download_directory = fake_dir, download_only = TRUE)
# Check the directory
list.files(fake_dir, pattern = "gpkg|pbf")
# Update all .pbf files and delete all .gpkg files
oe_update(fake_dir, quiet = TRUE)
list.files(fake_dir, pattern = "gpkg|pbf")
## End(Not run)
</code></pre>

<hr>
<h2 id='oe_vectortranslate'>Translate a .osm.pbf file into .gpkg format</h2><span id='topic+oe_vectortranslate'></span>

<h3>Description</h3>

<p>This function is used to translate a <code>.osm.pbf</code> file into <code>.gpkg</code> format.
The conversion is performed using
<a href="https://gdal.org/programs/ogr2ogr.html#ogr2ogr">ogr2ogr</a> via the
<code>vectortranslate</code> utility in <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code> . It was created following
<a href="https://github.com/OSGeo/gdal/issues/2100#issuecomment-565707053">the suggestions</a>
of the maintainers of GDAL. See Details and Examples to understand the basic
usage, and check the introductory vignette for more complex use-cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_vectortranslate(
  file_path,
  layer = "lines",
  vectortranslate_options = NULL,
  osmconf_ini = NULL,
  extra_tags = NULL,
  force_vectortranslate = FALSE,
  never_skip_vectortranslate = FALSE,
  boundary = NULL,
  boundary_type = c("spat", "clipsrc"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_vectortranslate_+3A_file_path">file_path</code></td>
<td>
<p>Character string representing the path of the input
<code>.pbf</code> or <code>.osm.pbf</code> file.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_layer">layer</code></td>
<td>
<p>Which <code>layer</code> should be read in? Typically <code>points</code>, <code>lines</code>
(the default), <code>multilinestrings</code>, <code>multipolygons</code> or <code>other_relations</code>. If
you specify an ad-hoc query using the argument <code>query</code> (see introductory
vignette and examples), then <code>oe_get()</code> and <code>oe_read()</code> will read the layer
specified in the query and ignore <code>layer</code>. See also
<a href="https://github.com/ropensci/osmextract/issues/122">#122</a>.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_vectortranslate_options">vectortranslate_options</code></td>
<td>
<p>Options passed to the <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>
argument <code>options</code>. Set by default. Check details in the introductory
vignette and the help page of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_osmconf_ini">osmconf_ini</code></td>
<td>
<p>The configuration file. See documentation at
<a href="https://gdal.org/drivers/vector/osm.html">gdal.org</a>. Check details in the
introductory vignette and the help page of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>. Set by
default.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_extra_tags">extra_tags</code></td>
<td>
<p>Which additional columns, corresponding to OSM tags, should
be in the resulting dataset? <code>NULL</code> by default. Check the introductory
vignette and the help pages of <code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code> and <code><a href="#topic+oe_get_keys">oe_get_keys()</a></code>.
Ignored when <code>osmconf_ini</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_force_vectortranslate">force_vectortranslate</code></td>
<td>
<p>Boolean. Force the original <code>.pbf</code> file to be
translated into a <code>.gpkg</code> file, even if a <code>.gpkg</code> with the same name
already exists? <code>FALSE</code> by default. If tags in <code>extra_tags</code> match data in
previously translated <code>.gpkg</code> files no translation occurs (see
<a href="https://github.com/ropensci/osmextract/issues/173">#173</a> for details).
Check the introductory vignette and the help page of
<code><a href="#topic+oe_vectortranslate">oe_vectortranslate()</a></code>.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_never_skip_vectortranslate">never_skip_vectortranslate</code></td>
<td>
<p>Boolean. This is used in case the user
passed its own <code>.ini</code> file or vectortranslate options (since, in those
case, it's too difficult to determine if an existing <code>.gpkg</code> file was
generated following the same options.)</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_boundary">boundary</code></td>
<td>
<p>An <code>sf</code>/<code>sfc</code>/<code>bbox</code> object that will be used to create a
spatial filter during the vectortranslate operations. The type of filter
can be chosen using the argument <code>boundary_type</code>.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_boundary_type">boundary_type</code></td>
<td>
<p>A character vector of length 1 specifying the type of
spatial filter. The <code>spat</code> filter selects only those features that
intersect a given area, while <code>clipsrc</code> also clips the geometries. Check
the examples and also <a href="https://gdal.org/programs/ogr2ogr.html">here</a> for
more details.</p>
</td></tr>
<tr><td><code id="oe_vectortranslate_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the function prints informative messages.
Starting from <code>sf</code> version
<a href="https://r-spatial.github.io/sf/news/index.html#version-0-9-6-2020-09-13">0.9.6</a>,
if <code>quiet</code> is equal to <code>FALSE</code>, then vectortranslate operations will
display a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new <code>.gpkg</code> file is created in the same directory as the input
<code>.osm.pbf</code> file. The translation process is performed using the
<code>vectortranslate</code> utility in <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>. This operation can be
customized in several ways modifying the parameters <code>layer</code>, <code>extra_tags</code>,
<code>osmconf_ini</code>, <code>vectortranslate_options</code>, <code>boundary</code> and <code>boundary_type</code>.
</p>
<p>The <code>.osm.pbf</code> files processed by GDAL are usually categorized into 5
layers, named <code>points</code>, <code>lines</code>, <code>multilinestrings</code>, <code>multipolygons</code> and
<code>other_relations</code>. Check the first paragraphs
<a href="https://gdal.org/drivers/vector/osm.html">here</a> for more details. This
function can covert only one layer at a time, and the parameter <code>layer</code> is
used to specify which layer of the <code>.osm.pbf</code> file should be converted.
Several layers with different names can be stored in the same <code>.gpkg</code> file.
By default, the function will convert the <code>lines</code> layer (which is the most
common one according to our experience).
</p>
<p>The arguments <code>osmconf_ini</code> and <code>extra_tags</code> are used to modify how GDAL
reads and processes a <code>.osm.pbf</code> file. More precisely, several operations
that GDAL performs on the input <code>.osm.pbf</code> file are governed by a <code>CONFIG</code>
file, that can be checked at the following
<a href="https://github.com/OSGeo/gdal/blob/master/ogr/ogrsf_frmts/osm/data/osmconf.ini">link</a>.
The basic components of OSM data are called
<a href="https://wiki.openstreetmap.org/wiki/Elements"><em>elements</em></a> and they are
divided into <em>nodes</em>, <em>ways</em> or <em>relations</em>, so, for example, the code at
line 7 of that file is used to determine which <em>ways</em> are assumed to be
polygons (according to the simple-feature definition of polygon) if they
are closed. Moreover, OSM data is usually described using several
<a href="https://wiki.openstreetmap.org/wiki/Tags"><em>tags</em></a>, i.e pairs of two items:
a key and a value. The code at lines 33, 53, 85, 103, and 121 is used to
determine, for each layer, which tags should be explicitly reported as
fields (while all the other tags are stored in the <code>other_tags</code> column).
The parameter <code>extra_tags</code> is used to determine which extra tags (i.e.
key/value pairs) should be added to the <code>.gpkg</code> file (other than the
default ones).
</p>
<p>By default, the vectortranslate operations are skipped if the function
detects a file having the same path as the input file, <code>.gpkg</code> extension, a
layer with the same name as the parameter <code>layer</code> and all <code>extra_tags</code>. In
that case the function will simply return the path of the <code>.gpkg</code> file.
This behaviour can be overwritten setting <code>force_vectortranslate = TRUE</code>.
The vectortranslate operations are never skipped if <code>osmconf_ini</code>,
<code>vectortranslate_options</code>, <code>boundary</code> or <code>boundary_type</code> arguments are not
<code>NULL</code>.
</p>
<p>The parameter <code>osmconf_ini</code> is used to pass your own <code>CONFIG</code> file in case
you need more control over the GDAL operations. Check the package
introductory vignette for an example. If <code>osmconf_ini</code> is equal to <code>NULL</code>
(the default value), then the function uses the standard <code>osmconf.ini</code> file
defined by GDAL (but for the extra tags).
</p>
<p>The parameter <code>vectortranslate_options</code> is used to control the options that
are passed to <code>ogr2ogr</code> via <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code> when converting between
<code>.osm.pbf</code> and <code>.gpkg</code> formats. <code>ogr2ogr</code> can perform various operations
during the conversion process, such as spatial filters or SQL queries.
These operations can be tuned using the <code>vectortranslate_options</code> argument.
If <code>NULL</code> (the default value), then <code>vectortranslate_options</code> is set equal
to
</p>
<p><code>c("-f", "GPKG", "-overwrite", "-oo", paste0("CONFIG_FILE=", osmconf_ini), "-lco", "GEOMETRY_NAME=geometry", layer)</code>.
</p>
<p>Explanation:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"-f", "GPKG"&#8288;</code> says that the output format is <code>GPKG</code>;
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"-overwrite&#8288;</code> is used to delete an existing layer and recreate
it empty;
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"-oo", paste0("CONFIG_FILE=", osmconf_ini)&#8288;</code> is used to set the
<a href="https://gdal.org/drivers/vector/osm.html#open-options">Open Options</a>
for the <code>.osm.pbf</code> file and change the <code>CONFIG</code> file (in case the user
asks for any extra tag or a totally different CONFIG file);
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"-lco", "GEOMETRY_NAME=geometry"&#8288;</code> is used to change the
<a href="https://gdal.org/drivers/vector/gpkg.html?highlight=gpkg#layer-creation-options">layer creation options</a>
for the <code>.gpkg</code> file and modify the name of the geometry column;
</p>
</li>
<li> <p><code>layer</code> indicates which layer should be converted.
</p>
</li></ul>

<p>If <code>vectortranslate_options</code> is not <code>NULL</code>, then the options <code>c("-f", "GPKG", "-overwrite", "-oo", "CONFIG_FILE=", path-to-config-file, "-lco", "GEOMETRY_NAME=geometry", layer)</code> are always appended unless the user
explicitly sets different default parameters for the arguments <code>-f</code>, <code>-oo</code>,
<code>-lco</code>, and <code>layer</code>.
</p>
<p>The arguments <code>boundary</code> and <code>boundary_type</code> can be used to set up a
spatial filter during the vectortranslate operations (and speed up the
process) using an <code>sf</code> or <code>sfc</code> object (<code>POLYGON</code> or <code>MULTIPOLYGON</code>). The
default arguments create a rectangular spatial filter which selects all
features that intersect the area. Setting <code>boundary_type = "clipsrc"</code> clips
the geometries. In both cases, the appropriate options are automatically
added to the <code>vectortranslate_options</code> (unless a user explicitly sets
different default options). Check Examples in <code>oe_get()</code> and the
introductory vignette.
</p>
<p>See also the help page of <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code> and
<a href="https://gdal.org/programs/ogr2ogr.html">ogr2ogr</a> for more examples and
extensive documentation on all available options that can be tuned during
the vectortranslate process.
</p>


<h3>Value</h3>

<p>Character string representing the path of the <code>.gpkg</code> file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oe_get_keys">oe_get_keys()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we need to match an input zone with a .osm.pbf file
(its_match = oe_match("ITS Leeds"))

# Copy ITS file to tempdir so that the examples do not require internet
# connection. You can skip the next 3 lines (and start directly with
# oe_download()) when running the examples locally.

file.copy(
  from = system.file("its-example.osm.pbf", package = "osmextract"),
  to = file.path(tempdir(), "test_its-example.osm.pbf"),
  overwrite = TRUE
)

# The we can download the .osm.pbf file (if it was not already downloaded)
its_pbf = oe_download(
  file_url = its_match$url,
  file_size = its_match$file_size,
  download_directory = tempdir(),
  provider = "test"
)

# Check that the file was downloaded
list.files(tempdir(), pattern = "pbf|gpkg")

# Convert to gpkg format
its_gpkg = oe_vectortranslate(its_pbf)

# Now there is an extra .gpkg file
list.files(tempdir(), pattern = "pbf|gpkg")

# Check the layers of the .gpkg file
sf::st_layers(its_gpkg, do_count = TRUE)

# Add points layer
its_gpkg = oe_vectortranslate(its_pbf, layer = "points")
sf::st_layers(its_gpkg, do_count = TRUE)

# Add extra tags to the lines layer
names(sf::st_read(its_gpkg, layer = "lines", quiet = TRUE))
its_gpkg = oe_vectortranslate(
  its_pbf,
  extra_tags = c("oneway", "maxspeed")
)
names(sf::st_read(its_gpkg, layer = "lines", quiet = TRUE))

# Adjust vectortranslate options and convert only 10 features
# for the lines layer
oe_vectortranslate(
  its_pbf,
  vectortranslate_options = c("-limit", 10)
)
sf::st_layers(its_gpkg, do_count = TRUE)

# Remove .pbf and .gpkg files in tempdir
oe_clean(tempdir())
</code></pre>

<hr>
<h2 id='openstreetmap_fr_zones'>An sf object of geographical zones taken from download.openstreetmap.fr</h2><span id='topic+openstreetmap_fr_zones'></span>

<h3>Description</h3>

<p>An <code>sf</code> object containing the URLs, names, and file-sizes of the OSM
extracts stored at <a href="http://download.openstreetmap.fr/">http://download.openstreetmap.fr/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openstreetmap_fr_zones
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 1187 rows and
7 columns:
</p>

<dl>
<dt>id</dt><dd><p>A unique ID for each area. It is used by <code>oe_update()</code>.</p>
</dd>
<dt>name</dt><dd><p>The, usually English, long-form name of the city.</p>
</dd>
<dt>parent</dt><dd><p>The identifier of the next larger excerpts that contains
this one, if present.</p>
</dd>
<dt>level</dt><dd><p>An integer code between 1 and 4. Check
<a href="http://download.openstreetmap.fr/polygons/">http://download.openstreetmap.fr/polygons/</a> to understand the hierarchical
structure of the zones. 1L correspond to the biggest areas. This is used
only for matching operations in case of spatial input.</p>
</dd>
<dt>pbf</dt><dd><p>Link to the latest <code>.osm.pbf</code> file for this region.</p>
</dd>
<dt>pbf_file_size</dt><dd><p>Size of the pbf file in bytes.</p>
</dd>
<dt>geometry</dt><dd><p>The <code>sfg</code> for that geographical region, rectangular. See
also <code>oe_get_boundary()</code> to extract the proper geographical boundaries.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://download.bbbike.org/osm/">https://download.bbbike.org/osm/</a>
</p>


<h3>See Also</h3>

<p>Other provider's-database: 
<code><a href="#topic+bbbike_zones">bbbike_zones</a></code>,
<code><a href="#topic+geofabrik_zones">geofabrik_zones</a></code>
</p>

<hr>
<h2 id='read_poly'>Read a <code>.poly</code> file.</h2><span id='topic+read_poly'></span>

<h3>Description</h3>

<p>Read a <code>.poly</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_poly(input, crs = "OGC:CRS84", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_poly_+3A_input">input</code></td>
<td>
<p>Character vector representing a polygon object saved using the
<code>.poly</code> format. Can be also a path to a file or a URL pointing to a valid
<code>.poly</code> file.</p>
</td></tr>
<tr><td><code id="read_poly_+3A_crs">crs</code></td>
<td>
<p>The Coordinate Reference System (CRS) of the input polygon.</p>
</td></tr>
<tr><td><code id="read_poly_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>readLines()</code> (which is the function
used to read external <code>.poly</code> files).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Polygon Filter File Format (<code>.poly</code>) is defined
<a href="https://wiki.openstreetmap.org/wiki/Osmosis/Polygon_Filter_File_Format">here</a>.
The code behind the function was inspired by the <code>parse_poly</code> function
defined
<a href="https://wiki.openstreetmap.org/wiki/Osmosis/Polygon_Filter_File_Python_Parsing">here</a>.
</p>
<p><a href="https://download.geofabrik.de/">Geofabrik</a> stores the <code>.poly</code> files used
to generate their extracts. Furthermore, a nice collection of exact-border
poly files created from cities with an OSM Relation ID is available in this
git repository on github: <a href="https://github.com/jameschevalier/cities">https://github.com/jameschevalier/cities</a>.
</p>
<p>The default value for the <code>crs</code> argument is &quot;OGC:CRS84&quot; instead of &quot;4326&quot;
or &quot;EPSG:4326&quot; since, by definition, the coordinates are provided as
&quot;longitude, latitude&quot; (but these differences should be relevant only when
<code>sf::st_axis_order()</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A <code>sfc_MULTIPOLYGON</code>/<code>sfc</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toy_poly &lt;- c(
  "test_poly",
  "first_area",
  "0 0",
  "0 1",
  "1 1",
  "1 0",
  "0 0",
  "END",
  "END"
)
(out &lt;- read_poly(toy_poly))
plot(out)

## Not run: 
italy_poly &lt;- "https://download.geofabrik.de/europe/italy.poly"
plot(read_poly(italy_poly))
## End(Not run)
</code></pre>

<hr>
<h2 id='test_zones'>An sf object of geographical zones taken from download.openstreetmap.fr</h2><span id='topic+test_zones'></span>

<h3>Description</h3>

<p>This object represent a minimal provider's database and it should be used
only for examples and tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_zones
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 2 rows and 7 columns.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
