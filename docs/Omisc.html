<!DOCTYPE html><html lang="en"><head><title>Help for package Omisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Omisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aboot'><p>Title</p></a></li>
<li><a href='#aCalc'><p>aCalc</p></a></li>
<li><a href='#add'><p>add</p></a></li>
<li><a href='#ajack'><p>ajack</p></a></li>
<li><a href='#AllBootResults'><p>AllBootResults</p></a></li>
<li><a href='#BarebonesBetas'><p>BarebonesBetas</p></a></li>
<li><a href='#BCa'><p>BCa</p></a></li>
<li><a href='#bias'><p>Title</p></a></li>
<li><a href='#bootAnalysis'><p>bootAnalysis</p></a></li>
<li><a href='#bootsample'><p>bootsample</p></a></li>
<li><a href='#cent'><p>cent</p></a></li>
<li><a href='#centerData'><p>centerData</p></a></li>
<li><a href='#cholcors'><p>cholcors</p></a></li>
<li><a href='#cholcovs'><p>cholcovs</p></a></li>
<li><a href='#DFanalysis'><p>DFanalysis</p></a></li>
<li><a href='#DFSimulated'><p>DFSimulated</p></a></li>
<li><a href='#DFSimulatedChisq'><p>DFSimulatedChisq</p></a></li>
<li><a href='#DFSimulatedChisqNew'><p>DFSimulatedChisqNew</p></a></li>
<li><a href='#doubleEnter'><p>DoubleEnter</p></a></li>
<li><a href='#findSa'><p>findSa</p></a></li>
<li><a href='#Group_function'><p>Grouping_function</p></a></li>
<li><a href='#HoffPseudoStandard'><p>HoffPseudoStandard</p></a></li>
<li><a href='#jackknife'><p>jackknife</p></a></li>
<li><a href='#justBetas'><p>justBetas</p></a></li>
<li><a href='#lbind'><p>lbind</p></a></li>
<li><a href='#leave1out'><p>leave1out</p></a></li>
<li><a href='#MyLM'><p>MyLM</p></a></li>
<li><a href='#NaiveBoot'><p>The Naive Bootstrap</p></a></li>
<li><a href='#NaiveBoot_dep'><p>The Naive Bootstrap</p></a></li>
<li><a href='#resample'><p>resample</p></a></li>
<li><a href='#RK'><p>RK</p></a></li>
<li><a href='#Sfunc'><p>Sfunc</p></a></li>
<li><a href='#standardBootIntervals'><p>standardBootIntervals</p></a></li>
<li><a href='#TestData'><p>TestData</p></a></li>
<li><a href='#uniboot'><p>Univariate Bootstrap</p></a></li>
<li><a href='#uniboot_dep'><p>Univariate Bootstrap</p></a></li>
<li><a href='#unibootsample'><p>unibootsample</p></a></li>
<li><a href='#unibootVar'><p>unibootVar</p></a></li>
<li><a href='#zScore'><p>Title</p></a></li>
<li><a href='#zScoreData'><p>centerData</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Univariate Bootstrapping and Other Things</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick O'Keefe</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick O'Keefe &lt;okeefep@ohsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Primarily devoted to implementing the Univariate Bootstrap (as well as the Traditional Bootstrap). In addition there are multiple functions for DeFries-Fulker behavioral genetics models. The univariate bootstrapping functions, DeFries-Fulker functions, regression and traditional bootstrapping functions form the original core. Additional features may come online later, however this software is a work in progress. For more information about univariate bootstrapping see: Lee and Rodgers (1998) and Beasley et al (2007) &lt;<a href="https://doi.org/10.1037%2F1082-989X.12.4.414">doi:10.1037/1082-989X.12.4.414</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, base, stats, psych, copula</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lavaan</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-08 19:52:27 UTC; pgok1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-09 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aboot'>Title</h2><span id='topic+aboot'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aboot(boot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aboot_+3A_boot">boot</code></td>
<td>
<p>a vector of bootstrap resample statistics to use to calculate the accelleration parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of accelleration parameters for use in BCa bootstrap intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data&lt;-DFSimulated()
boots&lt;-NaiveBoot(data, groups="Rs", keepgroups=TRUE)
boots&lt;-bootAnalysis(boots, cbind, DFanalysis, 1,2,3, robust=FALSE)
boots&lt;-t(boots)
aboot(boots)
</code></pre>

<hr>
<h2 id='aCalc'>aCalc</h2><span id='topic+aCalc'></span>

<h3>Description</h3>

<p>This function calculates the actual &quot;a&quot; estimate from the jackknife approximation of a used in BCa CI's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aCalc(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aCalc_+3A_x">X</code></td>
<td>
<p>A vector of jackknife results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of a for use in BCa.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-rchisq(100,2)
aCalc(X)

</code></pre>

<hr>
<h2 id='add'>add</h2><span id='topic+add'></span>

<h3>Description</h3>

<p>add
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_+3A_x">x</code></td>
<td>
<p>a list to be summed. Useful for doing elementwise summation of a list of matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a single summed object (e.g., a matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-list(matrix(c(1:4),nrow=2),matrix(c(1:4),nrow=2))
add(x)
</code></pre>

<hr>
<h2 id='ajack'>ajack</h2><span id='topic+ajack'></span>

<h3>Description</h3>

<p>ajack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajack(data, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ajack_+3A_data">data</code></td>
<td>
<p>data to get the bias parameter (a) for</p>
</td></tr>
<tr><td><code id="ajack_+3A_fun">FUN</code></td>
<td>
<p>a function to be applied to the data</p>
</td></tr>
<tr><td><code id="ajack_+3A_...">...</code></td>
<td>
<p>additional arguments passed to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of accelleration parameters for use in BCa bootstrap intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-DFSimulated()
ajack(data,DFanalysis, betasonly=TRUE, robust=FALSE)
</code></pre>

<hr>
<h2 id='AllBootResults'>AllBootResults</h2><span id='topic+AllBootResults'></span>

<h3>Description</h3>

<p>AllBootResults
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AllBootResults(boot, lower = 0.025, upper = 0.975, data, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AllBootResults_+3A_boot">boot</code></td>
<td>
<p>A matrix of bootstrap results</p>
</td></tr>
<tr><td><code id="AllBootResults_+3A_lower">lower</code></td>
<td>
<p>the lower alpha</p>
</td></tr>
<tr><td><code id="AllBootResults_+3A_upper">upper</code></td>
<td>
<p>the upper alpha</p>
</td></tr>
<tr><td><code id="AllBootResults_+3A_data">data</code></td>
<td>
<p>the data used for analysis</p>
</td></tr>
<tr><td><code id="AllBootResults_+3A_fun">FUN</code></td>
<td>
<p>the function used for analysis</p>
</td></tr>
<tr><td><code id="AllBootResults_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of results. Includes the baseline results, all output from standardBootIntervals, all results from BCa for both the jackknife and bootstrap accelleration methods. The bootstrap accelleration method is experimental.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-DFSimulated()
boots&lt;-NaiveBoot(data, groups="Rs", keepgroups=TRUE)
boots&lt;-bootAnalysis(boots, cbind, DFanalysis, 1,2,3, robust=FALSE)
AllBootResults(boots, .025,.975, data, DFanalysis, 1,2,3, robust=FALSE)
</code></pre>

<hr>
<h2 id='BarebonesBetas'>BarebonesBetas</h2><span id='topic+BarebonesBetas'></span>

<h3>Description</h3>

<p>Gives just the beta weights from a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BarebonesBetas(data, Y = NULL, RHS = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BarebonesBetas_+3A_data">data</code></td>
<td>
<p>Data to be analyzed. Dependent variable MUST BE THE FIRST VARIABLE.</p>
</td></tr>
<tr><td><code id="BarebonesBetas_+3A_y">Y</code></td>
<td>
<p>optional. The dependent variable</p>
</td></tr>
<tr><td><code id="BarebonesBetas_+3A_rhs">RHS</code></td>
<td>
<p>option. The right hand side of the model, in R's model formulation (i.e., ~ X1+X2+etc)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of beta coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data&lt;-TestData()
BarebonesBetas(Data)
</code></pre>

<hr>
<h2 id='BCa'>BCa</h2><span id='topic+BCa'></span>

<h3>Description</h3>

<p>BCa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BCa(
  boot,
  data,
  alphalower = 0.025,
  alphaupper = 0.975,
  accelleration = "jack",
  FUN,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCa_+3A_boot">boot</code></td>
<td>
<p>A vector of bootstrap estimates of Theta</p>
</td></tr>
<tr><td><code id="BCa_+3A_data">data</code></td>
<td>
<p>The data that was analyzed via the bootstrap</p>
</td></tr>
<tr><td><code id="BCa_+3A_alphalower">alphalower</code></td>
<td>
<p>The lower alpha for CI creation</p>
</td></tr>
<tr><td><code id="BCa_+3A_alphaupper">alphaupper</code></td>
<td>
<p>The upper alpha for CI creation</p>
</td></tr>
<tr><td><code id="BCa_+3A_accelleration">accelleration</code></td>
<td>
<p>can currently take two values, &quot;jack&quot; and &quot;bootstrap&quot;. &quot;jack&quot; returns the jackknife estimate of the accelleration parameter. &quot;boot&quot; is an experimental function that uses the bootstrap estimates in the calculation of the accelleration parameter. &quot;boot&quot; is many times faster (approximately n times faster where n is the number of observations).</p>
</td></tr>
<tr><td><code id="BCa_+3A_fun">FUN</code></td>
<td>
<p>The function used to get estimates of Theta</p>
</td></tr>
<tr><td><code id="BCa_+3A_...">...</code></td>
<td>
<p>Additional arguments to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of BCa bootstrap CI's, the bias parameter and the accellation parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-DFSimulated()
boot&lt;-NaiveBoot(data, groups="Rs", keepgroups=TRUE)
boot&lt;-bootAnalysis(boot, cbind, DFanalysis, 1,2,3, robust=FALSE)
BCa(boot, data, .025,.975, accelleration="bootstrap", DFanalysis, 1,2,3, robust=FALSE)

</code></pre>

<hr>
<h2 id='bias'>Title</h2><span id='topic+bias'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bias(boot, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bias_+3A_boot">boot</code></td>
<td>
<p>A vector of bootstrap estimates of theta</p>
</td></tr>
<tr><td><code id="bias_+3A_theta">theta</code></td>
<td>
<p>the sample estimate of theta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z0 the bias parameter for BCa CI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-data.frame(rnorm(1000))
theta&lt;-mean(X)
boot&lt;-NaiveBoot(X)
boot&lt;-lapply(boot, mean)
boot&lt;-do.call(rbind, boot)
bias(boot, theta)
</code></pre>

<hr>
<h2 id='bootAnalysis'>bootAnalysis</h2><span id='topic+bootAnalysis'></span>

<h3>Description</h3>

<p>bootAnalysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootAnalysis(boot, collapse = cbind, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootAnalysis_+3A_boot">boot</code></td>
<td>
<p>A list of bootstrap resamples from NaiveBoot or uniboot.</p>
</td></tr>
<tr><td><code id="bootAnalysis_+3A_collapse">collapse</code></td>
<td>
<p>Should the results be collapsed from list form. Can take values of NULL, cbind or rbind</p>
</td></tr>
<tr><td><code id="bootAnalysis_+3A_fun">FUN</code></td>
<td>
<p>The function to apply to the bootstrap resamples</p>
</td></tr>
<tr><td><code id="bootAnalysis_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or matrix of results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-DFSimulated()
data&lt;-doubleEnter(data[,1],data[,2],data[,3])
boots&lt;-uniboot(data, 1000, "Rs", TRUE, .5, NULL)
results&lt;-bootAnalysis(boots, cbind, FUN=DFanalysis, 1,2,3,TRUE,FALSE,FALSE,TRUE,FALSE)

</code></pre>

<hr>
<h2 id='bootsample'>bootsample</h2><span id='topic+bootsample'></span>

<h3>Description</h3>

<p>bootsample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootsample(data, size = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootsample_+3A_data">data</code></td>
<td>
<p>a dataset to be bootstrapped</p>
</td></tr>
<tr><td><code id="bootsample_+3A_size">size</code></td>
<td>
<p>the size of the bootstrap sample relative to the original sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-TestData()
Y&lt;-bootsample(X)
</code></pre>

<hr>
<h2 id='cent'>cent</h2><span id='topic+cent'></span>

<h3>Description</h3>

<p>cent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cent(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cent_+3A_x">X</code></td>
<td>
<p>vector to be centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a centered vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-c(1:10)
cent(X)
</code></pre>

<hr>
<h2 id='centerData'>centerData</h2><span id='topic+centerData'></span>

<h3>Description</h3>

<p>centerData
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centerData(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centerData_+3A_data">data</code></td>
<td>
<p>The data to be centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The centered data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-data.frame(X=c(1:4),Y=c(6:9))
centerData(X)
</code></pre>

<hr>
<h2 id='cholcors'>cholcors</h2><span id='topic+cholcors'></span>

<h3>Description</h3>

<p>cholcors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholcors(X, use = "everything")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cholcors_+3A_x">X</code></td>
<td>
<p>A matrix of data.</p>
</td></tr>
<tr><td><code id="cholcors_+3A_use">use</code></td>
<td>
<p>the missing data type to use for the correlation. Default is R's default &quot;everything&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the cholesky decomposition of the correlation matrix of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-stats::rnorm(100)
Y&lt;-stats::rnorm(100)+X
Z&lt;-cbind(X,Y)
cholcors(Z)
</code></pre>

<hr>
<h2 id='cholcovs'>cholcovs</h2><span id='topic+cholcovs'></span>

<h3>Description</h3>

<p>cholcovs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholcovs(X, use = "everything")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cholcovs_+3A_x">X</code></td>
<td>
<p>A matrix of data.</p>
</td></tr>
<tr><td><code id="cholcovs_+3A_use">use</code></td>
<td>
<p>the missing data type to use for the correlation. Default is R's default &quot;everything&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the cholesky decomposition of the correlation matrix of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-stats::rnorm(100)
Y&lt;-stats::rnorm(100)+X
Z&lt;-cbind(X,Y)
cholcovs(Z)
</code></pre>

<hr>
<h2 id='DFanalysis'>DFanalysis</h2><span id='topic+DFanalysis'></span>

<h3>Description</h3>

<p>There are three possible models to be fit. The default is the Rodgers and Kohler formulation of the DF model (Rodgers &amp; Kohler, 2005). The non-default (if RK=F), is to fit the original DeFries-Fulker model. The third option is only used when dominance coefficients are provided, and is based on the formulation by Waller (Waller 1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFanalysis(
  data = NULL,
  proband,
  sibling,
  Rs,
  Ds = NULL,
  RK = T,
  robust = T,
  DE = T,
  betasonly = F,
  typicalSE = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DFanalysis_+3A_data">data</code></td>
<td>
<p>A dataframe. This is not necessary as the variables can be passed directly via the other arguments.</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_proband">proband</code></td>
<td>
<p>Called &quot;proband&quot; for historical reasons this is the variable on the left hand side of the regression.</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_sibling">sibling</code></td>
<td>
<p>The right hand side version of proband. This would be the matched sibling scores.</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_rs">Rs</code></td>
<td>
<p>This is the vector of relatedness coefficients</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_ds">Ds</code></td>
<td>
<p>A vector of dominance coefficients. 1 for MZ twins, .25 for DZ twins and full siblings. The default is null, and no value should be provided if using the ACE model. This should only have a non-null value when fitting an ADE model. There is an RK version of this model, however it is not based on published work. The RK version uses double entered (and mean centered) data in order to drop the intercept term and the extraneous regression coefficient (both of which can be constrained to 0 when the phenotypic mean is 0). Initial simulations suggest that this formulation provides accurate parameter estimates, however the original formulation can be used by simply setting RK=F. It is assumed that, if RK=T, that DE=T (i.e., do NOT double enter data prior to analysis if using the ADE model).</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_rk">RK</code></td>
<td>
<p>Use the Rodgers and Kohler simplified version of the DF model (recommended). Data should not be double entered prior to analysis.</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_robust">robust</code></td>
<td>
<p>Use the Kohler and Rodgers robust standard errors (recommeneded when using double entered data)</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_de">DE</code></td>
<td>
<p>Will the data need to be double entered?</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_betasonly">betasonly</code></td>
<td>
<p>If TRUE only the beta weights from the regression analysis will be returned.</p>
</td></tr>
<tr><td><code id="DFanalysis_+3A_typicalse">typicalSE</code></td>
<td>
<p>Should the typical regression standard errors be used? Default is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results from MyLM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TwinData&lt;-DFSimulated(2000,2000,.3,.3)
p&lt;-TwinData[,1]
s&lt;-TwinData[,2]
r&lt;-TwinData[,3]
DFanalysis(data=NULL, p,s,r)
</code></pre>

<hr>
<h2 id='DFSimulated'>DFSimulated</h2><span id='topic+DFSimulated'></span>

<h3>Description</h3>

<p>DFSimulated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFSimulated(MZ = 250, DZ = 250, a2 = 0.3, c2 = 0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DFSimulated_+3A_mz">MZ</code></td>
<td>
<p>Number of MZ twins to simulate</p>
</td></tr>
<tr><td><code id="DFSimulated_+3A_dz">DZ</code></td>
<td>
<p>Number of DZ twins to simulate</p>
</td></tr>
<tr><td><code id="DFSimulated_+3A_a2">a2</code></td>
<td>
<p>Heritability (proportion of variance)</p>
</td></tr>
<tr><td><code id="DFSimulated_+3A_c2">c2</code></td>
<td>
<p>Shared environment (proportion of variance)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TwinData&lt;-DFSimulated(200,200,.3,.3)
</code></pre>

<hr>
<h2 id='DFSimulatedChisq'>DFSimulatedChisq</h2><span id='topic+DFSimulatedChisq'></span>

<h3>Description</h3>

<p>DFSimulatedChisq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFSimulatedChisq(MZ = 250, DZ = 250, a2 = 0.3, c2 = 0.3, df = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DFSimulatedChisq_+3A_mz">MZ</code></td>
<td>
<p>Number of MZ twins to simulate</p>
</td></tr>
<tr><td><code id="DFSimulatedChisq_+3A_dz">DZ</code></td>
<td>
<p>Number of DZ twins to simulate</p>
</td></tr>
<tr><td><code id="DFSimulatedChisq_+3A_a2">a2</code></td>
<td>
<p>Heritability (proportion of variance)</p>
</td></tr>
<tr><td><code id="DFSimulatedChisq_+3A_c2">c2</code></td>
<td>
<p>Shared environment (proportion of variance)</p>
</td></tr>
<tr><td><code id="DFSimulatedChisq_+3A_df">df</code></td>
<td>
<p>Total degrees of freedom for the Chi-Square variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of Chi-Square distributed outcome observations for MZ and DZ twins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TwinData&lt;-DFSimulatedChisq(200,200,.3,.3, 10)
</code></pre>

<hr>
<h2 id='DFSimulatedChisqNew'>DFSimulatedChisqNew</h2><span id='topic+DFSimulatedChisqNew'></span>

<h3>Description</h3>

<p>DFSimulatedChisqNew
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFSimulatedChisqNew(MZ = 250, DZ = 250, a2 = 0.3, c2 = 0.3, df = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DFSimulatedChisqNew_+3A_mz">MZ</code></td>
<td>
<p>Number of MZ twins to simulate</p>
</td></tr>
<tr><td><code id="DFSimulatedChisqNew_+3A_dz">DZ</code></td>
<td>
<p>Number of DZ twins to simulate</p>
</td></tr>
<tr><td><code id="DFSimulatedChisqNew_+3A_a2">a2</code></td>
<td>
<p>Heritability (proportion of variance)</p>
</td></tr>
<tr><td><code id="DFSimulatedChisqNew_+3A_c2">c2</code></td>
<td>
<p>Shared environment (proportion of variance)</p>
</td></tr>
<tr><td><code id="DFSimulatedChisqNew_+3A_df">df</code></td>
<td>
<p>Total degrees of freedom for the Chi-Square variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of Chi-Square distributed outcome observations for MZ and DZ twins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TwinData&lt;-DFSimulatedChisqNew(200,200,.3,.3, 10)
</code></pre>

<hr>
<h2 id='doubleEnter'>DoubleEnter</h2><span id='topic+doubleEnter'></span>

<h3>Description</h3>

<p>DoubleEnter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleEnter(proband, sibling, Rs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubleEnter_+3A_proband">proband</code></td>
<td>
<p>The proband scores</p>
</td></tr>
<tr><td><code id="doubleEnter_+3A_sibling">sibling</code></td>
<td>
<p>The matched sibling scores</p>
</td></tr>
<tr><td><code id="doubleEnter_+3A_rs">Rs</code></td>
<td>
<p>The relatedness coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-DFSimulated(10,10,.2,.2)
Y&lt;-doubleEnter(X[,"proband"], X[,"sibling"], X[,"Rs"])
</code></pre>

<hr>
<h2 id='findSa'>findSa</h2><span id='topic+findSa'></span>

<h3>Description</h3>

<p>This is an implementation of the YHY bootstrap covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSa(S, fitted, p, a = 0.5, df, n, tau = NULL, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findSa_+3A_s">S</code></td>
<td>
<p>Sample covariance matrix</p>
</td></tr>
<tr><td><code id="findSa_+3A_fitted">fitted</code></td>
<td>
<p>The fitted covariance matrix</p>
</td></tr>
<tr><td><code id="findSa_+3A_p">p</code></td>
<td>
<p>the number of columns in the covariance matrix</p>
</td></tr>
<tr><td><code id="findSa_+3A_a">a</code></td>
<td>
<p>the starting value for the a parameter</p>
</td></tr>
<tr><td><code id="findSa_+3A_df">df</code></td>
<td>
<p>the degrees of freedom in the model</p>
</td></tr>
<tr><td><code id="findSa_+3A_n">n</code></td>
<td>
<p>the number of participants in the model</p>
</td></tr>
<tr><td><code id="findSa_+3A_tau">tau</code></td>
<td>
<p>the population tau. If no tau is provided, the estimated tau from the model will be used</p>
</td></tr>
<tr><td><code id="findSa_+3A_tol">tol</code></td>
<td>
<p>the difference between ga and tau at which the function will converge</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the &quot;a&quot; adjusted covariance matrix, Sa, the tau, ga, and the number of interations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(Omisc)
require(lavaan)
set.seed(2^7-1)
modelTest&lt;-'
LV1=~ .7*x1+.8*x2+.75*x3+.6*x4
LV2=~ .7*y1+.8*y2+.75*y3+.6*y4
LV1~~.3*LV2
LV1~~1*LV1
LV2~~1*LV2
'
modelFit&lt;-'
LV1=~ x1+x2+x3+x4
LV2=~ y1+y2+y3+y4
LV1~~start(.5)*LV2
LV1~~1*LV1
LV2~~1*LV2
'

testdata&lt;-simulateData(modelTest, sample.nobs = 250)
fit&lt;-cfa(modelFit, testdata)

fitted&lt;-fitted(fit)$cov
fitted&lt;-fitted[,1:ncol(fitted)]
S&lt;-cov(testdata)
p&lt;-8
a&lt;-.5
n&lt;-250
df&lt;-21
findSa(S, fitted, p, .5, df, n)
</code></pre>

<hr>
<h2 id='Group_function'>Grouping_function</h2><span id='topic+Group_function'></span>

<h3>Description</h3>

<p>originally from the ParallelTree package. If data argument is Null, takes a variable &quot;x&quot; and a matrix or dataframe of level identifiers (e.g., mother and then child IDs). Level variables should be included in order from highest level to the lowest. Listwise deletes missing data. Otherwise grabs variables from entered dataframe
Group_function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Group_function(
  data = NULL,
  x,
  levels,
  func = mean,
  center = FALSE,
  nested = TRUE,
  append = FALSE,
  funcName = "Mean"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Group_function_+3A_data">data</code></td>
<td>
<p>a data frame with the x and level variables included. Default is NULL.</p>
</td></tr>
<tr><td><code id="Group_function_+3A_x">x</code></td>
<td>
<p>If data = NULL a dataframe of scores to have the function applied to. If data != NULL, a  vector of string(s) naming the variable(s) in data to use.</p>
</td></tr>
<tr><td><code id="Group_function_+3A_levels">levels</code></td>
<td>
<p>If data = NULL, a dataframe of grouping variables. If data != NULL, a vector of strings naming the variables in data to use. levels should be ordered from the highest level to the lowest. Group and case identifiers should be unique, if they are not unique, cases with non-unique identifiers will be grouped together.</p>
</td></tr>
<tr><td><code id="Group_function_+3A_func">func</code></td>
<td>
<p>A function to apply at each group. Default is mean.</p>
</td></tr>
<tr><td><code id="Group_function_+3A_center">center</code></td>
<td>
<p>If set to true variables will be group/person mean centered. Note that the grand mean remains unchanged by this operation. If this output is to be passed directly to Parallel_Tree the grand mean should be set to 0.</p>
</td></tr>
<tr><td><code id="Group_function_+3A_nested">nested</code></td>
<td>
<p>Are level variables nested? Default is TRUE. If set to FALSE means will be calculated for level variable independently. FALSE may be useful in cases of crossed designs. Note that if data are nested but all identifiers are unique both within and across groups nested = FALSE and nested = TRUE will return the same result.</p>
</td></tr>
<tr><td><code id="Group_function_+3A_append">append</code></td>
<td>
<p>If set to true, the original data will be returned along with all created variables.</p>
</td></tr>
<tr><td><code id="Group_function_+3A_funcname">funcName</code></td>
<td>
<p>Provides way to name function used. This is used when creating names for created variables. Default is &quot;Mean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a dataframe with variables labeled according to the level at which the function was applied. Assumed function is mean, and all variables are labeled accordingly. If an alternative function is used labels should be manually changed to reflect function used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#the ChickWeight data is from base R
#nested is set to false because Chick and Time are crossed
Means_Chick&lt;-Group_function(data=ChickWeight,x="weight", levels =c("Diet","Chick","Time"),
nested = FALSE, append=TRUE)
</code></pre>

<hr>
<h2 id='HoffPseudoStandard'>HoffPseudoStandard</h2><span id='topic+HoffPseudoStandard'></span>

<h3>Description</h3>

<p>HoffPseudoStandard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HoffPseudoStandard(betas, SDX, interceptvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HoffPseudoStandard_+3A_betas">betas</code></td>
<td>
<p>A vector of betas from a multilevel model</p>
</td></tr>
<tr><td><code id="HoffPseudoStandard_+3A_sdx">SDX</code></td>
<td>
<p>A vector of the standard deviations of the X value for each of the X's associated with the bets</p>
</td></tr>
<tr><td><code id="HoffPseudoStandard_+3A_interceptvar">interceptvar</code></td>
<td>
<p>A vector of the intercept variances at the level associated with the betas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of pseudostandardized coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("none")
</code></pre>

<hr>
<h2 id='jackknife'>jackknife</h2><span id='topic+jackknife'></span>

<h3>Description</h3>

<p>jackknife
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jackknife(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jackknife_+3A_data">data</code></td>
<td>
<p>The data to jackknife</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of jackknife datasets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-cbind(1:10,1:10)
result&lt;-jackknife(data)
lapply(result,mean)

</code></pre>

<hr>
<h2 id='justBetas'>justBetas</h2><span id='topic+justBetas'></span>

<h3>Description</h3>

<p>justBetas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>justBetas(data, Y, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="justBetas_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="justBetas_+3A_y">Y</code></td>
<td>
<p>The name or column number of the Y variable</p>
</td></tr>
<tr><td><code id="justBetas_+3A_x">X</code></td>
<td>
<p>The name(s) or column number(s) of the X variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of unstandardized beta weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-stats::rnorm(100)
Y&lt;-stats::rnorm(100)+5*(X)
data&lt;-cbind(Y,X)
justBetas(data,1,2)
#if you want an intercept
Y&lt;-stats::rnorm(100)+5*(X)+5
data&lt;-cbind(Y,X,1)
justBetas(data,1,c(2:3))
</code></pre>

<hr>
<h2 id='lbind'>lbind</h2><span id='topic+lbind'></span>

<h3>Description</h3>

<p>lbind is meant to be used in conjuction with lapply to combine elements of lists using rbind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbind(index, alist, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbind_+3A_index">index</code></td>
<td>
<p>a list of indexes. This should count the number of items to return in the final list</p>
</td></tr>
<tr><td><code id="lbind_+3A_alist">alist</code></td>
<td>
<p>a list of objects to be passed to rbind. They should be grouped according to which objects will be combined (e.g., if 1,2,3 are to be passed to cbind then they should be adjacent to eachother).</p>
</td></tr>
<tr><td><code id="lbind_+3A_n">n</code></td>
<td>
<p>The number of objects in each group. Currently each group must consist of the same number of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alist&lt;-list(c(1,1),c(2,2),c(3,3))
index&lt;-list(1)
n&lt;-3
lapply(index,lbind,alist,3)
</code></pre>

<hr>
<h2 id='leave1out'>leave1out</h2><span id='topic+leave1out'></span>

<h3>Description</h3>

<p>leave1out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leave1out(x, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leave1out_+3A_x">x</code></td>
<td>
<p>Which row(s) of data to leave out</p>
</td></tr>
<tr><td><code id="leave1out_+3A_data">data</code></td>
<td>
<p>A dataframe or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reduced dataframe or matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-cbind(1:10,1:10)
leave1out(5,data)

</code></pre>

<hr>
<h2 id='MyLM'>MyLM</h2><span id='topic+MyLM'></span>

<h3>Description</h3>

<p>MyLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MyLM(Y, X, robust = F, betasonly = F, typicalSE = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MyLM_+3A_y">Y</code></td>
<td>
<p>The Y variable</p>
</td></tr>
<tr><td><code id="MyLM_+3A_x">X</code></td>
<td>
<p>A matrix of X variables</p>
</td></tr>
<tr><td><code id="MyLM_+3A_robust">robust</code></td>
<td>
<p>Should robust standard errors be calculated? Assumes a double entered twin dataset with twins evenly spaced in the dataset.</p>
</td></tr>
<tr><td><code id="MyLM_+3A_betasonly">betasonly</code></td>
<td>
<p>Should only the betas be returned? Good for bootstrapping</p>
</td></tr>
<tr><td><code id="MyLM_+3A_typicalse">typicalSE</code></td>
<td>
<p>Should the typical standard errors be included? Default is true. Can be true when robust is True.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of betas and standard errors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-DFSimulated(100,100,.4,.4)
Y&lt;-RK(X[,1],X[,2],X[,3])
MyLM(Y[,1],Y[,c(2:3)],TRUE)
</code></pre>

<hr>
<h2 id='NaiveBoot'>The Naive Bootstrap</h2><span id='topic+NaiveBoot'></span>

<h3>Description</h3>

<p>The Naive Bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NaiveBoot(data, B = 1000, groups = NULL, keepgroups = F, size = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NaiveBoot_+3A_data">data</code></td>
<td>
<p>data to be bootstrapped</p>
</td></tr>
<tr><td><code id="NaiveBoot_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples to take</p>
</td></tr>
<tr><td><code id="NaiveBoot_+3A_groups">groups</code></td>
<td>
<p>grouping variable if there is one</p>
</td></tr>
<tr><td><code id="NaiveBoot_+3A_keepgroups">keepgroups</code></td>
<td>
<p>keep the grouping variable?</p>
</td></tr>
<tr><td><code id="NaiveBoot_+3A_size">size</code></td>
<td>
<p>size of the bootstrap resamples relative to the original sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of bootstrap resamples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-TestData()
Y&lt;-NaiveBoot(X)
</code></pre>

<hr>
<h2 id='NaiveBoot_dep'>The Naive Bootstrap</h2><span id='topic+NaiveBoot_dep'></span>

<h3>Description</h3>

<p>The Naive Bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NaiveBoot_dep(data, B = 1000, groups = NULL, keepgroups = F, size = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NaiveBoot_dep_+3A_data">data</code></td>
<td>
<p>data to be bootstrapped</p>
</td></tr>
<tr><td><code id="NaiveBoot_dep_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples to take</p>
</td></tr>
<tr><td><code id="NaiveBoot_dep_+3A_groups">groups</code></td>
<td>
<p>grouping variable if there is one</p>
</td></tr>
<tr><td><code id="NaiveBoot_dep_+3A_keepgroups">keepgroups</code></td>
<td>
<p>keep the grouping variable?</p>
</td></tr>
<tr><td><code id="NaiveBoot_dep_+3A_size">size</code></td>
<td>
<p>size of the bootstrap resamples relative to the original sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of bootstrap resamples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-TestData()
Y&lt;-NaiveBoot(X)
</code></pre>

<hr>
<h2 id='resample'>resample</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>resample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(X, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_+3A_x">X</code></td>
<td>
<p>A vector to be resamples</p>
</td></tr>
<tr><td><code id="resample_+3A_size">size</code></td>
<td>
<p>The size of the resulting vector. Should be a number such that size*nrow(X) is a whole number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of resampled X values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-c(1:10)
resample(X,.5)
</code></pre>

<hr>
<h2 id='RK'>RK</h2><span id='topic+RK'></span>

<h3>Description</h3>

<p>RK
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK(proband, sibling, Rs, DE = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RK_+3A_proband">proband</code></td>
<td>
<p>column name or number of the proband</p>
</td></tr>
<tr><td><code id="RK_+3A_sibling">sibling</code></td>
<td>
<p>column name or number of the siblings</p>
</td></tr>
<tr><td><code id="RK_+3A_rs">Rs</code></td>
<td>
<p>column name or number of the relatedness coefficients</p>
</td></tr>
<tr><td><code id="RK_+3A_de">DE</code></td>
<td>
<p>Should the data be double entered?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-DFSimulated(100,100,.3,.3)
Y&lt;-RK(X[,1],X[,2],X[,3])
</code></pre>

<hr>
<h2 id='Sfunc'>Sfunc</h2><span id='topic+Sfunc'></span>

<h3>Description</h3>

<p>function for calculating the matrices for the Kohler Rodgers SE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sfunc(X, e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sfunc_+3A_x">X</code></td>
<td>
<p>A matrix of X variables</p>
</td></tr>
<tr><td><code id="Sfunc_+3A_e">e</code></td>
<td>
<p>A matrix of error terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("Nah")
</code></pre>

<hr>
<h2 id='standardBootIntervals'>standardBootIntervals</h2><span id='topic+standardBootIntervals'></span>

<h3>Description</h3>

<p>This returns the quantiles of the bootstrap samples specified by the user. The quantiles uses the type=4 argument of the quantile function, which appears to function best.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardBootIntervals(boot, lower = 0.025, upper = 0.975)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardBootIntervals_+3A_boot">boot</code></td>
<td>
<p>A vector of bootstrap results</p>
</td></tr>
<tr><td><code id="standardBootIntervals_+3A_lower">lower</code></td>
<td>
<p>the lower alpha</p>
</td></tr>
<tr><td><code id="standardBootIntervals_+3A_upper">upper</code></td>
<td>
<p>the upper alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the mean, median, min, max, lower and upper CI values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-DFSimulated()
boots&lt;-NaiveBoot(data, groups="Rs", keepgroups=TRUE, B=100)
boots&lt;-bootAnalysis(boots, cbind, DFanalysis,1,2,3,TRUE,FALSE,TRUE,TRUE,FALSE)
apply(boots,1, standardBootIntervals)
DFanalysis(data,1,2,3)
</code></pre>

<hr>
<h2 id='TestData'>TestData</h2><span id='topic+TestData'></span>

<h3>Description</h3>

<p>Simple function for creating a dataset of two related variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestData(nobs = 1000, intercept = 0, beta = 5, meanX = 0, sdX = 1, sdYerr = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TestData_+3A_nobs">nobs</code></td>
<td>
<p>Number of observations, defaults to 1000</p>
</td></tr>
<tr><td><code id="TestData_+3A_intercept">intercept</code></td>
<td>
<p>Intercept of the regression. Defaults to 0</p>
</td></tr>
<tr><td><code id="TestData_+3A_beta">beta</code></td>
<td>
<p>Beta for the regression equation, defaults to 5</p>
</td></tr>
<tr><td><code id="TestData_+3A_meanx">meanX</code></td>
<td>
<p>Mean of X, defaults to 0</p>
</td></tr>
<tr><td><code id="TestData_+3A_sdx">sdX</code></td>
<td>
<p>Standard deviation of X, defaults to 1</p>
</td></tr>
<tr><td><code id="TestData_+3A_sdyerr">sdYerr</code></td>
<td>
<p>Variance of the error term of Y, defaults to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with an X and Y variable produced by the entered parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-TestData()
</code></pre>

<hr>
<h2 id='uniboot'>Univariate Bootstrap</h2><span id='topic+uniboot'></span>

<h3>Description</h3>

<p>WARNING: This function can't be used with data that is already fed through the RK function. The correlation matrix will not be positive definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniboot(
  data,
  B = 1000,
  groups = NULL,
  keepgroups = F,
  size = 1,
  HIcor = NULL,
  samplefrom = "group",
  use = "everything",
  standardized = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniboot_+3A_data">data</code></td>
<td>
<p>The data frame to be resampled</p>
</td></tr>
<tr><td><code id="uniboot_+3A_b">B</code></td>
<td>
<p>The number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="uniboot_+3A_groups">groups</code></td>
<td>
<p>A grouping variable name</p>
</td></tr>
<tr><td><code id="uniboot_+3A_keepgroups">keepgroups</code></td>
<td>
<p>Should the grouping variable be kept in the final datasets?</p>
</td></tr>
<tr><td><code id="uniboot_+3A_size">size</code></td>
<td>
<p>The size of the bootstrap sample to be returned. Should be as a proportion and must be evenly divided into nrow(data).</p>
</td></tr>
<tr><td><code id="uniboot_+3A_hicor">HIcor</code></td>
<td>
<p>If a hypothesis imposed correlation matrix is to be used, this argument takes a list of hypothesized correlation matrices. IT MUST BE A LIST OF ONE OR MORE MATRICES. Multiple matrices can be entered in the case of grouped data (one for each group). If the nil-null correlation is to be used an identity matrix can be entered here (the same size as the appropriate correlation matrix).</p>
</td></tr>
<tr><td><code id="uniboot_+3A_samplefrom">samplefrom</code></td>
<td>
<p>Takes one of either &quot;group&quot; or &quot;whole&quot;. When doing bootstrapping of grouped data this tells uniboot if the whole sample should be used as the sampling frame for each group (whole), or not (group). &quot;group&quot; should be used unless it is believed that all groups share the same underlying marginal distribution for each variable (e.g., the same mean and variance in the case of normally distributed data).</p>
</td></tr>
<tr><td><code id="uniboot_+3A_use">use</code></td>
<td>
<p>The missing data method for cor. Default is R's default &quot;everything&quot;.</p>
</td></tr>
<tr><td><code id="uniboot_+3A_standardized">standardized</code></td>
<td>
<p>should the resampled data be standardized? The default is TRUE. This is computationally more efficient (the data are standardized as a step during the diagonalization procedure).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bootstrap samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-TestData()
X&lt;-uniboot(data,1000)
</code></pre>

<hr>
<h2 id='uniboot_dep'>Univariate Bootstrap</h2><span id='topic+uniboot_dep'></span>

<h3>Description</h3>

<p>WARNING: This function can't be used with data that is already fed through the RK function. The correlation matrix will not be positive definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniboot_dep(
  data,
  B = 1000,
  groups = NULL,
  keepgroups = F,
  size = 1,
  HIcor = NULL,
  samplefrom = "group",
  use = "everything"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniboot_dep_+3A_data">data</code></td>
<td>
<p>The data frame to be resampled</p>
</td></tr>
<tr><td><code id="uniboot_dep_+3A_b">B</code></td>
<td>
<p>The number of bootstrap samples. Alternatively &quot;sampleframe&quot; which will return the univariate sampling frame. &quot;samplefrom&quot; is not advised when there are many observations and/or many variables as the returned dataframe will be quite large.</p>
</td></tr>
<tr><td><code id="uniboot_dep_+3A_groups">groups</code></td>
<td>
<p>A grouping variable name</p>
</td></tr>
<tr><td><code id="uniboot_dep_+3A_keepgroups">keepgroups</code></td>
<td>
<p>Should the grouping variable be kept in the final datasets?</p>
</td></tr>
<tr><td><code id="uniboot_dep_+3A_size">size</code></td>
<td>
<p>The size of the bootstrap sample to be returned. Should be as a proportion and must be evenly divided into nrow(data).</p>
</td></tr>
<tr><td><code id="uniboot_dep_+3A_hicor">HIcor</code></td>
<td>
<p>If a hypothesis imposed correlation matrix is to be used, this argument takes a list of hypothesized correlation matrices. IT MUST BE A LIST OF ONE OR MORE MATRICES. Multiple matrices can be entered in the case of grouped data (one for each group). If the nil-null correlation is to be used an identity matrix can be entered here (the same size as the appropriate correlation matrix).</p>
</td></tr>
<tr><td><code id="uniboot_dep_+3A_samplefrom">samplefrom</code></td>
<td>
<p>Takes one of either &quot;group&quot; or &quot;whole&quot;. When doing bootstrapping of grouped data this tells uniboot if the whole sample should be used as the sampling frame for each group (whole), or not (group). &quot;group&quot; should be used unless it is believed that all groups share the same underlying marginal distribution for each variable (e.g., the same mean and variance in the case of normally distributed data).</p>
</td></tr>
<tr><td><code id="uniboot_dep_+3A_use">use</code></td>
<td>
<p>The missing data method for cor. Default is R's default &quot;everything&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bootstrap samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data&lt;-TestData()
X&lt;-uniboot(data,1000)
</code></pre>

<hr>
<h2 id='unibootsample'>unibootsample</h2><span id='topic+unibootsample'></span>

<h3>Description</h3>

<p>unibootsample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unibootsample(data, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unibootsample_+3A_data">data</code></td>
<td>
<p>A dataframe or matrix to be univariately bootstrapped</p>
</td></tr>
<tr><td><code id="unibootsample_+3A_size">size</code></td>
<td>
<p>size of each bootstrap sample as a fraction of the total sample size. Total sample size must be evenly divisible by &quot;size&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or dataframe with nrow=nrow(X)*size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-c(0:9)
Y&lt;-c(20:29)
Z&lt;-cbind(X,Y)
unibootsample(Z,1)
</code></pre>

<hr>
<h2 id='unibootVar'>unibootVar</h2><span id='topic+unibootVar'></span>

<h3>Description</h3>

<p>unibootVar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unibootVar(X, times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unibootVar_+3A_x">X</code></td>
<td>
<p>The variable</p>
</td></tr>
<tr><td><code id="unibootVar_+3A_times">times</code></td>
<td>
<p>The number of times the variable is repeated in the univariate sampling frame. This is going to be equal to the number of variables being univariately sampled</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance of the variable in the univariate sampling frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-c(1,2)
times&lt;-100
unibootVar(X,times)
var(X)
</code></pre>

<hr>
<h2 id='zScore'>Title</h2><span id='topic+zScore'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zScore(X, reps = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zScore_+3A_x">X</code></td>
<td>
<p>The vector to be turned into z scores</p>
</td></tr>
<tr><td><code id="zScore_+3A_reps">reps</code></td>
<td>
<p>The number of reps the vector is to be repeated. This will only be used in univariate bootstrapping. The default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of z scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-c(1:10)
zScore(X)
</code></pre>

<hr>
<h2 id='zScoreData'>centerData</h2><span id='topic+zScoreData'></span>

<h3>Description</h3>

<p>centerData
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zScoreData(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zScoreData_+3A_data">data</code></td>
<td>
<p>The data to be converted to z scores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data converted to z scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-data.frame(X=c(1:4),Y=c(6:9))
zScoreData(X)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
