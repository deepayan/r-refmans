<!DOCTYPE html><html><head><title>Help for package qtl2convert</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtl2convert}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qtl2convert-package'><p>qtl2convert: Convert Data among QTL Mapping Packages</p></a></li>
<li><a href='#cbind_smother'><p>Combine matrices by columns, replacing matching ones and adding unique ones</p></a></li>
<li><a href='#count_unique_geno'><p>Count the unique genotypes for each row of a genotype matrix</p></a></li>
<li><a href='#cross2_do_to_genail8'><p>Convert cross2 object from do to genail8</p></a></li>
<li><a href='#cross2_ril_to_genril'><p>Convert cross2 object from ril to genril</p></a></li>
<li><a href='#encode_geno'><p>Encode a matrix of genotypes using a set of allele codes</p></a></li>
<li><a href='#find_consensus_geno'><p>Find the consensus genotype for each row of a genotype matrix</p></a></li>
<li><a href='#find_unique_geno'><p>Find the unique genotypes for each row of a genotype matrix</p></a></li>
<li><a href='#map_df_to_list'><p>Marker map data frame to list</p></a></li>
<li><a href='#map_list_to_df'><p>Marker map list to data frame</p></a></li>
<li><a href='#probs_doqtl_to_qtl2'><p>Convert DOQTL genotype probabilities to R/qtl2 format</p></a></li>
<li><a href='#probs_qtl_to_qtl2'><p>Convert R/qtl genotype probabilities to R/qtl2 format</p></a></li>
<li><a href='#probs_qtl2_to_array'><p>Convert R/qtl2 genotype probabilities to a 3d array</p></a></li>
<li><a href='#probs_qtl2_to_doqtl'><p>Convert R/qtl2 genotype probabilities to DOQTL format</p></a></li>
<li><a href='#scan_qtl_to_qtl2'><p>Convert R/qtl scanone results to R/qtl2 scan1 format</p></a></li>
<li><a href='#scan_qtl2_to_qtl'><p>Convert scan1 results to the scanone format</p></a></li>
<li><a href='#write2csv'><p>Write a data frame to a CSV file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.30</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Convert Data among QTL Mapping Packages</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to convert data structures among the 'qtl2', 'qtl', and 'DOQTL' packages for mapping quantitative trait loci (QTL).</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl W Broman <a href="https://orcid.org/0000-0002-4914-6671"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karl W Broman &lt;broman@wisc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12), qtl (&ge; 1.40-8), qtl2 (&ge; 0.18), utils,
stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, devtools, roxygen2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kbroman.org/qtl2/">https://kbroman.org/qtl2/</a>, <a href="https://github.com/rqtl/qtl2convert">https://github.com/rqtl/qtl2convert</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rqtl/qtl2convert/issues">https://github.com/rqtl/qtl2convert/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 18:31:38 UTC; kbroman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='qtl2convert-package'>qtl2convert: Convert Data among QTL Mapping Packages</h2><span id='topic+qtl2convert'></span><span id='topic+qtl2convert-package'></span>

<h3>Description</h3>

<p>Functions to convert data structures among the 'qtl2', 'qtl', and 'DOQTL' packages for mapping quantitative trait loci (QTL).
</p>


<h3>Vignettes</h3>


<ul>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/user_guide.html">user guide</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/input_files.html">input file formats</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/pages/prep_do_data.html">preparing DO mouse data for R/qtl2</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/rqtl_diff.html">differences between R/qtl and R/qtl2</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">developer guide</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> (<a href="https://orcid.org/0000-0002-4914-6671">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://kbroman.org/qtl2/">https://kbroman.org/qtl2/</a>
</p>
</li>
<li> <p><a href="https://github.com/rqtl/qtl2convert">https://github.com/rqtl/qtl2convert</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rqtl/qtl2convert/issues">https://github.com/rqtl/qtl2convert/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cbind_smother'>Combine matrices by columns, replacing matching ones and adding unique ones</h2><span id='topic+cbind_smother'></span>

<h3>Description</h3>

<p>This is like <code><a href="base.html#topic+cbind">base::cbind()</a></code> but if a column in the second matrix
has the same name as a column in the first matrix, the column in
the first matrix is deleted and that in the second matrix is used
in its place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind_smother(mat1, mat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind_smother_+3A_mat1">mat1</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="cbind_smother_+3A_mat2">mat2</code></td>
<td>
<p>Another matrix, with the same number of rows as <code>mat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The two matrices combined by columns, but columns in the
first matrix that also appear in the second matrix are deleted
and replaced by those in the second matrix. Uses the row names
to align the rows in the two matrices, and to expand them as needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(x=c(1,2,3,NA,4), y=c(5,8,9,10,11), row.names=c("A", "B", "C", "D", "E"))
df2 &lt;- data.frame(z=c(7,8,0,9,10), y=c(6,NA,NA,9,10), row.names=c("A", "B", "F", "C", "D"))
df1n2 &lt;- cbind_smother(df1, df2)
</code></pre>

<hr>
<h2 id='count_unique_geno'>Count the unique genotypes for each row of a genotype matrix</h2><span id='topic+count_unique_geno'></span>

<h3>Description</h3>

<p>For genotype data (markers x individuals) on a set of individuals,
count the unique genotypes for each marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_unique_geno(genotypes, na.strings = c("N", "H", "NA", ""), cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_unique_geno_+3A_genotypes">genotypes</code></td>
<td>
<p>Matrix of genotypes (markers x individuals)</p>
</td></tr>
<tr><td><code id="count_unique_geno_+3A_na.strings">na.strings</code></td>
<td>
<p>Genotypes to be considered as missing values.</p>
</td></tr>
<tr><td><code id="count_unique_geno_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of counts of unique genotypes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_unique_geno">find_unique_geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- rbind(c("NA", "A",  "A",  "A", "T"),
           c("NA", "NA", "NA", "A", "A"),
           c("A",  "A",  "T",  "G", "G"),
           c("C", "C",  "G",  "G", "NA"))
counts &lt;- count_unique_geno(g)
</code></pre>

<hr>
<h2 id='cross2_do_to_genail8'>Convert cross2 object from do to genail8</h2><span id='topic+cross2_do_to_genail8'></span><span id='topic+cross2_do_to_genail'></span>

<h3>Description</h3>

<p>Convert a cross2 object from cross type <code>"do"</code> to cross type <code>"genail8"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross2_do_to_genail8(cross)

cross2_do_to_genail(cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross2_do_to_genail8_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>, as produced by
<code><a href="qtl2.html#topic+read_cross2">qtl2::read_cross2()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>cross</code> with cross type changed to
class <code>"genail8"</code> and the cross information revised to match.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/DOex/DOex.zip")
DOex &lt;- read_cross2(file)

DOex_genail &lt;- cross2_do_to_genail8(DOex)

## End(Not run)
</code></pre>

<hr>
<h2 id='cross2_ril_to_genril'>Convert cross2 object from ril to genril</h2><span id='topic+cross2_ril_to_genril'></span>

<h3>Description</h3>

<p>Convert a cross2 object from cross type <code>"risibn"</code> to cross type <code>"genriln"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross2_ril_to_genril(cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross2_ril_to_genril_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>, as produced by
<code><a href="qtl2.html#topic+read_cross2">qtl2::read_cross2()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>cross</code> with cross type changed to
class <code>"genriln"</code> for some value of <code>n</code>,
and the cross information revised to match.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/CC/cc.zip")
cc &lt;- read_cross2(file)

cc_genril &lt;- cross2_ril_to_genril(cc)

## End(Not run)

## Not run: 
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/ArabMAGIC/arabmagic_tair9.zip")
arab &lt;- read_cross2(file)

arab_genril &lt;- cross2_ril_to_genril(arab)

## End(Not run)
</code></pre>

<hr>
<h2 id='encode_geno'>Encode a matrix of genotypes using a set of allele codes</h2><span id='topic+encode_geno'></span>

<h3>Description</h3>

<p>Encode a matrix of genotypes using a set of allele codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_geno(
  geno,
  allele_codes,
  output_codes = c("-", "A", "H", "B"),
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_geno_+3A_geno">geno</code></td>
<td>
<p>Character matrix of genotypes (rows as markers, columns as individuals)</p>
</td></tr>
<tr><td><code id="encode_geno_+3A_allele_codes">allele_codes</code></td>
<td>
<p>Two-column matrix of alleles (rows as markers)</p>
</td></tr>
<tr><td><code id="encode_geno_+3A_output_codes">output_codes</code></td>
<td>
<p>Vector of length four, with missing, AA, AB, BB codes</p>
</td></tr>
<tr><td><code id="encode_geno_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of same dimensions as <code>geno</code>, but with values in <code>output_codes</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_consensus_geno">find_consensus_geno()</a></code>, <code><a href="#topic+find_unique_geno">find_unique_geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno &lt;- rbind(c("C", "G", "C",  "GG", "CG"),
              c("A", "A", "AT", "TA", "TT"),
              c("T", "G", NA,   "GT", "TT"))
codes &lt;- rbind(c("C", "G"), c("A", "T"), c("T", "G"))
geno_encoded &lt;- encode_geno(geno, codes)

</code></pre>

<hr>
<h2 id='find_consensus_geno'>Find the consensus genotype for each row of a genotype matrix</h2><span id='topic+find_consensus_geno'></span>

<h3>Description</h3>

<p>For genotype data (markers x individuals) on a set of individuals
from a single inbred line, find the consensus genotype at each
marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_consensus_geno(genotypes, na.strings = c("N", "H", "NA", ""), cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_consensus_geno_+3A_genotypes">genotypes</code></td>
<td>
<p>Matrix of genotypes (markers x individuals)</p>
</td></tr>
<tr><td><code id="find_consensus_geno_+3A_na.strings">na.strings</code></td>
<td>
<p>Genotypes to be considered as missing values.</p>
</td></tr>
<tr><td><code id="find_consensus_geno_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of consensus genotypes, one value per row of <code>genotypes</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_unique_geno">find_unique_geno()</a></code>, <code><a href="#topic+encode_geno">encode_geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- rbind(c("NA", "N", "A", "A", "T", "G", NA, "H"),
           c("C",  "C", "G", "G", "A", NA,  NA, NA),
           rep(NA, 8),
           c("C", "C", "G", "G", "G", "C", "G", "G"))
consensus &lt;- find_consensus_geno(g)
</code></pre>

<hr>
<h2 id='find_unique_geno'>Find the unique genotypes for each row of a genotype matrix</h2><span id='topic+find_unique_geno'></span>

<h3>Description</h3>

<p>For genotype data (markers x individuals) on a set of individuals,
find the unique genotypes for each marker, provided that there are exactly two.
(If more than two or fewer than two, return NAs.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_unique_geno(genotypes, na.strings = c("N", "H", "NA", ""), cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_unique_geno_+3A_genotypes">genotypes</code></td>
<td>
<p>Matrix of genotypes (markers x individuals)</p>
</td></tr>
<tr><td><code id="find_unique_geno_+3A_na.strings">na.strings</code></td>
<td>
<p>Genotypes to be considered as missing values.</p>
</td></tr>
<tr><td><code id="find_unique_geno_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with two columns. Each row corresponds to a marker,
and has the two unique genotypes, or <code>NA</code>s (if &gt;2 or &lt;2 unique
genotypes).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+count_unique_geno">count_unique_geno()</a></code>, <code><a href="#topic+encode_geno">encode_geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- rbind(c("NA", "A",  "A",  "A", "T"),
           c("NA", "NA", "NA", "A", "A"),
           c("A",  "A",  "T",  "G", "G"),
           c("C", "C",  "G",  "G", "NA"))
ug &lt;- find_unique_geno(g)
</code></pre>

<hr>
<h2 id='map_df_to_list'>Marker map data frame to list</h2><span id='topic+map_df_to_list'></span>

<h3>Description</h3>

<p>Convert a marker map organized as data frame to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_df_to_list(
  map,
  chr_column = "chr",
  pos_column = "cM",
  marker_column = "marker",
  Xchr = c("x", "X")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_df_to_list_+3A_map">map</code></td>
<td>
<p>Data frame with marker map</p>
</td></tr>
<tr><td><code id="map_df_to_list_+3A_chr_column">chr_column</code></td>
<td>
<p>Name of the column in <code>map</code> that contains the chromosome IDs.</p>
</td></tr>
<tr><td><code id="map_df_to_list_+3A_pos_column">pos_column</code></td>
<td>
<p>Name of the column in <code>map</code> that contains the marker positions.</p>
</td></tr>
<tr><td><code id="map_df_to_list_+3A_marker_column">marker_column</code></td>
<td>
<p>Name of the column in <code>map</code> that contains
the marker names. If NULL, use the row names.</p>
</td></tr>
<tr><td><code id="map_df_to_list_+3A_xchr">Xchr</code></td>
<td>
<p>Vector of character strings indicating the name or
names of the X chromosome. If NULL, assume there's no X
chromosome.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of marker positions, one component per chromosome
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map_list_to_df">map_list_to_df()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map &lt;- data.frame(chr=c(1,1,1,  2,2,2,   "X","X"),
                  pos=c(0,5,10, 0,8,16,  5,20),
                  marker=c("D1M1","D1M2","D1M3",    "D2M1","D2M2","D2M3",   "DXM1","DXM2"))
map_list &lt;- map_df_to_list(map, pos_column="pos")

</code></pre>

<hr>
<h2 id='map_list_to_df'>Marker map list to data frame</h2><span id='topic+map_list_to_df'></span>

<h3>Description</h3>

<p>Convert a marker map organized as a list to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_list_to_df(
  map_list,
  chr_column = "chr",
  pos_column = "pos",
  marker_column = "marker"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_list_to_df_+3A_map_list">map_list</code></td>
<td>
<p>List of vectors containing marker positions</p>
</td></tr>
<tr><td><code id="map_list_to_df_+3A_chr_column">chr_column</code></td>
<td>
<p>Name of the chromosome column in the output</p>
</td></tr>
<tr><td><code id="map_list_to_df_+3A_pos_column">pos_column</code></td>
<td>
<p>Name of the position column in the output</p>
</td></tr>
<tr><td><code id="map_list_to_df_+3A_marker_column">marker_column</code></td>
<td>
<p>Name of the marker column in the output.
If NULL, just put them as row names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the marker positions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map_df_to_list">map_df_to_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl2)
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
iron_map &lt;- map_list_to_df(iron$gmap)

</code></pre>

<hr>
<h2 id='probs_doqtl_to_qtl2'>Convert DOQTL genotype probabilities to R/qtl2 format</h2><span id='topic+probs_doqtl_to_qtl2'></span>

<h3>Description</h3>

<p>Convert DOQTL genotype probabilities to R/qtl2 format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs_doqtl_to_qtl2(
  probs,
  map,
  is_female = NULL,
  chr_column = "chr",
  pos_column = "cM",
  marker_column = "marker"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probs_doqtl_to_qtl2_+3A_probs">probs</code></td>
<td>
<p>3d array of genotype probabilities as calculated from DOQTL
(individuals x genotypes x positions)</p>
</td></tr>
<tr><td><code id="probs_doqtl_to_qtl2_+3A_map">map</code></td>
<td>
<p>Data frame with marker map</p>
</td></tr>
<tr><td><code id="probs_doqtl_to_qtl2_+3A_is_female">is_female</code></td>
<td>
<p>Optional logical vector indicating which
individuals are female. Names should contain the individual
identifiers, matching the row names in <code>probs</code>.</p>
</td></tr>
<tr><td><code id="probs_doqtl_to_qtl2_+3A_chr_column">chr_column</code></td>
<td>
<p>Name of the column in <code>map</code> that contains the chromosome IDs.</p>
</td></tr>
<tr><td><code id="probs_doqtl_to_qtl2_+3A_pos_column">pos_column</code></td>
<td>
<p>Name of the column in <code>map</code> that contains the marker positions.</p>
</td></tr>
<tr><td><code id="probs_doqtl_to_qtl2_+3A_marker_column">marker_column</code></td>
<td>
<p>Name of the column in <code>map</code> that contains
the marker names. If NULL, use the row names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that the X chromosome is labeled <code>"X"</code> (must be
upper-case) and that any other chromosomes are autosomes.
We assume that the genotypes are labeled using the 8 letters A-H.
</p>
<p>If the probabilities are for the full 36 states and the X
chromosome is included but <code>is_female</code> is not provided, we'll guess
which individuals are females based on their genotype
probabilities. (If the average, across loci, of the sum of the
heterozygote probabilities is small, we'll assume it's a female.)
</p>


<h3>Value</h3>

<p>An object of the form produced by <code><a href="qtl2.html#topic+calc_genoprob">qtl2::calc_genoprob()</a></code>.
</p>

<hr>
<h2 id='probs_qtl_to_qtl2'>Convert R/qtl genotype probabilities to R/qtl2 format</h2><span id='topic+probs_qtl_to_qtl2'></span>

<h3>Description</h3>

<p>Convert R/qtl genotype probabilities to R/qtl2 format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs_qtl_to_qtl2(cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probs_qtl_to_qtl2_+3A_cross">cross</code></td>
<td>
<p>An R/qtl <code>"cross"</code> object (see
<code><a href="qtl.html#topic+read.cross">qtl::read.cross()</a></code> for details.) Must contain
genotype probabilities as calculated by
<code><a href="qtl.html#topic+calc.genoprob">qtl::calc.genoprob()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components:
</p>

<ul>
<li> <p><code>"probs"</code> - the genotype probabilities in the form produced by <code><a href="qtl2.html#topic+calc_genoprob">qtl2::calc_genoprob()</a></code>
</p>
</li>
<li> <p><code>"map"</code> - Map of marker/pseudomarker positions (a list of vectors of positions)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)
data(hyper)
hyper &lt;- calc.genoprob(hyper, step=1, error.prob=0.002)
result &lt;- probs_qtl_to_qtl2(hyper)
pr &lt;- result$probs
map &lt;- result$map

</code></pre>

<hr>
<h2 id='probs_qtl2_to_array'>Convert R/qtl2 genotype probabilities to a 3d array</h2><span id='topic+probs_qtl2_to_array'></span>

<h3>Description</h3>

<p>Convert R/qtl2 genotype probabilities to a 3d array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs_qtl2_to_array(probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probs_qtl2_to_array_+3A_probs">probs</code></td>
<td>
<p>A <code>"calc_genoprob"</code> object (a list of 3d arrays of
genotype probabilities), as calculated by <code><a href="qtl2.html#topic+calc_genoprob">qtl2::calc_genoprob()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We convert just the autosomal genotype probabilities, because they
should all have the same number of genotypes (columns). The main
application of this is for identifying possible sample mix-ups
among batches of genotype probabilities (e.g., using the
<a href="https://github.com/kbroman/lineup2">R/lineup2</a> package), and for
this the autosomal genotype probabilities should be sufficient.
</p>


<h3>Value</h3>

<p>A single three-dimensional array, with just the autosomal
genotype probabilities.
</p>

<hr>
<h2 id='probs_qtl2_to_doqtl'>Convert R/qtl2 genotype probabilities to DOQTL format</h2><span id='topic+probs_qtl2_to_doqtl'></span>

<h3>Description</h3>

<p>Convert R/qtl2 genotype probabilities to DOQTL format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs_qtl2_to_doqtl(probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probs_qtl2_to_doqtl_+3A_probs">probs</code></td>
<td>
<p>A <code>"calc_genoprob"</code> object (a list of 3d arrays of
genotype probabilities), as calculated by <code><a href="qtl2.html#topic+calc_genoprob">qtl2::calc_genoprob()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the arrays in <code>probs</code> all have 8 columns, they're assumed to be
allele dosages and we paste them all together into one big array.
</p>
<p>Otherwise, it should be that the autosomes all have 36 columns the
X chromosome has 44. In this case, the male hemizygotes on the X
are placed where the female homozygotes are, and then we reorder
the genotypes into alphabetical order.
</p>


<h3>Value</h3>

<p>A single three-dimensional array, for use with
<a href="https://github.com/dmgatti/DOQTL">DOQTL</a>.
</p>

<hr>
<h2 id='scan_qtl_to_qtl2'>Convert R/qtl scanone results to R/qtl2 scan1 format</h2><span id='topic+scan_qtl_to_qtl2'></span>

<h3>Description</h3>

<p>Convert the results of R/qtl1 <code><a href="qtl.html#topic+scanone">qtl::scanone()</a></code> to the form used by the R/qtl2 <code><a href="qtl2.html#topic+scan1">qtl2::scan1()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_qtl_to_qtl2(scanone_output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_qtl_to_qtl2_+3A_scanone_output">scanone_output</code></td>
<td>
<p>Data frame as output by the R/qtl1 function <code><a href="qtl.html#topic+scanone">qtl::scanone()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two objects: the LOD scores in <code><a href="qtl2.html#topic+scan1">qtl2::scan1()</a></code>
format, and the map (as a list of marker/pseudomarker
positions).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan_qtl_to_qtl2">scan_qtl_to_qtl2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)
data(hyper)
hyper &lt;- calc.genoprob(hyper, step=1, error.prob=0.002)
out &lt;- scanone(hyper)
out2 &lt;- scan_qtl_to_qtl2(out)

</code></pre>

<hr>
<h2 id='scan_qtl2_to_qtl'>Convert scan1 results to the scanone format</h2><span id='topic+scan_qtl2_to_qtl'></span>

<h3>Description</h3>

<p>Convert the results of <code><a href="qtl2.html#topic+scan1">qtl2::scan1()</a></code>
to the form used by the R/qtl function
<code><a href="qtl.html#topic+scanone">qtl::scanone()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_qtl2_to_qtl(scan1_output, map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_qtl2_to_qtl_+3A_scan1_output">scan1_output</code></td>
<td>
<p>Matrix of LOD scores, as calculated by
<code><a href="qtl2.html#topic+scan1">qtl2::scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="scan_qtl2_to_qtl_+3A_map">map</code></td>
<td>
<p>Map of markers/pseudomarkers (as a list of vectors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with class <code>"scanone"</code>, containing
chromosome and position columns followed by the LOD scores in
<code>scan1_output</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan_qtl2_to_qtl">scan_qtl2_to_qtl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl2)
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(iron$gmap, step=1)
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

out_rev &lt;- scan_qtl2_to_qtl(out, map)

</code></pre>

<hr>
<h2 id='write2csv'>Write a data frame to a CSV file</h2><span id='topic+write2csv'></span>

<h3>Description</h3>

<p>Write a data frame to a CSV file in a special form, with info about the number of rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write2csv(
  df,
  filename,
  comment = "",
  sep = ",",
  comment.char = "#",
  row.names = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write2csv_+3A_df">df</code></td>
<td>
<p>A data frame (or matrix)</p>
</td></tr>
<tr><td><code id="write2csv_+3A_filename">filename</code></td>
<td>
<p>File name to write</p>
</td></tr>
<tr><td><code id="write2csv_+3A_comment">comment</code></td>
<td>
<p>Comment to place on the first line</p>
</td></tr>
<tr><td><code id="write2csv_+3A_sep">sep</code></td>
<td>
<p>Field separator</p>
</td></tr>
<tr><td><code id="write2csv_+3A_comment.char">comment.char</code></td>
<td>
<p>Character to use to initiate the comment lines</p>
</td></tr>
<tr><td><code id="write2csv_+3A_row.names">row.names</code></td>
<td>
<p>If NA or NULL (the default), row names are not
included in the output file. Otherwise, the row names are
included as the first column of the output, and this is taken
to be the name for that column.</p>
</td></tr>
<tr><td><code id="write2csv_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, overwrite file if it exists. If FALSE
(the default) and the file exists, stop with an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the file already exists, the function will refuse to write over it.
</p>
<p>The file will include comments at the top, using <code style="white-space: pre;">&#8288;#&#8288;</code> as a
comment character, including the number of rows (not including the
header) and the number of columns.
</p>
<p>By default, row names are not included. But with the option
<code>row.names</code> provided as a character string, they are added as an
initial column, with the value of this argument defining the name
for that column. If a column with that name already exists, the
function halts with an error.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nr &lt;- 10
nc &lt;- 5
x &lt;- data.frame(id=paste0("ind", 1:nr),
                matrix(rnorm(nr*nc), ncol=nc))
colnames(x)[1:nc + 1] &lt;- paste0("col", 1:nc)

testfile &lt;- file.path(tempdir(), "tmpfile.csv")
write2csv(x, testfile, "A file created by write2csv")

# Remove the file, to clean up temporary directory
unlink(testfile)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
