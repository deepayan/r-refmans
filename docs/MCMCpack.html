<!DOCTYPE html><html><head><title>Help for package MCMCpack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MCMCpack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesFactor'><p>Create an object of class BayesFactor from MCMCpack output</p></a></li>
<li><a href='#choicevar'><p>Handle Choice-Specific Covariates in Multinomial Choice Models</p></a></li>
<li><a href='#Dirichlet'><p>The Dirichlet Distribution</p></a></li>
<li><a href='#dtomogplot'><p>Dynamic Tomography Plot</p></a></li>
<li><a href='#Euro2016'><p>Euro 2016 data</p></a></li>
<li><a href='#HDPHMMnegbin'><p>Markov Chain Monte Carlo for sticky HDP-HMM with a Negative</p>
Binomial outcome distribution</a></li>
<li><a href='#HDPHMMpoisson'><p>Markov Chain Monte Carlo for sticky HDP-HMM with a Poisson</p>
outcome distribution</a></li>
<li><a href='#HDPHSMMnegbin'><p>Markov Chain Monte Carlo for HDP-HSMM with a Negative</p>
Binomial outcome distribution</a></li>
<li><a href='#HMMpanelFE'><p>Markov Chain Monte Carlo for the Hidden Markov Fixed-effects Model</p></a></li>
<li><a href='#HMMpanelRE'><p>Markov Chain Monte Carlo for the Hidden Markov Random-effects Model</p></a></li>
<li><a href='#InvGamma'><p>The Inverse Gamma Distribution</p></a></li>
<li><a href='#InvWishart'><p>The Inverse Wishart Distribution</p></a></li>
<li><a href='#make.breaklist'><p>Vector of break numbers</p></a></li>
<li><a href='#MCbinomialbeta'><p>Monte Carlo Simulation from a Binomial Likelihood with a Beta Prior</p></a></li>
<li><a href='#MCMCbinaryChange'><p>Markov Chain Monte Carlo for a Binary Multiple Changepoint Model</p></a></li>
<li><a href='#MCMCdynamicEI'><p>Markov Chain Monte Carlo for Quinn's Dynamic Ecological Inference Model</p></a></li>
<li><a href='#MCMCdynamicIRT1d_b'><p>Markov Chain Monte Carlo for Dynamic One Dimensional Item Response</p>
Theory Model</a></li>
<li><a href='#MCMCfactanal'><p>Markov Chain Monte Carlo for Normal Theory Factor Analysis Model</p></a></li>
<li><a href='#MCMChierEI'><p>Markov Chain Monte Carlo for Wakefield's Hierarchial Ecological Inference</p>
Model</a></li>
<li><a href='#MCMChlogit'><p>Markov Chain Monte Carlo for the Hierarchical Binomial Linear Regression</p>
Model using the logit link function</a></li>
<li><a href='#MCMChpoisson'><p>Markov Chain Monte Carlo for the Hierarchical Poisson Linear Regression</p>
Model using the log link function</a></li>
<li><a href='#MCMChregress'><p>Markov Chain Monte Carlo for the Hierarchical Gaussian Linear Regression</p>
Model</a></li>
<li><a href='#MCMCirt1d'><p>Markov Chain Monte Carlo for One Dimensional Item Response Theory Model</p></a></li>
<li><a href='#MCMCirtHier1d'><p>Markov Chain Monte Carlo for Hierarchical One Dimensional Item Response</p>
Theory Model, Covariates Predicting Latent Ideal Point (Ability)</a></li>
<li><a href='#MCMCirtKd'><p>Markov Chain Monte Carlo for K-Dimensional Item Response Theory Model</p></a></li>
<li><a href='#MCMCirtKdRob'><p>Markov Chain Monte Carlo for Robust K-Dimensional Item Response Theory Model</p></a></li>
<li><a href='#MCMClogit'><p>Markov Chain Monte Carlo for Logistic Regression</p></a></li>
<li><a href='#MCMCmetrop1R'><p>Metropolis Sampling from User-Written R function</p></a></li>
<li><a href='#MCMCmixfactanal'><p>Markov Chain Monte Carlo for Mixed Data Factor Analysis Model</p></a></li>
<li><a href='#MCMCmnl'><p>Markov Chain Monte Carlo for Multinomial Logistic Regression</p></a></li>
<li><a href='#MCMCnegbin'><p>Markov Chain Monte Carlo for Negative Binomial Regression</p></a></li>
<li><a href='#MCMCnegbinChange'><p>Markov Chain Monte Carlo for Negative Binomial Regression</p>
Changepoint Model</a></li>
<li><a href='#MCMCoprobit'><p>Markov Chain Monte Carlo for Ordered Probit Regression</p></a></li>
<li><a href='#MCMCoprobitChange'><p>Markov Chain Monte Carlo for Ordered Probit Changepoint Regression Model</p></a></li>
<li><a href='#MCMCordfactanal'><p>Markov Chain Monte Carlo for Ordinal Data Factor Analysis Model</p></a></li>
<li><a href='#MCMCpaircompare'><p>Markov Chain Monte Carlo for a Pairwise Comparisons Model with Probit Link</p></a></li>
<li><a href='#MCMCpaircompare2d'><p>Markov Chain Monte Carlo for the Two-Dimensional Pairwise Comparisons</p>
Model in Yu and Quinn (2021)</a></li>
<li><a href='#MCMCpaircompare2dDP'><p>Markov Chain Monte Carlo for the Two-Dimensional Pairwise Comparisons</p>
Model with Dirichlet Process Prior in Yu and Quinn (2021)</a></li>
<li><a href='#MCMCpoisson'><p>Markov Chain Monte Carlo for Poisson Regression</p></a></li>
<li><a href='#MCMCpoissonChange'><p>Markov Chain Monte Carlo for a Poisson Regression Changepoint Model</p></a></li>
<li><a href='#MCMCprobit'><p>Markov Chain Monte Carlo for Probit Regression</p></a></li>
<li><a href='#MCMCprobitChange'><p>Markov Chain Monte Carlo for a linear Gaussian Multiple Changepoint Model</p></a></li>
<li><a href='#MCMCquantreg'><p>Bayesian quantile regression using Gibbs sampling</p></a></li>
<li><a href='#MCMCregress'><p>Markov Chain Monte Carlo for Gaussian Linear Regression</p></a></li>
<li><a href='#MCMCregressChange'><p>Markov Chain Monte Carlo for a linear Gaussian Multiple Changepoint Model</p></a></li>
<li><a href='#MCMCresidualBreakAnalysis'><p>Break Analysis of Univariate Time Series using Markov Chain Monte Carlo</p></a></li>
<li><a href='#MCMCSVDreg'><p>Markov Chain Monte Carlo for SVD Regression</p></a></li>
<li><a href='#MCMCtobit'><p>Markov Chain Monte Carlo for Gaussian Linear Regression with a Censored</p>
Dependent Variable</a></li>
<li><a href='#MCmultinomdirichlet'><p>Monte Carlo Simulation from a Multinomial Likelihood with a Dirichlet Prior</p></a></li>
<li><a href='#MCnormalnormal'><p>Monte Carlo Simulation from a Normal Likelihood (with known variance) with a</p>
Normal Prior</a></li>
<li><a href='#MCpoissongamma'><p>Monte Carlo Simulation from a Poisson Likelihood with a Gamma Prior</p></a></li>
<li><a href='#mptable'><p>Calculate the marginal posterior probabilities of predictors being included</p>
in a quantile regression model.</a></li>
<li><a href='#Nethvote'><p>Dutch Voting Behavior in 1989</p></a></li>
<li><a href='#NoncenHypergeom'><p>The Noncentral Hypergeometric Distribution</p></a></li>
<li><a href='#PErisk'><p>Political Economic Risk Data from 62 Countries in 1987</p></a></li>
<li><a href='#plot.qrssvs'><p>Plot output from quantile regression stochastic search variable selection</p>
(QR-SSVS).</a></li>
<li><a href='#plotChangepoint'><p>Posterior Density of Regime Change Plot</p></a></li>
<li><a href='#plotHDPChangepoint'><p>Posterior Changepoint Probabilities from HDP-HMM</p></a></li>
<li><a href='#plotState'><p>Changepoint State Plot</p></a></li>
<li><a href='#PostProbMod'><p>Calculate Posterior Probability of Model</p></a></li>
<li><a href='#procrustes'><p>Procrustes Transformation</p></a></li>
<li><a href='#read.Scythe'><p>Read a Matrix from a File written by Scythe</p></a></li>
<li><a href='#Rehnquist'><p>U.S. Supreme Court Vote Matrix, Rehnquist Court (1994-2004)</p></a></li>
<li><a href='#Senate'><p>106th U.S. Senate Roll Call Vote Matrix</p></a></li>
<li><a href='#SSVSquantreg'><p>Stochastic search variable selection for quantile regression</p></a></li>
<li><a href='#summaryqrssvs'><p>Summarising the results of quantile regression stochastic search variable</p>
selection (QR-SSVS).</a></li>
<li><a href='#SupremeCourt'><p>U.S. Supreme Court Vote Matrix</p></a></li>
<li><a href='#testpanelGroupBreak'><p>A Test for the Group-level Break using a Multivariate Linear Regression</p>
Model with Breaks</a></li>
<li><a href='#testpanelSubjectBreak'><p>A Test for the Subject-level Break using a Unitivariate Linear Regression</p>
Model with Breaks</a></li>
<li><a href='#tomogplot'><p>Tomography Plot</p></a></li>
<li><a href='#topmodels'><p>Shows an ordered list of the most frequently visited models sampled during</p>
quantile regression stochastic search variable selection (QR-SSVS).</a></li>
<li><a href='#vech'><p>Extract Lower Triangular Elements from a Symmetric Matrix</p></a></li>
<li><a href='#Wishart'><p>The Wishart Distribution</p></a></li>
<li><a href='#write.Scythe'><p>Write a Matrix to a File to be Read by Scythe</p></a></li>
<li><a href='#xpnd'><p>Expand a Vector into a Symmetric Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Markov Chain Monte Carlo (MCMC) Package</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew D. Martin [aut], Kevin M. Quinn [aut], Jong Hee Park [aut,cre], Ghislain Vieilledent [ctb], Michael Malecki[ctb], Matthew Blackwell [ctb], Keith Poole [ctb], Craig Reed [ctb], Ben Goodrich [ctb], Qiushi Yu [ctb], Ross Ihaka [cph], The R Development Core Team [cph], The R Foundation [cph], Pierre L'Ecuyer [cph], Makoto Matsumoto [cph], Takuji Nishimura [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jong Hee Park &lt;jongheepark@snu.ac.kr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), coda (&ge; 0.11-3), MASS, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, lattice, methods, utils, mcmc, quantreg</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions to perform Bayesian
        inference using posterior simulation for a number of
        statistical models. Most simulation is done in compiled C++
        written in the Scythe Statistical Library Version 1.0.3. All
        models return 'coda' mcmc objects that can then be summarized
        using the 'coda' package. Some useful
        utility functions such as density functions,
	pseudo-random number generators for statistical
        distributions, a general purpose Metropolis sampling algorithm,
        and tools for visualization are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gcc (&gt;= 4.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=MCMCpack">https://CRAN.R-project.org/package=MCMCpack</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-18 14:23:16 UTC; park</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-18 15:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesFactor'>Create an object of class BayesFactor from MCMCpack output</h2><span id='topic+BayesFactor'></span><span id='topic+is.BayesFactor'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>BayesFactor</code> from
MCMCpack output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesFactor(...)

is.BayesFactor(BF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesFactor_+3A_...">...</code></td>
<td>
<p>MCMCpack output objects. These have to be of class
<code>mcmc</code> and have a <code>logmarglike</code> attribute. In what
follows, we let <code>M</code> denote the total number of models to be
compared.</p>
</td></tr>
<tr><td><code id="BayesFactor_+3A_bf">BF</code></td>
<td>
<p>An object to be checked for membership in class
</p>
<p><code>BayesFactor</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>BayesFactor</code>. A <code>BayesFactor</code>
object has four attributes. They are: <code>BF.mat</code> an <code class="reqn">M
  \times M</code> matrix in which element <code class="reqn">i,j</code> contains the Bayes
factor for model <code class="reqn">i</code> relative to model <code class="reqn">j</code>;
<code>BF.log.mat</code> an <code class="reqn">M \times M</code> matrix in which element
<code class="reqn">i,j</code> contains the natural log of the Bayes factor for model
<code class="reqn">i</code> relative to model <code class="reqn">j</code>; <code>BF.logmarglike</code> an
<code class="reqn">M</code> vector containing the log marginal likelihoods for models
1 through <code class="reqn">M</code>; and <code>BF.call</code> an <code class="reqn">M</code> element list
containing the calls used to fit models 1 through <code class="reqn">M</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCregress">MCMCregress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(birthwt)

model1 &lt;- MCMCregress(bwt~age+lwt+as.factor(race) + smoke + ht,
                     data=birthwt, b0=c(2700, 0, 0, -500, -500,
                                        -500, -500),
                     B0=c(1e-6, .01, .01, 1.6e-5, 1.6e-5, 1.6e-5,
                          1.6e-5), c0=10, d0=4500000,
                     marginal.likelihood="Chib95", mcmc=10000)

model2 &lt;- MCMCregress(bwt~age+lwt+as.factor(race) + smoke,
                     data=birthwt, b0=c(2700, 0, 0, -500, -500,
                                        -500),
                     B0=c(1e-6, .01, .01, 1.6e-5, 1.6e-5, 1.6e-5),
                     c0=10, d0=4500000,
                     marginal.likelihood="Chib95", mcmc=10000)

model3 &lt;- MCMCregress(bwt~as.factor(race) + smoke + ht,
                     data=birthwt, b0=c(2700, -500, -500,
                                        -500, -500),
                     B0=c(1e-6, 1.6e-5, 1.6e-5, 1.6e-5,
                          1.6e-5), c0=10, d0=4500000,
                     marginal.likelihood="Chib95", mcmc=10000)

BF &lt;- BayesFactor(model1, model2, model3)
print(BF)


## End(Not run)

</code></pre>

<hr>
<h2 id='choicevar'>Handle Choice-Specific Covariates in Multinomial Choice Models</h2><span id='topic+choicevar'></span>

<h3>Description</h3>

<p>This function handles choice-specific covariates in multinomial choice
models.  See the example for an example of useage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choicevar(var, varname, choicelevel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choicevar_+3A_var">var</code></td>
<td>
<p>The is the name of the variable in the dataframe.</p>
</td></tr>
<tr><td><code id="choicevar_+3A_varname">varname</code></td>
<td>
<p>The name of the new variable to be created.</p>
</td></tr>
<tr><td><code id="choicevar_+3A_choicelevel">choicelevel</code></td>
<td>
<p>The level of <code>y</code> that the variable corresponds to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new variable used by the <code>MCMCmnl()</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCmnl">MCMCmnl</a></code>
</p>

<hr>
<h2 id='Dirichlet'>The Dirichlet Distribution</h2><span id='topic+Dirichlet'></span><span id='topic+ddirichlet'></span><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Density function and random generation from the Dirichlet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(x, alpha)

rdirichlet(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dirichlet_+3A_x">x</code></td>
<td>
<p>A vector containing a single deviate or matrix containing one
random deviate per row.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>Vector of shape parameters, or matrix of shape parameters
corresponding to the number of draw.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_n">n</code></td>
<td>
<p>Number of random vectors to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dirichlet distribution is the multidimensional generalization of the
beta distribution.
</p>


<h3>Value</h3>

<p><code>ddirichlet</code> gives the density. <code>rdirichlet</code> returns a
matrix with <code>n</code> rows, each containing a single Dirichlet random
deviate.
</p>


<h3>Author(s)</h3>

<p>Code is taken from Greg's Miscellaneous Functions (gregmisc).  His
code was based on code posted by Ben Bolker to R-News on 15 Dec 2000.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  density &lt;- ddirichlet(c(.1,.2,.7), c(1,1,1))
  draws &lt;- rdirichlet(20, c(1,1,1) )

</code></pre>

<hr>
<h2 id='dtomogplot'>Dynamic Tomography Plot</h2><span id='topic+dtomogplot'></span>

<h3>Description</h3>

<p>dtomogplot is used to produce a tomography plot (see King, 1997) for a
series of temporally ordered, partially observed 2 x 2 contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtomogplot(
  r0,
  r1,
  c0,
  c1,
  time.vec = NA,
  delay = 0,
  xlab = "fraction of r0 in c0 (p0)",
  ylab = "fraction of r1 in c0 (p1)",
  color.palette = heat.colors,
  bgcol = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtomogplot_+3A_r0">r0</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of row sums from
row 0.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_r1">r1</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of row sums from
row 1.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_c0">c0</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of column sums
from column 0.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_c1">c1</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of column sums
from column 1.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_time.vec">time.vec</code></td>
<td>
<p>Vector of time periods that correspond to the elements of
<code class="reqn">r_0</code>, <code class="reqn">r_1</code>, <code class="reqn">c_0</code>, and <code class="reqn">c_1</code>.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_delay">delay</code></td>
<td>
<p>Time delay in seconds between the plotting of the tomography
lines. Setting a positive delay is useful for visualizing temporal
dependence.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_xlab">xlab</code></td>
<td>
<p>The x axis label for the plot.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_ylab">ylab</code></td>
<td>
<p>The y axis label for the plot.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_color.palette">color.palette</code></td>
<td>
<p>Color palette to be used to encode temporal patterns.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_bgcol">bgcol</code></td>
<td>
<p>The background color for the plot.</p>
</td></tr>
<tr><td><code id="dtomogplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the following partially observed 2 by 2 contingency table:
</p>

<table>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> | <code class="reqn">Y=0</code> </td><td style="text-align: left;"> | <code class="reqn">Y=1</code> </td><td style="text-align: left;"> |           </td>
</tr>
<tr>
 <td style="text-align: left;">
 --------- </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">X=0</code> </td><td style="text-align: left;"> | <code class="reqn">Y_0</code> </td><td style="text-align: left;"> |           </td><td style="text-align: left;"> | <code class="reqn">r_0</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 --------- </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">X=1</code> </td><td style="text-align: left;"> | <code class="reqn">Y_1</code> </td><td style="text-align: left;"> |           </td><td style="text-align: left;"> | <code class="reqn">r_1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 --------- </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> | <code class="reqn">c_0</code> </td><td style="text-align: left;"> | <code class="reqn">c_1</code> </td><td style="text-align: left;"> | <code class="reqn">N</code>
</td>
</tr>

</table>

<p>where <code class="reqn">r_0</code>, <code class="reqn">r_1</code>, <code class="reqn">c_0</code>, <code class="reqn">c_1</code>, and
<code class="reqn">N</code> are non-negative integers that are observed. The interior cell
entries are not observed. It is assumed that <code class="reqn">Y_0|r_0 \sim
\mathcal{B}inomial(r_0, p_0)</code> and <code class="reqn">Y_1|r_1 \sim \mathcal{B}inomial(r_1, p_1)</code>.
</p>
<p>This function plots the bounds on the maximum likelihood estimates for (p0,
p1) and color codes them by the elements of time.vec.
</p>


<h3>References</h3>

<p>Gary King, 1997. <em>A Solution to the Ecological Inference
Problem</em>.  Princeton: Princeton University Press.
</p>
<p>Jonathan C. Wakefield. 2004. &ldquo;Ecological Inference for 2 x 2 Tables.&rdquo;
<em>Journal of the Royal Statistical Society, Series A</em>. 167(3): 385445.
</p>
<p>Kevin Quinn. 2004. &ldquo;Ecological Inference in the Presence of Temporal
Dependence.&quot; In <em>Ecological Inference: New Methodological Strategies</em>.
Gary King, Ori Rosen, and Martin A. Tanner (eds.). New York: Cambridge
University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMChierEI">MCMChierEI</a></code>,
<code><a href="#topic+MCMCdynamicEI">MCMCdynamicEI</a></code>,<code><a href="#topic+tomogplot">tomogplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## simulated data example 1
set.seed(3920)
n &lt;- 100
r0 &lt;- rpois(n, 2000)
r1 &lt;- round(runif(n, 100, 4000))
p0.true &lt;- pnorm(-1.5 + 1:n/(n/2))
p1.true &lt;- pnorm(1.0 - 1:n/(n/4))
y0 &lt;- rbinom(n, r0, p0.true)
y1 &lt;- rbinom(n, r1, p1.true)
c0 &lt;- y0 + y1
c1 &lt;- (r0+r1) - c0

## plot data
dtomogplot(r0, r1, c0, c1, delay=0.1)

## simulated data example 2
set.seed(8722)
n &lt;- 100
r0 &lt;- rpois(n, 2000)
r1 &lt;- round(runif(n, 100, 4000))
p0.true &lt;- pnorm(-1.0 + sin(1:n/(n/4)))
p1.true &lt;- pnorm(0.0 - 2*cos(1:n/(n/9)))
y0 &lt;- rbinom(n, r0, p0.true)
y1 &lt;- rbinom(n, r1, p1.true)
c0 &lt;- y0 + y1
c1 &lt;- (r0+r1) - c0

## plot data
dtomogplot(r0, r1, c0, c1, delay=0.1)

## End(Not run)

</code></pre>

<hr>
<h2 id='Euro2016'>Euro 2016 data</h2><span id='topic+Euro2016'></span>

<h3>Description</h3>

<p>Data on head-to-head outcomes from the 2016 UEFA European Football
Championship.
</p>


<h3>Format</h3>

<p>This dataframe contains all of the head-to-head results from
Euro 2016. This includes results from both the group stage and the
knock-out rounds.
</p>

<dl>
<dt>dummy.rater</dt><dd><p>An artificial &quot;dummy&quot; rater equal to 1 for all
matches. Included so that <code>Euro2016</code> can be used directly with
<code>MCMCpack</code>'s models for pairwise comparisons.</p>
</dd>
<dt>team1</dt><dd><p>The home team</p>
</dd>
<dt>team2</dt><dd><p>The away team </p>
</dd>
<dt>winner</dt><dd><p>The winner of the match. <code>NA</code> if a draw.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/UEFA_Euro_2016">https://en.wikipedia.org/wiki/UEFA_Euro_2016</a>
</p>

<hr>
<h2 id='HDPHMMnegbin'>Markov Chain Monte Carlo for sticky HDP-HMM with a Negative
Binomial outcome distribution</h2><span id='topic+HDPHMMnegbin'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a (sticky) HDP-HMM with a Negative Binomial outcome distribution
(Fox et al, 2011). The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HDPHMMnegbin(
  formula,
  data = parent.frame(),
  K = 10,
  b0 = 0,
  B0 = 1,
  a.theta = 50,
  b.theta = 5,
  a.alpha = 1,
  b.alpha = 0.1,
  a.gamma = 1,
  b.gamma = 0.1,
  e = 2,
  f = 2,
  g = 10,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  rho.start = NA,
  rho.step,
  nu.start = NA,
  gamma.start = 0.5,
  theta.start = 0.98,
  ak.start = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HDPHMMnegbin_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_k">K</code></td>
<td>
<p>The number of regimes under consideration. This should be
larger than the hypothesized number of regimes in the data. Note
that the sampler will likely visit fewer than <code>K</code> regimes.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_a.theta">a.theta</code>, <code id="HDPHMMnegbin_+3A_b.theta">b.theta</code></td>
<td>
<p>Paramaters for the Beta prior on
<code class="reqn">\theta</code>, which captures the strength of the self-transition
bias.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_a.alpha">a.alpha</code>, <code id="HDPHMMnegbin_+3A_b.alpha">b.alpha</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\alpha + \kappa</code>.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_a.gamma">a.gamma</code>, <code id="HDPHMMnegbin_+3A_b.gamma">b.gamma</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_e">e</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code> See details.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_f">f</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_g">g</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value
for all regimes.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_p.start">P.start</code></td>
<td>
<p>Initial transition matrix between regimes. Should be
a <code>K</code> by <code>K</code> matrix. If not provided, the default value
will be place <code>theta.start</code> along the diagonal and the rest
of the mass even distributed within rows.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_rho.start">rho.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\rho</code> variable.
This can either be a scalar or a column vector with dimension
equal to the number of regimes. If the value is scalar, it will
be used for all regimes. The default value is a vector of ones.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_rho.step">rho.step</code></td>
<td>
<p>Tuning parameter for the slice sampling approach to
sampling <code class="reqn">rho</code>. Determines the size of the step-out used to
find the correct slice to draw from. Lower values are more
accurate, but will take longer (up to a fixed searching limit).
Default is 0.1.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_nu.start">nu.start</code></td>
<td>
<p>The starting values for the random effect,
<code class="reqn">\nu</code>. The default value is a vector of ones.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_theta.start">theta.start</code>, <code id="HDPHMMnegbin_+3A_ak.start">ak.start</code>, <code id="HDPHMMnegbin_+3A_gamma.start">gamma.start</code></td>
<td>
<p>Scalar starting values for the
<code class="reqn">\theta</code>, <code class="reqn">\alpha + \kappa</code>, and <code class="reqn">\gamma</code> parameters.</p>
</td></tr>
<tr><td><code id="HDPHMMnegbin_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HDPHMMnegbin</code> simulates from the posterior distribution of a
sticky HDP-HMM with a Negative Binomial outcome distribution,
allowing for multiple, arbitrary changepoints in the model. The details of the
model are discussed in Blackwell (2017). The implementation here is
based on a weak-limit approximation, where there is a large, though
finite number of regimes that can be switched between. Unlike other
changepoint models in <code>MCMCpack</code>, the HDP-HMM approach allows
for the state sequence to return to previous visited states.
</p>
<p>The model takes the following form, where we show the fixed-limit version:
</p>
<p style="text-align: center;"><code class="reqn">y_t \sim \mathcal{P}oisson(\nu_t\mu_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = x_t ' \beta_m,\;\; m = 1, \ldots, M</code>
</p>

<p style="text-align: center;"><code class="reqn">\nu_t \sim \mathcal{G}amma(\rho_m, \rho_m)</code>
</p>

<p>Where <code class="reqn">M</code> is an upper bound on the number of states and
<code class="reqn">\beta_m</code> and <code class="reqn">\rho_m</code> are parameters when a state is
<code class="reqn">m</code> at <code class="reqn">t</code>.
</p>
<p>The transition probabilities between states are assumed to follow a
heirarchical Dirichlet process:
</p>
<p style="text-align: center;"><code class="reqn">\pi_m \sim \mathcal{D}irichlet(\alpha\delta_1, \ldots,
\alpha\delta_j + \kappa, \ldots, \alpha\delta_M)</code>
</p>

<p style="text-align: center;"><code class="reqn">\delta \sim \mathcal{D}irichlet(\gamma/M, \ldots, \gamma/M)</code>
</p>

<p>The <code class="reqn">\kappa</code> value here is the sticky parameter that
encourages self-transitions. The sampler follows Fox et al (2011)
and parameterizes these priors with <code class="reqn">\alpha + \kappa</code> and
<code class="reqn">\theta = \kappa/(\alpha + \kappa)</code>, with the latter
representing the degree of self-transition bias. Gamma priors are
assumed for <code class="reqn">(\alpha + \kappa)</code> and <code class="reqn">\gamma</code>.
</p>
<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, M</code>
</p>

<p>The overdispersion parameters have a prior with the following form:
</p>
<p style="text-align: center;"><code class="reqn">f(\rho_m|e,f,g) \propto \rho^{e-1}(\rho + g)^{-(e+f)}</code>
</p>

<p>The model is simulated via blocked Gibbs conditonal on the states.
The <code class="reqn">\beta</code> being simulated via the auxiliary mixture sampling
method of Fuerhwirth-Schanetter et al. (2009). The <code class="reqn">\rho</code> is
updated via slice sampling. The <code class="reqn">\nu_i</code> are updated their
(conjugate) full conditional, which is also Gamma. The states are
updated as in Fox et al (2011), supplemental materials.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Sylvia Fruehwirth-Schnatter, Rudolf Fruehwirth, Leonhard Held, and
Havard Rue. 2009. &ldquo;Improved auxiliary mixture sampling for
hierarchical models of non-Gaussian data&rdquo;, <em>Statistics
and Computing</em> 19(4): 479-492.
&lt;doi:10.1007/s11222-008-9109-4&gt;
</p>
<p>Matthew Blackwell. 2017. &ldquo;Game Changers: Detecting Shifts in
Overdispersed Count Data,&rdquo; <em>Political Analysis</em>
26(2), 230-239. &lt;doi:10.1017/pan.2017.42&gt;
</p>
<p>Emily B. Fox, Erik B. Sudderth, Michael I. Jordan, and Alan S.
Willsky. 2011.. &ldquo;A sticky HDP-HMM with application to speaker
diarization.&rdquo; <em>The Annals of Applied Statistics</em>, 5(2A),
1020-1056. &lt;doi:10.1214/10-AOAS395&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCnegbinChange">MCMCnegbinChange</a></code>, <code><a href="#topic+HDPHMMpoisson">HDPHMMpoisson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   n &lt;- 150
   reg &lt;- 3
   true.s &lt;- gl(reg, n/reg, n)
   rho.true &lt;- c(1.5, 0.5, 3)
   b1.true &lt;- c(1, -2, 2)
   x1 &lt;- runif(n, 0, 2)
   nu.true &lt;- rgamma(n, rho.true[true.s], rho.true[true.s])
   mu &lt;- nu.true * exp(1 + x1 * b1.true[true.s])
   y &lt;- rpois(n, mu)

   posterior &lt;- HDPHMMnegbin(y ~ x1, K = 10, verbose = 1000,
                          e = 2, f = 2, g = 10,
                          a.theta = 100, b.theta = 1,
                          b0 = rep(0, 2), B0 = (1/9) * diag(2),
                          rho.step = rep(0.75, times = 10),
                          seed = list(NA, 2),
                          theta.start = 0.95, gamma.start = 10,
                          ak.start = 10)

   plotHDPChangepoint(posterior, ylab="Density", start=1)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='HDPHMMpoisson'>Markov Chain Monte Carlo for sticky HDP-HMM with a Poisson
outcome distribution</h2><span id='topic+HDPHMMpoisson'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a (sticky) HDP-HMM with a Poisson outcome distribution
(Fox et al, 2011). The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HDPHMMpoisson(
  formula,
  data = parent.frame(),
  K = 10,
  b0 = 0,
  B0 = 1,
  a.alpha = 1,
  b.alpha = 0.1,
  a.gamma = 1,
  b.gamma = 0.1,
  a.theta = 50,
  b.theta = 5,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  gamma.start = 0.5,
  theta.start = 0.98,
  ak.start = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HDPHMMpoisson_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_k">K</code></td>
<td>
<p>The number of regimes under consideration. This should be
larger than the hypothesized number of regimes in the data. Note
that the sampler will likely visit fewer than <code>K</code> regimes.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_a.alpha">a.alpha</code>, <code id="HDPHMMpoisson_+3A_b.alpha">b.alpha</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\alpha + \kappa</code>.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_a.gamma">a.gamma</code>, <code id="HDPHMMpoisson_+3A_b.gamma">b.gamma</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_a.theta">a.theta</code>, <code id="HDPHMMpoisson_+3A_b.theta">b.theta</code></td>
<td>
<p>Paramaters for the Beta prior on
<code class="reqn">\theta</code>, which captures the strength of the self-transition
bias.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value
for all regimes.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_p.start">P.start</code></td>
<td>
<p>Initial transition matrix between regimes. Should be
a <code>K</code> by <code>K</code> matrix. If not provided, the default value
will be place <code>theta.start</code> along the diagonal and the rest
of the mass even distributed within rows.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_theta.start">theta.start</code>, <code id="HDPHMMpoisson_+3A_ak.start">ak.start</code>, <code id="HDPHMMpoisson_+3A_gamma.start">gamma.start</code></td>
<td>
<p>Scalar starting values for the
<code class="reqn">\theta</code>, <code class="reqn">\alpha + \kappa</code>, and <code class="reqn">\gamma</code> parameters.</p>
</td></tr>
<tr><td><code id="HDPHMMpoisson_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HDPHMMpoisson</code> simulates from the posterior distribution of a
sticky HDP-HMM with a Poisson outcome distribution,
allowing for multiple, arbitrary changepoints in the model. The details of the
model are discussed in Blackwell (2017). The implementation here is
based on a weak-limit approximation, where there is a large, though
finite number of regimes that can be switched between. Unlike other
changepoint models in <code>MCMCpack</code>, the HDP-HMM approach allows
for the state sequence to return to previous visited states.
</p>
<p>The model takes the following form, where we show the fixed-limit version:
</p>
<p style="text-align: center;"><code class="reqn">y_t \sim \mathcal{P}oisson(\mu_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = x_t ' \beta_m,\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is an upper bound on the number of states and
<code class="reqn">\beta_m</code> are parameters when a state is
<code class="reqn">m</code> at <code class="reqn">t</code>.
</p>
<p>The transition probabilities between states are assumed to follow a
heirarchical Dirichlet process:
</p>
<p style="text-align: center;"><code class="reqn">\pi_m \sim \mathcal{D}irichlet(\alpha\delta_1, \ldots,
\alpha\delta_j + \kappa, \ldots, \alpha\delta_M)</code>
</p>

<p style="text-align: center;"><code class="reqn">\delta \sim \mathcal{D}irichlet(\gamma/M, \ldots, \gamma/M)</code>
</p>

<p>The <code class="reqn">\kappa</code> value here is the sticky parameter that
encourages self-transitions. The sampler follows Fox et al (2011)
and parameterizes these priors with <code class="reqn">\alpha + \kappa</code> and
<code class="reqn">\theta = \kappa/(\alpha + \kappa)</code>, with the latter
representing the degree of self-transition bias. Gamma priors are
assumed for <code class="reqn">(\alpha + \kappa)</code> and <code class="reqn">\gamma</code>.
</p>
<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, M</code>
</p>

<p>The model is simulated via blocked Gibbs conditonal on the states.
The <code class="reqn">\beta</code> being simulated via the auxiliary mixture sampling
method of Fuerhwirth-Schanetter et al. (2009). The states are
updated as in Fox et al (2011), supplemental materials.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Sylvia Fruehwirth-Schnatter, Rudolf Fruehwirth, Leonhard Held, and
Havard Rue. 2009. &ldquo;Improved auxiliary mixture sampling for
hierarchical models of non-Gaussian data&rdquo;, <em>Statistics
and Computing</em> 19(4): 479-492.
&lt;doi:10.1007/s11222-008-9109-4&gt;
</p>
<p>Matthew Blackwell. 2017. &ldquo;Game Changers: Detecting Shifts in
Overdispersed Count Data,&rdquo; <em>Political Analysis</em>
26(2), 230-239. &lt;doi:10.1017/pan.2017.42&gt;
</p>
<p>Emily B. Fox, Erik B. Sudderth, Michael I. Jordan, and Alan S.
Willsky. 2011.. &ldquo;A sticky HDP-HMM with application to speaker
diarization.&rdquo; <em>The Annals of Applied Statistics</em>, 5(2A),
1020-1056. &lt;doi:10.1214/10-AOAS395&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCpoissonChange">MCMCpoissonChange</a></code>, <code><a href="#topic+HDPHMMnegbin">HDPHMMnegbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   n &lt;- 150
   reg &lt;- 3
   true.s &lt;- gl(reg, n/reg, n)
   b1.true &lt;- c(1, -2, 2)
   x1 &lt;- runif(n, 0, 2)
   mu &lt;- exp(1 + x1 * b1.true[true.s])
   y &lt;- rpois(n, mu)

   posterior &lt;- HDPHMMpoisson(y ~ x1, K = 10, verbose = 1000,
                          a.theta = 100, b.theta = 1,
                          b0 = rep(0, 2), B0 = (1/9) * diag(2),
                          seed = list(NA, 2),
                          theta.start = 0.95, gamma.start = 10,
                          ak.start = 10)

   plotHDPChangepoint(posterior, ylab="Density", start=1)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='HDPHSMMnegbin'>Markov Chain Monte Carlo for HDP-HSMM with a Negative
Binomial outcome distribution</h2><span id='topic+HDPHSMMnegbin'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a Hidden Semi-Markov Model with a Heirarchical Dirichlet Process
and a Negative Binomial outcome distribution
(Johnson and Willsky, 2013).  The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HDPHSMMnegbin(
  formula,
  data = parent.frame(),
  K = 10,
  b0 = 0,
  B0 = 1,
  a.alpha = 1,
  b.alpha = 0.1,
  a.gamma = 1,
  b.gamma = 0.1,
  a.omega,
  b.omega,
  e = 2,
  f = 2,
  g = 10,
  r = 1,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  rho.start = NA,
  rho.step,
  nu.start = NA,
  omega.start = NA,
  gamma.start = 0.5,
  alpha.start = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HDPHSMMnegbin_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_k">K</code></td>
<td>
<p>The number of regimes under consideration. This should be
larger than the hypothesized number of regimes in the data. Note
that the sampler will likely visit fewer than <code>K</code> regimes.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_a.alpha">a.alpha</code>, <code id="HDPHSMMnegbin_+3A_b.alpha">b.alpha</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_a.gamma">a.gamma</code>, <code id="HDPHSMMnegbin_+3A_b.gamma">b.gamma</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_a.omega">a.omega</code>, <code id="HDPHSMMnegbin_+3A_b.omega">b.omega</code></td>
<td>
<p>Paramaters for the Beta prior on
<code class="reqn">\omega</code>, which determines the regime length distribution,
which is Negative Binomial, with parameters <code>r</code> and <code>omega</code>.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_e">e</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code> See details.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_f">f</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_g">g</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_r">r</code></td>
<td>
<p>Parameter of the Negative Binomial prior for regime
durations. It is the target number of successful trials. Must be
strictly positive. Higher values increase the variance of the
duration distributions.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value
for all regimes.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_p.start">P.start</code></td>
<td>
<p>Initial transition matrix between regimes. Should be
a <code>K</code> by <code>K</code> matrix. If not provided, the default value
will be uniform transition distributions.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_rho.start">rho.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\rho</code> variable.
This can either be a scalar or a column vector with dimension
equal to the number of regimes. If the value is scalar, it will
be used for all regimes. The default value is a vector of ones.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_rho.step">rho.step</code></td>
<td>
<p>Tuning parameter for the slice sampling approach to
sampling <code class="reqn">rho</code>. Determines the size of the step-out used to
find the correct slice to draw from. Lower values are more
accurate, but will take longer (up to a fixed searching limit).
Default is 0.1.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_nu.start">nu.start</code></td>
<td>
<p>The starting values for the random effect,
<code class="reqn">\nu</code>. The default value is a vector of ones.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_omega.start">omega.start</code></td>
<td>
<p>A vector of starting values for the probability
of success parameter in the Negative Binomial distribution that
governs the duration distributions.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_alpha.start">alpha.start</code>, <code id="HDPHSMMnegbin_+3A_gamma.start">gamma.start</code></td>
<td>
<p>Scalar starting values for the
<code class="reqn">\alpha</code>, and <code class="reqn">\gamma</code> parameters.</p>
</td></tr>
<tr><td><code id="HDPHSMMnegbin_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HDPHSMMnegbin</code> simulates from the posterior distribution of a
HDP-HSMM with a Negative Binomial outcome distribution,
allowing for multiple, arbitrary changepoints in the model. The details of the
model are discussed in Johnson &amp; Willsky (2013). The implementation here is
based on a weak-limit approximation, where there is a large, though
finite number of regimes that can be switched between. Unlike other
changepoint models in <code>MCMCpack</code>, the HDP-HSMM approach allows
for the state sequence to return to previous visited states.
</p>
<p>The model takes the following form, where we show the fixed-limit version:
</p>
<p style="text-align: center;"><code class="reqn">y_t \sim \mathcal{P}oisson(\nu_t\mu_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = x_t ' \beta_k,\;\; k = 1, \ldots, K</code>
</p>

<p style="text-align: center;"><code class="reqn">\nu_t \sim \mathcal{G}amma(\rho_k, \rho_k)</code>
</p>

<p>Where <code class="reqn">K</code> is an upper bound on the number of states and
<code class="reqn">\beta_k</code> and <code class="reqn">\rho_k</code> are parameters when a state is
<code class="reqn">k</code> at <code class="reqn">t</code>.
</p>
<p>In the HDP-HSMM, there is a super-state sequence that, for a given
observation, is drawn from the transition distribution and then a
duration is drawn from a duration distribution to determin how long
that state will stay active. After that duration, a new super-state
is drawn from the transition distribution, where self-transitions
are  disallowed. The transition probabilities between states are
assumed to follow a heirarchical Dirichlet process:
</p>
<p style="text-align: center;"><code class="reqn">\pi_k \sim \mathcal{D}irichlet(\alpha\delta_1, \ldots ,
\alpha\delta_K)</code>
</p>

<p style="text-align: center;"><code class="reqn">\delta \sim \mathcal{D}irichlet(\gamma/K, \ldots, \gamma/K)</code>
</p>

<p>In the algorithm itself, these <code class="reqn">\pi</code> vectors are modified to
remove self-transitions as discussed above. There is a unique
duration distribution for each regime with the following
parameters:
</p>
<p style="text-align: center;"><code class="reqn">D_k \sim \mathcal{N}egBin(r, \omega_k)</code>
</p>

<p style="text-align: center;"><code class="reqn">\omega_k \sim \mathcal{B}eta(a_{\omega,k}, b_{\omega, k})</code>
</p>

<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_k \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, K</code>
</p>

<p>The overdispersion parameters have a prior with the following form:
</p>
<p style="text-align: center;"><code class="reqn">f(\rho_k|e,f,g) \propto \rho^{e-1}(\rho + g)^{-(e+f)}</code>
</p>

<p>The model is simulated via blocked Gibbs conditonal on the states.
The <code class="reqn">\beta</code> being simulated via the auxiliary mixture sampling
method of Fuerhwirth-Schanetter et al. (2009). The <code class="reqn">\rho</code> is
updated via slice sampling. The <code class="reqn">\nu_t</code> are updated their
(conjugate) full conditional, which is also Gamma. The states and
their durations are drawn as in Johnson &amp; Willsky (2013).
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Sylvia Fruehwirth-Schnatter, Rudolf Fruehwirth, Leonhard Held, and
Havard Rue. 2009. &ldquo;Improved auxiliary mixture sampling for
hierarchical models of non-Gaussian data&rdquo;, <em>Statistics
and Computing</em> 19(4): 479-492.
&lt;doi:10.1007/s11222-008-9109-4&gt;
</p>
<p>Matthew Blackwell. 2017. &ldquo;Game Changers: Detecting Shifts in
Overdispersed Count Data,&rdquo; <em>Political Analysis</em>
26(2), 230-239. &lt;doi:10.1017/pan.2017.42&gt;
</p>
<p>Matthew J. Johnson and Alan S. Willsky. 2013. &ldquo;Bayesian Nonparametric Hidden Semi-Markov Models.&rdquo; <em>Journal of Machine Learning Research</em>, 14(Feb), 673-701.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCnegbinChange">MCMCnegbinChange</a></code>,
<code><a href="#topic+HDPHMMnegbin">HDPHMMnegbin</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   n &lt;- 150
   reg &lt;- 3
   true.s &lt;- gl(reg, n/reg, n)
   rho.true &lt;- c(1.5, 0.5, 3)
   b1.true &lt;- c(1, -2, 2)
   x1 &lt;- runif(n, 0, 2)
   nu.true &lt;- rgamma(n, rho.true[true.s], rho.true[true.s])
   mu &lt;- nu.true * exp(1 + x1 * b1.true[true.s])
   y &lt;- rpois(n, mu)

   posterior &lt;- HDPHSMMnegbin(y ~ x1, K = 10, verbose = 1000,
                          e = 2, f = 2, g = 10,
                          b0 = 0, B0 = 1/9,
                          a.omega = 1, b.omega = 100, r = 1,
                          rho.step = rep(0.75, times = 10),
                          seed = list(NA, 2),
                          omega.start = 0.05, gamma.start = 10,
                          alpha.start = 5)

   plotHDPChangepoint(posterior, ylab="Density", start=1)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='HMMpanelFE'>Markov Chain Monte Carlo for the Hidden Markov Fixed-effects Model</h2><span id='topic+HMMpanelFE'></span>

<h3>Description</h3>

<p>HMMpanelFE generates a sample from the posterior distribution of
the fixed-effects model with varying individual effects model
discussed in Park (2011).  The code works for both balanced and
unbalanced panel data as long as there is no missing data in the
middle of each group.  This model uses a multivariate Normal prior
for the fixed effects parameters and varying individual effects, an
Inverse-Gamma prior on the residual error variance, and Beta prior
for transition probabilities. The user supplies data and priors,
and a sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMMpanelFE(
  subject.id,
  y,
  X,
  m,
  mcmc = 1000,
  burnin = 1000,
  thin = 1,
  verbose = 0,
  b0 = 0,
  B0 = 0.001,
  c0 = 0.001,
  d0 = 0.001,
  delta0 = 0,
  Delta0 = 0.001,
  a = NULL,
  b = NULL,
  seed = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMMpanelFE_+3A_subject.id">subject.id</code></td>
<td>
<p>A numeric vector indicating the group number. It
should start from 1.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_y">y</code></td>
<td>
<p>The response variable.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_x">X</code></td>
<td>
<p>The model matrix excluding the constant.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_m">m</code></td>
<td>
<p>A vector of break numbers for each subject in the panel.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burn-in.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0, the iteration number and the
posterior density samples are printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a
scalar or a column vector with dimension equal to the number of
betas. If this takes a scalar value, then that value will serve
as the prior mean for all of the betas.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of
betas.  If this takes a scalar value, then that value times an
identity matrix serves as the prior precision of beta. Default
value of 0 is equivalent to an improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). The
amount of information in the inverse Gamma prior is something
like that from <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). In
constructing the inverse Gamma prior, <code class="reqn">d_0</code> acts like the sum
of squared errors from the <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_delta0">delta0</code></td>
<td>
<p>The prior mean of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_delta0">Delta0</code></td>
<td>
<p>The prior precision of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition
probabilities.  By default, the expected duration is computed and
corresponding a and b values are assigned. The expected duration
is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition
probabilities.  By default, the expected duration is computed and
corresponding a and b values are assigned. The expected duration
is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA,
current R system seed is used.</p>
</td></tr>
<tr><td><code id="HMMpanelFE_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HMMpanelFE</code> simulates from the fixed-effect hidden Markov
pbject level: </p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{it} \sim \mathcal{N}(\alpha_{im},
\sigma^2_{im})</code>
</p>

<p>We assume standard, semi-conjugate priors: </p>
<p style="text-align: center;"><code class="reqn">\beta \sim
\mathcal{N}(b_0,B_0^{-1})</code>
</p>
<p> And: </p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2} \sim
\mathcal{G}amma(c_0/2, d_0/2)</code>
</p>
<p> And: </p>
<p style="text-align: center;"><code class="reqn">\alpha \sim
\mathcal{N}(delta_0,Delta_0^{-1})</code>
</p>
 <p><code class="reqn">\beta</code>, <code class="reqn">\alpha</code> and
<code class="reqn">\sigma^{-2}</code> are assumed <em>a priori</em> independent.
</p>
<p>And: </p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>
<p>OLS estimates are used for starting values.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This
object can be summarized by functions provided by the coda
package.  The object contains an attribute <code>sigma</code> storage
matrix that contains time-varying residual variance, an attribute
<code>state</code> storage matrix that contains posterior samples of
hidden states, and an attribute <code>delta</code> storage matrix
containing time-varying intercepts.
</p>


<h3>References</h3>

<p>Jong Hee Park, 2012. &ldquo;Unified Method for Dynamic and
Cross-Sectional Heterogeneity: Introducing Hidden Markov Panel
Models.&rdquo;  <em>American Journal of Political Science</em>.56:
1040-1054. &lt;doi: 10.1111/j.1540-5907.2012.00590.x&gt;
</p>
<p>Siddhartha Chib. 1998. &ldquo;Estimation and comparison of multiple
change-point models.&rdquo; <em>Journal of Econometrics</em>. 86: 221-241.
&lt;doi: 10.1016/S0304-4076(97)00115-2&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  ## data generating
  set.seed(1974)
  N &lt;- 30
  T &lt;- 80
  NT &lt;- N*T

  ## true parameter values
  true.beta &lt;- c(1, 1)
  true.sigma &lt;- 3
  x1 &lt;- rnorm(NT)
  x2 &lt;- runif(NT, 2, 4)

  ## group-specific breaks
  break.point = rep(T/2, N); break.sigma=c(rep(1, N));
  break.list &lt;- rep(1, N)

  X &lt;- as.matrix(cbind(x1, x2), NT, );
  y &lt;- rep(NA, NT)
  id  &lt;-  rep(1:N, each=NT/N)
  K &lt;-  ncol(X);
  true.beta &lt;- as.matrix(true.beta, K, 1)

  ## compute the break probability
  ruler &lt;- c(1:T)
  W.mat &lt;- matrix(NA, T, N)
  for (i in 1:N){
    W.mat[, i] &lt;- pnorm((ruler-break.point[i])/break.sigma[i])
  }
  Weight &lt;- as.vector(W.mat)

  ## draw time-varying individual effects and sample y
  j = 1
  true.sigma.alpha &lt;- 30
  true.alpha1 &lt;- true.alpha2 &lt;- rep(NA, N)
  for (i in 1:N){
    Xi &lt;- X[j:(j+T-1), ]
    true.mean &lt;- Xi  %*% true.beta
    weight &lt;- Weight[j:(j+T-1)]
    true.alpha1[i] &lt;- rnorm(1, 0, true.sigma.alpha)
    true.alpha2[i] &lt;- -1*true.alpha1[i]
    y[j:(j+T-1)] &lt;- ((1-weight)*true.mean + (1-weight)*rnorm(T, 0, true.sigma) +
    		    (1-weight)*true.alpha1[i]) +
    		    (weight*true.mean + weight*rnorm(T, 0, true.sigma) + weight*true.alpha2[i])
    j &lt;- j + T
  }

  ## extract the standardized residuals from the OLS with fixed-effects
  FEols &lt;- lm(y ~ X + as.factor(id) -1 )
  resid.all &lt;- rstandard(FEols)
  time.id &lt;- rep(1:80, N)

  ## model fitting
  G &lt;- 100
  BF &lt;- testpanelSubjectBreak(subject.id=id, time.id=time.id,
         resid= resid.all, max.break=3, minimum = 10,
         mcmc=G, burnin = G, thin=1, verbose=G,
         b0=0, B0=1/100, c0=2, d0=2, Time = time.id)

  ## get the estimated break numbers
  estimated.breaks &lt;- make.breaklist(BF, threshold=3)

  ## model fitting
  out &lt;- HMMpanelFE(subject.id = id, y, X=X, m =  estimated.breaks,
             mcmc=G, burnin=G, thin=1, verbose=G,
             b0=0, B0=1/100, c0=2, d0=2, delta0=0, Delta0=1/100)

  ## print out the slope estimate
  ## true values are 1 and 1
  summary(out)

  ## compare them with the result from the constant fixed-effects
  summary(FEols)

## End(Not run)

</code></pre>

<hr>
<h2 id='HMMpanelRE'>Markov Chain Monte Carlo for the Hidden Markov Random-effects Model</h2><span id='topic+HMMpanelRE'></span>

<h3>Description</h3>

<p>HMMpanelRE generates a sample from the posterior distribution of
the hidden Markov random-effects model discussed in Park (2011).
The code works for panel data with the same starting point.  The
sampling of panel parameters is based on Algorithm 2 of Chib and
Carlin (1999). This model uses a multivariate Normal prior for the
fixed effects parameters and varying individual effects, an
Inverse-Wishart prior on the random-effects parameters, an
Inverse-Gamma prior on the residual error variance, and Beta prior
for transition probabilities.  The user supplies data and priors,
and a sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMMpanelRE(
  subject.id,
  time.id,
  y,
  X,
  W,
  m = 1,
  mcmc = 1000,
  burnin = 1000,
  thin = 1,
  verbose = 0,
  b0 = 0,
  B0 = 0.001,
  c0 = 0.001,
  d0 = 0.001,
  r0,
  R0,
  a = NULL,
  b = NULL,
  seed = NA,
  beta.start = NA,
  sigma2.start = NA,
  D.start = NA,
  P.start = NA,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMMpanelRE_+3A_subject.id">subject.id</code></td>
<td>
<p>A numeric vector indicating the group number. It
should start from 1.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_time.id">time.id</code></td>
<td>
<p>A numeric vector indicating the time unit. It should
start from 1.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_y">y</code></td>
<td>
<p>The dependent variable</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_x">X</code></td>
<td>
<p>The model matrix of the fixed-effects</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_w">W</code></td>
<td>
<p>The model matrix of the random-effects. W should be a
subset of X.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burn-in.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0, the iteration number and the
posterior density samples are printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a
scalar or a column vector with dimension equal to the number of
betas. If this takes a scalar value, then that value will serve
as the prior mean for all of the betas.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of
betas.  If this takes a scalar value, then that value times an
identity matrix serves as the prior precision of beta. Default
value of 0 is equivalent to an improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). The
amount of information in the inverse Gamma prior is something
like that from <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). In
constructing the inverse Gamma prior, <code class="reqn">d_0</code> acts like the sum
of squared errors from the <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_r0">r0</code></td>
<td>
<p>The shape parameter for the Inverse-Wishart prior on
variance matrix for the random effects. Set r=q for an
uninformative prior where q is the number of random effects</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_r0">R0</code></td>
<td>
<p>The scale matrix for the Inverse-Wishart prior on
variance matrix for the random effects. This must be a square
q-dimension matrix. Use plausible variance regarding random
effects for the diagonal of R.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition
probabilities.  By default, the expected duration is computed and
corresponding a and b values are assigned. The expected duration
is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition
probabilities.  By default, the expected duration is computed and
corresponding a and b values are assigned. The expected duration
is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA,
current R system seed is used.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the beta vector. This can
either be a scalar or a column vector with dimension equal to the
number of betas.  The default value of NA will use draws from the
Uniform distribution with the same boundary with the data as the
starting value. If this is a scalar, that value will serve as the
starting value mean for all of the betas. When there is no
covariate, the log value of means should be used.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_sigma2.start">sigma2.start</code></td>
<td>
<p>The starting values for <code class="reqn">\sigma^2</code>. This
can either be a scalar or a column vector with dimension equal to
the number of states.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_d.start">D.start</code></td>
<td>
<p>The starting values for the beta vector. This can
either be a scalar or a column vector with dimension equal to the
number of betas. The default value of NA will use draws from the
Uniform distribution with the same boundary with the data as the
starting value. If this is a scalar, that value will serve as the
starting value mean for all of the betas. When there is no
covariate, the log value of means should be used.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix. A
user should provide a square matrix with dimension equal to the
number of states. By default, draws from the <code>Beta(0.9,
0.1)</code> are used to construct a proper transition matrix for each
raw except the last raw.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be
calculated?  Options are: <code>none</code> in which case the marginal
likelihood will not be calculated and <code>Chib95</code> in which case
the method of Chib (1995) is used.</p>
</td></tr>
<tr><td><code id="HMMpanelRE_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HMMpanelRE</code> simulates from the random-effect hidden Markov
panel model introduced by Park (2011).
</p>
<p>The model takes the following form: </p>
<p style="text-align: center;"><code class="reqn">y_i = X_i \beta_m + W_i
b_i + \varepsilon_i\;\; m = 1, \ldots, M</code>
</p>
<p> Where each group <code class="reqn">i</code> have
<code class="reqn">k_i</code> observations.  Random-effects parameters are assumed to
be time-varying at the system level: </p>
<p style="text-align: center;"><code class="reqn">b_i \sim
\mathcal{N}_q(0, D_m)</code>
</p>
 <p style="text-align: center;"><code class="reqn">\varepsilon_i \sim \mathcal{N}(0,
\sigma^2_m I_{k_i})</code>
</p>

<p>And the errors: We assume standard, conjugate priors: </p>
<p style="text-align: center;"><code class="reqn">\beta
\sim \mathcal{N}_p(b0, B0)</code>
</p>
<p> And: </p>
<p style="text-align: center;"><code class="reqn">\sigma^{2} \sim
\mathcal{IG}amma(c0/2, d0/2)</code>
</p>
<p> And: </p>
<p style="text-align: center;"><code class="reqn">D \sim
\mathcal{IW}ishart(r0, R0)</code>
</p>
<p> See Chib and Carlin (1999) for more
details.
</p>
<p>And: </p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>
<p><em>NOTE:</em> We do not provide default parameters for the priors on
the precision matrix for the random effects. When fitting one of
these models, it is of utmost importance to choose a prior that
reflects your prior beliefs about the random effects. Using the
<code>dwish</code> and <code>rwish</code> functions might be useful in choosing
these values.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This
object can be summarized by functions provided by the coda
package.  The object contains an attribute <code>prob.state</code>
storage matrix that contains the probability of <code class="reqn">state_i</code> for
each period, and the log-marginal likelihood of the model
(<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park, 2012. &ldquo;Unified Method for Dynamic and
Cross-Sectional Heterogeneity: Introducing Hidden Markov Panel
Models.&rdquo;  <em>American Journal of Political Science</em>.56:
1040-1054. &lt;doi: 10.1111/j.1540-5907.2012.00590.x&gt;
</p>
<p>Siddhartha Chib. 1998. &ldquo;Estimation and comparison of multiple
change-point models.&rdquo; <em>Journal of Econometrics</em>. 86:
221-241. &lt;doi: 10.1016/S0304-4076(97)00115-2&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of
Statistical Software</em>.  42(9): 1-21. <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  ## data generating
  set.seed(1977)
  Q &lt;- 3
  true.beta1   &lt;-  c(1, 1, 1) ; true.beta2   &lt;-  c(-1, -1, -1)
  true.sigma2 &lt;-  c(2, 5); true.D1 &lt;- diag(.5, Q); true.D2 &lt;- diag(2.5, Q)
  N=30; T=100;
  NT &lt;- N*T
  x1 &lt;- runif(NT, 1, 2)
  x2 &lt;- runif(NT, 1, 2)
  X &lt;- cbind(1, x1, x2);   W &lt;- X;   y &lt;- rep(NA, NT)

  ## true break numbers are one and at the center
  break.point = rep(T/2, N); break.sigma=c(rep(1, N));
  break.list &lt;- rep(1, N)
  id  &lt;-  rep(1:N, each=NT/N)
  K &lt;-  ncol(X);
  ruler &lt;- c(1:T)

  ## compute the weight for the break
  W.mat &lt;- matrix(NA, T, N)
  for (i in 1:N){
    W.mat[, i] &lt;- pnorm((ruler-break.point[i])/break.sigma[i])
  }
  Weight &lt;- as.vector(W.mat)

  ## data generating by weighting two means and variances
  j = 1
  for (i in 1:N){
    Xi &lt;- X[j:(j+T-1), ]
    Wi &lt;- W[j:(j+T-1), ]
    true.V1 &lt;- true.sigma2[1]*diag(T) + Wi%*%true.D1%*%t(Wi)
    true.V2 &lt;- true.sigma2[2]*diag(T) + Wi%*%true.D2%*%t(Wi)
    true.mean1 &lt;- Xi%*%true.beta1
    true.mean2 &lt;- Xi%*%true.beta2
    weight &lt;- Weight[j:(j+T-1)]
    y[j:(j+T-1)] &lt;- (1-weight)*true.mean1 + (1-weight)*chol(true.V1)%*%rnorm(T) +
      weight*true.mean2 + weight*chol(true.V2)%*%rnorm(T)
    j &lt;- j + T
  }
  ## model fitting
  subject.id &lt;- c(rep(1:N, each=T))
  time.id &lt;- c(rep(1:T, N))

  ## model fitting
  G &lt;- 100
  b0  &lt;- rep(0, K) ; B0  &lt;- solve(diag(100, K))
  c0  &lt;- 2; d0  &lt;- 2
  r0  &lt;- 5; R0  &lt;- diag(c(1, 0.1, 0.1))
  subject.id &lt;- c(rep(1:N, each=T))
  time.id &lt;- c(rep(1:T, N))
  out1 &lt;- HMMpanelRE(subject.id, time.id, y, X, W, m=1,
                     mcmc=G, burnin=G, thin=1, verbose=G,
                     b0=b0, B0=B0, c0=c0, d0=d0, r0=r0, R0=R0)

  ## latent state changes
  plotState(out1)

  ## print mcmc output
  summary(out1)




## End(Not run)

</code></pre>

<hr>
<h2 id='InvGamma'>The Inverse Gamma Distribution</h2><span id='topic+InvGamma'></span><span id='topic+dinvgamma'></span><span id='topic+rinvgamma'></span>

<h3>Description</h3>

<p>Density function and random generation from the inverse gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma(x, shape, scale = 1)

rinvgamma(n, shape, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvGamma_+3A_x">x</code></td>
<td>
<p>Scalar location to evaluate density.</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_shape">shape</code></td>
<td>
<p>Scalar shape parameter.</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_scale">scale</code></td>
<td>
<p>Scalar scale parameter (default value one).</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_n">n</code></td>
<td>
<p>Number of draws from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An inverse gamma random variable with shape <code class="reqn">a</code> and scale <code class="reqn">b</code>
has mean <code class="reqn">\frac{b}{a-1}</code> (assuming <code class="reqn">a&gt;1</code>) and variance
<code class="reqn">\frac{b^2}{(a-1)^2(a-2)}</code> (assuming <code class="reqn">a&gt;2</code>).
</p>


<h3>Value</h3>

<p><code>dinvgamma</code> evaluates the density at <code>x</code>.
</p>
<p><code>rinvgamma</code> takes <code>n</code> draws from the inverse Gamma distribution.
The parameterization is consistent with the Gamma Distribution in the stats
package.
</p>


<h3>References</h3>

<p>Andrew Gelman, John B. Carlin, Hal S. Stern, and Donald B.
Rubin. 2004. <em>Bayesian Data Analysis</em>. 2nd Edition. Boca Raton: Chapman
&amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+GammaDist">GammaDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
density &lt;- dinvgamma(4.2, 1.1)
draws &lt;- rinvgamma(10, 3.2)

</code></pre>

<hr>
<h2 id='InvWishart'>The Inverse Wishart Distribution</h2><span id='topic+InvWishart'></span><span id='topic+diwish'></span><span id='topic+riwish'></span>

<h3>Description</h3>

<p>Density function and random generation from the Inverse Wishart
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riwish(v, S)

diwish(W, v, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvWishart_+3A_v">v</code></td>
<td>
<p>Degrees of freedom (scalar).</p>
</td></tr>
<tr><td><code id="InvWishart_+3A_s">S</code></td>
<td>
<p>Scale matrix <code class="reqn">(p \times p)</code>.</p>
</td></tr>
<tr><td><code id="InvWishart_+3A_w">W</code></td>
<td>
<p>Positive definite matrix W <code class="reqn">(p \times p)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of an inverse Wishart random variable with <code>v</code> degrees of
freedom and scale matrix <code>S</code> is <code class="reqn">(v-p-1)^{-1}S</code>.
</p>


<h3>Value</h3>

<p><code>diwish</code> evaluates the density at positive definite matrix W.
<code>riwish</code> generates one random draw from the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
density &lt;- diwish(matrix(c(2,-.3,-.3,4),2,2), 3, matrix(c(1,.3,.3,1),2,2))
draw &lt;- riwish(3, matrix(c(1,.3,.3,1),2,2))

</code></pre>

<hr>
<h2 id='make.breaklist'>Vector of break numbers</h2><span id='topic+make.breaklist'></span>

<h3>Description</h3>

<p>This function generates a vector of break numbers using the output of
<code>testpanelSubjectBreak</code>.  The function performs a pairwise comparison
of models using Bayes Factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.breaklist(BF, threshold = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.breaklist_+3A_bf">BF</code></td>
<td>
<p>output of <code>testpanelSubjectBreak</code>.</p>
</td></tr>
<tr><td><code id="make.breaklist_+3A_threshold">threshold</code></td>
<td>
<p>The Bayes Factor threshold to pick the best model.  If a
Bayes factor of two models is smaller than <code>threshold</code>, the model with
a smaller number of break is chosen to avoid the over-identification
problem.  Users can change threshold into any positive number.  The default
value of 3 is chosen as it indicates the existence of &quot;substantial evidence&quot;
in favor of the model in the numerator according to Jeffreys' scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector fo break numbers.
</p>


<h3>References</h3>

<p>Jong Hee Park, 2012. &ldquo;Unified Method for Dynamic and
Cross-Sectional Heterogeneity: Introducing Hidden Markov Panel
Models.&rdquo;  <em>American Journal of Political Science</em>.56:
1040-1054. &lt;doi: 10.1111/j.1540-5907.2012.00590.x&gt;
</p>
<p>Harold Jeffreys, 1961. The Theory of Probability. Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testpanelSubjectBreak">testpanelSubjectBreak</a></code>
</p>

<hr>
<h2 id='MCbinomialbeta'>Monte Carlo Simulation from a Binomial Likelihood with a Beta Prior</h2><span id='topic+MCbinomialbeta'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
binomial likelihood with a Beta prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCbinomialbeta(y, n, alpha = 1, beta = 1, mc = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCbinomialbeta_+3A_y">y</code></td>
<td>
<p>The number of successes in the independent Bernoulli trials.</p>
</td></tr>
<tr><td><code id="MCbinomialbeta_+3A_n">n</code></td>
<td>
<p>The number of independent Bernoulli trials.</p>
</td></tr>
<tr><td><code id="MCbinomialbeta_+3A_alpha">alpha</code></td>
<td>
<p>Beta prior distribution alpha parameter.</p>
</td></tr>
<tr><td><code id="MCbinomialbeta_+3A_beta">beta</code></td>
<td>
<p>Beta prior distribution beta parameter.</p>
</td></tr>
<tr><td><code id="MCbinomialbeta_+3A_mc">mc</code></td>
<td>
<p>The number of Monte Carlo draws to make.</p>
</td></tr>
<tr><td><code id="MCbinomialbeta_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCbinomialbeta</code> directly simulates from the posterior distribution.
This model is designed primarily for instructional use.  <code class="reqn">\pi</code> is
the probability of success for each independent Bernoulli trial.  We assume
a conjugate Beta prior:
</p>
<p style="text-align: center;"><code class="reqn">\pi \sim \mathcal{B}eta(\alpha, \beta)</code>
</p>

<p><code class="reqn">y</code> is the number of successes in <code class="reqn">n</code> trials.  By
default, a uniform prior is used.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
posterior &lt;- MCbinomialbeta(3,12,mc=5000)
summary(posterior)
plot(posterior)
grid &lt;- seq(0,1,0.01)
plot(grid, dbeta(grid, 1, 1), type="l", col="red", lwd=3, ylim=c(0,3.6),
  xlab="pi", ylab="density")
lines(density(posterior), col="blue", lwd=3)
legend(.75, 3.6, c("prior", "posterior"), lwd=3, col=c("red", "blue"))

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCbinaryChange'>Markov Chain Monte Carlo for a Binary Multiple Changepoint Model</h2><span id='topic+MCMCbinaryChange'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a binary model with multiple changepoints. The function uses the
Markov chain Monte Carlo method of Chib (1998).  The user supplies
data and priors, and a sample from the posterior distribution is
returned as an mcmc object, which can be subsequently analyzed with
functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCbinaryChange(
  data,
  m = 1,
  c0 = 1,
  d0 = 1,
  a = NULL,
  b = NULL,
  burnin = 10000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  phi.start = NA,
  P.start = NA,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCbinaryChange_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0</code> is the shape1 parameter for Beta prior on
<code class="reqn">\phi</code> (the mean).</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0</code> is the shape2 parameter for Beta prior on
<code class="reqn">\phi</code> (the mean).</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition
probabilities.  By default, the expected duration is computed and
corresponding a and b values are assigned. The expected duration
is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition
probabilities.  By default, the expected duration is computed and
corresponding a and b values are assigned. The expected duration
is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burn-in.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0, the iteration number and the
posterior density samples are printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA,
current R system seed is used.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_phi.start">phi.start</code></td>
<td>
<p>The starting values for the mean. The default
value of NA will use draws from the Uniform distribution.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix. A
user should provide a square matrix with dimension equal to the
number of states. By default, draws from the <code>Beta(0.9,
0.1)</code> are used to construct a proper transition matrix for each
raw except the last raw.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be
calculated?  Options are: <code>none</code> in which case the marginal
likelihood will not be calculated, and <code>Chib95</code> in which
case the method of Chib (1995) is used.</p>
</td></tr>
<tr><td><code id="MCMCbinaryChange_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCbinaryChange</code> simulates from the posterior distribution
of a binary model with multiple changepoints.
</p>
<p>The model takes the following form: </p>
<p style="text-align: center;"><code class="reqn">Y_t \sim
\mathcal{B}ernoulli(\phi_i),\;\; i = 1, \ldots, k</code>
</p>
<p> Where <code class="reqn">k</code>
is the number of states.
</p>
<p>We assume Beta priors for <code class="reqn">\phi_{i}</code> and for transition
probabilities: </p>
<p style="text-align: center;"><code class="reqn">\phi_i \sim \mathcal{B}eta(c_0, d_0)</code>
</p>
<p> And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta{a}{b},\;\; m = 1, \ldots, k</code>
</p>
<p> Where
<code class="reqn">M</code> is the number of states.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This
object can be summarized by functions provided by the coda
package.  The object contains an attribute <code>prob.state</code>
storage matrix that contains the probability of <code class="reqn">state_i</code> for
each period, and the log-marginal likelihood of the model
(<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park. 2011. &ldquo;Changepoint Analysis of Binary
and Ordinal Probit Models: An Application to Bank Rate Policy
Under the Interwar Gold Standard.&quot;
<em>Political Analysis</em>. 19: 188-204.
&lt;doi:10.1093/pan/mpr007&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of
Statistical Software</em>.  42(9): 1-21.
<a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Siddhartha Chib. 1995. &ldquo;Marginal Likelihood from the Gibbs
Output.&rdquo;  <em>Journal of the American Statistical
Association</em>. 90: 1313-1321. &lt;doi: 10.1080/01621459.1995.10476635&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCpoissonChange">MCMCpoissonChange</a></code>,<code><a href="#topic+plotState">plotState</a></code>,
<code><a href="#topic+plotChangepoint">plotChangepoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    ## Not run: 
    set.seed(19173)
    true.phi&lt;- c(0.5, 0.8, 0.4)

    ## two breaks at c(80, 180)
    y1 &lt;- rbinom(80, 1,  true.phi[1])
    y2 &lt;- rbinom(100, 1, true.phi[2])
    y3 &lt;- rbinom(120, 1, true.phi[3])
    y  &lt;- as.ts(c(y1, y2, y3))

    model0 &lt;- MCMCbinaryChange(y, m=0, c0=2, d0=2, mcmc=100, burnin=100, verbose=50,
    	      marginal.likelihood = "Chib95")
    model1 &lt;- MCMCbinaryChange(y, m=1, c0=2, d0=2, mcmc=100, burnin=100, verbose=50,
    	      marginal.likelihood = "Chib95")
    model2 &lt;- MCMCbinaryChange(y, m=2, c0=2, d0=2, mcmc=100, burnin=100, verbose=50,
    	      marginal.likelihood = "Chib95")
    model3 &lt;- MCMCbinaryChange(y, m=3, c0=2, d0=2, mcmc=100, burnin=100, verbose=50,
    	      marginal.likelihood = "Chib95")
    model4 &lt;- MCMCbinaryChange(y, m=4, c0=2, d0=2, mcmc=100, burnin=100, verbose=50,
    	      marginal.likelihood = "Chib95")
    model5 &lt;- MCMCbinaryChange(y, m=5, c0=2, d0=2, mcmc=100, burnin=100, verbose=50,
    	      marginal.likelihood = "Chib95")

    print(BayesFactor(model0, model1, model2, model3, model4, model5))

    ## plot two plots in one screen
    par(mfrow=c(attr(model2, "m") + 1, 1), mai=c(0.4, 0.6, 0.3, 0.05))
    plotState(model2, legend.control = c(1, 0.6))
    plotChangepoint(model2, verbose = TRUE, ylab="Density", start=1, overlay=TRUE)

    
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCdynamicEI'>Markov Chain Monte Carlo for Quinn's Dynamic Ecological Inference Model</h2><span id='topic+MCMCdynamicEI'></span>

<h3>Description</h3>

<p>MCMCdynamicEI is used to fit Quinn's dynamic ecological inference
model for partially observed 2 x 2 contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCdynamicEI(
  r0,
  r1,
  c0,
  c1,
  burnin = 5000,
  mcmc = 50000,
  thin = 1,
  verbose = 0,
  seed = NA,
  W = 0,
  a0 = 0.825,
  b0 = 0.0105,
  a1 = 0.825,
  b1 = 0.0105,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCdynamicEI_+3A_r0">r0</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of row sums from row 0.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_r1">r1</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of row sums from row 1.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of column sums from
column 0.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_c1">c1</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of column sums from
column 1.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in scans for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of mcmc scans to be saved.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0 then every <code>verbose</code>th
iteration will be printed to the screen.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the
Mersenne Twister generator is used with default seed 12345; if an
integer is passed it is used to seed the Mersenne twister.  The
user can also pass a list of length two to use the L'Ecuyer
random number generator, which is suitable for parallel
computation.  The first element of the list is the L'Ecuyer seed,
which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a
positive substream number. See the MCMCpack specification for
more details.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_w">W</code></td>
<td>
<p>Weight (<em>not precision</em>) matrix structuring the
temporal dependence among elements of <code class="reqn">\theta_{0}</code> and
<code class="reqn">\theta_{1}</code>. The default value of 0 will construct a weight
matrix that corresponds to random walk priors for
<code class="reqn">\theta_{0}</code> and <code class="reqn">\theta_{1}</code>. The default assumes that
the tables are equally spaced throughout time and that the
elements of <code class="reqn">r0</code>, <code class="reqn">r1</code>, <code class="reqn">c0</code>, and <code class="reqn">c1</code> are
temporally ordered.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_a0">a0</code></td>
<td>
<p><code>a0/2</code> is the shape parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_0</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_b0">b0</code></td>
<td>
<p><code>b0/2</code> is the scale parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_0</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_a1">a1</code></td>
<td>
<p><code>a1/2</code> is the shape parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_1</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_b1">b1</code></td>
<td>
<p><code>b1/2</code> is the scale parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_1</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMCdynamicEI_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the following partially observed 2 by 2 contingency table
for unit <code class="reqn">t</code> where <code class="reqn">t=1,\ldots,ntables</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> | <code class="reqn">Y=0</code>    </td><td style="text-align: left;"> | <code class="reqn">Y=1</code>    </td><td style="text-align: left;"> |              </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------- </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">X=0</code> </td><td style="text-align: left;"> | <code class="reqn">Y_{0t}</code> </td><td style="text-align: left;"> |              </td><td style="text-align: left;"> | <code class="reqn">r_{0t}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------- </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">X=1</code> </td><td style="text-align: left;"> | <code class="reqn">Y_{1t}</code> </td><td style="text-align: left;"> |              </td><td style="text-align: left;"> | <code class="reqn">r_{1t}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------- </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> | <code class="reqn">c_{0t}</code> </td><td style="text-align: left;"> | <code class="reqn">c_{1t}</code> </td><td style="text-align: left;"> | <code class="reqn">N_t</code>
</td>
</tr>

</table>

<p>Where <code class="reqn">r_{0t}</code>, <code class="reqn">r_{1t}</code>, <code class="reqn">c_{0t}</code>, <code class="reqn">c_{1t}</code>, and
<code class="reqn">N_t</code> are non-negative integers that are observed. The interior
cell entries are not observed. It is assumed that
<code class="reqn">Y_{0t}|r_{0t} \sim \mathcal{B}inomial(r_{0t}, p_{0t})</code> and
<code class="reqn">Y_{1t}|r_{1t} \sim \mathcal{B}inomial(r_{1t}, p_{1t})</code>.  Let
<code class="reqn">\theta_{0t} = log(p_{0t}/(1-p_{0t}))</code>, and <code class="reqn">\theta_{1t} =
log(p_{1t}/(1-p_{1t}))</code>.
</p>
<p>The following prior distributions are assumed:
</p>
<p style="text-align: center;"><code class="reqn">p(\theta_0|\sigma^2_0) \propto \sigma_0^{-ntables} \exp \left(-\frac{1}{2\sigma^2_0} \theta'_{0} P \theta_{0}\right)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">p(\theta_1|\sigma^2_1) \propto \sigma_1^{-ntables} \exp \left(-\frac{1}{2\sigma^2_1} \theta'_{1} P \theta_{1}\right)</code>
</p>

<p>where <code class="reqn">P_{ts}</code> = <code class="reqn">-W_{ts}</code> for <code class="reqn">t</code> not equal to <code class="reqn">s</code>
and <code class="reqn">P_{tt}</code> = <code class="reqn">\sum_{s \ne t}W_{ts}</code>.  The
<code class="reqn">\theta_{0t}</code> is assumed to be a priori independent of
<code class="reqn">\theta_{1t}</code> for all t.  In addition, the following
hyperpriors are assumed: <code class="reqn">\sigma^2_0 \sim \mathcal{IG}(a_0/2,
b_0/2)</code>, and <code class="reqn">\sigma^2_1 \sim \mathcal{IG}(a_1/2, b_1/2)</code>.
</p>
<p>Inference centers on <code class="reqn">p_0</code>, <code class="reqn">p_1</code>, <code class="reqn">\sigma^2_0</code>, and
<code class="reqn">\sigma^2_1</code>.  Univariate slice sampling (Neal, 2003) together
with Gibbs sampling is used to sample from the posterior
distribution.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the sample from the posterior
distribution.  This object can be summarized by functions
provided by the coda package.
</p>


<h3>References</h3>

<p>Kevin Quinn. 2004. &ldquo;Ecological Inference in the Presence of Temporal
Dependence.&quot; In <em>Ecological Inference: New Methodological Strategies</em>.
Gary King, Ori Rosen, and Martin A. Tanner (eds.). New York: Cambridge
University Press.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Radford Neal. 2003. &ldquo;Slice Sampling&quot; (with discussion). <em>Annals of
Statistics</em>, 31: 705-767.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Jonathan C. Wakefield. 2004. &ldquo;Ecological Inference for 2 x 2 Tables.&rdquo;
<em>Journal of the Royal Statistical Society, Series A</em>. 167(3): 385445.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMChierEI">MCMChierEI</a></code>,
<code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
## simulated data example 1
set.seed(3920)
n &lt;- 100
r0 &lt;- rpois(n, 2000)
r1 &lt;- round(runif(n, 100, 4000))
p0.true &lt;- pnorm(-1.5 + 1:n/(n/2))
p1.true &lt;- pnorm(1.0 - 1:n/(n/4))
y0 &lt;- rbinom(n, r0, p0.true)
y1 &lt;- rbinom(n, r1, p1.true)
c0 &lt;- y0 + y1
c1 &lt;- (r0+r1) - c0

## plot data
dtomogplot(r0, r1, c0, c1, delay=0.1)

## fit dynamic model
post1 &lt;- MCMCdynamicEI(r0,r1,c0,c1, mcmc=40000, thin=5, verbose=100,
                    seed=list(NA, 1))

## fit exchangeable hierarchical model
post2 &lt;- MCMChierEI(r0,r1,c0,c1, mcmc=40000, thin=5, verbose=100,
                    seed=list(NA, 2))

p0meanDyn &lt;- colMeans(post1)[1:n]
p1meanDyn &lt;- colMeans(post1)[(n+1):(2*n)]
p0meanHier &lt;- colMeans(post2)[1:n]
p1meanHier &lt;- colMeans(post2)[(n+1):(2*n)]

## plot truth and posterior means
pairs(cbind(p0.true, p0meanDyn, p0meanHier, p1.true, p1meanDyn, p1meanHier))


## simulated data example 2
set.seed(8722)
n &lt;- 100
r0 &lt;- rpois(n, 2000)
r1 &lt;- round(runif(n, 100, 4000))
p0.true &lt;- pnorm(-1.0 + sin(1:n/(n/4)))
p1.true &lt;- pnorm(0.0 - 2*cos(1:n/(n/9)))
y0 &lt;- rbinom(n, r0, p0.true)
y1 &lt;- rbinom(n, r1, p1.true)
c0 &lt;- y0 + y1
c1 &lt;- (r0+r1) - c0

## plot data
dtomogplot(r0, r1, c0, c1, delay=0.1)

## fit dynamic model
post1 &lt;- MCMCdynamicEI(r0,r1,c0,c1, mcmc=40000, thin=5, verbose=100,
                    seed=list(NA, 1))

## fit exchangeable hierarchical model
post2 &lt;- MCMChierEI(r0,r1,c0,c1, mcmc=40000, thin=5, verbose=100,
                    seed=list(NA, 2))

p0meanDyn &lt;- colMeans(post1)[1:n]
p1meanDyn &lt;- colMeans(post1)[(n+1):(2*n)]
p0meanHier &lt;- colMeans(post2)[1:n]
p1meanHier &lt;- colMeans(post2)[(n+1):(2*n)]

## plot truth and posterior means
pairs(cbind(p0.true, p0meanDyn, p0meanHier, p1.true, p1meanDyn, p1meanHier))
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCdynamicIRT1d_b'>Markov Chain Monte Carlo for Dynamic One Dimensional Item Response
Theory Model</h2><span id='topic+MCMCdynamicIRT1d_b'></span><span id='topic+MCMCdynamicIRT1d'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a dynamic one dimensional item response theory (IRT) model, with
Normal random walk priors on the subject abilities (ideal points),
and multivariate Normal priors on the item parameters. The user
supplies data and priors, and a sample from the posterior
distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCdynamicIRT1d_b(
  datamatrix,
  item.time.map,
  theta.constraints = list(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  theta.start = NA,
  alpha.start = NA,
  beta.start = NA,
  tau2.start = 1,
  a0 = 0,
  A0 = 0.1,
  b0 = 0,
  B0 = 0.1,
  c0 = -1,
  d0 = -1,
  e0 = 0,
  E0 = 1,
  store.ability = TRUE,
  store.item = TRUE,
  ...
)

MCMCdynamicIRT1d(
  datamatrix,
  item.time.map,
  theta.constraints = list(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  theta.start = NA,
  alpha.start = NA,
  beta.start = NA,
  tau2.start = 1,
  a0 = 0,
  A0 = 0.1,
  b0 = 0,
  B0 = 0.1,
  c0 = -1,
  d0 = -1,
  e0 = 0,
  E0 = 1,
  store.ability = TRUE,
  store.item = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_datamatrix">datamatrix</code></td>
<td>
<p>The matrix of data.  Must be 0, 1, or missing
values.  The rows of <code>datamatrix</code> correspond to subjects and
the columns correspond to items.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_item.time.map">item.time.map</code></td>
<td>
<p>A vector that relates each item to a time
period.  Each element of <code>item.time.map</code> gives the time
period of the corresponding column of <code>datamatrix</code>. It is
assumed that the minimum value of <code>item.time.map</code> is 1.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_theta.constraints">theta.constraints</code></td>
<td>
<p>A list specifying possible simple equality
or inequality constraints on the ability parameters. A typical
entry in the list has one of three forms: <code>varname=c</code> which
will constrain the ability parameter for the subject named
<code>varname</code> to be equal to c, <code>varname="+"</code> which will
constrain the ability parameter for the subject named
<code>varname</code> to be positive, and <code>varname="-"</code> which will
constrain the ability parameter for the subject named
<code>varname</code> to be negative. If x is a matrix without row names
defaults names of &ldquo;V1&quot;,&ldquo;V2&quot;, ... , etc will be used. See Rivers
(2003) for a thorough discussion of identification of IRT models.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0 then every <code>verbose</code>th
iteration will be printed to the screen.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the
Mersenne Twister generator is used with default seed 12345; if an
integer is passed it is used to seed the Mersenne twister.  The
user can also pass a list of length two to use the L'Ecuyer
random number generator, which is suitable for parallel
computation.  The first element of the list is the L'Ecuyer seed,
which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a
positive substream number. See the MCMCpack specification for
more details.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_theta.start">theta.start</code></td>
<td>
<p>The starting values for the subject abilities
(ideal points). This can either be a scalar or a column vector
with dimension equal to the number of voters.  If this takes a
scalar value, then that value will serve as the starting value
for all of the thetas.  The default value of NA will choose the
starting values based on an eigenvalue-eigenvector decomposition
of the aggreement score matrix formed from the <code>datamatrix</code>.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_alpha.start">alpha.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\alpha</code>
difficulty parameters. This can either be a scalar or a column
vector with dimension equal to the number of items.  If this
takes a scalar value, then that value will serve as the starting
value for all of the alphas.  The default value of NA will set
the starting values based on a series of probit regressions that
condition on the starting values of theta.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code>
discrimination parameters. This can either be a scalar or a
column vector with dimension equal to the number of items.  If
this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA
will set the starting values based on a series of probit
regressions that condition on the starting values of theta.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_tau2.start">tau2.start</code></td>
<td>
<p>The starting values for the evolution variances
(the variance of the random walk increments for the ability
parameters / ideal points. Order corresponds to the rows of
<code>datamatrix</code>.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_a0">a0</code></td>
<td>
<p>A vector containing the prior mean of each of the
difficulty parameters <code class="reqn">\alpha</code>. Should have as many
elements as items / roll calls. Order corresponds to the columns
of <code>datamatrix</code>. If a scalar is passed it is assumed that
all elements of <code>a0</code> are equal to the scalar.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_a0">A0</code></td>
<td>
<p>A vector containing the prior precision (inverse
variance) of each of the difficulty parameters <code class="reqn">\alpha</code>.
Should have as many elements as items / roll calls. Order
corresponds to the columns of <code>datamatrix</code>. If a scalar is
passed it is assumed that all elements of <code>A0</code> are equal to
the scalar.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_b0">b0</code></td>
<td>
<p>A vector containing the prior mean of each of the
discrimination parameters <code class="reqn">\beta</code>. Should have as many
elements as items / roll calls. Order corresponds to the columns
of <code>datamatrix</code>. If a scalar is passed it is assumed that
all elements of <code>b0</code> are equal to the scalar.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_b0">B0</code></td>
<td>
<p>A vector containing the prior precision (inverse
variance) of each of the discrimination parameters
<code class="reqn">\beta</code>. Should have as many elements as items / roll
calls. Order corresponds to the columns of <code>datamatrix</code>. If
a scalar is passed it is assumed that all elements of <code>B0</code>
are equal to the scalar.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_{0/2}</code> is the shape parameter for the inverse
Gamma prior on <code class="reqn">\tau^2</code> (the variance of the random walk
increments).  The amount of information in the inverse Gamma
prior is something like that from <code class="reqn">c_0</code>
pseudo-observations. <code>c0</code> can be either a vector with an
element for each subject or a scalar. If <code>c0</code> is negative
then <code class="reqn">\tau^2</code> is not estimated&ndash; the values in
<code>tau2.start</code> are used throughout the sampling.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_{0/2}</code> is the scale parameter for the inverse
Gamma prior on <code class="reqn">\tau^2</code> (the variance of the random walk
increments).  In constructing the inverse Gamma prior, <code class="reqn">d_0</code>
acts like the sum of squared errors from the <code class="reqn">c_0</code>
pseudo-observations. <code>d0</code> can be either a vector with an
element for each subject or a scalar. If <code>d0</code> is negative
then <code class="reqn">\tau^2</code> is not estimated&ndash; the values in
<code>tau2.start</code> are used throughout the sampling.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_e0">e0</code></td>
<td>
<p>A vector containing the prior mean of the initial ability
parameter / ideal point for each subject. Should have as many
elements as subjects. Order corresponds to the rows of
<code>datamatrix</code>. If a scalar is passed it is assumed that all
elements of <code>e0</code> are equal to the scalar.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_e0">E0</code></td>
<td>
<p>A vector containing the prior variance of the initial
ability parameter / ideal point for each subject. Should have as
many elements as subjects. Order corresponds to the rows of
<code>datamatrix</code>. If a scalar is passed it is assumed that all
elements of <code>E0</code> are equal to the scalar.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_store.ability">store.ability</code></td>
<td>
<p>A switch that determines whether or not to
store the ability parameters for posterior analysis.
<em>NOTE</em>: In situations with many individuals storing the
ability parameters takes an enormous amount of memory, so
<code>store.ability</code> should only be <code>TRUE</code> if the chain is
thinned heavily, or for applications with a small number of
individuals.  By default, the item parameters are stored.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_store.item">store.item</code></td>
<td>
<p>A switch that determines whether or not to store
the item parameters for posterior analysis.  <em>NOTE</em>: In
situations with many items storing the item parameters takes an
enormous amount of memory, so <code>store.item</code> should only be
<code>FALSE</code> if the chain is thinned heavily, or for applications
with a small number of items.  By default, the item parameters
are not stored.</p>
</td></tr>
<tr><td><code id="MCMCdynamicIRT1d_b_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCdynamicIRT1d</code> simulates from the posterior distribution
using the algorithm of Martin and Quinn (2002). The simulation
proper is done in compiled C++ code to maximize efficiency.  Please
consult the coda documentation for a comprehensive list of
functions that can be used to analyze the posterior sample.
</p>
<p>The model takes the following form. We assume that each subject has
an subject ability (ideal point) denoted <code class="reqn">\theta_{j,t}</code> (where
<code class="reqn">j</code> indexes subjects and <code class="reqn">t</code> indexes time periods) and that
each item has a difficulty parameter <code class="reqn">\alpha_i</code> and
discrimination parameter <code class="reqn">\beta_i</code>. The observed choice by
subject <code class="reqn">j</code> on item <code class="reqn">i</code> is the observed data matrix which
is <code class="reqn">(I \times J)</code>. We assume that the choice is dictated by an
unobserved utility:
</p>
<p style="text-align: center;"><code class="reqn">z_{i,j,t} = -\alpha_i + \beta_i \theta_{j,t} +
\varepsilon_{i,j,t}</code>
</p>

<p>Where the disturbances are assumed to be distributed standard
Normal. The parameters of interest are the subject abilities (ideal
points) and the item parameters.
</p>
<p>We assume the following priors.  For the subject abilities (ideal
points):
</p>
<p style="text-align: center;"><code class="reqn">\theta_{j,t} \sim \mathcal{N}(\theta_{j,t-1}, \tau^2_j)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">\theta_{j,0} \sim \mathcal{N}(e0, E0)</code>
</p>
<p>.
</p>
<p>The evolution variance has the following prior:
</p>
<p style="text-align: center;"><code class="reqn">\tau^2_j \sim \mathcal{IG}(c0/2, d0/2)</code>
</p>
<p>.
</p>
<p>For the item parameters in the standard model, the prior is:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_i \sim \mathcal{N}(a0, A0^{-1})</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \sim \mathcal{N}(b0, B0^{-1})</code>
</p>
<p>.
</p>
<p>The model is identified by the proper priors on the item parameters
and constraints placed on the ability parameters.
</p>
<p>As is the case with all measurement models, make sure that you have
plenty of free memory, especially when storing the item parameters.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This
object can be summarized by functions provided by the coda
package.
</p>


<h3>Author(s)</h3>

<p>Kevin M. Quinn
</p>


<h3>References</h3>

<p>Andrew D. Martin and Kevin M. Quinn. 2002. &quot;Dynamic Ideal Point
Estimation via Markov Chain Monte Carlo for the U.S. Supreme Court,
1953-1999.&quot; <em>Political Analysis.</em> 10: 134-153. &lt;doi:10.1093/pan/10.2.134&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCirt1d">MCMCirt1d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
	data(Rehnquist)

	## assign starting values
	theta.start &lt;- rep(0, 9)
	theta.start[2] &lt;- -3 ## Stevens
	theta.start[7] &lt;- 2  ## Thomas

	out &lt;- MCMCdynamicIRT1d(t(Rehnquist[,1:9]),
	                        item.time.map=Rehnquist$time,
	                        theta.start=theta.start,
	                        mcmc=50000, burnin=20000, thin=5,
	                        verbose=500, tau2.start=rep(0.1, 9),
	                        e0=0, E0=1,
	                        a0=0, A0=1,
	                        b0=0, B0=1, c0=-1, d0=-1,
	                        store.item=FALSE,
	                        theta.constraints=list(Stevens="-", Thomas="+"))

	summary(out)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCfactanal'>Markov Chain Monte Carlo for Normal Theory Factor Analysis Model</h2><span id='topic+MCMCfactanal'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a normal theory factor analysis model. Normal priors are assumed on
the factor loadings and factor scores while inverse Gamma priors
are assumed for the uniquenesses. The user supplies data and
parameters for the prior distributions, and a sample from the
posterior distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCfactanal(
  x,
  factors,
  lambda.constraints = list(),
  data = NULL,
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  lambda.start = NA,
  psi.start = NA,
  l0 = 0,
  L0 = 0,
  a0 = 0.001,
  b0 = 0.001,
  store.scores = FALSE,
  std.var = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCfactanal_+3A_x">x</code></td>
<td>
<p>Either a formula or a numeric matrix containing the
manifest variables.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_factors">factors</code></td>
<td>
<p>The number of factors to be fitted.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_lambda.constraints">lambda.constraints</code></td>
<td>
<p>List of lists specifying possible simple
equality or inequality constraints on the factor loadings. A
typical entry in the list has one of three forms:
<code>varname=list(d,c)</code> which will constrain the dth loading for
the variable named <code>varname</code> to be equal to c,
<code>varname=list(d,"+")</code> which will constrain the dth loading
for the variable named <code>varname</code> to be positive, and
<code>varname=list(d, "-")</code> which will constrain the dth loading
for the variable named <code>varname</code> to be negative. If x is a
matrix without column names defaults names of &ldquo;V1&quot;,&ldquo;V2&quot;, ... ,
etc will be used.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0 the iteration number and the
factor loadings and uniquenesses are printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the
Mersenne Twister generator is used with default seed 12345; if an
integer is passed it is used to seed the Mersenne twister.  The
user can also pass a list of length two to use the L'Ecuyer
random number generator, which is suitable for parallel
computation.  The first element of the list is the L'Ecuyer seed,
which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a
positive substream number. See the MCMCpack specification for
more details.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_lambda.start">lambda.start</code></td>
<td>
<p>Starting values for the factor loading matrix
Lambda. If <code>lambda.start</code> is set to a scalar the starting
value for all unconstrained loadings will be set to that
scalar. If <code>lambda.start</code> is a matrix of the same dimensions
as Lambda then the <code>lambda.start</code> matrix is used as the
starting values (except for equality-constrained elements). If
<code>lambda.start</code> is set to <code>NA</code> (the default) then
starting values for unconstrained elements are set to 0, and
starting values for inequality constrained elements are set to
either 0.5 or -0.5 depending on the nature of the constraints.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_psi.start">psi.start</code></td>
<td>
<p>Starting values for the uniquenesses. If
<code>psi.start</code> is set to a scalar then the starting value for
all diagonal elements of <code>Psi</code> are set to this value. If
<code>psi.start</code> is a <code class="reqn">k</code>-vector (where <code class="reqn">k</code> is the number
of manifest variables) then the staring value of <code>Psi</code> has
<code>psi.start</code> on the main diagonal. If <code>psi.start</code> is set
to <code>NA</code> (the default) the starting values of all the
uniquenesses are set to 0.5.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_l0">l0</code></td>
<td>
<p>The means of the independent Normal prior on the factor loadings.
Can be either a scalar or a matrix with the same dimensions as
<code>Lambda</code>.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_l0">L0</code></td>
<td>
<p>The precisions (inverse variances) of the independent Normal prior
on the factor loadings. Can be either a scalar or a matrix with the same
dimensions as <code>Lambda</code>.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_a0">a0</code></td>
<td>
<p>Controls the shape of the inverse Gamma prior on the uniqueness.
The actual shape parameter is set to <code>a0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_b0">b0</code></td>
<td>
<p>Controls the scale of the inverse Gamma prior on the uniquenesses.
The actual scale parameter is set to <code>b0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_store.scores">store.scores</code></td>
<td>
<p>A switch that determines whether or not to store the
factor scores for posterior analysis.  <em>NOTE: This takes an enormous
amount of memory, so should only be used if the chain is thinned heavily, or
for applications with a small number of observations</em>.  By default, the
factor scores are not stored.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_std.var">std.var</code></td>
<td>
<p>If <code>TRUE</code> (the default) the manifest variables are
rescaled to have zero mean and unit variance. Otherwise, the manifest
variables are rescaled to have zero mean but retain their observed
variances.</p>
</td></tr>
<tr><td><code id="MCMCfactanal_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">x_i = \Lambda \phi_i + \epsilon_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_i \sim \mathcal{N}(0,\Psi)</code>
</p>

<p>where <code class="reqn">x_i</code> is the <code class="reqn">k</code>-vector of observed variables
specific to observation <code class="reqn">i</code>, <code class="reqn">\Lambda</code> is the <code class="reqn">k \times
d</code> matrix of factor loadings, <code class="reqn">\phi_i</code> is the <code class="reqn">d</code>-vector of
latent factor scores, and <code class="reqn">\Psi</code> is a diagonal, positive
definite matrix. Traditional factor analysis texts refer to the
diagonal elements of <code class="reqn">\Psi</code> as uniquenesses.
</p>
<p>The implementation used here assumes independent conjugate priors
for each element of <code class="reqn">\Lambda</code> each <code class="reqn">\phi_i</code>, and each
diagonal element of <code class="reqn">\Psi</code>. More specifically we assume:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_{ij} \sim \mathcal{N}(l_{0_{ij}}, L_{0_{ij}}^{-1}),
i=1,\ldots,k, j=1,\ldots,d</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_i \sim \mathcal{N}(0, I), i=1,\dots,n</code>
</p>

<p style="text-align: center;"><code class="reqn">\Psi_{ii} \sim \mathcal{IG}(a_{0_i}/2, b_{0_i}/2),
i=1,\ldots,k</code>
</p>

<p><code>MCMCfactanal</code> simulates from the posterior distribution using
standard Gibbs sampling. The simulation proper is done in compiled
C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be
used to analyze the posterior sample.
</p>
<p>As is the case with all measurement models, make sure that you have
plenty of free memory, especially when storing the scores.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the sample from the posterior
distribution. This object can be summarized by functions provided by the
coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,<code><a href="stats.html#topic+factanal">factanal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   ### An example using the formula interface
   data(swiss)
   posterior &lt;- MCMCfactanal(~Agriculture+Examination+Education+Catholic
                    +Infant.Mortality, factors=2,
                    lambda.constraints=list(Examination=list(1,"+"),
                       Examination=list(2,"-"), Education=c(2,0),
                       Infant.Mortality=c(1,0)),
                    verbose=0, store.scores=FALSE, a0=1, b0=0.15,
                    data=swiss, burnin=5000, mcmc=50000, thin=20)
   plot(posterior)
   summary(posterior)

   ### An example using the matrix interface
   Y &lt;- cbind(swiss$Agriculture, swiss$Examination,
              swiss$Education, swiss$Catholic,
              swiss$Infant.Mortality)
   colnames(Y) &lt;- c("Agriculture", "Examination", "Education", "Catholic",
                    "Infant.Mortality")
   post &lt;- MCMCfactanal(Y, factors=2,
                        lambda.constraints=list(Examination=list(1,"+"),
                          Examination=list(2,"-"), Education=c(2,0),
                          Infant.Mortality=c(1,0)),
                        verbose=0, store.scores=FALSE, a0=1, b0=0.15,
                        burnin=5000, mcmc=50000, thin=20)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMChierEI'>Markov Chain Monte Carlo for Wakefield's Hierarchial Ecological Inference
Model</h2><span id='topic+MCMChierEI'></span>

<h3>Description</h3>

<p>&lsquo;MCMChierEI&rsquo; is used to fit Wakefield's hierarchical ecological
inference model for partially observed 2 x 2 contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMChierEI(
  r0,
  r1,
  c0,
  c1,
  burnin = 5000,
  mcmc = 50000,
  thin = 1,
  verbose = 0,
  seed = NA,
  m0 = 0,
  M0 = 2.287656,
  m1 = 0,
  M1 = 2.287656,
  a0 = 0.825,
  b0 = 0.0105,
  a1 = 0.825,
  b1 = 0.0105,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMChierEI_+3A_r0">r0</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of row sums from row 0.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_r1">r1</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of row sums from row 1.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of column sums from
column 0.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_c1">c1</code></td>
<td>
<p><code class="reqn">(ntables \times 1)</code> vector of column sums from
column 1.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in scans for the sampler.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of mcmc scans to be saved.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen. If <code>verbose</code> is greater than 0 then
every <code>verbose</code>th iteration will be printed to the screen.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_m0">m0</code></td>
<td>
<p>Prior mean of the <code class="reqn">\mu_0</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_m0">M0</code></td>
<td>
<p>Prior variance of the <code class="reqn">\mu_0</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_m1">m1</code></td>
<td>
<p>Prior mean of the <code class="reqn">\mu_1</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_m1">M1</code></td>
<td>
<p>Prior variance of the <code class="reqn">\mu_1</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_a0">a0</code></td>
<td>
<p><code>a0/2</code> is the shape parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_0</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_b0">b0</code></td>
<td>
<p><code>b0/2</code> is the scale parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_0</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_a1">a1</code></td>
<td>
<p><code>a1/2</code> is the shape parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_1</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_b1">b1</code></td>
<td>
<p><code>b1/2</code> is the scale parameter for the inverse-gamma
prior on the <code class="reqn">\sigma^2_1</code> parameter.</p>
</td></tr>
<tr><td><code id="MCMChierEI_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the following partially observed 2 by 2 contingency table
for unit <code class="reqn">t</code> where <code class="reqn">t=1,\ldots,ntables</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> | <code class="reqn">Y=0</code>    </td><td style="text-align: left;"> | <code class="reqn">Y=1</code>    </td><td style="text-align: left;"> |              </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------- </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">X=0</code> </td><td style="text-align: left;"> | <code class="reqn">Y_{0t}</code> </td><td style="text-align: left;"> |              </td><td style="text-align: left;"> | <code class="reqn">r_{0t}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------- </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">X=1</code> </td><td style="text-align: left;"> | <code class="reqn">Y_{1t}</code> </td><td style="text-align: left;"> |              </td><td style="text-align: left;"> | <code class="reqn">r_{1t}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------- </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td><td style="text-align: left;"> ------------   </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> | <code class="reqn">c_{0t}</code> </td><td style="text-align: left;"> | <code class="reqn">c_{1t}</code> </td><td style="text-align: left;"> | <code class="reqn">N_t</code>
</td>
</tr>

</table>

<p>Where <code class="reqn">r_{0t}</code>, <code class="reqn">r_{1t}</code>, <code class="reqn">c_{0t}</code>, <code class="reqn">c_{1t}</code>, and
<code class="reqn">N_t</code> are non-negative integers that are observed. The interior
cell entries are not observed. It is assumed that
<code class="reqn">Y_{0t}|r_{0t} \sim \mathcal{B}inomial(r_{0t}, p_{0t})</code> and
<code class="reqn">Y_{1t}|r_{1t} \sim \mathcal{B}inomial(r_{1t}, p_{1t})</code>.  Let
<code class="reqn">\theta_{0t} = log(p_{0t}/(1-p_{0t}))</code>, and <code class="reqn">\theta_{1t} =
log(p_{1t}/(1-p_{1t}))</code>.
</p>
<p>The following prior distributions are assumed: <code class="reqn">\theta_{0t}
\sim \mathcal{N}(\mu_0, \sigma^2_0)</code>, <code class="reqn">\theta_{1t} \sim
\mathcal{N}(\mu_1, \sigma^2_1)</code>.  <code class="reqn">\theta_{0t}</code> is assumed to
be a priori independent of <code class="reqn">\theta_{1t}</code> for all t.  In
addition, we assume the following hyperpriors: <code class="reqn">\mu_0 \sim
\mathcal{N}(m_0, M_0)</code>, <code class="reqn">\mu_1 \sim \mathcal{N}(m_1, M_1)</code>,
<code class="reqn">\sigma^2_0 \sim \mathcal{IG}(a_0/2, b_0/2)</code>, and
<code class="reqn">\sigma^2_1 \sim \mathcal{IG}(a_1/2, b_1/2)</code>.
</p>
<p>The default priors have been chosen to make the implied prior
distribution for <code class="reqn">p_{0}</code> and <code class="reqn">p_{1}</code> <em>approximately</em>
uniform on (0,1).
</p>
<p>Inference centers on <code class="reqn">p_0</code>, <code class="reqn">p_1</code>, <code class="reqn">\mu_0</code>,
<code class="reqn">\mu_1</code>, <code class="reqn">\sigma^2_0</code>, and <code class="reqn">\sigma^2_1</code>.  Univariate
slice sampling (Neal, 2003) along with Gibbs sampling is used to
sample from the posterior distribution.
</p>
<p>See Section 5.4 of Wakefield (2003) for discussion of the priors
used here.  <code>MCMChierEI</code> departs from the Wakefield model in
that the <code>mu0</code> and <code>mu1</code> are here assumed to be drawn
from independent normal distributions whereas Wakefield assumes
they are drawn from logistic distributions.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the sample from the posterior
distribution.  This object can be summarized by functions
provided by the coda package.
</p>


<h3>References</h3>

<p>Jonathan C. Wakefield. 2004. &ldquo;Ecological Inference for 2 x 2
Tables.&rdquo; <em>Journal of the Royal Statistical Society, Series A</em>. 167(3):
385445.
</p>
<p>Radford Neal. 2003. &ldquo;Slice Sampling&quot; (with discussion). <em>Annals of
Statistics</em>, 31: 705-767.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCdynamicEI">MCMCdynamicEI</a></code>,
<code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
## simulated data example
set.seed(3920)
n &lt;- 100
r0 &lt;- round(runif(n, 400, 1500))
r1 &lt;- round(runif(n, 100, 4000))
p0.true &lt;- pnorm(rnorm(n, m=0.5, s=0.25))
p1.true &lt;- pnorm(rnorm(n, m=0.0, s=0.10))
y0 &lt;- rbinom(n, r0, p0.true)
y1 &lt;- rbinom(n, r1, p1.true)
c0 &lt;- y0 + y1
c1 &lt;- (r0+r1) - c0

## plot data
tomogplot(r0, r1, c0, c1)

## fit exchangeable hierarchical model
post &lt;- MCMChierEI(r0,r1,c0,c1, mcmc=40000, thin=5, verbose=100,
                    seed=list(NA, 1))

p0meanHier &lt;- colMeans(post)[1:n]
p1meanHier &lt;- colMeans(post)[(n+1):(2*n)]

## plot truth and posterior means
pairs(cbind(p0.true, p0meanHier, p1.true, p1meanHier))
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMChlogit'>Markov Chain Monte Carlo for the Hierarchical Binomial Linear Regression
Model using the logit link function</h2><span id='topic+MCMChlogit'></span>

<h3>Description</h3>

<p>MCMChlogit generates a sample from the posterior distribution of a
Hierarchical Binomial Linear Regression Model using the logit link function
and Algorithm 2 of Chib and Carlin (1999). This model uses a multivariate
Normal prior for the fixed effects parameters, an Inverse-Wishart prior on
the random effects variance matrix, and an Inverse-Gamma prior on the
variance modelling over-dispersion. The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc object, which
can be subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMChlogit(
  fixed,
  random,
  group,
  data,
  burnin = 5000,
  mcmc = 10000,
  thin = 10,
  verbose = 1,
  seed = NA,
  beta.start = NA,
  sigma2.start = NA,
  Vb.start = NA,
  mubeta = 0,
  Vbeta = 1e+06,
  r,
  R,
  nu = 0.001,
  delta = 0.001,
  FixOD = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMChlogit_+3A_fixed">fixed</code></td>
<td>
<p>A two-sided linear formula of the form 'y~x1+...+xp' describing
the fixed-effects part of the model, with the response on the left of a '~'
operator and the p fixed terms, separated by '+' operators, on the right.
Response variable y must be 0 or 1 (Binomial process).</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_random">random</code></td>
<td>
<p>A one-sided formula of the form '~x1+...+xq' specifying the
model for the random effects part of the model, with the q random terms,
separated by '+' operators.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_group">group</code></td>
<td>
<p>String indicating the name of the grouping variable in
<code>data</code>, defining the hierarchical structure of the model.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_burnin">burnin</code></td>
<td>
<p>The number of burnin iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler. Total number of
Gibbs iterations is equal to <code>burnin+mcmc</code>. <code>burnin+mcmc</code> must be
divisible by 10 and superior or equal to 100 so that the progress bar can be
displayed.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation. The number of mcmc
iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_verbose">verbose</code></td>
<td>
<p>A switch (0,1) which determines whether or not the progress
of the sampler is printed to the screen. Default is 1: a progress bar is
printed, indicating the step (in %) reached by the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator. If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector. This
can either be a scalar or a p-length vector. The default value of NA will
use the OLS <code class="reqn">\beta</code> estimate of the corresponding Gaussian Linear
Regression without random effects. If this is a scalar, that value will
serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_sigma2.start">sigma2.start</code></td>
<td>
<p>Scalar for the starting value of the residual error
variance. The default value of NA will use the OLS estimates of the
corresponding Gaussian Linear Regression without random effects.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_vb.start">Vb.start</code></td>
<td>
<p>The starting value for variance matrix of the random
effects. This must be a square q-dimension matrix. Default value of NA uses
an identity matrix.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_mubeta">mubeta</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>. This can either be a
scalar or a p-length vector. If this takes a scalar value, then that value
will serve as the prior mean for all of the betas. The default value of 0
will use a vector of zeros for an uninformative prior.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_vbeta">Vbeta</code></td>
<td>
<p>The prior variance of <code class="reqn">\beta</code>.  This can either be a
scalar or a square p-dimension matrix. If this takes a scalar value, then
that value times an identity matrix serves as the prior variance of beta.
Default value of 1.0E6 will use a diagonal matrix with very large variance
for an uninformative flat prior.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_r">r</code></td>
<td>
<p>The shape parameter for the Inverse-Wishart prior on variance
matrix for the random effects. r must be superior or equal to q. Set r=q for
an uninformative prior. See the NOTE for more details</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_r">R</code></td>
<td>
<p>The scale matrix for the Inverse-Wishart prior on variance matrix
for the random effects. This must be a square q-dimension matrix. Use
plausible variance regarding random effects for the diagonal of R. See the
NOTE for more details</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_nu">nu</code></td>
<td>
<p>The shape parameter for the Inverse-Gamma prior on the residual
error variance. Default value is <code>nu=delta=0.001</code> for uninformative
prior.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_delta">delta</code></td>
<td>
<p>The rate (1/scale) parameter for the Inverse-Gamma prior on the
residual error variance. Default value is <code>nu=delta=0.001</code> for
uninformative prior.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_fixod">FixOD</code></td>
<td>
<p>A switch (0,1) which determines whether or not the variance for
over-dispersion (sigma2) should be fixed (1) or not (0). Default is 0,
parameter sigma2 is estimated. If FixOD=1, sigma2 is fixed to the value
provided for <code>sigma2.start</code>.</p>
</td></tr>
<tr><td><code id="MCMChlogit_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMChlogit</code> simulates from the posterior distribution sample using the
blocked Gibbs sampler of Chib and Carlin (1999), Algorithm 2. The simulation
is done in compiled C++ code to maximize efficiency. Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim \mathcal{B}ernoulli(\theta_i)</code>
</p>

<p>With latent variables <code class="reqn">\phi(\theta_i)</code>, <code class="reqn">\phi</code> being the
logit link function:
</p>
<p style="text-align: center;"><code class="reqn">\phi(\theta_i) = X_i \beta + W_i b_i + \varepsilon_i</code>
</p>

<p>Where each group <code class="reqn">i</code> have <code class="reqn">k_i</code> observations.
</p>
<p>Where the random effects:
</p>
<p style="text-align: center;"><code class="reqn">b_i \sim \mathcal{N}_q(0,V_b)</code>
</p>

<p>And the over-dispersion terms:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_i \sim \mathcal{N}(0, \sigma^2 I_{k_i})</code>
</p>

<p>We assume standard, conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}_p(\mu_{\beta},V_{\beta})</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{2} \sim \mathcal{IG}amma(\nu, 1/\delta)</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">V_b \sim \mathcal{IW}ishart(r, rR)</code>
</p>
<p> See Chib and Carlin
(1999) for more details.
</p>
<p><em>NOTE:</em> We do not provide default parameters for the priors on
the precision matrix for the random effects. When fitting one of
these models, it is of utmost importance to choose a prior that
reflects your prior beliefs about the random effects. Using the
<code>dwish</code> and <code>rwish</code> functions might be useful in choosing
these values.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mcmc</code></td>
<td>
<p>An mcmc object that contains the posterior sample. This
object can be summarized by functions provided by the coda
package. The posterior sample of the deviance <code class="reqn">D</code>, with
<code class="reqn">D=-2\log(\prod_i P(y_i|\theta_i))</code>, is also provided.</p>
</td></tr>
<tr><td><code>theta.pred</code></td>
<td>
<p>Predictive posterior mean for the inverse-logit
of the latent variables. The approximation of Diggle et al. (2004)
is used to marginalized with respect to over-dispersion terms:
</p>
<p style="text-align: center;"><code class="reqn">E[\theta_i|\beta,b_i,\sigma^2]=\phi^{-1}((X_i\beta+W_ib_i)/\sqrt{(16\sqrt{3}/15\pi)^2\sigma^2+1})</code>
</p>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ghislain Vieilledent &lt;ghislain.vieilledent@cirad.fr&gt;
</p>


<h3>References</h3>

<p>Siddhartha Chib and Bradley P. Carlin. 1999. &ldquo;On MCMC Sampling
in Hierarchical Longitudinal Models.&rdquo; <em>Statistics and Computing.</em> 9:
17-26.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Andrew D. Martin and Kyle L. Saunders. 2002. &ldquo;Bayesian Inference for
Political Science Panel Data.&rdquo; Paper presented at the 2002 Annual Meeting
of the American Political Science Association.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Diggle P., Heagerty P., Liang K., and Zeger S. 2004. &ldquo;Analysis of
Longitudinal Data.&rdquo; <em>Oxford University Press</em>, 2sd Edition.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#========================================
# Hierarchical Binomial Linear Regression
#========================================

#== inv.logit function
inv.logit &lt;- function(x, min=0, max=1) {
    p &lt;- exp(x)/(1+exp(x))
    p &lt;- ifelse( is.na(p) &amp; !is.na(x), 1, p ) # fix problems with +Inf
    return(p*(max-min)+min)
}

#== Generating data

# Constants
nobs &lt;- 1000
nspecies &lt;- 20
species &lt;- c(1:nspecies,sample(c(1:nspecies),(nobs-nspecies),replace=TRUE))

# Covariates
X1 &lt;- runif(n=nobs,min=-10,max=10)
X2 &lt;- runif(n=nobs,min=-10,max=10)
X &lt;- cbind(rep(1,nobs),X1,X2)
W &lt;- X

# Target parameters
# beta
beta.target &lt;- matrix(c(0.3,0.2,0.1),ncol=1)
# Vb
Vb.target &lt;- c(0.5,0.05,0.05)
# b
b.target &lt;- cbind(rnorm(nspecies,mean=0,sd=sqrt(Vb.target[1])),
                  rnorm(nspecies,mean=0,sd=sqrt(Vb.target[2])),
                  rnorm(nspecies,mean=0,sd=sqrt(Vb.target[3])))

# Response
theta &lt;- vector()
Y &lt;- vector()
for (n in 1:nobs) {
  theta[n] &lt;- inv.logit(X[n,]%*%beta.target+W[n,]%*%b.target[species[n],])
  Y[n] &lt;- rbinom(n=1,size=1,prob=theta[n])
}

# Data-set
Data &lt;- as.data.frame(cbind(Y,theta,X1,X2,species))
plot(Data$X1,Data$theta)

#== Call to MCMChlogit
model &lt;- MCMChlogit(fixed=Y~X1+X2, random=~X1+X2, group="species",
              data=Data, burnin=5000, mcmc=1000, thin=1,verbose=1,
              seed=NA, beta.start=0, sigma2.start=1,
              Vb.start=1, mubeta=0, Vbeta=1.0E6,
              r=3, R=diag(c(1,0.1,0.1)), nu=0.001, delta=0.001, FixOD=1)

#== MCMC analysis

# Graphics
pdf("Posteriors-MCMChlogit.pdf")
plot(model$mcmc)
dev.off()

# Summary
summary(model$mcmc)

# Predictive posterior mean for each observation
model$theta.pred

# Predicted-Observed
plot(Data$theta,model$theta.pred)
abline(a=0,b=1)

## #Not run
## #You can also compare with lme4 results
## #== lme4 resolution
## library(lme4)
## model.lme4 &lt;- lmer(Y~X1+X2+(1+X1+X2|species),data=Data,family="binomial")
## summary(model.lme4)
## plot(fitted(model.lme4),model$theta.pred,main="MCMChlogit/lme4")
## abline(a=0,b=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMChpoisson'>Markov Chain Monte Carlo for the Hierarchical Poisson Linear Regression
Model using the log link function</h2><span id='topic+MCMChpoisson'></span>

<h3>Description</h3>

<p>MCMChpoisson generates a sample from the posterior distribution of a
Hierarchical Poisson Linear Regression Model using the log link function and
Algorithm 2 of Chib and Carlin (1999). This model uses a multivariate Normal
prior for the fixed effects parameters, an Inverse-Wishart prior on the
random effects variance matrix, and an Inverse-Gamma prior on the variance
modelling over-dispersion. The user supplies data and priors, and a sample
from the posterior distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMChpoisson(
  fixed,
  random,
  group,
  data,
  burnin = 5000,
  mcmc = 10000,
  thin = 10,
  verbose = 1,
  seed = NA,
  beta.start = NA,
  sigma2.start = NA,
  Vb.start = NA,
  mubeta = 0,
  Vbeta = 1e+06,
  r,
  R,
  nu = 0.001,
  delta = 0.001,
  FixOD = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMChpoisson_+3A_fixed">fixed</code></td>
<td>
<p>A two-sided linear formula of the form 'y~x1+...+xp' describing
the fixed-effects part of the model, with the response on the left of a '~'
operator and the p fixed terms, separated by '+' operators, on the right.
Response variable y must be 0 or 1 (Binomial process).</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_random">random</code></td>
<td>
<p>A one-sided formula of the form '~x1+...+xq' specifying the
model for the random effects part of the model, with the q random terms,
separated by '+' operators.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_group">group</code></td>
<td>
<p>String indicating the name of the grouping variable in
<code>data</code>, defining the hierarchical structure of the model.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_burnin">burnin</code></td>
<td>
<p>The number of burnin iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler. Total number of
Gibbs iterations is equal to <code>burnin+mcmc</code>. <code>burnin+mcmc</code> must be
divisible by 10 and superior or equal to 100 so that the progress bar can be
displayed.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation. The number of mcmc
iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_verbose">verbose</code></td>
<td>
<p>A switch (0,1) which determines whether or not the progress
of the sampler is printed to the screen. Default is 1: a progress bar is
printed, indicating the step (in %) reached by the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator. If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector. This
can either be a scalar or a p-length vector. The default value of NA will
use the OLS <code class="reqn">\beta</code> estimate of the corresponding Gaussian Linear
Regression without random effects. If this is a scalar, that value will
serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_sigma2.start">sigma2.start</code></td>
<td>
<p>Scalar for the starting value of the residual error
variance. The default value of NA will use the OLS estimates of the
corresponding Gaussian Linear Regression without random effects.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_vb.start">Vb.start</code></td>
<td>
<p>The starting value for variance matrix of the random
effects. This must be a square q-dimension matrix. Default value of NA uses
an identity matrix.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_mubeta">mubeta</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>. This can either be a
scalar or a p-length vector. If this takes a scalar value, then that value
will serve as the prior mean for all of the betas. The default value of 0
will use a vector of zeros for an uninformative prior.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_vbeta">Vbeta</code></td>
<td>
<p>The prior variance of <code class="reqn">\beta</code>.  This can either be a
scalar or a square p-dimension matrix. If this takes a scalar value, then
that value times an identity matrix serves as the prior variance of beta.
Default value of 1.0E6 will use a diagonal matrix with very large variance
for an uninformative flat prior.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_r">r</code></td>
<td>
<p>The shape parameter for the Inverse-Wishart prior on variance
matrix for the random effects. r must be superior or equal to q. Set r=q for
an uninformative prior. See the NOTE for more details.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_r">R</code></td>
<td>
<p>The scale matrix for the Inverse-Wishart prior on variance matrix
for the random effects. This must be a square q-dimension matrix. Use
plausible variance regarding random effects for the diagonal of R. See the
NOTE for more details.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_nu">nu</code></td>
<td>
<p>The shape parameter for the Inverse-Gamma prior on the residual
error variance. Default value is <code>nu=delta=0.001</code> for uninformative
prior.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_delta">delta</code></td>
<td>
<p>The rate (1/scale) parameter for the Inverse-Gamma prior on the
residual error variance. Default value is <code>nu=delta=0.001</code> for
uninformative prior.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_fixod">FixOD</code></td>
<td>
<p>A switch (0,1) which determines whether or not the variance for
over-dispersion (sigma2) should be fixed (1) or not (0). Default is 0,
parameter sigma2 is estimated. If FixOD=1, sigma2 is fixed to the value
provided for <code>sigma2.start</code>.</p>
</td></tr>
<tr><td><code id="MCMChpoisson_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMChpoisson</code> simulates from the posterior distribution sample using
the blocked Gibbs sampler of Chib and Carlin (1999), Algorithm 2. The
simulation is done in compiled C++ code to maximize efficiency. Please
consult the coda documentation for a comprehensive list of functions that
can be used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim \mathcal{P}oisson(\lambda_i)</code>
</p>

<p>With latent variables <code class="reqn">\phi(\lambda_i)</code>, <code class="reqn">\phi</code> being the
log link function:
</p>
<p style="text-align: center;"><code class="reqn">\phi(\lambda_i) = X_i \beta + W_i b_i + \varepsilon_i</code>
</p>

<p>Where each group <code class="reqn">i</code> have <code class="reqn">k_i</code> observations.
</p>
<p>Where the random effects:
</p>
<p style="text-align: center;"><code class="reqn">b_i \sim \mathcal{N}_q(0,V_b)</code>
</p>

<p>And the over-dispersion terms:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_i \sim \mathcal{N}(0, \sigma^2 I_{k_i})</code>
</p>

<p>We assume standard, conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}_p(\mu_{\beta},V_{\beta})</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{2} \sim \mathcal{IG}amma(\nu, 1/\delta)</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">V_b \sim \mathcal{IW}ishart(r, rR)</code>
</p>
<p> See Chib and Carlin (1999) for more
details.
</p>
<p><em>NOTE:</em> We do not provide default parameters for the priors on the
precision matrix for the random effects. When fitting one of these models,
it is of utmost importance to choose a prior that reflects your prior
beliefs about the random effects. Using the <code>dwish</code> and <code>rwish</code>
functions might be useful in choosing these values.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mcmc</code></td>
<td>
<p>An mcmc object that contains the posterior sample. This
object can be summarized by functions provided by the coda
package. The posterior sample of the deviance <code class="reqn">D</code>, with
<code class="reqn">D=-2\log(\prod_i P(y_i|\lambda_i))</code>, is also provided.</p>
</td></tr>
<tr><td><code>lambda.pred</code></td>
<td>
<p>Predictive posterior mean for the exponential of
the latent variables. The approximation of Diggle et al. (2004) is
used to marginalized with respect to over-dispersion terms:
</p>
<p style="text-align: center;"><code class="reqn">E[\lambda_i|\beta,b_i,\sigma^2]=\phi^{-1}((X_i \beta+W_i b_i)+0.5 \sigma^2)</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ghislain Vieilledent &lt;ghislain.vieilledent@cirad.fr&gt;
</p>


<h3>References</h3>

<p>Siddhartha Chib and Bradley P. Carlin. 1999. &ldquo;On MCMC Sampling
in Hierarchical Longitudinal Models.&rdquo; <em>Statistics and Computing.</em> 9:
17-26.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Andrew D. Martin and Kyle L. Saunders. 2002. &ldquo;Bayesian Inference for
Political Science Panel Data.&rdquo; Paper presented at the 2002 Annual Meeting
of the American Political Science Association.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#========================================
# Hierarchical Poisson Linear Regression
#========================================

#== Generating data

# Constants
nobs &lt;- 1000
nspecies &lt;- 20
species &lt;- c(1:nspecies,sample(c(1:nspecies),(nobs-nspecies),replace=TRUE))

# Covariates
X1 &lt;- runif(n=nobs,min=-1,max=1)
X2 &lt;- runif(n=nobs,min=-1,max=1)
X &lt;- cbind(rep(1,nobs),X1,X2)
W &lt;- X

# Target parameters
# beta
beta.target &lt;- matrix(c(0.1,0.1,0.1),ncol=1)
# Vb
Vb.target &lt;- c(0.05,0.05,0.05)
# b
b.target &lt;- cbind(rnorm(nspecies,mean=0,sd=sqrt(Vb.target[1])),
                  rnorm(nspecies,mean=0,sd=sqrt(Vb.target[2])),
                  rnorm(nspecies,mean=0,sd=sqrt(Vb.target[3])))

# Response
lambda &lt;- vector()
Y &lt;- vector()
for (n in 1:nobs) {
  lambda[n] &lt;- exp(X[n,]%*%beta.target+W[n,]%*%b.target[species[n],])
  Y[n] &lt;- rpois(1,lambda[n])
}

# Data-set
Data &lt;- as.data.frame(cbind(Y,lambda,X1,X2,species))
plot(Data$X1,Data$lambda)

#== Call to MCMChpoisson
model &lt;- MCMChpoisson(fixed=Y~X1+X2, random=~X1+X2, group="species",
              data=Data, burnin=5000, mcmc=1000, thin=1,verbose=1,
              seed=NA, beta.start=0, sigma2.start=1,
              Vb.start=1, mubeta=0, Vbeta=1.0E6,
              r=3, R=diag(c(0.1,0.1,0.1)), nu=0.001, delta=0.001, FixOD=1)

#== MCMC analysis

# Graphics
pdf("Posteriors-MCMChpoisson.pdf")
plot(model$mcmc)
dev.off()

# Summary
summary(model$mcmc)

# Predictive posterior mean for each observation
model$lambda.pred

# Predicted-Observed
plot(Data$lambda,model$lambda.pred)
abline(a=0,b=1)

## #Not run
## #You can also compare with lme4 results
## #== lme4 resolution
## library(lme4)
## model.lme4 &lt;- lmer(Y~X1+X2+(1+X1+X2|species),data=Data,family="poisson")
## summary(model.lme4)
## plot(fitted(model.lme4),model$lambda.pred,main="MCMChpoisson/lme4")
## abline(a=0,b=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMChregress'>Markov Chain Monte Carlo for the Hierarchical Gaussian Linear Regression
Model</h2><span id='topic+MCMChregress'></span>

<h3>Description</h3>

<p>MCMChregress generates a sample from the posterior distribution of a
Hierarchical Gaussian Linear Regression Model using Algorithm 2 of Chib and
Carlin (1999). This model uses a multivariate Normal prior for the fixed
effects parameters, an Inverse-Wishart prior on the random effects variance
matrix, and an Inverse-Gamma prior on the residual error variance. The user
supplies data and priors, and a sample from the posterior distribution is
returned as an mcmc object, which can be subsequently analyzed with
functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMChregress(
  fixed,
  random,
  group,
  data,
  burnin = 1000,
  mcmc = 10000,
  thin = 10,
  verbose = 1,
  seed = NA,
  beta.start = NA,
  sigma2.start = NA,
  Vb.start = NA,
  mubeta = 0,
  Vbeta = 1e+06,
  r,
  R,
  nu = 0.001,
  delta = 0.001,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMChregress_+3A_fixed">fixed</code></td>
<td>
<p>A two-sided linear formula of the form 'y~x1+...+xp' describing
the fixed-effects part of the model, with the response on the left of a '~'
operator and the p fixed terms, separated by '+' operators, on the right.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_random">random</code></td>
<td>
<p>A one-sided formula of the form '~x1+...+xq' specifying the
model for the random effects part of the model, with the q random terms,
separated by '+' operators.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_group">group</code></td>
<td>
<p>String indicating the name of the grouping variable in
<code>data</code>, defining the hierarchical structure of the model.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_burnin">burnin</code></td>
<td>
<p>The number of burnin iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler. Total number of
Gibbs iterations is equal to <code>burnin+mcmc</code>. <code>burnin+mcmc</code> must be
divisible by 10 and superior or equal to 100 so that the progress bar can be
displayed.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation. The number of mcmc
iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_verbose">verbose</code></td>
<td>
<p>A switch (0,1) which determines whether or not the progress
of the sampler is printed to the screen. Default is 1: a progress bar is
printed, indicating the step (in %) reached by the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator. If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector. This
can either be a scalar or a p-length vector. The default value of NA will
use the OLS <code class="reqn">\beta</code> estimate of the corresponding Gaussian Linear
Regression without random effects. If this is a scalar, that value will
serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_sigma2.start">sigma2.start</code></td>
<td>
<p>Scalar for the starting value of the residual error
variance. The default value of NA will use the OLS estimates of the
corresponding Gaussian Linear Regression without random effects.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_vb.start">Vb.start</code></td>
<td>
<p>The starting value for variance matrix of the random
effects. This must be a square q-dimension matrix. Default value of NA uses
an identity matrix.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_mubeta">mubeta</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>. This can either be a
scalar or a p-length vector. If this takes a scalar value, then that value
will serve as the prior mean for all of the betas. The default value of 0
will use a vector of zeros for an uninformative prior.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_vbeta">Vbeta</code></td>
<td>
<p>The prior variance of <code class="reqn">\beta</code>.  This can either be a
scalar or a square p-dimension matrix. If this takes a scalar value, then
that value times an identity matrix serves as the prior variance of beta.
Default value of 1.0E6 will use a diagonal matrix with very large variance
for an uninformative flat prior.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_r">r</code></td>
<td>
<p>The shape parameter for the Inverse-Wishart prior on variance
matrix for the random effects. r must be superior or equal to q. Set r=q for
an uninformative prior. See the NOTE for more details</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_r">R</code></td>
<td>
<p>The scale matrix for the Inverse-Wishart prior on variance matrix
for the random effects. This must be a square q-dimension matrix. Use
plausible variance regarding random effects for the diagonal of R. See the
NOTE for more details</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_nu">nu</code></td>
<td>
<p>The shape parameter for the Inverse-Gamma prior on the residual
error variance. Default value is <code>nu=delta=0.001</code> for uninformative
prior.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_delta">delta</code></td>
<td>
<p>The rate (1/scale) parameter for the Inverse-Gamma prior on the
residual error variance. Default value is <code>nu=delta=0.001</code> for
uninformative prior.</p>
</td></tr>
<tr><td><code id="MCMChregress_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMChregress</code> simulates from the posterior distribution sample using
the blocked Gibbs sampler of Chib and Carlin (1999), Algorithm 2. The
simulation is done in compiled C++ code to maximize efficiency. Please
consult the coda documentation for a comprehensive list of functions that
can be used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i = X_i \beta + W_i b_i + \varepsilon_i</code>
</p>

<p>Where each group <code class="reqn">i</code> have <code class="reqn">k_i</code> observations.
</p>
<p>Where the random effects:
</p>
<p style="text-align: center;"><code class="reqn">b_i \sim \mathcal{N}_q(0,V_b)</code>
</p>

<p>And the errors:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_i \sim \mathcal{N}(0, \sigma^2 I_{k_i})</code>
</p>

<p>We assume standard, conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}_p(\mu_{\beta},V_{\beta})</code>
</p>

<p>And: </p>
<p style="text-align: center;"><code class="reqn">\sigma^{2} \sim \mathcal{IG}amma(\nu, 1/\delta)</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">V_b \sim \mathcal{IW}ishart(r, rR)</code>
</p>
<p> See Chib and Carlin
(1999) for more details.
</p>
<p><em>NOTE:</em> We do not provide default parameters for the priors on the
precision matrix for the random effects. When fitting one of these models,
it is of utmost importance to choose a prior that reflects your prior
beliefs about the random effects. Using the <code>dwish</code> and <code>rwish</code>
functions might be useful in choosing these values.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mcmc</code></td>
<td>
<p>An mcmc object that contains the posterior sample. This
object can be summarized by functions provided by the coda
package. The posterior sample of the deviance <code class="reqn">D</code>, with
<code class="reqn">D=-2\log(\prod_i P(y_i|\beta,b_i,\sigma^2))</code>, is also
provided.</p>
</td></tr>
<tr><td><code>Y.pred</code></td>
<td>
<p>Predictive posterior mean for each observation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ghislain Vieilledent &lt;ghislain.vieilledent@cirad.fr&gt;
</p>


<h3>References</h3>

<p>Siddhartha Chib and Bradley P. Carlin. 1999. &ldquo;On MCMC Sampling
in Hierarchical Longitudinal Models.&rdquo; <em>Statistics and Computing.</em> 9:
17-26.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Andrew D. Martin and Kyle L. Saunders. 2002. &ldquo;Bayesian Inference for
Political Science Panel Data.&rdquo; Paper presented at the 2002 Annual Meeting
of the American Political Science Association.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#========================================
# Hierarchical Gaussian Linear Regression
#========================================

#== Generating data

# Constants
nobs &lt;- 1000
nspecies &lt;- 20
species &lt;- c(1:nspecies,sample(c(1:nspecies),(nobs-nspecies),replace=TRUE))

# Covariates
X1 &lt;- runif(n=nobs,min=0,max=10)
X2 &lt;- runif(n=nobs,min=0,max=10)
X &lt;- cbind(rep(1,nobs),X1,X2)
W &lt;- X

# Target parameters
# beta
beta.target &lt;- matrix(c(0.1,0.3,0.2),ncol=1)
# Vb
Vb.target &lt;- c(0.5,0.2,0.1)
# b
b.target &lt;- cbind(rnorm(nspecies,mean=0,sd=sqrt(Vb.target[1])),
                  rnorm(nspecies,mean=0,sd=sqrt(Vb.target[2])),
                  rnorm(nspecies,mean=0,sd=sqrt(Vb.target[3])))
# sigma2
sigma2.target &lt;- 0.02

# Response
Y &lt;- vector()
for (n in 1:nobs) {
  Y[n] &lt;- rnorm(n=1,
                mean=X[n,]%*%beta.target+W[n,]%*%b.target[species[n],],
                sd=sqrt(sigma2.target))
}

# Data-set
Data &lt;- as.data.frame(cbind(Y,X1,X2,species))
plot(Data$X1,Data$Y)

#== Call to MCMChregress
model &lt;- MCMChregress(fixed=Y~X1+X2, random=~X1+X2, group="species",
              data=Data, burnin=1000, mcmc=1000, thin=1,verbose=1,
              seed=NA, beta.start=0, sigma2.start=1,
              Vb.start=1, mubeta=0, Vbeta=1.0E6,
              r=3, R=diag(c(1,0.1,0.1)), nu=0.001, delta=0.001)

#== MCMC analysis

# Graphics
pdf("Posteriors-MCMChregress.pdf")
plot(model$mcmc)
dev.off()

# Summary
summary(model$mcmc)

# Predictive posterior mean for each observation
model$Y.pred

# Predicted-Observed
plot(Data$Y,model$Y.pred)
abline(a=0,b=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCirt1d'>Markov Chain Monte Carlo for One Dimensional Item Response Theory Model</h2><span id='topic+MCMCirt1d'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a one
dimensional item response theory (IRT) model, with Normal priors on the
subject abilities (ideal points), and multivariate Normal priors on the item
parameters.  The user supplies data and priors, and a sample from the
posterior distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCirt1d(
  datamatrix,
  theta.constraints = list(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  theta.start = NA,
  alpha.start = NA,
  beta.start = NA,
  t0 = 0,
  T0 = 1,
  ab0 = 0,
  AB0 = 0.25,
  store.item = FALSE,
  store.ability = TRUE,
  drop.constant.items = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCirt1d_+3A_datamatrix">datamatrix</code></td>
<td>
<p>The matrix of data.  Must be 0, 1, or missing values.  The
rows of <code>datamatrix</code> correspond to subjects and the columns correspond
to items.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_theta.constraints">theta.constraints</code></td>
<td>
<p>A list specifying possible simple equality or
inequality constraints on the ability parameters. A typical entry in the
list has one of three forms: <code>varname=c</code> which will constrain the
ability parameter for the subject named <code>varname</code> to be equal to c,
<code>varname="+"</code> which will constrain the ability parameter for the
subject named <code>varname</code> to be positive, and <code>varname="-"</code> which
will constrain the ability parameter for the subject named <code>varname</code> to
be negative. If x is a matrix without row names defaults names of
&ldquo;V1&quot;,&ldquo;V2&quot;, ... , etc will be used. See Rivers (2003) for a thorough
discussion of identification of IRT models.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 then
every <code>verbose</code>th iteration will be printed to the screen.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_theta.start">theta.start</code></td>
<td>
<p>The starting values for the subject abilities (ideal
points). This can either be a scalar or a column vector with dimension equal
to the number of voters.  If this takes a scalar value, then that value will
serve as the starting value for all of the thetas.  The default value of NA
will choose the starting values based on an eigenvalue-eigenvector
decomposition of the aggreement score matrix formed from the
<code>datamatrix</code>.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_alpha.start">alpha.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\alpha</code>
difficulty parameters. This can either be a scalar or a column vector with
dimension equal to the number of items.  If this takes a scalar value, then
that value will serve as the starting value for all of the alphas.  The
default value of NA will set the starting values based on a series of probit
regressions that condition on the starting values of theta.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code>
discrimination parameters. This can either be a scalar or a column vector
with dimension equal to the number of items.  If this takes a scalar value,
then that value will serve as the starting value for all of the betas.  The
default value of NA will set the starting values based on a series of probit
regressions that condition on the starting values of theta.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_t0">t0</code></td>
<td>
<p>A scalar parameter giving the prior mean of the subject abilities
(ideal points).</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_t0">T0</code></td>
<td>
<p>A scalar parameter giving the prior precision (inverse variance)
of the subject abilities (ideal points).</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_ab0">ab0</code></td>
<td>
<p>The prior mean of <code>(alpha, beta)</code>. Can be either a scalar or
a 2-vector. If a scalar both means will be set to the passed value. The
prior mean is assumed to be the same across all items.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_ab0">AB0</code></td>
<td>
<p>The prior precision of <code>(alpha, beta)</code>.This can either be
ascalar or a 2 by 2 matrix. If this takes a scalar value, then that value
times an identity matrix serves as the prior precision. The prior precision
is assumed to be the same across all items.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_store.item">store.item</code></td>
<td>
<p>A switch that determines whether or not to store the item
parameters for posterior analysis.  <em>NOTE: In situations with many
items storing the item parameters takes an enormous amount of memory, so
<code>store.item</code> should only be <code>FALSE</code> if the chain is thinned
heavily, or for applications with a small number of items</em>.  By default, the
item parameters are not stored.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_store.ability">store.ability</code></td>
<td>
<p>A switch that determines whether or not to store the
ability parameters for posterior analysis.  <em>NOTE: In situations with
many individuals storing the ability parameters takes an enormous amount of
memory, so <code>store.ability</code> should only be <code>TRUE</code> if the chain is
thinned heavily, or for applications with a small number of individuals</em>.
By default, the item parameters are stored.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_drop.constant.items">drop.constant.items</code></td>
<td>
<p>A switch that determines whether or not items
that have no variation should be deleted before fitting the model. Default =
TRUE.</p>
</td></tr>
<tr><td><code id="MCMCirt1d_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are interested in fitting K-dimensional item response theory models,
or would rather identify the model by placing constraints on the item
parameters, please see <code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>.
</p>
<p><code>MCMCirt1d</code> simulates from the posterior distribution using standard
Gibbs sampling using data augmentation (a Normal draw for the subject
abilities, a multivariate Normal draw for the item parameters, and a
truncated Normal draw for the latent utilities). The simulation proper is
done in compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The model takes the following form.  We assume that each subject has an
subject ability (ideal point) denoted <code class="reqn">\theta_j</code> and that each
item has a difficulty parameter <code class="reqn">\alpha_i</code> and discrimination
parameter <code class="reqn">\beta_i</code>.  The observed choice by subject <code class="reqn">j</code>
on item <code class="reqn">i</code> is the observed data matrix which is <code class="reqn">(I \times
J)</code>.  We assume that the choice is dictated by an unobserved
utility:
</p>
<p style="text-align: center;"><code class="reqn">z_{i,j} = -\alpha_i + \beta_i \theta_j + \varepsilon_{i,j}</code>
</p>

<p>Where the errors are assumed to be distributed standard Normal.
The parameters of interest are the subject abilities (ideal points)
and the item parameters.
</p>
<p>We assume the following priors.  For the subject abilities (ideal points):
</p>
<p style="text-align: center;"><code class="reqn">\theta_j \sim \mathcal{N}(t_{0},T_{0}^{-1})</code>
</p>

<p>For the item parameters, the prior is:
</p>
<p style="text-align: center;"><code class="reqn">\left[\alpha_i, \beta_i \right]' \sim \mathcal{N}_2 (ab_{0},AB_{0}^{-1})</code>
</p>

<p>The model is identified by the proper priors on the item parameters and
constraints placed on the ability parameters.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the item parameters.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the sample from the posterior
distribution. This object can be summarized by functions provided by the
coda package.
</p>


<h3>References</h3>

<p>James H. Albert. 1992. &ldquo;Bayesian Estimation of Normal Ogive
Item Response Curves Using Gibbs Sampling.&quot; <em>Journal of Educational
Statistics</em>.  17: 251-269.
</p>
<p>Joshua Clinton, Simon Jackman, and Douglas Rivers. 2004. &ldquo;The Statistical
Analysis of Roll Call Data.&quot;  <em>American Political Science Review</em>.  98:
355-370.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. &ldquo;Ordinal Data Modeling.&quot;
Springer: New York.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Douglas Rivers.  2004.  &ldquo;Identification of Multidimensional Item-Response
Models.&quot;  Stanford University, typescript.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   ## US Supreme Court Example with inequality constraints
   data(SupremeCourt)
   posterior1 &lt;- MCMCirt1d(t(SupremeCourt),
                   theta.constraints=list(Scalia="+", Ginsburg="-"),
                   B0.alpha=.2, B0.beta=.2,
                   burnin=500, mcmc=100000, thin=20, verbose=500,
                   store.item=TRUE)
   geweke.diag(posterior1)
   plot(posterior1)
   summary(posterior1)

   ## US Senate Example with equality constraints
   data(Senate)
   Sen.rollcalls &lt;- Senate[,6:677]
   posterior2 &lt;- MCMCirt1d(Sen.rollcalls,
                    theta.constraints=list(KENNEDY=-2, HELMS=2),
                    burnin=2000, mcmc=100000, thin=20, verbose=500)
   geweke.diag(posterior2)
   plot(posterior2)
   summary(posterior2)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCirtHier1d'>Markov Chain Monte Carlo for Hierarchical One Dimensional Item Response
Theory Model, Covariates Predicting Latent Ideal Point (Ability)</h2><span id='topic+MCMCirtHier1d'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a one
dimensional item response theory (IRT) model, with multivariate Normal
priors on the item parameters, and a Normal-Inverse Gamma hierarchical prior
on subject ideal points (abilities).  The user supplies item-response data,
subject covariates, and priors. Note that this identification strategy
obviates the constraints used on theta in <code><a href="#topic+MCMCirt1d">MCMCirt1d</a></code>.
A sample from the posterior distribution is returned as an mcmc object,
which can be subsequently analyzed with functions provided in the coda
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCirtHier1d(
  datamatrix,
  Xjdata,
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  theta.start = NA,
  a.start = NA,
  b.start = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0.01,
  c0 = 0.001,
  d0 = 0.001,
  ab0 = 0,
  AB0 = 0.25,
  store.item = FALSE,
  store.ability = TRUE,
  drop.constant.items = TRUE,
  marginal.likelihood = c("none", "Chib95"),
  px = TRUE,
  px_a0 = 10,
  px_b0 = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCirtHier1d_+3A_datamatrix">datamatrix</code></td>
<td>
<p>The matrix of data.  Must be 0, 1, or missing values.  The
rows of <code>datamatrix</code> correspond to subjects and the columns correspond
to items.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_xjdata">Xjdata</code></td>
<td>
<p>A <code>data.frame</code> containing second-level predictor
covariates for ideal points <code class="reqn">\theta</code>. Predictors are modeled as a
linear regression on the mean vector of <code class="reqn">\theta</code>; the posterior
sample contains regression coefficients <code class="reqn">\beta</code> and common
variance <code class="reqn">\sigma^2</code>. See Rivers (2003) for a thorough
discussion of identification of IRT models.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen. If <code>verbose</code> is greater than 0 then
every <code>verbose</code>th iteration will be printed to the screen.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_theta.start">theta.start</code></td>
<td>
<p>The starting values for the subject abilities (ideal
points). This can either be a scalar or a column vector with dimension equal
to the number of voters.  If this takes a scalar value, then that value will
serve as the starting value for all of the thetas.  The default value of NA
will choose the starting values based on an eigenvalue-eigenvector
decomposition of the agreement score matrix formed from the
<code>datamatrix</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_a.start">a.start</code></td>
<td>
<p>The starting values for the <code class="reqn">a</code> difficulty parameters.
This can either be a scalar or a column vector with dimension equal to the
number of items.  If this takes a scalar value, then that value will serve
as the starting value for all <code class="reqn">a</code>.  The default value of NA will set
the starting values based on a series of probit regressions that condition
on the starting values of theta.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_b.start">b.start</code></td>
<td>
<p>The starting values for the <code class="reqn">b</code> discrimination
parameters. This can either be a scalar or a column vector with dimension
equal to the number of items.  If this takes a scalar value, then that value
will serve as the starting value for all <code class="reqn">b</code>.  The default value of
NA will set the starting values based on a series of probit regressions that
condition on the starting values of theta.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> regression
coefficients that predict the means of ideal points <code class="reqn">\theta</code>.
This can either be a scalar or a column vector with length equal to the
number of covariates. If this takes a scalar value, then that value will
serve as the starting value for all of the betas.  The default value of NA
will set the starting values based on a linear regression of the covariates
on (either provided or generated) <code>theta.start</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>. Can be either a scalar or a
vector of length equal to the number of subject covariates. If a scalar all
means with be set to the passed value.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. A default proper but diffuse value of .01
ensures finite marginal likelihood for model comparison.  A value of 0 is
equivalent to an improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of <code class="reqn">\theta</code>). The
amount of information in the inverse Gamma prior is something
like that from <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of <code class="reqn">\theta</code>). In
constructing the inverse Gamma prior, <code class="reqn">d_0</code> acts like the sum of
squared errors from the <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_ab0">ab0</code></td>
<td>
<p>The prior mean of <code>(a, b)</code>. Can be either a scalar or a
2-vector. If a scalar both means will be set to the passed value. The prior
mean is assumed to be the same across all items.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_ab0">AB0</code></td>
<td>
<p>The prior precision of <code>(a, b)</code>.This can either be ascalar
or a 2 by 2 matrix. If this takes a scalar value, then that value times an
identity matrix serves as the prior precision. The prior precision is
assumed to be the same across all items.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_store.item">store.item</code></td>
<td>
<p>A switch that determines whether or not to store the item
parameters for posterior analysis.  <em>NOTE: In situations with many
items storing the item parameters takes an enormous amount of memory, so
<code>store.item</code> should only be <code>TRUE</code> if the chain is thinned
heavily, or for applications with a small number of items</em>.  By default, the
item parameters are not stored.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_store.ability">store.ability</code></td>
<td>
<p>A switch that determines whether or not to store the
ability parameters for posterior analysis.  <em>NOTE: In situations with
many individuals storing the ability parameters takes an enormous amount of
memory, so <code>store.ability</code> should only be <code>TRUE</code> if the chain is
thinned heavily, or for applications with a small number of individuals</em>.
By default, ability parameters are stored.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_drop.constant.items">drop.constant.items</code></td>
<td>
<p>A switch that determines whether or not items
that have no variation should be deleted before fitting the model. Default =
TRUE.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>Should the marginal likelihood of the
second-level model on ideal points be calculated using the method of Chib
(1995)? It is stored as an attribute of the posterior <code>mcmc</code> object and
suitable for comparison using <code><a href="#topic+BayesFactor">BayesFactor</a></code>.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_px">px</code></td>
<td>
<p>Use Parameter Expansion to reduce autocorrelation in the chain?
PX introduces an unidentified parameter <code class="reqn">alpha</code> for the residual
variance in the latent data (Liu and Wu 1999). Default = TRUE</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_px_a0">px_a0</code></td>
<td>
<p>Prior shape parameter for the inverse-gamma distribution on
<code class="reqn">alpha</code>, the residual variance of the latent data. Default=10.</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_px_b0">px_b0</code></td>
<td>
<p>Prior scale parameter for the inverse-gamma distribution on
<code class="reqn">alpha</code>, the residual variance of the latent data. Default = 10</p>
</td></tr>
<tr><td><code id="MCMCirtHier1d_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are interested in fitting K-dimensional item response theory models,
or would rather identify the model by placing constraints on the item
parameters, please see <code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>.
</p>
<p><code>MCMCirtHier1d</code> simulates from the posterior distribution using
standard Gibbs sampling using data augmentation (a Normal draw for the
subject abilities, a multivariate Normal draw for (second-level) subject
ability predictors, an Inverse-Gamma draw for the (second-level) variance of
subject abilities, a multivariate Normal draw for the item parameters, and a
truncated Normal draw for the latent utilities). The simulation proper is
done in compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The model takes the following form.  We assume that each subject has an
subject ability (ideal point) denoted <code class="reqn">\theta_j</code> and that each
item has a difficulty parameter <code class="reqn">a_i</code> and discrimination parameter
<code class="reqn">b_i</code>.  The observed choice by subject <code class="reqn">j</code> on item
<code class="reqn">i</code> is the observed data matrix which is <code class="reqn">(I \times J)</code>.
We assume that the choice is dictated by an unobserved utility:
</p>
<p style="text-align: center;"><code class="reqn">z_{i,j} = -\alpha_i + \beta_i \theta_j + \varepsilon_{i,j}</code>
</p>

<p>Where the errors are assumed to be distributed standard Normal.
This constitutes the measurement or level-1 model. The subject abilities
(ideal points) are modeled by a second level Normal linear predictor for
subject covariates <code>Xjdata</code>, with common variance
<code class="reqn">\sigma^2</code>. The parameters of interest are the subject
abilities (ideal points), item parameters, and second-level coefficients.
</p>
<p>We assume the following priors.  For the subject abilities (ideal points):
</p>
<p style="text-align: center;"><code class="reqn">\theta_j \sim \mathcal{N}(\mu_{\theta} ,T_{0}^{-1})</code>
</p>

<p>For the item parameters, the prior is:
</p>
<p style="text-align: center;"><code class="reqn">\left[a_i, b_i \right]' \sim \mathcal{N}_2 (ab_{0},AB_{0}^{-1})</code>
</p>

<p>The model is identified by the proper priors on the item parameters and
constraints placed on the ability parameters.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the item parameters.
</p>


<h3>Value</h3>

<p>An <code>mcmc</code> object that contains the sample from the posterior
distribution. This object can be summarized by functions provided by the
coda package. If <code>marginal.likelihood = "Chib95"</code> the object will have
attribute <code>logmarglike</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Malecki, <a href="mailto:mike@crunch.io">mike@crunch.io</a>,
<a href="https://github.com/malecki">https://github.com/malecki</a>.
</p>


<h3>References</h3>

<p>James H. Albert. 1992. &ldquo;Bayesian Estimation of Normal Ogive
Item Response Curves Using Gibbs Sampling.&quot; <em>Journal of Educational
Statistics</em>.  17: 251&ndash;269.
</p>
<p>Joshua Clinton, Simon Jackman, and Douglas Rivers. 2004. &ldquo;The Statistical
Analysis of Roll Call Data.&quot;  <em>American Political Science Review</em> 98:
355&ndash;370.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. &ldquo;Ordinal Data Modeling.&quot;
Springer: New York.
</p>
<p>Liu, Jun S. and Ying Nian Wu. 1999. &ldquo;Parameter Expansion for Data
Augmentation.&rdquo; <em>Journal of the American Statistical Association</em> 94:
1264&ndash;1274.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Douglas Rivers.  2004.  &ldquo;Identification of Multidimensional Item-Response
Models.&quot;  Stanford University, typescript.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
data(SupremeCourt)

Xjdata &lt;- data.frame(presparty= c(1,1,0,1,1,1,1,0,0),
                     sex= c(0,0,1,0,0,0,0,1,0))

## Parameter Expansion reduces autocorrelation.
  posterior1 &lt;- MCMCirtHier1d(t(SupremeCourt),
                   burnin=50000, mcmc=10000, thin=20,
                   verbose=10000,
                   Xjdata=Xjdata,
                   marginal.likelihood="Chib95",
		   px=TRUE)

## But, you can always turn it off.
  posterior2 &lt;- MCMCirtHier1d(t(SupremeCourt),
                   burnin=50000, mcmc=10000, thin=20,
                   verbose=10000,
                   Xjdata=Xjdata,
                   #marginal.likelihood="Chib95",
		   px=FALSE)
## Note that the hierarchical model has greater autocorrelation than
## the naive IRT model.
  posterior0 &lt;- MCMCirt1d(t(SupremeCourt),
                        theta.constraints=list(Scalia="+", Ginsburg="-"),
                        B0.alpha=.2, B0.beta=.2,
                        burnin=50000, mcmc=100000, thin=100, verbose=10000,
                        store.item=FALSE)

## Randomly 10% Missing -- this affects the expansion parameter, increasing
## the variance of the (unidentified) latent parameter alpha.

   scMiss &lt;- SupremeCourt
   scMiss[matrix(as.logical(rbinom(nrow(SupremeCourt)*ncol(SupremeCourt), 1, .1)),
      dim(SupremeCourt))] &lt;- NA

   posterior1.miss &lt;- MCMCirtHier1d(t(scMiss),
                   burnin=80000, mcmc=10000, thin=20,
                   verbose=10000,
                   Xjdata=Xjdata,
                   marginal.likelihood="Chib95",
		   px=TRUE)

   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCirtKd'>Markov Chain Monte Carlo for K-Dimensional Item Response Theory Model</h2><span id='topic+MCMCirtKd'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
K-dimensional item response theory (IRT) model, with standard normal priors
on the subject abilities (ideal points), and normal priors on the item
parameters.  The user supplies data and priors, and a sample from the
posterior distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCirtKd(
  datamatrix,
  dimensions,
  item.constraints = list(),
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  alphabeta.start = NA,
  b0 = 0,
  B0 = 0,
  store.item = FALSE,
  store.ability = TRUE,
  drop.constant.items = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCirtKd_+3A_datamatrix">datamatrix</code></td>
<td>
<p>The matrix of data.  Must be 0, 1, or missing values.  It
is of dimensionality subjects by items.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_dimensions">dimensions</code></td>
<td>
<p>The number of dimensions in the latent space.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_item.constraints">item.constraints</code></td>
<td>
<p>List of lists specifying possible equality
or simple inequality constraints on the item parameters. A
typical entry in the list has one of three forms:
<code>rowname=list(d,c)</code> which will constrain the dth item
parameter for the item named rowname to be equal to c,
<code>rowname=list(d,"+")</code> which will constrain the dth item
parameter for the item named rowname to be positive,
and<code>rowname=list(d, "-")</code> which will constrain the dth item
parameter for the item named rowname to be negative. If x is a
matrix without row names defaults names of &ldquo;V1&quot;, &ldquo;V2&quot;, ... ,
etc will be used. In a K dimensional model, the first item
parameter for item <code class="reqn">i</code> is the difficulty parameter
(<code class="reqn">\alpha_i</code>), the second item parameter is the discrimation
parameter on dimension 1 (<code class="reqn">\beta_{i,1}</code>), the third item
parameter is the discrimation parameter on dimension 2
(<code class="reqn">\beta_{i,2}</code>), ..., and the (K+1)th item parameter is the
discrimation parameter on dimension K (<code class="reqn">\beta_{i,1}</code>).  The
item difficulty parameters (<code class="reqn">\alpha</code>) should generally not be
constrained.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 then
every <code>verbose</code>th iteration will be printed to the screen.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_alphabeta.start">alphabeta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code> difficulty and discrimination parameters. If
<code>alphabeta.start</code> is set to a scalar the starting value for all
unconstrained item parameters will be set to that scalar. If
<code>alphabeta.start</code> is a matrix of dimension <code class="reqn">(K+1) \times
items</code> then the <code>alphabeta.start</code> matrix is used as the
starting values (except for equality-constrained elements). If
<code>alphabeta.start</code> is set to <code>NA</code> (the default) then starting
values for unconstrained elements are set to values generated from a series
of proportional odds logistic regression fits, and starting values for
inequality constrained elements are set to either 1.0 or -1.0 depending on
the nature of the constraints.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_b0">b0</code></td>
<td>
<p>The prior means of the <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
difficulty and discrimination parameters, stacked for all items.  If a
scalar is passed, it is used as the prior mean for all items.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_b0">B0</code></td>
<td>
<p>The prior precisions (inverse variances) of the independent normal
prior on the item parameters.  Can be either a scalar or a matrix of
dimension <code class="reqn">(K+1) \times items</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_store.item">store.item</code></td>
<td>
<p>A switch that determines whether or not to store the item
parameters for posterior analysis.  <em>NOTE: In applications with many
items this takes an enormous amount of memory. If you have many items and
want to want to store the item parameters you may want to thin the chain
heavily</em>.  By default, the item parameters are not stored.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_store.ability">store.ability</code></td>
<td>
<p>A switch that determines whether or not to store the
subject abilities for posterior analysis. <em>NOTE: In applications with
many subjects this takes an enormous amount of memory. If you have many
subjects and want to want to store the ability parameters you may want to
thin the chain heavily</em>. By default, the ability parameters are all stored.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_drop.constant.items">drop.constant.items</code></td>
<td>
<p>A switch that determines whether or not items
that have no variation should be deleted before fitting the model. Default =
TRUE.</p>
</td></tr>
<tr><td><code id="MCMCirtKd_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCirtKd</code> simulates from the posterior distribution using standard
Gibbs sampling using data augmentation (a normal draw for the subject
abilities, a multivariate normal draw for the item parameters, and a
truncated normal draw for the latent utilities). The simulation proper is
done in compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The default number of burnin and mcmc iterations is much smaller than the
typical default values in MCMCpack.  This is because fitting this model is
extremely computationally expensive.  It does not mean that this small of a
number of scans will yield good estimates.  The priors of this model need to
be proper for identification purposes.  The user is asked to provide prior
means and precisions <em>(not variances)</em> for the item parameters and the
subject parameters.
</p>
<p>The model takes the following form.  We assume that each subject
has an ability (ideal point) denoted <code class="reqn">\theta_j</code> <code class="reqn">(K \times
1)</code>, and that each item has a difficulty parameter <code class="reqn">\alpha_i</code>
and discrimination parameter <code class="reqn">\beta_i</code> <code class="reqn">(K \times 1)</code>.  The
observed choice by subject <code class="reqn">j</code> on item <code class="reqn">i</code> is the observed
data matrix which is <code class="reqn">(I \times J)</code>.  We assume that the choice
is dictated by an unobserved utility:
</p>
<p style="text-align: center;"><code class="reqn">z_{i,j} = - \alpha_i + \beta_i'\theta_j + \varepsilon_{i,j}</code>
</p>

<p>Where the <code class="reqn">\varepsilon_{i,j}</code>s are assumed to be distributed
standard normal.  The parameters of interest are the subject
abilities (ideal points) and the item parameters.
</p>
<p>We assume the following priors.  For the subject abilities (ideal points) we
assume independent standard normal priors:
</p>
<p style="text-align: center;"><code class="reqn">\theta_{j,k} \sim \mathcal{N}(0,1)</code>
</p>

<p>These cannot be changed by the user.
For each item parameter, we assume independent normal priors:
</p>
<p style="text-align: center;"><code class="reqn">\left[\alpha_i, \beta_i \right]' \sim \mathcal{N}_{(K+1)} (b_{0,i},B_{0,i})</code>
</p>

<p>Where <code class="reqn">B_{0,i}</code> is a diagonal matrix.  One can specify a
separate prior mean and precision for each item parameter.
</p>
<p>The model is identified by the constraints on the item parameters (see
Jackman 2001).  The user cannot place constraints on the subject abilities.
This identification scheme differs from that in <code>MCMCirt1d</code>, which uses
constraints on the subject abilities to identify the model.  In our
experience, using subject ability constraints for models in greater than one
dimension does not work particularly well.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the item parameters.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>James H. Albert. 1992. &ldquo;Bayesian Estimation of Normal Ogive
Item Response Curves Using Gibbs Sampling.&quot; <em>Journal of Educational
Statistics</em>.  17: 251-269.
</p>
<p>Joshua Clinton, Simon Jackman, and Douglas Rivers. 2004. &ldquo;The Statistical
Analysis of Roll Call Data.&quot;  <em>American Political Science Review</em>.  98:
355-370.
</p>
<p>Simon Jackman. 2001. &ldquo;Multidimensional Analysis of Roll Call Data via
Bayesian Simulation.&rdquo; <em>Political Analysis.</em> 9: 227-241.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. <em>Ordinal Data Modeling</em>.
Springer: New York.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Douglas Rivers.  2004.  &ldquo;Identification of Multidimensional Item-Response
Models.&quot;  Stanford University, typescript.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCirt1d">MCMCirt1d</a></code>, <code><a href="#topic+MCMCordfactanal">MCMCordfactanal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   data(SupremeCourt)
   # note that the rownames (the item names) are "1", "2", etc
   posterior1 &lt;- MCMCirtKd(t(SupremeCourt), dimensions=1,
                   burnin=5000, mcmc=50000, thin=10,
                   B0=.25, store.item=TRUE,
                   item.constraints=list("1"=list(2,"-")))
   plot(posterior1)
   summary(posterior1)


   data(Senate)
   Sen.rollcalls &lt;- Senate[,6:677]
   posterior2 &lt;- MCMCirtKd(Sen.rollcalls, dimensions=2,
                   burnin=5000, mcmc=50000, thin=10,
                   item.constraints=list(rc2=list(2,"-"), rc2=c(3,0),
                                         rc3=list(3,"-")),
                   B0=.25)
   plot(posterior2)
   summary(posterior2)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCirtKdRob'>Markov Chain Monte Carlo for Robust K-Dimensional Item Response Theory Model</h2><span id='topic+MCMCirtKdRob'></span>

<h3>Description</h3>

<p>This function generates a posterior sample from a Robust K-dimensional item
response theory (IRT) model with logistic link, independent standard normal
priors on the subject abilities (ideal points), and independent normal
priors on the item parameters.  The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc object, which
can be subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCirtKdRob(
  datamatrix,
  dimensions,
  item.constraints = list(),
  ability.constraints = list(),
  burnin = 500,
  mcmc = 5000,
  thin = 1,
  interval.method = "step",
  theta.w = 0.5,
  theta.mp = 4,
  alphabeta.w = 1,
  alphabeta.mp = 4,
  delta0.w = NA,
  delta0.mp = 3,
  delta1.w = NA,
  delta1.mp = 3,
  verbose = FALSE,
  seed = NA,
  theta.start = NA,
  alphabeta.start = NA,
  delta0.start = NA,
  delta1.start = NA,
  b0 = 0,
  B0 = 0,
  k0 = 0.1,
  k1 = 0.1,
  c0 = 1,
  d0 = 1,
  c1 = 1,
  d1 = 1,
  store.item = TRUE,
  store.ability = FALSE,
  drop.constant.items = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCirtKdRob_+3A_datamatrix">datamatrix</code></td>
<td>
<p>The matrix of data.  Must be 0, 1, or missing values.  It
is of dimensionality subjects by items.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_dimensions">dimensions</code></td>
<td>
<p>The number of dimensions in the latent space.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_item.constraints">item.constraints</code></td>
<td>
<p>List of lists specifying possible equality
or simple inequality constraints on the item parameters. A
typical entry in the list has one of three forms:
<code>rowname=list(d,c)</code> which will constrain the dth item
parameter for the item named rowname to be equal to c,
<code>rowname=list(d,"+")</code> which will constrain the dth item
parameter for the item named rowname to be positive, and
<code>rowname=list(d, "-")</code> which will constrain the dth item
parameter for the item named rowname to be negative. If
datamatrix is a matrix without row names defaults names of
&ldquo;V1&quot;, &ldquo;V2&quot;, ... , etc will be used. In a <code class="reqn">K</code>-dimensional
model, the first item parameter for item <code class="reqn">i</code> is the
difficulty parameter (<code class="reqn">\alpha_i</code>), the second item parameter
is the discrimation parameter on dimension 1 (<code class="reqn">\beta_{i,1}</code>),
the third item parameter is the discrimation parameter on
dimension 2 (<code class="reqn">\beta_{i,2}</code>), ..., and the <code class="reqn">(K+1)</code>th item
parameter is the discrimation parameter on dimension <code class="reqn">K</code>
(<code class="reqn">\beta_{i,K}</code>).  The item difficulty parameters
(<code class="reqn">\alpha</code>) should generally not be constrained.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_ability.constraints">ability.constraints</code></td>
<td>
<p>List of lists specifying possible equality or
simple inequality constraints on the ability parameters. A typical entry in
the list has one of three forms: <code>colname=list(d,c)</code> which will
constrain the dth ability parameter for the subject named colname to be
equal to c, <code>colname=list(d,"+")</code> which will constrain the dth ability
parameter for the subject named colname to be positive, and
<code>colname=list(d, "-")</code> which will constrain the dth ability parameter
for the subject named colname to be negative. If datamatrix is a matrix
without column names defaults names of &ldquo;V1&quot;, &ldquo;V2&quot;, ... , etc will be used.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of iterations for the sampler after burn-in.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_interval.method">interval.method</code></td>
<td>
<p>Method for finding the slicing interval. Can be equal
to either <code>step</code> in which case the stepping out algorithm of Neal
(2003) is used or <code>doubling</code> in which case the doubling procedure of
Neal (2003) is used. The stepping out method tends to be faster on a
per-iteration basis as it typically requires few function calls. The
doubling method expands the initial interval more quickly which makes the
Markov chain mix somewhat more quickly&ndash; at least in some situations.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_theta.w">theta.w</code></td>
<td>
<p>The initial width of the slice sampling interval for each
ability parameter (the elements of <code class="reqn">\theta</code>)</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_theta.mp">theta.mp</code></td>
<td>
<p>The parameter governing the maximum possible width of the
slice interval for each ability parameter (the elements of
<code class="reqn">\theta</code>). If <code>interval.method="step"</code> then the maximum
width is <code>theta.w * theta.mp</code>.
</p>
<p>If <code>interval.method="doubling"</code> then the maximum width is <code>theta.w
* 2^theta.mp</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_alphabeta.w">alphabeta.w</code></td>
<td>
<p>The initial width of the slice sampling interval for each
item parameter (the elements of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>)</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_alphabeta.mp">alphabeta.mp</code></td>
<td>
<p>The parameter governing the maximum possible width of
the slice interval for each item parameters (the elements of
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code>). If <code>interval.method="step"</code>
then the maximum width is <code>alphabeta.w * alphabeta.mp</code>.
</p>
<p>If <code>interval.method="doubling"</code> then the maximum width is
<code>alphabeta.w * 2^alphabeta.mp</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_delta0.w">delta0.w</code></td>
<td>
<p>The initial width of the slice sampling interval for
<code class="reqn">\delta_0</code></p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_delta0.mp">delta0.mp</code></td>
<td>
<p>The parameter governing the maximum possible width of the
slice interval for <code class="reqn">\delta_0</code>. If <code>interval.method="step"</code>
then the maximum width is <code>delta0.w * delta0.mp</code>. If
<code>interval.method="doubling"</code> then the maximum width is <code>delta0.w *
2^delta0.mp</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_delta1.w">delta1.w</code></td>
<td>
<p>The initial width of the slice sampling interval for
<code class="reqn">\delta_1</code></p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_delta1.mp">delta1.mp</code></td>
<td>
<p>The parameter governing the maximum possible width of the
slice interval for <code class="reqn">\delta_1</code>. If <code>interval.method="step"</code>
then the maximum width is <code>delta1.w * delta1.mp</code>. If
<code>interval.method="doubling"</code> then the maximum width is <code>delta1.w *
2^delta1.mp</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If verbose &gt; 0, the iteration number with
be printed to the screen every verbose'th iteration.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_theta.start">theta.start</code></td>
<td>
<p>The starting values for the ability parameters
<code class="reqn">\theta</code>. Can be either a scalar or a matrix with number of rows
equal to the number of subjects and number of columns equal to the dimension
<code class="reqn">K</code> of the latent space. If <code>theta.start=NA</code> then starting
values will be chosen that are 0 for unconstrained subjects, -0.5 for
subjects with negative inequality constraints and 0.5 for subjects with
positive inequality constraints.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_alphabeta.start">alphabeta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code> difficulty and discrimination parameters. If
<code>alphabeta.start</code> is set to a scalar the starting value for all
unconstrained item parameters will be set to that scalar. If
<code>alphabeta.start</code> is a matrix of dimension <code class="reqn">(K+1) \times
items</code> then the <code>alphabeta.start</code> matrix is used as the
starting values (except for equality-constrained elements). If
<code>alphabeta.start</code> is set to <code>NA</code> (the default) then starting
values for unconstrained elements are set to values generated from a series
of proportional odds logistic regression fits, and starting values for
inequality constrained elements are set to either 1.0 or -1.0 depending on
the nature of the constraints.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_delta0.start">delta0.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\delta_0</code>
parameter.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_delta1.start">delta1.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\delta_1</code>
parameter.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_b0">b0</code></td>
<td>
<p>The prior means of the <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
difficulty and discrimination parameters, stacked for all items.  If a
scalar is passed, it is used as the prior mean for all items.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_b0">B0</code></td>
<td>
<p>The prior precisions (inverse variances) of the independent Normal
prior on the item parameters.  Can be either a scalar or a matrix of
dimension <code class="reqn">(K+1) \times items</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_k0">k0</code></td>
<td>
<p><code class="reqn">\delta_0</code> is constrained to lie in the interval
between 0 and <code>k0</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_k1">k1</code></td>
<td>
<p><code class="reqn">\delta_1</code> is constrained to lie in the interval
between 0 and <code>k1</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_c0">c0</code></td>
<td>
<p>Parameter governing the prior for <code class="reqn">\delta_0</code>.
<code class="reqn">\delta_0</code> divided by <code>k0</code> is assumed to be follow a beta
distribution with first parameter <code>c0</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_d0">d0</code></td>
<td>
<p>Parameter governing the prior for <code class="reqn">\delta_0</code>.
<code class="reqn">\delta_0</code> divided by <code>k0</code> is assumed to be follow a beta
distribution with second parameter <code>d0</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_c1">c1</code></td>
<td>
<p>Parameter governing the prior for <code class="reqn">\delta_1</code>.
<code class="reqn">\delta_1</code> divided by <code>k1</code> is assumed to be follow a beta
distribution with first parameter <code>c1</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_d1">d1</code></td>
<td>
<p>Parameter governing the prior for <code class="reqn">\delta_1</code>.
<code class="reqn">\delta_1</code> divided by <code>k1</code> is assumed to be follow a beta
distribution with second parameter <code>d1</code>.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_store.item">store.item</code></td>
<td>
<p>A switch that determines whether or not to store the item
parameters for posterior analysis.  <em>NOTE: This typically takes an
enormous amount of memory, so should only be used if the chain is thinned
heavily, or for applications with a small number of items</em>.  By default, the
item parameters are not stored.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_store.ability">store.ability</code></td>
<td>
<p>A switch that determines whether or not to store the
subject abilities for posterior analysis.  By default, the item parameters
are all stored.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_drop.constant.items">drop.constant.items</code></td>
<td>
<p>A switch that determines whether or not items
that have no variation should be deleted before fitting the model. Default =
TRUE.</p>
</td></tr>
<tr><td><code id="MCMCirtKdRob_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCirtKdRob</code> simulates from the posterior using the slice sampling
algorithm of Neal (2003).  The simulation proper is done in compiled C++
code to maximize efficiency.  Please consult the coda documentation for a
comprehensive list of functions that can be used to analyze the posterior
sample.
</p>
<p>The model takes the following form.  We assume that each subject has an
subject ability (ideal point) denoted <code class="reqn">\theta_j</code> <code class="reqn">(K \times
1)</code>, and that each item has a scalar difficulty parameter
<code class="reqn">\alpha_i</code> and discrimination parameter <code class="reqn">\beta_i</code>
<code class="reqn">(K \times 1)</code>.  The observed choice by subject <code class="reqn">j</code> on
item <code class="reqn">i</code> is the observed data matrix which is <code class="reqn">(I \times J)</code>.
</p>
<p>The probability that subject <code class="reqn">j</code> answers item <code class="reqn">i</code> correctly is
assumed to be:
</p>
<p style="text-align: center;"><code class="reqn">\pi_{ij} = \delta_0 + (1 - \delta_0 - \delta_1) / (1+\exp(\alpha_i - \beta_i \theta_j))</code>
</p>

<p>This model was discussed in Bafumi et al. (2005).
</p>
<p>We assume the following priors.  For the subject abilities (ideal points) we
assume independent standard Normal priors:
</p>
<p style="text-align: center;"><code class="reqn">\theta_{j,k} \sim \mathcal{N}(0,1)</code>
</p>

<p>These cannot be changed by the user.  For each item parameter, we
assume independent Normal priors:
</p>
<p style="text-align: center;"><code class="reqn">\left[\alpha_i, \beta_i \right]' \sim \mathcal{N}_{(K+1)} (b_{0,i},B_{0,i})</code>
</p>

<p>Where <code class="reqn">B_{0,i}</code> is a diagonal matrix.  One can specify a
separate prior mean and precision for each item parameter. We also
assume <code class="reqn">\delta_0 / k_0 \sim </code><code class="reqn">
\mathcal{B}eta(c_0, d_0)</code> and
<code class="reqn">\delta_1 / k_1 \sim </code><code class="reqn">
\mathcal{B}eta(c_1, d_1)</code>.
</p>
<p>The model is identified by constraints on the item parameters and / or
ability parameters. See Rivers (2004) for a discussion of identification of
IRT models.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the item parameters.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>James H. Albert. 1992. &ldquo;Bayesian Estimation of Normal Ogive
Item Response Curves Using Gibbs Sampling.&quot; <em>Journal of Educational
Statistics</em>.  17: 251-269.
</p>
<p>Joseph Bafumi, Andrew Gelman, David K. Park, and Noah Kaplan. 2005.
&ldquo;Practical Issues in Implementing and Understanding Bayesian Ideal Point
Estimation.&rdquo; <em>Political Analysis</em>.
</p>
<p>Joshua Clinton, Simon Jackman, and Douglas Rivers. 2004. &ldquo;The Statistical
Analysis of Roll Call Data.&quot;  <em>American Political Science Review</em>.  98:
355-370.
</p>
<p>Simon Jackman. 2001. &ldquo;Multidimensional Analysis of Roll Call Data via
Bayesian Simulation.&rdquo; <em>Political Analysis.</em> 9: 227-241.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. <em>Ordinal Data Modeling</em>.
Springer: New York.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Radford Neal. 2003. &ldquo;Slice Sampling&rdquo; (with discussion). <em>Annals of
Statistics</em>, 31: 705-767.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Douglas Rivers.  2004.  &ldquo;Identification of Multidimensional Item-Response
Models.&quot;  Stanford University, typescript.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCirt1d">MCMCirt1d</a></code>, <code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   ## Court example with ability (ideal point) and
   ##  item (case) constraints
   data(SupremeCourt)
   post1 &lt;- MCMCirtKdRob(t(SupremeCourt), dimensions=1,
                   burnin=500, mcmc=5000, thin=1,
                   B0=.25, store.item=TRUE, store.ability=TRUE,
                   ability.constraints=list("Thomas"=list(1,"+"),
                   "Stevens"=list(1,-4)),
                   item.constraints=list("1"=list(2,"-")),
                   verbose=50)
   plot(post1)
   summary(post1)

   ## Senate example with ability (ideal point) constraints
   data(Senate)
   namestring &lt;- as.character(Senate$member)
   namestring[78] &lt;- "CHAFEE1"
   namestring[79] &lt;- "CHAFEE2"
   namestring[59] &lt;- "SMITH.NH"
   namestring[74] &lt;- "SMITH.OR"
   rownames(Senate) &lt;- namestring
   post2 &lt;- MCMCirtKdRob(Senate[,6:677], dimensions=1,
                         burnin=1000, mcmc=5000, thin=1,
                         ability.constraints=list("KENNEDY"=list(1,-4),
                                  "HELMS"=list(1, 4), "ASHCROFT"=list(1,"+"),
                                  "BOXER"=list(1,"-"), "KERRY"=list(1,"-"),
                                  "HATCH"=list(1,"+")),
                         B0=0.1, store.ability=TRUE, store.item=FALSE,
                         verbose=5, k0=0.15, k1=0.15,
                         delta0.start=0.13, delta1.start=0.13)

   plot(post2)
   summary(post2)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMClogit'>Markov Chain Monte Carlo for Logistic Regression</h2><span id='topic+MCMClogit'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
logistic regression model using a random walk Metropolis algorithm. The user
supplies data and priors, and a sample from the posterior distribution is
returned as an mcmc object, which can be subsequently analyzed with
functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMClogit(
  formula,
  data = NULL,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  tune = 1.1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  user.prior.density = NULL,
  logfun = TRUE,
  marginal.likelihood = c("none", "Laplace"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMClogit_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_tune">tune</code></td>
<td>
<p>Metropolis tuning parameter. Can be either a positive scalar or
a <code class="reqn">k</code>-vector, where <code class="reqn">k</code> is the length of
<code class="reqn">\beta</code>.Make sure that the acceptance rate is satisfactory
(typically between 0.20 and 0.5) before using the posterior sample for
inference.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_b0">b0</code></td>
<td>
<p>If <code>user.prior.density==NULL</code> <code>b0</code> is the prior mean of
<code class="reqn">\beta</code> under a multivariate normal prior.  This can either be a
scalar or a column vector with dimension equal to the number of betas. If
this takes a scalar value, then that value will serve as the prior mean for
all of the betas.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_b0">B0</code></td>
<td>
<p>If <code>user.prior.density==NULL</code> <code>B0</code> is the prior
precision of <code class="reqn">\beta</code> under a multivariate normal prior.  This can
either be a scalar or a square matrix with dimensions equal to the number of
betas.  If this takes a scalar value, then that value times an identity
matrix serves as the prior precision of <code class="reqn">\beta</code>. Default value of
0 is equivalent to an improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_user.prior.density">user.prior.density</code></td>
<td>
<p>If non-NULL, the prior (log)density up to a
constant of proportionality. This must be a function defined in R whose
first argument is a continuous (possibly vector) variable. This first
argument is the point in the state space at which the prior (log)density is
to be evaluated. Additional arguments can be passed to
<code>user.prior.density()</code> by inserting them in the call to
<code>MCMClogit()</code>. See the Details section and the examples below for more
information.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_logfun">logfun</code></td>
<td>
<p>Logical indicating whether <code>use.prior.density()</code> returns
the natural log of a density function (TRUE) or a density (FALSE).</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated or <code>Laplace</code> in which case the Laplace approximation (see
Kass and Raftery, 1995) is used.</p>
</td></tr>
<tr><td><code id="MCMClogit_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMClogit</code> simulates from the posterior distribution of a logistic
regression model using a random walk Metropolis algorithm. The simulation
proper is done in compiled C++ code to maximize efficiency.  Please consult
the coda documentation for a comprehensive list of functions that can be
used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim \mathcal{B}ernoulli(\pi_i)</code>
</p>

<p>Where the inverse link function:
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = \frac{\exp(x_i'\beta)}{1 + \exp(x_i'\beta)}</code>
</p>

<p>By default, we assume a multivariate Normal prior on <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>Additionally, arbitrary user-defined priors can be specified with
the <code>user.prior.density</code> argument.
</p>
<p>If the default multivariate normal prior is used, the Metropolis proposal
distribution is centered at the current value of <code class="reqn">\beta</code> and has
variance-covariance <code class="reqn">V = T (B_0 + C^{-1})^{-1} T </code>, where <code class="reqn">T</code> is a the
diagonal positive definite matrix formed from the <code>tune</code>, <code class="reqn">B_0</code>
is the prior precision, and <code class="reqn">C</code> is the large sample
variance-covariance matrix of the MLEs. This last calculation is done via an
initial call to <code>glm</code>.
</p>
<p>If a user-defined prior is used, the Metropolis proposal distribution is
centered at the current value of <code class="reqn">\beta</code> and has
variance-covariance <code class="reqn">V = T C T</code>, where
<code class="reqn">T</code> is a the diagonal positive definite matrix formed from the
<code>tune</code> and <code class="reqn">C</code> is the large sample variance-covariance matrix of
the MLEs. This last calculation is done via an initial call to <code>glm</code>.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   ## default improper uniform prior
   data(birthwt)
   posterior &lt;- MCMClogit(low~age+as.factor(race)+smoke, data=birthwt)
   plot(posterior)
   summary(posterior)


   ## multivariate normal prior
   data(birthwt)
   posterior &lt;- MCMClogit(low~age+as.factor(race)+smoke, b0=0, B0=.001,
                          data=birthwt)
   plot(posterior)
   summary(posterior)


   ## user-defined independent Cauchy prior
   logpriorfun &lt;- function(beta){
     sum(dcauchy(beta, log=TRUE))
   }

   posterior &lt;- MCMClogit(low~age+as.factor(race)+smoke,
                          data=birthwt, user.prior.density=logpriorfun,
                          logfun=TRUE)
   plot(posterior)
   summary(posterior)


   ## user-defined independent Cauchy prior with additional args
   logpriorfun &lt;- function(beta, location, scale){
     sum(dcauchy(beta, location, scale, log=TRUE))
   }

   posterior &lt;- MCMClogit(low~age+as.factor(race)+smoke,
                          data=birthwt, user.prior.density=logpriorfun,
                          logfun=TRUE, location=0, scale=10)
   plot(posterior)
   summary(posterior)


   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCmetrop1R'>Metropolis Sampling from User-Written R function</h2><span id='topic+MCMCmetrop1R'></span>

<h3>Description</h3>

<p>This function allows a user to construct a sample from a user-defined
continuous distribution using a random walk Metropolis algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCmetrop1R(
  fun,
  theta.init,
  burnin = 500,
  mcmc = 20000,
  thin = 1,
  tune = 1,
  verbose = 0,
  seed = NA,
  logfun = TRUE,
  force.samp = FALSE,
  V = NULL,
  optim.method = "BFGS",
  optim.lower = -Inf,
  optim.upper = Inf,
  optim.control = list(fnscale = -1, trace = 0, REPORT = 10, maxit = 500),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCmetrop1R_+3A_fun">fun</code></td>
<td>
<p>The unnormalized (log)density of the distribution from which to
take a sample. This must be a function defined in R whose first argument is
a continuous (possibly vector) variable. This first argument is the point in
the state space at which the (log)density is to be evaluated. Additional
arguments can be passed to <code>fun()</code> by inserting them in the call to
<code>MCMCmetrop1R()</code>. See the Details section and the examples below for
more information.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_theta.init">theta.init</code></td>
<td>
<p>Starting values for the sampling. Must be of the
appropriate dimension. It must also be the case that <code>fun(theta.init,
...)</code> is greater than <code>-Inf</code> if <code>fun()</code> is a logdensity or greater
than 0 if <code>fun()</code> is a density.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_tune">tune</code></td>
<td>
<p>The tuning parameter for the Metropolis sampling.  Can be either
a positive scalar or a <code class="reqn">k</code>-vector, where <code class="reqn">k</code> is the length of
<code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\theta</code> vector, the function value, and
the Metropolis acceptance rate are sent to the screen every <code>verbose</code>th
iteration.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_logfun">logfun</code></td>
<td>
<p>Logical indicating whether <code>fun</code> returns the natural log
of a density function (TRUE) or a density (FALSE).</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_force.samp">force.samp</code></td>
<td>
<p>Logical indicating whether the sampling should proceed if
the Hessian calculated from the initial call to <code>optim</code> routine to
maximize the (log)density is not negative definite. If
<code>force.samp==TRUE</code> and the Hessian from <code>optim</code> is non-negative
definite, the Hessian is rescaled by subtracting small values from it's main
diagonal until it is negative definite. Sampling proceeds using this
rescaled Hessian in place of the original Hessian from <code>optim</code>. By
default, if <code>force.samp==FALSE</code> and the Hessian from <code>optim</code> is
non-negative definite, an error message is printed and the call to
<code>MCMCmetrop1R</code> is terminated.
</p>
<p><em>Please note that a non-negative Hessian at the mode is often an
indication that the function of interest is not a proper density. Thus,
<code>force.samp</code> should only be set equal to <code>TRUE</code> with great
caution.</em></p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_v">V</code></td>
<td>
<p>The variance-covariance matrix for the Gaussian proposal
distribution. Must be a square matrix or <code>NULL</code>. If a square matrix,
<code>V</code> must have dimension equal to the length of <code>theta.init</code>. If
<code>NULL</code>, <code>V</code> is calculated from <code>tune</code> and an initial call to
<code>optim</code>. See the Details section below for more information. Unless the
log-posterior is expensive to compute it will typically be best to use the
default <code>V = NULL</code>.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_optim.method">optim.method</code></td>
<td>
<p>The value of the <code>method</code> parameter sent to
<code>optim</code> during an initial maximization of <code>fun</code>. See <code>optim</code>
for more details.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_optim.lower">optim.lower</code></td>
<td>
<p>The value of the <code>lower</code> parameter sent to
<code>optim</code> during an initial maximization of <code>fun</code>. See <code>optim</code>
for more details.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_optim.upper">optim.upper</code></td>
<td>
<p>The value of the <code>upper</code> parameter sent to
<code>optim</code> during an initial maximization of <code>fun</code>. See <code>optim</code>
for more details.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_optim.control">optim.control</code></td>
<td>
<p>The value of the <code>control</code> parameter sent to
<code>optim</code> during an initial maximization of <code>fun</code>. See <code>optim</code>
for more details.</p>
</td></tr>
<tr><td><code id="MCMCmetrop1R_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MCMCmetrop1R produces a sample from a user-defined distribution using a
random walk Metropolis algorithm with multivariate normal proposal
distribution. See Gelman et al. (2003) and Robert &amp; Casella (2004) for
details of the random walk Metropolis algorithm.
</p>
<p>The proposal distribution is centered at the current value of
<code class="reqn">\theta</code> and has variance-covariance <code class="reqn">V</code>. If <code class="reqn">V</code> is
specified by the user to be <code>NULL</code> then <code class="reqn">V</code> is calculated
as: <code class="reqn">V = T (-1\cdot H)^{-1} T </code>, where <code class="reqn">T</code> is a the
diagonal positive definite matrix formed from the <code>tune</code> and
<code class="reqn">H</code> is the approximate Hessian of <code>fun</code> evaluated at its
mode. This last calculation is done via an initial call to
<code>optim</code>.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Siddhartha Chib; Edward Greenberg. 1995. &ldquo;Understanding the
Metropolis-Hastings Algorithm.&quot;  <em>The American Statistician</em>, 49,
327-335.
</p>
<p>Andrew Gelman, John B. Carlin, Hal S. Stern, and Donald B. Rubin. 2003.
<em>Bayesian Data Analysis</em>. 2nd Edition. Boca Raton: Chapman &amp; Hall/CRC.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Christian P. Robert and George Casella. 2004. <em>Monte Carlo Statistical
Methods</em>. 2nd Edition. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="mcmc.html#topic+metrop">metrop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 

    ## logistic regression with an improper uniform prior
    ## X and y are passed as args to MCMCmetrop1R

    logitfun &lt;- function(beta, y, X){
      eta &lt;- X %*% beta
      p &lt;- 1.0/(1.0+exp(-eta))
      sum( y * log(p) + (1-y)*log(1-p) )
    }

    x1 &lt;- rnorm(1000)
    x2 &lt;- rnorm(1000)
    Xdata &lt;- cbind(1,x1,x2)
    p &lt;- exp(.5 - x1 + x2)/(1+exp(.5 - x1 + x2))
    yvector &lt;- rbinom(1000, 1, p)

    post.samp &lt;- MCMCmetrop1R(logitfun, theta.init=c(0,0,0),
                              X=Xdata, y=yvector,
                              thin=1, mcmc=40000, burnin=500,
                              tune=c(1.5, 1.5, 1.5),
                              verbose=500, logfun=TRUE)

    raftery.diag(post.samp)
    plot(post.samp)
    summary(post.samp)
    ## ##################################################


    ##  negative binomial regression with an improper unform prior
    ## X and y are passed as args to MCMCmetrop1R
    negbinfun &lt;- function(theta, y, X){
      k &lt;- length(theta)
      beta &lt;- theta[1:(k-1)]
      alpha &lt;- exp(theta[k])
      mu &lt;- exp(X %*% beta)
      log.like &lt;- sum(
                      lgamma(y+alpha) - lfactorial(y) - lgamma(alpha) +
                      alpha * log(alpha/(alpha+mu)) +
                      y * log(mu/(alpha+mu))
                     )
    }

    n &lt;- 1000
    x1 &lt;- rnorm(n)
    x2 &lt;- rnorm(n)
    XX &lt;- cbind(1,x1,x2)
    mu &lt;- exp(1.5+x1+2*x2)*rgamma(n,1)
    yy &lt;- rpois(n, mu)

    post.samp &lt;- MCMCmetrop1R(negbinfun, theta.init=c(0,0,0,0), y=yy, X=XX,
                              thin=1, mcmc=35000, burnin=1000,
                              tune=1.5, verbose=500, logfun=TRUE,
                              seed=list(NA,1))
    raftery.diag(post.samp)
    plot(post.samp)
    summary(post.samp)
    ## ##################################################


    ## sample from a univariate normal distribution with
    ## mean 5 and standard deviation 0.1
    ##
    ## (MCMC obviously not necessary here and this should
    ##  really be done with the logdensity for better
    ##  numerical accuracy-- this is just an illustration of how
    ##  MCMCmetrop1R works with a density rather than logdensity)

    post.samp &lt;- MCMCmetrop1R(dnorm, theta.init=5.3, mean=5, sd=0.1,
                          thin=1, mcmc=50000, burnin=500,
                          tune=2.0, verbose=5000, logfun=FALSE)

    summary(post.samp)

  
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCmixfactanal'>Markov Chain Monte Carlo for Mixed Data Factor Analysis Model</h2><span id='topic+MCMCmixfactanal'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a mixed
data (both continuous and ordinal) factor analysis model. Normal priors are
assumed on the factor loadings and factor scores, improper uniform priors
are assumed on the cutpoints, and inverse gamma priors are assumed for the
error variances (uniquenesses). The user supplies data and parameters for
the prior distributions, and a sample from the posterior distribution is
returned as an mcmc object, which can be subsequently analyzed with
functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCmixfactanal(
  x,
  factors,
  lambda.constraints = list(),
  data = parent.frame(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  tune = NA,
  verbose = 0,
  seed = NA,
  lambda.start = NA,
  psi.start = NA,
  l0 = 0,
  L0 = 0,
  a0 = 0.001,
  b0 = 0.001,
  store.lambda = TRUE,
  store.scores = FALSE,
  std.mean = TRUE,
  std.var = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCmixfactanal_+3A_x">x</code></td>
<td>
<p>A one-sided formula containing the manifest variables. Ordinal
(including dichotomous) variables must be coded as ordered factors. Each
level of these ordered factors must be present in the data passed to the
function.  NOTE: data input is different in <code>MCMCmixfactanal</code> than in
either <code>MCMCfactanal</code> or <code>MCMCordfactanal</code>.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_factors">factors</code></td>
<td>
<p>The number of factors to be fitted.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_lambda.constraints">lambda.constraints</code></td>
<td>
<p>List of lists specifying possible equality or
simple inequality constraints on the factor loadings. A typical entry in the
list has one of three forms: <code>varname=list(d,c)</code> which will constrain
the dth loading for the variable named varname to be equal to c,
<code>varname=list(d,"+")</code> which will constrain the dth loading for the
variable named varname to be positive, and <code>varname=list(d, "-")</code> which
will constrain the dth loading for the variable named varname to be
negative. If x is a matrix without column names defaults names of &ldquo;V1&quot;,
&ldquo;V2&quot;, ... , etc will be used. Note that, unlike <code>MCMCfactanal</code>, the
<code class="reqn">\Lambda</code> matrix used here has <code>factors</code>+1 columns. The
first column of <code class="reqn">\Lambda</code> corresponds to negative item
difficulty parameters for ordinal manifest variables and mean parameters for
continuous manifest variables and should generally not be constrained
directly by the user.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_tune">tune</code></td>
<td>
<p>The tuning parameter for the Metropolis-Hastings sampling. Can
be either a scalar or a <code class="reqn">k</code>-vector (where <code class="reqn">k</code> is the number of
manifest variables). <code>tune</code> must be strictly positive.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is great than 0 the
iteration number and the Metropolis-Hastings acceptance rate are printed to
the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_lambda.start">lambda.start</code></td>
<td>
<p>Starting values for the factor loading matrix Lambda. If
<code>lambda.start</code> is set to a scalar the starting value for all
unconstrained loadings will be set to that scalar. If <code>lambda.start</code> is
a matrix of the same dimensions as Lambda then the <code>lambda.start</code>
matrix is used as the starting values (except for equality-constrained
elements). If <code>lambda.start</code> is set to <code>NA</code> (the default) then
starting values for unconstrained elements in the first column of Lambda are
based on the observed response pattern, the remaining unconstrained elements
of Lambda are set to 0, and starting values for inequality constrained
elements are set to either 1.0 or -1.0 depending on the nature of the
constraints.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_psi.start">psi.start</code></td>
<td>
<p>Starting values for the error variance (uniqueness) matrix.
If <code>psi.start</code> is set to a scalar then the starting value for all
diagonal elements of <code>Psi</code> that represent error variances for
continuous variables are set to this value. If <code>psi.start</code> is a
<code class="reqn">k</code>-vector (where <code class="reqn">k</code> is the number of manifest variables)
then the staring value of <code>Psi</code> has <code>psi.start</code> on the main
diagonal with the exception that entries corresponding to error variances
for ordinal variables are set to 1.. If <code>psi.start</code> is set to <code>NA</code>
(the default) the starting values of all the continuous variable
uniquenesses are set to 0.5. Error variances for ordinal response variables
are always constrained (regardless of the value of <code>psi.start</code> to have
an error variance of 1 in order to achieve identification.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_l0">l0</code></td>
<td>
<p>The means of the independent Normal prior on the factor loadings.
Can be either a scalar or a matrix with the same dimensions as
<code>Lambda</code>.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_l0">L0</code></td>
<td>
<p>The precisions (inverse variances) of the independent Normal prior
on the factor loadings. Can be either a scalar or a matrix with the same
dimensions as <code>Lambda</code>.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_a0">a0</code></td>
<td>
<p>Controls the shape of the inverse Gamma prior on the uniqueness.
The actual shape parameter is set to <code>a0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_b0">b0</code></td>
<td>
<p>Controls the scale of the inverse Gamma prior on the uniquenesses.
The actual scale parameter is set to <code>b0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_store.lambda">store.lambda</code></td>
<td>
<p>A switch that determines whether or not to store the
factor loadings for posterior analysis. By default, the factor loadings are
all stored.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_store.scores">store.scores</code></td>
<td>
<p>A switch that determines whether or not to store the
factor scores for posterior analysis.  <em>NOTE: This takes an enormous
amount of memory, so should only be used if the chain is thinned heavily, or
for applications with a small number of observations</em>.  By default, the
factor scores are not stored.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_std.mean">std.mean</code></td>
<td>
<p>If <code>TRUE</code> (the default) the continuous manifest
variables are rescaled to have zero mean.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_std.var">std.var</code></td>
<td>
<p>If <code>TRUE</code> (the default) the continuous manifest
variables are rescaled to have unit variance.</p>
</td></tr>
<tr><td><code id="MCMCmixfactanal_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model takes the following form:
</p>
<p>Let <code class="reqn">i=1,\ldots,N</code> index observations and <code class="reqn">j=1,\ldots,K</code>
index response variables within an observation. An observed
variable <code class="reqn">x_{ij}</code> can be either ordinal with a total of
<code class="reqn">C_j</code> categories or continuous.  The distribution of <code class="reqn">X</code> is
governed by a <code class="reqn">N \times K</code> matrix of latent variables <code class="reqn">X^*</code>
and a series of cutpoints <code class="reqn">\gamma</code>. <code class="reqn">X^*</code> is assumed to be
generated according to:
</p>
<p style="text-align: center;"><code class="reqn">x^*_i = \Lambda \phi_i + \epsilon_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_i \sim \mathcal{N}(0,\Psi)</code>
</p>

<p>where <code class="reqn">x^*_i</code> is the <code class="reqn">k</code>-vector of latent variables
specific to observation <code class="reqn">i</code>, <code class="reqn">\Lambda</code> is the <code class="reqn">k \times
d</code> matrix of factor loadings, and <code class="reqn">\phi_i</code> is the
<code class="reqn">d</code>-vector of latent factor scores. It is assumed that the
first element of <code class="reqn">\phi_i</code> is equal to 1 for all <code class="reqn">i</code>.
</p>
<p>If the <code class="reqn">j</code>th variable is ordinal, the probability that it takes the
value <code class="reqn">c</code> in observation <code class="reqn">i</code> is:
</p>
<p style="text-align: center;"><code class="reqn">\pi_{ijc} = \Phi(\gamma_{jc} - \Lambda'_j\phi_i) -
\Phi(\gamma_{j(c-1)} - \Lambda'_j\phi_i)</code>
</p>

<p>If the <code class="reqn">j</code>th variable is continuous, it is assumed that <code class="reqn">x^*_{ij}
= x_{ij}</code> for all <code class="reqn">i</code>.
</p>
<p>The implementation used here assumes independent conjugate priors for each
element of <code class="reqn">\Lambda</code> and each <code class="reqn">\phi_i</code>. More
specifically we assume:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_{ij} \sim \mathcal{N}(l_{0_{ij}}, L_{0_{ij}}^{-1}),
i=1,\ldots,k, j=1,\ldots,d</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_{i(2:d)} \sim \mathcal{N}(0, I), i=1,\dots,n</code>
</p>

<p><code>MCMCmixfactanal</code> simulates from the posterior distribution using a
Metropolis-Hastings within Gibbs sampling algorithm. The algorithm employed
is based on work by Cowles (1996).  Note that the first element of
<code class="reqn">\phi_i</code> is a 1. As a result, the first column of
<code class="reqn">\Lambda</code> can be interpretated as negative item difficulty
parameters.  Further, the first element <code class="reqn">\gamma_1</code> is
normalized to zero, and thus not returned in the mcmc object.  The
simulation proper is done in compiled C++ code to maximize efficiency.
Please consult the coda documentation for a comprehensive list of functions
that can be used to analyze the posterior sample.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the scores.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Kevin M. Quinn. 2004. &ldquo;Bayesian Factor Analysis for Mixed
Ordinal and Continuous Responses.&rdquo; <em>Political Analysis</em>. 12: 338-353.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>M. K. Cowles. 1996. &ldquo;Accelerating Monte Carlo Markov Chain Convergence for
Cumulative-link Generalized Linear Models.&quot; <em>Statistics and Computing.</em>
6: 101-110.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. &ldquo;Ordinal Data Modeling.&quot;
Springer: New York.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+factanal">factanal</a></code>, <code><a href="#topic+MCMCfactanal">MCMCfactanal</a></code>,
<code><a href="#topic+MCMCordfactanal">MCMCordfactanal</a></code>, <code><a href="#topic+MCMCirt1d">MCMCirt1d</a></code>,
<code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(PErisk)

post &lt;- MCMCmixfactanal(~courts+barb2+prsexp2+prscorr2+gdpw2,
                        factors=1, data=PErisk,
                        lambda.constraints = list(courts=list(2,"-")),
                        burnin=5000, mcmc=1000000, thin=50,
                        verbose=500, L0=.25, store.lambda=TRUE,
                        store.scores=TRUE, tune=1.2)
plot(post)
summary(post)




library(MASS)
data(Cars93)
attach(Cars93)
new.cars &lt;- data.frame(Price, MPG.city, MPG.highway,
                 Cylinders, EngineSize, Horsepower,
                 RPM, Length, Wheelbase, Width, Weight, Origin)
rownames(new.cars) &lt;- paste(Manufacturer, Model)
detach(Cars93)

# drop obs 57 (Mazda RX 7) b/c it has a rotary engine
new.cars &lt;- new.cars[-57,]
# drop 3 cylinder cars
new.cars &lt;- new.cars[new.cars$Cylinders!=3,]
# drop 5 cylinder cars
new.cars &lt;- new.cars[new.cars$Cylinders!=5,]

new.cars$log.Price &lt;- log(new.cars$Price)
new.cars$log.MPG.city &lt;- log(new.cars$MPG.city)
new.cars$log.MPG.highway &lt;- log(new.cars$MPG.highway)
new.cars$log.EngineSize &lt;- log(new.cars$EngineSize)
new.cars$log.Horsepower &lt;- log(new.cars$Horsepower)

new.cars$Cylinders &lt;- ordered(new.cars$Cylinders)
new.cars$Origin    &lt;- ordered(new.cars$Origin)



post &lt;- MCMCmixfactanal(~log.Price+log.MPG.city+
                 log.MPG.highway+Cylinders+log.EngineSize+
                 log.Horsepower+RPM+Length+
                 Wheelbase+Width+Weight+Origin, data=new.cars,
                 lambda.constraints=list(log.Horsepower=list(2,"+"),
                 log.Horsepower=c(3,0), weight=list(3,"+")),
                 factors=2,
                 burnin=5000, mcmc=500000, thin=100, verbose=500,
                 L0=.25, tune=3.0)
plot(post)
summary(post)


## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCmnl'>Markov Chain Monte Carlo for Multinomial Logistic Regression</h2><span id='topic+MCMCmnl'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
multinomial logistic regression model using either a random walk Metropolis
algorithm or a slice sampler. The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc object, which
can be subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCmnl(
  formula,
  baseline = NULL,
  data = NULL,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  mcmc.method = "IndMH",
  tune = 1,
  tdf = 6,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCmnl_+3A_formula">formula</code></td>
<td>
<p>Model formula.
</p>
<p>If the choicesets do not vary across individuals, the <code>y</code> variable
should be a factor or numeric variable that gives the observed choice of
each individual. If the choicesets do vary across individuals, <code>y</code>
should be a <code class="reqn">n \times p</code> matrix where <code class="reqn">n</code> is the number of
individuals and <code class="reqn">p</code> is the maximum number of choices in any
choiceset.  Here each column of <code>y</code> corresponds to a particular
observed choice and the elements of <code>y</code> should be either <code>0</code> (not
chosen but available), <code>1</code> (chosen), or <code>-999</code> (not available).
</p>
<p>Choice-specific covariates have to be entered using the syntax:
<code>choicevar(cvar, "var", "choice")</code> where <code>cvar</code> is the name of a
variable in <code>data</code>, <code>"var"</code> is the name of the new variable to be
created, and <code>"choice"</code> is the level of <code>y</code> that <code>cvar</code>
corresponds to. Specifying each choice-specific covariate will typically
require <code class="reqn">p</code> calls to the <code>choicevar</code> function in the formula.
</p>
<p>Individual specific covariates can be entered into the formula normally.
</p>
<p>See the examples section below to see the syntax used to fit various models.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_baseline">baseline</code></td>
<td>
<p>The baseline category of the response variable.
</p>
<p><code>baseline</code> should be set equal to one of the observed levels of the
response variable. If left equal to <code>NULL</code> then the baseline level is
set to the alpha-numerically first element of the response variable. If the
choicesets vary across individuals, the baseline choice must be in the
choiceset of each individual.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_data">data</code></td>
<td>
<p>The data frame used for the analysis. Each row of the dataframe
should correspond to an individual who is making a choice.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of iterations to run the sampler past burn-in.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_mcmc.method">mcmc.method</code></td>
<td>
<p>Can be set to either &quot;IndMH&quot; (default), &quot;RWM&quot;, or &quot;slice&quot;
to perform independent Metropolis-Hastings sampling, random walk Metropolis
sampling or slice sampling respectively.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_tune">tune</code></td>
<td>
<p>Metropolis tuning parameter. Can be either a positive scalar or
a <code class="reqn">k</code>-vector, where <code class="reqn">k</code> is the length of <code class="reqn">\beta</code>.
Make sure that the acceptance rate is satisfactory (typically between 0.20
and 0.5) before using the posterior sample for inference.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_tdf">tdf</code></td>
<td>
<p>Degrees of freedom for the multivariate-t proposal distribution
when <code>mcmc.method</code> is set to &quot;IndMH&quot;. Must be positive.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>. This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\beta</code>. Default value of 0 is
equivalent to an improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCmnl_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCmnl</code> simulates from the posterior distribution of a multinomial
logistic regression model using either a random walk Metropolis algorithm or
a univariate slice sampler. The simulation proper is done in compiled C++
code to maximize efficiency.  Please consult the coda documentation for a
comprehensive list of functions that can be used to analyze the posterior
sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim \mathcal{M}ultinomial(\pi_i)</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">\pi_{ij} = \frac{\exp(x_{ij}'\beta)}{\sum_{k=1}^p\exp(x_{ik}'\beta)}</code>
</p>

<p>We assume a multivariate Normal prior on <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>The Metropolis proposal distribution is centered at the current
value of <code class="reqn">\beta</code> and has variance-covariance
<code class="reqn">V = T(B_0 + C^{-1})^{-1} T</code>, where <code class="reqn">T</code> is a the
diagonal positive definite matrix formed from the <code>tune</code>,
<code class="reqn">B_0</code> is the prior precision, and <code class="reqn">C</code> is the large sample
variance-covariance matrix of the MLEs. This last calculation is
done via an initial call to <code>optim</code>.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Radford Neal. 2003. &ldquo;Slice Sampling&rdquo; (with discussion). <em>Annals of
Statistics</em>, 31: 705-767.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Siddhartha Chib, Edward Greenberg, and Yuxin Chen. 1998.  &ldquo;MCMC Methods for
Fitting and Comparing Multinomial Response Models.&quot;
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="nnet.html#topic+multinom">multinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  data(Nethvote)

  ## just a choice-specific X var
  post1 &lt;- MCMCmnl(vote ~
                choicevar(distD66, "sqdist", "D66") +
                choicevar(distPvdA, "sqdist", "PvdA") +
                choicevar(distVVD, "sqdist", "VVD") +
                choicevar(distCDA, "sqdist", "CDA"),
                baseline="D66", mcmc.method="IndMH", B0=0,
                verbose=500, mcmc=100000, thin=10, tune=1.0,
                data=Nethvote)

  plot(post1)
  summary(post1)



  ## just individual-specific X vars
  post2&lt;- MCMCmnl(vote ~
                relig + class + income + educ + age + urban,
                baseline="D66", mcmc.method="IndMH", B0=0,
                verbose=500, mcmc=100000, thin=10, tune=0.5,
                data=Nethvote)

  plot(post2)
  summary(post2)



  ## both choice-specific and individual-specific X vars
  post3 &lt;- MCMCmnl(vote ~
                choicevar(distD66, "sqdist", "D66") +
                choicevar(distPvdA, "sqdist", "PvdA") +
                choicevar(distVVD, "sqdist", "VVD") +
                choicevar(distCDA, "sqdist", "CDA") +
                relig + class + income + educ + age + urban,
                baseline="D66", mcmc.method="IndMH", B0=0,
                verbose=500, mcmc=100000, thin=10, tune=0.5,
                data=Nethvote)

  plot(post3)
  summary(post3)


  ## numeric y variable
  nethvote$vote &lt;- as.numeric(nethvote$vote)
  post4 &lt;- MCMCmnl(vote ~
                choicevar(distD66, "sqdist", "2") +
                choicevar(distPvdA, "sqdist", "3") +
                choicevar(distVVD, "sqdist", "4") +
                choicevar(distCDA, "sqdist", "1") +
                relig + class + income + educ + age + urban,
                baseline="2", mcmc.method="IndMH", B0=0,
                verbose=500, mcmc=100000, thin=10, tune=0.5,
                data=Nethvote)


  plot(post4)
  summary(post4)



  ## Simulated data example with nonconstant choiceset
  n &lt;- 1000
  y &lt;- matrix(0, n, 4)
  colnames(y) &lt;- c("a", "b", "c", "d")
  xa &lt;- rnorm(n)
  xb &lt;- rnorm(n)
  xc &lt;- rnorm(n)
  xd &lt;- rnorm(n)
  xchoice &lt;- cbind(xa, xb, xc, xd)
  z &lt;- rnorm(n)
  for (i in 1:n){
    ## randomly determine choiceset (c is always in choiceset)
    choiceset &lt;- c(3, sample(c(1,2,4), 2, replace=FALSE))
    numer &lt;- matrix(0, 4, 1)
    for (j in choiceset){
      if (j == 3){
        numer[j] &lt;- exp(xchoice[i, j] )
      }
      else {
        numer[j] &lt;- exp(xchoice[i, j] - z[i] )
      }
    }
    p &lt;- numer / sum(numer)
    y[i,] &lt;- rmultinom(1, 1, p)
    y[i,-choiceset] &lt;- -999
  }

  post5 &lt;- MCMCmnl(y~choicevar(xa, "x", "a") +
                  choicevar(xb, "x", "b") +
                  choicevar(xc, "x", "c") +
                  choicevar(xd, "x", "d") + z,
                  baseline="c", verbose=500,
                  mcmc=100000, thin=10, tune=.85)

  plot(post5)
  summary(post5)

  
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCnegbin'>Markov Chain Monte Carlo for Negative Binomial Regression</h2><span id='topic+MCMCnegbin'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
Negative Binomial regression model via auxiliary mixture sampling. The user
supplies data and priors, and a sample from the posterior distribution is
returned as an mcmc object, which can be subsequently analyzed with
functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCnegbin(
  formula,
  data = parent.frame(),
  b0 = 0,
  B0 = 1,
  e = 2,
  f = 2,
  g = 10,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  rho.start = NA,
  rho.step = 0.1,
  nu.start = NA,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCnegbin_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\beta</code>. Default value of 0 is
equivalent to an improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_e">e</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_f">f</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_g">g</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_rho.start">rho.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\rho</code> variable.
The default value is 1.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_rho.step">rho.step</code></td>
<td>
<p>Tuning parameter for the slice sampling approach to
sampling <code class="reqn">rho</code>. Determines the size of the step-out used to
find the correct slice to draw from. Lower values are more
accurate, but will take longer (up to a fixed searching limit).
Default is 0.1.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_nu.start">nu.start</code></td>
<td>
<p>The starting values for the random effect,
<code class="reqn">\nu</code>. The default value is a vector of ones.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated or <code>Laplace</code> in which case the Laplace approximation (see
Kass and Raftery, 1995) is used.</p>
</td></tr>
<tr><td><code id="MCMCnegbin_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCnegbin</code> simulates from the posterior distribution of a
Negative Binomial regression model using a combination of auxiliary
mixture sampling and slice sampling. The simulation proper is done
in compiled C++ code to maximize efficiency. Please consult the
coda documentation for a comprehensive list of functions that can
be used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim \mathcal{P}oisson(\nu_i\mu_i)</code>
</p>

<p>Where the inverse link function:
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = \exp(x_i'\beta)</code>
</p>

<p>We assume a multivariate Normal prior on <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>The unit-level random effect that handles overdispersion is assumed
to be distributed Gamma:
</p>
<p style="text-align: center;"><code class="reqn">\nu_i \sim \mathcal{G}amma(\rho, \rho)</code>
</p>

<p>The overdispersion parameter has a prior with the following form:
</p>
<p style="text-align: center;"><code class="reqn">f(\rho|e,f,g) \propto \rho^{e-1}(\rho + g)^{-(e+f)}</code>
</p>

<p>The model is simulated via blocked Gibbs, with the the <code class="reqn">\beta</code>
being simulated via the auxiliary mixture sampling method of
Fuerhwirth-Schanetter et al. (2009). The <code class="reqn">\rho</code> is updated via
slice sampling. The <code class="reqn">\nu_i</code> are updated their (conjugate) full
conditional, which is also Gamma.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Sylvia Fruehwirth-Schnatter, Rudolf Fruehwirth, Leonhard Held, and
Havard Rue. 2009. &ldquo;Improved auxiliary mixture sampling for
hierarchical models of non-Gaussian data&rdquo;, <em>Statistics
and Computing</em> 19(4): 479-492.
&lt;doi:10.1007/s11222-008-9109-4&gt;
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   n &lt;- 150
   mcmcs &lt;- 5000
   burnin &lt;- 5000
   thin &lt;- 5
   x1 &lt;- runif(n, 0, 2)
   rho.true &lt;- 1.5
   nu.true &lt;- rgamma(n, rho.true, rho.true)
   mu &lt;- nu.true * exp(1 + x1 * 1)
   y &lt;- rpois(n, mu)
   posterior &lt;- MCMCnegbin(y ~ x1)
   plot(posterior)
   summary(posterior)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCnegbinChange'>Markov Chain Monte Carlo for Negative Binomial Regression
Changepoint Model</h2><span id='topic+MCMCnegbinChange'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a Negative Binomial regression model with multiple changepoints.
For the changepoints, the sampler uses the Markov Chain Monte Carlo
method of Chib (1998). The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCnegbinChange(
  formula,
  data = parent.frame(),
  m = 1,
  fixed.m = TRUE,
  b0 = 0,
  B0 = 1,
  a = NULL,
  b = NULL,
  e = 2,
  f = 2,
  g = 10,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  rho.start = NA,
  rho.step,
  nu.start = NA,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCnegbinChange_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_fixed.m">fixed.m</code></td>
<td>
<p>A logical indicator for whether or not the number of
changepoints in the sampler should be exactly equal to <code>m</code>
or if that is simply an upper bound. Setting <code>fixed.m</code> to
<code>FALSE</code> is equivalent to assuming a weak-limit approximation
to a Dirichlet process mixture.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_e">e</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code> See details.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_f">f</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_g">g</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value
for all regimes.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix. A user should
provide a square matrix with dimension equal to the number of states. By
default, draws from the <code>Beta(0.9, 0.1)</code> are used to construct a proper
transition matrix for each raw except the last raw.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_rho.start">rho.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\rho</code> variable.
This can either be a scalar or a column vector with dimension
equal to the number of regimes. If the value is scalar, it will
be used for all regimes. The default value is a vector of ones.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_rho.step">rho.step</code></td>
<td>
<p>Tuning parameter for the slice sampling approach to
sampling <code class="reqn">rho</code>. Determines the size of the step-out used to
find the correct slice to draw from. Lower values are more
accurate, but will take longer (up to a fixed searching limit).
Default is 0.1.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_nu.start">nu.start</code></td>
<td>
<p>The starting values for the random effect,
<code class="reqn">\nu</code>. The default value is a vector of ones.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated or <code>Laplace</code> in which case the Laplace approximation (see
Kass and Raftery, 1995) is used.</p>
</td></tr>
<tr><td><code id="MCMCnegbinChange_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCnegbinChange</code>simulates from the posterior distribution of a
Negative Binomial regression model with multiple changepoints using the methods of
Chib (1998) and Fruehwirth-Schnatter et al (2009).  The details of the
model are discussed in Blackwell (2017).
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_t \sim \mathcal{P}oisson(\nu_t\mu_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = x_t ' \beta_m,\;\; m = 1, \ldots, M</code>
</p>

<p style="text-align: center;"><code class="reqn">\nu_t \sim \mathcal{G}amma(\rho_m, \rho_m)</code>
</p>

<p>Where
<code class="reqn">M</code> is the number of states and <code class="reqn">\beta_m</code> and <code class="reqn">\rho_m</code>
are parameters when a state is <code class="reqn">m</code> at <code class="reqn">t</code>.
</p>
<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, M</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>
<p> Where <code class="reqn">M</code> is the number of states.
</p>
<p>The overdispersion parameters have a prior with the following form:
</p>
<p style="text-align: center;"><code class="reqn">f(\rho_m|e,f,g) \propto \rho^{e-1}(\rho + g)^{-(e+f)}</code>
</p>

<p>The model is simulated via blocked Gibbs conditonal on the states.
The <code class="reqn">\beta</code> being simulated via the auxiliary mixture sampling
method of Fuerhwirth-Schanetter et al. (2009). The <code class="reqn">\rho</code> is
updated via slice sampling. The <code class="reqn">\nu_i</code> are updated their
(conjugate) full conditional, which is also Gamma. The states are
updated as in Chib (1998)
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Sylvia Fruehwirth-Schnatter, Rudolf Fruehwirth, Leonhard Held, and
Havard Rue. 2009. &ldquo;Improved auxiliary mixture sampling for
hierarchical models of non-Gaussian data&rdquo;, <em>Statistics
and Computing</em> 19(4): 479-492.
&lt;doi:10.1007/s11222-008-9109-4&gt;
</p>
<p>Matthew Blackwell. 2017. &ldquo;Game Changers: Detecting Shifts in
Overdispersed Count Data,&rdquo; <em>Political Analysis</em>
26(2), 230-239. &lt;doi:10.1017/pan.2017.42&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCpoissonChange">MCMCpoissonChange</a></code>, <code><a href="#topic+plotState">plotState</a></code>,
<code><a href="#topic+plotChangepoint">plotChangepoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   n &lt;- 150
   reg &lt;- 3
   true.s &lt;- gl(reg, n/reg, n)
   rho.true &lt;- c(1.5, 0.5, 3)
   b0.true &lt;- c(1, 3, 1)
   b1.true &lt;- c(1, -2, 2)
   x1 &lt;- runif(n, 0, 2)
   nu.true &lt;- rgamma(n, rho.true[true.s], rho.true[true.s])
   mu &lt;- nu.true * exp(b0.true[true.s] + x1 * b1.true[true.s])
   y &lt;- rpois(n, mu)

   posterior &lt;- MCMCnegbinChange(y ~ x1, m = 2, verbose = 1000,
                          marginal.likelihood = "Chib95",
                          e = 2, f = 2, g = 10,
                          b0 = rep(0, 2), B0 = (1/9) * diag(2),
                          rho.step = rep(0.75, times = 3),
                          seed = list(NA, 2))

   par(mfrow=c(attr(posterior, "m") + 1, 1), mai=c(0.4, 0.6, 0.3, 0.05))
   plotState(posterior, legend.control = c(1, 0.6))
   plotChangepoint(posterior, verbose = TRUE, ylab="Density",
  start=1, overlay=TRUE)


   open.ended &lt;- MCMCnegbinChange(y ~ x1, m = 10, verbose = 1000,
                          fixed.m = FALSE, mcmc = 2000, burnin = 2000,
                          e = 2, f = 2, g = 10,
                          a = 100, b = 1,
                          b0 = rep(0, 2), B0 = (1/9) * diag(2),
                          rho.step = 0.75,
                          seed = list(NA, 2))

   plotState(open.ended, legend.control = c(1, 0.6))
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCoprobit'>Markov Chain Monte Carlo for Ordered Probit Regression</h2><span id='topic+MCMCoprobit'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
an ordered probit regression model using the data augmentation approach of
Albert and Chib (1993), with cut-points sampled according to Cowles (1996)
or Albert and Chib (2001). The user supplies data and priors, and a sample from the
posterior distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCoprobit(
  formula,
  data = parent.frame(),
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  tune = NA,
  tdf = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  a0 = 0,
  A0 = 0,
  mcmc.method = c("Cowles", "AC"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCoprobit_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_tune">tune</code></td>
<td>
<p>The tuning parameter for the Metropolis-Hastings step. Default
of NA corresponds to a choice of 0.05 divided by the number of categories in
the response variable.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_tdf">tdf</code></td>
<td>
<p>Degrees of freedom for the multivariate-t proposal distribution
when <code>mcmc.method</code> is set to &quot;IndMH&quot;. Must be positive.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the beta vector, and the Metropolis-Hastings acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas. The default value of NA will use
rescaled estimates from an ordered logit model.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\beta</code>.  Default value of 0 is
equivalent to an improper uniform prior on <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_a0">a0</code></td>
<td>
<p>The prior mean of <code class="reqn">\gamma</code>.  This can either be a
scalar or a column vector with dimension equal to the number of betas. If
this takes a scalar value, then that value will serve as the prior mean for
all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_a0">A0</code></td>
<td>
<p>The prior precision of <code class="reqn">\gamma</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\gamma</code>.  Default value of 0 is
equivalent to an improper uniform prior on <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_mcmc.method">mcmc.method</code></td>
<td>
<p>Can be set to either &quot;Cowles&quot; (default) or &quot;AC&quot; to
perform posterior sampling of cutpoints based on Cowles (1996) or Albert and
Chib (2001) respectively.</p>
</td></tr>
<tr><td><code id="MCMCoprobit_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCoprobit</code> simulates from the posterior distribution of a ordered
probit regression model using data augmentation. The simulation proper is
done in compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The observed variable <code class="reqn">y_i</code> is ordinal with a total of <code class="reqn">C</code>
categories, with distribution governed by a latent variable: </p>
<p style="text-align: center;"><code class="reqn">z_i =
x_i'\beta + \varepsilon_i</code>
</p>
<p> The errors are
assumed to be from a standard Normal distribution.  The probabilities of
observing each outcome is governed by this latent variable and
<code class="reqn">C-1</code> estimable cutpoints, which are denoted
<code class="reqn">\gamma_c</code>.  The probability that individual <code class="reqn">i</code> is in
category <code class="reqn">c</code> is computed by:
</p>
<p style="text-align: center;"><code class="reqn">\pi_{ic} = \Phi(\gamma_c - x_i'\beta) - \Phi(\gamma_{c-1} -
x_i'\beta)</code>
</p>

<p>These probabilities are used to form the multinomial distribution
that defines the likelihoods.
</p>
<p><code>MCMCoprobit</code> provides two ways to sample the cutpoints. Cowles (1996)
proposes a sampling scheme that groups sampling of a latent variable with
cutpoints.  In this case, for identification the first element
<code class="reqn">\gamma_1</code> is normalized to zero. Albert and Chib (2001) show
that we can sample cutpoints indirectly without constraints by transforming
cutpoints into real-valued parameters (<code class="reqn">\alpha</code>).
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Albert, J. H. and S. Chib. 1993. &ldquo;Bayesian Analysis of Binary
and Polychotomous Response Data.&rdquo; <em>J. Amer. Statist. Assoc.</em> 88,
669-679
</p>
<p>M. K. Cowles. 1996. &ldquo;Accelerating Monte Carlo Markov Chain Convergence for
Cumulative-link Generalized Linear Models.&quot; <em>Statistics and Computing.</em>
6: 101-110.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. <em>Ordinal Data Modeling</em>.
Springer: New York.
</p>
<p>Albert, James and Siddhartha Chib. 2001. &ldquo;Sequential Ordinal Modeling with
Applications to Survival Data.&quot; <em>Biometrics.</em> 57: 829-836.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   x1 &lt;- rnorm(100); x2 &lt;- rnorm(100);
   z &lt;- 1.0 + x1*0.1 - x2*0.5 + rnorm(100);
   y &lt;- z; y[z &lt; 0] &lt;- 0; y[z &gt;= 0 &amp; z &lt; 1] &lt;- 1;
   y[z &gt;= 1 &amp; z &lt; 1.5] &lt;- 2; y[z &gt;= 1.5] &lt;- 3;
   out1 &lt;- MCMCoprobit(y ~ x1 + x2, tune=0.3)
   out2 &lt;- MCMCoprobit(y ~ x1 + x2, tune=0.3, tdf=3, verbose=1000, mcmc.method="AC")
   summary(out1)
   summary(out2)
   plot(out1)
   plot(out2)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCoprobitChange'>Markov Chain Monte Carlo for Ordered Probit Changepoint Regression Model</h2><span id='topic+MCMCoprobitChange'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of an
ordered probit regression model with multiple parameter breaks. The function
uses the Markov chain Monte Carlo method of Chib (1998).  The user supplies
data and priors, and a sample from the posterior distribution is returned as
an mcmc object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCoprobitChange(
  formula,
  data = parent.frame(),
  m = 1,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  tune = NA,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  gamma.start = NA,
  P.start = NA,
  b0 = NULL,
  B0 = NULL,
  a = NULL,
  b = NULL,
  marginal.likelihood = c("none", "Chib95"),
  gamma.fixed = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCoprobitChange_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_tune">tune</code></td>
<td>
<p>The tuning parameter for the Metropolis-Hastings step. Default
of NA corresponds to a choice of 0.05 divided by the number of categories in
the response variable.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of betas.  The default value of of NA will use the MLE estimate of
<code class="reqn">\beta</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_gamma.start">gamma.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\gamma</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of gammas.  The default value of of NA will use the MLE estimate of
<code class="reqn">\gamma</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the gammas.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix.  A user should
provide a square matrix with dimension equal to the number of states.  By
default, draws from the <code>Beta(0.9, 0.1)</code> are used to construct a proper
transition matrix for each raw except the last raw.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, and <code>Chib95</code> in which case the method of Chib (1995) is
used.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_gamma.fixed">gamma.fixed</code></td>
<td>
<p>1 if users want to constrain <code class="reqn">\gamma</code> values
to be constant. By default, <code class="reqn">\gamma</code> values are allowed to vary
across regimes.</p>
</td></tr>
<tr><td><code id="MCMCoprobitChange_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCoprobitChange</code> simulates from the posterior distribution of an
ordinal probit regression model with multiple parameter breaks. The
simulation of latent states is based on the linear approximation method
discussed in Park (2011).
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">\Pr(y_t = 1) = \Phi(\gamma_{c, m} - x_i'\beta_m) - \Phi(\gamma_{c-1, m} - x_i'\beta_m)\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states, and <code class="reqn">\gamma_{c, m}</code> and
<code class="reqn">\beta_m</code> are paramters when a state is <code class="reqn">m</code> at <code class="reqn">t</code>.
</p>
<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, M</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>
<p>Note that when the fitted changepoint model has very few observations in any
of states, the marginal likelihood outcome can be &ldquo;nan,&quot; which indicates
that too many breaks are assumed given the model and data.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.  The object
contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period, the log-likelihood of
the model (<code>loglike</code>), and the log-marginal likelihood of the model
(<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park. 2011. &ldquo;Changepoint Analysis of Binary and
Ordinal Probit Models: An Application to Bank Rate Policy Under the Interwar
Gold Standard.&quot;  <em>Political Analysis</em>. 19: 188-204. &lt;doi:10.1093/pan/mpr007&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Siddhartha Chib. 1998. &ldquo;Estimation and comparison of multiple change-point
models.&rdquo; <em>Journal of Econometrics</em>. 86: 221-241.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotState">plotState</a></code>, <code><a href="#topic+plotChangepoint">plotChangepoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1909)
N &lt;- 200
x1 &lt;- rnorm(N, 1, .5);

## set a true break at 100
z1 &lt;- 1 + x1[1:100] + rnorm(100);
z2 &lt;- 1 -0.2*x1[101:200] + rnorm(100);
z &lt;- c(z1,  z2);
y &lt;- z

## generate y
y[z &lt; 1] &lt;- 1;
y[z &gt;= 1 &amp; z &lt; 2] &lt;- 2;
y[z &gt;= 2] &lt;- 3;

## inputs
formula &lt;- y ~ x1

## fit multiple models with a varying number of breaks
out1 &lt;- MCMCoprobitChange(formula, m=1,
      	mcmc=100, burnin=100, thin=1, tune=c(.5, .5), verbose=100,
     	b0=0, B0=0.1, marginal.likelihood = "Chib95")
out2 &lt;- MCMCoprobitChange(formula, m=2,
      	mcmc=100, burnin=100, thin=1, tune=c(.5, .5, .5), verbose=100,
     	b0=0, B0=0.1, marginal.likelihood = "Chib95")

## Do model comparison
## NOTE: the chain should be run longer than this example!
BayesFactor(out1, out2)

## draw plots using the "right" model
plotState(out1)
plotChangepoint(out1)

</code></pre>

<hr>
<h2 id='MCMCordfactanal'>Markov Chain Monte Carlo for Ordinal Data Factor Analysis Model</h2><span id='topic+MCMCordfactanal'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of an
ordinal data factor analysis model. Normal priors are assumed on the factor
loadings and factor scores while improper uniform priors are assumed on the
cutpoints. The user supplies data and parameters for the prior
distributions, and a sample from the posterior distribution is returned as
an mcmc object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCordfactanal(
  x,
  factors,
  lambda.constraints = list(),
  data = parent.frame(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  tune = NA,
  verbose = 0,
  seed = NA,
  lambda.start = NA,
  l0 = 0,
  L0 = 0,
  store.lambda = TRUE,
  store.scores = FALSE,
  drop.constantvars = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCordfactanal_+3A_x">x</code></td>
<td>
<p>Either a formula or a numeric matrix containing the manifest
variables.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_factors">factors</code></td>
<td>
<p>The number of factors to be fitted.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_lambda.constraints">lambda.constraints</code></td>
<td>
<p>List of lists specifying possible equality or
simple inequality constraints on the factor loadings. A typical entry in the
list has one of three forms: <code>varname=list(d,c)</code> which will constrain
the dth loading for the variable named varname to be equal to c,
<code>varname=list(d,"+")</code> which will constrain the dth loading for the
variable named varname to be positive, and <code>varname=list(d, "-")</code> which
will constrain the dth loading for the variable named varname to be
negative. If x is a matrix without column names defaults names of &ldquo;V1&quot;,
&ldquo;V2&quot;, ... , etc will be used. Note that, unlike <code>MCMCfactanal</code>, the
<code class="reqn">\Lambda</code> matrix used here has <code>factors</code>+1 columns. The
first column of <code class="reqn">\Lambda</code> corresponds to negative item
difficulty parameters and should generally not be constrained.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_tune">tune</code></td>
<td>
<p>The tuning parameter for the Metropolis-Hastings sampling. Can
be either a scalar or a <code class="reqn">k</code>-vector. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number and the Metropolis-Hastings acceptance rate are printed to
the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_lambda.start">lambda.start</code></td>
<td>
<p>Starting values for the factor loading matrix Lambda. If
<code>lambda.start</code> is set to a scalar the starting value for all
unconstrained loadings will be set to that scalar. If <code>lambda.start</code> is
a matrix of the same dimensions as Lambda then the <code>lambda.start</code>
matrix is used as the starting values (except for equality-constrained
elements). If <code>lambda.start</code> is set to <code>NA</code> (the default) then
starting values for unconstrained elements in the first column of Lambda are
based on the observed response pattern, the remaining unconstrained elements
of Lambda are set to , and starting values for inequality constrained
elements are set to either 1.0 or -1.0 depending on the nature of the
constraints.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_l0">l0</code></td>
<td>
<p>The means of the independent Normal prior on the factor loadings.
Can be either a scalar or a matrix with the same dimensions as
<code>Lambda</code>.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_l0">L0</code></td>
<td>
<p>The precisions (inverse variances) of the independent Normal prior
on the factor loadings. Can be either a scalar or a matrix with the same
dimensions as <code>Lambda</code>.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_store.lambda">store.lambda</code></td>
<td>
<p>A switch that determines whether or not to store the
factor loadings for posterior analysis. By default, the factor loadings are
all stored.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_store.scores">store.scores</code></td>
<td>
<p>A switch that determines whether or not to store the
factor scores for posterior analysis.  <em>NOTE: This takes an enormous
amount of memory, so should only be used if the chain is thinned heavily, or
for applications with a small number of observations</em>.  By default, the
factor scores are not stored.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_drop.constantvars">drop.constantvars</code></td>
<td>
<p>A switch that determines whether or not manifest
variables that have no variation should be deleted before fitting the model.
Default = TRUE.</p>
</td></tr>
<tr><td><code id="MCMCordfactanal_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model takes the following form:
</p>
<p>Let <code class="reqn">i=1,\ldots,N</code> index observations and <code class="reqn">j=1,\ldots,K</code>
index response variables within an observation. The typical
observed variable <code class="reqn">x_{ij}</code> is ordinal with a total of <code class="reqn">C_j</code>
categories. The distribution of <code class="reqn">X</code> is governed by a <code class="reqn">N
\times K</code> matrix of latent variables <code class="reqn">X^*</code> and a series of
cutpoints <code class="reqn">\gamma</code>.  <code class="reqn">X^*</code> is assumed to be generated
according to:
</p>
<p style="text-align: center;"><code class="reqn">x^*_i = \Lambda \phi_i + \epsilon_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_i \sim \mathcal{N}(0,I)</code>
</p>

<p>where <code class="reqn">x^*_i</code> is the <code class="reqn">k</code>-vector of latent variables
specific to observation <code class="reqn">i</code>, <code class="reqn">\Lambda</code> is the <code class="reqn">k \times
d</code> matrix of factor loadings, and <code class="reqn">\phi_i</code> is the
<code class="reqn">d</code>-vector of latent factor scores. It is assumed that the
first element of <code class="reqn">\phi_i</code> is equal to 1 for all <code class="reqn">i</code>.
</p>
<p>The probability that the <code class="reqn">j</code>th variable in observation <code class="reqn">i</code>
takes the value <code class="reqn">c</code> is:
</p>
<p style="text-align: center;"><code class="reqn">\pi_{ijc} = \Phi(\gamma_{jc} - \Lambda'_j\phi_i) - \Phi(\gamma_{j(c-1)} - \Lambda'_j\phi_i) </code>
</p>

<p>The implementation used here assumes independent conjugate priors
for each element of <code class="reqn">\Lambda</code> and each <code class="reqn">\phi_i</code>. More
specifically we assume:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_{ij} \sim \mathcal{N}(l_{0_{ij}}, L_{0_{ij}}^{-1}),
i=1,\ldots,k, j=1,\ldots,d</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_{i(2:d)} \sim \mathcal{N}(0, I), i=1,\dots,n</code>
</p>

<p>The standard two-parameter item response theory model with probit link is a
special case of the model sketched above.
</p>
<p><code>MCMCordfactanal</code> simulates from the posterior distribution using a
Metropolis-Hastings within Gibbs sampling algorithm. The algorithm employed
is based on work by Cowles (1996).  Note that the first element of
<code class="reqn">\phi_i</code> is a 1. As a result, the first column of
<code class="reqn">\Lambda</code> can be interpretated as item difficulty parameters.
Further, the first element <code class="reqn">\gamma_1</code> is normalized to zero,
and thus not returned in the mcmc object.  The simulation proper is done in
compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the scores.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Shawn Treier and Simon Jackman. 2008. &ldquo;Democracy as a Latent
Variable.&quot;  <em>American Journal of Political Science</em>. 52: 201-217.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>M. K. Cowles. 1996. &ldquo;Accelerating Monte Carlo Markov Chain Convergence for
Cumulative-link Generalized Linear Models.&quot; <em>Statistics and Computing.</em>
6: 101-110.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. &ldquo;Ordinal Data Modeling.&quot;
Springer: New York.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+factanal">factanal</a></code>, <code><a href="#topic+MCMCfactanal">MCMCfactanal</a></code>,
<code><a href="#topic+MCMCirt1d">MCMCirt1d</a></code>, <code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   data(painters)
   new.painters &lt;- painters[,1:4]
   cuts &lt;- apply(new.painters, 2, quantile, c(.25, .50, .75))
   for (i in 1:4){
      new.painters[new.painters[,i]&lt;cuts[1,i],i] &lt;- 100
     new.painters[new.painters[,i]&lt;cuts[2,i],i] &lt;- 200
     new.painters[new.painters[,i]&lt;cuts[3,i],i] &lt;- 300
     new.painters[new.painters[,i]&lt;100,i] &lt;- 400
   }

   posterior &lt;- MCMCordfactanal(~Composition+Drawing+Colour+Expression,
                        data=new.painters, factors=1,
                        lambda.constraints=list(Drawing=list(2,"+")),
                        burnin=5000, mcmc=500000, thin=200, verbose=500,
                        L0=0.5, store.lambda=TRUE,
                        store.scores=TRUE, tune=1.2)
   plot(posterior)
   summary(posterior)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCpaircompare'>Markov Chain Monte Carlo for a Pairwise Comparisons Model with Probit Link</h2><span id='topic+MCMCpaircompare'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
model for pairwise comparisons data with a probit link. Thurstone's model
is a special case of this model when the <code class="reqn">\alpha</code> parameter is fixed at
1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCpaircompare(
  pwc.data,
  theta.constraints = list(),
  alpha.fixed = FALSE,
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  alpha.start = NA,
  a = 0,
  A = 0.25,
  store.theta = TRUE,
  store.alpha = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCpaircompare_+3A_pwc.data">pwc.data</code></td>
<td>
<p>A data.frame containing the pairwise comparisons data.
Each row of <code>pwc.data</code> corresponds to a single pairwise comparison.
<code>pwc.data</code> needs to have exactly four columns. The first column
contains a unique identifier for the rater. Column two contains the unique
identifier for the first item being compared. Column three contains the
unique identifier for the second item being compared. Column four contains
the unique identifier of the item selected from the two items being
compared. If a tie occurred, the entry in the fourth column should be NA.
For applications without raters (such as sports competitions) all entries
in the first column should be set to a single value and <code>alpha.fixed</code>
(see below) should be set to <code>TRUE</code>. <strong>The identifiers in
columns 2 through 4 must start with a letter. Examples are provided below.</strong></p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_theta.constraints">theta.constraints</code></td>
<td>
<p>A list specifying possible simple equality or
inequality constraints on the item parameters. A typical entry in the
list has one of three forms: <code>itemname=c</code> which will constrain the
item parameter for the item named <code>itemname</code> to be equal to c,
<code>itemname="+"</code> which will constrain the item parameter for the
item named <code>itemname</code> to be positive, and <code>itemname="-"</code> which
will constrain the item parameter for the item named <code>itemname</code> to
be negative.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_alpha.fixed">alpha.fixed</code></td>
<td>
<p>Should alpha be fixed to a constant value of 1 for all
raters? Default is FALSE. If set to FALSE, an alpha value is estimated for
each rater.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0
output is printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_alpha.start">alpha.start</code></td>
<td>
<p>The starting value for the alpha vector.  This
can either be a scalar or a column vector with dimension equal to the number
of alphas.  If this takes a scalar value, then that value will serve as the
starting value for all of the alphas. The default value of NA will set the
starting value of each alpha parameter to 1.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_a">a</code></td>
<td>
<p>The prior mean of alpha. Must be a scalar. Default is 0.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_a">A</code></td>
<td>
<p>The prior precision of alpha. Must be a positive scalar.
Default is 0.25 (prior variance is 4).</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_store.theta">store.theta</code></td>
<td>
<p>Should the theta draws be returned? Default is TRUE.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_store.alpha">store.alpha</code></td>
<td>
<p>Should the alpha draws be returned? Default is FALSE.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCpaircompare</code> uses the data augmentation approach of Albert and
Chib (1993). The user supplies data and priors, and a sample from the
posterior is returned as an <code>mcmc</code> object, which can be subsequently
analyzed in the <code>coda</code> package.
</p>
<p>The simulation is done in compiled C++ code to maximize efficiency.
</p>
<p>Please consult the <code>coda</code> package documentation for a comprehensive
list of functions that can be used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">i = 1,...,I \ \ \ \   (raters) </code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1,...,J \ \ \ \   (items)  </code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 1 \ \  if  \ \  i \ \  chooses \ \  j \ \ over \ \ j'</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 0 \ \ if \ \ i \ \ chooses \ \ j' \ \ over \ \ j</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = NA \ \  if \ \ i \ \ chooses \ \ neither</code>
</p>

<p style="text-align: center;"><code class="reqn">Pr(Y_{ijj'} = 1) = \Phi( \alpha_{i} [\theta_{j} - \theta_{ j'} ] ) </code>
</p>

<p>The following Gaussian priors are assumed:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_i \sim \mathcal{N}(a, A^{-1})</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_j \sim \mathcal{N}(0, 1)</code>
</p>

<p>For identification, some <code class="reqn">\theta_j</code>s are truncated above or below 0,
or fixed to constants.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Albert, J. H. and S. Chib. 1993. &ldquo;Bayesian Analysis of Binary
and Polychotomous Response Data.&rdquo; <em>J. Amer. Statist. Assoc.</em> 88,
669-679
</p>
<p>Yu, Qiushi and Kevin M. Quinn. 2021. &ldquo;A Multidimensional Pairwise
Comparison Model for Heterogeneous Perception with an Application to
Modeling the Perceived Truthfulness of Public Statements on COVID-19.&rdquo;
University of Michigan Working Paper.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21. <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCpaircompare2d">MCMCpaircompare2d</a></code>,
<code><a href="#topic+MCMCpaircompare2dDP">MCMCpaircompare2dDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  ## Euro 2016 example
  data(Euro2016)

posterior1 &lt;- MCMCpaircompare(pwc.data=Euro2016,
                              theta.constraints=list(Ukraine="-",
                                                     Portugal="+"),
                              alpha.fixed=TRUE,
                              verbose=10000,
                              burnin=10000, mcmc=500000, thin=100,
                              store.theta=TRUE, store.alpha=FALSE)

## alternative identification constraints
posterior2 &lt;- MCMCpaircompare(pwc.data=Euro2016,
                              theta.constraints=list(Ukraine="-",
                                                     Portugal=1),
                              alpha.fixed=TRUE,
                              verbose=10000,
                              burnin=10000, mcmc=500000, thin=100,
                              store.theta=TRUE, store.alpha=FALSE)








## a synthetic data example with estimated rater-specific parameters
set.seed(123)

I &lt;- 65  ## number of raters
J &lt;- 50 ## number of items to be compared


## raters 1 to 5 have less sensitivity to stimuli than raters 6 through I
alpha.true &lt;- c(rnorm(5, m=0.2, s=0.05), rnorm(I - 5, m=1, s=0.1))
theta.true &lt;- sort(rnorm(J, m=0, s=1))

n.comparisons &lt;- 125 ## number of pairwise comparisons for each rater

## generate synthetic data according to the assumed model
rater.id &lt;- NULL
item.1.id &lt;- NULL
item.2.id &lt;- NULL
choice.id &lt;- NULL
for (i in 1:I){
    for (c in 1:n.comparisons){
        rater.id &lt;- c(rater.id, i+100)
        item.numbers &lt;- sample(1:J, size=2, replace=FALSE)
        item.1 &lt;- item.numbers[1]
        item.2 &lt;- item.numbers[2]
        item.1.id &lt;- c(item.1.id, item.1)
        item.2.id &lt;- c(item.2.id, item.2)
        eta &lt;- alpha.true[i] * (theta.true[item.1] - theta.true[item.2])
        prob.item.1.chosen &lt;- pnorm(eta)
        u &lt;- runif(1)
        if (u &lt;= prob.item.1.chosen){
            choice.id &lt;- c(choice.id, item.1)
        }
        else{
            choice.id &lt;- c(choice.id, item.2)
        }
    }
}
item.1.id &lt;- paste("item", item.1.id+100, sep=".")
item.2.id &lt;- paste("item", item.2.id+100, sep=".")
choice.id &lt;- paste("item", choice.id+100, sep=".")

sim.data &lt;- data.frame(rater.id, item.1.id, item.2.id, choice.id)


## fit the model
posterior &lt;- MCMCpaircompare(pwc.data=sim.data,
                             theta.constraints=list(item.101=-2,
                                                    item.150=2),
                             alpha.fixed=FALSE,
                             verbose=10000,
                             a=0, A=0.5,
                             burnin=10000, mcmc=200000, thin=100,
                             store.theta=TRUE, store.alpha=TRUE)

theta.draws &lt;- posterior[, grep("theta", colnames(posterior))]
alpha.draws &lt;- posterior[, grep("alpha", colnames(posterior))]

theta.post.med &lt;- apply(theta.draws, 2, median)
alpha.post.med &lt;- apply(alpha.draws, 2, median)

theta.post.025 &lt;- apply(theta.draws, 2, quantile, prob=0.025)
theta.post.975 &lt;- apply(theta.draws, 2, quantile, prob=0.975)
alpha.post.025 &lt;- apply(alpha.draws, 2, quantile, prob=0.025)
alpha.post.975 &lt;- apply(alpha.draws, 2, quantile, prob=0.975)

## compare estimates to truth
par(mfrow=c(1,2))
plot(theta.true, theta.post.med, xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
segments(x0=theta.true, x1=theta.true,
         y0=theta.post.025, y1=theta.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))

plot(alpha.true, alpha.post.med, xlim=c(0, 1.2), ylim=c(0, 3),
     col=rgb(0,0,0,0.3))
segments(x0=alpha.true, x1=alpha.true,
         y0=alpha.post.025, y1=alpha.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))


## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCpaircompare2d'>Markov Chain Monte Carlo for the Two-Dimensional Pairwise Comparisons
Model in Yu and Quinn (2021)</h2><span id='topic+MCMCpaircompare2d'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
model for pairwise comparisons data with a probit link. Unlike standard
models for pairwise comparisons data, in this model the latent attribute
of each item being compared is a vector in two-dimensional Euclidean space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCpaircompare2d(
  pwc.data,
  theta.constraints = list(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  gamma.start = NA,
  theta.start = NA,
  store.theta = TRUE,
  store.gamma = TRUE,
  tune = 0.3,
  procrustes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCpaircompare2d_+3A_pwc.data">pwc.data</code></td>
<td>
<p>A data.frame containing the pairwise comparisons data.
Each row of <code>pwc.data</code> corresponds to a single pairwise comparison.
<code>pwc.data</code> needs to have exactly four columns. The first column
contains a unique identifier for the rater. Column two contains the unique
identifier for the first item being compared. Column three contains the
unique identifier for the second item being compared. Column four contains
the unique identifier of the item selected from the two items being
compared. If a tie occurred, the entry in the fourth column should be NA.
<strong>The identifiers in columns 2 through 4 must start with a letter.
Examples are provided below.</strong></p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_theta.constraints">theta.constraints</code></td>
<td>
<p>A list specifying possible simple equality or
inequality constraints on the item parameters. A
typical entry in the list has one of three forms:
<code>itemname=list(d,c)</code> which will constrain the dth dimension of
theta for the item named <code>itemname</code> to be equal to c,
<code>itemname=list(d,"+")</code> which will constrain the dth dimension of
theta for the item named <code>itemname</code> to be positive, and
<code>itemname=list(d, "-")</code> which will constrain the dth dimension of
theta for the item named <code>itemname</code> to be negative.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 
output is printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_gamma.start">gamma.start</code></td>
<td>
<p>The starting value for the gamma vector.  This
can either be a scalar or a column vector with dimension equal to the number
of raters.  If this takes a scalar value, then that value will serve as the
starting value for all of the gammas. The default value of NA will set the
starting value of each gamma parameter to <code class="reqn">\pi/4</code>.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_theta.start">theta.start</code></td>
<td>
<p>Starting values for the theta. Can be either a numeric
scalar, a J by 2 matrix (where J is the number of items compared), or NA.
If a scalar, all theta values are set to that value (except elements already
specified via theta.contraints. If NA, then non constrained elements of
theta are set equal to 0, elements constrained to be positive are set equal
to 0.5, elements constrained to be negative are set equal to -0.5 and
elements with equality constraints are set to satisfy those constraints.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_store.theta">store.theta</code></td>
<td>
<p>Should the theta draws be returned? Default is TRUE.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_store.gamma">store.gamma</code></td>
<td>
<p>Should the gamma draws be returned? Default is TRUE.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_tune">tune</code></td>
<td>
<p>Tuning parameter for the random walk Metropolis proposal for
each gamma_i. <code>tune</code> is the width of the uniform proposal centered at
the current value of gamma_i. Must be a positive scalar.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_procrustes">procrustes</code></td>
<td>
<p>Should the theta and gamma draws be post-processed with
a Procrustes transformation? Default is FALSE. The Procrustes target matrix
is derived from the constrained elements of theta. Each row of theta that
has both theta values constrained is part of the of the target matrix.
Elements with equality constraints are set to those values. Elements
constrained to be positive are set to 1. Elements constrained to be negative
are set to -1. If <code>procrustes</code> is set to <code>TRUE</code> theta.constraints
must be set so that there are at least three rows of theta that have both
elements of theta constrained.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2d_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCpaircompare2d</code> uses the data augmentation approach of Albert and
Chib (1993) in conjunction with Gibbs and Metropolis-within-Gibbs steps
to fit the model. The user supplies data and a sample from the
posterior is returned as an <code>mcmc</code> object, which can be subsequently
analyzed in the <code>coda</code> package.
</p>
<p>The simulation is done in compiled C++ code to maximize efficiency.
</p>
<p>Please consult the <code>coda</code> package documentation for a comprehensive
list of functions that can be used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">i = 1,...,I \ \ \ \   (raters) </code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1,...,J \ \ \ \   (items)  </code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 1 \ \  if  \ \  i \ \  chooses \ \  j \ \ over \ \ j'</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 0 \ \ if \ \ i \ \ chooses \ \ j' \ \ over \ \ j</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = NA \ \  if \ \ i \ \ chooses \ \ neither</code>
</p>

<p style="text-align: center;"><code class="reqn">\Pr(Y_{ijj'} = 1) = \Phi( \mathbf{z}_{i}' [\boldsymbol{\theta}_{j} -
\boldsymbol{\theta}_{ j'} ])</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{z}_{i}=[\cos(\gamma_{i}), \  \sin(\gamma_{i})]' </code>
</p>

<p>The following priors are assumed:
</p>
<p style="text-align: center;"><code class="reqn">\gamma_i \sim \mathcal{U}nif(0, \  \pi/2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\theta}_j \sim
\mathcal{N}_{2}(\mathbf{0}, \mathbf{I}_{2})</code>
</p>

<p>For identification, some <code class="reqn">\boldsymbol{\theta}_j</code>s are truncated
above or below 0, or fixed to constants.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>Author(s)</h3>

<p>Qiushi Yu &lt;yuqiushi@umich.edu&gt; and
Kevin M. Quinn &lt;kmq@umich.edu&gt;
</p>


<h3>References</h3>

<p>Albert, J. H. and S. Chib. 1993. &ldquo;Bayesian Analysis of Binary
and Polychotomous Response Data.&rdquo; <em>J. Amer. Statist. Assoc.</em> 88,
669-679
</p>
<p>Yu, Qiushi and Kevin M. Quinn. 2021. &ldquo;A Multidimensional Pairwise
Comparison Model for Heterogeneous Perceptions with an Application to
Modeling the Perceived Truthfulness of Public Statements on COVID-19.&rdquo;
University of Michigan Working Paper.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCpaircompare">MCMCpaircompare</a></code>,
<code><a href="#topic+MCMCpaircompare2dDP">MCMCpaircompare2dDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
## a synthetic data example
set.seed(123)

I &lt;- 65  ## number of raters
J &lt;- 50 ## number of items to be compared


## raters 1 to 5 put most weight on dimension 1
## raters 6 to 10 put most weight on dimension 2
## raters 11 to I put substantial weight on both dimensions
gamma.true &lt;- c(runif(5, 0, 0.1),
             runif(5, 1.47, 1.57),
             runif(I-10, 0.58, 0.98) )
theta1.true &lt;- rnorm(J, m=0, s=1)
theta2.true &lt;- rnorm(J, m=0, s=1)
theta1.true[1] &lt;- 2
theta2.true[1] &lt;- 2
theta1.true[2] &lt;- -2
theta2.true[2] &lt;- -2
theta1.true[3] &lt;-  2
theta2.true[3] &lt;- -2



n.comparisons &lt;- 125 ## number of pairwise comparisons for each rater

## generate synthetic data according to the assumed model
rater.id &lt;- NULL
item.1.id &lt;- NULL
item.2.id &lt;- NULL
choice.id &lt;- NULL
for (i in 1:I){
    for (c in 1:n.comparisons){
        rater.id &lt;- c(rater.id, i+100)
        item.numbers &lt;- sample(1:J, size=2, replace=FALSE)
        item.1 &lt;- item.numbers[1]
        item.2 &lt;- item.numbers[2]
        item.1.id &lt;- c(item.1.id, item.1)
        item.2.id &lt;- c(item.2.id, item.2)
        z &lt;- c(cos(gamma.true[i]), sin(gamma.true[i]))
        eta &lt;- z[1] * (theta1.true[item.1] - theta1.true[item.2])  +
            z[2] * (theta2.true[item.1] - theta2.true[item.2])
        prob.item.1.chosen &lt;- pnorm(eta)
        u &lt;- runif(1)
        if (u &lt;= prob.item.1.chosen){
            choice.id &lt;- c(choice.id, item.1)
        }
        else{
            choice.id &lt;- c(choice.id, item.2)
        }
    }
}
item.1.id &lt;- paste("item", item.1.id+100, sep=".")
item.2.id &lt;- paste("item", item.2.id+100, sep=".")
choice.id &lt;- paste("item", choice.id+100, sep=".")

sim.data &lt;- data.frame(rater.id, item.1.id, item.2.id, choice.id)


## fit the model
posterior &lt;- MCMCpaircompare2d(pwc.data=sim.data,
                             theta.constraints=list(item.101=list(1,2),
                                                    item.101=list(2,2),
                                                    item.102=list(1,-2),
                                                    item.102=list(2,-2),
                                                    item.103=list(1,"+"),
                                                    item.103=list(2,"-")),
                             verbose=1000,
                             burnin=500, mcmc=20000, thin=10,
                             store.theta=TRUE, store.gamma=TRUE, tune=0.5)





theta1.draws &lt;- posterior[, grep("theta1", colnames(posterior))]
theta2.draws &lt;- posterior[, grep("theta2", colnames(posterior))]
gamma.draws &lt;- posterior[, grep("gamma", colnames(posterior))]

theta1.post.med &lt;- apply(theta1.draws, 2, median)
theta2.post.med &lt;- apply(theta2.draws, 2, median)
gamma.post.med &lt;- apply(gamma.draws, 2, median)

theta1.post.025 &lt;- apply(theta1.draws, 2, quantile, prob=0.025)
theta1.post.975 &lt;- apply(theta1.draws, 2, quantile, prob=0.975)
theta2.post.025 &lt;- apply(theta2.draws, 2, quantile, prob=0.025)
theta2.post.975 &lt;- apply(theta2.draws, 2, quantile, prob=0.975)
gamma.post.025 &lt;- apply(gamma.draws, 2, quantile, prob=0.025)
gamma.post.975 &lt;- apply(gamma.draws, 2, quantile, prob=0.975)



## compare estimates to truth
par(mfrow=c(2,2))
plot(theta1.true, theta1.post.med, xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
segments(x0=theta1.true, x1=theta1.true,
         y0=theta1.post.025, y1=theta1.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))

plot(theta2.true, theta2.post.med, xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
segments(x0=theta2.true, x1=theta2.true,
         y0=theta2.post.025, y1=theta2.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))

plot(gamma.true, gamma.post.med, xlim=c(0, 1.6), ylim=c(0, 1.6),
     col=rgb(0,0,0,0.3))
segments(x0=gamma.true, x1=gamma.true,
         y0=gamma.post.025, y1=gamma.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))


## plot point estimates 
plot(theta1.post.med, theta2.post.med,
     xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
for (i in 1:length(gamma.post.med)){
    arrows(x0=0, y0=0,
           x1=cos(gamma.post.med[i]),
           y1=sin(gamma.post.med[i]),
           col=rgb(1,0,0,0.2), len=0.05, lwd=0.5)
}

## End(Not run) 
</code></pre>

<hr>
<h2 id='MCMCpaircompare2dDP'>Markov Chain Monte Carlo for the Two-Dimensional Pairwise Comparisons
Model with Dirichlet Process Prior in Yu and Quinn (2021)</h2><span id='topic+MCMCpaircompare2dDP'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
model for pairwise comparisons data with a probit link. Unlike standard
models for pairwise comparisons data, in this model the latent attribute
of each item being compared is a vector in two-dimensional Euclidean space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCpaircompare2dDP(
  pwc.data,
  theta.constraints = list(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  gamma.start = NA,
  theta.start = NA,
  store.theta = TRUE,
  store.gamma = FALSE,
  tune = 0.3,
  procrustes = FALSE,
  alpha.start = 1,
  cluster.max = 100,
  cluster.mcmc = 500,
  alpha.fixed = TRUE,
  a0 = 1,
  b0 = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCpaircompare2dDP_+3A_pwc.data">pwc.data</code></td>
<td>
<p>A data.frame containing the pairwise comparisons data.
Each row of <code>pwc.data</code> corresponds to a single pairwise comparison.
<code>pwc.data</code> needs to have exactly four columns. The first column
contains a unique identifier for the rater. Column two contains the unique
identifier for the first item being compared. Column three contains the
unique identifier for the second item being compared. Column four contains
the unique identifier of the item selected from the two items being
compared. If a tie occurred, the entry in the fourth column should be NA.
<strong>The identifiers in columns 2 through 4 must start with a letter.
Examples are provided below.</strong></p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_theta.constraints">theta.constraints</code></td>
<td>
<p>A list specifying possible simple equality or
inequality constraints on the item parameters. A
typical entry in the list has one of three forms:
<code>itemname=list(d,c)</code> which will constrain the dth dimension of
theta for the item named <code>itemname</code> to be equal to c,
<code>itemname=list(d,"+")</code> which will constrain the dth dimension of
theta for the item named <code>itemname</code> to be positive, and
<code>itemname=list(d, "-")</code> which will constrain the dth dimension of
theta for the item named <code>itemname</code> to be negative.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 
output is printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_gamma.start">gamma.start</code></td>
<td>
<p>The starting value for the gamma vector.  This
can either be a scalar or a column vector with dimension equal to the number
of raters.  If this takes a scalar value, then that value will serve as the
starting value for all of the gammas. The default value of NA will set the
starting value of each gamma parameter to <code class="reqn">\pi/4</code>.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_theta.start">theta.start</code></td>
<td>
<p>Starting values for the theta. Can be either a numeric
scalar, a J by 2 matrix (where J is the number of items compared), or NA.
If a scalar, all theta values are set to that value (except elements already
specified via theta.contraints. If NA, then non constrained elements of
theta are set equal to 0, elements constrained to be positive are set equal
to 0.5, elements constrained to be negative are set equal to -0.5 and
elements with equality constraints are set to satisfy those constraints.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_store.theta">store.theta</code></td>
<td>
<p>Should the theta draws be returned? Default is TRUE.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_store.gamma">store.gamma</code></td>
<td>
<p>Should the gamma draws be returned? Default is TRUE.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_tune">tune</code></td>
<td>
<p>Tuning parameter for the random walk Metropolis proposal for
each gamma_i. <code>tune</code> is the width of the uniform proposal centered at
the current value of gamma_i. Must be a positive scalar.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_procrustes">procrustes</code></td>
<td>
<p>Should the theta and gamma draws be post-processed with
a Procrustes transformation? Default is FALSE. The Procrustes target matrix
is derived from the constrained elements of theta. Each row of theta that
has both theta values constrained is part of the of the target matrix.
Elements with equality constraints are set to those values. Elements
constrained to be positive are set to 1. Elements constrained to be negative
are set to -1. If <code>procrustes</code> is set to <code>TRUE</code> theta.constraints
must be set so that there are at least three rows of theta that have both
elements of theta constrained.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_alpha.start">alpha.start</code></td>
<td>
<p>The starting value for the DP concentration parameter
alpha. Must be a positive scalar. Defaults to 1. If <code>alpha.fixed</code> is
set equal to TRUE, then alpha is held fixed at alpha.start.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_cluster.max">cluster.max</code></td>
<td>
<p>The maximum number of clusters allowed in the
approximation to the DP prior for gamma. Defaults to 100. Must be a
positive integer.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_cluster.mcmc">cluster.mcmc</code></td>
<td>
<p>The number of additional MCMC iterations that are done
to sample each cluster-specific gamma value within one main MCMC iteration.
Must be a positive integer. Defaults to 500. Setting this to a lower value
speeds runtime at the cost of (possibly) worse mixing.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_alpha.fixed">alpha.fixed</code></td>
<td>
<p>Logical value indicating whether the DP concentration
parameter alpha be held fixed (<code>TRUE</code>) or estimated (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_a0">a0</code></td>
<td>
<p>The shape parameter of the gamma prior for alpha. This is the
same parameterization of the gamma distribution as R's internal
<code>rgamma()</code> function. Only relevant if <code>alpha.fixed</code> is set equal
to <code>FALSE</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_b0">b0</code></td>
<td>
<p>The rate parameter of the gamma prior for alpha.  This is the
same parameterization of the gamma distribution as R's internal
<code>rgamma()</code> function. Only relevant if <code>alpha.fixed</code> is set equal
to <code>FALSE</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="MCMCpaircompare2dDP_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCpaircompare2d</code> uses the data augmentation approach of Albert and
Chib (1993) in conjunction with Gibbs and Metropolis-within-Gibbs steps
to fit the model. The user supplies data and a sample from the
posterior is returned as an <code>mcmc</code> object, which can be subsequently
analyzed in the <code>coda</code> package.
</p>
<p>The simulation is done in compiled C++ code to maximize efficiency.
</p>
<p>Please consult the <code>coda</code> package documentation for a comprehensive
list of functions that can be used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">i = 1,...,I \ \ \ \   (raters) </code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1,...,J \ \ \ \   (items)  </code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 1 \ \  if  \ \  i \ \  chooses \ \  j \ \ over \ \ j'</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 0 \ \ if \ \ i \ \ chooses \ \ j' \ \ over \ \ j</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = NA \ \  if \ \ i \ \ chooses \ \ neither</code>
</p>

<p style="text-align: center;"><code class="reqn">\Pr(Y_{ijj'} = 1) = \Phi( \mathbf{z}_{i}' [\boldsymbol{\theta}_{j} -
\boldsymbol{\theta}_{ j'} ])</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{z}_{i}=[\cos(\gamma_{i}), \  \sin(\gamma_{i})]' </code>
</p>

<p>The following priors are assumed:
</p>
<p style="text-align: center;"><code class="reqn">\gamma_i \sim G</code>
</p>

<p style="text-align: center;"><code class="reqn">G \sim \mathcal{DP}(\alpha G_0)</code>
</p>

<p style="text-align: center;"><code class="reqn">G_0 = \mathcal{U}nif(0,   \pi/2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha \sim \mathcal{G}amma(a_0, b_0)</code>
</p>
 
<p style="text-align: center;"><code class="reqn">\boldsymbol{\theta}_j \sim
\mathcal{N}_{2}(\mathbf{0}, \mathbf{I}_{2})</code>
</p>

<p>For identification, some <code class="reqn">\boldsymbol{\theta}_j</code>s are truncated
above or below 0, or fixed to constants.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package. Most of the column
names of the mcmc object are self explanatory. Note however that the columns
with names of the form &quot;cluster.[raterID]&quot; give the cluster membership of
each rater at each stored MCMC iteration. Because of the possibility of
label switching, the particular values of these cluster membership variables
are not meaningful. What is meaningful is whether two raters share the same
cluster membership value at a particular MCMC iteration. This indicates
that those two raters were clustered together during that iteration.
Finally, note that the &quot;n.clusters&quot; column gives the number of distinct
gamma values at each iteration, i.e. the number of clusters at that
iteration.
</p>


<h3>Author(s)</h3>

<p>Qiushi Yu &lt;yuqiushi@umich.edu&gt; and
Kevin M. Quinn &lt;kmq@umich.edu&gt;
</p>


<h3>References</h3>

<p>Albert, J. H. and S. Chib. 1993. &ldquo;Bayesian Analysis of Binary
and Polychotomous Response Data.&rdquo; <em>J. Amer. Statist. Assoc.</em> 88,
669-679
</p>
<p>Yu, Qiushi and Kevin M. Quinn. 2021. &ldquo;A Multidimensional Pairwise
Comparison Model for Heterogeneous Perceptions with an Application to
Modeling the Perceived Truthfulness of Public Statements on COVID-19.&rdquo;
University of Michigan Working Paper.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+MCMCpaircompare">MCMCpaircompare</a></code>,
<code><a href="#topic+MCMCpaircompare2dDP">MCMCpaircompare2dDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## a synthetic data example
set.seed(123)

I &lt;- 65  ## number of raters
J &lt;- 50 ## number of items to be compared

## 3 clusters:
## raters 1 to 5 put most weight on dimension 1
## raters 6 to 10 put most weight on dimension 2
## raters 11 to I put substantial weight on both dimensions
gamma.true &lt;- c(rep(0.05, 5),
             rep(1.50, 5),
             rep(0.7, I-10) )
theta1.true &lt;- rnorm(J, m=0, s=1)
theta2.true &lt;- rnorm(J, m=0, s=1)
theta1.true[1] &lt;- 2
theta2.true[1] &lt;- 2
theta1.true[2] &lt;- -2
theta2.true[2] &lt;- -2
theta1.true[3] &lt;-  2
theta2.true[3] &lt;- -2



n.comparisons &lt;- 125 ## number of pairwise comparisons for each rater

## generate synthetic data according to the assumed model
rater.id &lt;- NULL
item.1.id &lt;- NULL
item.2.id &lt;- NULL
choice.id &lt;- NULL
for (i in 1:I){
    for (c in 1:n.comparisons){
        rater.id &lt;- c(rater.id, i+100)
        item.numbers &lt;- sample(1:J, size=2, replace=FALSE)
        item.1 &lt;- item.numbers[1]
        item.2 &lt;- item.numbers[2]
        item.1.id &lt;- c(item.1.id, item.1)
        item.2.id &lt;- c(item.2.id, item.2)
        z &lt;- c(cos(gamma.true[i]), sin(gamma.true[i]))
        eta &lt;- z[1] * (theta1.true[item.1] - theta1.true[item.2])  +
            z[2] * (theta2.true[item.1] - theta2.true[item.2])
        prob.item.1.chosen &lt;- pnorm(eta)
        u &lt;- runif(1)
        if (u &lt;= prob.item.1.chosen){
            choice.id &lt;- c(choice.id, item.1)
        }
        else{
            choice.id &lt;- c(choice.id, item.2)
        }
    }
}
item.1.id &lt;- paste("item", item.1.id+100, sep=".")
item.2.id &lt;- paste("item", item.2.id+100, sep=".")
choice.id &lt;- paste("item", choice.id+100, sep=".")

sim.data &lt;- data.frame(rater.id, item.1.id, item.2.id, choice.id)


## fit the model (should be run for more than 10500 iterations)
posterior &lt;- MCMCpaircompare2dDP(pwc.data=sim.data,
                                 theta.constraints=list(item.101=list(1,2),
                                                        item.101=list(2,2),
                                                        item.102=list(1,-2),
                                                        item.102=list(2,-2),
                                                        item.103=list(1,"+"),
                                                        item.103=list(2,"-")),
                                 verbose=100,
                                 burnin=500, mcmc=10000, thin=5,
                                 cluster.mcmc=10,
                                 store.theta=TRUE, store.gamma=TRUE,
                                 tune=0.1)





theta1.draws &lt;- posterior[, grep("theta1", colnames(posterior))]
theta2.draws &lt;- posterior[, grep("theta2", colnames(posterior))]
gamma.draws &lt;- posterior[, grep("gamma", colnames(posterior))]

theta1.post.med &lt;- apply(theta1.draws, 2, median)
theta2.post.med &lt;- apply(theta2.draws, 2, median)
gamma.post.med &lt;- apply(gamma.draws, 2, median)

theta1.post.025 &lt;- apply(theta1.draws, 2, quantile, prob=0.025)
theta1.post.975 &lt;- apply(theta1.draws, 2, quantile, prob=0.975)
theta2.post.025 &lt;- apply(theta2.draws, 2, quantile, prob=0.025)
theta2.post.975 &lt;- apply(theta2.draws, 2, quantile, prob=0.975)
gamma.post.025 &lt;- apply(gamma.draws, 2, quantile, prob=0.025)
gamma.post.975 &lt;- apply(gamma.draws, 2, quantile, prob=0.975)



## compare estimates to truth
par(mfrow=c(2,2))
plot(theta1.true, theta1.post.med, xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
segments(x0=theta1.true, x1=theta1.true,
         y0=theta1.post.025, y1=theta1.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))

plot(theta2.true, theta2.post.med, xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
segments(x0=theta2.true, x1=theta2.true,
         y0=theta2.post.025, y1=theta2.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))

plot(gamma.true, gamma.post.med, xlim=c(0, 1.6), ylim=c(0, 1.6),
     col=rgb(0,0,0,0.3))
segments(x0=gamma.true, x1=gamma.true,
         y0=gamma.post.025, y1=gamma.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))


## plot point estimates 
plot(theta1.post.med, theta2.post.med,
     xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
for (i in 1:length(gamma.post.med)){
    arrows(x0=0, y0=0,
           x1=cos(gamma.post.med[i]),
           y1=sin(gamma.post.med[i]),
           col=rgb(1,0,0,0.2), len=0.05, lwd=0.5)
}


## End(Not run)
</code></pre>

<hr>
<h2 id='MCMCpoisson'>Markov Chain Monte Carlo for Poisson Regression</h2><span id='topic+MCMCpoisson'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
Poisson regression model using a random walk Metropolis algorithm. The user
supplies data and priors, and a sample from the posterior distribution is
returned as an mcmc object, which can be subsequently analyzed with
functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCpoisson(
  formula,
  data = NULL,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  tune = 1.1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  marginal.likelihood = c("none", "Laplace"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCpoisson_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_tune">tune</code></td>
<td>
<p>Metropolis tuning parameter. Can be either a positive scalar or
a <code class="reqn">k</code>-vector, where <code class="reqn">k</code> is the length of
<code class="reqn">\beta</code>.Make sure that the acceptance rate is satisfactory
(typically between 0.20 and 0.5) before using the posterior sample for
inference.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\beta</code>. Default value of 0 is
equivalent to an improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated or <code>Laplace</code> in which case the Laplace approximation (see
Kass and Raftery, 1995) is used.</p>
</td></tr>
<tr><td><code id="MCMCpoisson_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCpoisson</code> simulates from the posterior distribution of a Poisson
regression model using a random walk Metropolis algorithm. The simulation
proper is done in compiled C++ code to maximize efficiency.  Please consult
the coda documentation for a comprehensive list of functions that can be
used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim \mathcal{P}oisson(\mu_i)</code>
</p>

<p>Where the inverse link
function:
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = \exp(x_i'\beta)</code>
</p>

<p>We assume a multivariate Normal prior on <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>The Metropois proposal distribution is centered at the current value of
<code class="reqn">\theta</code> and has variance-covariance <code class="reqn">V = T (B_0 + C^{-1})^{-1} T </code>
where <code class="reqn">T</code> is a the diagonal positive definite matrix formed from the
<code>tune</code>, <code class="reqn">B_0</code> is the prior precision, and <code class="reqn">C</code> is the
large sample variance-covariance matrix of the MLEs. This last calculation
is done via an initial call to <code>glm</code>.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   counts &lt;- c(18,17,15,20,10,20,25,13,12)
   outcome &lt;- gl(3,1,9)
   treatment &lt;- gl(3,3)
   posterior &lt;- MCMCpoisson(counts ~ outcome + treatment)
   plot(posterior)
   summary(posterior)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCpoissonChange'>Markov Chain Monte Carlo for a Poisson Regression Changepoint Model</h2><span id='topic+MCMCpoissonChange'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
Poisson regression model with multiple changepoints. The function uses the
Markov chain Monte Carlo method of Chib (1998).  The user supplies data and
priors, and a sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided in the
coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCpoissonChange(
  formula,
  data = parent.frame(),
  m = 1,
  b0 = 0,
  B0 = 1,
  a = NULL,
  b = NULL,
  c0 = NA,
  d0 = NA,
  lambda.mu = NA,
  lambda.var = NA,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCpoissonChange_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0</code> is the shape parameter for Gamma prior on
<code class="reqn">\lambda</code> (the mean). When there is no covariate, this should be
provided by users. No default value is provided.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0</code> is the scale parameter for Gamma prior on
<code class="reqn">\lambda</code> (the mean). When there is no covariate, this should be
provided by users. No default value is provided.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_lambda.mu">lambda.mu</code></td>
<td>
<p>The mean of the Gamma prior on <code class="reqn">\lambda</code>.
<code class="reqn">sigma.mu</code> and <code class="reqn">sigma.var</code> allow users to
choose the Gamma prior by choosing its mean and variance.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_lambda.var">lambda.var</code></td>
<td>
<p>The variacne of the Gamma prior on <code class="reqn">\lambda</code>.
<code class="reqn">sigma.mu</code> and <code class="reqn">sigma.var</code> allow users to
choose the Gamma prior by choosing its mean and variance.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burn-in.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0, the
iteration number and the posterior density samples are printed to the screen
every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, current R
system seed is used.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the beta vector. This can either
be a scalar or a column vector with dimension equal to the number of betas.
The default value of NA will use draws from the Uniform distribution with
the same boundary with the data as the starting value. If this is a scalar,
that value will serve as the starting value mean for all of the betas. When
there is no covariate, the log value of means should be used.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix. A user should
provide a square matrix with dimension equal to the number of states. By
default, draws from the <code>Beta(0.9, 0.1)</code> are used to construct a proper
transition matrix for each raw except the last raw.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, and <code>Chib95</code> in which case the method of Chib (1995) is
used.</p>
</td></tr>
<tr><td><code id="MCMCpoissonChange_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCpoissonChange</code> simulates from the posterior distribution of a
Poisson regression model with multiple changepoints using the methods of
Chib (1998) and Fruhwirth-Schnatter and Wagner (2006).  The details of the
model are discussed in Park (2010).
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_t \sim \mathcal{P}oisson(\mu_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = x_t ' \beta_m,\;\; m = 1, \ldots, M</code>
</p>

<p>Where
<code class="reqn">M</code> is the number of states and <code class="reqn">\beta_m</code> is paramters
when a state is <code class="reqn">m</code> at <code class="reqn">t</code>.
</p>
<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, M</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>
<p> Where <code class="reqn">M</code> is the number of states.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This object can
be summarized by functions provided by the coda package.  The object
contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period, and the log-marginal
likelihood of the model (<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park. 2010. &ldquo;Structural Change in the U.S. Presidents'
Use of Force Abroad.&rdquo; <em>American Journal of Political Science</em> 54:
766-782. &lt;doi:10.1111/j.1540-5907.2010.00459.x&gt;
</p>
<p>Sylvia Fruhwirth-Schnatter and Helga Wagner 2006. &ldquo;Auxiliary Mixture
Sampling for Parameter-driven Models of Time Series of Counts with
Applications to State Space Modelling.&rdquo; <em>Biometrika</em>. 93:827&ndash;841.
</p>
<p>Siddhartha Chib. 1998. &ldquo;Estimation and comparison of multiple change-point
models.&rdquo; <em>Journal of Econometrics</em>. 86: 221-241.
&lt;doi: 10.1016/S0304-4076(97)00115-2&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Siddhartha Chib. 1995. &ldquo;Marginal Likelihood from the Gibbs Output.&rdquo;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
&lt;doi: 10.1080/01621459.1995.10476635&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCbinaryChange">MCMCbinaryChange</a></code>, <code><a href="#topic+plotState">plotState</a></code>,
<code><a href="#topic+plotChangepoint">plotChangepoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    ## Not run: 
    set.seed(11119)
    n &lt;- 150
    x1 &lt;- runif(n, 0, 0.5)
    true.beta1 &lt;- c(1,  1)
    true.beta2 &lt;- c(1,  -2)
    true.beta3 &lt;- c(1,  2)

    ## set true two breaks at (50, 100)
    true.s &lt;- rep(1:3, each=n/3)
    mu1 &lt;- exp(1 + x1[true.s==1]*1)
    mu2 &lt;- exp(1 + x1[true.s==2]*-2)
    mu3 &lt;- exp(1 + x1[true.s==3]*2)

    y &lt;- as.ts(c(rpois(n/3, mu1), rpois(n/3, mu2), rpois(n/3, mu3)))
    formula = y ~ x1

    ## fit multiple models with a varying number of breaks
    model0 &lt;-  MCMCpoissonChange(formula, m=0,
            mcmc = 1000, burnin = 1000, verbose = 500,
            b0 = rep(0, 2), B0 = 1/5*diag(2), marginal.likelihood = "Chib95")
    model1 &lt;-  MCMCpoissonChange(formula, m=1,
            mcmc = 1000, burnin = 1000, verbose = 500,
            b0 = rep(0, 2), B0 = 1/5*diag(2), marginal.likelihood = "Chib95")
    model2 &lt;-  MCMCpoissonChange(formula, m=2,
            mcmc = 1000, burnin = 1000, verbose = 500,
            b0 = rep(0, 2), B0 = 1/5*diag(2), marginal.likelihood = "Chib95")
    model3 &lt;-  MCMCpoissonChange(formula, m=3,
            mcmc = 1000, burnin = 1000, verbose = 500,
            b0 = rep(0, 2), B0 = 1/5*diag(2), marginal.likelihood = "Chib95")
    model4 &lt;-  MCMCpoissonChange(formula, m=4,
            mcmc = 1000, burnin = 1000, verbose = 500,
            b0 = rep(0, 2), B0 = 1/5*diag(2), marginal.likelihood = "Chib95")
    model5 &lt;-  MCMCpoissonChange(formula, m=5,
            mcmc = 1000, burnin = 1000, verbose = 500,
            b0 = rep(0, 2), B0 = 1/5*diag(2), marginal.likelihood = "Chib95")

    ## find the most reasonable one
    print(BayesFactor(model0, model1, model2, model3, model4, model5))

    ## draw plots using the "right" model
    par(mfrow=c(attr(model2, "m") + 1, 1), mai=c(0.4, 0.6, 0.3, 0.05))
    plotState(model2, legend.control = c(1, 0.6))
    plotChangepoint(model2, verbose = TRUE, ylab="Density", start=1, overlay=TRUE)

    ## No covariate case
    model2.1 &lt;- MCMCpoissonChange(y ~ 1, m = 2, c0 = 2, d0 = 1,
             mcmc = 1000, burnin = 1000, verbose = 500,
             marginal.likelihood = "Chib95")
    print(BayesFactor(model2, model2.1))
    
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCprobit'>Markov Chain Monte Carlo for Probit Regression</h2><span id='topic+MCMCprobit'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a probit
regression model using the data augmentation approach of Albert and Chib
(1993). The user supplies data and priors, and a sample from the posterior
distribution is returned as an mcmc object, which can be subsequently
analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCprobit(
  formula,
  data = NULL,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  bayes.resid = FALSE,
  marginal.likelihood = c("none", "Laplace", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCprobit_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number and the betas are printed to the screen every
<code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas.  If this takes a scalar value, then that value will serve as the
starting value for all of the betas. The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\beta</code>. Default value of 0 is
equivalent to an improper uniform prior on <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_bayes.resid">bayes.resid</code></td>
<td>
<p>Should latent Bayesian residuals (Albert and Chib, 1995)
be returned? Default is FALSE meaning no residuals should be returned.
Alternatively, the user can specify an array of integers giving the
observation numbers for which latent residuals should be calculated and
returned. TRUE will return draws of latent residuals for all observations.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, <code>Laplace</code> in which case the Laplace approximation (see Kass
and Raftery, 1995) is used, or <code>Chib95</code> in which case Chib (1995)
method is used.</p>
</td></tr>
<tr><td><code id="MCMCprobit_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCprobit</code> simulates from the posterior distribution of a probit
regression model using data augmentation. The simulation proper is done in
compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim \mathcal{B}ernoulli(\pi_i)</code>
</p>

<p>Where the inverse link function:
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = \Phi(x_i'\beta)</code>
</p>

<p>We assume a multivariate Normal prior on <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>See Albert and Chib (1993)
for estimation details.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Albert, J. H. and S. Chib. 1993. &ldquo;Bayesian Analysis of Binary
and Polychotomous Response Data.&rdquo; <em>J. Amer. Statist. Assoc.</em> 88,
669-679
</p>
<p>Albert, J. H. and S. Chib. 1995. &ldquo;Bayesian Residual Analysis for Binary
Response Regression Models.&rdquo; <em>Biometrika.</em> 82, 747-759.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Siddhartha Chib. 1995. &ldquo;Marginal Likelihood from the Gibbs Output.&rdquo;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
&lt;doi: 10.1080/01621459.1995.10476635&gt;
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   data(birthwt)
   out1 &lt;- MCMCprobit(low~as.factor(race)+smoke, data=birthwt,
   	b0 = 0, B0 = 10, marginal.likelihood="Chib95")
   out2 &lt;- MCMCprobit(low~age+as.factor(race), data=birthwt,
   	b0 = 0, B0 = 10,  marginal.likelihood="Chib95")
   out3 &lt;- MCMCprobit(low~age+as.factor(race)+smoke, data=birthwt,
   	b0 = 0, B0 = 10,  marginal.likelihood="Chib95")
   BayesFactor(out1, out2, out3)
   plot(out3)
   summary(out3)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCprobitChange'>Markov Chain Monte Carlo for a linear Gaussian Multiple Changepoint Model</h2><span id='topic+MCMCprobitChange'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a linear
Gaussian model with multiple changepoints. The function uses the Markov
chain Monte Carlo method of Chib (1998).  The user supplies data and priors,
and a sample from the posterior distribution is returned as an mcmc object,
which can be subsequently analyzed with functions provided in the coda
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCprobitChange(
  formula,
  data = parent.frame(),
  m = 1,
  burnin = 10000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  b0 = NULL,
  B0 = NULL,
  a = NULL,
  b = NULL,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCprobitChange_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of betas.  The default value of of NA will use the MLE estimate of
<code class="reqn">\beta</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix.  A user should
provide a square matrix with dimension equal to the number of states.  By
default, draws from the <code>Beta(0.9, 0.1)</code> are used to construct a proper
transition matrix for each raw except the last raw.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, and <code>Chib95</code> in which case the method of Chib (1995) is
used.</p>
</td></tr>
<tr><td><code id="MCMCprobitChange_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCprobitChange</code> simulates from the posterior distribution of a
probit regression model with multiple parameter breaks. The simulation is
based on Chib (1998) and Park (2011).
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">\Pr(y_t = 1) = \Phi(x_i'\beta_m) \;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states, and <code class="reqn">\beta_m</code>
is a parameter when a state is <code class="reqn">m</code> at <code class="reqn">t</code>.
</p>
<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, M</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.  The object
contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period, the log-likelihood of
the model (<code>loglike</code>), and the log-marginal likelihood of the model
(<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park. 2011. &ldquo;Changepoint Analysis of Binary and
Ordinal Probit Models: An Application to Bank Rate Policy Under the Interwar
Gold Standard.&quot;  <em>Political Analysis</em>. 19: 188-204. &lt;doi:10.1093/pan/mpr007&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  &ldquo;MCMCpack:
Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Siddhartha Chib. 1998. &ldquo;Estimation and comparison of multiple change-point
models.&rdquo; <em>Journal of Econometrics</em>. 86: 221-241.
</p>
<p>Albert, J. H. and S. Chib. 1993. &ldquo;Bayesian Analysis of Binary and
Polychotomous Response Data.&rdquo; <em>J. Amer. Statist. Assoc.</em> 88, 669-679
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotState">plotState</a></code>, <code><a href="#topic+plotChangepoint">plotChangepoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1973)
x1 &lt;- rnorm(300, 0, 1)
true.beta &lt;- c(-.5, .2, 1)
true.alpha &lt;- c(.1, -1., .2)
X &lt;- cbind(1, x1)

## set two true breaks at 100 and 200
true.phi1 &lt;- pnorm(true.alpha[1] + x1[1:100]*true.beta[1])
true.phi2 &lt;- pnorm(true.alpha[2] + x1[101:200]*true.beta[2])
true.phi3 &lt;-  pnorm(true.alpha[3] + x1[201:300]*true.beta[3])

## generate y
y1 &lt;- rbinom(100, 1, true.phi1)
y2 &lt;- rbinom(100, 1, true.phi2)
y3 &lt;- rbinom(100, 1, true.phi3)
Y &lt;- as.ts(c(y1, y2, y3))

## fit multiple models with a varying number of breaks
out0 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=0,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))
out1 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=1,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))
out2 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=2,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))
out3 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=3,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))

## find the most reasonable one
BayesFactor(out0, out1, out2, out3)

## draw plots using the "right" model
plotState(out2)
plotChangepoint(out2)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCquantreg'>Bayesian quantile regression using Gibbs sampling</h2><span id='topic+MCMCquantreg'></span>

<h3>Description</h3>

<p>This function fits quantile regression models under Bayesian inference.  The
function samples from the posterior distribution using Gibbs sampling with
data augmentation.  A multivariate normal prior is assumed for
<code class="reqn">\beta</code>. The user supplies the prior parameters.  A sample of the
posterior distribution is returned as an mcmc object, which can then be
analysed by functions in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCquantreg(
  formula,
  data = NULL,
  tau = 0.5,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = sample(1:1e+06, 1),
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCquantreg_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_tau">tau</code></td>
<td>
<p>The quantile of interest. Must be between 0 and 1. The default
value of 0.5 corresponds to median regression.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number and the most recently sampled values of <code class="reqn">\beta</code>
and <code class="reqn">\sigma</code> are printed to the screen every <code>verbose</code>th
iteration.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator. If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister. The default value for this argument
is a random integer between 1 and 1,000,000. This default value ensures that
if the function is used again with a different value of <code class="reqn">\tau</code>, it
is extremely unlikely that the seed will be identical. The user can also
pass a list of length two to use the L'Ecuyer random number generator, which
is suitable for parallel computation.  The first element of the list is the
L'Ecuyer seed, which is a vector of length six or NA (if NA a default seed
of <code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for <code class="reqn">\beta</code>.  This can
either be a scalar or a column vector with dimension equal to the dimension
of <code class="reqn">\beta</code>.  The default value of NA will use the OLS estimate
<code class="reqn">\hat{\beta}</code> with
<code class="reqn">\hat{\sigma}\Phi^{-1}(\tau)</code> added on to the
first element of <code class="reqn">\hat{\beta}</code> as the starting value.
(<code class="reqn">\hat{\sigma}^2</code> denotes the usual unbiased estimator of
<code class="reqn">\sigma^2</code> under ordinary mean regression and
<code class="reqn">\Phi^{-1}(\tau)</code> denotes the inverse of the cumulative
density function of the standard normal distribution.)  Note that the
default value assume that an intercept is included in the model.  If a
scalar is given, that value will serve as the starting value for all
<code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the dimension of
</p>
<p><code class="reqn">\beta</code>. If this takes a scalar value, then that value will serve
as the prior mean for all <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\beta</code>. Default value of 0 is
equivalent to an improper uniform prior for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="MCMCquantreg_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCquantreg</code> simulates from the posterior distribution using Gibbs
sampling with data augmentation (see
<a href="http://people.brunel.ac.uk/~mastkky/">http://people.brunel.ac.uk/~mastkky/</a>).  <code class="reqn">\beta</code> are drawn
from a multivariate normal distribution. The augmented data are drawn
conditionally from the inverse Gaussian distribution. The simulation is
carried out in compiled C++ code to maximise efficiency.  Please consult the
coda documentation for a comprehensive list of functions that can be used to
analyse the posterior sample.
</p>
<p>We assume the model
</p>
<p style="text-align: center;"><code class="reqn">Q_{\tau}(y_i|x_i) = x_i'\beta</code>
</p>

<p>where <code class="reqn">Q_{\tau}(y_i|x_i)</code> denotes the
conditional <code class="reqn">\tau</code>th quantile of <code class="reqn">y_i</code> given
<code class="reqn">x_i</code>, and <code class="reqn">\beta=\beta(\tau)</code> are the
regression parameters possibly dependent on <code class="reqn">\tau</code>. The likelihood
is formed based on assuming independent Asymmetric Laplace distributions on
the <code class="reqn">y_i</code> with skewness parameter <code class="reqn">\tau</code> and location
parameters <code class="reqn">x_i'\beta</code>. This assumption ensures that the
likelihood function is maximised by the <code class="reqn">\tau</code>th conditional
quantile of the response variable.  We assume standard, semi-conjugate
priors on <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>Only starting values for
<code class="reqn">\beta</code> are allowed for this sampler.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarised by functions provided by the coda package.
</p>


<h3>Author(s)</h3>

<p>Craig Reed
</p>


<h3>References</h3>

<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.
<em>Scythe Statistical Library 1.2.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Craig Reed and Keming Yu. 2009. &ldquo;An Efficient Gibbs Sampler for Bayesian
Quantile Regression.&rdquo; Technical Report.
</p>
<p>Keming Yu and Jin Zhang. 2005. &ldquo;A Three Parameter Asymmetric Laplace
Distribution and it's extensions.&rdquo; <em>Communications in Statistics -
Theory and Methods</em>, 34, 1867-1879.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCregress">MCMCregress</a></code>, <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,
<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="quantreg.html#topic+rq">rq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

x&lt;-rep(1:10,5)
y&lt;-rnorm(50,mean=x)
posterior_50 &lt;- MCMCquantreg(y~x)
posterior_95 &lt;- MCMCquantreg(y~x, tau=0.95, verbose=10000,
    mcmc=50000, thin=10, seed=2)
plot(posterior_50)
plot(posterior_95)
raftery.diag(posterior_50)
autocorr.plot(posterior_95)
summary(posterior_50)
summary(posterior_95)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCregress'>Markov Chain Monte Carlo for Gaussian Linear Regression</h2><span id='topic+MCMCregress'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a linear
regression model with Gaussian errors using Gibbs sampling (with a
multivariate Gaussian prior on the beta vector, and an inverse Gamma prior
on the conditional error variance).  The user supplies data and priors, and
a sample from the posterior distribution is returned as an mcmc object,
which can be subsequently analyzed with functions provided in the coda
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCregress(
  formula,
  data = NULL,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  c0 = 0.001,
  d0 = 0.001,
  sigma.mu = NA,
  sigma.var = NA,
  marginal.likelihood = c("none", "Laplace", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCregress_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of betas.  The default value of of NA will use the OLS estimate of
<code class="reqn">\beta</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). The
amount of information in the inverse Gamma prior is something like that from
<code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). In
constructing the inverse Gamma prior, <code class="reqn">d_0</code> acts like the sum of
squared errors from the <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_sigma.mu">sigma.mu</code></td>
<td>
<p>The mean of the inverse Gamma prior on
<code class="reqn">\sigma^2</code>.  <code class="reqn">sigma.mu</code> and
<code class="reqn">sigma.var</code> allow users to choose the inverse Gamma prior by
choosing its mean and variance.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_sigma.var">sigma.var</code></td>
<td>
<p>The variacne of the inverse Gamma prior on
<code class="reqn">\sigma^2</code>.  <code class="reqn">sigma.mu</code> and
<code class="reqn">sigma.var</code> allow users to choose the inverse Gamma prior by
choosing its mean and variance.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, <code>Laplace</code> in which case the Laplace approximation (see Kass
and Raftery, 1995) is used, and <code>Chib95</code> in which case the method of
Chib (1995) is used.</p>
</td></tr>
<tr><td><code id="MCMCregress_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCregress</code> simulates from the posterior distribution using standard
Gibbs sampling (a multivariate Normal draw for the betas, and an inverse
Gamma draw for the conditional error variance).  The simulation proper is
done in compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i = x_i ' \beta + \varepsilon_{i}</code>
</p>

<p>Where the errors are assumed to be Gaussian:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i} \sim \mathcal{N}(0, \sigma^2)</code>
</p>

<p>We assume standard, semi-conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2} \sim \mathcal{G}amma(c_0/2, d_0/2)</code>
</p>

<p>Where
<code class="reqn">\beta</code> and <code class="reqn">\sigma^{-2}</code> are assumed <em>a
priori</em> independent.  Note that only starting values for <code class="reqn">\beta</code>
are allowed because simulation is done using Gibbs sampling with the
conditional error variance as the first block in the sampler.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Siddhartha Chib. 1995. &ldquo;Marginal Likelihood from the Gibbs Output.&rdquo;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
</p>
<p>Robert E. Kass and Adrian E. Raftery. 1995. &ldquo;Bayes Factors.&rdquo; <em>Journal
of the American Statistical Association</em>. 90: 773-795.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
line   &lt;- list(X = c(-2,-1,0,1,2), Y = c(1,3,3,3,5))
posterior  &lt;- MCMCregress(Y~X, b0=0, B0 = 0.1,
	      sigma.mu = 5, sigma.var = 25, data=line, verbose=1000)
plot(posterior)
raftery.diag(posterior)
summary(posterior)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCregressChange'>Markov Chain Monte Carlo for a linear Gaussian Multiple Changepoint Model</h2><span id='topic+MCMCregressChange'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a linear
Gaussian model with multiple changepoints. The function uses the Markov
chain Monte Carlo method of Chib (1998).  The user supplies data and priors,
and a sample from the posterior distribution is returned as an mcmc object,
which can be subsequently analyzed with functions provided in the coda
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCregressChange(
  formula,
  data = parent.frame(),
  m = 1,
  b0 = 0,
  B0 = 0,
  c0 = 0.001,
  d0 = 0.001,
  sigma.mu = NA,
  sigma.var = NA,
  a = NULL,
  b = NULL,
  mcmc = 1000,
  burnin = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  random.perturb = FALSE,
  WAIC = FALSE,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCregressChange_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). The
amount of information in the inverse Gamma prior is something like that from
<code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). In
constructing the inverse Gamma prior, <code class="reqn">d_0</code> acts like the sum of
squared errors from the <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_sigma.mu">sigma.mu</code></td>
<td>
<p>The mean of the inverse Gamma prior on
<code class="reqn">\sigma^2</code>.  <code class="reqn">sigma.mu</code> and
<code class="reqn">sigma.var</code> allow users to choose the inverse Gamma prior by
choosing its mean and variance.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_sigma.var">sigma.var</code></td>
<td>
<p>The variacne of the inverse Gamma prior on
<code class="reqn">\sigma^2</code>.  <code class="reqn">sigma.mu</code> and
<code class="reqn">sigma.var</code> allow users to choose the inverse Gamma prior by
choosing its mean and variance.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of betas.  The default value of of NA will use the MLE estimate of
<code class="reqn">\beta</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix.  A user should
provide a square matrix with dimension equal to the number of states.  By
default, draws from the <code>Beta(0.9, 0.1)</code> are used to construct a proper
transition matrix for each raw except the last raw.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_random.perturb">random.perturb</code></td>
<td>
<p>If TRUE, randomly sample hidden states whenever
regularly sampled hidden states have at least one single observation state
(SOS). SOS is a sign of overfitting in non-ergodic hidden Markov models.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_waic">WAIC</code></td>
<td>
<p>Compute the Widely Applicable Information Criterion (Watanabe
2010).</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, and <code>Chib95</code> in which case the method of Chib (1995) is
used.</p>
</td></tr>
<tr><td><code id="MCMCregressChange_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCregressChange</code> simulates from the posterior distribution of the
linear regression model with multiple changepoints.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_t=x_t ' \beta_i + I(s_t=i)\varepsilon_{t},\;\; i=1, \ldots, k</code>
</p>

<p>Where <code class="reqn">k</code> is the number of states and <code class="reqn">I(s_t=i)</code> is an
indicator function that becomes 1 when a state at <code class="reqn">t</code> is
<code class="reqn">i</code> and otherwise 0.
</p>
<p>The errors are assumed to be Gaussian in each regime:
</p>
<p style="text-align: center;"><code class="reqn">I(s_t=i)\varepsilon_{t} \sim \mathcal{N}(0, \sigma^2_i)</code>
</p>

<p>We assume standard, semi-conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \sim \mathcal{N}(b_0,B_0^{-1}),\;\; i=1, \ldots, k</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2}_i \sim \mathcal{G}amma(c_0/2, d_0/2),\;\; i=1, \ldots, k</code>
</p>

<p>Where <code class="reqn">\beta_i</code> and <code class="reqn">\sigma^{-2}_i</code> are assumed <em>a
priori</em> independent.
</p>
<p>The simulation proper is done in compiled C++ code to maximize efficiency.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.  The object
contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period, the log-likelihood of
the model (<code>loglike</code>), and the log-marginal likelihood of the model
(<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park, 2012. &ldquo;Unified Method for Dynamic and
Cross-Sectional Heterogeneity: Introducing Hidden Markov Panel
Models.&rdquo;  <em>American Journal of Political Science</em>.56:
1040-1054. &lt;doi: 10.1111/j.1540-5907.2012.00590.x&gt;
</p>
<p>Sumio Watanabe. 2010. &quot;Asymptotic equivalence of Bayes cross validation and
widely applicable information criterion in singular learning theory&quot;
<em>Journal of Machine Learning Research</em>. 11: 3571-3594.
</p>
<p>Siddhartha Chib. 1995. &quot;Marginal Likelihood from the Gibbs Output.&quot;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
&lt;doi: 10.1016/S0304-4076(97)00115-2&gt;
</p>
<p>Siddhartha Chib. 1998. &quot;Estimation and comparison of multiple change-point
models.&quot;  <em>Journal of Econometrics</em>. 86: 221-241.
&lt;doi: 10.1080/01621459.1995.10476635&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of
Statistical Software</em>.  42(9): 1-21. <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotState">plotState</a></code>, <code><a href="#topic+plotChangepoint">plotChangepoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1119)
n &lt;- 100
x1 &lt;- runif(n)
true.beta1 &lt;- c(2, -2)
true.beta2 &lt;- c(0,  2)
true.Sigma &lt;- c(1, 2)
true.s &lt;- rep(1:2, each=n/2)

mu1 &lt;- cbind(1, x1[true.s==1])%*%true.beta1
mu2 &lt;- cbind(1, x1[true.s==2])%*%true.beta2

y &lt;- as.ts(c(rnorm(n/2, mu1, sd=sqrt(true.Sigma[1])), rnorm(n/2, mu2, sd=sqrt(true.Sigma[2]))))
formula=y ~ x1

ols1 &lt;- lm(y[true.s==1] ~x1[true.s==1])
ols2 &lt;- lm(y[true.s==2] ~x1[true.s==2])

## prior
b0 &lt;- 0
B0 &lt;- 0.1
sigma.mu=sd(y)
sigma.var=var(y)

## models
model0 &lt;-  MCMCregressChange(formula, m=0, b0=b0, B0=B0, mcmc=100, burnin=100,
           sigma.mu=sigma.mu, sigma.var=sigma.var, marginal.likelihood="Chib95")
model1 &lt;-  MCMCregressChange(formula, m=1, b0=b0, B0=B0, mcmc=100, burnin=100,
           sigma.mu=sigma.mu, sigma.var=sigma.var, marginal.likelihood="Chib95")
model2 &lt;-  MCMCregressChange(formula, m=2, b0=b0, B0=B0, mcmc=100, burnin=100,
           sigma.mu=sigma.mu, sigma.var=sigma.var, marginal.likelihood="Chib95")
model3 &lt;-  MCMCregressChange(formula, m=3, b0=b0, B0=B0, mcmc=100, burnin=100,
           sigma.mu=sigma.mu, sigma.var=sigma.var, marginal.likelihood="Chib95")
model4 &lt;-  MCMCregressChange(formula, m=4, b0=b0, B0=B0, mcmc=100, burnin=100,
           sigma.mu=sigma.mu, sigma.var=sigma.var, marginal.likelihood="Chib95")
model5 &lt;-  MCMCregressChange(formula, m=5, b0=b0, B0=B0, mcmc=100, burnin=100,
           sigma.mu=sigma.mu, sigma.var=sigma.var, marginal.likelihood="Chib95")

print(BayesFactor(model0, model1, model2, model3, model4, model5))
plotState(model1)
plotChangepoint(model1)


## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCresidualBreakAnalysis'>Break Analysis of Univariate Time Series using Markov Chain Monte Carlo</h2><span id='topic+MCMCresidualBreakAnalysis'></span>

<h3>Description</h3>

<p>This function performs a break analysis for univariate time series data
using a linear Gaussian changepoint model. The code is written mainly for an
internal use in <code>testpanelSubjectBreak</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCresidualBreakAnalysis(
  resid,
  m = 1,
  b0 = 0,
  B0 = 0.001,
  c0 = 0.1,
  d0 = 0.1,
  a = NULL,
  b = NULL,
  mcmc = 1000,
  burnin = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  random.perturb = FALSE,
  WAIC = FALSE,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_resid">resid</code></td>
<td>
<p>Univariate time series</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_m">m</code></td>
<td>
<p>The number of breaks.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). The
amount of information in the inverse Gamma prior is something like that from
<code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). In
constructing the inverse Gamma prior, <code class="reqn">d_0</code> acts like the sum of
squared errors from the <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of betas.  The default value of of NA will use the OLS estimate of
<code class="reqn">\beta</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_p.start">P.start</code></td>
<td>
<p>The starting values for the transition matrix.  A user should
provide a square matrix with dimension equal to the number of states.  By
default, draws from the <code>Beta(0.9, 0.1)</code> are used to construct a proper
transition matrix for each raw except the last raw.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_random.perturb">random.perturb</code></td>
<td>
<p>If TRUE, randomly sample hidden states whenever
regularly sampled hidden states have at least one single observation state.
It's one method to avoid overfitting in a non-ergodic hidden Markov models.
See Park and Sohn (2017).</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_waic">WAIC</code></td>
<td>
<p>Compute the Widely Applicable Information Criterion (Watanabe
2010).</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, and <code>Chib95</code> in which case the method of Chib (1995) is
used.</p>
</td></tr>
<tr><td><code id="MCMCresidualBreakAnalysis_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCresidualBreakAnalysis</code> simulates from the posterior distribution
using standard Gibbs sampling (a multivariate Normal draw for the betas, and
an inverse Gamma draw for the conditional error variance).  The simulation
proper is done in compiled C++ code to maximize efficiency.  Please consult
the coda documentation for a comprehensive list of functions that can be
used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_{i} \sim \mathcal{N}(\beta_{m}, \sigma^2_{m}) \;\; m = 1, \ldots, M</code>
</p>

<p>We assume standard, semi-conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>And: </p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2} \sim \mathcal{G}amma(c_0/2, d_0/2)</code>
</p>

<p>Where <code class="reqn">\beta</code> and <code class="reqn">\sigma^{-2}</code> are
assumed <em>a priori</em> independent.
</p>
<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyu Sohn. 2017. &quot;Detecting Structural
Changes in Network Data: An Application to Changes in Military Alliance
Networks, 1816-2012&quot;.  Working Paper.
</p>
<p>Jong Hee Park, 2012. &ldquo;Unified Method for Dynamic and Cross-Sectional
Heterogeneity: Introducing Hidden Markov Panel Models.&rdquo; <em>American
Journal of Political Science</em>.56: 1040-1054. &lt;doi: 10.1111/j.1540-5907.2012.00590.x&gt;
</p>
<p>Sumio Watanabe. 2010. &quot;Asymptotic equivalence of Bayes cross validation and
widely applicable information criterion in singular learning theory&quot;
<em>Journal of Machine Learning Research</em>. 11: 3571-3594.
</p>
<p>Siddhartha Chib. 1995. &quot;Marginal Likelihood from the Gibbs Output.&quot;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
&lt;doi: 10.1016/S0304-4076(97)00115-2&gt;
</p>
<p>Siddhartha Chib. 1998. &quot;Estimation and comparison of multiple change-point
models.&quot;  <em>Journal of Econometrics</em>. 86: 221-241.
&lt;doi: 10.1080/01621459.1995.10476635&gt;
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
line   &lt;- list(X = c(-2,-1,0,1,2), Y = c(1,3,3,3,5))
ols &lt;- lm(Y~X)
residual &lt;-   rstandard(ols)
posterior  &lt;- MCMCresidualBreakAnalysis(residual, m = 1, data=line, mcmc=1000, verbose=200)
plotState(posterior)
summary(posterior)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCSVDreg'>Markov Chain Monte Carlo for SVD Regression</h2><span id='topic+MCMCSVDreg'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a linear regression model with Gaussian errors in which the design
matrix has been decomposed with singular value decomposition.The
sampling is done via the Gibbs sampling algorithm.  The user
supplies data and priors, and a sample from the posterior
distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCSVDreg(
  formula,
  data = NULL,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  tau2.start = 1,
  g0 = 0,
  a0 = 0.001,
  b0 = 0.001,
  c0 = 2,
  d0 = 2,
  w0 = 1,
  beta.samp = FALSE,
  intercept = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCSVDreg_+3A_formula">formula</code></td>
<td>
<p>Model formula. Predictions are returned for elements
of y that are coded as NA.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0 the iteration number, the
<code class="reqn">\beta</code> vector, and the error variance are printed to the
screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the
Mersenne Twister generator is used with default seed 12345; if an
integer is passed it is used to seed the Mersenne twister.  The
user can also pass a list of length two to use the L'Ecuyer
random number generator, which is suitable for parallel
computation.  The first element of the list is the L'Ecuyer seed,
which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a
positive substream number. See the MCMCpack specification for
more details.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_tau2.start">tau2.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\tau^2</code> vector.
Can be either a scalar or a vector. If a scalar is passed then
that value will be the starting value for all elements of
<code class="reqn">\tau^2</code>.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_g0">g0</code></td>
<td>
<p>The prior mean of <code class="reqn">\gamma</code>.  This can either be a
scalar or a column vector with dimension equal to the number of
gammas. If this takes a scalar value, then that value will serve
as the prior mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_a0">a0</code></td>
<td>
<p><code class="reqn">a_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). The
amount of information in the inverse Gamma prior is something
like that from <code class="reqn">a_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_b0">b0</code></td>
<td>
<p><code class="reqn">b_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). In
constructing the inverse Gamma prior, <code class="reqn">b_0</code> acts like the sum
of squared errors from the <code class="reqn">a_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\tau_i^2</code>.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\tau_i^2</code>.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_w0">w0</code></td>
<td>
<p>The prior probability that <code class="reqn">\gamma_i = 0</code>.  Can be
either a scalar or an <code class="reqn">N</code> vector where <code class="reqn">N</code> is the number
of observations.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_beta.samp">beta.samp</code></td>
<td>
<p>Logical indicating whether the sampled elements of
beta should be stored and returned.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_intercept">intercept</code></td>
<td>
<p>Logical indicating whether the original design
matrix should include a constant term.</p>
</td></tr>
<tr><td><code id="MCMCSVDreg_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model takes the following form: </p>
<p style="text-align: center;"><code class="reqn">y = X \beta +
\varepsilon</code>
</p>
<p> Where the errors are assumed to be iid Gaussian:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i} \sim \mathcal{N}(0, \sigma^2)</code>
</p>

<p>Let <code class="reqn">N</code> denote the number of rows of <code class="reqn">X</code> and <code class="reqn">P</code> the
number of columns of <code class="reqn">X</code>. Unlike the standard regression setup
where <code class="reqn">N &gt;&gt; P</code> here it is the case that <code class="reqn">P &gt;&gt; N</code>.
</p>
<p>To deal with this problem a singular value decomposition of
<code class="reqn">X'</code> is performed: <code class="reqn">X' = ADF</code> and the regression model
becomes
</p>
<p style="text-align: center;"><code class="reqn">y = F'D \gamma + \varepsilon</code>
</p>

<p>where <code class="reqn">\gamma = A' \beta</code>
</p>
<p>We assume the following priors:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2} \sim \mathcal{G}amma(a_0/2, b_0/2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau^{-2} \sim \mathcal{G}amma(c_0/2, d_0/2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma_i \sim w0_i \delta_0 + (1-w0_i) \mathcal{N}(g0_i,
\sigma^2 \tau_i^2/ d_i^2)</code>
</p>

<p>where <code class="reqn">\delta_0</code> is a unit point mass at 0 and <code class="reqn">d_i</code> is the
<code class="reqn">i</code>th diagonal element of <code class="reqn">D</code>.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This
object can be summarized by functions provided by the coda
package.
</p>


<h3>References</h3>

<p>Mike West, Josheph Nevins, Jeffrey Marks, Rainer Spang,
and Harry Zuzan. 2000. &ldquo;DNA Microarray Data Analysis and
Regression Modeling for Genetic Expression
Profiling.&quot; Duke ISDS working paper.
</p>
<p>Gottardo, Raphael, and Adrian Raftery. 2004. &ldquo;Markov chain Monte
Carlo with mixtures of singular distributions.&rdquo; Statistics
Department, University of Washington, Technical Report 470.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of
Statistical Software</em>.  42(9): 1-21.
<a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.
<em>Scythe Statistical Library 1.0.</em>
<a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.
&ldquo;Output Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R
News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,
<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>
</p>

<hr>
<h2 id='MCMCtobit'>Markov Chain Monte Carlo for Gaussian Linear Regression with a Censored
Dependent Variable</h2><span id='topic+MCMCtobit'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a linear
regression model with Gaussian errors using Gibbs sampling (with a
multivariate Gaussian prior on the beta vector, and an inverse Gamma prior
on the conditional error variance).  The dependent variable may be censored
from below, from above, or both. The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc object, which
can be subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCtobit(
  formula,
  data = NULL,
  below = 0,
  above = Inf,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  c0 = 0.001,
  d0 = 0.001,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCtobit_+3A_formula">formula</code></td>
<td>
<p>A model formula.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_below">below</code></td>
<td>
<p>The point at which the dependent variable is censored from
below. The default is zero. To censor from above only, specify that below =
-Inf.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_above">above</code></td>
<td>
<p>The point at which the dependent variable is censored from
above. To censor from below only, use the default value of Inf.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance is
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_beta.start">beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of betas. The default value of of NA will use the OLS estimate of
<code class="reqn">\beta</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the betas.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_b0">B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). The
amount of information in the inverse Gamma prior is something like that from
<code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code> (the variance of the disturbances). In
constructing the inverse Gamma prior, <code class="reqn">d_0</code> acts like the sum of
squared errors from the <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="MCMCtobit_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCMCtobit</code> simulates from the posterior distribution using standard
Gibbs sampling (a multivariate Normal draw for the betas, and an inverse
Gamma draw for the conditional error variance). <code>MCMCtobit</code> differs
from <code>MCMCregress</code> in that the dependent variable may be censored from
below, from above, or both. The simulation proper is done in compiled C++
code to maximize efficiency.  Please consult the coda documentation for a
comprehensive list of functions that can be used to analyze the posterior
sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">y_i = x_i ' \beta + \varepsilon_{i},</code>
</p>

<p>where the errors are assumed
to be Gaussian:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i} \sim \mathcal{N}(0, \sigma^2).</code>
</p>

<p>Let <code class="reqn">c_1</code> and <code class="reqn">c_2</code> be the two censoring points, and let
<code class="reqn">y_i^\ast</code> be the partially observed dependent variable. Then,
</p>
<p style="text-align: center;"><code class="reqn">y_i = y_i^{\ast} \texttt{ if } c_1 &lt; y_i^{\ast} &lt; c_2,</code>
</p>

<p style="text-align: center;"><code class="reqn">y_i = c_1 \texttt{ if } c_1 \geq y_i^{\ast},</code>
</p>

<p style="text-align: center;"><code class="reqn">y_i = c_2 \texttt{ if } c_2 \leq y_i^{\ast}.</code>
</p>

<p>We assume standard, semi-conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1}),</code>
</p>

<p>and:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2} \sim \mathcal{G}amma(c_0/2, d_0/2),</code>
</p>

<p>where <code class="reqn">\beta</code> and <code class="reqn">\sigma^{-2}</code> are
assumed <em>a priori</em> independent.  Note that only starting
values for <code class="reqn">\beta</code> are allowed because simulation is done
using Gibbs sampling with the conditional error variance as the
first block in the sampler.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich, <a href="mailto:goodrich.ben@gmail.com">goodrich.ben@gmail.com</a>,
<a href="http://www.columbia.edu/~bg2382/">http://www.columbia.edu/~bg2382/</a>
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
&ldquo;MCMCpack: Markov Chain Monte Carlo in R.&rdquo;, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Siddhartha Chib. 1992. &ldquo;Bayes inference in the Tobit censored regression
model.&quot;  <em>Journal of Econometrics</em>. 51:79-99.
</p>
<p>James Tobin. 1958. &ldquo;Estimation of relationships for limited dependent
variables.&quot; <em>Econometrica.</em> 26:24-36.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="survival.html#topic+survreg">survreg</a></code>, <code><a href="#topic+MCMCregress">MCMCregress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(survival)
example(tobin)
summary(tfit)
tfit.mcmc &lt;- MCMCtobit(durable ~ age + quant, data=tobin, mcmc=30000,
                        verbose=1000)
plot(tfit.mcmc)
raftery.diag(tfit.mcmc)
summary(tfit.mcmc)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCmultinomdirichlet'>Monte Carlo Simulation from a Multinomial Likelihood with a Dirichlet Prior</h2><span id='topic+MCmultinomdirichlet'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
multinomial likelihood with a Dirichlet prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCmultinomdirichlet(y, alpha0, mc = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCmultinomdirichlet_+3A_y">y</code></td>
<td>
<p>A vector of data (number of successes for each category).</p>
</td></tr>
<tr><td><code id="MCmultinomdirichlet_+3A_alpha0">alpha0</code></td>
<td>
<p>The vector of parameters of the Dirichlet prior.</p>
</td></tr>
<tr><td><code id="MCmultinomdirichlet_+3A_mc">mc</code></td>
<td>
<p>The number of Monte Carlo draws to make.</p>
</td></tr>
<tr><td><code id="MCmultinomdirichlet_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCmultinomdirichlet</code> directly simulates from the posterior
distribution.  This model is designed primarily for instructional use.
<code class="reqn">\pi</code> is the parameter of interest of the multinomial distribution.
It is of dimension <code class="reqn">(d \times 1)</code>. We assume a conjugate
Dirichlet prior:
</p>
<p style="text-align: center;"><code class="reqn">\pi \sim \mathcal{D}irichlet(\alpha_0)</code>
</p>

<p><code class="reqn">y</code> is a <code class="reqn">(d \times 1)</code> vector of
observed data.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Example from Gelman, et. al. (1995, p. 78)
posterior &lt;- MCmultinomdirichlet(c(727,583,137), c(1,1,1), mc=10000)
bush.dukakis.diff &lt;- posterior[,1] - posterior[,2]
cat("Pr(Bush &gt; Dukakis): ",
   sum(bush.dukakis.diff &gt; 0) / length(bush.dukakis.diff), "\n")
hist(bush.dukakis.diff)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCnormalnormal'>Monte Carlo Simulation from a Normal Likelihood (with known variance) with a
Normal Prior</h2><span id='topic+MCnormalnormal'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a Normal
likelihood (with known variance) with a Normal prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCnormalnormal(y, sigma2, mu0, tau20, mc = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCnormalnormal_+3A_y">y</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="MCnormalnormal_+3A_sigma2">sigma2</code></td>
<td>
<p>The known variance of y.</p>
</td></tr>
<tr><td><code id="MCnormalnormal_+3A_mu0">mu0</code></td>
<td>
<p>The prior mean of mu.</p>
</td></tr>
<tr><td><code id="MCnormalnormal_+3A_tau20">tau20</code></td>
<td>
<p>The prior variance of mu.</p>
</td></tr>
<tr><td><code id="MCnormalnormal_+3A_mc">mc</code></td>
<td>
<p>The number of Monte Carlo draws to make.</p>
</td></tr>
<tr><td><code id="MCnormalnormal_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCnormalnormal</code> directly simulates from the posterior distribution.
This model is designed primarily for instructional use.  <code class="reqn">\mu</code> is
the parameter of interest of the Normal distribution.  We assume a conjugate
normal prior:
</p>
<p style="text-align: center;"><code class="reqn">\mu \sim \mathcal{N}(\mu_0, \tau^2_0)</code>
</p>

<p><code class="reqn">y</code> is a vector of observed data.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
y &lt;- c(2.65, 1.80, 2.29, 2.11, 2.27, 2.61, 2.49, 0.96, 1.72, 2.40)
posterior &lt;- MCMCpack:::MCnormalnormal(y, 1, 0, 1, 5000)
summary(posterior)
plot(posterior)
grid &lt;- seq(-3,3,0.01)
plot(grid, dnorm(grid, 0, 1), type="l", col="red", lwd=3, ylim=c(0,1.4),
   xlab="mu", ylab="density")
lines(density(posterior), col="blue", lwd=3)
legend(-3, 1.4, c("prior", "posterior"), lwd=3, col=c("red", "blue"))

## End(Not run)

</code></pre>

<hr>
<h2 id='MCpoissongamma'>Monte Carlo Simulation from a Poisson Likelihood with a Gamma Prior</h2><span id='topic+MCpoissongamma'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
Poisson likelihood with a Gamma prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCpoissongamma(y, alpha, beta, mc = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCpoissongamma_+3A_y">y</code></td>
<td>
<p>A vector of counts (must be non-negative).</p>
</td></tr>
<tr><td><code id="MCpoissongamma_+3A_alpha">alpha</code></td>
<td>
<p>Gamma prior distribution shape parameter.</p>
</td></tr>
<tr><td><code id="MCpoissongamma_+3A_beta">beta</code></td>
<td>
<p>Gamma prior distribution scale parameter.</p>
</td></tr>
<tr><td><code id="MCpoissongamma_+3A_mc">mc</code></td>
<td>
<p>The number of Monte Carlo draws to make.</p>
</td></tr>
<tr><td><code id="MCpoissongamma_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MCpoissongamma</code> directly simulates from the posterior distribution.
This model is designed primarily for instructional use.
<code class="reqn">\lambda</code> is the parameter of interest of the Poisson
distribution.  We assume a conjugate Gamma prior:
</p>
<p style="text-align: center;"><code class="reqn">\lambda \sim \mathcal{G}amma(\alpha, \beta)</code>
</p>

<p><code class="reqn">y</code> is a vector of counts.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(quine)
posterior &lt;- MCpoissongamma(quine$Days, 15, 1, 5000)
summary(posterior)
plot(posterior)
grid &lt;- seq(14,18,0.01)
plot(grid, dgamma(grid, 15, 1), type="l", col="red", lwd=3, ylim=c(0,1.3),
  xlab="lambda", ylab="density")
lines(density(posterior), col="blue", lwd=3)
legend(17, 1.3, c("prior", "posterior"), lwd=3, col=c("red", "blue"))

## End(Not run)

</code></pre>

<hr>
<h2 id='mptable'>Calculate the marginal posterior probabilities of predictors being included
in a quantile regression model.</h2><span id='topic+mptable'></span>

<h3>Description</h3>

<p>This function extracts the marginal probability table produced by
<code>summary.qrssvs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mptable(qrssvs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mptable_+3A_qrssvs">qrssvs</code></td>
<td>
<p>An object of class <code>qrssvs</code>. Typically this will be the
<code>gamma</code> component of the list returned by <code>SSVSquantreg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with the predictors listed together with their posterior
marginal posterior probability of inclusion.
</p>


<h3>Author(s)</h3>

<p>Craig Reed
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SSVSquantreg">SSVSquantreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1)
epsilon&lt;-rnorm(100)
set.seed(2)
x&lt;-matrix(rnorm(1000),100,10)
y&lt;-x[,1]+x[,10]+epsilon
qrssvs&lt;-SSVSquantreg(y~x)
mptable(qrssvs$gamma)

## End(Not run)

</code></pre>

<hr>
<h2 id='Nethvote'>Dutch Voting Behavior in 1989</h2><span id='topic+Nethvote'></span>

<h3>Description</h3>

<p>Dutch Voting Behavior in 1989.
</p>


<h3>Format</h3>

<p>A data frame with 1754 observations and 11 variables from the 1989
Dutch Parliamentary Election Study (Anker and Oppenhuis, 1993). Each
observation is a survey respondent.  These data are a subset of one of five
multiply imputed datasets used in Quinn and Martin (2002). For more
information see Quinn and Martin (2002).
</p>

<dl>
<dt>vote</dt><dd><p>A factor giving the self-reported vote choice of each respondent.
The levels are CDA (Christen Democratisch Appel), D66 (Democraten 66), Pvda
(Partij van de Arbeid), and VVD (Volkspartij voor Vrijheid en Democratie).</p>
</dd>
<dt>distD66</dt><dd><p>A numeric variable giving the squared ideological distance
between the respondent and the D66. Larger values indicate ideological
dissimilarity between the respondent and the party.</p>
</dd>
<dt>distPvdA</dt><dd><p>A numeric variable giving the squared ideological distance
between the respondent and the PvdA. Larger values indicate ideological
dissimilarity between the respondent and the party.</p>
</dd>
<dt>distVVD</dt><dd><p>A numeric variable giving the squared ideological distance between
the respondent and the VVD. Larger values indicate ideological dissimilarity
between the respondent and the party.</p>
</dd>
<dt>distCDA</dt><dd><p>A numeric variable giving the squared ideological
distance between the respondent and the CDA. Larger values indicate
ideological dissimilarity between the respondent and the party.</p>
</dd>
<dt>relig</dt><dd><p>An indicator variable equal to 0 if the respondent is not
religious and 1 if the respondent is religious.</p>
</dd>
<dt>class</dt><dd><p>Social class of respondent. 0 is the lowest social class,
4 is the highest social class.</p>
</dd>
<dt>income</dt><dd><p>Income of respondent. 0 is lowest and 6 is highest.</p>
</dd>
<dt>educ</dt><dd><p>Education of respondent. 0 is lowest and 4 is highest.</p>
</dd>
<dt>age</dt><dd><p>Age category of respondent. 0 is lowest and 12 is highest.</p>
</dd>
<dt>urban</dt><dd><p>Indicator variable equal to 0 if the respondent is not a
resident of an urban area and 1 if the respondent is a resident of an urban
area.</p>
</dd>
</dl>



<h3>Source</h3>

<p>H. Anker and E.V. Oppenhuis. 1993. &ldquo;Dutch Parliamentary Election
Study.&rdquo; (computer file). Dutch Electoral Research Foundation and
Netherlands Central Bureau of Statistics, Amsterdam.
</p>


<h3>References</h3>

<p>Kevin M. Quinn and Andrew D. Martin. 2002. &ldquo;An Integrated
Computational Model of Multiparty Electoral Competition.&rdquo; <em>Statistical
Science</em>. 17: 405-419.
</p>

<hr>
<h2 id='NoncenHypergeom'>The Noncentral Hypergeometric Distribution</h2><span id='topic+NoncenHypergeom'></span><span id='topic+rnoncenhypergeom'></span><span id='topic+dnoncenhypergeom'></span>

<h3>Description</h3>

<p>Evaluates the density at a single point or all points, and generate random
draws from the Noncentral Hypergeometric distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnoncenhypergeom(x = NA, n1, n2, m1, psi)

rnoncenhypergeom(n, n1, n2, m1, psi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoncenHypergeom_+3A_x">x</code></td>
<td>
<p>The location to evaluate the density.  If <code>x</code> is NA, then a
matrix is returned with the density evaluated at all possible points.</p>
</td></tr>
<tr><td><code id="NoncenHypergeom_+3A_n1">n1</code></td>
<td>
<p>The size of group one.</p>
</td></tr>
<tr><td><code id="NoncenHypergeom_+3A_n2">n2</code></td>
<td>
<p>The size of group two.</p>
</td></tr>
<tr><td><code id="NoncenHypergeom_+3A_m1">m1</code></td>
<td>
<p>The observed number of positive outcomes (in both groups).</p>
</td></tr>
<tr><td><code id="NoncenHypergeom_+3A_psi">psi</code></td>
<td>
<p>Odds ratio.</p>
</td></tr>
<tr><td><code id="NoncenHypergeom_+3A_n">n</code></td>
<td>
<p>The number of draws to make from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Noncentral Hypergeometric is particularly useful for conditional
inference for <code class="reqn">(2 \times 2)</code> tables.  We use the
parameterization and algorithms of Liao and Rosen (2001).  The underlying R
code is based on their published code.  See their article for details of the
parameterization.
</p>


<h3>Value</h3>

<p><code>dnoncenhypergeom</code> evaluates the density at point <code>x</code>, or
a matrix with the first column containing the possible values of the random
variable, and the second column containing the probabilities.
</p>
<p><code>rnoncenhypergeom</code> returns a list of <code>n</code> random draws from the
distribution.
</p>


<h3>Source</h3>

<p>J. G. Liao and Ori Rosen. 2001. &ldquo;Fast and Stable Algorithms for
Computing and Sampling From the Noncentral Hypergeometric Distribution.&quot;
<em>The American Statistician.</em> 55: 366-369.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  density &lt;- dnoncenhypergeom(NA, 500, 500, 500, 6.0)
  draws &lt;- rnoncenhypergeom(10, 500, 500, 500, 6.0)
</code></pre>

<hr>
<h2 id='PErisk'>Political Economic Risk Data from 62 Countries in 1987</h2><span id='topic+PErisk'></span>

<h3>Description</h3>

<p>Political Economic Risk Data from 62 Countries in 1987.
</p>


<h3>Format</h3>

<p>A data frame with 62 observations on the following 9 variables. All
data points are from 1987. See Quinn (2004) for more details.
</p>

<dl>
<dt>country</dt><dd><p>a factor with levels <code>Argentina</code> through
<code>Zimbabwe</code></p>
</dd> <dt>courts</dt><dd><p>an ordered factor with levels <code>0</code> &lt;
<code>1</code>.<code>courts</code> is an indicator of whether the country in question is
judged to have an independent judiciary. From Henisz (2002).</p>
</dd>
<dt>barb2</dt><dd><p>a numeric vector giving the natural log of the black market
premium in each country. The black market premium is coded as the black market
exchange rate (local currency per dollar) divided by the official exchange rate
minus 1. From Marshall, Gurr, and Harff (2002). </p>
</dd>
<dt>prsexp2</dt><dd><p>an ordered factor
with levels <code>0</code> &lt; <code>1</code> &lt; <code>2</code> &lt; <code>3</code> &lt; <code>4</code> &lt; <code>5</code>,
giving the lack of expropriation risk. From Marshall, Gurr, and Harff
(2002).</p>
</dd>
<dt>prscorr2</dt><dd><p>an ordered factor with levels <code>0</code> &lt; <code>1</code> &lt;
<code>2</code> &lt; <code>3</code> &lt; <code>4</code> &lt; <code>5</code>, measuring the lack of corruption.
From Marshall, Gurr, and Harff (2002).</p>
</dd>
<dt>gdpw2</dt><dd><p>a numeric vector giving the natural log of real GDP per worker in
1985 international prices. From Alvarez et al. (1999).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mike Alvarez, Jose Antonio Cheibub, Fernando Limongi, and Adam
Przeworski. 1999. &ldquo;ACLP Political and Economic Database.&rdquo;
</p>
<p>Witold J. Henisz. 2002. &ldquo;The Political Constraint Index (POLCON) Dataset.&rdquo;
</p>
<p>Monty G. Marshall, Ted Robert Gurr, and Barbara Harff. 2002. &ldquo;State Failure
Task Force Problem Set.&rdquo;
</p>


<h3>References</h3>

<p>Kevin M. Quinn. 2004. &ldquo;Bayesian Factor Analysis for Mixed
Ordinal and Continuous Response.&rdquo; <em>Political Analyis</em>. 12: 338-353.
</p>

<hr>
<h2 id='plot.qrssvs'>Plot output from quantile regression stochastic search variable selection
(QR-SSVS).</h2><span id='topic+plot.qrssvs'></span>

<h3>Description</h3>

<p>This function produces a Trellis plot of the predictors on the y-axis versus
the marginal posterior probability of inclusion on the x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrssvs'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qrssvs_+3A_x">x</code></td>
<td>
<p>An object of class <code>qrssvs</code>. Typically this will be the
<code>gamma</code> component of the list returned by <code>SSVSquantreg</code>.</p>
</td></tr>
<tr><td><code id="plot.qrssvs_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"trellis"</code>. The associated
<code><a href="lattice.html#topic+update.trellis">update</a></code> and
<code><a href="lattice.html#topic+print.trellis">print</a></code> methods are documented in the
&quot;Lattice&quot; package.
</p>


<h3>Author(s)</h3>

<p>Craig Reed
</p>


<h3>References</h3>

<p>Deepayan Sarkar. 2008. <em>lattice: Lattice Graphics.</em> R package version
0.17-17
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SSVSquantreg">SSVSquantreg</a></code>,
<code><a href="#topic+mptable">mptable</a></code>, <code><a href="lattice.html#topic+Lattice">Lattice</a></code> for
a brief introduction to lattice displays and links to further documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1)
epsilon&lt;-rnorm(100)
set.seed(2)
x&lt;-matrix(rnorm(1000),100,10)
y&lt;-x[,1]+x[,10]+epsilon
qrssvs&lt;-SSVSquantreg(y~x)
plot(qrssvs$gamma)
## Modify the graph by increasing the fontsize on the axes
qrssvsplot&lt;-plot(qrssvs$gamma)
update(qrssvsplot, scales=list(cex=3))

## End(Not run)

</code></pre>

<hr>
<h2 id='plotChangepoint'>Posterior Density of Regime Change Plot</h2><span id='topic+plotChangepoint'></span>

<h3>Description</h3>

<p>Plot the posterior density of regime change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotChangepoint(
  mcmcout,
  main = "Posterior Density of Regime Change Probabilities",
  xlab = "Time",
  ylab = "",
  verbose = FALSE,
  start = 1,
  overlay = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotChangepoint_+3A_mcmcout">mcmcout</code></td>
<td>
<p>The <code>mcmc</code> object containing the posterior density
sample from a changepoint model.  Note that this must have a
</p>
<p><code>prob.state</code> attribute.</p>
</td></tr>
<tr><td><code id="plotChangepoint_+3A_main">main</code></td>
<td>
<p>Title of the plot</p>
</td></tr>
<tr><td><code id="plotChangepoint_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="plotChangepoint_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="plotChangepoint_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose=TRUE</code>, expected changepoints are printed.</p>
</td></tr>
<tr><td><code id="plotChangepoint_+3A_start">start</code></td>
<td>
<p>The time of the first observation to be shown in the time
series plot.</p>
</td></tr>
<tr><td><code id="plotChangepoint_+3A_overlay">overlay</code></td>
<td>
<p>If <code>overlay=TRUE</code>, the probability of each regime change is
drawn separately, which will be useful to draw multiple plots in one screen.
See the example in <code>MCMCpoissonChange</code>. Otherwise, multiple plots of
regime change probabilities will be drawn.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCpoissonChange">MCMCpoissonChange</a></code>, <code><a href="#topic+MCMCbinaryChange">MCMCbinaryChange</a></code>
</p>

<hr>
<h2 id='plotHDPChangepoint'>Posterior Changepoint Probabilities from HDP-HMM</h2><span id='topic+plotHDPChangepoint'></span>

<h3>Description</h3>

<p>Plot the posterior density of regime change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHDPChangepoint(
  mcmcout,
  main = "Posterior Changepoint Probabilities",
  xlab = "Time",
  ylab = "",
  start = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHDPChangepoint_+3A_mcmcout">mcmcout</code></td>
<td>
<p>The <code>mcmc</code> object containing the posterior density
sample from a changepoint model. Note that this must be from a
HDP-HMM sampler.</p>
</td></tr>
<tr><td><code id="plotHDPChangepoint_+3A_main">main</code></td>
<td>
<p>Title of the plot</p>
</td></tr>
<tr><td><code id="plotHDPChangepoint_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="plotHDPChangepoint_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="plotHDPChangepoint_+3A_start">start</code></td>
<td>
<p>The time of the first observation to be shown in the time
series plot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HDPHMMpoisson">HDPHMMpoisson</a></code>, <code><a href="#topic+HDPHMMnegbin">HDPHMMnegbin</a></code>, <code><a href="#topic+HDPHSMMnegbin">HDPHSMMnegbin</a></code>
</p>

<hr>
<h2 id='plotState'>Changepoint State Plot</h2><span id='topic+plotState'></span>

<h3>Description</h3>

<p>Plot the posterior probability that each time point is in each state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotState(
  mcmcout,
  main = "Posterior Regime Probability",
  ylab = expression(paste("Pr(", S[t], "= k |", Y[t], ")")),
  legend.control = NULL,
  cex = 0.8,
  lwd = 1.2,
  start = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotState_+3A_mcmcout">mcmcout</code></td>
<td>
<p>The <code>mcmc</code> object containing the posterior density
sample from a changepoint model.  Note that this must have a
<code>prob.state</code> attribute.</p>
</td></tr>
<tr><td><code id="plotState_+3A_main">main</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="plotState_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="plotState_+3A_legend.control">legend.control</code></td>
<td>
<p>Control the location of the legend.  It is necessary
to pass both the x and y locations; i.e., <code>c(x,y)</code>.</p>
</td></tr>
<tr><td><code id="plotState_+3A_cex">cex</code></td>
<td>
<p>Control point size.</p>
</td></tr>
<tr><td><code id="plotState_+3A_lwd">lwd</code></td>
<td>
<p>Line width parameter.</p>
</td></tr>
<tr><td><code id="plotState_+3A_start">start</code></td>
<td>
<p>The time of the first observation to be shown in the time
series plot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCpoissonChange">MCMCpoissonChange</a></code>, <code><a href="#topic+MCMCbinaryChange">MCMCbinaryChange</a></code>
</p>

<hr>
<h2 id='PostProbMod'>Calculate Posterior Probability of Model</h2><span id='topic+PostProbMod'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>BayesFactor</code> and
calculates the posterior probability that each model under study is
correct given that one of the models under study is correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PostProbMod(BF, prior.probs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PostProbMod_+3A_bf">BF</code></td>
<td>
<p>An object of class <code>BayesFactor</code>.</p>
</td></tr>
<tr><td><code id="PostProbMod_+3A_prior.probs">prior.probs</code></td>
<td>
<p>The prior probabilities that each model is
correct. Can be either a scalar or array. Must be positive. If
the sum of the prior probabilities is not equal to 1 prior.probs
will be normalized so that it does sum to unity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array holding the posterior probabilities that each
model under study is correct given that one of the models under
study is correct.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCregress">MCMCregress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(birthwt)

post1 &lt;- MCMCregress(bwt~age+lwt+as.factor(race) + smoke + ht,
                     data=birthwt, b0=c(2700, 0, 0, -500, -500,
                                        -500, -500),
                     B0=c(1e-6, .01, .01, 1.6e-5, 1.6e-5, 1.6e-5,
                          1.6e-5), c0=10, d0=4500000,
                     marginal.likelihood="Chib95", mcmc=10000)

post2 &lt;- MCMCregress(bwt~age+lwt+as.factor(race) + smoke,
                     data=birthwt, b0=c(2700, 0, 0, -500, -500,
                                        -500),
                     B0=c(1e-6, .01, .01, 1.6e-5, 1.6e-5, 1.6e-5),
                     c0=10, d0=4500000,
                     marginal.likelihood="Chib95", mcmc=10000)

post3 &lt;- MCMCregress(bwt~as.factor(race) + smoke + ht,
                     data=birthwt, b0=c(2700, -500, -500,
                                        -500, -500),
                     B0=c(1e-6, 1.6e-5, 1.6e-5, 1.6e-5,
                          1.6e-5), c0=10, d0=4500000,
                     marginal.likelihood="Chib95", mcmc=10000)

BF &lt;- BayesFactor(post1, post2, post3)
mod.probs &lt;- PostProbMod(BF)
print(mod.probs)

## End(Not run)

</code></pre>

<hr>
<h2 id='procrustes'>Procrustes Transformation</h2><span id='topic+procrustes'></span>

<h3>Description</h3>

<p>This function performs a Procrustes transformation on a matrix <code>X</code> to
minimize the squared distance between <code>X</code> and another matrix
<code>Xstar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procrustes(X, Xstar, translation = FALSE, dilation = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procrustes_+3A_x">X</code></td>
<td>
<p>The matrix to be transformed.</p>
</td></tr>
<tr><td><code id="procrustes_+3A_xstar">Xstar</code></td>
<td>
<p>The target matrix.</p>
</td></tr>
<tr><td><code id="procrustes_+3A_translation">translation</code></td>
<td>
<p>logical value indicating whether <code>X</code> should be
translated.</p>
</td></tr>
<tr><td><code id="procrustes_+3A_dilation">dilation</code></td>
<td>
<p>logical value indicating whether <code>X</code> should be dilated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R</code>, <code>tt</code>, and <code>s</code> are chosen so that:
</p>
<p style="text-align: center;"><code class="reqn">s X R + 1 tt' \approx X^*</code>
</p>

<p><code>X.new</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">X_{new} = s X R + 1 tt'</code>
</p>



<h3>Value</h3>

<p>A list containing: <code>X.new</code> the matrix that is the Procrustes
transformed version of <code>X</code>, <code>R</code> the rotation matrix, <code>tt</code> the
translation vector, and <code>s</code> the scale factor.
</p>


<h3>References</h3>

<p>Borg and Groenen. 1997. <em>Modern Multidimensional Scaling</em>.
New York: Springer. pp. 340-342.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCirtKd">MCMCirtKd</a></code>
</p>

<hr>
<h2 id='read.Scythe'>Read a Matrix from a File written by Scythe</h2><span id='topic+read.Scythe'></span>

<h3>Description</h3>

<p>This function reads a matrix from an ASCII file in the form produced by the
Scythe Statistical Library.  Scythe output files contain the number of rows
and columns in the first row, followed by the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.Scythe(infile = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.Scythe_+3A_infile">infile</code></td>
<td>
<p>The file to be read. This can include path information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the data stored in the read file.
</p>


<h3>References</h3>

<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.
<em>Scythe Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.Scythe">write.Scythe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  mymatrix &lt;- read.Scythe("myfile.txt")
  
## End(Not run)

</code></pre>

<hr>
<h2 id='Rehnquist'>U.S. Supreme Court Vote Matrix, Rehnquist Court (1994-2004)</h2><span id='topic+Rehnquist'></span>

<h3>Description</h3>

<p>This dataframe contains a matrix of votes cast by U.S. Supreme Court
justices by all cases in the 1994-2004 terms.
</p>


<h3>Format</h3>

<p>The dataframe has contains data for justices Rehnquist, Stevens,
O'Connor, Scalia, Kennedy, Souter, Thomas, Ginsburg, and Breyer for the
1994-2004 terms of the U.S. Supreme Court.  The dataframe also contains the
term of the case, and a time variable that counts from term 1 to 11.  The
votes are coded liberal (1) and conservative (0) using the protocol of
Spaeth (2003).  The unit of analysis is the case citation (ANALU=0).  We are
concerned with formally decided cases issued with written opinions, after
full oral argument and cases decided by an equally divided vote
(DECTYPE=1,5,6,7).
</p>


<h3>Source</h3>

<p>Harold J. Spaeth. 2005. <em>Original United States Supreme Court
Database: 1953-2004 Terms.</em>
</p>

<hr>
<h2 id='Senate'>106th U.S. Senate Roll Call Vote Matrix</h2><span id='topic+Senate'></span>

<h3>Description</h3>

<p>This dataframe contains a matrix of votes cast by U.S. Senators in the 106th
Congress.
</p>


<h3>Format</h3>

<p>The dataframe contains roll call data for all Senators in the 106th
Senate.  The first column (id) is the ICPSR member ID number, the second
column (statecode) is the ICPSR state code, the third column (party) is the
member's state name, and the fourth column (member) is the member's name.
This is followed by all roll call votes (including unanimous ones) in the
106th.  Nay votes are coded 0, yea votes are coded 1, and NAs are missing
votes.
</p>


<h3>Source</h3>

<p>Keith Poole. 2005. <em>106th Roll Call Vote Data</em>.
</p>

<hr>
<h2 id='SSVSquantreg'>Stochastic search variable selection for quantile regression</h2><span id='topic+SSVSquantreg'></span>

<h3>Description</h3>

<p>This function uses stochastic search to select promising regression models
at a fixed quantile <code class="reqn">\tau</code>.  Indicator variables
<code class="reqn">\gamma</code> are used to represent whether a predictor is included in
the model or not.  The user supplies the data and the prior distribution on
the model size.  A list is returned containing the posterior sample of
<code class="reqn">\gamma</code> and the associated regression parameters
<code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSVSquantreg(
  formula,
  data = NULL,
  tau = 0.5,
  include = NULL,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = sample(1:1e+06, 1),
  pi0a0 = 1,
  pi0b0 = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSVSquantreg_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_tau">tau</code></td>
<td>
<p>The quantile of interest. Must be between 0 and 1. The default
value of 0.5 corresponds to median regression model selection.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_include">include</code></td>
<td>
<p>The predictor(s) that should definitely appear in the model.
Can be specified by name, or their position in the formula (taking into
account the intercept).</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the most recently sampled values of <code class="reqn">\gamma</code>
and the associated values of <code class="reqn">\beta</code> are printed to the screen
every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator. If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister. The default value for this argument
is a random integer between 1 and 1,000,000.  This default value ensures
that if the function is used again with a different value of
<code class="reqn">\tau</code>, it is extremely unlikely that the seed will be identical.
The user can also pass a list of length two to use the L'Ecuyer random
number generator, which is suitable for parallel computation.  The first
element of the list is the L'Ecuyer seed, which is a vector of length six or
NA (if NA a default seed of <code>rep(12345,6)</code> is used).  The second
element of list is a positive substream number. See the MCMCpack
specification for more details.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_pi0a0">pi0a0</code>, <code id="SSVSquantreg_+3A_pi0b0">pi0b0</code></td>
<td>
<p>Hyperparameters of the beta prior on <code class="reqn">\pi_0</code>,
the prior probability of including a predictor. Default values of (1,1) are
equivalent to a uniform distribution.</p>
</td></tr>
<tr><td><code id="SSVSquantreg_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SSVSquantreg</code> implements stochastic search variable selection
over a set of potential predictors to obtain promising models.  The
models considered take the following form:
</p>
<p style="text-align: center;"><code class="reqn">Q_{\tau}(y_i|x_{i\gamma}) = x_{i\gamma} ' \beta_{\gamma},</code>
</p>

<p>where <code class="reqn">Q_{\tau}(y_i|x_{i\gamma})</code> denotes the conditional
<code class="reqn">\tau</code>th quantile of <code class="reqn">y_i</code> given <code class="reqn">x_{i\gamma}</code>,
<code class="reqn">x_{i\gamma}</code> denotes <code class="reqn">x_i</code> with those predictors
<code class="reqn">x_{ij}</code> for which <code class="reqn">\gamma_j=0</code> removed and
<code class="reqn">\beta_{\gamma}</code> denotes the model specific regression
parameters.
</p>
<p>The likelihood is formed based on the assumption of independent
asymmetric Laplace distributions on the <code class="reqn">y_i</code> with skewness
parameter <code class="reqn">\tau</code> and location parameters <code class="reqn"> x_{i\gamma} '
\beta_{\gamma}</code>. This assumption ensures that the likelihood
function is maximised by the <code class="reqn">\tau</code>th conditional quantile of
the response variable.
</p>
<p>The prior on each <code class="reqn">\beta_j</code> is
</p>
<p style="text-align: center;"><code class="reqn">(1-\gamma_j)\delta_0+\gamma_j\mbox{Cauchy}(0,1),</code>
</p>

<p>where <code class="reqn">\delta_0</code> denotes a degenerate distribution with all
mass at 0.  A standard Cauchy distribution is chosen conditional on
<code class="reqn">\gamma_j=1</code>.  This allows for a wider range of nonzero
values of <code class="reqn">\beta_j</code> than a standard Normal distribution,
improving the robustness of the method.  Each of the indicator variables
<code class="reqn">\gamma_j</code> is independently assigned a Bernoulli prior, with
prior probability of inclusion <code class="reqn">\pi_0</code>.  This in turn is assigned
a beta distribution, resulting in a beta-binomial prior on the model size.
The user can supply the hyperparameters for the beta distribution.  Starting
values are randomly generated from the prior distribution.
</p>
<p>It is recommended to standardise any non-binary predictors in order to
compare these predictors on the same scale.  This can be achieved using the
<code>scale</code> function.
</p>
<p>If it is certain that a predictor should be included, all predictors
specified are brought to the first positions for computational convenience.
The regression parameters associated with these predictors are given
independent improper priors. Users may notice a small speed advantage if
they specify the predictors that they feel certain should appear in the
model, particularly for large models with a large number of observations.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>gamma</code></td>
<td>
<p>The posterior sample of <code class="reqn">\gamma</code>. This has
associated summary and plot methods.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The posterior sample of the associated regression parameters
<code class="reqn">\beta</code>. This can be analysed with functions from the coda
package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Craig Reed
</p>


<h3>References</h3>

<p>Craig Reed, David B. Dunson and Keming Yu. 2010. &quot;Bayesian
Variable Selection for Quantile Regression&quot; Technical Report.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.2.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>
<p>Keming Yu and Jin Zhang. 2005. &quot;A Three Parameter Asymmetric Laplace
Distribution and it's extensions.&quot; <em>Communications in Statistics -
Theory and Methods</em>, 34, 1867-1879.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  &ldquo;Output
Analysis and Diagnostics for MCMC (CODA)&rdquo;, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCquantreg">MCMCquantreg</a></code>,
<code><a href="#topic+summary.qrssvs">summary.qrssvs</a></code>, <code><a href="#topic+plot.qrssvs">plot.qrssvs</a></code>,
<code><a href="#topic+mptable">mptable</a></code>, <code><a href="#topic+topmodels">topmodels</a></code>,
<code><a href="base.html#topic+scale">scale</a></code>, <code><a href="quantreg.html#topic+rq">rq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(1)
epsilon&lt;-rnorm(100)
set.seed(2)
x&lt;-matrix(rnorm(1000),100,10)
y&lt;-x[,1]+x[,10]+epsilon
qrssvs&lt;-SSVSquantreg(y~x)
model.50pc&lt;-SSVSquantreg(y~x)
model.90pc&lt;-SSVSquantreg(y~x,tau=0.9)
summary(model.50pc) ## Intercept not in median probability model
summary(model.90pc) ## Intercept appears in median probability model

## End(Not run)

</code></pre>

<hr>
<h2 id='summaryqrssvs'>Summarising the results of quantile regression stochastic search variable
selection (QR-SSVS).</h2><span id='topic+summaryqrssvs'></span><span id='topic+summary.qrssvs'></span><span id='topic+print.summary.qrssvs'></span>

<h3>Description</h3>

<p>This function produces a table of predictors and their associated marginal
posterior probability of inclusion. It also returns the median probability
model (see the details section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrssvs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryqrssvs_+3A_object">object</code></td>
<td>
<p>An object of class <code>qrssvs</code>. Typically this will be the
<code>gamma</code> component of the list returned by <code>SSVSquantreg</code>.</p>
</td></tr>
<tr><td><code id="summaryqrssvs_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The median probability model is defined to be the model that contains any
predictor with marginal posterior probability greater than or equal to 0.5.
If the goal is to select a single model e.g. for prediction, Barbieri and
Berger (2004) recommend the median probability model. In some cases, this
will coincide with the maximum probability model.
</p>


<h3>Author(s)</h3>

<p>Craig Reed
</p>


<h3>References</h3>

<p>Maria M. Barbieri, and James O. Berger (2004). &quot;Optimal predictive model
selection&quot;. <em>Annals of Statistics</em>, 32, 870-897.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SSVSquantreg">SSVSquantreg</a></code>,
<code><a href="#topic+mptable">mptable</a></code>, <code><a href="#topic+topmodels">topmodels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1)
epsilon&lt;-rnorm(100)
set.seed(2)
x&lt;-matrix(rnorm(1000),100,10)
y&lt;-x[,1]+x[,10]+epsilon
qrssvs&lt;-SSVSquantreg(y~x)
summary(qrssvs$gamma)

## End(Not run)

</code></pre>

<hr>
<h2 id='SupremeCourt'>U.S. Supreme Court Vote Matrix</h2><span id='topic+SupremeCourt'></span>

<h3>Description</h3>

<p>This dataframe contains a matrix votes cast by U.S. Supreme Court justices
in all cases in the 2000 term.
</p>


<h3>Format</h3>

<p>The dataframe has contains data for justices Rehnquist, Stevens,
O'Connor, Scalia, Kennedy, Souter, Thomas, Ginsburg, and Breyer for the 2000
term of the U.S. Supreme Court.  It contains data from 43 non-unanimous
cases. The votes are coded liberal (1) and conservative (0) using the
protocol of Spaeth (2003).  The unit of analysis is the case citation
(ANALU=0).  We are concerned with formally decided cases issued with written
opinions, after full oral argument and cases decided by an equally divided
vote (DECTYPE=1,5,6,7).
</p>


<h3>Source</h3>

<p>Harold J. Spaeth. 2005. <em>Original United States Supreme Court
Database: 1953-2004 Terms.</em> <a href="http://supremecourtdatabase.org">http://supremecourtdatabase.org</a>.
</p>

<hr>
<h2 id='testpanelGroupBreak'>A Test for the Group-level Break using a Multivariate Linear Regression
Model with Breaks</h2><span id='topic+testpanelGroupBreak'></span>

<h3>Description</h3>

<p>testpanelGroupBreak fits a multivariate linear regression model with
parametric breaks using panel residuals to test the existence of group-level
breaks in panel residuals. The details are discussed in Park (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testpanelGroupBreak(
  subject.id,
  time.id,
  resid,
  m = 1,
  mcmc = 1000,
  burnin = 1000,
  thin = 1,
  verbose = 0,
  b0,
  B0,
  c0,
  d0,
  a = NULL,
  b = NULL,
  seed = NA,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testpanelGroupBreak_+3A_subject.id">subject.id</code></td>
<td>
<p>A numeric vector indicating the group number. It should
start from 1.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_time.id">time.id</code></td>
<td>
<p>A numeric vector indicating the time unit. It should start
from 1.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_resid">resid</code></td>
<td>
<p>A vector of panel residuals</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_m">m</code></td>
<td>
<p>The number of changepoints.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burn-in.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0, the
iteration number and the posterior density samples are printed to the screen
every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_b0">b0</code></td>
<td>
<p>The prior mean of the residual mean.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_b0">B0</code></td>
<td>
<p>The prior precision of the residual variance</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code>. The amount of information in the inverse
Gamma prior is something like that from <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, current R
system seed is used.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated and <code>Chib95</code> in which case the method of Chib (1995) is
used.</p>
</td></tr>
<tr><td><code id="testpanelGroupBreak_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>testpanelGroupBreak</code> fits a multivariate linear regression model with
parametric breaks using panel residuals to detect the existence of
system-level breaks in unobserved factors as discussed in Park (2011).
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">e_{i} \sim \mathcal{N}(\beta_{m}, \sigma^2_m I)\;\; m = 1, \ldots, M</code>
</p>

<p>We assume standard, semi-conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b0, B0)</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2} \sim \mathcal{G}amma(c_0/2, d_0/2)</code>
</p>

<p>Where <code class="reqn">\beta</code> and <code class="reqn">\sigma^{-2}</code> are
assumed <em>a priori</em> independent.
</p>
<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This object can
be summarized by functions provided by the coda package.  The object
contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period, and the log-marginal
likelihood of the model (<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park, 2012. &ldquo;Unified Method for Dynamic and
Cross-Sectional Heterogeneity: Introducing Hidden Markov Panel Models.&rdquo;
<em>American Journal of Political Science</em>.56: 1040-1054.
&lt;doi: 10.1111/j.1540-5907.2012.00590.x&gt;
</p>
<p>Siddhartha Chib. 1998. &ldquo;Estimation and comparison of multiple change-point
models.&rdquo; <em>Journal of Econometrics</em>. 86: 221-241.
&lt;doi: 10.1080/01621459.1995.10476635&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
   ## data generating
  set.seed(1977)
  Q &lt;- 3
  true.beta1   &lt;-  c(1, 1, 1) ; true.beta2   &lt;-  c(1, -1, -1)
  true.sigma2 &lt;-  c(1, 3); true.D1 &lt;- diag(.5, Q); true.D2 &lt;- diag(2.5, Q)
  N=20; T=100;
  NT &lt;- N*T
  x1 &lt;- rnorm(NT)
  x2 &lt;- runif(NT, 5, 10)
  X &lt;- cbind(1, x1, x2);   W &lt;- X;   y &lt;- rep(NA, NT)

  ## true break numbers are one and at the center
  break.point = rep(T/2, N); break.sigma=c(rep(1, N));
  break.list &lt;- rep(1, N)
  id  &lt;-  rep(1:N, each=NT/N)
  K &lt;-  ncol(X);
  ruler &lt;- c(1:T)

  ## compute the weight for the break
  W.mat &lt;- matrix(NA, T, N)
  for (i in 1:N){
    W.mat[, i] &lt;- pnorm((ruler-break.point[i])/break.sigma[i])
  }
  Weight &lt;- as.vector(W.mat)

  ## data generating by weighting two means and variances
  j = 1
  for (i in 1:N){
    Xi &lt;- X[j:(j+T-1), ]
    Wi &lt;- W[j:(j+T-1), ]
    true.V1 &lt;- true.sigma2[1]*diag(T) + Wi%*%true.D1%*%t(Wi)
    true.V2 &lt;- true.sigma2[2]*diag(T) + Wi%*%true.D2%*%t(Wi)
    true.mean1 &lt;- Xi%*%true.beta1
    true.mean2 &lt;- Xi%*%true.beta2
    weight &lt;- Weight[j:(j+T-1)]
    y[j:(j+T-1)] &lt;- (1-weight)*true.mean1 + (1-weight)*chol(true.V1)%*%rnorm(T) +
      weight*true.mean2 + weight*chol(true.V2)%*%rnorm(T)
    j &lt;- j + T
  }
  ## model fitting
  subject.id &lt;- c(rep(1:N, each=T))
  time.id &lt;- c(rep(1:T, N))


  resid &lt;- rstandard(lm(y ~X-1 + as.factor(subject.id)))
  G &lt;- 100
  out0 &lt;- testpanelGroupBreak(subject.id, time.id, resid, m=0,
           mcmc=G, burnin=G, thin=1, verbose=G,
           b0=0, B0=1/100, c0=2, d0=2, marginal.likelihood = "Chib95")
  out1 &lt;- testpanelGroupBreak(subject.id, time.id, resid, m=1,
           mcmc=G, burnin=G, thin=1, verbose=G,
           b0=0, B0=1/100, c0=2, d0=2, marginal.likelihood = "Chib95")
  out2 &lt;- testpanelGroupBreak(subject.id, time.id, resid, m=2,
           mcmc=G, burnin=G, thin=1, verbose=G,
           b0=0, B0=1/100, c0=2, d0=2, marginal.likelihood = "Chib95")
  out3 &lt;- testpanelGroupBreak(subject.id, time.id, resid, m=3,
           mcmc=G, burnin=G, thin=1, verbose=G,
           b0=0, B0=1/100, c0=2, d0=2, marginal.likelihood = "Chib95")

  ## Note that the code is for a hypothesis test of no break in panel residuals.
  ## When breaks exist, the estimated number of break in the mean and variance of panel residuals
  ## tends to be larger than the number of break in the data generating process.
  ## This is due to the difference in parameter space, not an error of the code.
  BayesFactor(out0, out1, out2, out3)

  ## In order to identify the number of breaks in panel parameters,
  ## use HMMpanelRE() instead.


## End(Not run)

</code></pre>

<hr>
<h2 id='testpanelSubjectBreak'>A Test for the Subject-level Break using a Unitivariate Linear Regression
Model with Breaks</h2><span id='topic+testpanelSubjectBreak'></span>

<h3>Description</h3>

<p>testpanelSubjectBreak fits a unitivariate linear regression model with
parametric breaks using panel residuals to test the existence of
subject-level breaks in panel residuals. The details are discussed in Park
(2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testpanelSubjectBreak(
  subject.id,
  time.id,
  resid,
  max.break = 2,
  minimum = 10,
  mcmc = 1000,
  burnin = 1000,
  thin = 1,
  verbose = 0,
  b0,
  B0,
  c0,
  d0,
  a = NULL,
  b = NULL,
  seed = NA,
  Time = NULL,
  ps.out = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testpanelSubjectBreak_+3A_subject.id">subject.id</code></td>
<td>
<p>A numeric vector indicating the group number. It should
start from 1.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_time.id">time.id</code></td>
<td>
<p>A numeric vector indicating the time unit. It should start
from 1.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_resid">resid</code></td>
<td>
<p>A vector of panel residuals.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_max.break">max.break</code></td>
<td>
<p>An upper bound of break numbers for the test.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_minimum">minimum</code></td>
<td>
<p>A minimum length of time series for the test. The test will
skip a subject with a time series shorter than this.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burn-in.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0, the
iteration number and the posterior density samples are printed to the screen
every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_b0">b0</code></td>
<td>
<p>The prior mean of the residual mean.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_b0">B0</code></td>
<td>
<p>The prior precision of the residual variance</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_c0">c0</code></td>
<td>
<p><code class="reqn">c_0/2</code> is the shape parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code>. The amount of information in the inverse
Gamma prior is something like that from <code class="reqn">c_0</code> pseudo-observations.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_d0">d0</code></td>
<td>
<p><code class="reqn">d_0/2</code> is the scale parameter for the inverse Gamma
prior on <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, current R
system seed is used.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_time">Time</code></td>
<td>
<p>Times of the observations. This will be used to find the time of
the first observations in panel residuals.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_ps.out">ps.out</code></td>
<td>
<p>If ps.out == TRUE, state probabilities are exported. If the
number of panel subjects is huge, users can turn it off to save memory.</p>
</td></tr>
<tr><td><code id="testpanelSubjectBreak_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>testpanelSubjectBreak</code> fits a univariate linear regression model for
subject-level residuals from a panel model.  The details are discussed in
Park (2011).
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">e_{it} = \alpha_{im} + \varepsilon_{it}\;\; m = 1, \ldots, M</code>
</p>

<p>The errors are assumed to be time-varying at the subject level:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{it} \sim \mathcal{N}(0, \sigma^2_{im})</code>
</p>

<p>We assume standard, semi-conjugate priors:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^{-2} \sim \mathcal{G}amma(c_0/2, d_0/2)</code>
</p>

<p>Where <code class="reqn">\beta</code> and <code class="reqn">\sigma^{-2}</code> are assumed <em>a priori</em>
independent.
</p>
<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>
<p>OLS estimates are used for starting values.
</p>


<h3>Value</h3>

<p>The returned object is a matrix containing log marginal likelihoods
for all HMMs.  The dimension of the returned object is the number of panel
subjects by max.break + 1.  If psout == TRUE, the returned object has an
array attribute <code>psout</code> containing state probabilities for all HMMs.
</p>


<h3>References</h3>

<p>Jong Hee Park, 2012. &ldquo;Unified Method for Dynamic and
Cross-Sectional Heterogeneity: Introducing Hidden Markov Panel Models.&rdquo;
<em>American Journal of Political Science</em>.56: 1040-1054.
&lt;doi: 10.1111/j.1540-5907.2012.00590.x&gt;
</p>
<p>Siddhartha Chib. 1998. &ldquo;Estimation and comparison of multiple change-point
models.&rdquo; <em>Journal of Econometrics</em>. 86: 221-241.
&lt;doi: 10.1080/01621459.1995.10476635&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  set.seed(1974)
  N &lt;- 30
  T &lt;- 80
  NT &lt;- N*T

  ## true parameter values
  true.beta &lt;- c(1, 1)
  true.sigma &lt;- 3
  x1 &lt;- rnorm(NT)
  x2 &lt;- runif(NT, 2, 4)

  ## group-specific breaks
  break.point = rep(T/2, N); break.sigma=c(rep(1, N));
  break.list &lt;- rep(1, N)

  X &lt;- as.matrix(cbind(x1, x2), NT, );
  y &lt;- rep(NA, NT)
  id  &lt;-  rep(1:N, each=NT/N)
  K &lt;-  ncol(X);
  true.beta &lt;- as.matrix(true.beta, K, 1)

  ## compute the break probability
  ruler &lt;- c(1:T)
  W.mat &lt;- matrix(NA, T, N)
  for (i in 1:N){
    W.mat[, i] &lt;- pnorm((ruler-break.point[i])/break.sigma[i])
  }
  Weight &lt;- as.vector(W.mat)

  ## draw time-varying individual effects and sample y
  j = 1
  true.sigma.alpha &lt;- 30
  true.alpha1 &lt;- true.alpha2 &lt;- rep(NA, N)
  for (i in 1:N){
    Xi &lt;- X[j:(j+T-1), ]
    true.mean &lt;- Xi  %*% true.beta
    weight &lt;- Weight[j:(j+T-1)]
    true.alpha1[i] &lt;- rnorm(1, 0, true.sigma.alpha)
    true.alpha2[i] &lt;- -1*true.alpha1[i]
    y[j:(j+T-1)] &lt;- ((1-weight)*true.mean + (1-weight)*rnorm(T, 0, true.sigma) +
    		    (1-weight)*true.alpha1[i]) +
    		    (weight*true.mean + weight*rnorm(T, 0, true.sigma) + weight*true.alpha2[i])
    j &lt;- j + T
  }

  ## extract the standardized residuals from the OLS with fixed-effects
  FEols &lt;- lm(y ~ X + as.factor(id) -1 )
  resid.all &lt;- rstandard(FEols)
  time.id &lt;- rep(1:80, N)

  ## model fitting
  G &lt;- 1000
  BF &lt;- testpanelSubjectBreak(subject.id=id, time.id=time.id,
         resid= resid.all, max.break=3, minimum = 10,
         mcmc=G, burnin = G, thin=1, verbose=G,
         b0=0, B0=1/100, c0=2, d0=2, Time = time.id)

  ## estimated break numbers
  ## thresho
  estimated.breaks &lt;- make.breaklist(BF, threshold=3)

  ## print all posterior model probabilities
  print(attr(BF, "model.prob"))

## End(Not run)

</code></pre>

<hr>
<h2 id='tomogplot'>Tomography Plot</h2><span id='topic+tomogplot'></span>

<h3>Description</h3>

<p>tomogplot is used to produce a tomography plot (see King, 1997) for a series
of partially observed 2 x 2 contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tomogplot(
  r0,
  r1,
  c0,
  c1,
  xlab = "fraction of r0 in c0 (p0)",
  ylab = "fraction of r1 in c0 (p1)",
  bgcol = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tomogplot_+3A_r0">r0</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of row sums from
row 0.</p>
</td></tr>
<tr><td><code id="tomogplot_+3A_r1">r1</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of row sums from
row 1.</p>
</td></tr>
<tr><td><code id="tomogplot_+3A_c0">c0</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of column sums
from column 0.</p>
</td></tr>
<tr><td><code id="tomogplot_+3A_c1">c1</code></td>
<td>
<p>An <code class="reqn">(ntables \times 1)</code> vector of column sums
from column 1.</p>
</td></tr>
<tr><td><code id="tomogplot_+3A_xlab">xlab</code></td>
<td>
<p>The x axis label for the plot.</p>
</td></tr>
<tr><td><code id="tomogplot_+3A_ylab">ylab</code></td>
<td>
<p>The y axis label for the plot.</p>
</td></tr>
<tr><td><code id="tomogplot_+3A_bgcol">bgcol</code></td>
<td>
<p>The background color for the plot.</p>
</td></tr>
<tr><td><code id="tomogplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the following partially observed 2 by 2 contingency table:
</p>

<table>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> | <code class="reqn">Y=0</code> </td><td style="text-align: left;"> | <code class="reqn">Y=1</code> </td><td style="text-align: left;"> |           </td>
</tr>
<tr>
 <td style="text-align: left;">
 --------- </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">X=0</code> </td><td style="text-align: left;"> | <code class="reqn">Y_0</code> </td><td style="text-align: left;"> |           </td><td style="text-align: left;"> | <code class="reqn">r_0</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 --------- </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">X=1</code> </td><td style="text-align: left;"> | <code class="reqn">Y_1</code> </td><td style="text-align: left;"> |           </td><td style="text-align: left;"> | <code class="reqn">r_1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 --------- </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td><td style="text-align: left;"> ---------   </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> | <code class="reqn">c_0</code> </td><td style="text-align: left;"> | <code class="reqn">c_1</code> </td><td style="text-align: left;"> | <code class="reqn">N</code>
</td>
</tr>

</table>

<p>where <code class="reqn">r_0</code>, <code class="reqn">r_1</code>, <code class="reqn">c_0</code>, <code class="reqn">c_1</code>, and <code class="reqn">N</code> are
non-negative integers that are observed. The interior cell entries
are not observed. It is assumed that <code class="reqn">Y_0|r_0 \sim
\mathcal{B}inomial(r_0, p_0)</code> and <code class="reqn">Y_1|r_1 \sim
\mathcal{B}inomial(r_1, p_1)</code>.
</p>
<p>This function plots the bounds on the maximum likelihood estimatess for (p0,
p1).
</p>


<h3>References</h3>

<p>Gary King, 1997. <em>A Solution to the Ecological Inference
Problem</em>.  Princeton: Princeton University Press.
</p>
<p>Jonathan C. Wakefield. 2004. &ldquo;Ecological Inference for 2 x 2 Tables.&rdquo;
<em>Journal of the Royal Statistical Society, Series A</em>. 167(3): 385445.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMChierEI">MCMChierEI</a></code>, <code><a href="#topic+MCMCdynamicEI">MCMCdynamicEI</a></code>,
<code><a href="#topic+dtomogplot">dtomogplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r0 &lt;- rpois(100, 500)
r1 &lt;- rpois(100, 200)
c0 &lt;- rpois(100, 100)
c1 &lt;- (r0 + r1) - c0
tomogplot(r0, r1, c0, c1)

</code></pre>

<hr>
<h2 id='topmodels'>Shows an ordered list of the most frequently visited models sampled during
quantile regression stochastic search variable selection (QR-SSVS).</h2><span id='topic+topmodels'></span>

<h3>Description</h3>

<p>Given output from quantile regression stochastic search variable selection,
this function returns a table of the 'best' models together with their
associated empirical posterior probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topmodels(qrssvs, nmodels = 5, abbreviate = FALSE, minlength = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topmodels_+3A_qrssvs">qrssvs</code></td>
<td>
<p>An object of class <code>qrssvs</code>. Typically this will be the
<code>gamma</code> component of the list returned by <code>SSVSquantreg</code>.</p>
</td></tr>
<tr><td><code id="topmodels_+3A_nmodels">nmodels</code></td>
<td>
<p>The number of models to tabulate.</p>
</td></tr>
<tr><td><code id="topmodels_+3A_abbreviate">abbreviate</code></td>
<td>
<p>Logical: should the names of the predictors be
abbreviated?</p>
</td></tr>
<tr><td><code id="topmodels_+3A_minlength">minlength</code></td>
<td>
<p>If <code>abbreviate</code> is set to <code>TRUE</code>, the minimum
length of the abbreviations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with the models and their associated posterior probability.
The models are arranged in descending order of probability.
</p>


<h3>Author(s)</h3>

<p>Craig Reed
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SSVSquantreg">SSVSquantreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1)
epsilon&lt;-rnorm(100)
set.seed(2)
x&lt;-matrix(rnorm(1000),100,10)
y&lt;-x[,1]+x[,10]+epsilon
qrssvs&lt;-SSVSquantreg(y~x)
topmodels(qrssvs$gamma)

## End(Not run)

</code></pre>

<hr>
<h2 id='vech'>Extract Lower Triangular Elements from a Symmetric Matrix</h2><span id='topic+vech'></span>

<h3>Description</h3>

<p>This function takes a symmetric matrix and extracts a list of all lower
triangular elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vech_+3A_x">x</code></td>
<td>
<p>A symmetric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks to make sure the matrix is square, but it does not
check for symmetry (it just pulls the lower triangular elements).  The
elements are stored in column major order.  The original matrix can be
restored using the <code>xpnd</code> command.
</p>


<h3>Value</h3>

<p>A list of the lower triangular elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xpnd">xpnd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   symmat &lt;- matrix(c(1,2,3,4,2,4,5,6,3,5,7,8,4,6,8,9),4,4)
   vech(symmat)

</code></pre>

<hr>
<h2 id='Wishart'>The Wishart Distribution</h2><span id='topic+Wishart'></span><span id='topic+dwish'></span><span id='topic+rwish'></span>

<h3>Description</h3>

<p>Density function and random generation from the Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwish(v, S)

dwish(W, v, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wishart_+3A_v">v</code></td>
<td>
<p>Degrees of freedom (scalar).</p>
</td></tr>
<tr><td><code id="Wishart_+3A_s">S</code></td>
<td>
<p>Inverse scale matrix <code class="reqn">(p \times p)</code>.</p>
</td></tr>
<tr><td><code id="Wishart_+3A_w">W</code></td>
<td>
<p>Positive definite matrix W <code class="reqn">(p \times p)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of a Wishart random variable with <code>v</code> degrees of freedom and
inverse scale matrix <code>S</code> is <code class="reqn">vS</code>.
</p>


<h3>Value</h3>

<p><code>dwish</code> evaluates the density at positive definite matrix W.
<code>rwish</code> generates one random draw from the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
density &lt;- dwish(matrix(c(2,-.3,-.3,4),2,2), 3, matrix(c(1,.3,.3,1),2,2))
draw &lt;- rwish(3, matrix(c(1,.3,.3,1),2,2))

</code></pre>

<hr>
<h2 id='write.Scythe'>Write a Matrix to a File to be Read by Scythe</h2><span id='topic+write.Scythe'></span>

<h3>Description</h3>

<p>This function writes a matrix to an ASCII file that can be read by the
Sycthe Statistical Library.  Scythe requires that input files contain the
number of rows and columns in the first row, followed by the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.Scythe(outmatrix, outfile = NA, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.Scythe_+3A_outmatrix">outmatrix</code></td>
<td>
<p>The matrix to be written to a file.</p>
</td></tr>
<tr><td><code id="write.Scythe_+3A_outfile">outfile</code></td>
<td>
<p>The file to be written. This can include path information.</p>
</td></tr>
<tr><td><code id="write.Scythe_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical that determines whether an existing file should
be over-written.  By default, it protects the user from over-writing
existing files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A zero if the file is properly written.
</p>


<h3>References</h3>

<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.
<em>Scythe Statistical Library 1.0.</em> <a href="http://scythe.lsa.umich.edu">http://scythe.lsa.umich.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.Scythe">write.Scythe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  write.Scythe(mymatrix, file.path(tempdir(), "myfile.txt"))
  
## End(Not run)

</code></pre>

<hr>
<h2 id='xpnd'>Expand a Vector into a Symmetric Matrix</h2><span id='topic+xpnd'></span>

<h3>Description</h3>

<p>This function takes a vector of appropriate length (typically created using
<code>vech</code>) and creates a symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xpnd(x, nrow = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpnd_+3A_x">x</code></td>
<td>
<p>A list of elements to expand into symmetric matrix.</p>
</td></tr>
<tr><td><code id="xpnd_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows (and columns) in the returned matrix.  Look
into the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly useful when dealing with variance covariance
matrices. Note that R stores matrices in column major order, and that the
items in <code>x</code> will be recycled to fill the matrix if need be.
</p>
<p>The number of rows can be specified or automatically computed from the
number of elements in a given object via <code class="reqn">(-1 + \sqrt{(1 + 8 *
length(x))}) / 2</code>.
</p>


<h3>Value</h3>

<p>An <code class="reqn">(nrows \times nrows)</code> symmetric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vech">vech</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  xpnd(c(1,2,3,4,4,5,6,7,8,9),4)
  xpnd(c(1,2,3,4,4,5,6,7,8,9))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
