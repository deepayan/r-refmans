<!DOCTYPE html><html lang="en"><head><title>Help for package DatastreamR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DatastreamR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DataClient'><p>DataClient</p></a></li>
<li><a href='#DSConnect'><p>initializer</p></a></li>
<li><a href='#DSTimeSeriesCarryIndicator'><p>DSTimeSeriesCarryIndicator</p></a></li>
<li><a href='#DSTimeSeriesDataInput'><p>DSTimeSeriesDataInput</p></a></li>
<li><a href='#DSTimeSeriesDateAlignment'><p>DSTimeSeriesDateAlignment</p></a></li>
<li><a href='#DSTimeSeriesDateInfo'><p>DSTimeSeriesDateInfo</p></a></li>
<li><a href='#DSTimeSeriesDateRange'><p>DSTimeSeriesDateRange</p></a></li>
<li><a href='#DSTimeSeriesDateRangeResponse'><p>DSTimeSeriesDateRangeResponse</p></a></li>
<li><a href='#DSTimeSeriesFrequencyConversion'><p>DSTimeSeriesFrequencyConversion</p></a></li>
<li><a href='#DSTimeSeriesRequestObject'><p>DSTimeSeriesRequestObject</p></a></li>
<li><a href='#DSTimeSeriesResponseObject'><p>DSTimeSeriesResponseObject</p></a></li>
<li><a href='#DSTimeSeriesUserObjectBase'><p>DSTimeSeriesUserObjectBase</p></a></li>
<li><a href='#DSUserObjectAccessRights'><p>Datastream User Object access rights</p></a></li>
<li><a href='#DSUserObjectBase'><p>DSUserObjectBase</p></a></li>
<li><a href='#DSUserObjectFrequency'><p>DSUserObjectFrequency</p></a></li>
<li><a href='#DSUserObjectGetAllResponse'><p>DSUserObjectGetAllResponse</p></a></li>
<li><a href='#DSUserObjectResponse'><p>DSUserObjectResponse</p></a></li>
<li><a href='#DSUserObjectResponseStatus'><p>DSUserObjectResponseStatus</p></a></li>
<li><a href='#DSUserObjectShareTypes'><p>DSUserObjectShareTypes</p></a></li>
<li><a href='#DSUserObjectTypes'><p>DSUserObjectTypes</p></a></li>
<li><a href='#TimeSeriesClient'><p>TimeSeriesClient</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Datastream API</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Access Datastream content through <a href="https://product.datastream.com/dswsclient/Docs/Default.aspx">https://product.datastream.com/dswsclient/Docs/Default.aspx</a>., our historical financial database with over 35 million individual instruments or indicators across all major asset classes, including over 19 million active economic indicators. It features 120 years of data, across 175 countries – the information you need to interpret market trends, economic cycles, and the impact of world events.    Data spans bond indices, bonds, commodities, convertibles, credit default swaps, derivatives, economics, energy, equities, equity indices, ESG, estimates, exchange rates, fixed income, funds, fundamentals, interest rates, and investment trusts. Unique content includes I/B/E/S Estimates, Worldscope Fundamentals, point-in-time data, and Reuters Polls.    Alongside the content, sit a set of powerful analytical tools for exploring relationships between different asset types, with a library of customizable analytical functions.    In-house timeseries can also be uploaded using the package to comingle with Datastream maintained datasets, use with these analytical tools and displayed in Datastream’s flexible charting facilities in Microsoft Office. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>httr, jsonlite, logger, ini, stringr, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Common.R' 'DSConnect.R' 'DSRequests.R' 'DSResponse.R'
'DSUserDataObjectBase.R' 'Datastream.R' 'DatastreamR.R'
'DatastreamUserCreated_TimeSeries.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-09 07:34:05 UTC; ux010740</td>
</tr>
<tr>
<td>Author:</td>
<td>LSEG (Datastream) [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>LSEG (Datastream) &lt;datastreamapi@lseg.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 11:03:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='DataClient'>DataClient</h2><span id='topic+DataClient'></span>

<h3>Description</h3>

<p>An RC class for accessing Datastream content through Datastream Web services API
</p>


<h3>Value</h3>

<p>DataClient object
</p>


<h3>Super class</h3>

<p><code><a href="#topic+DSConnect">DatastreamR::DSConnect</a></code> -&gt; <code>DataClient</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>useNaNforNotANumber</code></dt><dd><p>: TRUE by default. NULLs are replaced to NaN (Not a Number)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataClient-new"><code>DataClient$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataClient-getData"><code>DataClient$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-DataClient-getDataframe"><code>DataClient$getDataframe()</code></a>
</p>
</li>
<li> <p><a href="#method-DataClient-formatDataRequest"><code>DataClient$formatDataRequest()</code></a>
</p>
</li>
<li> <p><a href="#method-DataClient-getDataBundle"><code>DataClient$getDataBundle()</code></a>
</p>
</li>
<li> <p><a href="#method-DataClient-toDataframe"><code>DataClient$toDataframe()</code></a>
</p>
</li>
<li> <p><a href="#method-DataClient-clone"><code>DataClient$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="CheckToken"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-CheckToken'><code>DatastreamR::DSConnect$CheckToken()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="IsValid"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-IsValid'><code>DatastreamR::DSConnect$IsValid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="getJsonResponse"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-getJsonResponse'><code>DatastreamR::DSConnect$getJsonResponse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="getToken"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-getToken'><code>DatastreamR::DSConnect$getToken()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DataClient-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize method to create Datastream Object
</p>


<h5>Usage</h5>

<div class="r"><pre>DataClient$new(
  config = NULL,
  username = "",
  password = "",
  proxys = NULL,
  sslCer = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>: Config path</p>
</dd>
<dt><code>username</code></dt><dd><p>: Your Id</p>
</dd>
<dt><code>password</code></dt><dd><p>: Your Password</p>
</dd>
<dt><code>proxys</code></dt><dd><p>: Proxy details (if any)</p>
</dd>
<dt><code>sslCer</code></dt><dd><p>: ssl Certificates path</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Creates Datastream RC object for accessing Datastream content
through Datastream Web Services API
</p>



<h5>Returns</h5>

<p>DataClient object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
 # ds = DataClient$new(NULL, "YourID", "YourPswd")

 #  OR

 # Login using config file
 # Config file details provided in DSConnect.R
 ds = DataClient("Config.ini")

 # Timeseries requests

 df = tryCatch (
   {ds$getData(tickers="VOD", fields=list("PH","PL"),
               start='2022-01-12', end='2022-07-13', kind=1)},
   error = function(e) { stop (message(e))})
   print(df)

 # Snapshot requests

 df = tryCatch (
 { ds$getData(tickers="VOD", fields=list("PH", "PL"),
              start='2022-01-12', kind=0)},
 error = function(e) { stop (message(e))})
 print(df)
}


</pre>
</div>


<hr>
<a id="method-DataClient-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>getData posts the JSON formatted request and the JSON response is
then converted to Dataframe, if dataToDF is TRUE.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataClient$getData(
  tickers,
  fields = NULL,
  start = "",
  end = "",
  freq = "D",
  kind = 1,
  properties = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tickers</code></dt><dd><p>: Intruments Eg: &quot;VOD,BARC&quot;</p>
</dd>
<dt><code>fields</code></dt><dd><p>: Datatypes   Eg: list('PH, 'PL', 'PI')</p>
</dd>
<dt><code>start</code></dt><dd><p>: start date in &quot;YYYY-mm-dd&quot; format Eg: &quot;2019-01-20&quot;</p>
</dd>
<dt><code>end</code></dt><dd><p>: end date  in</p>
</dd>
<dt><code>freq</code></dt><dd><p>: Refer DSDateFrequencyNames in DSRequests.R</p>
</dd>
<dt><code>kind</code></dt><dd><p>: 1 - TimeSeries Request (default), 0 - Snapshot Request</p>
</dd>
<dt><code>properties</code></dt><dd><p>: properties</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Response Class
</p>


<hr>
<a id="method-DataClient-getDataframe"></a>



<h4>Method <code>getDataframe()</code></h4>

<p>getDataframe posts the JSON formatted request and the JSON response is
then converted to Dataframe
</p>


<h5>Usage</h5>

<div class="r"><pre>DataClient$getDataframe(
  tickers,
  fields = NULL,
  start = "",
  end = "",
  freq = "D",
  kind = 1,
  properties = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tickers</code></dt><dd><p>: Intruments Eg: &quot;VOD,BARC&quot;</p>
</dd>
<dt><code>fields</code></dt><dd><p>: Datatypes   Eg: list('PH, 'PL', 'PI')</p>
</dd>
<dt><code>start</code></dt><dd><p>: start date in &quot;YYYY-mm-dd&quot; format Eg: &quot;2019-01-20&quot;</p>
</dd>
<dt><code>end</code></dt><dd><p>: end date  in</p>
</dd>
<dt><code>freq</code></dt><dd><p>: Refer DSDateFrequencyNames in DSRequests.R</p>
</dd>
<dt><code>kind</code></dt><dd><p>: 1 - TimeSeries Request (default), 0 - Snapshot Request</p>
</dd>
<dt><code>properties</code></dt><dd><p>: properties</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Dataframe
</p>


<hr>
<a id="method-DataClient-formatDataRequest"></a>



<h4>Method <code>formatDataRequest()</code></h4>

<p>This method formats the request provided by client (in form of tickers and fields)
to the JSON formatted request.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataClient$formatDataRequest(
  tickers,
  fields = NULL,
  start = "",
  end = "",
  freq = "D",
  kind = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tickers</code></dt><dd><p>: Instruments</p>
</dd>
<dt><code>fields</code></dt><dd><p>: Datatypes</p>
</dd>
<dt><code>start</code></dt><dd><p>: start date</p>
</dd>
<dt><code>end</code></dt><dd><p>: end date</p>
</dd>
<dt><code>freq</code></dt><dd><p>: frequency</p>
</dd>
<dt><code>kind</code></dt><dd><p>: kind = 0 for Snapshot request and Kind = 1 for Timeseries request</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>JSON formatted data request
</p>


<hr>
<a id="method-DataClient-getDataBundle"></a>



<h4>Method <code>getDataBundle()</code></h4>

<p>getData posts the JSON formatted request and the JSON response is
then converted to Dataframe, if dataToDF is TRUE.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataClient$getDataBundle(dataRequests, properties = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataRequests</code></dt><dd><p>: dataRequests should be formed using formatDataRequest method</p>
</dd>
<dt><code>properties</code></dt><dd><p>: properties</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Response Class
</p>


<hr>
<a id="method-DataClient-toDataframe"></a>



<h4>Method <code>toDataframe()</code></h4>

<p>Converts the Class response into a Dataframe which can be further used to plot
</p>


<h5>Usage</h5>

<div class="r"><pre>DataClient$toDataframe(dataResponse)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataResponse</code></dt><dd><p>: The raw data response that is ingested into Dataframe</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Dataframe
</p>


<hr>
<a id="method-DataClient-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataClient$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `DataClient$new`
## ------------------------------------------------

## Not run: 
 # ds = DataClient$new(NULL, "YourID", "YourPswd")

 #  OR

 # Login using config file
 # Config file details provided in DSConnect.R
 ds = DataClient("Config.ini")

 # Timeseries requests

 df = tryCatch (
   {ds$getData(tickers="VOD", fields=list("PH","PL"),
               start='2022-01-12', end='2022-07-13', kind=1)},
   error = function(e) { stop (message(e))})
   print(df)

 # Snapshot requests

 df = tryCatch (
 { ds$getData(tickers="VOD", fields=list("PH", "PL"),
              start='2022-01-12', kind=0)},
 error = function(e) { stop (message(e))})
 print(df)

## End(Not run)


</code></pre>

<hr>
<h2 id='DSConnect'>initializer</h2><span id='topic+DSConnect'></span>

<h3>Description</h3>

<p>initializer
</p>
<p>initializer
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Config</code></dt><dd><p>: config file path</p>
</dd>
<dt><code>Username</code></dt><dd><p>: Your id</p>
</dd>
<dt><code>Password</code></dt><dd><p>: Your Password</p>
</dd>
<dt><code>Proxies</code></dt><dd><p>: Proxy Server details (if any)</p>
</dd>
<dt><code>SslCert</code></dt><dd><p>: ssl Certifactes file path</p>
</dd>
<dt><code>Url</code></dt><dd><p>: internal parameter set by application</p>
</dd>
<dt><code>RequestUrl</code></dt><dd><p>: internal parameter set up by application</p>
</dd>
<dt><code>Token</code></dt><dd><p>: Token received on successfull logon</p>
</dd>
<dt><code>TokenExpiry</code></dt><dd><p>: Expiry time of the token</p>
</dd>
<dt><code>Timeout</code></dt><dd><p>: Max Timeout set in Configuartion for the process to complete</p>
</dd>
<dt><code>Version</code></dt><dd><p>: Application Version</p>
</dd>
<dt><code>AppID</code></dt><dd><p>: Application Id</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSConnect-new"><code>DSConnect$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSConnect-getJsonResponse"><code>DSConnect$getJsonResponse()</code></a>
</p>
</li>
<li> <p><a href="#method-DSConnect-getToken"><code>DSConnect$getToken()</code></a>
</p>
</li>
<li> <p><a href="#method-DSConnect-IsValid"><code>DSConnect$IsValid()</code></a>
</p>
</li>
<li> <p><a href="#method-DSConnect-CheckToken"><code>DSConnect$CheckToken()</code></a>
</p>
</li>
<li> <p><a href="#method-DSConnect-clone"><code>DSConnect$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSConnect-new"></a>



<h4>Method <code>new()</code></h4>

<p>DSConnect connects to the Datastream web service on behalf of derived classes
and helps to send and retrieve data
</p>
<p>DSConnect connects to the Datastream web service on behalf of derived classes
</p>


<h5>Usage</h5>

<div class="r"><pre>DSConnect$new(
  config = NULL,
  username = NA,
  password = NA,
  proxies = NULL,
  sslCert = NULL,
  service = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>: config path</p>
</dd>
<dt><code>username</code></dt><dd><p>: your username</p>
</dd>
<dt><code>password</code></dt><dd><p>: your password</p>
</dd>
<dt><code>proxies</code></dt><dd><p>: proxy url, if any</p>
</dd>
<dt><code>sslCert</code></dt><dd><p>: path to ssl cert file</p>
</dd>
<dt><code>service</code></dt><dd><p>: internally set by the application</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>user details can be supplied from a config file or passed directly as parameters in the
constructor of the derived user object type class.
</p>
<div class="sourceCode"><pre>   1) Using ini file (e.g. config.ini) with format

   [credentials]
   username=YourID
   password=YourPwd

   [proxies]
   url=Your Proxy Url
   port=Proxy port
   username=Proxy Username
   password=Proxy Password

   [cert]
   sslCertFile=YourCertFile
   #only read if no sslCertFile entry
   sslCertPath=YourCertPath
</pre></div>


<hr>
<a id="method-DSConnect-getJsonResponse"></a>



<h4>Method <code>getJsonResponse()</code></h4>

<p>This method makes the query against the API service and does some basic error handling
</p>


<h5>Usage</h5>

<div class="r"><pre>DSConnect$getJsonResponse(requestUrl, request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>requestUrl</code></dt><dd><p>: Url used to send the Post request</p>
</dd>
<dt><code>request</code></dt><dd><p>: Raw Datastream request</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DSConnect-getToken"></a>



<h4>Method <code>getToken()</code></h4>

<p>getToken uses you credentials to try and obtain a token to be used in subsequent request for data.
The returned token is valid for 24 hours
</p>


<h5>Usage</h5>

<div class="r"><pre>DSConnect$getToken()</pre></div>


<hr>
<a id="method-DSConnect-IsValid"></a>



<h4>Method <code>IsValid()</code></h4>

<p>IsValid checks whether the token is valid against the token expiry time
</p>


<h5>Usage</h5>

<div class="r"><pre>DSConnect$IsValid()</pre></div>


<hr>
<a id="method-DSConnect-CheckToken"></a>



<h4>Method <code>CheckToken()</code></h4>

<p>CheckToken checks whether the token is valid against the token expiry time
and generates new token if the token has expired.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSConnect$CheckToken()</pre></div>


<hr>
<a id="method-DSConnect-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSConnect$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSTimeSeriesCarryIndicator'>DSTimeSeriesCarryIndicator</h2><span id='topic+DSTimeSeriesCarryIndicator'></span>

<h3>Description</h3>

<p>This list is a supporting attribute for the CarryIndicator properties of the DSTimeSeriesRequestObject
and DSTimeSeriesResponseObjects. When you supply data which contains 'Not A Number' values (NaN) to denote non trading
days, this list instructs the mainframe in how to store the values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSTimeSeriesCarryIndicator
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Fields</h3>


<dl>
<dt><code>Yes</code></dt><dd><p>Any incoming NaN values are replaced with the last non-NaN value (e.g. 1,2,3,NaN,5,NaN,7,8
will be converted and stored as 1,2,3,3,5,5,7,8).</p>
</dd>
<dt><code>No</code></dt><dd><p>Any incoming NaN values are stored as is and returned as NaN values.</p>
</dd>
<dt><code>Pad</code></dt><dd><p>This is similar to YES, but also pads the final value for any dates your users may request beyond the last
date in your timeseries.<br />
For example, if your timeseries supplies just 3 values 1, NaN and 3, and your user requests a range of dates two days
before and two days after your range, your user will receive the following values: <br />
No:  NaN, NaN, 1, NaN, 3, NaN, NaN <br />
Yes: NaN, NaN, 1, 1, 3, NaN, NaN <br />
Pad: NaN, NaN, 1, 1, 3, 3, 3 <br /></p>
</dd>
</dl>

<hr>
<h2 id='DSTimeSeriesDataInput'>DSTimeSeriesDataInput</h2><span id='topic+DSTimeSeriesDataInput'></span>

<h3>Description</h3>

<p>This class is a supporting attribute for the DateInput property of the DSTimeSeriesRequestObject.
It is used to supply the raw data for the timeseries.
</p>


<h3>Value</h3>

<p>DSTimeSeriesDataInput object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>StartDate</code></dt><dd><p>A datetime value defining the start date for the timeseries.</p>
</dd>
<dt><code>EndDate</code></dt><dd><p>A datetime value defining the end date for the timeseries.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>The frequency of the timeseries. One of the DSUserObjectFrequency values defined in
DSUserDataObjectBase.R</p>
</dd>
<dt><code>Values</code></dt><dd><p>An array of float values. Use NULL to represent NotANumber for non-trading days. Alternatively, if you
set the DatastreamUserCreated_TimeSeries property useNaNforNotANumber as True, you can use float NaN values.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSTimeSeriesDataInput-new"><code>DSTimeSeriesDataInput$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSTimeSeriesDataInput-clone"><code>DSTimeSeriesDataInput$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSTimeSeriesDataInput-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDataInput$new(
  startDate = NULL,
  endDate = NULL,
  frequency = DSUserObjectFrequency$Daily,
  values = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>startDate</code></dt><dd><p>A datetime value defining the start date for the timeseries.</p>
</dd>
<dt><code>endDate</code></dt><dd><p>A datetime value defining the end date for the timeseries.</p>
</dd>
<dt><code>frequency</code></dt><dd><p>The frequency of the timeseries.</p>
</dd>
<dt><code>values</code></dt><dd><p>An array of float values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesDataInput object
</p>


<hr>
<a id="method-DSTimeSeriesDataInput-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDataInput$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>Datastream takes the StartDate, Frequency and Values properties defined here and creates the timeseries based
only on these parameters.The EndDate is not actually used internally other than for logging purposes. The true end
date is calculated based on the start date, frequency and the supplied list of values. Supply too few or too many values
and the mainframe will accept them and set the end date accordingly based on the given frequency for the item.
</p>

<hr>
<h2 id='DSTimeSeriesDateAlignment'>DSTimeSeriesDateAlignment</h2><span id='topic+DSTimeSeriesDateAlignment'></span>

<h3>Description</h3>

<p>This list is a supporting attribute for the DateAlignment properties of the DSTimeSeriesRequestObject
and DSTimeSeriesResponseObjects. When you supply monthly, quarterly or annual data, the dates are stored internally
as the first day of the given period and always returned to you through this interface as the first date of the given
period. However, when your users request data from Datastream, you can specify whether the dates returned to users are
returned with dates set as the start, mid or end of the requested period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSTimeSeriesDateAlignment
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Fields</h3>


<dl>
<dt><code>EndPeriod</code></dt><dd><p>This will return dates to your users that represent the last day of the month, quarter or year.</p>
</dd>
<dt><code>StartPeriod</code></dt><dd><p>This will return dates to your users that represent the first day of the month, quarter or year.</p>
</dd>
<dt><code>MidPeriod</code></dt><dd><p>This will return dates to your users that represent the middle of the month (15th day), quarter
(15th of the middle month) or year (30th June).</p>
</dd>
</dl>

<hr>
<h2 id='DSTimeSeriesDateInfo'>DSTimeSeriesDateInfo</h2><span id='topic+DSTimeSeriesDateInfo'></span>

<h3>Description</h3>

<p>This class is a supporting attribute for the DateInfo property of the DSTimeSeriesResponseObject.
It describes the basic range of data for the timeseries.
</p>
<p>The DateRange property (DSTimeSeriesDateRange described above) of the DSTimeSeriesResponseObject always returns the
dates for a given frequency as the first date in each period
(e.g. 2022-01-01, 2020-04-01, etc. for quarterly frequencies). However, The StartDate and EndDate values returned
in this class for the DSTimeSeriesResponseObject reflect the start and end dates of the range of dates
that would be returned to users requesting the data via Datastream For Office, charting, etc.
This depends on the DateAlignment property (DSTimeSeriesDateAlignment) of the timeseries.
The start and end dates returned here will be either the start, mid or end dates for the set frequency
based on the DateAlignment property (see DSTimeSeriesDateAlignment).
</p>


<h3>Value</h3>

<p>DSTimeSeriesDateInfo object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>StartDate</code></dt><dd><p>A datetime value defining the start date of the timeseries data</p>
</dd>
<dt><code>EndDate</code></dt><dd><p>A datetime value defining the end date for the timeseries.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>The frequency of the timeseries. One of the DSUserObjectFrequency values
defined in DSUserDataObjectBase.R</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSTimeSeriesDateInfo-new"><code>DSTimeSeriesDateInfo$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSTimeSeriesDateInfo-clone"><code>DSTimeSeriesDateInfo$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSTimeSeriesDateInfo-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDateInfo$new(jsonDict)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt><dd><p>JSON dictionary (from JSON Response)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesDateInfo object
</p>


<hr>
<a id="method-DSTimeSeriesDateInfo-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDateInfo$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSTimeSeriesDateRange'>DSTimeSeriesDateRange</h2><span id='topic+DSTimeSeriesDateRange'></span>

<h3>Description</h3>

<p>This class is a supporting attribute for the DateRange property of the DSTimeSeriesResponseObject.
It returns the raw data for the timeseries. The DateRange property of the DSTimeSeriesResponseObject always returns
the dates for a given frequency as the first date in each period. (e.g. 2022-01-01, 2020-04-01, etc. for quarterly
frequencies). You specify whether you want your users to receive either the first, mid or end dates in the given
period by setting the DateAlignment property (DSTimeSeriesDateAlignment) of the DSTimeSeriesRequestObject. <br />
<br />
When you retrieve a list of all your available timeseries using the GetAllItems method, since this list could contain
many thousand timeseries objects, the Dates and Values lists will always be NULL. Only the ValuesCount field will be
set to reflect the number of datapoints available for each item. You need to request an individual timeseries
(GetItem method) in order to receive a response containing actual data in the Dates and Values properties.
</p>


<h3>Value</h3>

<p>DSTimeSeriesDateRange object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Dates</code></dt><dd>
<ul>
<li><p> A list of datetime values specifying the dates for each datapoint.
</p>
</li></ul>
</dd>
<dt><code>Values</code></dt><dd>
<ul>
<li><p> A list of float values specifying the values for each datapoint.
</p>
</li></ul>
</dd>
<dt><code>ValuesCount</code></dt><dd>
<ul>
<li><p> A count of the number of datapoints in the timeseries.
</p>
</li></ul>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSTimeSeriesDateRange-new"><code>DSTimeSeriesDateRange$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSTimeSeriesDateRange-clone"><code>DSTimeSeriesDateRange$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSTimeSeriesDateRange-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDateRange$new(jsonDict, convertNullToNans = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt><dd><p>JSON dictionary (from JSON Response)</p>
</dd>
<dt><code>convertNullToNans</code></dt><dd><p>FALSE by default, TRUE converts the NULLs in the NaNs (Not a Number)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesDateRange object
</p>


<hr>
<a id="method-DSTimeSeriesDateRange-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDateRange$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSTimeSeriesDateRangeResponse'>DSTimeSeriesDateRangeResponse</h2><span id='topic+DSTimeSeriesDateRangeResponse'></span>

<h3>Description</h3>

<p>DSTimeSeriesDateRangeResponse is the object returned from the timeseries
GetTimeseriesDateRange method. This method allows you to determine the supported dates between given start
and end dates at a specified frequency.
</p>


<h3>Value</h3>

<p>DSTimeSeriesDateRangeResponse object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Dates</code></dt><dd><p>A list of datetime values representing the supported dates between requested start and end
dates at a specified frequency.</p>
</dd>
<dt><code>ResponseStatus</code></dt><dd><p>This property will contain a DSUserObjectResponseStatus value. DSUserObjectResponseStatus$UserObjectSuccess
represents a successful response.</p>
</dd>
<dt><code>ErrorMessage</code></dt><dd><p>If ResponseStatus is not DSUserObjectResponseStatus$UserObjectSuccess this status string will provide a
description of the error condition.</p>
</dd>
<dt><code>Properties</code></dt><dd><p>Not currently used and will currently always return NULL.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSTimeSeriesDateRangeResponse-new"><code>DSTimeSeriesDateRangeResponse$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSTimeSeriesDateRangeResponse-clone"><code>DSTimeSeriesDateRangeResponse$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSTimeSeriesDateRangeResponse-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDateRangeResponse$new(jsonDict = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt><dd><p>: JSON dictionary (from JSON Response)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesDateRangeResponse object
</p>


<hr>
<a id="method-DSTimeSeriesDateRangeResponse-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesDateRangeResponse$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSTimeSeriesFrequencyConversion'>DSTimeSeriesFrequencyConversion</h2><span id='topic+DSTimeSeriesFrequencyConversion'></span>

<h3>Description</h3>

<p>This list is a supporting attribute for the FrequencyConversion properties of the
DSTimeSeriesRequestObject and DSTimeSeriesResponseObjects.
This enumeration specifies how to return values if your end users requests the
timeseries at a lower frequency.
For example: if your timeseries has daily  frequency data, and your user requests monthly or
quarterly data, the FrequencyConversion property instructs the mainframe how to return monthly
or quarterly data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSTimeSeriesFrequencyConversion
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Fields</h3>


<dl>
<dt><code>EndValue</code></dt><dd><p>The daily value for the end of the requested period will be returned.</p>
</dd>
<dt><code>AverageValue</code></dt><dd><p>The average of all the values for the requested period will be returned.</p>
</dd>
<dt><code>SumValues</code></dt><dd><p>The sum of all the values for the requested period will be returned.</p>
</dd>
<dt><code>ActualValue</code></dt><dd><p>The actual value for the requested start date will be returned for the same given date
in the requested period.</p>
</dd>
</dl>

<hr>
<h2 id='DSTimeSeriesRequestObject'>DSTimeSeriesRequestObject</h2><span id='topic+DSTimeSeriesRequestObject'></span>

<h3>Description</h3>

<p>This is a subclass of DSTimeSeriesUserObjectBase and is used to create or modify a timeseries.
(See DSTimeSeriesUserObjectBase for details of all the superclass properties.)
</p>


<h3>Value</h3>

<p>DSTimeSeriesRequestObject object
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+DSUserObjectBase">DatastreamR::DSUserObjectBase</a></code> -&gt; <code><a href="#topic+DSTimeSeriesUserObjectBase">DatastreamR::DSTimeSeriesUserObjectBase</a></code> -&gt; <code>DSTimeSeriesRequestObject</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Id</code></dt><dd><p>A valid TimeSeries Id</p>
</dd>
<dt><code>DataInput</code></dt><dd><p>A DSTimeSeriesDataInput object used to supply the start date, end date, frequency and
list of data values. (See DSTimeSeriesDataInput for details.)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSTimeSeriesRequestObject-new"><code>DSTimeSeriesRequestObject$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSTimeSeriesRequestObject-clone"><code>DSTimeSeriesRequestObject$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSUserObjectBase" data-id="SetSafeUpdateParams"><a href='../../DatastreamR/html/DSUserObjectBase.html#method-DSUserObjectBase-SetSafeUpdateParams'><code>DatastreamR::DSUserObjectBase$SetSafeUpdateParams()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DSTimeSeriesRequestObject-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesRequestObject$new(
  id = "",
  startDate = NULL,
  endDate = NULL,
  frequency = NULL,
  values = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>A valid TimeSeries Id</p>
</dd>
<dt><code>startDate</code></dt><dd><p>A datetime value defining the start date for the timeseries</p>
</dd>
<dt><code>endDate</code></dt><dd><p>A datetime value defining the end date for the timeseries</p>
</dd>
<dt><code>frequency</code></dt><dd><p>The frequency of the timeseries. DSUserObjectFrequency is defined in DSUserDataObjectBase.R</p>
</dd>
<dt><code>values</code></dt><dd><p>list of float values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesRequestObject object
</p>


<hr>
<a id="method-DSTimeSeriesRequestObject-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesRequestObject$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSTimeSeriesResponseObject'>DSTimeSeriesResponseObject</h2><span id='topic+DSTimeSeriesResponseObject'></span>

<h3>Description</h3>

<p>This is a subclass of DSTimeSeriesUserObjectBase and is used to return the details for a timeseries.
(See DSTimeSeriesUserObjectBase for details of all the superclass properties.)
</p>


<h3>Value</h3>

<p>DSTimeSeriesResponseObject object
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+DSUserObjectBase">DatastreamR::DSUserObjectBase</a></code> -&gt; <code><a href="#topic+DSTimeSeriesUserObjectBase">DatastreamR::DSTimeSeriesUserObjectBase</a></code> -&gt; <code>DSTimeSeriesResponseObject</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>DateInfo</code></dt><dd><p>A DSTimeSeriesDateInfo object defining the start date, end date and frequency
of the timeseries.</p>
</dd>
<dt><code>DateRange</code></dt><dd><p>A DSTimeSeriesDateRange object used to return the dates and values stored in
the timeseries. See DSTimeSeriesDateRange for details.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSTimeSeriesResponseObject-new"><code>DSTimeSeriesResponseObject$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSTimeSeriesResponseObject-clone"><code>DSTimeSeriesResponseObject$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSUserObjectBase" data-id="SetSafeUpdateParams"><a href='../../DatastreamR/html/DSUserObjectBase.html#method-DSUserObjectBase-SetSafeUpdateParams'><code>DatastreamR::DSUserObjectBase$SetSafeUpdateParams()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DSTimeSeriesResponseObject-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesResponseObject$new(jsonDict = NULL, convertNullToNans = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt><dd><p>: JSON dictionary (from JSON Response)</p>
</dd>
<dt><code>convertNullToNans</code></dt><dd><p>: FALSE by default, TRUE converts the NULLs in the NaNs (Not a Number)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesResponseObject object
</p>


<hr>
<a id="method-DSTimeSeriesResponseObject-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesResponseObject$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSTimeSeriesUserObjectBase'>DSTimeSeriesUserObjectBase</h2><span id='topic+DSTimeSeriesUserObjectBase'></span>

<h3>Description</h3>

<p>This is the base object for creating or requesting timeseries data. It has two subclasses
DSTimeSeriesRequestObject and DSTimeSeriesResponseObject. It defines the basic attributes for a timeseries.
It subclasses DSUserObjectBase which defines the basic attributes common to all five user created item types
supported by the API.<br />
<br />
Specifics of some of the properties of the DSUserObjectBase superclass<br />
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
ID <br /> The ID property is defined in DSUserObjectBase but has a specific format for timeseries. Timeseries IDs must be
8 alphanumeric characters long, start with TS followed by 6 uppercase
alphanumeric characters. For example: TSTEST01, TS123456, TSMYTEST, etc.<br />
Mnemonic <br /> The Mnemonic property is defined in DSUserObjectBase but should always be left empty or set the same as the
ID property for timeseries requests. As a safety measure, this class always ensures it's the same as the ID.
In a response from the API server, the value will always be the same as the ID.<br />
(see DSUserObjectBase for a description of the other properties)<br />
<br />
DSTimeSeriesUserObjectBase specific properties
</p>


<h3>Value</h3>

<p>DSTimeSeriesUserObjectBase object
</p>


<h3>Super class</h3>

<p><code><a href="#topic+DSUserObjectBase">DatastreamR::DSUserObjectBase</a></code> -&gt; <code>DSTimeSeriesUserObjectBase</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ManagementGroup</code></dt><dd><p>This is an optional group name that allows you to organise timeseries into distinct 'folders'
displayed in the search category of Navigator. This can be up to 10 uppercase alphanumeric characters. Leave blank for the
item to be assigned under the 'GENERAL' group.</p>
</dd>
<dt><code>Units</code></dt><dd><p>This is a optional qualifying unit for your data. For example: tons, U$ millions, index, etc.
Maximum 12 characters.</p>
</dd>
<dt><code>DecimalPlaces</code></dt><dd><p>A numeric value between 0 and 8 decimal places specifying how many decimal places to use when storing data.
The maximum length including decimals for a value is 10 characters including the decimal point. Boundary case examples are 0.12345678,
1234567890, 123456789.0, etc.</p>
</dd>
<dt><code>FrequencyConversion</code></dt><dd><p>A DSTimeSeriesFrequencyConversion enum value specifying how to return values if a user requests data
at a lower frequency than the timeseries data is supplied. See DSTimeSeriesFrequencyConversion for details.</p>
</dd>
<dt><code>DateAlignment</code></dt><dd><p>A DSTimeSeriesDateAlignment enum value specifying whether dates for certain frequencies should be returned
as the start, middle or end date of the period. See DSTimeSeriesDateAlignment for details.</p>
</dd>
<dt><code>CarryIndicator</code></dt><dd><p>A DSTimeSeriesCarryIndicator enum value specifying how to treat 'Not A Number' values for non-trading days
and how to represent values if users request data after the end of the timeseries range. See DSTimeSeriesCarryIndicator for details.</p>
</dd>
<dt><code>PrimeCurrencyCode</code></dt><dd><p>An optional 2 character currency code for your timeseries.</p>
</dd>
<dt><code>HasPadding</code></dt><dd><p>This property has been replaced with the CarryIndicator property and will always be False</p>
</dd>
<dt><code>UnderCurrencyCode</code></dt><dd><p>This property has been deprecated and will always return NULL</p>
</dd>
<dt><code>AsPercentage</code></dt><dd><p>This This property has been deprecated and will always return False</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSTimeSeriesUserObjectBase-new"><code>DSTimeSeriesUserObjectBase$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSTimeSeriesUserObjectBase-clone"><code>DSTimeSeriesUserObjectBase$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSUserObjectBase" data-id="SetSafeUpdateParams"><a href='../../DatastreamR/html/DSUserObjectBase.html#method-DSUserObjectBase-SetSafeUpdateParams'><code>DatastreamR::DSUserObjectBase$SetSafeUpdateParams()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DSTimeSeriesUserObjectBase-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesUserObjectBase$new(jsonDict)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt><dd><p>JSON dictionary (from JSON Response)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesUserObjectBase object
</p>


<hr>
<a id="method-DSTimeSeriesUserObjectBase-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSTimeSeriesUserObjectBase$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSUserObjectAccessRights'>Datastream User Object access rights</h2><span id='topic+DSUserObjectAccessRights'></span>

<h3>Description</h3>

<p>All user created objects have a flag specifying if they can be modified by the u
All items that have their ShareType property set to DSUserObjectShareTypes.
PrivateUserGroup will also have their AccessRight property set to ReadWrite.
Global expression objects, not being editable by users, will have the AccessRight
property set to Read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSUserObjectAccessRights
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='DSUserObjectBase'>DSUserObjectBase</h2><span id='topic+DSUserObjectBase'></span>

<h3>Description</h3>

<p>DSUserObjectBase is the base object for all five user object types.
It defines the properties common to all the types
</p>


<h3>Value</h3>

<p>DSUserObjectBase object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Id</code></dt><dd><p>The object identifier. The format is specific to each object type. See the individual
object file for the particular specification</p>
</dd>
<dt><code>Mnemonic</code></dt><dd><p>For all object types bar indices, this is the same as the Id property.
For indices, the ID (of the form X#:Xnnnnn where n is a digit) is  returned when you create an index
and is used to manage the index via the API interface. The Mnemonic property is specified when creating an
index and is used to reference the index when using Datastream tools such as Charting, Datastream For Office, etc.
A mnemonic has format X#aaaaa where aaaaa is 1 to 6 alphanumeric characters.</p>
</dd>
<dt><code>DisplayName</code></dt><dd><p>A string describing the object. The maximum length varies from object type to
object type.<br />
Expression: Max 30 alphanumeric characters.<br />
Index: Max 60 alphanumeric characters.<br />
List: Max 60 alphanumeric characters.<br />
Regression: Max 50 alphanumeric characters.<br />
Timeseries: Max 64 alphanumeric characters.<br /></p>
</dd>
<dt><code>Description</code></dt><dd><p>Currently this isn't supported. When the API returns an object, the Description
property will be the same as the DisplayName property.</p>
</dd>
<dt><code>Created</code></dt><dd><p>a datetime value representing the date when the object was first created.</p>
</dd>
<dt><code>LastModified</code></dt><dd><p>a datetime value representing the date when the object was last updated.</p>
</dd>
<dt><code>Owner</code></dt><dd><p>The parent Datastream ID that owns the object. This will be the parent of your Datastream ID.
For global expressions this will always be 'Admin'</p>
</dd>
<dt><code>ShareType</code></dt><dd><p>For all objects except global expressions, this will be DSUserObjectShareTypes.
PrivateUserGroup. For global expressions it will be DSUserObjectShareTypes.Global.</p>
</dd>
<dt><code>AccessRight</code></dt><dd><p>For all objects except global expressions, this will be DSUserObjectAccessRights.
ReadWrite. For global expressions it will be DSUserObjectAccessRights.Read.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSUserObjectBase-new"><code>DSUserObjectBase$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSUserObjectBase-SetSafeUpdateParams"><code>DSUserObjectBase$SetSafeUpdateParams()</code></a>
</p>
</li>
<li> <p><a href="#method-DSUserObjectBase-clone"><code>DSUserObjectBase$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSUserObjectBase-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize
</p>


<h5>Usage</h5>

<div class="r"><pre>DSUserObjectBase$new(jsonResp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonResp</code></dt><dd><p>: json Response</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectBase object
</p>


<hr>
<a id="method-DSUserObjectBase-SetSafeUpdateParams"></a>



<h4>Method <code>SetSafeUpdateParams()</code></h4>

<p>The following parameters are set only in response when we query for user created items.
This method is called before Create or Update to ensure safe values set prior to JSON encoding
</p>


<h5>Usage</h5>

<div class="r"><pre>DSUserObjectBase$SetSafeUpdateParams()</pre></div>



<h5>Returns</h5>

<p>No return value
</p>


<hr>
<a id="method-DSUserObjectBase-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSUserObjectBase$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSUserObjectFrequency'>DSUserObjectFrequency</h2><span id='topic+DSUserObjectFrequency'></span>

<h3>Description</h3>

<p>Regressions and Timeseries objects specify a frequency for the underlying data.
DSUserObjectFrequency defines the supported frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSUserObjectFrequency
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='DSUserObjectGetAllResponse'>DSUserObjectGetAllResponse</h2><span id='topic+DSUserObjectGetAllResponse'></span>

<h3>Description</h3>

<p>This is the object returned for the client class' GetAllItems query only.<br />
<br />
For GetAllItems queries only, the returned objects will not have all their property fields set.<br />
Specifically for below:<br />
Expression: All property fields are fully populated.<br />
Index: The ConstituentsCount property will correctly specify the number of constituents but the
Constituents property will be NULL.<br />
List: The ConstituentsCount property will correctly specify the number of constituents but the
Constituents property will be NULL.<br />
Regression: All property fields are fully populated.<br />
Timeseries: The ValuesCount field of the DateRange property will specify the number of date value
pairs, but the Dates and Values fields will be NULL.<br />
You need to query for the individual object using the GetItem request to retrieve the full content
for the object.
</p>


<h3>Value</h3>

<p>DSUserObjectGetAllResponse object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>UserObjectType</code></dt><dd><p>specifies the returned object types. e.g. DSUserObjectTypes.List,
DSUserObjectTypes.TimeSeries, etc.</p>
</dd>
<dt><code>UserObjects</code></dt><dd><p>An array of the specified object types such as DSListUserObject,
DSRegressionUserObject, etc.</p>
</dd>
<dt><code>UserObjectsCount</code></dt><dd><p>The number of objects returned in the UserObjects property.</p>
</dd>
<dt><code>ResponseStatus</code></dt><dd><p>This property will contain a DSUserObjectResponseStatus value.
DSUserObjectResponseStatus.UserObjectSuccess represents a successful response.</p>
</dd>
<dt><code>ErrorMessage</code></dt><dd><p>If ResponseStatus is not DSUserObjectResponseStatus.UserObjectSuccess this status
string will provide a description of the error condition.</p>
</dd>
<dt><code>Properties</code></dt><dd><p>Not currently used and will currently always return NULL.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSUserObjectGetAllResponse-new"><code>DSUserObjectGetAllResponse$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSUserObjectGetAllResponse-clone"><code>DSUserObjectGetAllResponse$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSUserObjectGetAllResponse-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize
</p>


<h5>Usage</h5>

<div class="r"><pre>DSUserObjectGetAllResponse$new(jsonResp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonResp</code></dt><dd><p>JSON Response</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectGetAllResponse object
</p>


<hr>
<a id="method-DSUserObjectGetAllResponse-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSUserObjectGetAllResponse$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSUserObjectResponse'>DSUserObjectResponse</h2><span id='topic+DSUserObjectResponse'></span>

<h3>Description</h3>

<p>This is the object returned from the client class' GetItem, CreateItem, UpdateItem
and DeleteItem requests.
</p>


<h3>Value</h3>

<p>DSUserObjectResponse object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>UserObjectId</code></dt><dd><p>The ID of the object requested. If the item is deleted, the UserObject
property will be NULL but the UserObjectId field will be populated</p>
</dd>
<dt><code>UserObjectType</code></dt><dd><p>specifies the returned object type. e.g. DSUserObjectTypes.List,
DSUserObjectTypes.TimeSeries, etc.</p>
</dd>
<dt><code>UserObject</code></dt><dd><p>For all queries bar DeletItem, if the query is successful, this property will
contain the user created item requested.</p>
</dd>
<dt><code>ResponseStatus</code></dt><dd><p>This property will contain a DSUserObjectResponseStatus value.
DSUserObjectResponseStatus.UserObjectSuccess represents a successful response.</p>
</dd>
<dt><code>ErrorMessage</code></dt><dd><p>If ResponseStatus is not DSUserObjectResponseStatus.UserObjectSuccess this
status string will provide a description of the error condition.</p>
</dd>
<dt><code>Properties</code></dt><dd><p>Not currently used and will currently always return NULL.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DSUserObjectResponse-new"><code>DSUserObjectResponse$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DSUserObjectResponse-clone"><code>DSUserObjectResponse$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DSUserObjectResponse-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize
</p>


<h5>Usage</h5>

<div class="r"><pre>DSUserObjectResponse$new(jsonResp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonResp</code></dt><dd><p>JSON Response</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-DSUserObjectResponse-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DSUserObjectResponse$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DSUserObjectResponseStatus'>DSUserObjectResponseStatus</h2><span id='topic+DSUserObjectResponseStatus'></span>

<h3>Description</h3>

<p>All client methods to retrieve or modify user created items return a respone object which
includes a ResponseStatus property.The ResponseStatus property specifies success or failure
for the request using a DSUserObjectResponseStatus value<br />
<br />
Response Values:<br />
UserObjectSuccess : The request succeeded and the response object's UserObject(s) property
should contain the (updated) object (except for DeleteItem method).<br />
UserObjectPermissions : Users need to be specifically permissioned to create custom objects.
This flag is set if you are not currently permissioned.<br />
UserObjectNotPresent : Returned if the requested ID does not exist.<br />
UserObjectFormatError : Returned if your request object is not in the correct format.<br />
UserObjectTypeError : Returned if your supplied object is not the same as the type specified.<br />
UserObjectError : The generic error flag. This will be set for any error not specified above.<br />
</p>
<p>Examples are: <br />
1.Requested object ID is not present <br />
2.You have exceeded the number of custom objects permitted on your account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSUserObjectResponseStatus
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='DSUserObjectShareTypes'>DSUserObjectShareTypes</h2><span id='topic+DSUserObjectShareTypes'></span>

<h3>Description</h3>

<p>All user created objects have a flag specifying how they are shared with other users.
Currently only PrivateUserGroup and Global are supported.<br />
<br />
PrivateUserGroup are items created by any Datastream ID that shares a parent Datastream ID
with your ID. Only children of the parent ID can access the user o
Expressions can be either PrivateUserGroup or Global. Like the other object types,
PrivateUserGroup items are items created by users and visible to just children of their
Datastream parent ID. PrivateUserGroup expressions have the ID signature Eaaa,
where 'a' is any alphabetical character.<br />
<br />
Global expressions are Datastream owned expressions that are available for use by any client.
These have the signature nnnE, where n is a digit.
Global expressions can be retrieved using the API service, but you cannot modify them.
Only your PrivateUserGroup items can be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSUserObjectShareTypes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='DSUserObjectTypes'>DSUserObjectTypes</h2><span id='topic+DSUserObjectTypes'></span>

<h3>Description</h3>

<p>Five user created types are supported. When the client classes communicate with the API
server, a DSUserObjectTypes property is set to specify the object type.
Responses from the API server also specify the type of the object being returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSUserObjectTypes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='TimeSeriesClient'>TimeSeriesClient</h2><span id='topic+TimeSeriesClient'></span>

<h3>Description</h3>

<p>This is the client class that manages the connection to the API server on your behalf.
It allows you to query for all your timeseries and to create/modify new timeseries.
</p>


<h3>Details</h3>

<p>Methods Supported <br />
GetAllItems : Allows you to query for all the current timeseries available for your use.<br />
GetItem : Allows you to download the details of a specific timeseries item.<br />
GetTimeseriesDateRange : Allows you to determine the supported timeseries dates between supplied start and
end dates at a specified frequency.<br />
CreateItem : Allows you to create a new timeseries item with up to 130 years of daily data.<br />
UpdateItem : Allows you to update an existing timeseries.<br />
DeleteItem : Allows you to delete an existing timeseries.<br />
</p>


<h3>Value</h3>

<p>TimeSeriesClient object
</p>


<h3>Super class</h3>

<p><code><a href="#topic+DSConnect">DatastreamR::DSConnect</a></code> -&gt; <code>TimeSeriesClient</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>useNaNforNotANumber</code></dt><dd><p>If Enabled, NaN is appears in output response instead of NULL</p>
</dd>
<dt><code>TimeseriesResponseType</code></dt><dd><p>Response type</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TimeSeriesClient-new"><code>TimeSeriesClient$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.checkValidTimeseriesId"><code>TimeSeriesClient$.checkValidTimeseriesId()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.checkTimeSeriesReqValidity"><code>TimeSeriesClient$.checkTimeSeriesReqValidity()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.checkKeyTimeseriesProperties"><code>TimeSeriesClient$.checkKeyTimeseriesProperties()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.asGetAllResponse"><code>TimeSeriesClient$.asGetAllResponse()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.asGetResponse"><code>TimeSeriesClient$.asGetResponse()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.jsonRequestEncoder"><code>TimeSeriesClient$.jsonRequestEncoder()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.jsonResponseDecoder"><code>TimeSeriesClient$.jsonResponseDecoder()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-GetAllItems"><code>TimeSeriesClient$GetAllItems()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-GetItem"><code>TimeSeriesClient$GetItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-CreateItem"><code>TimeSeriesClient$CreateItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-UpdateItem"><code>TimeSeriesClient$UpdateItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-DeleteItem"><code>TimeSeriesClient$DeleteItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-GetTimeseriesDateRange"><code>TimeSeriesClient$GetTimeseriesDateRange()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-clone"><code>TimeSeriesClient$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="CheckToken"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-CheckToken'><code>DatastreamR::DSConnect$CheckToken()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="IsValid"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-IsValid'><code>DatastreamR::DSConnect$IsValid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="getJsonResponse"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-getJsonResponse'><code>DatastreamR::DSConnect$getJsonResponse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="getToken"><a href='../../DatastreamR/html/DSConnect.html#method-DSConnect-getToken'><code>DatastreamR::DSConnect$getToken()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TimeSeriesClient-new"></a>



<h4>Method <code>new()</code></h4>

<p>User details can be supplied from a config file or passed directly as parameters
in the constructor of the derived user object type class.
(See the DSConnect superclass for a description of the connection parameters required)
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$new(
  config = NULL,
  username = NULL,
  password = NULL,
  proxies = NULL,
  sslCer = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>Configuration File path</p>
</dd>
<dt><code>username</code></dt><dd><p>Your Datastream Id</p>
</dd>
<dt><code>password</code></dt><dd><p>Your Password</p>
</dd>
<dt><code>proxies</code></dt><dd><p>Proxies if any</p>
</dd>
<dt><code>sslCer</code></dt><dd><p>Path to CA bundle certificates file</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Timeseries Properties: <br />
useNaNforNotANumber : Non-trading days are stored as double NaNs on Datastream, JSON protocol permits NaNs as valid numbers.
Thus, all the NULLs in the converted to NaNs in the JSON requests. Responses contain the NULLs, But this should be converted
to Nans for Plotting purposes. If you want to receive NaN float values, set useNaNforNotANumber to TRUE, any NULLs in the returned
array of float values will be converted to NaNs.
</p>



<h5>Returns</h5>

<p>TimeSeriesClient object
</p>


<hr>
<a id="method-TimeSeriesClient-.checkValidTimeseriesId"></a>



<h4>Method <code>.checkValidTimeseriesId()</code></h4>

<p>A helper method to check the timeseries Id
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.checkValidTimeseriesId(inputId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inputId</code></dt><dd><p>: Timeseries Id</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL if Timeseries id is valid else error string
</p>


<hr>
<a id="method-TimeSeriesClient-.checkTimeSeriesReqValidity"></a>



<h4>Method <code>.checkTimeSeriesReqValidity()</code></h4>

<p>A helper method to check some of the mandatory fields of timeseries for its validity
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.checkTimeSeriesReqValidity(tsItem)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsItem</code></dt><dd><p>Timeseries Item</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL if Timeseries id is valid else error string
</p>


<hr>
<a id="method-TimeSeriesClient-.checkKeyTimeseriesProperties"></a>



<h4>Method <code>.checkKeyTimeseriesProperties()</code></h4>

<p>A helper method to check the Timeseries properties
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.checkKeyTimeseriesProperties(tsItem)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsItem</code></dt><dd><p>Timeseries Item</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL if Timeseries id is valid else error string
</p>


<hr>
<a id="method-TimeSeriesClient-.asGetAllResponse"></a>



<h4>Method <code>.asGetAllResponse()</code></h4>

<p>A helper method which converts the JSON response to GetAllResponse Object
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.asGetAllResponse(jsonDict)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt><dd><p>JSON Response</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectGetAllResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-.asGetResponse"></a>



<h4>Method <code>.asGetResponse()</code></h4>

<p>A helper method which converts the JSON response to GetResponse Object
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.asGetResponse(jsonDict)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt><dd><p>JSON Response</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-.jsonRequestEncoder"></a>



<h4>Method <code>.jsonRequestEncoder()</code></h4>

<p>A helper method that reformats the raw request to JSON format
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.jsonRequestEncoder(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>Raw request</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>return JSON formatted list
</p>


<hr>
<a id="method-TimeSeriesClient-.jsonResponseDecoder"></a>



<h4>Method <code>.jsonResponseDecoder()</code></h4>

<p>A helper method that converts JSON Response to a given class response type
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.jsonResponseDecoder(jsonResp, responseType)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonResp</code></dt><dd><p>JSON Response</p>
</dd>
<dt><code>responseType</code></dt><dd><p>GetResponse or GetAllResponse type</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>return DSUserObjectGetAllResponse or DSUserObjectGetResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-GetAllItems"></a>



<h4>Method <code>GetAllItems()</code></h4>

<p>This method returns all the current timeseries you can use in Datastream queries.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$GetAllItems()</pre></div>



<h5>Returns</h5>

<p>DSUserObjectGetAllResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-GetItem"></a>



<h4>Method <code>GetItem()</code></h4>

<p>GetItem returns the details for an individual timeseries.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$GetItem(itemId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>itemId</code></dt><dd><p>: a valid timeseries Id.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-CreateItem"></a>



<h4>Method <code>CreateItem()</code></h4>

<p>This method attempts to create the given DSTimeSeriesRequestObject via the API service
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$CreateItem(newItem, overWrite = FALSE, skipItemReturn = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newItem</code></dt><dd><p>A DSTimeSeriesRequestObject containing the data used for creating the Timeseries.</p>
</dd>
<dt><code>overWrite</code></dt><dd><p>If the given Timeseries Id already exists on the system, the create call will be rejected.
Set overWrite = True to overwrite the existing item with new Timeseries.</p>
</dd>
<dt><code>skipItemReturn</code></dt><dd><p>: Upon successful creation of an item, the server requests the new item from the mainframe
and returns it in the response object. For faster processing, set skipItemReturn = True to skip returning the
object in the response</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-UpdateItem"></a>



<h4>Method <code>UpdateItem()</code></h4>

<p>This method attempts to modify a timeseries item using the given DSTimeSeriesRequestObject via
the API service
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$UpdateItem(item, skipItemReturn = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>item</code></dt><dd><p>A DSTimeSeriesRequestObject containing the data used for creating the Timeseries.</p>
</dd>
<dt><code>skipItemReturn</code></dt><dd><p>Upon successful creation of an item, the server requests the new item from the
mainframe and returns it in the response object. For faster processing, set skipItemReturn = True to
skip returning the object in the response.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-DeleteItem"></a>



<h4>Method <code>DeleteItem()</code></h4>

<p>DeleteItem allows you to delete an existing timeseries
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$DeleteItem(itemId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>itemId</code></dt><dd><p>a valid timeseries Id.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value
</p>


<hr>
<a id="method-TimeSeriesClient-GetTimeseriesDateRange"></a>



<h4>Method <code>GetTimeseriesDateRange()</code></h4>

<p>This method allows you to determine the supported dates between supplied start and end dates
at a specified frequency.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$GetTimeseriesDateRange(
  startDate,
  endDate,
  frequency = DSUserObjectFrequency$Daily
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>startDate</code></dt><dd><p>A date specifying the beginning of the date range</p>
</dd>
<dt><code>endDate</code></dt><dd><p>A date specifying the end of the date range</p>
</dd>
<dt><code>frequency</code></dt><dd><p>A DSUserObjectFrequency enumeration defining if the frequency should be daily,
weekly, monthly, quarterly or yearly.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>DSTimeSeriesDateRangeResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>: You need a Datastream ID which is permissioned to access the Datastream APIs. In addition, this ID also needs
to be permissioned to access the custom user object service. Attempting to access this service without these permissions
will result in a permission denied error response.
</p>
<p>: For Daily and Weekly frequencies, if the supplied startDate falls on a weekend or a trading holiday, the returned
starting date will be the first trading day before the given start date. If the supplied endDate falls on a weekend or a
trading holiday, the returned final date will be the last trading day before the given end date. For Weekly frequencies,
this will be the last date which matches the day of the week for the first returned start date.<br />
<br />
For Monthly, Quarterly and Yearly frequencies, the returned dates are always the 1st day of each month, quarter or year.
The returned start and end dates are always the 1st days of the requested  month, quarter or year that the given start
and end dates fall within.
</p>
<p>: For Daily and Weekly frequencies, if the supplied startDate falls on a weekend or a trading holiday, the returned
starting date will be the first trading day before the given start date. If the supplied endDate falls on a weekend or a
trading holiday, the returned final date will be the last trading day before the given end date. For Weekly frequencies,
this will be the last date which matches the day of the week for the first returned start date.<br />
<br />
For Monthly, Quarterly and Yearly frequencies, the returned dates are always the 1st day of each month, quarter or year.
The returned start and end dates are always the 1st days of the requested  month, quarter or year that the given start
and end dates fall within.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
 # first logon with your credentials.
 # Creating a TimeSeriesClient instance with your credentials
 # automatically logs on for you.

 timeseriesClient = TimeSeriesClient$new(NULL, 'YourID', 'YourPwd')

 # query for all your current timeseries items

 itemsResp = timeseriesClient$GetAllItems()
 if (!is.null(itemsResp))
 {
   if (itemsResp$ResponseStatus != DSUserObjectResponseStatus$UserObjectSuccess)
   {
     # Your Datastream Id might not be permissioned for managing
     # user created items on this API

     print(paste('GetAllItems failed with error ',
     names(DSUserObjectResponseStatus)[[itemsResp$ResponseStatus + 1]],
     ': ', itemsResp$ErrorMessage))

   }
   else if (!is.null(itemsResp$UserObjects) &amp; itemsResp$UserObjectsCount &gt; 0)
   {
     # You do have access to some timeseries
     # Here we just put the timeseries details into a dataframe and list them
     print(paste('GetAllItems returned', itemsResp$UserObjectsCount, 'timeseries items.'))
     df = data.frame()

     for (tsItem in itemsResp$UserObjects)
     {
      if (!is.null(tsItem))
      {
       rowdata = list(Id = tsItem$Id,
       LastModified = tsItem$LastModified,
       StartDate = ifelse(!is.null(tsItem$DateInfo),as.character(tsItem$DateInfo$StartDate),""),
       EndDate =ifelse(!is.null(tsItem$DateInfo),as.character(tsItem$DateInfo$EndDate), ""),
       Frequency = ifelse(!is.null(tsItem$DateInfo), tsItem$DateInfo$Frequency, 0),
       NoOfValues = ifelse(!is.null(tsItem$DateRange), tsItem$DateRange$ValuesCount , 0),
       Desc = tsItem$Description)
       df = rbind(df, rowdata)
      }
     }
     print(df)
  }
 }
 #Example to show how to GetItem
 # query for a specific timeseries

 tsName = 'TSZZZ001'
 tsResponse = timeseriesClient$GetItem(tsName)

 # You may want to put the timeseries request response handling into a common function.
 if (!is.null(tsResponse))
 {
   # Any request dealing with a single user created item returns a DSUserObjectResponse.
   # This has ResponseStatus property that indicates success or failure

   if (tsResponse$ResponseStatus != DSUserObjectResponseStatus$UserObjectSuccess)
   {
     print(paste('Request failed for timeseries', tsName, 'with error',
                   names(DSUserObjectResponseStatus)[[tsResponse$ResponseStatus+1]],
                   ':', tsResponse$ErrorMessage))
   }
   else if (!is.null(tsResponse$UserObject))
   {
     # The timeseries item won't be returned if you set SkipItem true
     # in CreateItem or UpdateItem

     # Here we simply display the timeseries data using a dataframe.

     tsItem = tsResponse$UserObject
     metadata = c (Id = tsItem$Id,
     Desc = tsItem$Description,
     LastModified = as.character(tsItem$LastModified),
     StartDate = ifelse (!is.null(tsItem$DateInfo), as.character(tsItem$DateInfo$StartDate), NULL),
     EndDate = ifelse(!is.null(tsItem$DateInfo),as.character(tsItem$DateInfo$EndDate), NULL),
     Frequency = ifelse(!is.null(tsItem$DateInfo),
     names(DSUserObjectFrequency)[[tsItem$DateInfo$Frequency + 1]], NULL),
     NoOfValues = ifelse(!is.null(tsItem$DateRange), tsItem$DateRange$ValuesCount , 0))

     df = data.frame(metadata)
     print(df)
     if (!is.null(tsItem$DateRange))
     {
       df = data.frame(Dates = sapply(tsItem$DateRange$Dates,
       FUN = function(x){ return (as.character(x)) }),
                         Values = sapply(tsItem$DateRange$Values,
                         FUN = function(x){ ifelse (is.null(x),
                         return (NA_character_ ), return (x) )} ))

       # Values if NULL, is printed as &lt;NA&gt; because, while
       # convertind list to vector either by using as.vector or sapply,
       # the NULL values in the list are deleted. and thus there will
       # be mismatch in no of rows and cannot be put in a dataframe

       print(df)

     }
   }
 }
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
