<!DOCTYPE html><html lang="en"><head><title>Help for package lavaan.mi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lavaan.mi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binHS5imps'><p>List of imputed Holzinger &amp; Swineford (1939) dichotomized data</p></a></li>
<li><a href='#calculate.D2'><p>Calculate the &quot;D2&quot; statistic</p></a></li>
<li><a href='#HS20imps'><p>List of imputed Holzinger &amp; Swineford (1939) datasets</p></a></li>
<li><a href='#lavaan.mi'><p>Fit a lavaan Model to Multiple Imputed Data Sets</p></a></li>
<li><a href='#lavaan.mi-class'><p>Class for a lavaan Model Fitted to Multiple Imputations</p></a></li>
<li><a href='#lavResiduals.mi'><p>Covariance and Correlation Residuals</p></a></li>
<li><a href='#lavTestLRT.mi'><p>Likelihood Ratio Test for Multiple Imputations</p></a></li>
<li><a href='#lavTestScore.mi'><p>Score Test for Multiple Imputations</p></a></li>
<li><a href='#lavTestWald.mi'><p>Wald Test for Multiple Imputations</p></a></li>
<li><a href='#modindices.mi'><p>Modification Indices for Multiple Imputations</p></a></li>
<li><a href='#parameterEstimates.mi'><p>Pooled Parameter Estimates</p></a></li>
<li><a href='#poolSat'><p>Fit a Saturated <code>lavaan</code> Model to Multiple Imputed Data Sets</p></a></li>
<li><a href='#standardizedSolution.mi'><p>Standardized Pooled Parameter Estimates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-0</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit Structural Equation Models to Multiply Imputed Data</td>
</tr>
<tr>
<td>Description:</td>
<td>The primary purpose of 'lavaan.mi' is to extend the functionality 
     of the R package 'lavaan', which implements structural equation modeling
     (SEM).  When incomplete data have been multiply imputed, the imputed data
     sets can be analyzed by 'lavaan' using complete-data estimation methods,
     but results must be pooled across imputations (Rubin, 1987, &lt;<a href="https://doi.org/10.1002%2F9780470316696">doi:10.1002/9780470316696</a>&gt;).
     The 'lavaan.mi' package automates the pooling of point and standard-error
     estimates, as well as a variety of test statistics, using a familiar interface
     that allows users to fit an SEM to multiple imputations as they would to a
     single data set using the 'lavaan' package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.0), lavaan(&ge; 0.6-18), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Amelia, MASS, mice, parallel, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TDJorgensen/lavaan.mi">https://github.com/TDJorgensen/lavaan.mi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TDJorgensen/lavaan.mi/issues">https://github.com/TDJorgensen/lavaan.mi/issues</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-07</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 11:54:30 UTC; terrence</td>
</tr>
<tr>
<td>Author:</td>
<td>Terrence D. Jorgensen
    <a href="https://orcid.org/0000-0001-5111-6773"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Yves Rosseel <a href="https://orcid.org/0000-0002-4129-4477"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Terrence D. Jorgensen &lt;TJorgensen314@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-10 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binHS5imps'>List of imputed Holzinger &amp; Swineford (1939) dichotomized data</h2><span id='topic+binHS5imps'></span>

<h3>Description</h3>

<p>A version of the classic Holzinger and Swineford (1939) dataset, with
missing data imposed on variables <code>x5</code> and <code>x9</code>:
</p>


<h3>Details</h3>


<ul>
<li> <p><code>x5</code> is missing not at random (MNAR) by deleting the lowest 30% of
<code>x5</code> values.
</p>
</li>
<li> <p><code>x9</code> is missing at random (MAR) conditional on age, by deleting <code>x9</code>
values for the youngest 30% of subjects in the data.
</p>
</li></ul>

<p>The data are then dichotomized using a median split, and imputed 5 times
using the syntax shown in the example. The data include only the 9 tests
(<code>x1</code> through <code>x9</code>) and school.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>Source</h3>

<p>The lavaan package.
</p>


<h3>References</h3>

<p>Holzinger, K., &amp; Swineford, F. (1939).
<em>A study in factor analysis: The stability of a bifactor solution</em>.
Supplementary Educational Monograph, no. 48.
Chicago, IL: University of Chicago Press.
</p>


<h3>See Also</h3>

<p><a href="lavaan.html#topic+HolzingerSwineford1939">lavaan::HolzingerSwineford1939</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(HolzingerSwineford1939, package = "lavaan")

## impose missing data for example
HSMiss &lt;- HolzingerSwineford1939[ , c(paste("x", 1:9, sep = ""),
                                      "ageyr","agemo","school")]
set.seed(123)
HSMiss$x5 &lt;- ifelse(HSMiss$x5 &lt;= quantile(HSMiss$x5, .3), NA, HSMiss$x5)
age &lt;- HSMiss$ageyr + HSMiss$agemo/12
HSMiss$x9 &lt;- ifelse(age &lt;= quantile(age, .3), NA, HSMiss$x9)

## median split
HSbinary &lt;- as.data.frame( lapply(HSMiss[ , paste0("x", 1:9)],
                                  FUN = cut, breaks = 2, labels = FALSE) )
HSbinary$school &lt;- HSMiss$school

## impute binary missing data using mice package
library(mice)
set.seed(456)
miceImps &lt;- mice(HSbinary)
## save imputations in a list of data.frames
binHS5imps &lt;- list()
for (i in 1:miceImps$m) binHS5imps[[i]] &lt;- complete(miceImps, action = i)


</code></pre>

<hr>
<h2 id='calculate.D2'>Calculate the &quot;D2&quot; statistic</h2><span id='topic+calculate.D2'></span>

<h3>Description</h3>

<p>This is a utility function used to calculate the &quot;D2&quot; statistic for pooling
test statistics across multiple imputations. This function is called by
several functions used for <a href="#topic+lavaan.mi-class">lavaan.mi</a> objects, such as
<code><a href="#topic+lavTestLRT.mi">lavTestLRT.mi()</a></code>, <code><a href="#topic+lavTestWald.mi">lavTestWald.mi()</a></code>, and
<code><a href="#topic+lavTestScore.mi">lavTestScore.mi()</a></code>. But this function can be used for any general
scenario because it only requires a vector of <code class="reqn">\chi^2</code> statistics (one
from each imputation) and the degrees of freedom for the test statistic.
See Li, Meng, Raghunathan, &amp; Rubin (1991) and Enders (2010, chapter 8) for
details about how it is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.D2(w, DF = 0L, asymptotic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.D2_+3A_w">w</code></td>
<td>
<p><code>numeric</code> vector of Wald <code class="reqn">\chi^2</code> statistics. Can also
be Wald <em>z</em> statistics, which will be internally squared to make
<code class="reqn">\chi^2</code> statistics with one <em>df</em> (must set <code>DF = 0L</code>).</p>
</td></tr>
<tr><td><code id="calculate.D2_+3A_df">DF</code></td>
<td>
<p>degrees of freedom (<em>df</em>) of the <code class="reqn">\chi^2</code> statistics.
If <code>DF = 0L</code> (default), <code>w</code> is assumed to contain <em>z</em>
statistics, which will be internally squared.</p>
</td></tr>
<tr><td><code id="calculate.D2_+3A_asymptotic">asymptotic</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default), the pooled test
will be returned as an <em>F</em>-distributed statistic with numerator
(<code>df1</code>) and denominator (<code>df2</code>) degrees of freedom.
If <code>TRUE</code>, the pooled <em>F</em> statistic will be multiplied by its
<code>df1</code> on the assumption that its <code>df2</code> is sufficiently large
enough that the statistic will be asymptotically <code class="reqn">\chi^2</code> distributed
with <code>df1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector containing the test statistic, <em>df</em>,
its <em>p</em> value, and 2 missing-data diagnostics: the relative invrease
in variance (RIV, or average for multiparameter tests: ARIV) and the
fraction missing information (FMI = ARIV / (1 + ARIV)).
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>. New
York, NY: Guilford.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991).
Significance levels from repeated <em>p</em>-values with multiply-imputed
data. <em>Statistica Sinica, 1</em>(1), 65&ndash;92. Retrieved from
<a href="https://www.jstor.org/stable/24303994">https://www.jstor.org/stable/24303994</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavTestLRT.mi">lavTestLRT.mi()</a></code>, <code><a href="#topic+lavTestWald.mi">lavTestWald.mi()</a></code>,
<code><a href="#topic+lavTestScore.mi">lavTestScore.mi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a vector of chi-squared values, just for example
DF &lt;- 3 # degrees of freedom
M &lt;- 20 # number of imputations
CHI &lt;- rchisq(M, DF)

## pool the "results"
calculate.D2(CHI, DF) # by default, an F statistic is returned
calculate.D2(CHI, DF, asymptotic = TRUE) # asymptotically chi-squared

## generate standard-normal values, for an example of Wald z tests
Z &lt;- rnorm(M)
calculate.D2(Z) # default DF = 0 will square Z to make chisq(DF = 1)
## F test is equivalent to a t test with the denominator DF


</code></pre>

<hr>
<h2 id='HS20imps'>List of imputed Holzinger &amp; Swineford (1939) datasets</h2><span id='topic+HS20imps'></span>

<h3>Description</h3>

<p>A version of the classic Holzinger and Swineford (1939) dataset, with
missing data imposed on variables <code>x5</code> and <code>x9</code>:
</p>


<h3>Details</h3>


<ul>
<li> <p><code>x5</code> is missing not at random (MNAR) by deleting the lowest 30% of
<code>x5</code> values.
</p>
</li>
<li> <p><code>x9</code> is missing at random (MAR) conditional on age, by deleting <code>x5</code>
values for the youngest 30% of subjects in the data.
</p>
</li></ul>

<p>The data are imputed 20 times using the syntax shown in the example.
The data include only age and school variables, along with 9 tests
(<code>x1</code> through <code>x9</code>).
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>Source</h3>

<p>The lavaan package.
</p>


<h3>References</h3>

<p>Holzinger, K., &amp; Swineford, F. (1939).
<em>A study in factor analysis: The stability of a bifactor solution</em>.
Supplementary Educational Monograph, no. 48.
Chicago, IL: University of Chicago Press.
</p>


<h3>See Also</h3>

<p><a href="lavaan.html#topic+HolzingerSwineford1939">lavaan::HolzingerSwineford1939</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(HolzingerSwineford1939, package = "lavaan")

## impose missing data for example
HSMiss &lt;- HolzingerSwineford1939[ , c(paste("x", 1:9, sep = ""),
                                      "ageyr","agemo","school")]
set.seed(123)
HSMiss$x5 &lt;- ifelse(HSMiss$x5 &lt;= quantile(HSMiss$x5, .3), NA, HSMiss$x5)
age &lt;- HSMiss$ageyr + HSMiss$agemo/12
HSMiss$x9 &lt;- ifelse(age &lt;= quantile(age, .3), NA, HSMiss$x9)

## impute missing data with Amelia
library(Amelia)
set.seed(456)
HS.amelia &lt;- amelia(HSMiss, m = 20, noms = "school", p2s = FALSE)
HS20imps &lt;- HS.amelia$imputations


</code></pre>

<hr>
<h2 id='lavaan.mi'>Fit a lavaan Model to Multiple Imputed Data Sets</h2><span id='topic+lavaan.mi'></span><span id='topic+cfa.mi'></span><span id='topic+sem.mi'></span><span id='topic+growth.mi'></span>

<h3>Description</h3>

<p>This function fits a lavaan model to a list of imputed data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaan.mi(model, data, ...)

cfa.mi(model, data, ...)

sem.mi(model, data, ...)

growth.mi(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavaan.mi_+3A_model">model</code></td>
<td>
<p>The analysis model can be specified using lavaan
<code><a href="lavaan.html#topic+model.syntax">lavaan::model.syntax()</a></code> or a parameter table (as generated by
<code><a href="lavaan.html#topic+model.syntax">lavaan::lavaanify()</a></code> or returned by <code><a href="lavaan.html#topic+parTable">lavaan::parTable()</a></code>).</p>
</td></tr>
<tr><td><code id="lavaan.mi_+3A_data">data</code></td>
<td>
<p>A a <code>list</code> of imputed data sets, or an object class from
which imputed data can be extracted. Recognized classes are
<code>lavaan.mi</code> (stored in the <code style="white-space: pre;">&#8288;@DataList&#8288;</code> slot),
<code>amelia</code> (created by the Amelia package), or
<code>mids</code> (created by the mice package).</p>
</td></tr>
<tr><td><code id="lavaan.mi_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or
<code><a href="lavaan.html#topic+lavaanList">lavaan::lavaanList()</a></code>. See also <code><a href="lavaan.html#topic+lavOptions">lavaan::lavOptions()</a></code>.
Note that <code>lavaanList</code> provides parallel computing options, as well as
a <code style="white-space: pre;">&#8288;FUN=&#8288;</code> argument so the user can extract custom output after the model
is fitted to each imputed data set (see <strong>Examples</strong>).  TIP: If a
custom <code>FUN</code> is used <em>and</em> <code>parallel = "snow"</code> is requested,
the user-supplied function should explicitly call <code>library</code> or use
<code><a href="base.html#topic++3A+3A">::</a></code> for any functions not part of the base distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+lavaan.mi-class">lavaan.mi</a> object
</p>


<h3>Note</h3>

<p>This functionality was originally provided via <code>runMI()</code> in the
<code>semTools</code> package, but there are differences.  See the README file
on the GitHub page for this package (find link in DESCRIPTION).
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>.
New York, NY: Guilford.
</p>
<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>.
New York, NY: Wiley. <a href="https://doi.org/10.1002/9780470316696">doi:10.1002/9780470316696</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poolSat">poolSat()</a></code> for a more efficient method to obtain SEM results
for multiple imputations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'

## fit model to imputed data sets
fit &lt;- cfa.mi(HS.model, data = HS20imps)


summary(fit, fit.measures = TRUE, fmi = TRUE)
summary(fit, standardized = "std.all", rsquare = TRUE)


## You can pass other lavaanList() arguments, such as FUN=, which allows
## you to save any custom output from each imputation's fitted model.

## An example with ordered-categorical data:
data(binHS5imps) # import a list of 5 imputed data sets

## Define a function to save a list with 2 custom outputs per imputation:
##  - zero-cell tables
##  - the obsolete "WRMR" fit index
myCustomFunc &lt;- function(object) {
  list(wrmr      = lavaan::fitMeasures(object, "wrmr"),
       zeroCells = lavaan::lavInspect(object, "zero.cell.tables"))
}
## fit the model
catout &lt;- cfa.mi(HS.model, data = binHS5imps, ordered = TRUE,
                 FUN = myCustomFunc)
## pooled results

summary(catout)


## extract custom output (per imputation)
sapply(catout@funList, function(x) x$wrmr) # WRMR for each imputation
catout@funList[[1]]$zeroCells # zero-cell tables for first imputation
catout@funList[[2]]$zeroCells # zero-cell tables for second imputation ...


</code></pre>

<hr>
<h2 id='lavaan.mi-class'>Class for a lavaan Model Fitted to Multiple Imputations</h2><span id='topic+lavaan.mi-class'></span><span id='topic+show+2Clavaan.mi-method'></span><span id='topic+summary+2Clavaan.mi-method'></span><span id='topic+fitMeasures+2Clavaan.mi-method'></span><span id='topic+fitmeasures+2Clavaan.mi-method'></span><span id='topic+nobs+2Clavaan.mi-method'></span><span id='topic+coef+2Clavaan.mi-method'></span><span id='topic+vcov+2Clavaan.mi-method'></span><span id='topic+fitted+2Clavaan.mi-method'></span><span id='topic+fitted.values+2Clavaan.mi-method'></span>

<h3>Description</h3>

<p>This class extends the <a href="lavaan.html#topic+lavaanList-class">lavaan::lavaanList</a> class, created by
fitting a lavaan model to a list of data sets. In this case, the list of
data sets are multiple imputations of missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lavaan.mi'
show(object)

## S4 method for signature 'lavaan.mi'
summary(
  object,
  header = TRUE,
  fit.measures = FALSE,
  fm.args = list(standard.test = "default", scaled.test = "default", rmsea.ci.level =
    0.9, rmsea.h0.closefit = 0.05, rmsea.h0.notclosefit = 0.08, robust = TRUE,
    cat.check.pd = TRUE),
  estimates = TRUE,
  ci = FALSE,
  standardized = FALSE,
  std = standardized,
  cov.std = TRUE,
  rsquare = FALSE,
  fmi = FALSE,
  asymptotic = FALSE,
  scale.W = !asymptotic,
  omit.imps = c("no.conv", "no.se"),
  remove.unused = TRUE,
  modindices = FALSE,
  nd = 3L,
  ...
)

## S4 method for signature 'lavaan.mi'
nobs(object, total = TRUE)

## S4 method for signature 'lavaan.mi'
coef(object, type = "free", labels = TRUE, omit.imps = c("no.conv", "no.se"))

## S4 method for signature 'lavaan.mi'
vcov(
  object,
  type = c("pooled", "between", "within", "ariv"),
  scale.W = TRUE,
  omit.imps = c("no.conv", "no.se")
)

## S4 method for signature 'lavaan.mi'
fitted(object, omit.imps = c("no.conv", "no.se"))

## S4 method for signature 'lavaan.mi'
fitted.values(object, omit.imps = c("no.conv", "no.se"))

## S4 method for signature 'lavaan.mi'
fitMeasures(
  object,
  fit.measures = "all",
  baseline.model = NULL,
  h1.model = NULL,
  fm.args = list(standard.test = "default", scaled.test = "default", rmsea.ci.level =
    0.9, rmsea.h0.closefit = 0.05, rmsea.h0.notclosefit = 0.08, robust = 0.08,
    cat.check.pd = TRUE),
  output = "vector",
  omit.imps = c("no.conv", "no.se"),
  ...
)

## S4 method for signature 'lavaan.mi'
fitmeasures(
  object,
  fit.measures = "all",
  baseline.model = NULL,
  h1.model = NULL,
  fm.args = list(standard.test = "default", scaled.test = "default", rmsea.ci.level =
    0.9, rmsea.h0.closefit = 0.05, rmsea.h0.notclosefit = 0.08, robust = 0.08,
    cat.check.pd = TRUE),
  output = "vector",
  omit.imps = c("no.conv", "no.se"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavaan.mi-class_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+lavaan.mi-class">lavaan.mi</a></p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_header">header</code>, <code id="lavaan.mi-class_+3A_fit.measures">fit.measures</code>, <code id="lavaan.mi-class_+3A_fm.args">fm.args</code>, <code id="lavaan.mi-class_+3A_estimates">estimates</code>, <code id="lavaan.mi-class_+3A_ci">ci</code>, <code id="lavaan.mi-class_+3A_standardized">standardized</code>, <code id="lavaan.mi-class_+3A_std">std</code>, <code id="lavaan.mi-class_+3A_cov.std">cov.std</code>, <code id="lavaan.mi-class_+3A_rsquare">rsquare</code>, <code id="lavaan.mi-class_+3A_remove.unused">remove.unused</code>, <code id="lavaan.mi-class_+3A_modindices">modindices</code>, <code id="lavaan.mi-class_+3A_nd">nd</code>, <code id="lavaan.mi-class_+3A_output">output</code></td>
<td>
<p>See descriptions of <code>summary()</code> arguments in the help page for
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> class. Also see <code><a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures()</a></code> for arguments
<code>fit.measures</code> and <code>fm.args</code>.</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_fmi">fmi</code></td>
<td>
<p><code>logical</code> indicating whether to add the Fraction Missing
Information (FMI) and (average) relative increase in variance (ARIV)
to the output.</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_asymptotic">asymptotic</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (typically a default, but
see <strong>Value</strong> section for details using various methods), pooled
tests (of fit or pooled estimates) will be <em>F</em> or <em>t</em>
statistics with associated degrees of freedom (<em>df</em>). If
<code>TRUE</code>, the (denominator) <em>df</em> are assumed to be
sufficiently large for a <em>t</em> statistic to follow a normal
distribution, so it is printed as a <em>z</em> statistic; likewise,
<em>F</em> times its numerator <em>df</em> is printed, assumed to follow
a <code class="reqn">\chi^2</code> distribution.</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_scale.w">scale.W</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), the <code>vcov</code>
method will calculate the pooled covariance matrix by scaling the
within-imputation component by the ARIV (see Enders, 2010, p. 235,
for definition and formula). Otherwise, the pooled matrix is
calculated as the weighted sum of the within-imputation and
between-imputation components (see Enders, 2010, ch. 8, for details).
This in turn affects how the <code>summary</code> method calculates its
pooled standard errors, as well as the Wald test
(<code><a href="#topic+lavTestWald.mi">lavTestWald.mi()</a></code>).</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any &quot;improper solutions&quot; such
as Heywood cases.  NPD solutions are not excluded by default because
they are likely to occur due to sampling error, especially in small
samples.  However, gross model misspecification could also cause
NPD solutions, users can compare pooled results with and without
this setting as a sensitivity analysis to see whether some
imputations warrant further investigation. Specific imputation
numbers can also be included in this argument, in case users want to
apply their own custom omission criteria (or simulations can use
different numbers of imputations without redundantly refitting the
model).</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+lavTestLRT.mi">lavTestLRT.mi()</a></code>, or
subsequently to <code><a href="lavaan.html#topic+lavTestLRT">lavaan::lavTestLRT()</a></code>. This is how users can
specify a <code style="white-space: pre;">&#8288;pool.method=&#8288;</code> for the model's <code class="reqn">\chi^2</code> statistic
(optionally used in any <code style="white-space: pre;">&#8288;fit.measures=&#8288;</code>), or set <code>pool.method="D1"</code>
when <code>summary(modindices=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_total">total</code></td>
<td>
<p><code>logical</code> (default: <code>TRUE</code>) indicating whether the
<code>nobs()</code> method should return the total sample size or (if
<code>FALSE</code>) a vector of group sample sizes.</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_type">type</code></td>
<td>
<p>The meaning of this argument varies depending on which method it
it used for. Find detailed descriptions in the <strong>Value</strong> section
under <code>coef()</code> and <code>vcov()</code>.</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_labels">labels</code></td>
<td>
<p><code>logical</code> indicating whether the <code>coef()</code> output
should include parameter labels. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lavaan.mi-class_+3A_baseline.model">baseline.model</code>, <code id="lavaan.mi-class_+3A_h1.model">h1.model</code></td>
<td>
<p>See <code><a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p><code>signature(object = "lavaan.mi", type = "free", labels = TRUE, omit.imps = c("no.conv","no.se"))</code>:
See argument description on the help page for <a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> class.
Returns the pooled point estimates (i.e., averaged across imputed data
sets; see Rubin, 1987).</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p><code>signature(object = "lavaan.mi", scale.W = TRUE, omit.imps = c("no.conv","no.se"), type = c("pooled","between","within","ariv"))</code>:  By default, returns the
pooled covariance matrix of parameter estimates (<code>type = "pooled"</code>),
the within-imputations covariance matrix (<code>type = "within"</code>), the
between-imputations covariance matrix (<code>type = "between"</code>), or the
average relative increase in variance (<code>type = "ariv"</code>) due to
missing data.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p><code>signature(object = "lavaan.mi", omit.imps = c("no.conv","no.se"))</code>: See corresponding <a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> method.
Returns model-implied moments, evaluated at the pooled point estimates.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>alias for <code>fitted.values</code></p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p><code>signature(object = "lavaan.mi", total = TRUE)</code>: either
the total (default) sample size or a vector of group sample sizes
(<code>total = FALSE</code>).</p>
</td></tr>
<tr><td><code>fitMeasures</code></td>
<td>
<p><code>signature(object = "lavaan.mi", fit.measures = "all", baseline.model = NULL, h1.model = NULL, fm.args = list(standard.test = "default", scaled.test = "default", rmsea.ci.level = 0.90, rmsea.h0.closefit = 0.05, rmsea.h0.notclosefit = 0.08, robust = TRUE, cat.check.pd = TRUE), output = "vector", omit.imps = c("no.conv","no.se"), ...)</code>:
See <code><a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures()</a></code> for details.
Pass additional arguments to <code><a href="#topic+lavTestLRT.mi">lavTestLRT.mi()</a></code> via <code>...</code>.</p>
</td></tr>
<tr><td><code>fitmeasures</code></td>
<td>
<p>alias for <code>fitMeasures</code>.</p>
</td></tr>
<tr><td><code>show</code></td>
<td>
<p><code>signature(object = "lavaan.mi")</code>: returns a message about
convergence rates and estimation problems (if applicable) across imputed
data sets.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p><code>signature(object = "lavaan.mi", header = TRUE, fit.measures = FALSE,fm.args = list(standard.test = "default", scaled.test = "default", rmsea.ci.level = 0.90, rmsea.h0.closefit = 0.05, rmsea.h0.notclosefit = 0.08, robust = TRUE, cat.check.pd = TRUE), estimates = TRUE, ci = FALSE, standardized = FALSE, std = standardized, cov.std = TRUE, rsquare = FALSE, fmi = FALSE, asymptotic = FALSE, scale.W = !asymptotic, omit.imps = c("no.conv","no.se"), remove.unused = TRUE, modindices = FALSE, nd = 3L, ...)</code>:
Analogous to <code>summary()</code> for <code>lavaan-class</code> objects.
By default, <code>summary</code> returns output from <code><a href="#topic+parameterEstimates.mi">parameterEstimates.mi()</a></code>,
with some cursory information in the header.
Setting <code>fit.measures=TRUE</code> will additionally run <code>fitMeasures()</code>, and
setting <code>modindices=TRUE</code> will additionally run <code><a href="#topic+modindices.mi">modindices.mi()</a></code>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>coefList</code></dt><dd><p><code>list</code> of estimated coefficients in matrix format (one
per imputation) as output by <code>lavInspect(fit, "est")</code></p>
</dd>
<dt><code>phiList</code></dt><dd><p><code>list</code> of model-implied latent-variable covariance
matrices (one per imputation) as output by
<code>lavInspect(fit, "cov.lv")</code></p>
</dd>
<dt><code>miList</code></dt><dd><p><code>list</code> of modification indices output by
<code><a href="lavaan.html#topic+modificationIndices">lavaan::modindices()</a></code></p>
</dd>
<dt><code>lavListCall</code></dt><dd><p>call to <code><a href="lavaan.html#topic+lavaanList">lavaan::lavaanList()</a></code> used to fit the
model to the list of imputed data sets in <code style="white-space: pre;">&#8288;@DataList&#8288;</code>, stored as a
<code>list</code> of arguments</p>
</dd>
<dt><code>convergence</code></dt><dd><p><code>list</code> of <code>logical</code> vectors indicating whether,
for each imputed data set, (1) the model converged on a solution, (2)
<em>SE</em>s could be calculated, (3) the (residual) covariance matrix of
latent variables (<code class="reqn">\Psi</code>) is non-positive-definite, and (4) the
residual covariance matrix of observed variables (<code class="reqn">\Theta</code>) is
non-positive-definite.</p>
</dd>
<dt><code>version</code></dt><dd><p>Named <code>character</code> vector indicating the <code>lavaan</code> and
<code>lavaan.mi</code> version numbers.</p>
</dd>
<dt><code>DataList</code></dt><dd><p>The <code>list</code> of imputed data sets</p>
</dd>
<dt><code>SampleStatsList</code></dt><dd><p>List of output from
<code>lavInspect(fit, "sampstat")</code> applied to each fitted model.</p>
</dd>
<dt><code>ParTableList,vcovList,testList,baselineList</code></dt><dd><p>See <a href="lavaan.html#topic+lavaanList-class">lavaan::lavaanList</a></p>
</dd>
<dt><code>h1List</code></dt><dd><p>See <a href="lavaan.html#topic+lavaanList-class">lavaan::lavaanList</a>. An additional element is
added to the <code>list</code>: <code style="white-space: pre;">&#8288;$PT&#8288;</code> is the &quot;saturated&quot; model's parameter
table, returned by <code><a href="lavaan.html#topic+lav_partable">lavaan::lav_partable_unrestricted()</a></code>.</p>
</dd>
<dt><code>call,Options,ParTable,pta,Data,Model,meta,timingList,CacheList,optimList,impliedList,loglikList,internalList,funList,external</code></dt><dd><p>By default, <code><a href="#topic+lavaan.mi">lavaan.mi()</a></code> does not populate the remaining <code style="white-space: pre;">&#8288;@*List&#8288;</code> slots
from the <a href="lavaan.html#topic+lavaanList-class">lavaan::lavaanList</a> class. But they can be added to the call using
the <code style="white-space: pre;">&#8288;store.slots=&#8288;</code> argument (passed to <code><a href="lavaan.html#topic+lavaanList">lavaan::lavaanList()</a></code> via ...).</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>See the <code><a href="#topic+lavaan.mi">lavaan.mi()</a></code> function
for details. Wrapper functions include <code><a href="#topic+cfa.mi">cfa.mi()</a></code>,
<code><a href="#topic+sem.mi">sem.mi()</a></code>, and <code><a href="#topic+growth.mi">growth.mi()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>. New York, NY:
Guilford.
</p>
<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>.
New York, NY: Wiley. <a href="https://doi.org/10.1002/9780470316696">doi:10.1002/9780470316696</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'

## fit model to imputed data sets
fit &lt;- cfa.mi(HS.model, data = HS20imps)

## vector of pooled coefficients
coef(fit)
## their pooled asymptotic covariance matrix
vcov(fit)
## which is the weighted sum of within- and between-imputation components
vcov(fit, type = "within")
vcov(fit, type = "between")

## covariance matrix of observed variables,
## as implied by pooled estimates
fitted(fit)

## custom null model for CFI
HS.parallel &lt;- '
  visual  =~ x1 + 1*x2 + 1*x3
  textual =~ x4 + 1*x5 + 1*x6
  speed   =~ x7 + 1*x8 + 1*x9
'
fit0 &lt;- cfa.mi(HS.parallel, data = HS20imps, orthogonal = TRUE)
fitMeasures(fit, baseline.model = fit0, fit.measures = "default",
            output = "text")

## See ?lavaan.mi help page for more examples

</code></pre>

<hr>
<h2 id='lavResiduals.mi'>Covariance and Correlation Residuals</h2><span id='topic+lavResiduals.mi'></span><span id='topic+residuals+2Clavaan.mi-method'></span><span id='topic+resid+2Clavaan.mi-method'></span>

<h3>Description</h3>

<p>This function calculates residuals for sample moments (e.g., means and
(co)variances, means) from a lavaan model fitted to multiple imputed data
sets, along with summary and inferential statistics about the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lavaan.mi'
residuals(object, type = "raw", omit.imps = c("no.conv", "no.se"), ...)

## S4 method for signature 'lavaan.mi'
resid(object, type = "raw", omit.imps = c("no.conv", "no.se"), ...)

lavResiduals.mi(object, omit.imps = c("no.conv", "no.se"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavResiduals.mi_+3A_object">object</code></td>
<td>
<p>An object of class <code>lavaan.mi</code></p>
</td></tr>
<tr><td><code id="lavResiduals.mi_+3A_type">type</code></td>
<td>
<p><code>character</code> indicating whether/how to standardize the covariance
residuals. If <code>type = "raw"</code>, the raw (= unscaled) difference between
the observed and expected (model-implied) summary statistics are
returned. The observed summary statistics are averaged across
imputations, and the model-implied statistics are calculated from
pooled parameter estimates (as returned by <code>fitted.values()</code>).
If <code>type = "cor"</code> or <code>"cor.bollen"</code>, the observed and
model-implied covariance matrices are first transformed to
correlation matrices (using <code><a href="stats.html#topic+cor">stats::cov2cor()</a></code>); then correlation
residuals are computed. If <code>type = "cor.bentler"</code>, both the observed
and model-implied covariance matrices are rescaled by dividing the
elements by the square roots of the corresponding variances of the
observed covariance matrix.</p>
</td></tr>
<tr><td><code id="lavResiduals.mi_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> indicating criteria for excluding imputations
from pooled results. See <a href="#topic+lavaan.mi-class">lavaan.mi</a> for argument details.</p>
</td></tr>
<tr><td><code id="lavResiduals.mi_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="lavaan.html#topic+lavResiduals">lavaan::lavResiduals()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of residuals and other information (see <code><a href="lavaan.html#topic+lavResiduals">lavaan::lavResiduals()</a></code>).
The standard <code>residuals()</code> (and <code>resid()</code> alias) method simply calls
<code>lavResiduals.mi(..., zstat=FALSE, summary=FALSE)</code>.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="lavaan.html#topic+lavResiduals">lavaan::lavResiduals()</a></code> for details about other arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'
## fit model to 20 imputed data sets
fit &lt;- cfa.mi(HS.model, data = HS20imps)

## default type = "cor.bentler" (standardized covariance residuals)
lavResiduals.mi(fit, zstat = FALSE)
## SRMR is in the $summary

## correlation residuals
lavResiduals.mi(fit, zstat = FALSE, type = "cor")
## CRMR is in the $summary

## raw covariance residuals
lavResiduals.mi(fit, type = "raw") # zstat=TRUE by default
## RMR is in the $summary
## "normalized" residuals are in $cov.z


## The standard resid() and residuals() method simply call lavResiduals.mi()
## with arguments to display only the residuals ("raw" by default).

resid(fit)
residuals(fit, type = "cor.bollen") # same as type = "cor"


</code></pre>

<hr>
<h2 id='lavTestLRT.mi'>Likelihood Ratio Test for Multiple Imputations</h2><span id='topic+lavTestLRT.mi'></span><span id='topic+anova+2Clavaan.mi-method'></span>

<h3>Description</h3>

<p>Likelihood ratio test (LRT) for lavaan models fitted to multiple imputed
data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTestLRT.mi(
  object,
  ...,
  modnames = NULL,
  asANOVA = TRUE,
  pool.method = c("D4", "D3", "D2"),
  omit.imps = c("no.conv", "no.se"),
  asymptotic = FALSE,
  pool.robust = FALSE
)

## S4 method for signature 'lavaan.mi'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTestLRT.mi_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+lavaan.mi-class">lavaan.mi</a></p>
</td></tr>
<tr><td><code id="lavTestLRT.mi_+3A_...">...</code></td>
<td>
<p>Additional objects of class <a href="#topic+lavaan.mi-class">lavaan.mi</a>, as
well as arguments passed to <code><a href="lavaan.html#topic+lavTestLRT">lavaan::lavTestLRT()</a></code> when
<code>pool.method = "D2"</code> and <code>pool.robust = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lavTestLRT.mi_+3A_modnames">modnames</code></td>
<td>
<p>Optional <code>character</code> of model names to use as row names
in the resulting matrix of results (when more than 2 models are compared)</p>
</td></tr>
<tr><td><code id="lavTestLRT.mi_+3A_asanova">asANOVA</code></td>
<td>
<p><code>logical</code> indicating whether to return an object of
class <code>"anova"</code>.  If <code>FALSE</code>, a numeric vector is returned for
one (pair of) model(s), or a <code>data.frame</code> is returned for multiple
pairs of models.</p>
</td></tr>
<tr><td><code id="lavTestLRT.mi_+3A_pool.method">pool.method</code></td>
<td>
<p><code>character</code> indicating which pooling method to use.
</p>

<ul>
<li> <p><code>"D4"</code>, <code>"new.LRT"</code>, <code>"cm"</code>, or <code>"chan.meng"</code>
requests the method described by Chan &amp; Meng (2022).
This is currently the default.
</p>
</li>
<li> <p><code>"D3"</code>, <code>"old.LRT"</code>, <code>"mr"</code>, or <code>"meng.rubin"</code>
requests the method described by Meng &amp; Rubin (1992).
</p>
</li>
<li> <p><code>"D2"</code>, <code>"LMRR"</code>, or <code>"Li.et.al"</code> requests the
complete-data LRT statistic should be calculated using each
imputed data set, which will then be pooled across imputations, as
described in Li, Meng, Raghunathan, &amp; Rubin (1991).
</p>
</li></ul>

<p>Find additional details in Enders (2010, chapter 8).</p>
</td></tr>
<tr><td><code id="lavTestLRT.mi_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any &quot;improper solutions&quot; such
as Heywood cases. Specific imputation numbers can also be included in this
argument, in case users want to  apply their own custom omission criteria
(or simulations can use different numbers of imputations without
redundantly refitting the model).</p>
</td></tr>
<tr><td><code id="lavTestLRT.mi_+3A_asymptotic">asymptotic</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default), the pooled test
will be returned as an <em>F</em>-distributed statistic with numerator
(<code>df1</code>) and denominator (<code>df2</code>) degrees of freedom.
If <code>TRUE</code>, the pooled <em>F</em> statistic will be multiplied by its
<code>df1</code> on the assumption that its <code>df2</code> is sufficiently large
enough that the statistic will be asymptotically <code class="reqn">\chi^2</code> distributed
with <code>df1</code>.</p>
</td></tr>
<tr><td><code id="lavTestLRT.mi_+3A_pool.robust">pool.robust</code></td>
<td>
<p><code>logical</code>. Ignored unless <code>pool.method = "D2"</code> and a
robust test was requested. If <code>pool.robust = TRUE</code>, the robust test
statistic is pooled, whereas <code>pool.robust = FALSE</code> will pool
the naive test statistic (or difference statistic) and apply the average
scale/shift parameter to it. The harmonic mean is applied to the scaling
factor, whereas the arithmetic mean is applied to the shift parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"D2"</code> method is available using any estimator and test statistic.
When using a likelihood-based estimator, 2 additional methods are available
to pool the LRT.
</p>

<ul>
<li><p> The Meng &amp; Rubin (1992) method, commonly referred to as <code>"D3"</code>.
This method has many problems, discussed in Chan &amp; Meng (2022).
</p>
</li>
<li><p> The Chan &amp; Meng (2022) method, referred to as <code>"D4"</code> by
Grund et al. (2023), resolves problems with <code>"D3"</code>.
</p>
</li></ul>

<p>When <code>"D2"</code> is not explicitly requested in situations it is the only
applicable method, (e.g., DWLS for categorical outcomes), users are notified
that <code>pool.method</code> was set to <code>"D2"</code>.
</p>
<p><code>pool.method = "Mplus"</code> implies <code>"D3"</code> and <code>asymptotic = TRUE</code>
(see Asparouhov &amp; Muthen, 2010).
</p>
<p>Note that the <code>anova()</code> method simply calls <code>lavTestLRT.mi()</code>.
</p>


<h3>Value</h3>


<ul>
<li><p> When <code>asANOVA=TRUE</code>, returns an object of class <a href="stats.html#topic+anova">stats::anova</a> with a
a test of model fit for a single model (<code>object</code>) or test(s) of the
difference(s) in fit between nested models passed via <code>...</code> (either an
<code>F</code> or <code class="reqn">\chi^2</code> statistic, depending on the <code>asymptotic</code> argument),
its degrees of freedom, its <em>p</em> value, and 2 missing-data diagnostics:
the relative increase in variance (RIV = FMI / (1 <code class="reqn">-</code> FMI)) and the
fraction of missing information (FMI = RIV / (1 + RIV)).
</p>
</li>
<li><p> When <code>asANOVA=FALSE</code>, returns a vector containing the LRT statistic for
a single model or comparison of a single pair of models, or a
<code>data.frame</code> of multiple model comparisons. Robust statistics will also
include the average (across imputations) scaling factor and
(if relevant) shift parameter(s), unless <code>pool.robust = TRUE</code>.
When using <code>pool.method = "D3"</code> or <code>"D4"</code>, the vector for a single
model also includes its average log-likelihood and information criteria.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>
<p>Based on source code for <code><a href="lavaan.html#topic+lavTestLRT">lavaan::lavTestLRT()</a></code> by Yves Rosseel.
</p>


<h3>References</h3>

<p>Asparouhov, T., &amp; Muthen, B. (2010). <em>Chi-square statistics
with multiple imputation</em>. Technical Report. Retrieved from
<a href="http://www.statmodel.com/">http://www.statmodel.com/</a>
</p>
<p>Chan, K. W., &amp; Meng, X. L. (2022). Multiple improvements of multiple
imputation likelihood ratio tests. <em>Statistica Sinica, 32</em>,
1489&ndash;1514. <a href="https://doi.org/10.5705/ss.202019.0314">doi:10.5705/ss.202019.0314</a>
</p>
<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>.
New York, NY: Guilford.
</p>
<p>Grund, S., Lüdtke, O., &amp; Robitzsch, A. (2023). Pooling methods for
likelihood ratio tests in multiply imputed data sets.
<em>Psychological Methods, 28</em>(5), 1207&ndash;1221.
<a href="https://doi.org/10.1037/met0000556">doi:10.1037/met0000556</a>
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991).
Significance levels from repeated <em>p</em>-values with multiply-imputed
data. <em>Statistica Sinica, 1</em>(1), 65&ndash;92. Retrieved from
<a href="https://www.jstor.org/stable/24303994">https://www.jstor.org/stable/24303994</a>
</p>
<p>Meng, X.-L., &amp; Rubin, D. B. (1992). Performing likelihood ratio tests with
multiply-imputed data sets. <em>Biometrika, 79</em>(1), 103&ndash;111.
<a href="https://doi.org/10.2307/2337151">doi:10.2307/2337151</a>
</p>
<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>.
New York, NY: Wiley. <a href="https://doi.org/10.1002/9780470316696">doi:10.1002/9780470316696</a>
</p>


<h3>See Also</h3>

<p><code><a href="lavaan.html#topic+lavTestLRT">lavaan::lavTestLRT()</a></code> for arguments that can be passed via ...,
and use <code><a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures()</a></code> to obtain fit indices calculated from pooled
test statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from ?lavaan::cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'

fit1 &lt;- cfa.mi(HS.model, data = HS20imps, estimator = "mlm")

## By default, pool.method = "D4".
## Must request an asymptotic chi-squared statistic
## in order to accommodate a robust correction.
lavTestLRT.mi(fit1, asymptotic = TRUE)
## or   anova(fit1, asymptotic = TRUE)

## Comparison with more constrained (nested) models: parallel indicators
HS.parallel &lt;- '
  visual  =~ x1 + 1*x2 + 1*x3
  textual =~ x4 + 1*x5 + 1*x6
  speed   =~ x7 + 1*x8 + 1*x9
'

fitp &lt;- cfa.mi(HS.parallel, data = HS20imps, estimator = "mlm")

## Even more constrained model: orthogonal factors
fit0 &lt;- cfa.mi(HS.parallel, data = HS20imps, estimator = "mlm",
               orthogonal = TRUE)

## Compare 3 models, and pass the lavTestLRT(method=) argument

lavTestLRT.mi(fit1, fit0, fitp, asymptotic = TRUE,
              method = "satorra.bentler.2010")

## For a single model, you can request a vector instead of an anova-class
## table in order to see naive information criteria (only using D3 or D4),
## which are calculated using the average log-likelihood across imputations.
lavTestLRT.mi(fit1, asANOVA = FALSE)



## When using a least-squares (rather than maximum-likelihood) estimator,
## only the D2 method is available.  For example, ordered-categorical data:
data(binHS5imps) # import a list of 5 imputed data sets

## fit model using default DWLS estimation
fit1c &lt;- cfa.mi(HS.model   , data = binHS5imps, ordered = TRUE)
fit0c &lt;- cfa.mi(HS.parallel, data = binHS5imps, ordered = TRUE,
                orthogonal = TRUE)

## Using D2, you can either robustify the pooled naive statistic ...
lavTestLRT.mi(fit1c, fit0c, asymptotic = TRUE, pool.method = "D2")
## ... or pool the robust chi-squared statistic (NOT recommended)
lavTestLRT.mi(fit1c, fit0c, asymptotic = TRUE, pool.method = "D2",
              pool.robust = TRUE)

## When calculating fit indices, you can pass lavTestLRT.mi() arguments:
fitMeasures(fit1c, output = "text",
            # lavTestLRT.mi() arguments:
            pool.method = "D2", pool.robust = TRUE)


</code></pre>

<hr>
<h2 id='lavTestScore.mi'>Score Test for Multiple Imputations</h2><span id='topic+lavTestScore.mi'></span>

<h3>Description</h3>

<p>Score test (or &quot;Lagrange multiplier&quot; test) for lavaan models fitted to
multiple imputed data sets. Statistics for releasing one or more
fixed or constrained parameters in model can be calculated by pooling
the gradient and information matrices pooled across imputed data sets in a
method proposed by Mansolf, Jorgensen, &amp; Enders (2020)&mdash;analogous to
the &quot;D1&quot; Wald test proposed by Li, Meng, Raghunathan, &amp; Rubin's (1991)&mdash;or
by pooling the complete-data score-test statistics across imputed data sets
(i.e., &quot;D2&quot;; Li et al., 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTestScore.mi(
  object,
  add = NULL,
  release = NULL,
  pool.method = c("D2", "D1"),
  scale.W = !asymptotic,
  omit.imps = c("no.conv", "no.se"),
  asymptotic = is.null(add),
  univariate = TRUE,
  cumulative = FALSE,
  epc = FALSE,
  standardized = epc,
  cov.std = epc,
  verbose = FALSE,
  warn = TRUE,
  information = "expected"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTestScore.mi_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+lavaan.mi-class">lavaan.mi</a>.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_add">add</code></td>
<td>
<p>Either a <code>character</code> string (typically between single
quotes) or a parameter table containing additional (currently
fixed-to-zero) parameters for which the score test must be computed.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_release">release</code></td>
<td>
<p>Vector of <code>integer</code>s. The indices of the <em>equality</em>
constraints that should be released. The indices correspond to the order of
the equality constraints as they appear in the parameter table.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_pool.method">pool.method</code></td>
<td>
<p><code>character</code> indicating which pooling method to use.
<code>"D1"</code> requests Mansolf, Jorgensen, &amp; Enders' (2020) proposed
Wald-like test for pooling the gradient and information, which are then
used to calculate score-test statistics in the usual manner. <code>"D2"</code>
(default because it is less computationall intensive) requests to pool the
complete-data score-test statistics from each imputed data set, then pool
them across imputations, described by Li et al. (1991) and Enders (2010).</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_scale.w">scale.W</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code>, the pooled
information matrix is calculated as the weighted sum of the
within-imputation and between-imputation components. Otherwise, the pooled
information is calculated by scaling the within-imputation component by
the average relative increase in variance (ARIV; Enders, 2010, p. 235),
which is <em>only</em> consistent when requesting the <em>F</em> test (i.e.,
<code>asymptotic = FALSE</code>.  Ignored (irrelevant) if <code>pool.method = "D2"</code>.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any &quot;improper solutions&quot; such
as Heywood cases. Specific imputation numbers can also be included in this
argument, in case users want to  apply their own custom omission criteria
(or simulations can use different numbers of imputations without
redundantly refitting the model).</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_asymptotic">asymptotic</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default when using
<code>add</code> to test adding fixed parameters to the model), the pooled test
will be returned as an <em>F</em>-distributed variable with numerator
(<code>df1</code>) and denominator (<code>df2</code>) degrees of freedom.
If <code>TRUE</code>, the pooled <em>F</em> statistic will be multiplied by its
<code>df1</code> on the assumption that its <code>df2</code> is sufficiently large
enough that the statistic will be asymptotically <code class="reqn">\chi^2</code> distributed
with <code>df1</code>. When using the <code>release</code> argument, <code>asymptotic</code>
will be set to <code>TRUE</code> because (A)RIV can only be calculated for
<code>add</code>ed parameters.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_univariate">univariate</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, compute the univariate
score statistics, one for each constraint.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_cumulative">cumulative</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, order the univariate score
statistics from large to small, and compute a series of multivariate
score statistics, each time including an additional constraint in the test.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_epc">epc</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, and we are releasing existing
constraints, compute the expected parameter changes for the existing
(free) parameters (and any specified with <code>add</code>), if all constraints
were released. For EPCs associated with a particular (1-<em>df</em>)
constraint, only specify one parameter in <code>add</code> or one constraint in
<code>release</code>.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_standardized">standardized</code></td>
<td>
<p>If <code>TRUE</code>, two extra columns (<code>sepc.lv</code> and
<code>sepc.all</code>) in the <code style="white-space: pre;">&#8288;$epc&#8288;</code> table will contain standardized values
for the EPCs. See <code><a href="lavaan.html#topic+lavTestScore">lavaan::lavTestScore()</a></code>.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_cov.std">cov.std</code></td>
<td>
<p><code>logical</code>. See <code><a href="lavaan.html#topic+standardizedSolution">lavaan::standardizedSolution()</a></code>.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Not used for now.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_warn">warn</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, print warnings if they occur.</p>
</td></tr>
<tr><td><code id="lavTestScore.mi_+3A_information">information</code></td>
<td>
<p><code>character</code> indicating the type of information
matrix to use (check <code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code> for available options).
<code>"expected"</code> information is the default, which provides better
control of Type I errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing at least one <code>data.frame</code>:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;$test&#8288;</code>: The total score test, with columns for the score
test statistic (<code>X2</code>), its degrees of freedom (<code>df</code>), its
<em>p</em> value under the <code class="reqn">\chi^2</code> distribution (<code>p.value</code>),
and if <code>asymptotic=FALSE</code>, the average relative invrease in
variance (ARIV) used to calculate the denominator <em>df</em> is also
returned as a missing-data diagnostic, along with the fraction missing
information (FMI = ARIV / (1 + ARIV)).
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;$uni&#8288;</code>: Optional (if <code>univariate=TRUE</code>).
Each 1-<em>df</em> score test, equivalent to modification indices. Also
includes EPCs if <code>epc=TRUE</code>, and RIV and FMI if
<code>asymptotic=FALSE</code>.
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;$cumulative&#8288;</code>: Optional (if <code>cumulative=TRUE</code>).
Cumulative score tests, with ARIV and FMI if <code>asymptotic=FALSE</code>.
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;$epc&#8288;</code>: Optional (if <code>epc=TRUE</code>). Parameter estimates,
expected parameter changes, and expected parameter values if ALL
the tested constraints were freed.
</p>
</li></ul>

<p>See <code><a href="lavaan.html#topic+lavTestScore">lavaan::lavTestScore()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>
<p>Based on source code for <code><a href="lavaan.html#topic+lavTestScore">lavaan::lavTestScore()</a></code> by Yves Rosseel
</p>
<p><code>pool.method = "D1"</code> method proposed by
Maxwell Mansolf (University of California, Los Angeles;
<a href="mailto:mamansolf@gmail.com">mamansolf@gmail.com</a>)
</p>


<h3>References</h3>

<p>Bentler, P. M., &amp; Chou, C.-P. (1992). Some new covariance structure model
improvement statistics. <em>Sociological Methods &amp; Research, 21</em>(2),
259&ndash;282. <a href="https://doi.org/10.1177/0049124192021002006">doi:10.1177/0049124192021002006</a>
</p>
<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>.
New York, NY: Guilford.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991).
Significance levels from repeated <em>p</em>-values with multiply-imputed
data. <em>Statistica Sinica, 1</em>(1), 65&ndash;92. Retrieved from
<a href="https://www.jstor.org/stable/24303994">https://www.jstor.org/stable/24303994</a>
</p>
<p>Mansolf, M., Jorgensen, T. D., &amp; Enders, C. K. (2020). A multiple
imputation score test for model modification in structural equation
models. <em>Psychological Methods, 25</em>(4), 393&ndash;411.
<a href="https://doi.org/10.1037/met0000243">doi:10.1037/met0000243</a>
</p>


<h3>See Also</h3>

<p><code><a href="lavaan.html#topic+lavTestScore">lavaan::lavTestScore()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  speed =~ c(L1, L1)*x7 + c(L1, L1)*x8 + c(L1, L1)*x9
'

fit &lt;- cfa.mi(HS.model, data = HS20imps, group = "school", std.lv = TRUE)

## Mode 1: Score test for releasing equality constraints

## default test: Li et al.'s (1991) "D2" method
lavTestScore.mi(fit, cumulative = TRUE)

## Li et al.'s (1991) "D1" method,
## adapted for score tests by Mansolf et al. (2020)

lavTestScore.mi(fit, pool.method = "D1")


## Mode 2: Score test for adding currently fixed-to-zero parameters
lavTestScore.mi(fit, add = 'x7 ~~ x8 + x9')


</code></pre>

<hr>
<h2 id='lavTestWald.mi'>Wald Test for Multiple Imputations</h2><span id='topic+lavTestWald.mi'></span>

<h3>Description</h3>

<p>Wald test for testing a linear hypothesis about the parameters of lavaan
models fitted to multiple imputed data sets. Statistics for constraining
one or more free parameters in a model can be calculated from the pooled
point estimates and asymptotic covariance matrix of model parameters
using Rubin's (1987) rules, or by pooling the Wald  test statistics
across imputed data sets (Li, Meng, Raghunathan, &amp; Rubin, 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTestWald.mi(
  object,
  constraints = NULL,
  pool.method = c("D1", "D2"),
  asymptotic = FALSE,
  scale.W = !asymptotic,
  omit.imps = c("no.conv", "no.se"),
  verbose = FALSE,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTestWald.mi_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+lavaan.mi-class">lavaan.mi</a>.</p>
</td></tr>
<tr><td><code id="lavTestWald.mi_+3A_constraints">constraints</code></td>
<td>
<p>A <code>character</code> string (typically between single
quotes) containing one or more equality constraints.
See examples for more details</p>
</td></tr>
<tr><td><code id="lavTestWald.mi_+3A_pool.method">pool.method</code></td>
<td>
<p><code>character</code> indicating which pooling method to use.
<code>"D1"</code> or <code>"Rubin"</code> (default) indicates Rubin's (1987) rules
will be applied to the point estimates and the asymptotic covariance
matrix of model parameters, and those pooled values will be used to
calculate the Wald test in the usual manner. <code>"D2"</code>, <code>"LMRR"</code>,
or <code>"Li.et.al"</code> indicate that the complete-data Wald test statistic
should be calculated using each imputed data set, which will then be
pooled across imputations, as described in Li, Meng, Raghunathan, &amp; Rubin
(1991) and Enders (2010, chapter 8).</p>
</td></tr>
<tr><td><code id="lavTestWald.mi_+3A_asymptotic">asymptotic</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default), the pooled test
will be returned as an <em>F</em>-distributed statistic with numerator
(<code>df1</code>) and denominator (<code>df2</code>) degrees of freedom.
If <code>TRUE</code>, the pooled <em>F</em> statistic will be multiplied by its
<code>df1</code> on the assumption that its <code>df2</code> is sufficiently large
enough that the statistic will be asymptotically <code class="reqn">\chi^2</code> distributed
with <code>df1</code>.</p>
</td></tr>
<tr><td><code id="lavTestWald.mi_+3A_scale.w">scale.W</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code>, the pooled
asymptotic covariance matrix of model parameters is calculated as the
weighted sum of the within-imputation and between-imputation components.
Otherwise, the pooled asymptotic covariance matrix of model parameters is
calculated by scaling the within-imputation component by the
average relative increase in variance (ARIV; see Enders, 2010, p. 235),
which is <em>only</em> consistent when requesting the <em>F</em> test (i.e.,
<code>asymptotic = FALSE</code>.  Ignored (irrelevant) if <code>pool.method = "D2"</code>.</p>
</td></tr>
<tr><td><code id="lavTestWald.mi_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any &quot;improper solutions&quot; such
as Heywood cases. Specific imputation numbers can also be included in this
argument, in case users want to  apply their own custom omission criteria
(or simulations can use different numbers of imputations without
redundantly refitting the model).</p>
</td></tr>
<tr><td><code id="lavTestWald.mi_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, print the restriction
matrix and the estimated restricted values.</p>
</td></tr>
<tr><td><code id="lavTestWald.mi_+3A_warn">warn</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, print warnings if they occur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constraints are specified using the <code>"=="</code> operator.
Both the left-hand side and the right-hand side of the equality can contain
a linear combination of model parameters, or a constant (like zero).
The model parameters must be specified by their user-specified labels from
the <code>link[lavaan]{model.syntax}</code>. Names of defined parameters
(using the &quot;:=&quot; operator) can be included too.
</p>


<h3>Value</h3>

<p>A vector containing the Wald test statistic (either an <code>F</code> or
<code class="reqn">\chi^2</code> statistic, depending on the <code>asymptotic</code> argument),
the degrees of freedom (numerator and denominator, if
<code>asymptotic = FALSE</code>), and a <em>p</em> value. If
<code>asymptotic = FALSE</code>, the relative invrease in variance (RIV, or
average for multiparameter tests: ARIV) used to calculate the denominator
<em>df</em> is also returned as a missing-data diagnostic, along with the
fraction missing information (FMI = ARIV / (1 + ARIV)).
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>
<p>Based on source code for <code><a href="lavaan.html#topic+lavTestWald">lavaan::lavTestWald()</a></code> by Yves Rosseel
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>.
New York, NY: Guilford.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991).
Significance levels from repeated <em>p</em>-values with multiply-imputed
data. <em>Statistica Sinica, 1</em>(1), 65&ndash;92. Retrieved from
<a href="https://www.jstor.org/stable/24303994">https://www.jstor.org/stable/24303994</a>
</p>
<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>.
New York, NY: Wiley. <a href="https://doi.org/10.1002/9780470316696">doi:10.1002/9780470316696</a>
</p>


<h3>See Also</h3>

<p><code><a href="lavaan.html#topic+lavTestWald">lavaan::lavTestWald()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + b1*x2 + x3
  textual =~ x4 + b2*x5 + x6
  speed   =~ x7 + b3*x8 + x9
'

fit &lt;- cfa.mi(HS.model, data = HS20imps)

## Testing whether a single parameter equals zero yields the 'chi-square'
## version of the Wald z statistic from the summary() output, or the
## 'F' version of the t statistic from the summary() output, depending
## whether asymptotic = TRUE or FALSE
lavTestWald.mi(fit, constraints = "b1 == 0")             # default D1 statistic
lavTestWald.mi(fit, constraints = "b1 == 0", pool.method = "D2") # D2 statistic

## The real advantage is simultaneously testing several equality
## constraints, or testing more complex constraints:
con &lt;- '
   2*b1 == b3
   b2 - b3 == 0
'
lavTestWald.mi(fit, constraints = con) # default F statistic
lavTestWald.mi(fit, constraints = con, asymptotic = TRUE) # chi-squared


</code></pre>

<hr>
<h2 id='modindices.mi'>Modification Indices for Multiple Imputations</h2><span id='topic+modindices.mi'></span><span id='topic+modificationIndices.mi'></span><span id='topic+modificationindices.mi'></span>

<h3>Description</h3>

<p>Modification indices (1-<em>df</em> Lagrange multiplier tests) from a
latent variable model fitted to multiple imputed data sets. Statistics
for releasing one or more fixed or constrained parameters in model can
be calculated by pooling the gradient and information matrices
across imputed data sets in a method proposed by Mansolf, Jorgensen, &amp;
Enders (2020)&mdash;analogous to the &quot;D1&quot; Wald test proposed by Li, Meng,
Raghunathan, &amp; Rubin (1991)&mdash;or by pooling the complete-data score-test
statistics across imputed data sets (i.e., &quot;D2&quot;; Li et al., 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modindices.mi(
  object,
  pool.method = c("D2", "D1"),
  omit.imps = c("no.conv", "no.se"),
  standardized = TRUE,
  cov.std = TRUE,
  information = "expected",
  power = FALSE,
  delta = 0.1,
  alpha = 0.05,
  high.power = 0.75,
  sort. = FALSE,
  minimum.value = 0,
  maximum.number = nrow(LIST),
  na.remove = TRUE,
  op = NULL
)

modificationIndices.mi(
  object,
  pool.method = c("D2", "D1"),
  omit.imps = c("no.conv", "no.se"),
  standardized = TRUE,
  cov.std = TRUE,
  information = "expected",
  power = FALSE,
  delta = 0.1,
  alpha = 0.05,
  high.power = 0.75,
  sort. = FALSE,
  minimum.value = 0,
  maximum.number = nrow(LIST),
  na.remove = TRUE,
  op = NULL
)

modificationindices.mi(
  object,
  pool.method = c("D2", "D1"),
  omit.imps = c("no.conv", "no.se"),
  standardized = TRUE,
  cov.std = TRUE,
  information = "expected",
  power = FALSE,
  delta = 0.1,
  alpha = 0.05,
  high.power = 0.75,
  sort. = FALSE,
  minimum.value = 0,
  maximum.number = nrow(LIST),
  na.remove = TRUE,
  op = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modindices.mi_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+lavaan.mi-class">lavaan.mi</a></p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_pool.method">pool.method</code></td>
<td>
<p><code>character</code> indicating which pooling method to use.
<code>"D1"</code> requests Mansolf, Jorgensen, &amp; Enders' (2020) proposed
Wald-like test for pooling the gradient and information, which are then
used to calculate score-test statistics in the usual manner. <code>"D2"</code>
(default because it is less computationally intensive) requests to pool the
complete-data score-test statistics from each imputed data set, then pool
them across imputations, described by Li et al. (1991) and Enders (2010).</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any &quot;improper solutions&quot; such
as Heywood cases. Specific imputation numbers can also be included in this
argument, in case users want to  apply their own custom omission criteria
(or simulations can use different numbers of imputations without
redundantly refitting the model).</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_standardized">standardized</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, two extra columns
(<code style="white-space: pre;">&#8288;$sepc.lv&#8288;</code> and <code style="white-space: pre;">&#8288;$sepc.all&#8288;</code>) will contain standardized values
for the EPCs. In the first column (<code style="white-space: pre;">&#8288;$sepc.lv&#8288;</code>), standardizization is
based on the variances of the (continuous) latent variables. In the second
column (<code style="white-space: pre;">&#8288;$sepc.all&#8288;</code>), standardization is based on both the variances
of both (continuous) observed and latent variables. (Residual) covariances
are standardized using (residual) variances.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_cov.std">cov.std</code></td>
<td>
<p><code>logical</code>. <code>TRUE</code> if <code>pool.method == "D2"</code>.
If <code>TRUE</code> (default), the (residual)
observed covariances are scaled by the square-root of the diagonal elements
of the <code class="reqn">\Theta</code> matrix, and the (residual) latent covariances are
scaled by the square-root of the diagonal elements of the <code class="reqn">\Psi</code>
matrix. If <code>FALSE</code>, the (residual) observed covariances are scaled by
the square-root of the diagonal elements of the model-implied covariance
matrix of observed variables (<code class="reqn">\Sigma</code>), and the (residual) latent
covariances are scaled by the square-root of the diagonal elements of the
model-implied covariance matrix of the latent variables.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_information">information</code></td>
<td>
<p><code>character</code> indicating the type of information
matrix to use (check <code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code> for available options).
<code>"expected"</code> information is the default, which provides better
control of Type I errors.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_power">power</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the (post-hoc) power is
computed for each modification index, using the values of <code>delta</code>
and <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_delta">delta</code></td>
<td>
<p>The value of the effect size, as used in the post-hoc power
computation, currently using the unstandardized metric of the <code style="white-space: pre;">&#8288;$epc&#8288;</code>
column.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used for deciding if the modification
index is statistically significant or not.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_high.power">high.power</code></td>
<td>
<p>If the computed power is higher than this cutoff value,
the power is considered 'high'. If not, the power is considered 'low'.
This affects the values in the <code style="white-space: pre;">&#8288;$decision&#8288;</code> column in the output.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_sort.">sort.</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, sort the output using the
values of the modification index values. Higher values appear first.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_minimum.value">minimum.value</code></td>
<td>
<p><code>numeric</code>. Filter output and only show rows with a
modification index value equal or higher than this minimum value.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_maximum.number">maximum.number</code></td>
<td>
<p><code>integer</code>. Filter output and only show the first
maximum number rows. Most useful when combined with the <code>sort.</code> option.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_na.remove">na.remove</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), filter output by
removing all rows with <code>NA</code> values for the modification indices.</p>
</td></tr>
<tr><td><code id="modindices.mi_+3A_op">op</code></td>
<td>
<p><code>character</code> string. Filter the output by selecting only those
rows with operator <code>op</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing modification indices and (S)EPCs.
</p>


<h3>Note</h3>

<p>When <code>pool.method = "D2"</code>, each (S)EPC will be pooled by taking its
average across imputations. When <code>pool.method = "D1"</code>, EPCs will be
calculated in the standard way using the pooled gradient and information,
and SEPCs will be calculated by standardizing the EPCs using model-implied
(residual) variances.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>
<p>Based on source code for <code><a href="lavaan.html#topic+modificationIndices">lavaan::modindices()</a></code> by Yves Rosseel
</p>
<p><code>pool.method = "D1"</code> method proposed by
Maxwell Mansolf (University of California, Los Angeles;
<a href="mailto:mamansolf@gmail.com">mamansolf@gmail.com</a>)
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>.
New York, NY: Guilford.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991).
Significance levels from repeated <em>p</em>-values with multiply-imputed
data.<em>Statistica Sinica, 1</em>(1), 65&ndash;92. Retrieved from
<a href="https://www.jstor.org/stable/24303994">https://www.jstor.org/stable/24303994</a>
</p>
<p>Mansolf, M., Jorgensen, T. D., &amp; Enders, C. K. (2020). A multiple
imputation score test for model modification in structural equation
models. <em>Psychological Methods, 25</em>(4), 393&ndash;411.
<a href="https://doi.org/10.1037/met0000243">doi:10.1037/met0000243</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavTestScore.mi">lavTestScore.mi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'

fit &lt;- cfa.mi(HS.model, data = HS20imps)

modindices.mi(fit) # default: Li et al.'s (1991) "D2" method

## Li et al.'s (1991) "D1" method,
## adapted for score tests by Mansolf et al. (2020)
modindices.mi(fit, pool.method = "D1")


</code></pre>

<hr>
<h2 id='parameterEstimates.mi'>Pooled Parameter Estimates</h2><span id='topic+parameterEstimates.mi'></span><span id='topic+parameterestimates.mi'></span>

<h3>Description</h3>

<p>This function pools parameter estimates from a lavaan model fitted to
multiple imputed data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameterEstimates.mi(
  object,
  se = TRUE,
  zstat = se,
  pvalue = zstat,
  ci = TRUE,
  level = 0.95,
  fmi = FALSE,
  standardized = FALSE,
  cov.std = TRUE,
  rsquare = FALSE,
  asymptotic = FALSE,
  scale.W = !asymptotic,
  omit.imps = c("no.conv", "no.se"),
  remove.system.eq = TRUE,
  remove.eq = TRUE,
  remove.ineq = TRUE,
  remove.def = FALSE,
  remove.nonfree = FALSE,
  remove.unused = FALSE,
  output = "data.frame",
  header = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameterEstimates.mi_+3A_object">object</code></td>
<td>
<p>An object of class <code>lavaan.mi</code></p>
</td></tr>
<tr><td><code id="parameterEstimates.mi_+3A_se">se</code>, <code id="parameterEstimates.mi_+3A_zstat">zstat</code>, <code id="parameterEstimates.mi_+3A_pvalue">pvalue</code>, <code id="parameterEstimates.mi_+3A_ci">ci</code>, <code id="parameterEstimates.mi_+3A_level">level</code>, <code id="parameterEstimates.mi_+3A_standardized">standardized</code>, <code id="parameterEstimates.mi_+3A_cov.std">cov.std</code>, <code id="parameterEstimates.mi_+3A_rsquare">rsquare</code>, <code id="parameterEstimates.mi_+3A_remove.system.eq">remove.system.eq</code>, <code id="parameterEstimates.mi_+3A_remove.eq">remove.eq</code>, <code id="parameterEstimates.mi_+3A_remove.ineq">remove.ineq</code>, <code id="parameterEstimates.mi_+3A_remove.def">remove.def</code>, <code id="parameterEstimates.mi_+3A_remove.nonfree">remove.nonfree</code>, <code id="parameterEstimates.mi_+3A_remove.unused">remove.unused</code>, <code id="parameterEstimates.mi_+3A_output">output</code>, <code id="parameterEstimates.mi_+3A_header">header</code></td>
<td>
<p>See <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.</p>
</td></tr>
<tr><td><code id="parameterEstimates.mi_+3A_fmi">fmi</code></td>
<td>
<p><code>logical</code> indicating whether to add 2 columns:
</p>

<ul>
<li><p> the fraction of missing information (<code style="white-space: pre;">&#8288;$fmi&#8288;</code>), which is the ratio of
between-imputation variance to total (pooled) sampling variance
</p>
</li>
<li><p> the relative increase in variance (<code style="white-space: pre;">&#8288;$riv&#8288;</code>), which is the ratio of
between-imputation variance to within-imputation variance
</p>
</li></ul>

<p>Thus, RIV = FMI / (1 <code class="reqn">-</code> FMI) and FMI = RIV / (1 + RIV).
Ignored when <code>se=FALSE</code>.</p>
</td></tr>
<tr><td><code id="parameterEstimates.mi_+3A_asymptotic">asymptotic</code></td>
<td>
<p><code>logical</code>. When <code>FALSE</code>, pooled Wald tests will be <em>t</em>
statistics with associated degrees of freedom (<em>df</em>). When <code>TRUE</code>,
the <em>df</em> are assumed to be sufficiently large for a <em>t</em> statistic to
approximate a standard normal distribution, so it is printed as a <em>z</em>
statistic.</p>
</td></tr>
<tr><td><code id="parameterEstimates.mi_+3A_scale.w">scale.W</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), the <code>vcov</code>
method will calculate the pooled covariance matrix by scaling the
within-imputation component by the ARIV (see Enders, 2010, p. 235,
for definition and formula). Otherwise, the pooled matrix is
calculated as the weighted sum of the within-imputation and
between-imputation components (see Enders, 2010, ch. 8, for details).</p>
</td></tr>
<tr><td><code id="parameterEstimates.mi_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> indicating criteria for excluding imputations
from pooled results. See <a href="#topic+lavaan.mi-class">lavaan.mi</a> for argument details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, analogous to <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>, but estimates,
<em>SE</em>s, and tests are pooled across imputations.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>. New York, NY:
Guilford.
</p>
<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>.
New York, NY: Wiley. <a href="https://doi.org/10.1002/9780470316696">doi:10.1002/9780470316696</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardizedSolution.mi">standardizedSolution.mi()</a></code> to obtain inferential statistics for pooled
standardized parameter estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'
## fit model to 20 imputed data sets
fit &lt;- cfa.mi(HS.model, data = HS20imps)

## pooled estimates, with various optional features:

parameterEstimates.mi(fit, asymptotic = TRUE, rsquare = TRUE)
parameterEstimates.mi(fit, ci = FALSE, fmi = TRUE, output = "text")
parameterEstimates.mi(fit, standardized = "std.all", se = FALSE)

</code></pre>

<hr>
<h2 id='poolSat'>Fit a Saturated <code>lavaan</code> Model to Multiple Imputed Data Sets</h2><span id='topic+poolSat'></span>

<h3>Description</h3>

<p>This function fits a saturated model to a list of imputed data sets, and
returns a list of pooled summary statistics to treat as data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolSat(
  data,
  ...,
  return.fit = FALSE,
  scale.W = TRUE,
  omit.imps = c("no.conv", "no.se")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poolSat_+3A_data">data</code></td>
<td>
<p>A <code>list</code> of imputed data sets, or an object class from
which imputed data can be extracted. Recognized classes are
<code>lavaan.mi</code> (list of imputations stored in the <code style="white-space: pre;">&#8288;@DataList&#8288;</code> slot),
<code>amelia</code> (created by the <code>Amelia</code> package), or
<code>mids</code> (created by the <code>mice</code> package).</p>
</td></tr>
<tr><td><code id="poolSat_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="lavaan.html#topic+lavCor">lavaan::lavCor()</a></code> or to
<code><a href="#topic+lavaan.mi">lavaan.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="poolSat_+3A_return.fit">return.fit</code></td>
<td>
<p><code>logical</code> indicating whether to return a <a href="#topic+lavaan.mi-class">lavaan.mi</a>
object containing the results of fitting the saturated model to multiple
imputed <code>data</code>.  Could be useful for diagnostic purposes.</p>
</td></tr>
<tr><td><code id="poolSat_+3A_scale.w">scale.W</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), the within- and
between-imputation components will be pooled by scaling the
within-imputation component by the ARIV (see Enders, 2010, p. 235,
for definition and formula). Otherwise, the pooled matrix is
calculated as the weighted sum of the within-imputation and
between-imputation components (see Enders, 2010, ch. 8, for details).</p>
</td></tr>
<tr><td><code id="poolSat_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results of saturated model.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any &quot;improper solutions&quot; such
as Heywood cases.  NPD solutions are not excluded by default because
they are likely to occur due to sampling error, especially in small
samples.  However, gross model misspecification could also cause
NPD solutions, users can compare pooled results with and without
this setting as a sensitivity analysis to see whether some
imputations warrant further investigation. Specific imputation
numbers can also be included in this argument, in case users want to
apply their own custom omission criteria (or simulation studies can use
different numbers of imputations without redundantly refitting the model).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.fit=TRUE</code>, a <a href="#topic+lavaan.mi-class">lavaan.mi</a> object.
Otherwise, an object of class <code>lavMoments</code>, which is a <code>list</code>
that contains at least <code style="white-space: pre;">&#8288;$sample.cov&#8288;</code> and <code style="white-space: pre;">&#8288;$sample.nobs&#8288;</code>,
potentially also <code style="white-space: pre;">&#8288;$sample.mean&#8288;</code>, <code style="white-space: pre;">&#8288;$sample.th&#8288;</code>, <code style="white-space: pre;">&#8288;$NACOV&#8288;</code>,
and <code style="white-space: pre;">&#8288;$WLS.V&#8288;</code>.  Also contains <code style="white-space: pre;">&#8288;$lavOptions&#8288;</code> that will be passed
to <code>lavaan(...)</code>.
</p>


<h3>Note</h3>

<p>The <code style="white-space: pre;">&#8288;$lavOptions&#8288;</code> list will always set <code>fixed.x=FALSE</code> and
<code>conditional.x=FALSE</code>.  Users should not override those options when
calling <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> because doing so would yield
incorrect <em>SE</em>s and test statistics. Computing the correct
<code style="white-space: pre;">&#8288;$NACOV&#8288;</code> argument would depend on which specific variables are
treated as fixed, which would require an argument to <code>poolSat()</code> for
users to declare names of exogenous variables. This has not yet been
programmed, but that feature may be added in the future in order to reduce
the number of parameters to estimate.
However, if &quot;exogenous&quot; predictors were incomplete and imputed, then they
are not truly fixed (i.e., unvarying across samples), so treating them as
fixed would be illogical and yield biased <em>SE</em>s and test statistics.
</p>
<p>The information returned by <code>poolSat()</code> must assume that any fitted
SEM will include all the variables in <code style="white-space: pre;">&#8288;$sample.cov&#8288;</code> and (more
importantly) in <code style="white-space: pre;">&#8288;$NACOV&#8288;</code>.  Although <code>lavaan</code> can drop unused
rows/columns from <code style="white-space: pre;">&#8288;$sample.cov&#8288;</code>, it cannot be expected to drop the
corresponding sampling variances of those eliminated (co)variances from
<code style="white-space: pre;">&#8288;$NACOV&#8288;</code>.  Thus, it is necessary to use <code>poolSat()</code> to obtain
the appropriate summary statistics for any particular SEM (see <strong>Examples</strong>).
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p>Lee, T., &amp; Cai, L. (2012). Alternative multiple imputation inference for
mean and covariance structure modeling.
<em>Journal of Educational and Behavioral Statistics, 37</em>(6), 675&ndash;702.
<a href="https://doi.org/10.3102/1076998612458320">doi:10.3102/1076998612458320</a>
</p>
<p>Chung, S., &amp; Cai, L. (2019). Alternative multiple imputation inference
for categorical structural equation modeling,
<em>Multivariate Behavioral Research, 54</em>(3), 323&ndash;337.
<a href="https://doi.org/10.1080/00273171.2018.1523000">doi:10.1080/00273171.2018.1523000</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaan.mi">lavaan.mi()</a></code> for traditional method (fit SEM to each imputation,
pool results afterward).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(HS20imps) # import a list of 20 imputed data sets

## fit saturated model to imputations, pool those results
impSubset1 &lt;- lapply(HS20imps, "[", i = paste0("x", 1:9)) # only modeled variables
(prePooledData &lt;- poolSat(impSubset1))

## Note: no means were returned (default lavOption() is meanstructure=FALSE)
(prePooledData &lt;- poolSat(impSubset1, meanstructure = TRUE))

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'

## fit model to summary statistics in "prePooledData"
fit &lt;- cfa(HS.model, data = prePooledData, std.lv = TRUE)
## By default, the "Scaled" column provides a "scaled.shifted" test
## statistic that maintains an approximately nominal Type I error rate.
summary(fit, fit.measures = TRUE, standardized = "std.all")
## Note that this scaled statistic does NOT account for deviations from
## normality, because the default normal-theory standard errors were
## requested when running poolSat().  See below about non-normality.

## Alternatively, "Browne's residual-based (ADF) test" is also available:
lavTest(fit, test = "browne.residual.adf", output = "text")

## Optionally, save the saturated-model lavaan.mi object, which
## could be helpful for diagnosing convergence problems per imputation.
satFit &lt;- poolSat(impSubset1, return.fit = TRUE)


## FITTING MODELS TO DIFFERENT (SUBSETS OF) VARIABLES

## If you only want to analyze a subset of these variables,
mod.vis &lt;- 'visual  =~ x1 + x2 + x3'
## you will get an error:
try(
  fit.vis &lt;- cfa(mod.vis, data = prePooledData) # error
)

## As explained in the "Note" section, you must use poolSat() again for
## this subset of variables
impSubset3 &lt;- lapply(HS20imps, "[", i = paste0("x", 1:3)) # only modeled variables
visData &lt;- poolSat(impSubset3)
fit.vis &lt;- cfa(mod.vis, data = visData) # no problem


## OTHER lavaan OPTIONS


## fit saturated MULIPLE-GROUP model to imputations
impSubset2 &lt;- lapply(HS20imps, "[", i = c(paste0("x", 1:9), "school"))
(prePooledData2 &lt;- poolSat(impSubset2, group = "school",
                           ## request standard errors that are ROBUST
                           ## to violations of the normality assumption:
                           se = "robust.sem"))
## Nonnormality-robust standard errors are implicitly incorporated into the
## pooled weight matrix (NACOV= argument), so they are
## AUTOMATICALLY applied when fitting the model:
fit.config &lt;- cfa(HS.model, data = prePooledData2, group = "school",
                  std.lv = TRUE)
## standard errors and chi-squared test of fit both robust to nonnormality
summary(fit.config)


## CATEGORICAL OUTCOMES

## discretize the imputed data, for an example of 3-category data
HS3cat &lt;- lapply(impSubset1, function(x) {
  as.data.frame( lapply(x, cut, breaks = 3, labels = FALSE) )
})
## pool polychoric correlations and thresholds
(prePooledData3 &lt;- poolSat(HS3cat, ordered = paste0("x", 1:9)))

fitc &lt;- cfa(HS.model, data = prePooledData3, std.lv = TRUE)
summary(fitc)

## Optionally, use unweighted least-squares estimation.  However,
## you must first REMOVE the pooled weight matrix (WLS.V= argument)
## or replace it with an identity matrix of the same dimensions:
prePooledData4 &lt;- prePooledData3
prePooledData4$WLS.V &lt;- NULL
## or prePooledData4$WLS.V &lt;- diag(nrow(prePooledData3$WLS.V))
fitcu &lt;- cfa(HS.model, data = prePooledData4, std.lv = TRUE, estimator = "ULS")
## Note that the SEs and test were still appropriately corrected:
summary(fitcu)


</code></pre>

<hr>
<h2 id='standardizedSolution.mi'>Standardized Pooled Parameter Estimates</h2><span id='topic+standardizedSolution.mi'></span><span id='topic+standardizedsolution.mi'></span>

<h3>Description</h3>

<p>This function calculates pooled parameter estimates from a lavaan model
fitted to multiple imputed data sets, then transforms the pooled estimates
and their <em>SE</em>s using the delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizedSolution.mi(
  object,
  return.vcov = FALSE,
  omit.imps = c("no.conv", "no.se"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizedSolution.mi_+3A_object">object</code></td>
<td>
<p>An object of class <code>lavaan.mi</code></p>
</td></tr>
<tr><td><code id="standardizedSolution.mi_+3A_return.vcov">return.vcov</code></td>
<td>
<p><code>logical</code> indicating whether to return only the pooled
asymptotic covariance matrix, <code>vcov(object)</code>, but transformed for
standardized parameters. This is a way to obtain a pooled analog of
<code>lavInspect(object, "vcov.std.all")</code> with a <a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object,
and it is how the <em>SE</em>s are derived for standardized solutions.</p>
</td></tr>
<tr><td><code id="standardizedSolution.mi_+3A_omit.imps">omit.imps</code></td>
<td>
<p><code>character</code> indicating criteria for excluding imputations
from pooled results. See <a href="#topic+lavaan.mi-class">lavaan.mi</a> for argument details.</p>
</td></tr>
<tr><td><code id="standardizedSolution.mi_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="lavaan.html#topic+standardizedSolution">lavaan::standardizedSolution()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing standardized model parameters, analogous to
<code><a href="lavaan.html#topic+standardizedSolution">lavaan::standardizedSolution()</a></code>.  Delta-method <em>SE</em>s and CIs rely on
asymptotic theory, so only Wald <em>z</em> tests are available, analogous to
setting <code>parameterEstimates.mi(fit, asymptotic = TRUE)</code>.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parameterEstimates.mi">parameterEstimates.mi()</a></code> for pooling unstandardized parameter estimates,
which can also add standardized point estimates to indicate effect size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(HS20imps) # import a list of 20 imputed data sets

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'
## fit model to 20 imputed data sets
fit &lt;- cfa.mi(HS.model, data = HS20imps)

standardizedSolution.mi(fit) # default: type = "std.all"

## only standardize latent variables:
standardizedSolution.mi(fit, type = "std.lv",
                        output = "text") # display like summary()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
