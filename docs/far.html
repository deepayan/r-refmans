<!DOCTYPE html><html><head><title>Help for package far</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {far}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base.simul.far'><p> Creating functional basis</p></a></li>
<li><a href='#BaseK2BaseC'><p> Changing Basis</p></a></li>
<li><a href='#coef.far'><p> Extract Model Coefficients</p></a></li>
<li><a href='#date.fdata'><p> Extract the date of fdata</p></a></li>
<li><a href='#fapply'><p> Apply functions over a fdata object</p></a></li>
<li><a href='#far'><p> FARX(1) model estimation</p></a></li>
<li><a href='#far.cv'><p> Cross Validation for FARX(1) model</p></a></li>
<li><a href='#fdata'><p> Functional Data class</p></a></li>
<li><a href='#interpol.matrix'><p>Interpolation matrix</p></a></li>
<li><a href='#invgen'><p> Generalized inverse of a Matrix</p></a></li>
<li><a href='#is.na.fdata'><p> Not Available / &ldquo;Missing&rdquo; Values</p></a></li>
<li><a href='#kerfon'><p> Functional Kernel estimation</p></a></li>
<li><a href='#maxfdata'><p> Maxima of functional data</p></a></li>
<li><a href='#multplot'><p> Multivariate plots</p></a></li>
<li><a href='#orthonormalization'><p> Orthonormalization of a set of a matrix</p></a></li>
<li><a href='#plot.fdata'><p> Plot Functional Data</p></a></li>
<li><a href='#pred.persist'><p> Forecasting using functional persistence</p></a></li>
<li><a href='#predict.far'><p> Forecasting of FARX(1) model</p></a></li>
<li><a href='#predict.kerfon'><p> Forecasting of functional kernel model</p></a></li>
<li><a href='#select.fdata'><p> Subscript of fdata</p></a></li>
<li><a href='#simul.far'><p> FAR(1) process simulation</p></a></li>
<li><a href='#simul.far.sde'><p> FAR-SDE process simulation</p></a></li>
<li><a href='#simul.far.wiener'><p> FAR(1) process simulation with Wiener noise</p></a></li>
<li><a href='#simul.farx'><p> FARX(1) process simulation</p></a></li>
<li><a href='#simul.wiener'><p> Wiener process simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Modelization for Functional AutoRegressive Processes</td>
</tr>
<tr>
<td>Author:</td>
<td>Damon Julien &lt;julien.damon@gmail.com&gt;
   Guillas Serge</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Damon Julien &lt;julien.damon@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), nlme, graphics, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Modelizations and previsions functions for
   Functional AutoRegressive processes using
   nonparametric methods: functional kernel,
   estimation of the covariance operator in
   a subspace, ...</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Looping027/far">https://github.com/Looping027/far</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-13 19:06:59 UTC; rstudio</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-13 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='base.simul.far'> Creating functional basis </h2><span id='topic+base.simul.far'></span>

<h3>Description</h3>

<p>Computation of a particular basis in a functional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base.simul.far(m=24, n=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base.simul.far_+3A_m">m</code></td>
<td>
<p> Number of discretization points </p>
</td></tr>
<tr><td><code id="base.simul.far_+3A_n">n</code></td>
<td>
<p> Number of axis </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider a sinusoidal basis of the functional space C[0;1] of the
continuous functions from [0;1] to R. We compute here the values of
the <code>n</code> first (functional) axis at <code>m</code> equi-repartited
discretization points in [0;1] (more precisely the point
0,<code class="reqn">\frac{1}{\code{m}}</code>,...,
<code class="reqn">\frac{\code{m}-1}{\code{m}}</code>).
</p>


<h3>Value</h3>

<p>A matrix of size <code>m</code> x <code>n</code> containing the <code>m</code> values of
the <code>n</code> first axis of the basis.
</p>


<h3>Note</h3>

<p>The chosen basis is orthogonal.
</p>
<p>The aim of this function is to provide an internal tool for the
function <code><a href="#topic+simul.farx">simul.farx</a></code>.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+simul.farx">simul.farx</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  print(temp&lt;-base.simul.far(10,3))
  print(t(temp)%*%temp)
  matplot(base.simul.far(100,5),type='l')
</code></pre>

<hr>
<h2 id='BaseK2BaseC'> Changing Basis </h2><span id='topic+BaseK2BaseC'></span>

<h3>Description</h3>

<p>Given the coordinates in the Karhunen-Loève expansion
base of the Wiener, compute the coordinates in the
canonical basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BaseK2BaseC(x, nb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BaseK2BaseC_+3A_x">x</code></td>
<td>
<p> A matrix containing the coordinates in the Karhunen-Loève basis.
One observation per column. </p>
</td></tr>
<tr><td><code id="BaseK2BaseC_+3A_nb">nb</code></td>
<td>
<p> The dimension of the canonical basis consider. By default,
the dimension is the same as the Karhunen-Loève one
(i.e. number of row of <code>x</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Karhunen-Loève expansion is a sum of an infinity of terms, but here
the expansion is truncated to a finite number of terms. Empirically, we
remark that using twice the dimension of the canonical basis desired
for the number of terms in the expansion is a good compromise.
</p>


<h3>Value</h3>

<p>A object of class <code><a href="#topic+fdata">fdata</a></code> with <code>nb</code> discretization points
and the same number of observations as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>References</h3>

<p> Pumo, B. (1992). <em>Estimation et Prévision de Processus
Autoregressifs Fonctionnels. Applications aux Processus à Temps Continu</em>.
PhD Thesis, University Paris 6, Pierre et Marie Curie. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+simul.wiener">simul.wiener</a></code>, <code><a href="#topic+simul.far.wiener">simul.far.wiener</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    data1 &lt;- BaseK2BaseC(x=matrix(rnorm(50),ncol=5,nrow=10), nb=5)
    multplot(data1,whole=TRUE)
</code></pre>

<hr>
<h2 id='coef.far'> Extract Model Coefficients </h2><span id='topic+coef.far'></span>

<h3>Description</h3>

<p>'coef' method to extract the linear operator of a FAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'far'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.far_+3A_object">object</code></td>
<td>
<p> An object of type <code>far</code>. </p>
</td></tr>
<tr><td><code id="coef.far_+3A_...">...</code></td>
<td>
<p> Other arguments (not used in this case). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Give the matricial representation of the linear operator express in
the canonical basis. See <code><a href="#topic+far">far</a></code> for more details about the
meaning of this operator.
</p>
<p>If the <code>far</code> model is used on a one dimensional variable or with
the <code>joined=TRUE</code> option, then the matrix has a dimension equal
to the subspace dimension.
</p>
<p>In the other case, the dimension of the matrix is equal to the sum of
the dimensions of the various subspaces. In such a case, the order of
the variables in the matrix is the same as in the vector
<code>c(y,x)</code>. For instance, if <code>kn=c(3,2)</code> with <code>y="Var1"</code>
and <code>x="Var3"</code> then:
</p>

<ul>
<li><p> The first 3x3 first bloc of the matrix is the autocorrelation
of &ldquo;Var1&rdquo;.
</p>
</li>
<li><p> The 3x2 up right bloc of the matrix is the correlation of
&ldquo;Var3&rdquo; on &ldquo;Var1&rdquo;.
</p>
</li>
<li><p> The 2x3 down left bloc of the matrix is the correlation of
&ldquo;Var1&rdquo; on &ldquo;Var3&rdquo;.
</p>
</li>
<li><p> The 2x2 down right bloc of the matrix is the autocorrelation of
&ldquo;Var3&rdquo;.
</p>
</li></ul>



<h3>Value</h3>

<p>A square matrix of size (raw and column) equal to the sum of the
element of <code>kn</code>.
</p>


<h3>Author(s)</h3>

<p> J. Damon, S. Guillas </p>


<h3>See Also</h3>

 <p><code><a href="#topic+far">far</a></code>,<code><a href="stats.html#topic+coef">coef</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Modelization of the FARX process (joined and separate)
  model1 &lt;- far(data1,kn=4,joined=TRUE)
  model2 &lt;- far(data1,kn=c(3,1),joined=FALSE)

  # Calculation of the theoretical coefficients
  coef.theo &lt;- theoretical.coef(m=10,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Joined coefficient
  round(coef(model1),2)
  coef.theo$rho.T

  # Separate coefficient
  round(coef(model2),2)
  coef.theo$rho.X.Z
</code></pre>

<hr>
<h2 id='date.fdata'> Extract the date of fdata </h2><span id='topic+date.fdata'></span>

<h3>Description</h3>

<p>Extract the date(s) of <code>fdata</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date.fdata(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date.fdata_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dates are the labels of the functionals observations of the
<code>fdata</code> object.
</p>
<p><code>fdata</code> are not constructed as <code>ts</code> object so a specific
function to obtain the date is useful.
</p>


<h3>Value</h3>

<p>A vector giving the dates (as character).
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fdata">fdata</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Reading the data
library(stats)
data(UKDriverDeaths)

# Conversion of the data
fUKDriverDeaths &lt;- as.fdata(UKDriverDeaths,col=1,p=12,dates=1969:1984,
                            name="UK Driver Deaths")
date.fdata(fUKDriverDeaths)
</code></pre>

<hr>
<h2 id='fapply'> Apply functions over a fdata object </h2><span id='topic+fapply'></span>

<h3>Description</h3>

<p><code>fapply</code> returns a <code>fdata</code> object of the same length as
data. Each element of which is the result of applying <code>FUN</code> to
the corresponding element of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fapply(data, FUN, row.names, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fapply_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object </p>
</td></tr>
<tr><td><code id="fapply_+3A_fun">FUN</code></td>
<td>
<p> the function to be applied. In the case of functions like
+, %*%, etc., the function name must be quoted. </p>
</td></tr>
<tr><td><code id="fapply_+3A_row.names">row.names</code></td>
<td>
<p> a vector giving the names describing the results of
<code>FUN</code> </p>
</td></tr>
<tr><td><code id="fapply_+3A_...">...</code></td>
<td>
<p> optional arguments to <code>FUN</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has to be used only with <code>fdata</code> objects, unless it
stop, returning no value.
</p>


<h3>Value</h3>

<p>The returned value is a <code>fdata</code> object too.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+apply">apply</a></code>, <code><a href="base.html#topic+lapply">lapply</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  fapply(data1,sum)
  multplot(fapply(fapply(data1,abs),cumsum))
</code></pre>

<hr>
<h2 id='far'> FARX(1) model estimation </h2><span id='topic+far'></span><span id='topic+plot.far'></span><span id='topic+print.far'></span>

<h3>Description</h3>

<p>Estimates the parameters of FAR(1) and FARX(1) processes
(mean and autocorrelation operator)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>far(data, y, x, kn, center=TRUE, na.rm=TRUE, joined=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="far_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object. </p>
</td></tr>
<tr><td><code id="far_+3A_y">y</code></td>
<td>
<p> A vector giving the name(s) of the endogenous variable(s) of
the model. </p>
</td></tr>
<tr><td><code id="far_+3A_x">x</code></td>
<td>
<p> A vector giving the name(s) of the exogenous variable(s) of
the model. </p>
</td></tr>
<tr><td><code id="far_+3A_kn">kn</code></td>
<td>
<p> A vector giving the values of the various
<code>kn</code> (dimension of plug-in in the algorithm). If it not supplied,
the default value is one. </p>
</td></tr>
<tr><td><code id="far_+3A_center">center</code></td>
<td>
<p> Logical. Does the observation need to be centered. </p>
</td></tr>
<tr><td><code id="far_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical. Does the <code>n.a.</code> need to be removed. </p>
</td></tr>
<tr><td><code id="far_+3A_joined">joined</code></td>
<td>
<p> Logical. If <code>TRUE</code>, the joined (whole) far model
is computed, otherwise the model work with the separated variables. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>The models</b>
</p>
<p>A Functional AutoRegressive of order 1 (<b>FAR(1)</b>) process is, in a
general way,  defined by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">T_{n}=\rho\left(T_{n-1}\right)+\epsilon_{n}, n \in
    Z</code>
</p>

<p>where <code class="reqn">T_{n}</code> and <code class="reqn">\epsilon_{n}</code> take their values in a
functional space (for instance an Hilbertian one), and <code class="reqn">\rho</code>
is a linear operator. <code class="reqn">\epsilon_{n}</code> is a strong white noise.
</p>
<p>Now, let us consider a vector of observations, for instance:
</p>
<p style="text-align: center;"><code class="reqn">\left(T_{1,n},...,T_{i,n},...,T_{m,n}\right)</code>
</p>

<p>where each  <code class="reqn">T_{i,n}</code> lives in a one dimension functional
space (not necessary the same). In the following, we will cut this
list into two parts: the endogeneous variables <code class="reqn">Y_{n}</code> (the
ones we are interested in), and the exogeneous variables
<code class="reqn">X_{n}</code> (which influence the endogeneous ones).
</p>
<p>Then an order 1 Functional AutoRegressive process with eXogeneous
variables (<b>FARX(1)</b>) is defined by the equation:
</p>
<p style="text-align: center;"><code class="reqn">Y_{n}=\rho\left(Y_{n-1}\right)+a\left(X_{n}\right)+\epsilon_{n}
    , n \in Z</code>
</p>

<p>where <code class="reqn">\rho</code> and <code class="reqn">a</code> are linear operators in the
adequate spaces.
</p>
<p><b>Estimation</b>
</p>
<p>This function estimates the parameters of FAR and FARX models.
</p>
<p>First, if the mean of the <code>data</code> is not zero (which is required
by the model), you can substance this mean using the <code>center</code>
option. Moreover, if the <code>data</code> contains <code>NA</code> values, you
can work with it using the <code>na.rm</code> option.
</p>
<p><b>FAR Estimation</b>
</p>
<p>The estimation is mainly about estimating the <code class="reqn">\rho</code>
operator. This estimation is done in a appropriate subspace (computed
from the variance of the observations). What is important to know is
that the best dimension <code>kn</code> for this subspace is not determined
by this function. So the user have to supply this dimension using the
<code>kn</code> option. A way to chose this dimension is to first use the
<code><a href="#topic+far.cv">far.cv</a></code> function on the history.
</p>
<p><b>FARX Estimation</b>
</p>
<p>The FARX estimation can be realized by two methods: joined or not.
</p>
<p>The <b>joined</b> estimation is done by &ldquo;joining&rdquo; the variables
into one and estimating a FAR model on the resulting variable. For
instance, with the previous notations, the transformation is:
</p>
<p style="text-align: center;"><code class="reqn">T_{n}=\left(Y_{n},X_{n+1}\right)</code>
</p>

<p>and <code class="reqn">T_{n}</code> is then a peculiar FAR(1) process. In such a case,
you have to use the <code>joined=TRUE</code> oto the interpretation of
this operatorption and specify <b>one</b>
value for <code>kn</code> (corresponding to the <code class="reqn">T_{n}</code> variable).
</p>
<p>Alternatively, you can choose not to estimate the FARX model by the
joined procedure, then <code>kn</code> need to be a vector with a length
equal to the number of variables involved in the FARX model
(endogeneous and exogeneous).
</p>
<p>In both procedures, the endogeneous and exogeneous variables are
provided through the <code>y</code> and <code>x</code> options respectively.
</p>
<p><b>Results</b>
</p>
<p>The function returns a <code>far</code> object. Use the <code>print</code>,
<code>coef</code> and <code>predict</code> functions to get more informations
about the model.
</p>


<h3>Value</h3>

<p>A <code>far</code> object, see details for more informations.
</p>


<h3>Note</h3>

<p>This function could be used to estimate FAR and FARX with order higher
than 1 as a change of variables can transform the process to an
order 1 FAR or FARX. For instance, if <code class="reqn">T_{n}</code> is a FAR(2)
process then <code class="reqn">Y_{n}=\left(T_{n},T_{n-1}\right)</code> is a
FAR(1) process.
</p>
<p>However, this is not a basic use of this function and may require a
hard work of the user to get the result.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>References</h3>

<p> Besse, P. and Cardot, H. (1996). Approximation spline de la
prévision d'un processus fonctionnel autorégressif d'ordre 1.
<em>Revue Canadienne de Statistique/Canadian Journal of Statistics</em>,
<b>24</b>, 467&ndash;487.
</p>
<p>Bosq, D. (2000) <em>Linear Processes in Function Spaces: Theory and
Applications</em>, (Lecture Notes in Statistics,
Vol. 149). New York: Springer-Verlag.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict.far">predict.far</a></code>, <code><a href="#topic+far.cv">far.cv</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Cross validation (joined and separate)
  model1.cv &lt;- far.cv(data=data1, y="X", x="Z", kn=8, ncv=10, cvcrit="X",
                center=FALSE, na.rm=FALSE, joined=TRUE)
  model2.cv &lt;- far.cv(data=data1, y="X", x="Z", kn=c(4,4), ncv=10, cvcrit="X",
                center=FALSE, na.rm=FALSE, joined=FALSE)
  print(model1.cv)
  print(model2.cv)
  k1 &lt;- model1.cv$minL2[1]
  k2 &lt;- model2.cv$minL2[1:2]

  # Modelization of the FARX process (joined and separate)
  model1 &lt;- far(data=data1, y="X", x="Z", kn=k1,
                center=FALSE, na.rm=FALSE, joined=TRUE)
  model2 &lt;- far(data=data1, y="X", x="Z", kn=k2,
                center=FALSE, na.rm=FALSE, joined=FALSE)
  print(model1)
  print(model2)
</code></pre>

<hr>
<h2 id='far.cv'> Cross Validation for FARX(1) model </h2><span id='topic+far.cv'></span>

<h3>Description</h3>

<p>Cross Validation for FAR(1) and FARX(1) models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>far.cv(data, y, x, kn, ncv, cvcrit, center=TRUE, na.rm=TRUE, joined=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="far.cv_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object. </p>
</td></tr>
<tr><td><code id="far.cv_+3A_y">y</code></td>
<td>
<p> A vector giving the name(s) of the endogenous variable(s) of
the model. </p>
</td></tr>
<tr><td><code id="far.cv_+3A_x">x</code></td>
<td>
<p> A vector giving the name(s) of the exogenous variable(s) of
the model. </p>
</td></tr>
<tr><td><code id="far.cv_+3A_kn">kn</code></td>
<td>
<p> A vector giving the maximum values of the various
<code>kn</code> (dimension of plug-in in the algorithm). If it not supplied,
the number of discretization point is used. </p>
</td></tr>
<tr><td><code id="far.cv_+3A_ncv">ncv</code></td>
<td>
<p> Number of observations used to the cross validation </p>
</td></tr>
<tr><td><code id="far.cv_+3A_cvcrit">cvcrit</code></td>
<td>
<p> A vector of characters. Name of the variable used to
measure the errors (<code>y</code> by default). </p>
</td></tr>
<tr><td><code id="far.cv_+3A_center">center</code></td>
<td>
<p> Logical. Does the observation need to be centered. </p>
</td></tr>
<tr><td><code id="far.cv_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical. Does the <code>n.a.</code> need to be removed. </p>
</td></tr>
<tr><td><code id="far.cv_+3A_joined">joined</code></td>
<td>
<p> Logical. If <code>TRUE</code>, the joined (whole) far model
is computed, otherwise the model work with the separated variables. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to perform good forecasting with a FAR or FARX model, you need
to determine the dimensions <code>kn</code> of the subspace in which the linear
operator is estimated (see <code><a href="#topic+far">far</a></code> for more details).
</p>
<p>This function helps the user to do this choice by performing a cross
validation on a test sample. The usage is close of the
<code><a href="#topic+far">far</a></code> function, so we will discuss about the options which
differ.
</p>
<p>First, the <code>kn</code> option is used to restrict the values searched:
this is a vector containing the maxima values. As in
<code><a href="#topic+far">far</a></code>, the dimension of this vector is function of the
number of variables involved in the model and the type of estimation
done (joined or not).
</p>
<p><code>ncv</code> is the number of observation used to test the models. If it
is not provided, the function use the last fifth of the observations in
<code>data</code>. In such a case, the four first fifth are used to
estimates the models. This is in general a good compromise.
</p>
<p>Finally, <code>cvcrit</code> list the variables used to test the models. If
more than one variable is provided, the test is calculated as a mean
of the errors over all the variables.
</p>
<p>The criteria used to test the (functional) errors are the norms L1,
L2, L infinite, L1 on the maxima, L2 on the maxima, and L infinite on the
maxima.
</p>


<h3>Value</h3>

<p>It is a LIST with the following elements
</p>
<table>
<tr><td><code>cv</code></td>
<td>
<p>Matrix giving the various errors (L1, L2, L infinite, L1 on the
maxima, L2 on the maxima, L infinite on the maxima) for the tested
values of <code>kn</code></p>
</td></tr>
<tr><td><code>minL1</code></td>
<td>
<p>A vector corresponding to the row of <code>cv</code> where the
L1 error minima is obtained</p>
</td></tr>
<tr><td><code>minL2</code></td>
<td>
<p>A vector corresponding to the row of <code>cv</code> where the
L2 error minima is obtained</p>
</td></tr>
<tr><td><code>minLinf</code></td>
<td>
<p>A vector corresponding to the row of <code>cv</code> where the
L infinite error minima is obtained</p>
</td></tr>
<tr><td><code>minL1max</code></td>
<td>
<p>A vector corresponding to the row of <code>cv</code> where the
L1 maxima's error minima is obtained</p>
</td></tr>
<tr><td><code>minL2max</code></td>
<td>
<p>A vector corresponding to the row of <code>cv</code> where the
L2 maxima's error minima is obtained</p>
</td></tr>
<tr><td><code>minLinfmax</code></td>
<td>
<p>A vector corresponding to the row of <code>cv</code> where the
L infinite maxima's error minima is obtained</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+far">far</a></code>, <code><a href="#topic+fdata">fdata</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Cross validation (joined and separate)
  model1.cv &lt;- far.cv(data=data1, y="X", x="Z", kn=8, ncv=10, cvcrit="X",
                center=FALSE, na.rm=FALSE, joined=TRUE)
  model2.cv &lt;- far.cv(data=data1, y="X", x="Z", kn=c(4,4), ncv=10, cvcrit="X",
                center=FALSE, na.rm=FALSE, joined=FALSE)
  print(model1.cv)
  print(model2.cv)
  k1 &lt;- model1.cv$minL2[1]
  k2 &lt;- model2.cv$minL2[1:2]

  # Modelization of the FARX process (joined and separate)
  model1 &lt;- far(data=data1, y="X", x="Z", kn=k1,
                center=FALSE, na.rm=FALSE, joined=TRUE)
  model2 &lt;- far(data=data1, y="X", x="Z", kn=k2,
                center=FALSE, na.rm=FALSE, joined=FALSE)
  print(model1)
  print(model2)
</code></pre>

<hr>
<h2 id='fdata'> Functional Data class </h2><span id='topic+as.fdata'></span><span id='topic+as.fdata.default'></span><span id='topic+as.fdata.matrix'></span><span id='topic+as.fdata.array'></span><span id='topic+as.fdata.list'></span><span id='topic+fdata'></span><span id='topic+print.fdata'></span><span id='topic+summary.fdata'></span><span id='topic+print.summary.fdata'></span>

<h3>Description</h3>

<p>Object of class 'fdata' and its methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.fdata(object,...)
as.fdata.matrix(object,..., col, p, dates, name)
as.fdata.list(object,..., dates, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdata_+3A_object">object</code></td>
<td>
<p> A matrix or a list. </p>
</td></tr>
<tr><td><code id="fdata_+3A_col">col</code></td>
<td>
<p> A vector giving the names of the variables to include in
the 'fdata' object. </p>
</td></tr>
<tr><td><code id="fdata_+3A_p">p</code></td>
<td>
<p> A real value giving the number of discretization point chosen.</p>
</td></tr>
<tr><td><code id="fdata_+3A_dates">dates</code></td>
<td>
<p> A vector of character containing the dates of the observations.</p>
</td></tr>
<tr><td><code id="fdata_+3A_name">name</code></td>
<td>
<p> A vector of character containing the names of the
variables (generated if not provided). </p>
</td></tr>
<tr><td><code id="fdata_+3A_...">...</code></td>
<td>
<p> Additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fdata objects are mainly used to modelize functional data in the purpose
of computing functional autoregressive model by the
<code><a href="#topic+far">far</a></code> and <code><a href="#topic+kerfon">kerfon</a></code> functions.
</p>
<p>An fdata is composed of one or several variables.
Each ones is a functional time series.
</p>
<p>To be more precise, every variable got a functional data by
element of the <code>dates</code> (explicitly given or implicitly
deduced). So the number of functional observations is a common data.
</p>
<p>In the contrary, each variable can be expressed in a different
functional space. For example, if you got two variables,
Temperature and Wind, measured during 30 days. Choosing a daily
representation, the <code>fdata</code> will contain a 30 elements long
<code>dates</code> vector. Nevertheless, the variables measurement can be
different. If Temperature is measured every hour and Wind every two
hours, the <code>fdata</code> object can handle such a representation.
The only constraint is to get a regular measurement: no changes in the
methodology.
</p>
<p>Basically, the <code>fdata</code> objects are discrete measurements but the
modelization which can be used on it will make it functional.
Indeed, The first methods implemented as <code>far</code> and <code>kerfon</code>
use a linear approximation, but more sophisticate modelization, as
splines or wavelets approximations may come.
</p>


<h3>Value</h3>

<p>An object of class fdata.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+far">far</a></code>, <code><a href="#topic+multplot">multplot</a></code>,
<code><a href="#topic+maxfdata">maxfdata</a></code>, <code><a href="#topic+kerfon">kerfon</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reading of the data
library(stats)
data(UKDriverDeaths)

# Making the data of class 'fdata'
fUKDriverDeaths &lt;- as.fdata(UKDriverDeaths,col=1,p=12,dates=1969:1984,
                            name="UK Driver Deaths")
summary(fUKDriverDeaths)

# ploting of the data : whole and 1 year
par(mfrow=c(2,1))
plot(fUKDriverDeaths,xval=1969+(1:192)/12,whole=TRUE,
     name="Whole Evolution : ")
plot(fUKDriverDeaths,date="1984",xval=1:12,
     name="Evolution during year 1984 : ")

# Matrix conversion
print(as.fdata(matrix(rnorm(50),10,5)))
print(as.fdata(matrix(rnorm(500),100,5),col=1:2,p=5))

# List Conversions
print(as.fdata(list("X"=matrix(rnorm(100),10,10),
"Z"=matrix(rnorm(50),5,10))))
</code></pre>

<hr>
<h2 id='interpol.matrix'>Interpolation matrix</h2><span id='topic+interpol.matrix'></span>

<h3>Description</h3>

<p>Calculate the matrix giving the linear interpolation of regularly
spaced points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpol.matrix(n = 12, m = 24, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpol.matrix_+3A_n">n</code></td>
<td>
<p> Number (integer) of points in output space </p>
</td></tr>
<tr><td><code id="interpol.matrix_+3A_m">m</code></td>
<td>
<p> Number (integer) of points in the input function (or space) </p>
</td></tr>
<tr><td><code id="interpol.matrix_+3A_tol">tol</code></td>
<td>
<p> A relative tolerance to detect zero singular values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general principle is, considering a function for which we know
values at <code>m</code> equally spaced points (for instance 1/<code>m</code>,
2/<code>m</code>, ..., 1), to compute the matrix giving the linear
approximation of <code>n</code> equally spaced points (for instance
1/<code>n</code>, 2/<code>n</code>, ..., 1).
</p>
<p>The function works whether <code>n</code> or <code>m</code> is the largest.
</p>
<p>The function is vectorized, so <code>m</code> and <code>n</code> can be vectors of
integers. In this case, they have to be of the same size and the
resulting matrix is block diagonal.
</p>


<h3>Value</h3>

<p>A <code>n</code>x<code>m</code> matrix if they are integer, else a
<code>sum(n)</code>x<code>sum(m)</code> matrix.
</p>


<h3>Author(s)</h3>

<p>J. Damon</p>


<h3>See Also</h3>

 <p><code><a href="#topic+theoretical.coef">theoretical.coef</a></code>, <code><a href="#topic+simul.far">simul.far</a></code> or
<code><a href="#topic+simul.farx">simul.farx</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  mat1 &lt;- interpol.matrix(12,24)
  mat2 &lt;- interpol.matrix(c(3,5),c(12,12))
  print(mat1 %*% base.simul.far(24,5))
  print(mat2 %*% base.simul.far(24,5))  
</code></pre>

<hr>
<h2 id='invgen'> Generalized inverse of a Matrix </h2><span id='topic+invgen'></span>

<h3>Description</h3>

<p>Calculates the Moore-Penrose generalized inverse of a matrix X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invgen(a, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invgen_+3A_a">a</code></td>
<td>
<p> Matrix for which the Moore-Penrose inverse is required. </p>
</td></tr>
<tr><td><code id="invgen_+3A_tol">tol</code></td>
<td>
<p> A relative tolerance to detect zero singular values. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Moore-Penrose generalized inverse matrix for X.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+solve">solve</a></code>,<code><a href="base.html#topic+svd">svd</a></code>,<code><a href="base.html#topic+eigen">eigen</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  mat1&lt;-matrix(rnorm(100),ncol=10)
  print(invgen(mat1))
</code></pre>

<hr>
<h2 id='is.na.fdata'> Not Available / &ldquo;Missing&rdquo; Values </h2><span id='topic+is.na.fdata'></span>

<h3>Description</h3>

<p>The generic function is.na returns a logical vector of the same
&ldquo;form&rdquo; as its argument x, containing TRUE for those elements marked
NA or NaN (!) and FALSE otherwise. dim, dimnames and names attributes
are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fdata'
is.na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.na.fdata_+3A_x">x</code></td>
<td>
<p> A <code>fdata</code> object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An observation is considered as NA if any of its values is NA.
</p>


<h3>Value</h3>

<p>A matrix of Logical values giving as rows the variables of <code>x</code>
and as columns the observation.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+NA">NA</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Reading of the data
  library(stats)
  data(UKDriverDeaths)
  UKDriverDeaths[20]&lt;-NA

  # Making the data of class 'fdata'
  fUKDriverDeaths &lt;- as.fdata(UKDriverDeaths,col=1,p=12,dates=1969:1984,
                            name="UK Driver Deaths")
  summary(fUKDriverDeaths)
  is.na(fUKDriverDeaths)
</code></pre>

<hr>
<h2 id='kerfon'> Functional Kernel estimation </h2><span id='topic+kerfon'></span><span id='topic+print.kerfon'></span>

<h3>Description</h3>

<p>Modelization of <code>fdata</code> using functional kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kerfon(data, x, r, hmin, hmax, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kerfon_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object. </p>
</td></tr>
<tr><td><code id="kerfon_+3A_x">x</code></td>
<td>
<p> The name of the studied variable. </p>
</td></tr>
<tr><td><code id="kerfon_+3A_r">r</code></td>
<td>
<p> Number of observations used to cross validate the model. </p>
</td></tr>
<tr><td><code id="kerfon_+3A_hmin">hmin</code></td>
<td>
<p> Minimal value of the bandwidth. </p>
</td></tr>
<tr><td><code id="kerfon_+3A_hmax">hmax</code></td>
<td>
<p> Maximal value of the bandwidth. </p>
</td></tr>
<tr><td><code id="kerfon_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical. Does the <code>n.a.</code> need to be removed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs a functional kernel model and performs the
estimation of it's bandwidth.
</p>
<p>One nonparametric way to deal with the conditional expectation
<code class="reqn">\rho(x)=\mbox{I$\!$E}\left[  X_{i}\left|  X_{i-1}=x\right.  \right]</code>, where <code class="reqn">\left(X_{i}\right)</code> is a
$H$-valued process, is to consider a predictor inspired by the
classical kernel regression, as in Nadaraja and Watson. This estimator
is defined by :
</p>
<p style="text-align: center;"><code class="reqn">\hat{\rho}_{h_{n}}(x)=\frac{\sum\limits_{i=1}^{n-1}X_{i+1}\cdot%
      K\left(\frac{\left\|  X_{i}-x\right\|  _{H}}{h_{n}}\right)%
    }{\sum\limits_{i=1}^{n-1}K\left(  \frac{\left\|  X_{i}-x\right\|%
	_{H}}{h_{n}}\right)},x\in H</code>
</p>

<p>Where K is a kernel, <code class="reqn">\left\|.\right\|  _{H}</code> is the
norm in H, and <code class="reqn">h_n</code> is the bandwidth (<code class="reqn">\in
    \mbox{I$\!$R}^+_*</code>).
</p>
<p>The function <code>kerfon</code> use the cross validation to determinate a
value for <code class="reqn">h_n</code>. This method have been chosen because of the
lack of theoretical results about this model. The parameters
<code>hmin</code> and <code>hmax</code> are used, when provided, to control the
permissible values of <code class="reqn">h_n</code>. By default, those parameters are
respectively equals to <code class="reqn">\sigma/8</code> and <code class="reqn">4*\sigma</code>, where
<code class="reqn">\sigma</code> is the estimated squared root of the variance operator of
X. To choose the value of <code class="reqn">h_n</code>, you need to provide the same
value for both <code>hmin</code> and <code>hmax</code>.
</p>
<p>During the cross-validation, considering that the fdata object
<code>x</code> contains <code class="reqn">n</code> observations, the function use the first
<code class="reqn">(n-r)</code> observations as the past values, and compute the mean
square norm of the errors on the last <code class="reqn">r</code> observations.
</p>
<p>Of course, if the model created is then used to compute prediction
through <code><a href="#topic+predict.kerfon">predict.kerfon</a></code>, the whole set of observations (the
<code class="reqn">n</code> observations) are used as the past values.
</p>
<p>As <code>fdata</code> object may contains several variables, a way is
provided to select the studied variable (the function only works
with one variable for the moment).
</p>


<h3>Value</h3>

<p>A kerfon object. A method for the <code><a href="base.html#topic+print">print</a></code> function is
provided.
</p>
<p>For information, the object is a list with the following elements :
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>the bandwidth (three values : optimal, minimum, maximum)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the name of the chosen variable</p>
</td></tr>
<tr><td><code>xdata</code></td>
<td>
<p>the past values for <code>x</code></p>
</td></tr>
<tr><td><code>ydata</code></td>
<td>
<p>the associated values for <code>x</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict.kerfon">predict.kerfon</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Cross validation
  model1 &lt;- kerfon(data=data1, x="X", r=10, na.rm=TRUE)
  print(model1)
</code></pre>

<hr>
<h2 id='maxfdata'> Maxima of functional data </h2><span id='topic+maxfdata'></span>

<h3>Description</h3>

<p>Extract the maxima series from a functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxfdata(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxfdata_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fdata</code> object.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fapply">fapply</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  print(data2 &lt;- maxfdata(data1))
  print(unclass(data2))
</code></pre>

<hr>
<h2 id='multplot'> Multivariate plots </h2><span id='topic+multplot'></span><span id='topic+multplot.default'></span><span id='topic+multplot.fdata'></span>

<h3>Description</h3>

<p>Multivariate plots of Functional Data (more precisely <code>fdata</code>
objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multplot(object, ...)

## S3 method for class 'fdata'
 multplot(object, date = 1, xval = NULL, name = NULL, legend = FALSE,
    yleg, xlab = NULL, ylab = NULL, main = NULL, whole = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multplot_+3A_object">object</code></td>
<td>
<p> An <code>fdata</code> object for which a multplot is
desired. </p>
</td></tr>
<tr><td><code id="multplot_+3A_date">date</code></td>
<td>
<p> String vector. List of the dates to work with. </p>
</td></tr>
<tr><td><code id="multplot_+3A_xval">xval</code></td>
<td>
<p> Numerical vector. Values of the axis x. </p>
</td></tr>
<tr><td><code id="multplot_+3A_name">name</code></td>
<td>
<p> String vector. The set of variables to plot. </p>
</td></tr>
<tr><td><code id="multplot_+3A_legend">legend</code></td>
<td>
<p> Boolean. Plot a legend ? </p>
</td></tr>
<tr><td><code id="multplot_+3A_yleg">yleg</code></td>
<td>
<p> Numeric. Where to put the legend box (y value). </p>
</td></tr>
<tr><td><code id="multplot_+3A_xlab">xlab</code></td>
<td>
<p> String. Title of the axis x. </p>
</td></tr>
<tr><td><code id="multplot_+3A_ylab">ylab</code></td>
<td>
<p> String. Title of the axis y. </p>
</td></tr>
<tr><td><code id="multplot_+3A_main">main</code></td>
<td>
<p> String. Title of the plot. </p>
</td></tr>
<tr><td><code id="multplot_+3A_whole">whole</code></td>
<td>
<p> Boolean. A global plot (TRUE) or a plot by day (FALSE) </p>
</td></tr>
<tr><td><code id="multplot_+3A_...">...</code></td>
<td>
<p> Additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function facilitate the plotting of <code>fdata</code> objects.
It is dedicated to multivariate plots, please take a look at
<code><a href="#topic+plot.fdata">plot.fdata</a></code> if you need univariate plots in one graphic.
</p>
<p>The default behaviour is to produce one plot containing all the
variables of the observation called &quot;1&quot;.
</p>
<p>If you want less variables, use the <code>name</code> argument. If you need
more observations, use the <code>date</code> argument. When provided, the
<code>xval</code> argument allow you to change the labels of the x-axis.
</p>
<p>It is also possible to plot the complete series on the same plot using
the <code>whole</code> argument.
</p>
<p>Moreover a legend facility is provided using the <code>legend</code> and
<code>yleg</code> arguments.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fdata">fdata</a></code>, <code><a href="#topic+plot.fdata">plot.fdata</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=100,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

 # 2 variables : X et Z
 # number of points per curve : 10
 # number of curves : 100
 # corresponding dates
 date.fdata(data1)

 multplot(data1) # plot the date "1" of the variables "X" and "Z"
 multplot(data1,legend=TRUE) # Same thing with a legend
 multplot(data1,legend=TRUE,yleg=-0.5) # same thing with a legend misplaced
 multplot(data1,main="day 1",legend=TRUE,xlab="hour",
          ylab="object of study")

 par(mfrow=c(1,3))
 multplot(data1,date=c("3","4","5")) # days "3", "4" and "5" are plotted
 par(mfrow=c(1,1))

 # to plot the whole series, we used whole = TRUE
 # but we have to give the x values

 multplot(data1,xval=seq(from=0,to=99.9,by=0.1),whole=TRUE)

 # to plot a subset of the series,
 # it is recommended to create a subset object with select.fdata
 data2 &lt;- select.fdata(data1,date=c("4","5","6"))
 multplot(data2,xval=seq(from=4,to=6.9,by=0.1),whole=TRUE)
</code></pre>

<hr>
<h2 id='orthonormalization'> Orthonormalization of a set of a matrix </h2><span id='topic+orthonormalization'></span>

<h3>Description</h3>

<p>Gram-Schmidt orthogonalization of a matrix considering
its columns as vectors. Normalization is provided as will.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthonormalization(u, basis=TRUE, norm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthonormalization_+3A_u">u</code></td>
<td>
<p> a matrix (n x p) representing n different vectors 
in a n dimensional space  </p>
</td></tr>
<tr><td><code id="orthonormalization_+3A_basis">basis</code></td>
<td>
<p> does the returned matrix have to be a basis </p>
</td></tr>
<tr><td><code id="orthonormalization_+3A_norm">norm</code></td>
<td>
<p> does the returned vectors have to be normed </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple application of the Gram-Schmidt algorithm of 
orthogonalization (please note that this process was
presented first by Laplace).
</p>
<p>The user provides a set of vector (structured in a matrix)
and the function calculate a orthogonal basis of the same
space. If desired, the returned basis can be normed,
or/and completed to cover the hole space.
</p>
<p>If the number of vectors in <code>u</code> is greater than the
dimension of the space (that is if n &gt; p), only the first
p columns are taken into account to computed the result.
A warning is also provided.
</p>
<p>The only assumption made on <code>u</code> is that the span space
is of size min(n,p). In other words, there must be no
colinearities in the initial set of vector.
</p>


<h3>Value</h3>

<p>The orthogonalized matrix obtained from <code>u</code> where the
vector are arranged in columns.
</p>
<p>If <code>basis</code> is set to <code>TRUE</code>, the returned matrix
is squared.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>Examples</h3>

<pre><code class='language-R'>  mat1 &lt;- matrix(c(1,0,1,1,1,0),nrow=3,ncol=2)
  orth1 &lt;- orthonormalization(mat1, basis=FALSE, norm=FALSE)
  orth2 &lt;- orthonormalization(mat1, basis=FALSE, norm=TRUE)
  orth3 &lt;- orthonormalization(mat1, basis=TRUE, norm=TRUE)
  crossprod(orth1)
  crossprod(orth2)
  crossprod(orth3)
</code></pre>

<hr>
<h2 id='plot.fdata'> Plot Functional Data </h2><span id='topic+plot.fdata'></span>

<h3>Description</h3>

<p>Plot Functional Data (more precisely <code>fdata</code> objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fdata'
plot(x,...,date, xval, name, main, whole, separator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fdata_+3A_x">x</code></td>
<td>
<p> A <code>fdata</code> object. </p>
</td></tr>
<tr><td><code id="plot.fdata_+3A_date">date</code></td>
<td>
<p> A vector of character giving the chosen dates. </p>
</td></tr>
<tr><td><code id="plot.fdata_+3A_xval">xval</code></td>
<td>
<p> A numerical vector giving the values to appear on the x
axis. </p>
</td></tr>
<tr><td><code id="plot.fdata_+3A_name">name</code></td>
<td>
<p> A vector of character giving the plotted variables. </p>
</td></tr>
<tr><td><code id="plot.fdata_+3A_main">main</code></td>
<td>
<p> an overall title for the plot. </p>
</td></tr>
<tr><td><code id="plot.fdata_+3A_whole">whole</code></td>
<td>
<p> Logical. If <code>TRUE</code> all the observations are plot on
the same graphic. </p>
</td></tr>
<tr><td><code id="plot.fdata_+3A_separator">separator</code></td>
<td>
<p> Logical. It will be used when
<code>whole</code>=<code>TRUE</code>. If <code>TRUE</code> then dashed lines are
plotted to separated the observations. </p>
</td></tr>
<tr><td><code id="plot.fdata_+3A_...">...</code></td>
<td>
<p> Additional arguments to the plot. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function facilitate the plotting of <code>fdata</code> objects.
It is dedicated to univariate plots, please take a look at
<code><a href="#topic+multplot">multplot</a></code> if you need multivariate plots in one graphic.
</p>
<p>The default behaviour is to plot the observation called &quot;1&quot; of all the
variables available in <code>x</code> (so it will produce as many plots as
the number of variables).
</p>
<p>If you want less variables, use the <code>name</code> argument. If you need
more observations, use the <code>date</code> argument. When provided, the
<code>xval</code> argument allow you to change the labels of the x-axis.
</p>
<p>It is also possible to plot the complete series on the same plot using
the <code>whole</code> argument. In this case, the <code>separator</code> allow
you to draw line to distinguish the different observations of the
functional data.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fdata">fdata</a></code>, <code><a href="#topic+multplot">multplot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Reading of the data
  library(stats)
  data(UKDriverDeaths)

  # Making the data of class 'fdata'
  fUKDriverDeaths &lt;- as.fdata(UKDriverDeaths, col=1, p=12,
                            dates=1969:1984,
                            name="UK Driver Deaths")
  summary(fUKDriverDeaths)

  # plotting of the data : whole and 1 year
  par(mfrow=c(2,1))
  plot(fUKDriverDeaths, xval=1969+(1:192)/12,
       whole=TRUE, name="Whole Evolution : ", separator=TRUE)
  plot(fUKDriverDeaths, date="1984", xval=1:12,
       name="Evolution during year 1984 : ")
</code></pre>

<hr>
<h2 id='pred.persist'> Forecasting using functional persistence </h2><span id='topic+pred.persist'></span>

<h3>Description</h3>

<p>Compute prediction of functional data using the persistence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.persist(data, x, na.rm=TRUE, label, positive=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.persist_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object. </p>
</td></tr>
<tr><td><code id="pred.persist_+3A_x">x</code></td>
<td>
<p> A vector of character giving the names of the variables
predicted. </p>
</td></tr>
<tr><td><code id="pred.persist_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical. Does the <code>n.a.</code> need to be removed. </p>
</td></tr>
<tr><td><code id="pred.persist_+3A_label">label</code></td>
<td>
<p> A vector of character giving the dates to associate to
the predicted observations. </p>
</td></tr>
<tr><td><code id="pred.persist_+3A_positive">positive</code></td>
<td>
<p> Logical. Does the result must be forced to positive
values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The persistence model is a beautiful way to name the simplest model
ever. This model just suppose that the next observation will be equal
to the previous one, that is to say, noting <code class="reqn">\hat{X}_{n}</code>
the prediction for <code class="reqn">X_{n}</code> that we &quot;compute&quot; :
</p>
<p style="text-align: center;"><code class="reqn">\hat{X}_{n+1}=X_{n}</code>
</p>

<p>Of course, the intrinsic purpose of this model is to be a comparison
for more complicated  models.
</p>
<p>The <code>x</code> option is provided to select the variable to predict,
using the <code>label</code> option value as the labels for the new
observations. Notices that the output as the same length as the input
as it is only a shift in time.
</p>
<p>In some special context, the user may need to suppress the
<code>na.rm</code> observations with the <code>na.rm</code> option, or force the
prediction to be positive with the <code>positive</code> option (in this
case the maximum of 0 and the past value is computed).
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object.
</p>


<h3>Note</h3>

<p>This has been more instinctive to call this function predict.persist
but, due to the naming mechanism introduced by the object
oriented programming, this would have reefer to the predict method for
the persist objects. As it isn't the meaning of this function, we
preferred the name pred.persist. 
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict.far">predict.far</a></code>,<code><a href="#topic+predict.kerfon">predict.kerfon</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=40,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)
  print(data2 &lt;- pred.persist(data1,x="X",label="41"))
  print(unclass(select.fdata(data1,date=paste(38:40)))$X)
  print(unclass(select.fdata(data2,date=paste(39:41))))
</code></pre>

<hr>
<h2 id='predict.far'> Forecasting of FARX(1) model </h2><span id='topic+predict.far'></span>

<h3>Description</h3>

<p>Forecasting using FAR(1) or FARX(1) model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'far'
predict(object, ..., newdata=NULL, label, na.rm=TRUE, positive=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.far_+3A_object">object</code></td>
<td>
<p> A <code>far</code> object result of the <code>far</code> function. </p>
</td></tr>
<tr><td><code id="predict.far_+3A_newdata">newdata</code></td>
<td>
<p> A data matrix (one column for each observation) used to
predict the FAR(1) model from the values in newdata, or <code>NULL</code>
to predict one step forward with the data in <code>object</code>. </p>
</td></tr>
<tr><td><code id="predict.far_+3A_label">label</code></td>
<td>
<p> A vector of character giving the dates to associate to
the predicted observations. </p>
</td></tr>
<tr><td><code id="predict.far_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical. Does the <code>n.a.</code> need to be removed. </p>
</td></tr>
<tr><td><code id="predict.far_+3A_positive">positive</code></td>
<td>
<p> Logical. Does the result must be forced to positive values. </p>
</td></tr>
<tr><td><code id="predict.far_+3A_...">...</code></td>
<td>
<p> Additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes one step forward prediction for a
<code><a href="#topic+far">far</a></code> model.
</p>
<p>Use the <code>newdata</code> option to input the past values,
and the <code>label</code> option value to define the labels for the new
observations. Notices that the output as the same length as
<code>newdata</code> in the case of a FAR model, and the length of
<code>newdata</code> minus one in the case of a FARX model. This is due to
the time shift of the exogeneous variable: <code class="reqn">X_{t+1}</code> and
<code class="reqn">Y_{t}</code> are used in the computation of
<code class="reqn">\hat{Y}_{t+1}</code>.
</p>
<p>In some special context, the user may need to suppress the
<code>na.rm</code> observations with the <code>na.rm</code> option, or force the
prediction to be positive with the <code>positive</code> option (in this
case the result will be maximum of 0 and the predicted value).
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

<p><code><a href="#topic+far">far</a></code>, <code><a href="#topic+pred.persist">pred.persist</a></code>,
<code><a href="#topic+predict.kerfon">predict.kerfon</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Cross validation (joined and separate)
  model1.cv &lt;- far.cv(data=data1, y="X", x="Z", kn=8, ncv=10, cvcrit="X",
                center=FALSE, na.rm=FALSE, joined=TRUE)
  model2.cv &lt;- far.cv(data=data1, y="X", x="Z", kn=c(4,4), ncv=10, cvcrit="X",
                center=FALSE, na.rm=FALSE, joined=FALSE)
  print(model1.cv)
  print(model2.cv)
  k1 &lt;- model1.cv$minL2[1]
  k2 &lt;- model2.cv$minL2[1:2]

  # Modelization of the FARX process (joined and separate)
  model1 &lt;- far(data=data1, y="X", x="Z", kn=k1,
                center=FALSE, na.rm=FALSE, joined=TRUE)
  model2 &lt;- far(data=data1, y="X", x="Z", kn=k2,
                center=FALSE, na.rm=FALSE, joined=FALSE)

  # Predicting values
  pred1 &lt;- predict(model1,newdata=data1)
  pred2 &lt;- predict(model2,newdata=data1)
  # Persistence
  persist1 &lt;- pred.persist(select.fdata(data1,date=1:399),x="X")
  # Real values
  real1 &lt;- select.fdata(data1,date=2:400)

  errors0 &lt;- persist1[[1]]-real1[[1]]
  errors1 &lt;- pred1[[1]]-real1[[1]]
  errors2 &lt;- pred2[[1]]-real1[[1]]

  # Norm of observations
  summary(real1)
  # Persistence
  summary(as.fdata(errors0))
  # FARX models
  summary(as.fdata(errors1))
  summary(as.fdata(errors2))
</code></pre>

<hr>
<h2 id='predict.kerfon'> Forecasting of functional kernel model </h2><span id='topic+predict.kerfon'></span>

<h3>Description</h3>

<p>Computation of the prediction based on a functional kernel model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kerfon'
predict(object, ..., newdata=NULL, label, na.rm=TRUE, positive=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.kerfon_+3A_object">object</code></td>
<td>
<p> A <code>kerfon</code> object result of the <code>kerfon</code> function. </p>
</td></tr>
<tr><td><code id="predict.kerfon_+3A_newdata">newdata</code></td>
<td>
<p> A <code><a href="#topic+fdata">fdata</a></code> object used in the
<code>kerfon</code> model to compute the prediction, or <code>NULL</code>
to predict one step forward with the data in <code>object</code>. </p>
</td></tr>
<tr><td><code id="predict.kerfon_+3A_label">label</code></td>
<td>
<p> A vector of character giving the dates to associate to
the predicted observations. </p>
</td></tr>
<tr><td><code id="predict.kerfon_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical. Does the <code>n.a.</code> need to be removed. </p>
</td></tr>
<tr><td><code id="predict.kerfon_+3A_positive">positive</code></td>
<td>
<p> Logical. Does the result must be forced to positive values. </p>
</td></tr>
<tr><td><code id="predict.kerfon_+3A_...">...</code></td>
<td>
<p> Additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes one step forward prediction for a
<code><a href="#topic+kerfon">kerfon</a></code> model.
</p>
<p>Use the <code>newdata</code> option to input the past values,
and the <code>label</code> option value to define the labels for the new
observations. Notices that the output as the same length as
<code>newdata</code>.
</p>
<p>In some special context, the user may need to suppress the
<code>na.rm</code> observations with the <code>na.rm</code> option, or force the
prediction to be positive with the <code>positive</code> option (in this
case the result will be maximum of 0 and the predicted value).
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+kerfon">kerfon</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Cross validation
  model1 &lt;- kerfon(data=data1, x="X", r=10, na.rm=TRUE)
	print(model1)

  # Predicting values
  pred1 &lt;- predict(model1,newdata=select.fdata(data1,date=1:399))
  # Persistence
  persist1 &lt;- pred.persist(select.fdata(data1,date=1:399),x="X")
  # Real values
  real1 &lt;- select.fdata(data1,date=2:400)

  errors0 &lt;- persist1[[1]]-real1[[1]]
  errors1 &lt;- pred1[[1]]-real1[[1]]

  # Norm of observations
  summary(real1)
  # Persistence
  summary(as.fdata(errors0))
  # kerfon model
  summary(as.fdata(errors1))
</code></pre>

<hr>
<h2 id='select.fdata'> Subscript of fdata </h2><span id='topic+select.fdata'></span>

<h3>Description</h3>

<p>Use this function to subscript some functional observations of a
functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.fdata(data, date, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.fdata_+3A_data">data</code></td>
<td>
<p> A <code>fdata</code> object. </p>
</td></tr>
<tr><td><code id="select.fdata_+3A_date">date</code></td>
<td>
<p> A vector of character containing the chosen dates (could
be <code>NULL</code>). </p>
</td></tr>
<tr><td><code id="select.fdata_+3A_name">name</code></td>
<td>
<p> A vector giving the chosen name (could be <code>NULL</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function select one or several variables from <code>data</code>
and can also subset the dates. This is useful in order to
study the endogenous variables of a FARX process.
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fdata">fdata</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  print(data1)
  print(data1.X &lt;- select.fdata(data1,name="X"))
  print(data2 &lt;- select.fdata(data1,date=paste((1:5)*5)))
  date.fdata(data2)
</code></pre>

<hr>
<h2 id='simul.far'> FAR(1) process simulation </h2><span id='topic+simul.far'></span>

<h3>Description</h3>

<p>Simulation of a FAR process using a Gram-Schmidt basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.far(m=12,
  n=100,
  base=base.simul.far(24, 5),
  d.rho=diag(c(0.45, 0.9, 0.34, 0.45)),
  alpha=diag(c(0.5, 0.23, 0.018)),
  cst1=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.far_+3A_m">m</code></td>
<td>
<p> Integer. Number of discretization points. </p>
</td></tr>
<tr><td><code id="simul.far_+3A_n">n</code></td>
<td>
<p> Integer. Number of observations. </p>
</td></tr>
<tr><td><code id="simul.far_+3A_base">base</code></td>
<td>
<p> A functional basis expressed as a matrix, as the matrix
created by <code><a href="#topic+base.simul.far">base.simul.far</a></code> or with
<code><a href="#topic+orthonormalization">orthonormalization</a></code>.  </p>
</td></tr>
<tr><td><code id="simul.far_+3A_d.rho">d.rho</code></td>
<td>
<p> Numerical matrix. Expression of the first bloc of the
linear operator in the Gram-Schmidt basis. </p>
</td></tr>
<tr><td><code id="simul.far_+3A_alpha">alpha</code></td>
<td>
<p> Numerical matrix. Expression of the first bloc of the
covariance operator in the Gram-Schmidt basis. </p>
</td></tr>
<tr><td><code id="simul.far_+3A_cst1">cst1</code></td>
<td>
<p> Numeric. Perturbation coefficient on the linear
operator. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulate a FAR(1) process with a strong white noise.
</p>
<p>The simulation is realized in two steps.
</p>
<p>First step, the function compute a FAR(1) process <code class="reqn">T_n</code> in a
functional space (that we call in the sequel H) using a simple
equation and the <code>d.rho</code>, <code>alpha</code> and <code>cst</code> parameters.
</p>
<p>Second step, the process <code class="reqn">T_n</code> is projected in the canonical
basis using the <code>base</code> linear projector. 
</p>
<p>The <code>base</code> basis need to be a orthonormal basis wide enought. In the 
contrary, the function use the <code><a href="#topic+orthonormalization">orthonormalization</a></code> function
to make it so. Notice that the size of this matrix corresponds to the
dimension of the &quot;modelization space&quot; H (let's call it
<code class="reqn">m_2</code>). Of course, the larger <code>m2</code> the better the
functionnal approximation is. Whatever, keep in mind that
<code>m2</code>=2<code>m</code> is a good compromise, in order to avoid the memory
limits.
</p>
<p>In H, the linear operator <code class="reqn">\rho</code> is expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    \code{d.rho} &amp; 0 \cr%
    0 &amp; eps.rho%
    \end{array}\right)%
  </code>
</p>

<p>Where <code>d.rho</code> is the matrix provided in the call, the two 0 are
in fact two blocks of 0, and eps.rho is a diagonal matrix having on
his diagonal the terms:
</p>
<p style="text-align: center;"><code class="reqn">\left(\varepsilon_{k+1}, \varepsilon_{k+2}, \ldots, %
    \varepsilon_{\code{m2}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i}=\frac{\code{cst1}}{i^2}+%
    \frac{1-\code{cst1}}{e^i}</code>
</p>

<p>and k is the length of the <code>d.rho</code> diagonal.
</p>
<p>The <code>d.rho</code> matrix can be viewed as the information and the
eps.rho matrix as a perturbation. In this logic, the norm of eps.rho
need to be smaller than the one of <code>d.rho</code>.
</p>
<p>In H, <code class="reqn">C^T</code>, the covariance operator of <code class="reqn">T_n</code>, is
defined by:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    m_2 * \code{alpha} &amp; 0 \cr%
    0 &amp; eps.alpha%
    \end{array}\right)%
  </code>
</p>

<p>Where <code>alpha</code> is the matrix provided in the call, the two 0 are
in fact two blocks of 0, and eps.alpha is a diagonal matrix having on
his diagonal the terms:
</p>
<p style="text-align: center;"><code class="reqn">\left(\epsilon_{k+1}, \epsilon_{k+2}, \ldots, %
    \epsilon_{\code{m2}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_{i}=\frac{\code{cst1}}{i}</code>
</p>



<h3>Value</h3>

<p>A <code>fdata</code> object containing one variable (&quot;var&quot;) which is a
FAR(1) process of length <code>n</code> with <code>p</code> discretization
points.
</p>


<h3>Note</h3>

<p>To simulate <code class="reqn">T_n</code>, the function creates a white noise
<code class="reqn">E_n</code> having the following covariance operator:
</p>
<p style="text-align: center;"><code class="reqn">C^T - \rho * C^T * t({\rho})</code>
</p>

<p>where t(.) is the transposition operator.
<code class="reqn">T_n</code> is the computed using the equation:
</p>
<p style="text-align: center;"><code class="reqn">T_{n+1} = \rho * T_n + E_n</code>
</p>



<h3>Author(s)</h3>

<p> J. Damon, S. Guillas </p>


<h3>See Also</h3>

 <p><code><a href="#topic+simul.far.sde">simul.far.sde</a></code>, <code><a href="#topic+simul.far.wiener">simul.far.wiener</a></code>,
<code><a href="#topic+simul.farx">simul.farx</a></code>, <code><a href="#topic+simul.wiener">simul.wiener</a></code>,
<code><a href="#topic+base.simul.far">base.simul.far</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  far1 &lt;- simul.far(m=64,n=100)
  summary(far1)
  print(far(far1,kn=4))
  par(mfrow=c(2,1))
  plot(far1,date=1)
  plot(select.fdata(far1,date=1:5),whole=TRUE,separator=TRUE)
</code></pre>

<hr>
<h2 id='simul.far.sde'> FAR-SDE process simulation </h2><span id='topic+simul.far.sde'></span>

<h3>Description</h3>

<p>Simulation of a FAR process following an Stochastic
Differential Equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.far.sde(coef=c(0.4, 0.8), n=80, p=32, sigma=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.far.sde_+3A_coef">coef</code></td>
<td>
<p> Numerical vertor. It contains the two values of the
coefficients (<code class="reqn">a_1</code> and <code class="reqn">a_2</code>, see details for
more informations). </p>
</td></tr>
<tr><td><code id="simul.far.sde_+3A_n">n</code></td>
<td>
<p> Integer. The number of observations generated. </p>
</td></tr>
<tr><td><code id="simul.far.sde_+3A_p">p</code></td>
<td>
<p> Integer. The number of discretization points. </p>
</td></tr>
<tr><td><code id="simul.far.sde_+3A_sigma">sigma</code></td>
<td>
<p> Numeric. The standard deviation (see details for more
informations). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the simulation proposed by Besse and Cardot
(1996) to simulate a FAR process following the Stochastic Differential
Equation:
</p>
<p style="text-align: center;"><code class="reqn">dX^{(2)}+a_2.dX+a_1.X=\code{sigma}.dW</code>
</p>

<p>Where <code class="reqn">dX^{(2)}</code> and <code class="reqn">dX</code> stand respectively for
the second and first derivate of the process X, and W is a brownian
process.
</p>
<p>The coefficients <code class="reqn">a_1</code> and <code class="reqn">a_2</code> are the two first
elements of <code>coef</code>.
</p>
<p>The simulation use a order one approximation inspired by the work of
Milstein, as described in Besse and Cardot (1996).
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object containing one variable (&quot;var&quot;) which is a
FAR(1) process of length <code>n</code> with <code>p</code> discretization
points.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>References</h3>

<p> Besse, P. and Cardot, H. (1996).
<em>Approximation spline de la prévision d'un processus
fonctionnel autorégressif d'ordre 1</em>.
Revue Canadienne de Statistique/Canadian Journal of
Statistics, <b>24</b>, 467&ndash;487. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+simul.far">simul.far</a></code>, <code><a href="#topic+simul.far.wiener">simul.far.wiener</a></code>,
<code><a href="#topic+simul.farx">simul.farx</a></code>, <code><a href="#topic+simul.wiener">simul.wiener</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  far1 &lt;- simul.far.sde()
  summary(far1)
  print(far(far1,kn=2))
  par(mfrow=c(2,1))
  plot(far1,date=1)
  plot(select.fdata(far1,date=1:5),whole=TRUE,separator=TRUE)

</code></pre>

<hr>
<h2 id='simul.far.wiener'> FAR(1) process simulation with Wiener noise </h2><span id='topic+simul.far.wiener'></span>

<h3>Description</h3>

<p>Simulation of a FAR(1) process using a Wiener noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.far.wiener(m=64, n=128,
d.rho=diag(c(0.45, 0.9, 0.34, 0.45)), cst1=0.05, m2=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.far.wiener_+3A_m">m</code></td>
<td>
<p> Integer. Number of discretization points. </p>
</td></tr>
<tr><td><code id="simul.far.wiener_+3A_n">n</code></td>
<td>
<p> Integer. Number of observations. </p>
</td></tr>
<tr><td><code id="simul.far.wiener_+3A_d.rho">d.rho</code></td>
<td>
<p> Numerical matrix. Expression of the first bloc of the
linear operator in the Karhunen-Loève basis. </p>
</td></tr>
<tr><td><code id="simul.far.wiener_+3A_cst1">cst1</code></td>
<td>
<p> Numeric. Perturbation coefficient on the linear
operator. </p>
</td></tr>
<tr><td><code id="simul.far.wiener_+3A_m2">m2</code></td>
<td>
<p> Integer. Length of the Karhunen-Loève expansion (2<code>m</code>
by default). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulate a FAR(1) process with a Wiener noise. As for
the <code><a href="#topic+simul.wiener">simul.wiener</a></code>, the function use the Karhunen-Loève
expansion of the noise. The FAR(1) process, defined by its linear
operator (see <code><a href="#topic+far">far</a></code> for more details), is computed in the
Karhunen-Loève basis then projected in the natural basis. The
parameters given in input (<code>d.rho</code> and <code>cst1</code>) are expressed
in the Karhunen-Loève basis.
</p>
<p>The linear operator, expressed in the Karhunen-Loève basis, is of the
form:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    \code{d.rho} &amp; 0 \cr%
    0 &amp; eps.rho
    \end{array}\right)
  </code>
</p>

<p>Where <code>d.rho</code> is the matrix provided in ths call, the two 0 are
in fact two blocks of 0, and eps.rho is a diagonal matrix having on
his diagonal the terms:
</p>
<p style="text-align: center;"><code class="reqn">\left(\varepsilon_{k+1}, \varepsilon_{k+2}, \ldots, %
    \varepsilon_{\code{m2}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i}=\frac{\code{cst1}}{i^2}+%
    \frac{1-\code{cst1}}{e^i}</code>
</p>

<p>and k is the length of the <code>d.rho</code> diagonal.
</p>
<p>The <code>d.rho</code> matrix can be viewed as the information and the
eps.rho matrix as a perturbation. In this logic, the norm of eps.rho
need to be smaller than the one of <code>d.rho</code>.
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object containing one variable (&quot;var&quot;) which is a
FAR(1) process of length <code>n</code> with <code>m</code> discretization
points.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>References</h3>

<p> Pumo, B. (1992). <em>Estimation et Prévision de
Processus Autoregressifs Fonctionnels. Applications aux
Processus à Temps Continu.</em>
PhD Thesis, University Paris 6, Pierre et Marie Curie. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fdata">fdata</a></code>, <code><a href="#topic+far">far</a></code> ,
<code><a href="#topic+simul.far.wiener">simul.far.wiener</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  far1 &lt;- simul.far.wiener(m=64,n=100)
  summary(far1)
  print(far(far1,kn=4))
  par(mfrow=c(2,1))
  plot(far1,date=1)
  plot(select.fdata(far1,date=1:5),whole=TRUE,separator=TRUE)
</code></pre>

<hr>
<h2 id='simul.farx'> FARX(1) process simulation</h2><span id='topic+simul.farx'></span><span id='topic+theoretical.coef'></span>

<h3>Description</h3>

<p>Simulation of functional data with exogenous variables using a
Gram-Schmidt basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.farx(m=12,n=100,base=base.simul.far(24,5),
  base.exo=base.simul.far(24,5),
  d.a=matrix(c(0.5,0),nrow=1,ncol=2),
  alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
  d.rho=diag(c(0.45,0.90,0.34,0.45)),
  alpha=diag(c(0.5,0.23,0.018)),
  d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
  cst1=0.05)
theoretical.coef(m=12,base=base.simul.far(24,5),
  base.exo=NULL,
  d.rho=diag(c(0.45,0.90,0.34,0.45)),
  d.a=NULL,
  d.rho.exo=NULL,
  alpha=diag(c(0.5,0.23,0.018)),
  alpha.conj=NULL,
  cst1=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.farx_+3A_m">m</code></td>
<td>
<p> Integer. Number of discretization points. </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_n">n</code></td>
<td>
<p> Integer. Number of observations. </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_base">base</code></td>
<td>
<p> A functional basis expressed as a matrix, as the matrix
created by <code><a href="#topic+base.simul.far">base.simul.far</a></code> or with
<code><a href="#topic+orthonormalization">orthonormalization</a></code>.  </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_base.exo">base.exo</code></td>
<td>
<p> A functional basis expressed as a matrix, as the matrix
created by <code><a href="#topic+base.simul.far">base.simul.far</a></code> or with
<code><a href="#topic+orthonormalization">orthonormalization</a></code>.  </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_d.rho">d.rho</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_d.a">d.a</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_d.rho.exo">d.rho.exo</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_alpha">alpha</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_alpha.conj">alpha.conj</code></td>
<td>
<p> Numerical matrix.  Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td></tr>
<tr><td><code id="simul.farx_+3A_cst1">cst1</code></td>
<td>
<p> Numeric. Perturbation coefficient on the linear
operator. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simul.farx</code> function simulates a FARX(1) process with one
endogeneous variable, one exogeneous variable and a strong white
noise. To do so, the function uses the fact that a FARX(1) model can
be seen as a FAR(1) model in a wider space. Therefore, the method is
very similar to the one used by the function <code><a href="#topic+simul.far">simul.far</a></code>.
</p>
<p>The simulation is realized in two steps.
</p>
<p>First step, the function compute a FAR(1) process <code class="reqn">T_n</code> in a
functional space (that we call in the sequel H) using a simple
equation and the given parameters. <code class="reqn">T_n</code> is of the form
<code class="reqn">(T_{1n},T_{2n})</code> where <code class="reqn">T_{1n}</code> and
<code class="reqn">T_{2n}</code> are respectively the endogeneous and the exogeneous
parts of the process.
</p>
<p>Second step, the process <code class="reqn">T_n</code> is projected in the canonical
basis using the <code>base</code> and <code>base.exo</code> linear projectors to
give the endogeneous (<code class="reqn">X_n</code>) and the exogeneous
(<code class="reqn">Z_n</code>) variables respectively. 
</p>
<p>Those two basis need to be orthonormal and wide enought. In the
contrary, the function use the <code><a href="#topic+orthonormalization">orthonormalization</a></code>
function to make it so. Notice that the size of this matrix
corresponds to the dimension of the &quot;modelization space&quot; H (let's call
it <code class="reqn">m_2=m1_2+m2_2</code>). Of course, the larger <code>m2</code>
the better the functionnal approximation is. Whatever, keep in mind
that <code>m2</code>=2<code>m</code> is a good compromise, in order to avoid the
memory limits.
</p>
<p>In H, the linear operator <code class="reqn">\rho</code> is expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    d.rho.mod &amp; \code{d.a} \cr%
    0 &amp; d.rho.exo.mod%
    \end{array}\right)%
  </code>
</p>

<p>Where d.rho.mod and d.rho.exo.mod are modified version of the provided
<code>d.rho</code> and <code>d.rho.exo</code> respectively to avoid 0 on their
diagonal. More precisely, the 0 on their diaginals are replaced by:
</p>
<p style="text-align: center;"><code class="reqn">\left(\varepsilon_{k+1}, \varepsilon_{k+2}, \ldots, %
    \varepsilon_{\code{m2}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i}=\frac{\code{cst1}}{i^2}+%
    \frac{1-\code{cst1}}{e^i}</code>
</p>

<p>and k is the position in the <code>d.rho</code> or <code>d.r.ho.exo</code>
diagonal.
</p>
<p>In H, <code class="reqn">C^T</code>, the covariance operator of <code class="reqn">T_n</code>, is
defined by:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    alpha.mod &amp; alpha.conj.mod \cr%
    t(alpha.conj.mod) &amp; alpha.exo%
    \end{array}\right)%
  </code>
</p>

<p>Where alpha.mod and alpha.exo.mod are modified versions of
<code class="reqn">m1_2 * </code><code>alpha</code> and <code class="reqn">m2_2 * </code><code>alpha.conj</code> respectively to avoid 0 on their diagonal. More
precisely, the 0 on their diaginals are replaced by:
</p>
<p style="text-align: center;"><code class="reqn">\left(\epsilon_{k+1}, \epsilon_{k+2}, \ldots, %
    \epsilon_{\code{m2b}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_{i}=\frac{\code{cst1}}{i}</code>
</p>

<p>alpha.exo is a matrix representation of the covariance operator of
<code class="reqn">T_{2n}</code> and is obtained by inverting the following relation:
</p>
<p style="text-align: center;"><code class="reqn">alpha.conj.mod = d.rho.exo.mod * alpha.conj.mod * t(d.rho.mod) +%
    d.rho.exo.mod * mod.alpha * t(\code{d.a})</code>
</p>

<p>The <code>theoretical.coef</code> function is provided to help the user
making comparison. Calling this function with the same parameters that
where used in a simulation (realized with <code>simul.farx</code> or
<code>simul.far</code>), we obtain the parameters used internaly by the
function to make the simulation. Those values can therefore be
compared to those obtained with the estimation function <code>far</code>
(examples are provided below).
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object containing two variables (&quot;X&quot; the endogeous
variable, and &quot;Z&quot; the exogeneous variable) which is a FARX(1) process
of length <code>n</code> with <code>p</code> discretization points.
</p>


<h3>Note</h3>

<p>To simulate <code class="reqn">T_n</code>, the function creates a white noise
<code class="reqn">E_n</code> having the following covariance operator:
</p>
<p style="text-align: center;"><code class="reqn">C^T - \rho * C^T * t({\rho})</code>
</p>

<p>where t(.) is the transposition operator.
<code class="reqn">T_n</code> is the computed using the equation:
</p>
<p style="text-align: center;"><code class="reqn">T_{n+1} = \rho * T_n + E_n</code>
</p>



<h3>Author(s)</h3>

<p> J. Damon, S. Guillas </p>


<h3>See Also</h3>

 <p><code><a href="#topic+simul.far.sde">simul.far.sde</a></code>, <code><a href="#topic+simul.far.wiener">simul.far.wiener</a></code>,
<code><a href="#topic+simul.far">simul.far</a></code>, <code><a href="#topic+simul.wiener">simul.wiener</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Modelisation of the FARX process (joined and separate)
  model1 &lt;- far(data1,k=4,joined=TRUE)
  model2 &lt;- far(data1,k=c(3,1),joined=FALSE)

  # Calculation of the theoretical coefficients
  coef.theo &lt;- theoretical.coef(m=10,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Joined coefficient
  round(coef(model1),2)
  coef.theo$rho.T

  # Separate coefficient
  round(coef(model2),2)
  coef.theo$rho.X.Z
</code></pre>

<hr>
<h2 id='simul.wiener'> Wiener process simulation </h2><span id='topic+simul.wiener'></span>

<h3>Description</h3>

<p>Simulation of Wiener processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.wiener(m=64, n=1, m2=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.wiener_+3A_m">m</code></td>
<td>
<p> Integer. Number of discretization points. </p>
</td></tr>
<tr><td><code id="simul.wiener_+3A_n">n</code></td>
<td>
<p> Integer. Number of observations. </p>
</td></tr>
<tr><td><code id="simul.wiener_+3A_m2">m2</code></td>
<td>
<p> Integer. Length of the Karhunen-Loève expansion (2<code>m</code>
by default). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function use the known Karhunen-Loève expansion of Wiener
processes to simulate observations of such a process.
</p>
<p>The option <code>m2</code> is internally used to set the length of the
expansion. This expansion need to be larger than the number of
discretization points, but a too important value may slow down the
generation. The default value as been chosen as a compromise.
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object containing one variable (&quot;var&quot;) which is a Wiener
process of length <code>n</code> with <code>m</code> discretization points.
</p>


<h3>Author(s)</h3>

<p> J. Damon </p>


<h3>References</h3>

<p> Pumo, B. (1992). <em>Estimation et Prévision de Processus
Autoregressifs Fonctionnels. Applications aux Processus à Temps Continu.</em>
PhD Thesis, University Paris 6, Pierre et Marie Curie. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+simul.far.sde">simul.far.sde</a></code>, <code><a href="#topic+simul.far.wiener">simul.far.wiener</a></code>,
<code><a href="#topic+simul.farx">simul.farx</a></code>, <code><a href="#topic+simul.far">simul.far</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  noise &lt;- simul.wiener(m=64,n=100,m2=512)
  summary(noise)
  par(mfrow=c(2,1))
  plot(noise,date=1)
  plot(select.fdata(noise,date=1:5),whole=TRUE,separator=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
