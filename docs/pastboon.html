<!DOCTYPE html><html lang="en"><head><title>Help for package pastboon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pastboon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pastboon-package'>
<p>Simulation of Parameterized Stochastic Boolean Networks</p></a></li>
<li><a href='#calc_convergence_time'>
<p>Calculate convergence time-step for node activities</p></a></li>
<li><a href='#calc_node_activities'>
<p>Calculate activity rate for each node</p></a></li>
<li><a href='#count_pairwise_trans'>
<p>Count pairwise transitions between a given set of states</p></a></li>
<li><a href='#extract_edges'>
<p>Extract edges from a Boolean network</p></a></li>
<li><a href='#get_reached_states'>
<p>Obtain the reached states</p></a></li>
<li><a href='#lac_operon_net'>
<p>The lactose operon Boolean network</p></a></li>
<li><a href='#myeloid_diff_net'>
<p>The myeloid differentiation Boolean network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Parameterized Stochastic Boolean Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A Boolean network is a particular kind of discrete dynamical system where the variables are simple binary switches. Despite its simplicity, Boolean network modeling has been a successful method to describe the behavioral pattern of various phenomena. Applying stochastic noise to Boolean networks is a useful approach for representing the effects of various perturbing stimuli on complex systems. A number of methods have been developed to control noise effects on Boolean networks using parameters integrated into the update rules. This package provides functions to examine three such methods: Boolean network with perturbations (BNp), described by Trairatphisan et al. (2013) &lt;<a href="https://doi.org/10.1186%2F1478-811X-11-46">doi:10.1186/1478-811X-11-46</a>&gt;, stochastic discrete dynamical systems (SDDS), proposed by Murrugarra et al. (2012) &lt;<a href="https://doi.org/10.1186%2F1687-4153-2012-5">doi:10.1186/1687-4153-2012-5</a>&gt;, and Boolean network with probabilistic edge weights (PEW), presented by Deritei et al. (2022) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1010536">doi:10.1371/journal.pcbi.1010536</a>&gt;. This package includes source code derived from the 'BoolNet' package, which is licensed under the Artistic License 2.0.</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohammad Taheri-Ledari
    <a href="https://orcid.org/0009-0007-9132-077X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Kaveh Kavousi <a href="https://orcid.org/0000-0002-1906-3912"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sayed-Amir Marashi
    <a href="https://orcid.org/0000-0001-9801-7449"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Authors of BoolNet [ctb] (Original authors of the BoolNet package),
  Troy D. Hanson [ctb] (Contributed uthash macros)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohammad Taheri-Ledari &lt;mo.taheri@ut.ac.ir&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BoolNet</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/taherimo/pastboon/issues">https://github.com/taherimo/pastboon/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-24 18:56:30 UTC; taheri</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-24 19:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='pastboon-package'>
Simulation of Parameterized Stochastic Boolean Networks
</h2><span id='topic+pastboon-package'></span><span id='topic+pastboon'></span>

<h3>Description</h3>

<p>A Boolean network is a particular kind of discrete dynamical system where the variables are simple binary switches. Despite its simplicity, Boolean network modeling has been a successful method to describe the behavioral pattern of various phenomena. Applying stochastic noise to Boolean networks is a useful approach for representing the effects of various perturbing stimuli on complex systems. A number of methods have been developed to control noise effects on Boolean networks using parameters integrated into the update rules. This package provides functions to simulate and analyze three such methods: <em>Boolean network with perturbations</em> (BNp), described by Trairatphisan et al., <em>stochastic discrete dynamical systems</em> (SDDS), proposed by Murrugarra et al., and <em>Boolean network with probabilistic edge weights</em> (PEW), presented by Deritei et al. The package includes source code derived from the <code>BoolNet</code> package, which is licensed under the Artistic License 2.0.
</p>


<h3>Details</h3>

<p>Applying perturbations to a standard deterministic Boolean network involves altering its update rules. Manipulating the logical functions usually requires a thorough understanding of the reasoning behind the Boolean equations and may lead to a loss of the network's main functional characteristics, which often need to be preserved. An alternative approach to perturbing a Boolean network is to introduce stochastic noise and control its effect through a set of parameters integrated into the logical functions. This approach offers the advantage of allowing partial activation or inhibition of nodes.
</p>
<p>In <code>pastboon</code>, three parameterization methods are implemented to control the stochastic noise effect on Boolean networks:
</p>

<ul>
<li><p>BNp, <em>Boolean network with perturbations</em> (Trairatphisan et al.)
</p>
</li>
<li><p>SDDS, <em>Stochastic discrete dynamical systems</em> (Murrugarra et al.)
</p>
</li>
<li><p>PEW, <em>Boolean network with probabilistic edge weights</em> (Deritei et al.)
</p>
</li></ul>

<p>Given a Boolean network, its parameterization method, and the parameter values, useful insights can be gained from network simulations using the functions provided in this package. Node activities (the average state of the nodes at each time-step) in the form of a time-series can be calculated using <code><a href="#topic+calc_node_activities">calc_node_activities</a></code>. By having a time-series representing node activities, the time-step at which the network reaches a steady-state distribution can be estimated using <code><a href="#topic+calc_convergence_time">calc_convergence_time</a></code>. Additionally, the states reached after starting a Boolean network from a given set of initial states can be sampled over specified time-steps using <code><a href="#topic+get_reached_states">get_reached_states</a></code>. The number of pairwise transitions between a given set of states can be obtained using <code><a href="#topic+count_pairwise_trans">count_pairwise_trans</a></code>. Finally, the edges of a Boolean network can be extracted using <code><a href="#topic+extract_edges">extract_edges</a></code>.
</p>
<p>This package includes source code derived from the <code>BoolNet</code> package, which is licensed under the Artistic License 2.0. Specifically, the C code for simulating Boolean networks and its R interface code were initially taken from the <code>BoolNet</code> package but have been substantially altered (particularly the C code) to meet our purposes.
</p>


<h3>Author(s)</h3>

<p>Mohammad Taheri-Ledari [aut, cre, cph] &lt;mo.taheri@ut.ac.ir&gt;
</p>
<p>Kaveh Kavousi [ctb]
</p>
<p>Sayed-Amir Marashi [ctb]
</p>
<p>Authors of BoolNet [ctb]
</p>
<p>Troy D. Hanson [ctb]
</p>


<h3>References</h3>

<p>Trairatphisan, P., Mizera, A., Pang, J., Tantar, A. A., Schneider, J., &amp; Sauter, T. (2013). Recent development and biomedical applications of probabilistic Boolean networks. <em>Cell communication and signaling</em>, 11, 1-25.
</p>
<p>Murrugarra, D., Veliz-Cuba, A., Aguilar, B., Arat, S., &amp; Laubenbacher, R. (2012). Modeling stochasticity and variability in gene regulatory networks. <em>EURASIP Journal on Bioinformatics and Systems Biology</em>, 2012, 1-11.
</p>
<p>Deritei, D., Kunšič, N., &amp; Csermely, P. (2022). Probabilistic edge weights fine-tune Boolean network dynamics. <em>PLoS Computational Biology</em>, 18(10), e1010536.
</p>
<p>Müssel, C., Hopfensitz, M., &amp; Kestler, H. A. (2010). BoolNet—an R package for generation, reconstruction and analysis of Boolean networks. <em>Bioinformatics</em>, 26(10), 1378-1380.
</p>

<hr>
<h2 id='calc_convergence_time'>
Calculate convergence time-step for node activities
</h2><span id='topic+calc_convergence_time'></span>

<h3>Description</h3>

<p>Given a node activity time-series for a set of variables <code>node_act</code>, this function calculates the time-step from which the changes in all the curves are below <code>threshold</code> for <code>window_size</code> consecutive time-steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_convergence_time(node_act, threshold, window_size = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_convergence_time_+3A_node_act">node_act</code></td>
<td>
<p>A matrix describing node activities over consecutive time-steps (i.e., time-series), where rows represent time-steps and columns represent nodes. It is the output of <code><a href="#topic+calc_node_activities">calc_node_activities</a></code>.</p>
</td></tr>
<tr><td><code id="calc_convergence_time_+3A_threshold">threshold</code></td>
<td>
<p>A value determining the maximum allowable change in node activities to decide if they have converged.</p>
</td></tr>
<tr><td><code id="calc_convergence_time_+3A_window_size">window_size</code></td>
<td>
<p>The number of consecutive time-steps for which the node activity curves must remain stable (i.e., changes below <code>threshold</code>) to be considered converged. The default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks if the changes in all node activity curves are less than <code>threshold</code> for <code>window_size</code> consecutive time-steps. If this condition is met, the node activity curves are considered to have converged to their stable values, and the convergence time-step (the starting point of the window) is returned. Since node activities represent marginal probabilities of the nodes being active at each time-step, convergence indicates that the steady-state distribution of the corresponding Boolean network has been reached, meaning that the probability of being in each state of the network no longer changes significantly.
</p>


<h3>Value</h3>

<p>The time-step at which convergence occurs. If no convergence is detected, <code>NA</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the example network
data(lac_operon_net)

# Define parameters for the SDDS method
props &lt;- rep(0.95, length(lac_operon_net$genes))
params &lt;- list(p00 = props, p01 = props, p10 = props, p11 = props)

# Get node activities after simulation using the SDDS method
node_act &lt;- calc_node_activities(lac_operon_net, method = "SDDS", params = params,
    steps = 100, repeats = 10000)

# Calculate the convergence time
convergence_time &lt;- calc_convergence_time(node_act, threshold = 0.01)


# Print the convergence time
print(convergence_time)
</code></pre>

<hr>
<h2 id='calc_node_activities'>
Calculate activity rate for each node
</h2><span id='topic+calc_node_activities'></span>

<h3>Description</h3>

<p>Calculates the activity rate of the nodes (i.e., the number of times a node is active, i.e., ON, divided by the number of repeats) for a specified number of time-steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_node_activities(net, method = c("BNp", "SDDS", "PEW"), params, steps,
                     repeats = 1000, initial_prob = NULL, last_step = FALSE,
                     asynchronous = TRUE, update_prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_node_activities_+3A_net">net</code></td>
<td>
<p>A network structure of the class <code>BooleanNetwork</code> from the <code>BoolNet</code> package.</p>
</td></tr>
<tr><td><code id="calc_node_activities_+3A_method">method</code></td>
<td>
<p>The parameterization method to be used. Options are:
</p>

<ul>
<li> <p><code>"BNp"</code>: Boolean network with perturbations.
</p>
</li>
<li> <p><code>"SDDS"</code>: Stochastic discrete dynamical systems.
</p>
</li>
<li> <p><code>"PEW"</code>: Boolean network with probabilistic edge weights.
</p>
</li></ul>

<p>Each method requires a different format for the <code>params</code> argument.
</p>
</td></tr>
<tr><td><code id="calc_node_activities_+3A_params">params</code></td>
<td>
<p>The parameter values depending on <code>method</code>:
</p>

<ul>
<li><p> For <code>method = "BNp"</code>, a single vector of probabilities, equal in length to the number of network nodes.
</p>
</li>
<li><p> For <code>method = "SDDS"</code>, a list of four equal-length vectors of probabilities: <code>p00</code>, <code>p01</code>, <code>p10</code>, and <code>p11</code>, each equal in length to the number of network nodes.
</p>
</li>
<li><p> For <code>method = "PEW"</code>, a list of two equal-length vectors of probabilities: <code>p_on</code> and <code>p_off</code>, each as long as the number of network edges, ordered according to <code><a href="#topic+extract_edges">extract_edges</a></code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="calc_node_activities_+3A_steps">steps</code></td>
<td>
<p>The number of time-steps (non-negative integer) to simulate the network.</p>
</td></tr>
<tr><td><code id="calc_node_activities_+3A_repeats">repeats</code></td>
<td>
<p>The number of repeats (positive integer).</p>
</td></tr>
<tr><td><code id="calc_node_activities_+3A_initial_prob">initial_prob</code></td>
<td>
<p>The probability that each of the nodes is ON (1) in the initial state (time-step 0). It should be a vector of probabilities for each of the nodes which doesn't necessarily sum up to one. If <code>NULL</code> (default), 0.5 is used as the probability for all nodes, meaning the initial state is randomly chosen based on a uniform distribution.</p>
</td></tr>
<tr><td><code id="calc_node_activities_+3A_last_step">last_step</code></td>
<td>
<p>If <code>TRUE</code>, only the node activity rates for the last time-step are returned. Otherwise, the node activity rates for all time-steps in the form of a time-series are returned.</p>
</td></tr>
<tr><td><code id="calc_node_activities_+3A_asynchronous">asynchronous</code></td>
<td>
<p>If <code>TRUE</code>, the asynchronous update scheme is used, where a single node is updated at each time-step. In this case, <code>update_prob</code> indicates update probabilities. If <code>FALSE</code>, the synchronous update scheme is utilized.</p>
</td></tr>
<tr><td><code id="calc_node_activities_+3A_update_prob">update_prob</code></td>
<td>
<p>The probability of updating each variable (node) in each time-step when <code>asynchronous = TRUE</code>. It should be a vector of probabilities for each of the nodes which sums up to one. If <code>NULL</code> (default), nodes are updated randomly based on a uniform distribution. If <code>asynchronous = FALSE</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By incorporating stochasticity into the update rule of a Boolean network and repeating the simulation several times, the average value of each node across the repeats can be considered as a continuous variable. This approach transforms discrete binary variables into continuous ones, enabling continuous analysis methods applicable for studying the dynamic behavior of the Boolean network. This function calculates the average value (i.e., node activity rate) of each network node at each time-step.</p>


<h3>Value</h3>

<p>If <code>last_step = TRUE</code>, a vector with a length equal to the number of network nodes, representing the activity rate of each node at the last time-step, is returned. If <code>last_step = FALSE</code>, a matrix with <code>steps + 1</code> rows (where the first row corresponds to time-step 0) and <code>length(net$genes)</code> columns (representing node activities at each time-step) is returned. The order of the nodes in the vector or columns (depending on <code>last_step</code>) is the same as <code>net$genes</code>.
</p>


<h3>References</h3>

<p>Golinelli, O., &amp; Derrida, B. (1989). Barrier heights in the Kauffman model. <em>Journal De Physique</em>, 50(13), 1587-1601.
Shmulevich, I., Dougherty, E. R., &amp; Zhang, W. (2002). Gene perturbation and intervention in probabilistic Boolean networks. <em>Bioinformatics</em>, 18(10), 1319-1331.
</p>
<p>Shmulevich, I., Dougherty, E. R., &amp; Zhang, W. (2002). Gene perturbation and intervention in probabilistic Boolean networks. <em>Bioinformatics</em>, 18(10), 1319-1331.
</p>
<p>Trairatphisan, P., Mizera, A., Pang, J., Tantar, A. A., Schneider, J., &amp; Sauter, T. (2013). Recent development and biomedical applications of probabilistic Boolean networks. <em>Cell communication and signaling</em>, 11, 1-25.
</p>
<p>Murrugarra, D., Veliz-Cuba, A., Aguilar, B., Arat, S., &amp; Laubenbacher, R. (2012). Modeling stochasticity and variability in gene regulatory networks. <em>EURASIP Journal on Bioinformatics and Systems Biology</em>, 2012, 1-11.
</p>
<p>Deritei, D., Kunšič, N., &amp; Csermely, P. (2022). Probabilistic edge weights fine-tune Boolean network dynamics. <em>PLoS Computational Biology</em>, 18(10), e1010536.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Load network and generate random initial states  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Load the example network
data(lac_operon_net)

# Function to generate distinct colors for plot
generate_colors &lt;- function(n) {
  hues &lt;- seq(0, 1, length.out = n + 1)[-1]
  s &lt;- 0.8
  v &lt;- 0.6
  colors &lt;- hsv(h = hues, s = s, v = v)
  return(colors)
}

# Generate distinct colors
col_vec &lt;- generate_colors(length(lac_operon_net$genes))
col_vec &lt;- col_vec[sample(1:length(col_vec))]

# Define plot function
plot_node_activities &lt;- function(node_activities, xlab, ylab) {
  old_par &lt;- par(no.readonly = TRUE)
  layout(matrix(c(1, 2), nrow = 1), width = c(4, 1))
  par(mar = c(5, 4, 4, 0))
  matplot(1:nrow(node_activities), node_activities, type = "l", frame = TRUE, lwd = 2,
          lty = 1, xlab = xlab, ylab = ylab, col = col_vec)
  par(mar = c(5, 0, 4, 2))
  plot(c(0, 1), type = "n", axes = FALSE, xlab = "")
  legend("center", colnames(node_activities), col = col_vec,
         cex = 0.5, fill = col_vec)
  layout(matrix(1))
  par(old_par)
}

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: BNp  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the BNp method
params &lt;- rep(0.05, length(lac_operon_net$genes))

# Get node activities after simulation using the BNp method
node_act &lt;- calc_node_activities(lac_operon_net, method = "BNp", params = params,
    steps = 100, repeats = 10000)

# Plot node activities
plot_node_activities(node_act, "Time-step", "Node activity")

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: SDDS  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the SDDS method
props &lt;- rep(0.95, length(lac_operon_net$genes))
params &lt;- list(p00 = props, p01 = props, p10 = props, p11 = props)

# Get node activities after simulation using the SDDS method
node_act &lt;- calc_node_activities(lac_operon_net, method = "SDDS", params = params,
    steps = 100, repeats = 10000)

# Plot node activities
plot_node_activities(node_act, "Time-step", "Node activity")

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: PEW  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Extract edges from the network
edges &lt;- extract_edges(lac_operon_net)

# Define the parameters for the PEW method
p_on &lt;- runif(nrow(edges))
p_off &lt;- runif(nrow(edges))
params &lt;- list(p_on = p_on, p_off = p_off)

# Get node activities after simulation using the PEW method
node_act &lt;- calc_node_activities(lac_operon_net, method = "PEW", params = params,
    steps = 100, repeats = 10000)

# Plot node activities
plot_node_activities(node_act, "Time-step", "Node activity")
</code></pre>

<hr>
<h2 id='count_pairwise_trans'>
Count pairwise transitions between a given set of states
</h2><span id='topic+count_pairwise_trans'></span>

<h3>Description</h3>

<p>Counts the frequencies of transitions between each pair of states from a given set of states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_pairwise_trans(net, method = c("BNp", "SDDS", "PEW"), params, states,
                     steps = 1, repeats = 1000, asynchronous = TRUE,
                     update_prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_pairwise_trans_+3A_net">net</code></td>
<td>
<p>A network structure of the class <code>BooleanNetwork</code> from the <code>BoolNet</code> package.</p>
</td></tr>
<tr><td><code id="count_pairwise_trans_+3A_method">method</code></td>
<td>
<p>The parameterization method to be used. Options are:
</p>

<ul>
<li> <p><code>"BNp"</code>: Boolean network with perturbations.
</p>
</li>
<li> <p><code>"SDDS"</code>: Stochastic discrete dynamical systems.
</p>
</li>
<li> <p><code>"PEW"</code>: Boolean network with probabilistic edge weights.
</p>
</li></ul>

<p>Each method requires a different format for the <code>params</code> argument.
</p>
</td></tr>
<tr><td><code id="count_pairwise_trans_+3A_params">params</code></td>
<td>
<p>The parameter values depending on <code>method</code>:
</p>

<ul>
<li><p> For <code>method = "BNp"</code>, a single vector of probabilities, equal in length to the number of network nodes.
</p>
</li>
<li><p> For <code>method = "SDDS"</code>, a list of four equal-length vectors of probabilities: <code>p00</code>, <code>p01</code>, <code>p10</code>, and <code>p11</code>, each equal in length to the number of network nodes.
</p>
</li>
<li><p> For <code>method = "PEW"</code>, a list of two equal-length vectors of probabilities: <code>p_on</code> and <code>p_off</code>, each as long as the number of network edges, ordered according to <code><a href="#topic+extract_edges">extract_edges</a></code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="count_pairwise_trans_+3A_states">states</code></td>
<td>
<p>The network states among which pairwise transitions are to be counted. This should be a matrix (where the rows represent the binary form of the states) or a vector (for the binary form of a single state). The number of matrix columns (or the length of the vector) should match the number of network nodes.</p>
</td></tr>
<tr><td><code id="count_pairwise_trans_+3A_steps">steps</code></td>
<td>
<p>The number of time-steps, which should be a non-negative integer.</p>
</td></tr>
<tr><td><code id="count_pairwise_trans_+3A_repeats">repeats</code></td>
<td>
<p>The number of repeats, which should be a positive integer.</p>
</td></tr>
<tr><td><code id="count_pairwise_trans_+3A_asynchronous">asynchronous</code></td>
<td>
<p>If <code>TRUE</code>, the asynchronous update scheme is used, where a single node is updated at each time-step. In this case, <code>update_prob</code> indicates update probabilities. If <code>FALSE</code>, the synchronous update scheme is utilized.</p>
</td></tr>
<tr><td><code id="count_pairwise_trans_+3A_update_prob">update_prob</code></td>
<td>
<p>The probability of updating each variable (node) in each time-step when <code>asynchronous = TRUE</code>. It should be a vector of probabilities for each of the nodes which sums up to one. If <code>NULL</code> (default), nodes are updated randomly based on a uniform distribution. If <code>asynchronous = FALSE</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Counting the number of transitions between each pair of states reveals the reachability of one state from another. This function performs simulations by starting from each state in <code>states</code> for <code>steps</code> time-steps and <code>repeats</code> iterations, and counts the number of transitions to other states in <code>states</code>.
</p>


<h3>Value</h3>

<p>A matrix where each element (i, j) represents the number of transitions from the <em>i</em>th state to the <em>j</em>th state across <code>steps</code> time-steps and <code>repeats</code> iterations.
</p>


<h3>References</h3>

<p>Golinelli, O., &amp; Derrida, B. (1989). Barrier heights in the Kauffman model. <em>Journal De Physique</em>, 50(13), 1587-1601.
</p>
<p>Shmulevich, I., Dougherty, E. R., &amp; Zhang, W. (2002). Gene perturbation and intervention in probabilistic Boolean networks. <em>Bioinformatics</em>, 18(10), 1319-1331.
</p>
<p>Trairatphisan, P., Mizera, A., Pang, J., Tantar, A. A., Schneider, J., &amp; Sauter, T. (2013). Recent development and biomedical applications of probabilistic Boolean networks. <em>Cell communication and signaling</em>, 11, 1-25.
</p>
<p>Murrugarra, D., Veliz-Cuba, A., Aguilar, B., Arat, S., &amp; Laubenbacher, R. (2012). Modeling stochasticity and variability in gene regulatory networks. <em>EURASIP Journal on Bioinformatics and Systems Biology</em>, 2012, 1-11.
</p>
<p>Deritei, D., Kunšič, N., &amp; Csermely, P. (2022). Probabilistic edge weights fine-tune Boolean network dynamics. <em>PLoS Computational Biology</em>, 18(10), e1010536.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Load network and generate random initial states  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Load the example network
data(lac_operon_net)

# Generate some random states
states &lt;- matrix(sample(c(0, 1), 10 * length(lac_operon_net$genes),
    replace = TRUE), nrow = 10, ncol = length(lac_operon_net$genes))

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: BNp  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the BNp method
params &lt;- rep(0.05, length(lac_operon_net$genes))

# Obtain frequency of pairwise transitions
pairwise_trans &lt;- count_pairwise_trans(lac_operon_net, states = states,
    method = "BNp", params = params, steps = 100, repeats = 10)

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: SDDS  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the SDDS method
props &lt;- rep(0.95, length(lac_operon_net$genes))
params &lt;- list(p00 = props, p01 = props, p10 = props, p11 = props)

# Obtain frequency of pairwise transitions
pairwise_trans &lt;- count_pairwise_trans(lac_operon_net, states = states,
    method = "SDDS", params = params, steps = 100, repeats = 10)

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: PEW  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Extract edges from the network
edges &lt;- extract_edges(lac_operon_net)

# Define the parameters for the PEW method
p_on &lt;- runif(nrow(edges))
p_off &lt;- runif(nrow(edges))
params &lt;- list(p_on = p_on, p_off = p_off)

# Obtain frequency of pairwise transitions
pairwise_trans &lt;- count_pairwise_trans(lac_operon_net, states = states,
    method = "PEW", params = params, steps = 100, repeats = 10)
</code></pre>

<hr>
<h2 id='extract_edges'>
Extract edges from a Boolean network
</h2><span id='topic+extract_edges'></span>

<h3>Description</h3>

<p>Extracts the list of directed edges (links) from a given Boolean network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_edges(net, node_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_edges_+3A_net">net</code></td>
<td>
<p>A network structure of the class <code>BooleanNetwork</code> from the <code>BoolNet</code> package.</p>
</td></tr>
<tr><td><code id="extract_edges_+3A_node_names">node_names</code></td>
<td>
<p>If TRUE (default), the edges are returned by node names; otherwise, the edges are returned by node indices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since Boolean networks have a directed graph topology, this function extracts the list of directed edges from a given Boolean network.
</p>


<h3>Value</h3>

<p>A data frame where each row corresponds to a directed edge of the network and the two columns indicate the source and destination of each edge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the example network
data(lac_operon_net)

# Extract edges from the network
edges &lt;- extract_edges(lac_operon_net)
</code></pre>

<hr>
<h2 id='get_reached_states'>
Obtain the reached states
</h2><span id='topic+get_reached_states'></span>

<h3>Description</h3>

<p>Obtains the reached states after simulating a Boolean network for a specified number of time-steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reached_states(net, method = c("BNp", "SDDS", "PEW"), params, steps,
                   repeats = NULL, initial_states = NULL, asynchronous = TRUE,
                   update_prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_reached_states_+3A_net">net</code></td>
<td>
<p>A network structure of the class <code>BooleanNetwork</code> from the <code>BoolNet</code> package.</p>
</td></tr>
<tr><td><code id="get_reached_states_+3A_method">method</code></td>
<td>
<p>The parameterization method to be used. Options are:
</p>

<ul>
<li> <p><code>"BNp"</code>: Boolean network with perturbations.
</p>
</li>
<li> <p><code>"SDDS"</code>: Stochastic discrete dynamical systems.
</p>
</li>
<li> <p><code>"PEW"</code>: Boolean network with probabilistic edge weights.
</p>
</li></ul>

<p>Each method requires a different format for the <code>params</code> argument.
</p>
</td></tr>
<tr><td><code id="get_reached_states_+3A_params">params</code></td>
<td>
<p>The parameter values depending on <code>method</code>:
</p>

<ul>
<li><p> For <code>method = "BNp"</code>, a single vector of probabilities, equal in length to the number of network nodes.
</p>
</li>
<li><p> For <code>method = "SDDS"</code>, a list of four equal-length vectors of probabilities: <code>p00</code>, <code>p01</code>, <code>p10</code>, and <code>p11</code>, each equal in length to the number of network nodes.
</p>
</li>
<li><p> For <code>method = "PEW"</code>, a list of two equal-length vectors of probabilities: <code>p_on</code> and <code>p_off</code>, each as long as the number of network edges, ordered according to <code><a href="#topic+extract_edges">extract_edges</a></code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="get_reached_states_+3A_steps">steps</code></td>
<td>
<p>The number of time-steps (non-negative integer) to simulate the network.</p>
</td></tr>
<tr><td><code id="get_reached_states_+3A_repeats">repeats</code></td>
<td>
<p>The number of repeats (positive integer). If two or more initial states are provided via <code>initial_states</code>, this argument is ignored. If <code>NULL</code> (default), then <code>initial_states</code> should not be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_reached_states_+3A_initial_states">initial_states</code></td>
<td>
<p>The set of initial states as a matrix (where each row corresponds to the binary form of a state) or a vector (for the binary form of a single initial state). The number of matrix columns (or the length of the vector) should match the number of network nodes. The order of the nodes in the columns (or vector) is considered the same as <code>net$genes</code>. If <code>NULL</code> (default), initial states are chosen randomly for <code>repeats</code> number of times based on a uniform distribution, requiring <code>repeats</code> not to be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="get_reached_states_+3A_asynchronous">asynchronous</code></td>
<td>
<p>If <code>TRUE</code>, the asynchronous update scheme is used, where a single node is updated at each time-step. In this case, <code>update_prob</code> indicates update probabilities. If <code>FALSE</code>, the synchronous update scheme is utilized.</p>
</td></tr>
<tr><td><code id="get_reached_states_+3A_update_prob">update_prob</code></td>
<td>
<p>The probability of updating each variable (node) in each time-step when <code>asynchronous = TRUE</code>. It should be a vector of probabilities for each of the nodes which sums up to one. If <code>NULL</code> (default), nodes are updated randomly based on a uniform distribution. If <code>asynchronous = FALSE</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the reached states (the states in the last time-step) after simulating a network for <code>steps</code> time-steps and repeating it for <code>repeats</code> number of times. If <code>initial_states</code> is <code>NULL</code>, then the initial states are chosen randomly based on a uniform distribution for <code>repeats</code> number of times, resulting in <code>repeats</code> number of reached states. If two or more initial states are provided by the user, then the <code>repeats</code> argument is ignored, and one reached state is returned for each initial state. If <code>repeats</code> is <code>NULL</code>, the number of returned reached states equals the number of initial states (one reached state for each initial state). The arguments <code>repeats</code> and <code>initial_states</code> should not both be <code>NULL</code> simultaneously.
</p>


<h3>Value</h3>

<p>A matrix where each row is the binary form of a reached state, and each column corresponds to a network node. The order of the nodes in the columns is the same as <code>net$genes</code>.
</p>


<h3>References</h3>

<p>Golinelli, O., &amp; Derrida, B. (1989). Barrier heights in the Kauffman model. <em>Journal De Physique</em>, 50(13), 1587-1601.
</p>
<p>Shmulevich, I., Dougherty, E. R., &amp; Zhang, W. (2002). Gene perturbation and intervention in probabilistic Boolean networks. <em>Bioinformatics</em>, 18(10), 1319-1331.
</p>
<p>Trairatphisan, P., Mizera, A., Pang, J., Tantar, A. A., Schneider, J., &amp; Sauter, T. (2013). Recent development and biomedical applications of probabilistic Boolean networks. <em>Cell communication and signaling</em>, 11, 1-25.
</p>
<p>Murrugarra, D., Veliz-Cuba, A., Aguilar, B., Arat, S., &amp; Laubenbacher, R. (2012). Modeling stochasticity and variability in gene regulatory networks. <em>EURASIP Journal on Bioinformatics and Systems Biology</em>, 2012, 1-11.
</p>
<p>Deritei, D., Kunšič, N., &amp; Csermely, P. (2022). Probabilistic edge weights fine-tune Boolean network dynamics. <em>PLoS Computational Biology</em>, 18(10), e1010536.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Load network and generate random initial states  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Load the example network
data(lac_operon_net)

# Generate a single initial state
initial_state &lt;- sample(c(0, 1), length(lac_operon_net$genes), replace = TRUE)

# Generate multiple (10) initial states
initial_states &lt;- matrix(sample(c(0, 1), 10 * length(lac_operon_net$genes),
    replace = TRUE), nrow = 10, ncol = length(lac_operon_net$genes))

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: BNp  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the BNp method
params &lt;- rep(0.05, length(lac_operon_net$genes))

# No initial states are provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "BNp", params = params,
    steps = 100, repeats = 10)

# A single initial state is provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "BNp", params = params,
    steps = 100, initial_states = initial_state, repeats = 10)

# Multiple initial states are provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "BNp", params = params,
    steps = 100, initial_states = initial_states)

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: SDDS  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the SDDS method
props &lt;- rep(0.95, length(lac_operon_net$genes))
params &lt;- list(p00 = props, p01 = props, p10 = props, p11 = props)

# No initial states are provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "SDDS", params = params,
    steps = 100, repeats = 10)

# A single initial state is provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "SDDS", params = params,
    steps = 100, initial_states = initial_state, repeats = 10)

# Multiple initial states are provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "SDDS", params = params,
    steps = 100, initial_states = initial_states)

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: PEW  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Extract edges from the network
edges &lt;- extract_edges(lac_operon_net)

# Define the parameters for the PEW method
p_on &lt;- runif(nrow(edges))
p_off &lt;- runif(nrow(edges))
params &lt;- list(p_on = p_on, p_off = p_off)

# No initial states are provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "PEW", params = params,
    steps = 100, repeats = 10)

# A single initial state is provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "PEW", params = params,
    steps = 100, initial_states = initial_state, repeats = 10)

# Multiple initial states are provided
reached_states &lt;- get_reached_states(lac_operon_net, method = "PEW", params = params,
    steps = 100, initial_states = initial_states)
</code></pre>

<hr>
<h2 id='lac_operon_net'>
The lactose operon Boolean network
</h2><span id='topic+lac_operon_net'></span>

<h3>Description</h3>

<p>The <em>lactose</em> operon (<em>lac</em> operon) Boolean network proposed by Veliz-Cuba and Stigler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lac_operon_net)</code></pre>


<h3>Details</h3>

<p>The data consists of an object <code>lac_operon_net</code> of the class <code>BooleanNetwork</code> (from the <code>BoolNet</code> package), describing the <em>lac</em> operon gene regulatory network with 10 genes and 3 inputs. The three inputs collectively indicate the concentration of glucose and lactose. Based on the synchronous update scheme, when extracellular glucose is available, the <em>lac</em> operon is OFF (having one steady-state attractor where all genes are OFF). Otherwise, depending on the extracellular lactose concentration, the operon will be OFF, bistable (having two attractors), or ON (all genes are ON).
</p>


<h3>References</h3>

<p>Veliz-Cuba, A., &amp; Stigler, B. (2011). Boolean models can explain bistability in the lac operon. <em>Journal of computational biology</em>, 18(6), 783-794.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the network
data(lac_operon_net)

# the network is stored in a variable called 'lac_operon_net'
print(lac_operon_net)
</code></pre>

<hr>
<h2 id='myeloid_diff_net'>
The myeloid differentiation Boolean network
</h2><span id='topic+myeloid_diff_net'></span>

<h3>Description</h3>

<p>The myeloid differentiation Boolean network proposed by Krumsiek et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(myeloid_diff_net)</code></pre>


<h3>Details</h3>

<p>The data consists of an object <code>myeloid_diff_net</code> of the class <code>BooleanNetwork</code> (from the <code>BoolNet</code> package), describing the myeloid differentiation gene regulatory network with 11 genes. More specifically, this network represents differentiation of common myeloid progenitors to megakaryocytes, erythrocytes, granulocytes and monocytes. The state space of the model is a hierarchical, acyclic graph, showing the principles of myeloid differentiation. A good agreement between the steady states of the model and microarray expression profiles of two different studies has been observed.
</p>


<h3>References</h3>

<p>Krumsiek, J., Marr, C., Schroeder, T., &amp; Theis, F. J. (2011). Hierarchical differentiation of myeloid progenitors is encoded in the transcription factor network. <em>PloS one</em>, 6(8), e22649.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the network
data(myeloid_diff_net)

# the network is stored in a variable called 'myeloid_diff_net'
print(myeloid_diff_net)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
