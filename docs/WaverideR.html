<!DOCTYPE html><html><head><title>Help for package WaverideR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WaverideR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_wavelet'><p>Add a wavelet plot</p></a></li>
<li><a href='#add_wavelet_avg'><p>Add a plot of a the average spectral power of a continous wavelet transform</p></a></li>
<li><a href='#age_model_zeeden'><p>Age model of Zeeden et al., (2013) for the (154-174m) interval of the IODP 926 grey scale record</p></a></li>
<li><a href='#analyze_wavelet'><p>Conduct the continuous wavelet transform on a time series/signal</p></a></li>
<li><a href='#anchor_points_Bisciaro_al'><p>XRF records of the Bisciaro Fm</p></a></li>
<li><a href='#anchor_points_grey'><p>Example anchor points for the grey scale data set of Zeeden et al., (2013)</p></a></li>
<li><a href='#anchor2time'><p>Convert a proxy record to the time domain using anchor points</p></a></li>
<li><a href='#astro_anchor'><p>Anchor proxy record to an astronomical solution</p></a></li>
<li><a href='#astrosignal_example'><p>An ETP astronomical solution</p></a></li>
<li><a href='#Bisciaro_al_wt_track'><p>Period of the short kyr ecc cycle in the Al record of the Bisciaro Fm</p></a></li>
<li><a href='#Bisciaro_ca_wt_track'><p>Period of the short kyr ecc cycle in the Ca record of the Bisciaro Fm</p></a></li>
<li><a href='#Bisciaro_Mg_wt_track'><p>Period of the short kyr ecc cycle in the Mg record of the Bisciaro Fm</p></a></li>
<li><a href='#Bisciaro_Mn_wt_track'><p>Period of the short kyr ecc cycle in the Mn record of the Bisciaro Fm</p></a></li>
<li><a href='#Bisciaro_sial_wt_track'><p>Period of the short kyr ecc cycle in the si/Al record of the Bisciaro Fm</p></a></li>
<li><a href='#Bisciaro_XRF'><p>XRF records of the Bisciaro Fm</p></a></li>
<li><a href='#completed_series'><p>Complete the tracking of cycle in a wavelet spectra</p></a></li>
<li><a href='#curve2sedrate'><p>Convert a tracked tracked to a sedimentation rate curve</p></a></li>
<li><a href='#curve2time'><p>Convert the tracked curve to a depth time space</p></a></li>
<li><a href='#curve2time_unc'><p>Convert the re-tracked curve results to a</p>
depth time space with uncertainty</a></li>
<li><a href='#curve2time_unc_anchor'><p>Anchor an age model including its uncertainty to a single radiometric data</p></a></li>
<li><a href='#curve2tune'><p>Convert data from the depth to the time domain</p></a></li>
<li><a href='#delpts_tracked_period_wt'><p>Remove tracking points which were tracked in a wavelet spectra</p></a></li>
<li><a href='#depth_rank_example'><p>An example depth rank series</p></a></li>
<li><a href='#dur_gaps'><p>calculate the duration of stratigraphic gaps using astronomical cycles</p></a></li>
<li><a href='#extract_amplitude'><p>Extract amplitude from a signal</p></a></li>
<li><a href='#extract_power'><p>Extract power from a wavelet spectra</p></a></li>
<li><a href='#extract_power_stable'><p>Extract power from a wavelet spectra by using a constant period/duration</p></a></li>
<li><a href='#extract_signal'><p>Extract signal from a wavelet spectra using a traced period curve</p></a></li>
<li><a href='#extract_signal_stable'><p>Extract a signal/cycle from a wavelet spectra using a set period and boundaries</p></a></li>
<li><a href='#extract_signal_stable_V2'><p>Extract signal from a wavelet spectrum using a upper and lower period boundary</p></a></li>
<li><a href='#extract_signal_standard_deviation'><p>Extract a signal using standard deviation</p></a></li>
<li><a href='#flmw'><p>Fit linear models to spectral peaks extracted from the wavelet spectra to astronomical cycles multiplied by sedimentation rate x</p></a></li>
<li><a href='#geo_col'><p>Generate standard color codes for the Geological Time Scale</p></a></li>
<li><a href='#geo_loc'><p>Generates  ages for the boundaries of a geochronological subdivision</p></a></li>
<li><a href='#geo_mid'><p>Generate the mean age of a geological subdivision</p></a></li>
<li><a href='#grey'><p>Grey scale record IODP 926 of Zeeden et al., (2013)</p></a></li>
<li><a href='#grey_track'><p>Tracking points of the precession (22 kyr cycle) IODP 926 grey scale (154-174m) record of Zeeden et al., (2013)</p></a></li>
<li><a href='#GTS_info'><p>Information of the Geological timescale 2020</p></a></li>
<li><a href='#Hilbert_transform'><p>Perform a Hilbert transform on a signal</p></a></li>
<li><a href='#lithlog_disc'><p>Discriticizes lithologs</p></a></li>
<li><a href='#loess_auto'><p>Perform an automatically loess based smoothing of a time series</p></a></li>
<li><a href='#mag'><p>Magnetic susceptibility data of the Sullivan core of Pas et al., (2018)</p></a></li>
<li><a href='#mag_track_solution'><p>Period of the 405 kyr ecc cycle in the magnetic susceptibility record of the Sullivan core</p></a></li>
<li><a href='#max_detect'><p>Detect and filter out all maxima in a signal</p></a></li>
<li><a href='#min_detect'><p>Detect and filter out all minima in a signal</p></a></li>
<li><a href='#minimal_tuning'><p>Create an age model using minimal tuning</p></a></li>
<li><a href='#model_red_noise_wt'><p>Models average spectral power based curves based on a red-noise signal</p>
generated using the characteristics of an input signal.</a></li>
<li><a href='#percentile_from_red_noise'><p>Calculate average spectral power from red noise curves for a given percentile</p></a></li>
<li><a href='#plot_astro_anchor'><p>Plot proxy record anchored to an astronomical solution</p></a></li>
<li><a href='#plot_avg_wavelet'><p>Plot the average spectral power of a wavelet spectra</p></a></li>
<li><a href='#plot_sed_model'><p>Plot sedimentation modelling results</p></a></li>
<li><a href='#plot_wavelet'><p>Plots a wavelet power spectra</p></a></li>
<li><a href='#plot_win_fft'><p>Plot windowed fft based spectral analysis results</p></a></li>
<li><a href='#retrack_wt_MC'><p>Re-track cycles using a Monte-Carlo simulation</p></a></li>
<li><a href='#sedrate2tune'><p>Use a sedimentation curve to convert data to the time domain</p></a></li>
<li><a href='#sum_power_sedrate'><p>Calculate sum of maximum spectral power for sedimentation rates</p>
for a wavelet spectra</a></li>
<li><a href='#track_period_wavelet'><p>Track the period of a cycle in a wavelet spectra</p></a></li>
<li><a href='#TSI'><p>Total solar irradiation data (0-9400ka) of steinhilber et al., (2012)</p></a></li>
<li><a href='#wavelet_uncertainty'><p>Calculate the uncertainty associated with the wavelet analysis based on the Gabor uncertainty principle</p></a></li>
<li><a href='#WaverideR'><p>Extracting Signals from Wavelet Spectra</p></a></li>
<li><a href='#WaverideR_Datasets'><p>Example data sets for the 'WaverideR' package</p></a></li>
<li><a href='#win_fft'><p>Windowed fft based spectral analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extracting Signals from Wavelet Spectra</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michiel Arts &lt;michiel.arts@stratigraphy.eu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DecomposeR, DescTools, Hmisc, Matrix,utils,colorednoise,
doSNOW, fANCOVA,
foreach,stats,tcltk,matrixStats,reshape2,truncnorm,grDevices,graphics,parallel,astrochron,biwavelet,WaveletComp,RColorBrewer,colorRamps,viridis,magick,rlist</td>
</tr>
<tr>
<td>Description:</td>
<td>The continuous wavelet transform enables the observation of transient/non-stationary cyclicity in time-series. The goal of cyclostratigraphic studies is to define frequency/period in the depth/time domain. By conducting the continuous wavelet transform on cyclostratigraphic data series one can observe and extract cyclic signals/signatures from signals. These results can then be visualized and interpreted enabling one to identify/interpret cyclicity in the geological record, which can be used to construct astrochronological age-models and identify and interpret cyclicity in past and present climate systems. The 'WaverideR' R package builds upon existing literature and existing codebase. The list of articles which are relevant can be grouped in four subjects; cyclostratigraphic data analysis,example data sets,the (continuous) wavelet transform and astronomical solutions. References for the cyclostratigraphic data analysis articles are: Stephen Meyers (2019) &lt;<a href="https://doi.org/10.1016%2Fj.earscirev.2018.11.015">doi:10.1016/j.earscirev.2018.11.015</a>&gt;. Mingsong Li, Linda Hinnov, Lee Kump (2019) &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2019.02.011">doi:10.1016/j.cageo.2019.02.011</a>&gt; Stephen Meyers (2012)&lt;<a href="https://doi.org/10.1029%2F2012PA002307">doi:10.1029/2012PA002307</a>&gt; Mingsong Li, Lee R. Kump, Linda A. Hinnov, Michael E. Mann (2018) &lt;<a href="https://doi.org/10.1016%2Fj.epsl.2018.08.041">doi:10.1016/j.epsl.2018.08.041</a>&gt;. Wouters, S., Crucifix, M., Sinnesael, M., Da Silva, A.C., Zeeden, C., Zivanovic, M., Boulvain, F., Devleeschouwer, X. (2022) &lt;<a href="https://doi.org/10.1016%2Fj.earscirev.2021.103894">doi:10.1016/j.earscirev.2021.103894</a>&gt;. Wouters, S., Da Silva, A.-C., Boulvain, F., and Devleeschouwer, X. (2021) &lt;<a href="https://doi.org/10.32614%2FRJ-2021-039">doi:10.32614/RJ-2021-039</a>&gt;. Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold, Xianyao Chen, and Karin Blank  (2009) &lt;<a href="https://doi.org/10.1142%2FS1793536909000096">doi:10.1142/S1793536909000096</a>&gt;. Cleveland, W. S. (1979)&lt;<a href="https://doi.org/10.1080%2F01621459.1979.10481038">doi:10.1080/01621459.1979.10481038</a>&gt; Hurvich, C.M., Simonoff, J.S., and Tsai, C.L. (1998) &lt;<a href="https://doi.org/10.1111%2F1467-9868.00125">doi:10.1111/1467-9868.00125</a>&gt;, Golub, G., Heath, M. and Wahba, G. (1979) &lt;<a href="https://doi.org/10.2307%2F1268518">doi:10.2307/1268518</a>&gt;. References for the example data articles are: Damien Pas, Linda Hinnov, James E. (Jed) Day, Kenneth Kodama, Matthias Sinnesael, Wei Liu (2018) &lt;<a href="https://doi.org/10.1016%2Fj.epsl.2018.02.010">doi:10.1016/j.epsl.2018.02.010</a>&gt;. Steinhilber, Friedhelm, Abreu, Jacksiel, Beer, Juerg , Brunner, Irene, Christl, Marcus, Fischer, Hubertus, HeikkilA, U., Kubik,  Peter, Mann, Mathias, Mccracken, K. , Miller, Heinrich, Miyahara, Hiroko, Oerter, Hans , Wilhelms, Frank. (2012 &lt;<a href="https://doi.org/10.1073%2Fpnas.1118965109">doi:10.1073/pnas.1118965109</a>&gt;. Christian Zeeden, Frederik Hilgen, Thomas Westerhold, Lucas Lourens, Ursula Röhl, Torsten Bickert (2013) &lt;<a href="https://doi.org/10.1016%2Fj.palaeo.2012.11.009">doi:10.1016/j.palaeo.2012.11.009</a>&gt;. References for the (continuous) wavelet transform articles are: Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard  (1982a) &lt;<a href="https://doi.org/10.1190%2F1.1441328">doi:10.1190/1.1441328</a>&gt;. J. Morlet, G. Arens, E. Fourgeau, D. Giard (1982b) &lt;<a href="https://doi.org/10.1190%2F1.1441329">doi:10.1190/1.1441329</a>&gt;. Torrence, C., and G. P. Compo (1998)<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>, Gouhier TC, Grinsted A, Simko V (2021) <a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>. Angi Roesch and Harald Schmidbauer (2018) <a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>. Russell, Brian, and Jiajun Han (2016)<a href="https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf">https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf</a>. Gabor, Dennis (1946) <a href="http://genesis.eecg.toronto.edu/gabor1946.pdf">http://genesis.eecg.toronto.edu/gabor1946.pdf</a>. J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B. (2004) &lt;<a href="https://doi.org/10.1051%2F0004-6361%3A20041335">doi:10.1051/0004-6361:20041335</a>&gt;. Laskar, J., Fienga, A., Gastineau, M., Manche, H. (2011a) &lt;<a href="https://doi.org/10.1051%2F0004-6361%2F201116836">doi:10.1051/0004-6361/201116836</a>&gt;. References for the astronomical solutions articles are: Laskar, J., Gastineau, M., Delisle, J.-B., Farres, A., Fienga, A. (2011b &lt;<a href="https://doi.org/10.1051%2F0004-6361%2F201117504">doi:10.1051/0004-6361/201117504</a>&gt;. J. Laskar (2019) &lt;<a href="https://doi.org/10.1016%2FB978-0-12-824360-2.00004-8">doi:10.1016/B978-0-12-824360-2.00004-8</a>&gt;. Zeebe, Richard E (2017) &lt;<a href="https://doi.org/10.3847%2F1538-3881%2Faa8cce">doi:10.3847/1538-3881/aa8cce</a>&gt;. Zeebe, R. E. and Lourens, L. J. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.epsl.2022.117595">doi:10.1016/j.epsl.2022.117595</a>&gt;. Richard E. Zeebe Lucas J. Lourens (2022) &lt;<a href="https://doi.org/10.1126%2Fscience.aax0612">doi:10.1126/science.aax0612</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stratigraphy/WaverideR">https://github.com/stratigraphy/WaverideR</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 14:50:31 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Michiel Arts [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_wavelet'>Add a wavelet plot</h2><span id='topic+add_wavelet'></span>

<h3>Description</h3>

<p>Generates a plot of a wavelet scalogram which can be integrated into
a larger composite plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_wavelet(
  wavelet = NULL,
  lowerPeriod = NULL,
  upperPeriod = NULL,
  lower_depth_time = NULL,
  upper_depth_time = NULL,
  n.levels = 100,
  plot.COI = TRUE,
  color_brewer = "grDevices",
  palette_name = "rainbow",
  plot_dir = FALSE,
  add_lines = NULL,
  add_points = NULL,
  add_abline_h = NULL,
  add_abline_v = NULL,
  plot_horizontal = TRUE,
  period_ticks = 1,
  periodlab = "period (m)",
  main = NULL,
  yaxt = "s",
  xaxt = "s",
  depth_time_lab = "depth (m)"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_wavelet_+3A_wavelet">wavelet</code></td>
<td>
<p>wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_lowerperiod">lowerPeriod</code></td>
<td>
<p>Lowest period value which will be plotted</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_upperperiod">upperPeriod</code></td>
<td>
<p>Highest period value which will be plotted</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_lower_depth_time">lower_depth_time</code></td>
<td>
<p>lowest depth/time value which will be plotted</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_upper_depth_time">upper_depth_time</code></td>
<td>
<p>Highest depth/time value which will be plotted</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of color levels <code>Default=100</code>.</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_plot.coi">plot.COI</code></td>
<td>
<p>Option to plot the cone of influence <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_plot_dir">plot_dir</code></td>
<td>
<p>The direction of the proxy record which is assumed for tuning if time increases with increasing depth/time values
(e.g. bore hole data which gets older with increasing depth ) then plot_dir should be set to TRUE
if time decreases with depth/time values (eg stratospheric logs where 0m is the bottom of the section)
then plot_dir should be set to FALSE <code>plot_dir=TRUE</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_add_lines">add_lines</code></td>
<td>
<p>Add  lines to the wavelet plot input should be matrix with first axis being depth/time the columns after that
should be period values  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_add_points">add_points</code></td>
<td>
<p>Add points to the wavelet plot input should be matrix with first axis being depth/time and columns after that
should be period values <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_add_abline_h">add_abline_h</code></td>
<td>
<p>Add horizontal lines to the plot. Specify the lines as a vector e.g. c(2,3,5,6)  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_add_abline_v">add_abline_v</code></td>
<td>
<p>Add vertical lines to the plot. Specify the lines as a vector e.g. c(2,3,5,6)  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_plot_horizontal">plot_horizontal</code></td>
<td>
<p>plot the wavelet horizontal or vertical eg y axis is depth or y axis power <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_period_ticks">period_ticks</code></td>
<td>
<p>tick mark spacing 1 is all tickmarks and higher value removes tick marks by
the fraction of the tick mark spacing value, the opposite is true for value lower than 1 which
will add aditional tickmarks</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_periodlab">periodlab</code></td>
<td>
<p>lable for the the period column</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_yaxt">yaxt</code></td>
<td>
<p>turn on of off the yaxis &quot;s&quot; is on &quot;n&quot; is off <code>Default="s"</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_xaxt">xaxt</code></td>
<td>
<p>turn on of off the xaxis &quot;s&quot; is on &quot;n&quot; is off <code>Default="s"</code></p>
</td></tr>
<tr><td><code id="add_wavelet_+3A_depth_time_lab">depth_time_lab</code></td>
<td>
<p>lable for the the depth/time column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a plot of a wavelet scalogram
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+analyze.wavelet">analyze.wavelet</a> and <a href="WaveletComp.html#topic+wt.image">wt.image</a> functions of the 'WaveletComp' R package
and <a href="biwavelet.html#topic+wt">wt</a> function of the 'biwavelet' R package which are based on the
wavelet MATLAB code written by Christopher Torrence and Gibert P. Compo (1998).
The MTM analysis is from the astrochron R package of Meyers et al., (2012)
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate a plot for the magnetic susceptibility data set of Pas et al., (2018)

plot.new()
layout.matrix &lt;- matrix(c(rep(0, 2), 1, 0,0,seq(2, 6, by = 1)),
                       nrow = 2,
                      ncol = 5 ,
                       byrow = TRUE)
graphics::layout(mat = layout.matrix,
                heights = c(0.25, 1),
                # Heights of the two rows
                widths = c(rep(c(1, 2, 4,2,2), 2)))

par(mar = c(0, 0.5, 1, 0.5))


mag_wt &lt;-
 analyze_wavelet(
   data = mag,
   dj = 1 / 100,
  lowerPeriod = 0.1,
   upperPeriod = 254,
   verbose = FALSE,
   omega_nr = 10
 )

 add_wavelet_avg(
 wavelet = mag_wt,
 plot_horizontal = TRUE,
 add_abline_h = NULL,
 add_abline_v = NULL,
 lowerPeriod = 0.15,
 upperPeriod = 80
)

par(mar = c(4, 4, 0, 0.5))


plot(
 x = c(0, 1),
 y = c(max(mag[, 1]), min(mag[, 1])),
 col = "white",
 xlab = "",
 ylab = "Time (Ma)",
 xaxt = "n",
 xaxs = "i",
 yaxs = "i",
 ylim = rev(c(max(mag[, 1]), min(mag[, 1])))
)            # Draw empty plot


polygon(
 x = c(0, 1, 1, 0),
 y = c(max(mag[, 1]), max(mag[, 1]), min(mag[, 1]), min(mag[, 1])),
 col = geo_col("Famennian")
)

text(
 0.5,
 (max(mag[, 1]) - min(mag[, 1])) / 2,
 "Fammenian",
 cex = 1,
 col = "black",
 srt = 90
)
par(mar = c(4, 0.5, 0, 0.5))


plot(
 mag[, 2],
 mag[, 1],
 type = "l",
 ylim = rev(c(max(mag[, 1]), min(mag[, 1]))),
 yaxs = "i",
 yaxt = "n",
 xlab = "Mag. suc.",
 ylab = ""
)


add_wavelet(
 wavelet = mag_wt,
 lowerPeriod = 0.15,
 upperPeriod = 80,
 lower_depth_time = NULL,
 upper_depth_time = NULL,
 n.levels = 100,
 plot.COI = TRUE,
 color_brewer = "grDevices",
 palette_name = "rainbow",
 plot_dir = FALSE,
 add_lines = NULL,
 add_points = NULL,
 add_abline_h = NULL,
 add_abline_v = NULL,
 plot_horizontal = TRUE,
 period_ticks = 1,
 periodlab = "period (m)",
 main = NULL,
 yaxt = "n",
 xaxt = "s",
 depth_time_lab = ""
)


lines(log2(mag_track_solution[,2]),mag_track_solution[,1],lwd=4,lty=4)

mag_405 &lt;- extract_signal(
 tracked_cycle_curve = mag_track_solution,
 wavelet = mag_wt,
 period_up = 1.2,
 period_down = 0.8,
 add_mean = TRUE,
 tracked_cycle_period = 405,
 extract_cycle = 405,
 tune = FALSE,
 plot_residual = FALSE
)

plot(mag_405[,2],mag_405[,1],type="l",
    yaxt="n", yaxs = "i",
    xlab="405-kyr ecc")


mag_110 &lt;- extract_signal(
 tracked_cycle_curve = mag_track_solution,
 wavelet = mag_wt,
 period_up = 1.25,
 period_down = 0.75,
 add_mean = TRUE,
 tracked_cycle_period = 405,
 extract_cycle = 110,
 tune = FALSE,
 plot_residual = FALSE
)

mag_110_hil &lt;- Hilbert_transform(mag_110,demean=FALSE)

plot(mag_110[,2],mag_110[,1],type="l",
    yaxt="n", yaxs = "i",
    xlab="110-kyr ecc")

lines(mag_110_hil[,2],mag_110_hil[,1])

</code></pre>

<hr>
<h2 id='add_wavelet_avg'>Add a plot of a the average spectral power of a continous wavelet transform</h2><span id='topic+add_wavelet_avg'></span>

<h3>Description</h3>

<p>Generates a plot of a the average spectral power of a continous wavelet transform
which can be added to a larger composite plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_wavelet_avg(
  wavelet = NULL,
  plot_horizontal = TRUE,
  add_abline_h = NULL,
  add_abline_v = NULL,
  lowerPeriod = NULL,
  upperPeriod = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_wavelet_avg_+3A_wavelet">wavelet</code></td>
<td>
<p>wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="add_wavelet_avg_+3A_plot_horizontal">plot_horizontal</code></td>
<td>
<p>plot the wavelet horizontal or vertical eg y axis is depth or y axis power <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="add_wavelet_avg_+3A_add_abline_h">add_abline_h</code></td>
<td>
<p>Add horizontal lines to the plot. Specify the lines as a vector e.g. c(2,3,5,6)  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="add_wavelet_avg_+3A_add_abline_v">add_abline_v</code></td>
<td>
<p>Add vertical lines to the plot. Specify the lines as a vector e.g. c(2,3,5,6)  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="add_wavelet_avg_+3A_lowerperiod">lowerPeriod</code></td>
<td>
<p>Lowest period value which will be plotted</p>
</td></tr>
<tr><td><code id="add_wavelet_avg_+3A_upperperiod">upperPeriod</code></td>
<td>
<p>Highest period value which will be plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a plot of a the average spectral power of a continuous wavelet transform
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+analyze.wavelet">analyze.wavelet</a> and <a href="WaveletComp.html#topic+wt.image">wt.image</a> functions of the 'WaveletComp' R package
and <a href="biwavelet.html#topic+wt">wt</a> function of the 'biwavelet' R package which are based on the
wavelet MATLAB code written by Christopher Torrence and Gibert P. Compo (1998).
The MTM analysis is from the astrochron R package of Meyers et al., (2012)
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate a plot for the magnetic susceptibility data set of Pas et al., (2018)

plot.new()
layout.matrix &lt;- matrix(c(rep(0, 2), 1, 0,0,seq(2, 6, by = 1)),
                       nrow = 2,
                      ncol = 5 ,
                       byrow = TRUE)
graphics::layout(mat = layout.matrix,
                heights = c(0.25, 1),
                # Heights of the two rows
                widths = c(rep(c(1, 2, 4,2,2), 2)))

par(mar = c(0, 0.5, 1, 0.5))


mag_wt &lt;-
 analyze_wavelet(
   data = mag,
   dj = 1 / 100,
  lowerPeriod = 0.1,
   upperPeriod = 254,
   verbose = FALSE,
   omega_nr = 10
 )

add_wavelet_avg(
 wavelet = mag_wt,
 plot_horizontal = TRUE,
 add_abline_h = NULL,
 add_abline_v = NULL,
 lowerPeriod = 0.15,
 upperPeriod = 80
)


par(mar = c(4, 4, 0, 0.5))


plot(
 x = c(0, 1),
 y = c(max(mag[, 1]), min(mag[, 1])),
 col = "white",
 xlab = "",
 ylab = "Time (Ma)",
 xaxt = "n",
 xaxs = "i",
 yaxs = "i",
 ylim = rev(c(max(mag[, 1]), min(mag[, 1])))
)            # Draw empty plot


polygon(
 x = c(0, 1, 1, 0),
 y = c(max(mag[, 1]), max(mag[, 1]), min(mag[, 1]), min(mag[, 1])),
 col = geo_col("Famennian")
)

text(
 0.5,
 (max(mag[, 1]) - min(mag[, 1])) / 2,
 "Fammenian",
 cex = 1,
 col = "black",
 srt = 90
)
par(mar = c(4, 0.5, 0, 0.5))


plot(
 mag[, 2],
 mag[, 1],
 type = "l",
 ylim = rev(c(max(mag[, 1]), min(mag[, 1]))),
 yaxs = "i",
 yaxt = "n",
 xlab = "Mag. suc.",
 ylab = ""
)

add_wavelet(
 wavelet = mag_wt,
 lowerPeriod = 0.15,
 upperPeriod = 80,
 lower_depth_time = NULL,
 upper_depth_time = NULL,
 n.levels = 100,
 plot.COI = TRUE,
 color_brewer = "grDevices",
 palette_name = "rainbow",
 plot_dir = FALSE,
 add_lines = NULL,
 add_points = NULL,
 add_abline_h = NULL,
 add_abline_v = NULL,
 plot_horizontal = TRUE,
 period_ticks = 1,
 periodlab = "period (m)",
 main = NULL,
 yaxt = "n",
 xaxt = "s",
 depth_time_lab = ""
)

lines(log2(mag_track_solution[,2]),mag_track_solution[,1],lwd=4,lty=4)

mag_405 &lt;- extract_signal(
 tracked_cycle_curve = mag_track_solution,
 wavelet = mag_wt,
 period_up = 1.2,
 period_down = 0.8,
 add_mean = TRUE,
 tracked_cycle_period = 405,
 extract_cycle = 405,
 tune = FALSE,
 plot_residual = FALSE
)

plot(mag_405[,2],mag_405[,1],type="l",
    yaxt="n", yaxs = "i",
    xlab="405-kyr ecc")


mag_110 &lt;- extract_signal(
 tracked_cycle_curve = mag_track_solution,
 wavelet = mag_wt,
 period_up = 1.25,
 period_down = 0.75,
 add_mean = TRUE,
 tracked_cycle_period = 405,
 extract_cycle = 110,
 tune = FALSE,
 plot_residual = FALSE
)

mag_110_hil &lt;- Hilbert_transform(mag_110,demean=FALSE)

plot(mag_110[,2],mag_110[,1],type="l",
    yaxt="n", yaxs = "i",
    xlab="110-kyr ecc")

lines(mag_110_hil[,2],mag_110_hil[,1])

</code></pre>

<hr>
<h2 id='age_model_zeeden'>Age model of Zeeden et al., (2013) for the (154-174m) interval of the IODP 926 grey scale record</h2><span id='topic+age_model_zeeden'></span>

<h3>Description</h3>

<p>Age model (anchor points) of the IODP 926 grey scale (154-174m) record of Zeeden et al., (2013) <br />
Anchored to the eccentricity-tilt-precession model p-0.5t of la 2004.
</p>


<h3>Details</h3>

<p>Column 1: Depth (meters)<br />
Column 2: Age (kyr)<br />
</p>


<h3>References</h3>

<p>Christian Zeeden, Frederik Hilgen, Thomas Westerhold, Lucas Lourens, Ursula Röhl, Torsten Bickert,
Revised Miocene splice, astronomical tuning and calcareous plankton biochronology of ODP Site 926 between 5 and 14.4Ma,
Palaeogeography, Palaeoclimatology, Palaeoecology,Volume 369,2013,Pages 430-451,ISSN 0031-0182,
&lt;doi:10.1016/j.palaeo.2012.11.009&gt;
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004,
A long term numerical solution for the insolation quantities of the Earth: Astron. Astrophys.,
Volume 428, 261-285. &lt;doi:10.1051/0004-6361:20041335&gt;
</p>

<hr>
<h2 id='analyze_wavelet'>Conduct the continuous wavelet transform on a time series/signal</h2><span id='topic+analyze_wavelet'></span>

<h3>Description</h3>

<p>Compute the continuous wavelet transform (CWT) using a Morlet wavelet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_wavelet(
  data = NULL,
  dj = 1/20,
  lowerPeriod = 2,
  upperPeriod = 1024,
  verbose = FALSE,
  omega_nr = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_wavelet_+3A_data">data</code></td>
<td>
<p>Input data, should be a matrix or data frame in which
the first column is depth or time and the second column is proxy record.</p>
</td></tr>
<tr><td><code id="analyze_wavelet_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales. The CWT analyses analyses the signal using successive periods
which increase by the power of 2 (e.g.2^0=1,2^1=2,2^2=4,2^3=8,2^4=16). To have more resolution
in-between these steps the dj parameter exists, the dj parameter specifies how many extra steps/spacing in-between
the power of 2 scaled CWT is added. The amount of steps is 1/x with a higher x indicating a smaller spacing.
Increasing the increases the computational time of the CWT <code>Default=1/200</code>.</p>
</td></tr>
<tr><td><code id="analyze_wavelet_+3A_lowerperiod">lowerPeriod</code></td>
<td>
<p>Lowest period to be analyzed <code>Default=2</code>.
The CWT analyses the signal starting from the lowerPeriod to the upperPeriod so the proper selection these
parameters allows to analyze the signal for a specific range of cycles.
scaling is done using power 2 so for the best plotting results select a value to the power or 2.</p>
</td></tr>
<tr><td><code id="analyze_wavelet_+3A_upperperiod">upperPeriod</code></td>
<td>
<p>Upper period to be analyzed <code>Default=1024</code>.
The CWT analyses the signal starting from the lowerPeriod to the upperPeriod so the proper selection these
parameters allows to analyze the signal for a specific range of cycles.
scaling is done using power 2 so for the best plotting results select a value to the power or 2.</p>
</td></tr>
<tr><td><code id="analyze_wavelet_+3A_verbose">verbose</code></td>
<td>
<p>Print text <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_wavelet_+3A_omega_nr">omega_nr</code></td>
<td>
<p>Number of cycles contained within the Morlet wavelet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list (wavelet object) which contain 18 objects which are the result of the continuous wavelet transform (CWT).
Object 1: Wave - Wave values of the wavelet
Object 2: Phase - Phase of the wavelet
Object 3: Ampl - Amplitude values of the wavelet
Object 4: Power - Power values of the wavelet
Object 5: dt - Step size
Object 6: dj - Scale size
Object 7: Power.avg  - Average power values
Object 8: Period - Period values
Object 9: Scale - Scale value
Object 10: coi.1 - Cone of influence values 1
Object 11: coi.2 - Cone of influence values 2
Object 12: nc - Number of columns
Object 13: nr - Number of rows
Object 14: axis.1 - axis values 1
Object 15: axis.2 - axis values 2
Object 16: omega_nr - Number of cycles in the wavelet
Object 17: x - x values of the data set
Object 18: y - y values of the data set
</p>


<h3>Author(s)</h3>

<p>Code based on on the <a href="WaveletComp.html#topic+analyze.wavelet">analyze.wavelet</a> function of the 'WaveletComp' R package
and <a href="biwavelet.html#topic+wt">wt</a> function of the 'biwavelet' R package which are based on the
wavelet MATLAB code written by Christopher Torrence and Gibert P. Compo.
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example 1. Using the Total Solar Irradiance data set of Steinhilver et al., (2012)
TSI_wt &lt;-
 analyze_wavelet(
   data = TSI,
   dj = 1/200,
   lowerPeriod = 16,
   upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )


#Example 2. Using the magnetic susceptibility data set of Pas et al., (2018)
mag_wt &lt;-
analyze_wavelet(
data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10
)

#Example 3. Using the greyscale data set of Zeeden et al., (2013)
grey_wt &lt;-
 analyze_wavelet(
   data = grey,
   dj = 1/200,
   lowerPeriod = 0.02,
   upperPeriod = 256,
   verbose = FALSE,
   omega_nr = 8
 )


</code></pre>

<hr>
<h2 id='anchor_points_Bisciaro_al'>XRF records of the Bisciaro Fm</h2><span id='topic+anchor_points_Bisciaro_al'></span>

<h3>Description</h3>

<p>data set consist of the tie points between the Bisciaro_al record
of Arts (2014) and the la2011 solution of laskar et al., (20111)<br />
</p>


<h3>Details</h3>

<p>The data set is a matrix with the 4 columns.
The first column is the depth/time of the al proxy record tie-points.
The second column is the time value of the la2011 astronomical solution tie-points.
The third column is the Al value of the a; tie-point.
The fourth column is the eccentricity value of the la2011 astronomical solution tie-point.
</p>


<h3>References</h3>

<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>
<p>Laskar, J., M. Gastineau, J. B. Delisle, A. Farrés, and A. Fienga (2011b),
Strong chaos induced by close encounters with Ceres and Vesta, Astron. Astrophys.,
532, L4,&lt;doi:10.1051/0004-6361/201117504&gt; <br />
</p>

<hr>
<h2 id='anchor_points_grey'>Example anchor points for the grey scale data set of Zeeden et al., (2013)</h2><span id='topic+anchor_points_grey'></span>

<h3>Description</h3>

<p>An example of anchor points generated using <code><a href="#topic+astro_anchor">astro_anchor</a></code> function <br />
The anchor points were generated for the <code><a href="#topic+grey">grey</a></code> grey data set of <br />
Zeeden et al., (2013) and anchored to the code<a href="#topic+astrosignal_example">astrosignal_example</a> <br />
astronomical solution which is a pre-generated ETP (eccentricity-tilt-precession) <br />
solution(p-0.5t based on the la2004 solution) based on Laskar et al., (20004) <br />
astronomical solution.
</p>


<h3>Details</h3>

<p>Column 1: depth proxy record<br />
Column 2: time astronomical solution  <br />
Column 3: y-scale value proxy record<br />
Column 4: y-scale value astronomical solution  <br />
</p>


<h3>References</h3>

<p>Christian Zeeden, Frederik Hilgen, Thomas Westerhold, Lucas Lourens, Ursula Röhl, Torsten Bickert,
Revised Miocene splice, astronomical tuning and calcareous plankton biochronology of ODP Site 926 between 5 and 14.4Ma,
Palaeogeography, Palaeoclimatology, Palaeoecology,Volume 369,2013,Pages 430-451,ISSN 0031-0182,
&lt;doi:10.1016/j.palaeo.2012.11.009&gt;
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004,
A long term numerical solution for the insolation quantities of the Earth: Astron. Astrophys.,
Volume 428, 261-285. &lt;doi:10.1051/0004-6361:20041335&gt;
</p>

<hr>
<h2 id='anchor2time'>Convert a proxy record to the time domain using anchor points</h2><span id='topic+anchor2time'></span>

<h3>Description</h3>

<p>Convert a proxy record to the time domain using anchor points made using the <code><a href="#topic+astro_anchor">astro_anchor</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchor2time(
  anchor_points = NULL,
  data = NULL,
  genplot = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anchor2time_+3A_anchor_points">anchor_points</code></td>
<td>
<p>Anchor points made using the <code><a href="#topic+astro_anchor">astro_anchor</a></code> function or a matrix in which the first column is depth
and the second column is time.</p>
</td></tr>
<tr><td><code id="anchor2time_+3A_data">data</code></td>
<td>
<p>Data set which needs to be converted from the depth to time domain using set anchor points.
The data set should consist of a matrix with 2 column the first column should be depth
and the second column should be a proxy value.</p>
</td></tr>
<tr><td><code id="anchor2time_+3A_genplot">genplot</code></td>
<td>
<p>If  <code>genplot=FALSE</code> then 3 plots stacked on top of each other will be plotted.
Plot 1: the original data set
Plot 2: the depth time plot
Plot 3: the data set in the time domain
set to TRUE to allow for anchoring using the GUI</p>
</td></tr>
<tr><td><code id="anchor2time_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a matrix with 2 columns.
The first column is time.
The second column sedimentation proxy value.
</p>
<p>If <code>genplot=TRUE</code> then 3 plots stacked on top of each other will be plotted.
Plot 1: the original data set.
Plot 2: the depth time plot.
Plot 3: the data set in the time domain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the age_model_zeeden example anchor points of Zeeden et al., (2013)
#to anchor the grey data set of Zeeden et al., (2013) in the time domain.

anchored2time &lt;- anchor2time(anchor_points=age_model_zeeden,
data=grey,
genplot=FALSE,
keep_editable=FALSE)

</code></pre>

<hr>
<h2 id='astro_anchor'>Anchor proxy record to an astronomical solution</h2><span id='topic+astro_anchor'></span>

<h3>Description</h3>

<p>Anchor the extracted signal to an astronomical solution using a GUI.
The <code><a href="#topic+astro_anchor">astro_anchor</a></code> function allows one to tie minima or maxima in the proxy record
to minima or maxima in an astronomical solution.
By tying the proxy record to an astronomical solution one will generate tie-points which
can be used to generate a astrochronological age-model
As minima or maxima in the proxy record are tied to minima or maxima in an astronomical solution it is
important to provide input which has clearly definable minima and maxima.
As such input should be of a &quot;sinusoidal&quot; nature otherwise the <code>extract_astrosolution=TRUE</code>
and/or <code>extract_proxy_signal=TRUE</code> options need to be set to TRUE to create sinusoidal signals.
</p>
<p>Astronomical solutions option are:
</p>

<ul>
<li><p> La2004 Eccentricity solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a> function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2004 Obliquity solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a> function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2004 Precession solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a> function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010a Eccentricity solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a>function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010a Obliquity solution downloadable via the <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010a Precession solution downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010b Eccentricity solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a> function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010b Obliquity solution downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010b Precession solution downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010c Eccentricity solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a> function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010c Obliquity solution downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010c Precession solution downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010d Eccentricity solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a> function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010d Obliquity solution downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2010d Precession solution downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> La2011 Eccentricity solution available via the <a href="astrochron.html#topic+getLaskar">getLaskar</a> function or downloadable via <a href="http://vo.imcce.fr/insola/earth/online/earth/earth.html">http://vo.imcce.fr/insola/earth/online/earth/earth.html</a>
</p>
</li>
<li><p> ZB17a Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17a Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17b Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17b Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17c Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17c Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17d Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17d Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17e Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17e Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17f Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17f Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17h Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17h Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17i Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17i Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17j Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17j Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17k Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17k Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17p Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB17p Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB18a Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB18a Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20a Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20a Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20b Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20b Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20c Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20c Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20d Eccentricity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> ZB20d Obliquity solution downloadable via <a href="https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html">https://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html</a>
</p>
</li>
<li><p> 405kyr eccentricity 405 metronome can be generated using the formula:<br />
e405=0.027558-0.010739*cos(0.0118+2(pi)*(t/405000)) (laskar et al., 2004 &amp; laskar 2020)
</p>
</li>
<li><p> 173kyr obliquity  metronome can be generated using using the formula:<br />
es3-s6(t) = 0.144*cos(1.961+2(pi)*(t/172800) (laskar et al., 2004 &amp; laskar 2020)
</p>
</li>
<li><p> An etp model using the <a href="astrochron.html#topic+etp">etp</a> function of the 'astrochron' R package
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>astro_anchor(
  astro_solution = NULL,
  proxy_signal = NULL,
  proxy_min_or_max = "max",
  clip_astrosolution = FALSE,
  astrosolution_min_or_max = "max",
  clip_high = NULL,
  clip_low = NULL,
  extract_astrosolution = FALSE,
  astro_period_up = 1.2,
  astro_period_down = 0.8,
  astro_period_cycle = NULL,
  extract_proxy_signal = FALSE,
  proxy_period_up = 1.2,
  proxy_period_down = 0.8,
  proxy_period_cycle = NULL,
  pts = 3,
  verbose = FALSE,
  time_dir = TRUE,
  genplot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="astro_anchor_+3A_astro_solution">astro_solution</code></td>
<td>
<p>Input is an astronomical solution which the proxy record will be anchored to,
the input should be a matrix or data frame with the first column being
age and the second column should be a insolation/angle/value</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_proxy_signal">proxy_signal</code></td>
<td>
<p>Input is the proxy data set which will
be anchored to an astronomical solution, the input should be a matrix or
data frame with the first column being  depth/time and the second column should be a proxy value.
For the best results either the astronomical components need to be pre-extracted
before anchoring. This means that a filtering/cycle extracting need to be applied to
the input data or the  extract_proxy_signal option needs to be set to TRUE.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_proxy_min_or_max">proxy_min_or_max</code></td>
<td>
<p>Tune proxy maxima or minima to the astronomical solution <code>Default="max"</code>.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_clip_astrosolution">clip_astrosolution</code></td>
<td>
<p>Clip the astronomical solution <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_astrosolution_min_or_max">astrosolution_min_or_max</code></td>
<td>
<p>Tune to maximum or minimum values of
the astronomical solution <code>Default="max"</code></p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_clip_high">clip_high</code></td>
<td>
<p>Upper value to clip to.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_clip_low">clip_low</code></td>
<td>
<p>Lower value to clip to.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_extract_astrosolution">extract_astrosolution</code></td>
<td>
<p>Extract a certain astronomical cycle/component from a
astronomical solution prior to anchoring <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_astro_period_up">astro_period_up</code></td>
<td>
<p>Specifies the upper period of the astronomical cycle which is
extracted from an astronomical solution. The astro_period_up is a
factor with which the astronomical component is multiplied by.  <code>Default=1.2</code></p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_astro_period_down">astro_period_down</code></td>
<td>
<p>Specified the lower period of the astronomical cycle which is
extracted from an astronomical solution. The astro_period_down value is a
factor with which the astronomical component is multiplied by. <code>Default=0.8</code></p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_astro_period_cycle">astro_period_cycle</code></td>
<td>
<p>Period (in kyr) of the to be extracted astronomical component
from the astronomical solution.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_extract_proxy_signal">extract_proxy_signal</code></td>
<td>
<p>Extract a certain astronomical cycle/component from a
proxy signal  <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_proxy_period_up">proxy_period_up</code></td>
<td>
<p>Specifies the upper period of the astronomical cycle to be extracted
from the proxy record. The upper bound value is a factor with which the
(proxy_period_cycle) value is multiplied by. <code>Default=1.2</code>.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_proxy_period_down">proxy_period_down</code></td>
<td>
<p>Specifies the upper period of the astronomical cycle to be
extracted from the proxy record. The lower bound value is a factor with
which the astronomical component (proxy_period_cycle) value is multiplied by. <code>Default=0.8</code>.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_proxy_period_cycle">proxy_period_cycle</code></td>
<td>
<p>Period in kyr of the astronomical cycle/component which is to be extracted
from the proxy record.</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_pts">pts</code></td>
<td>
<p>The pts parameter specifies how many points to the left/right up/down the peak detect algorithm goes in detecting
a peak. The peak detecting algorithm works by comparing the values left/right up/down of it, if the values are both higher or lower
then the value a peak. To deal with error produced by this algorithm the pts parameter can be changed which can
aid in peak detection. Usually increasing the pts parameter means more peak certainty, however it also means that minor peaks might not be
picked up by the algorithm <code>Default=3</code></p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_verbose">verbose</code></td>
<td>
<p>print text <code>Default=FALSE</code> set verbose to TRUE to allow for anchoring using text feedback commands</p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_time_dir">time_dir</code></td>
<td>
<p>The direction of the proxy record which is assumed for tuning if time increases with increasing depth/time values
(e.g. bore hole data which gets older with increasing depth ) then time_dir should be set to TRUE
if time decreases with depth/time values (eg stratigraphic logs where 0m is the bottom of the section)
then time_dir should be set to FALSE <code>time_dir=TRUE</code></p>
</td></tr>
<tr><td><code id="astro_anchor_+3A_genplot">genplot</code></td>
<td>
<p>Generate plot <code>Default="FALSE"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a matrix with the 4 columns.
The first column is the depth/time of the proxy tie-point.
The second column is the time value of the astronomical solution tie-point.
The third column is the proxy value of the proxy tie-point.
The fourth column is the proxy/insolation value of the astronomical solution  tie-point.
If genplot is set to true then at plot of the of the achored points will be plotted
</p>


<h3>References</h3>

<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004,
A long term numerical solution for the insolation quantities of the Earth: Astron. Astrophys.,
Volume 428, 261-285. &lt;doi:10.1051/0004-6361:20041335&gt; <br />
</p>
<p>Laskar, J., Fienga, A., Gastineau, M., Manche, H., 2011a,
La2010: A new orbital solution for the long-term motion of the Earth: Astron. Astrophys.,
Volume 532, A89 &lt;doi:10.1051/0004-6361/201116836&gt; <br />
</p>
<p>Laskar, J., Gastineau, M., Delisle, J.-B., Farres, A., Fienga, A.:
2011b, Strong chaos induced by close encounters with Ceres and Vesta, Astron: Astrophys.,
Volume 532, L4.  &lt;doi:10.1051/0004-6361/201117504&gt;<br />
</p>
<p>J. Laskar,Chapter 4 - Astrochronology,Editor(s): Felix M. Gradstein, James G. Ogg, Mark D. Schmitz, Gabi M. Ogg,Geologic Time Scale 2020,Elsevier,2020,Pages 139-158,ISBN 9780128243602,
&lt;doi:10.1016/B978-0-12-824360-2.00004-8&gt; or <a href="https://www.sciencedirect.com/science/article/pii/B9780128243602000048">https://www.sciencedirect.com/science/article/pii/B9780128243602000048</a> <br />
</p>
<p>Zeebe, R. E. and Lourens, L. J.
Geologically constrained astronomical solutions for the Cenozoic era,
Earth and Planetary Science Letters, 2022 &lt;<a href="https://doi.org/10.1016/j.epsl.2022.117595">doi:10.1016/j.epsl.2022.117595</a>&gt;<br />
</p>
<p>Richard E. Zeebe Lucas J. Lourens ,Solar System chaos and the Paleocene–Eocene boundary age constrained by geology and astronomy.Science365,926-929(2019)
&lt;doi:10.1126/science.aax0612&gt;<br />
</p>
<p>Zeebe, Richard E. &quot;Numerical solutions for the orbital motion of the Solar System over the past 100 Myr: limits and new results.&quot;
The Astronomical Journal 154, no. 5 (2017): 193. &lt;doi:10.3847/1538-3881/aa8cce&gt; <br />
</p>
<p>Stephen R. Meyers,Cyclostratigraphy and the problem of astrochronologic testing,
Earth-Science Reviews,Volume 190,2019,Pages 190-223,ISSN 0012-8252
&lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use the grey_track example tracking points to anchor the grey scale data set
# of Zeeden et al., (2013) to the p-0.5t la2004 solution

grey_wt &lt;-
 analyze_wavelet(
   data = grey,
   dj = 1/200,
   lowerPeriod = 0.02,
   upperPeriod = 256,
   verbose = FALSE,
   omega_nr = 8
 )
#Use the pre-tracked grey_track curve which traced the precession cycle
grey_track &lt;- completed_series(
 wavelet = grey_wt,
 tracked_curve  = grey_track,
 period_up  = 1.25,
 period_down  = 0.75,
 extrapolate = TRUE,
genplot = FALSE
)
# Extract precession, obliquity and eccentricity to create a synthetic insolation curve

grey_prec &lt;- extract_signal(
tracked_cycle_curve = grey_track[,c(1,2)],
wavelet = grey_wt,
period_up = 1.2,
period_down = 0.8,
add_mean = FALSE,
tracked_cycle_period = 22,
extract_cycle = 22,
tune = FALSE,
plot_residual = FALSE
)

grey_obl &lt;- extract_signal(
 tracked_cycle_curve = grey_track[,c(1,2)],
 wavelet = grey_wt,
 period_up = 1.2,
 period_down = 0.8,
 add_mean = FALSE,
 tracked_cycle_period = 22,
 extract_cycle = 110,
 tune = FALSE,
 plot_residual = FALSE
)

grey_ecc &lt;- extract_signal(
 tracked_cycle_curve = grey_track[,c(1,2)],
 wavelet = grey_wt,
 period_up = 1.25,
 period_down = 0.75,
 add_mean = FALSE,
 tracked_cycle_period = 22,
 extract_cycle = 40.8,
 tune = FALSE,
 plot_residual = FALSE
)

insolation_extract &lt;- cbind(grey_ecc[,1],grey_prec[,2]+grey_obl[,2]+grey_ecc[,2]+mean(grey[,2]))
insolation_extract &lt;- as.data.frame(insolation_extract)
insolation_extract_mins &lt;- min_detect(insolation_extract,pts=3)

#use the astrosignal_example to tune to which is an \cr
# ETP solution (p-0.5t la2004 solution)
astrosignal_example &lt;- na.omit(astrosignal_example)
astrosignal_example[,2] &lt;- -1*astrosignal_example[,2]
astrosignal &lt;- as.data.frame(astrosignal_example)

#anchor the synthetic insolation curve extracted from the grey scale record to the insolation curve.

anchor_pts &lt;- astro_anchor(
astro_solution = astrosignal,
proxy_signal = insolation_extract,
proxy_min_or_max = "min",
clip_astrosolution = FALSE,
astrosolution_min_or_max = "min",
clip_high = NULL,
clip_low = NULL,
extract_astrosolution  = FALSE,
astro_period_up  = NULL,
astro_period_down  = NULL,
astro_period_cycle  = NULL,
extract_proxy_signal  = FALSE,
proxy_period_up  = NULL,
proxy_period_down  = NULL,
proxy_period_cycle  = NULL,
pts=3,
verbose=FALSE, #set verbose to TRUE to allow for anchoring using text feedback commands
genplot=FALSE
)

</code></pre>

<hr>
<h2 id='astrosignal_example'>An ETP astronomical solution</h2><span id='topic+astrosignal_example'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+astrosignal_example">astrosignal_example</a></code> is a pre-generated ETP <br />
(eccentricity-tilt-precession) (p-0.5t based on the la2004 solution) <br />
the <code><a href="#topic+astrosignal_example">astrosignal_example</a></code> can be used to anchor the <code><a href="#topic+grey">grey</a></code><br />
data set to an astronomical solution eg. <code><a href="#topic+astrosignal_example">astrosignal_example</a></code> <br />
using the  <code><a href="#topic+astro_anchor">astro_anchor</a></code> function. the data set was generated using the <br />
<a href="astrochron.html#topic+etp">etp</a> function of the 'astrochron' R package.
The pre-generated ETP spans 5000 to 6000kyr.
</p>


<h3>Details</h3>

<p>Column 1: time (kyr)<br />
Column 2: ETP  <br />
</p>


<h3>Author(s)</h3>

<p>Generated using the <a href="astrochron.html#topic+etp">etp</a>
function of the <a href="astrochron.html#topic+astrochron-package">astrochron-package</a>.
</p>


<h3>References</h3>

<p>Stephen R. Meyers,Cyclostratigraphy and the problem of astrochronologic testing,
Earth-Science Reviews,Volume 190,2019,Pages 190-223,ISSN 0012-8252
&lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004,
A long term numerical solution for the insolation quantities of the Earth: Astron. Astrophys.,
Volume 428, 261-285. &lt;doi:10.1051/0004-6361:20041335&gt;
</p>

<hr>
<h2 id='Bisciaro_al_wt_track'>Period of the short kyr ecc cycle in the Al record of the Bisciaro Fm</h2><span id='topic+Bisciaro_al_wt_track'></span>

<h3>Description</h3>

<p>Data points which give the period (in meters) of the short kyr eccentricity cycle tracked <br />
in the wavelet scalogram of the aluminium (XRF) record of the Bisciaro Formation <br />
The period was tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function<br />
The tracking is based on a reinterpretation of Arts (2014)<br />
</p>


<h3>Details</h3>

<p>Column 1: depth proxy record<br />
Column 2: period tracked in the wavelet scalogram of the Aluminium (XRF) record
</p>


<h3>References</h3>

<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>

<hr>
<h2 id='Bisciaro_ca_wt_track'>Period of the short kyr ecc cycle in the Ca record of the Bisciaro Fm</h2><span id='topic+Bisciaro_ca_wt_track'></span>

<h3>Description</h3>

<p>Data points which give the period (in meters) of the short kyr eccentricity cycle tracked <br />
in the wavelet scalogram of the calcium (XRF) record of the Bisciaro Formation <br />
The period was tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function<br />
The tracking is based on a reinterpretation of Arts (2014)<br />
</p>


<h3>Details</h3>

<p>Column 1: depth proxy record<br />
Column 2: period tracked in the wavelet scalogram of the calcium (XRF) record
</p>


<h3>References</h3>

<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>

<hr>
<h2 id='Bisciaro_Mg_wt_track'>Period of the short kyr ecc cycle in the Mg record of the Bisciaro Fm</h2><span id='topic+Bisciaro_Mg_wt_track'></span>

<h3>Description</h3>

<p>Data points which give the period (in meters) of the short kyr eccentricity cycle tracked <br />
in the wavelet scalogram of the magnesium (XRF) record of the Bisciaro Formation <br />
The period was tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function<br />
The tracking is based on a reinterpretation of Arts (2014)<br />
</p>


<h3>Details</h3>

<p>Column 1: depth proxy record<br />
Column 2: period tracked in the wavelet scalogram of the Magnesium (XRF) record
</p>


<h3>References</h3>

<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>

<hr>
<h2 id='Bisciaro_Mn_wt_track'>Period of the short kyr ecc cycle in the Mn record of the Bisciaro Fm</h2><span id='topic+Bisciaro_Mn_wt_track'></span>

<h3>Description</h3>

<p>Data points which give the period (in meters) of the short kyr eccentricity cycle tracked <br />
in the wavelet scalogram of the manganese (XRF) record of the Bisciaro Formation <br />
The period was tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function<br />
The tracking is based on a reinterpretation of Arts (2014)<br />
</p>


<h3>Details</h3>

<p>Column 1: depth proxy record<br />
Column 2: period tracked in the wavelet scalogram of the manganese (XRF) record
</p>


<h3>References</h3>

<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>

<hr>
<h2 id='Bisciaro_sial_wt_track'>Period of the short kyr ecc cycle in the si/Al record of the Bisciaro Fm</h2><span id='topic+Bisciaro_sial_wt_track'></span>

<h3>Description</h3>

<p>Data points which give the period (in meters) of the short kyr eccentricity cycle tracked <br />
in the wavelet scalogram of the silicon/aluminium (XRF) record of the Bisciaro Formation <br />
The period was tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function<br />
The tracking is based on a reinterpretation of Arts (2014)<br />
</p>


<h3>Details</h3>

<p>Column 1: depth proxy record<br />
Column 2: period tracked in the wavelet scalogram of the silicon/aluminium (XRF) record
</p>


<h3>References</h3>

<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>

<hr>
<h2 id='Bisciaro_XRF'>XRF records of the Bisciaro Fm</h2><span id='topic+Bisciaro_XRF'></span>

<h3>Description</h3>

<p>XRF proxy records from the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy)
</p>


<h3>Details</h3>

<p>Column 1: depth proxy record<br />
Column 2-71: XRF proxy records
</p>


<h3>References</h3>

<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>

<hr>
<h2 id='completed_series'>Complete the tracking of cycle in a wavelet spectra</h2><span id='topic+completed_series'></span>

<h3>Description</h3>

<p>Use the traced series and the existing wavelet
spectra to complete the tracking of a cycle of the wavelet spectra.
The selected points using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function form a incomplete line
unless every point is tracked. However clicking every individual point along a wavelet ridge is time
intensive and error prone.
To avoid errors and save time the <code><a href="#topic+completed_series">completed_series</a></code> function can be used to
complete the tracing of a cycle in a wavelet spectra.The <code><a href="#topic+completed_series">completed_series</a></code> function interpolates the
data points selected using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code>. A a search a algorithm then looks up and replaces
the interpolated curve values with the values of the nearest spectral peak in the wavelet spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completed_series(
  wavelet = NULL,
  tracked_curve = NULL,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completed_series_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="completed_series_+3A_tracked_curve">tracked_curve</code></td>
<td>
<p>Traced period result from the <code>track_period_wavelet</code> function.</p>
</td></tr>
<tr><td><code id="completed_series_+3A_period_up">period_up</code></td>
<td>
<p>The period_up parameter is the factor with which the linear interpolated tracked_curve
curve is multiplied by. This linear interpolated tracked_curve multiplied by the period_up factor is
the upper boundary which is used  for detecting the spectral peak nearest to the linear interpolated tracked_curve
curve. If no spectral peak is detected within the specified boundary the interpolated
value is used instead. between spectral peaks <code>Default=1.2</code>,</p>
</td></tr>
<tr><td><code id="completed_series_+3A_period_down">period_down</code></td>
<td>
<p>The period_down parameter is the factor with which the linear interpolated tracked_curve
curve is multiplied by. This linear interpolated tracked_curve multiplied by the period_down factor is
the lower boundary which is used  for detecting the spectral peak nearest to the linear interpolated tracked_curve
curve. If no spectral peak is detected within the specified boundary the interpolated
value is used instead. between spectral peaks <code>Default=0.8</code>,</p>
</td></tr>
<tr><td><code id="completed_series_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Extrapolate the completed curve when through parts where no spectral peaks could be traced
<code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="completed_series_+3A_genplot">genplot</code></td>
<td>
<p>Generate a plot <code>Default=TRUE</code>. The red curve is the completed curve,
the black curve is the original curve.</p>
</td></tr>
<tr><td><code id="completed_series_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns
The first column is the depth axis
The second column is the completed tracking of the period a cycle of the wavelet spectra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Use the grey_track example points to complete the tracking of the
# precession cycle in the wavelet spectra of the grey scale data set
# of Zeeden et al., (2013).



grey_wt &lt;-
 analyze_wavelet(
   data = grey,
   dj = 1/200,
   lowerPeriod = 0.02,
   upperPeriod = 256,
   verbose = FALSE,
   omega_nr = 8
 )

#The ~22kyr precession cycle is between 0.25 and 1m The grey_track data
#set is a pre-loaded uncompleted tracking of the precession cycle

#grey_track &lt;- track_period_wavelet(
#astro_cycle = 22,
#wavelet = NULL,
#n.levels = 100,
#periodlab = "Period (meters)",
#x_lab = "depth (meters)"
#)



grey_track &lt;- completed_series(
 wavelet = grey_wt,
 tracked_curve  = grey_track,
 period_up  = 1.25,
 period_down  = 0.75,
 extrapolate = TRUE,
genplot = FALSE,
keep_editable=FALSE
)


</code></pre>

<hr>
<h2 id='curve2sedrate'>Convert a tracked tracked to a sedimentation rate curve</h2><span id='topic+curve2sedrate'></span>

<h3>Description</h3>

<p>Converts the period of a tracked cycle to a sedimentation rate curve by
assigning a duration (in kyr) to the period of a tracked cycle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve2sedrate(tracked_cycle_curve = NULL, tracked_cycle_period = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve2sedrate_+3A_tracked_cycle_curve">tracked_cycle_curve</code></td>
<td>
<p>A tracked cycle  which is the result of using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function <br />
Any input (matrix or data frame) in which the first column is depth in meters and the second column is period in meters</p>
</td></tr>
<tr><td><code id="curve2sedrate_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period of the tracked cycle (in kyr).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a matrix with 2 columns
The first column is depth
The second column sedimentation rate in cm/kyr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Conversion of the period (in meters) of a 405 kyr eccentricity cycle tracked
#in a wavelet spectra by assigning a duration of  405 kyr to the tracked cycle.
# the example uses the magnetic susceptibility data set of Pas et al., (2018)
# perform the CWT
mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)")

#Instead of tracking, the tracked solution data set \code{\link{mag_track_solution}} is used \cr
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE
)

# smooth the tracking of the 405 kyr eccentricity cycle
mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE)

#convert period in meters to sedrate in cm/kyr
mag_track_sedrate &lt;- curve2sedrate(tracked_cycle_curve=mag_track_complete,
tracked_cycle_period=405)

</code></pre>

<hr>
<h2 id='curve2time'>Convert the tracked curve to a depth time space</h2><span id='topic+curve2time'></span>

<h3>Description</h3>

<p>Converts the tracked curve to a depth time space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve2time(
  tracked_cycle_curve = NULL,
  tracked_cycle_period = NULL,
  genplot = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve2time_+3A_tracked_cycle_curve">tracked_cycle_curve</code></td>
<td>
<p>Curve of the cycle tracked using the
<code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function <br />
Any input (matrix or data frame) in which the first column is depth in
meters and the second column is period in meters can be used.</p>
</td></tr>
<tr><td><code id="curve2time_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period of the tracked curve in kyr.</p>
</td></tr>
<tr><td><code id="curve2time_+3A_genplot">genplot</code></td>
<td>
<p>Generates a plot with depth vs time <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="curve2time_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a matrix with 2 columns.
The first column is depth.
The second column sedimentation rate in cm/kyr.
If <code>genplot=TRUE</code> then a depth vs time plot will be plotted.
</p>


<h3>Author(s)</h3>

<p>Based on the <a href="astrochron.html#topic+sedrate2time">sedrate2time</a>
function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Convert a tracked curve to a depth time space. The examples uses the
#magnetic susceptibility data set of Pas et al., (2018).

#'# perform the CWT
mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)")

#Instead of tracking, the tracked solution data set mag_track_solution is used
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE
)

# smooth the tracking of the 405 kyr eccentricity cycle
mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE)

#convert period in meters to sedrate depth vs time
mag_track_time&lt;- curve2time(tracked_cycle_curve=mag_track_complete,
tracked_cycle_period=405,
genplot=FALSE,
keep_editable=FALSE)


</code></pre>

<hr>
<h2 id='curve2time_unc'>Convert the re-tracked curve results to a
depth time space with uncertainty</h2><span id='topic+curve2time_unc'></span>

<h3>Description</h3>

<p>Converts the re-tracked curve results from
<code><a href="#topic+retrack_wt_MC">retrack_wt_MC</a></code> function to a depth time space while also
taking into account the uncertainty of the tracked astronomical cycle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve2time_unc(
  tracked_cycle_curve = NULL,
  tracked_cycle_period = NULL,
  tracked_cycle_period_unc = NULL,
  tracked_cycle_period_unc_dist = "n",
  n_simulations = NULL,
  output = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve2time_unc_+3A_tracked_cycle_curve">tracked_cycle_curve</code></td>
<td>
<p>Curve of the cycle tracked using the
<code><a href="#topic+retrack_wt_MC">retrack_wt_MC</a></code> function <br />
Any input (matrix or data frame) with 3 columns in which column 1 is the
x-axis, column 2 is the  mean tracked frequency (in cycles/metres) column 3
1 standard deviation</p>
</td></tr>
<tr><td><code id="curve2time_unc_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period of the tracked curve in kyr.</p>
</td></tr>
<tr><td><code id="curve2time_unc_+3A_tracked_cycle_period_unc">tracked_cycle_period_unc</code></td>
<td>
<p>uncertainty in the period of the tracked cycle</p>
</td></tr>
<tr><td><code id="curve2time_unc_+3A_tracked_cycle_period_unc_dist">tracked_cycle_period_unc_dist</code></td>
<td>
<p>distribution of the uncertainty of the
tracked cycle value need to be either &quot;u&quot; for uniform distribution or
&quot;n&quot; for normal distribution  <code>Default="n"</code></p>
</td></tr>
<tr><td><code id="curve2time_unc_+3A_n_simulations">n_simulations</code></td>
<td>
<p>number of time series to be modeled</p>
</td></tr>
<tr><td><code id="curve2time_unc_+3A_output">output</code></td>
<td>
<p>If output = 1 a matrix with the predicted ages given the input for each run
is given. If output = 2 a matrix with 6 columns is generated,
the first column is depth/height, the other columns are the quantile
(0.025,0.373,0.5,0.6827,0.975) age values of the runs
if output = 3 a matrix with 4 columns is generated with the first column
being depth/height, column 2 is the mean tracked duration (in kyrs) column 3
is mean duration + 1 standard deviation and column 4  is mean duration -  1
standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If output = 1 a matrix with the predicted ages given the input for each run
is given
If output = 2 a matrix with 6 columns is generated, the first column is
depth/height, the other columns are the quantile
(0.02275, 0.373, 0.5, 0.6827, 0.97725) age values of the runs
if output = 3 a matrix with 4 columns is generated with the first column
being depth/height, column 2 is the mean tracked duration (in kyrs) column 3
is mean duration + 1 standard deviation and column 4  is mean duration -  1
standard deviation
</p>


<h3>Author(s)</h3>

<p>Based on the <a href="astrochron.html#topic+sedrate2time">sedrate2time</a>
function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Re-track the 110kyr eccentricity cycle in the wavelet scalogram
# from the XRF record of the Bisciaro data set of Arts (2014) and then
# add generate and age model including uncertainty

Bisciaro_al &lt;- Bisciaro_XRF[, c(1, 61)]
Bisciaro_al &lt;- astrochron::sortNave(Bisciaro_al,verbose=FALSE,genplot=FALSE)
Bisciaro_al &lt;- astrochron::linterp(Bisciaro_al, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_al &lt;- Bisciaro_al[Bisciaro_al[, 1] &gt; 2, ]

Bisciaro_al_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_al,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_al_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_al_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
# Bisciaro_al_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_al_wt,
#   tracked_curve = Bisciaro_al_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_al_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_al_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )

Bisciaro_ca &lt;- Bisciaro_XRF[, c(1, 55)]
Bisciaro_ca &lt;- astrochron::sortNave(Bisciaro_ca,verbose=FALSE,genplot=FALSE)
Bisciaro_ca &lt;- astrochron::linterp(Bisciaro_ca, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_ca &lt;- Bisciaro_ca[Bisciaro_ca[, 1] &gt; 2, ]

Bisciaro_ca_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_ca,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_ca_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_ca_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
# Bisciaro_ca_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_ca_wt,
#   tracked_curve = Bisciaro_ca_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_ca_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_ca_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE)

Bisciaro_sial &lt;- Bisciaro_XRF[,c(1,64)]
Bisciaro_sial &lt;- astrochron::sortNave(Bisciaro_sial,verbose=FALSE,genplot=FALSE)
Bisciaro_sial &lt;- astrochron::linterp(Bisciaro_sial, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_sial &lt;- Bisciaro_sial[Bisciaro_sial[, 1] &gt; 2, ]

Bisciaro_sial_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_sial,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_sial_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_sial_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_sial_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_sial_wt,
#   tracked_curve = Bisciaro_sial_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_sial_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_sial_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )


Bisciaro_Mn &lt;- Bisciaro_XRF[,c(1,46)]
Bisciaro_Mn &lt;- astrochron::sortNave(Bisciaro_Mn,verbose=FALSE,genplot=FALSE)
Bisciaro_Mn &lt;- astrochron::linterp(Bisciaro_Mn, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_Mn &lt;- Bisciaro_Mn[Bisciaro_Mn[, 1] &gt; 2, ]

Bisciaro_Mn_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_Mn,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_Mn_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_Mn_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_Mn_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_Mn_wt,
#   tracked_curve = Bisciaro_Mn_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
# Bisciaro_Mn_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_Mn_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )

Bisciaro_Mg &lt;- Bisciaro_XRF[,c(1,71)]
Bisciaro_Mg &lt;- astrochron::sortNave(Bisciaro_Mg,verbose=FALSE,genplot=FALSE)
Bisciaro_Mg &lt;- astrochron::linterp(Bisciaro_Mg, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_Mg &lt;- Bisciaro_Mg[Bisciaro_Mg[, 1] &gt; 2, ]

Bisciaro_Mg_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_Mg,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_Mg_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_Mg_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_Mg_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_Mg_wt,
#   tracked_curve = Bisciaro_Mg_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_Mg_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_Mg_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE)




wt_list_bisc &lt;- list(Bisciaro_al_wt,
               Bisciaro_ca_wt,
               Bisciaro_sial_wt,
               Bisciaro_Mn_wt,
               Bisciaro_Mg_wt)

#Instead of tracking, the tracked solution data sets Bisciaro_al_wt_track,
#Bisciaro_ca_wt_track, Bisciaro_sial_wt_track, Bisciaro_Mn_wt_track,
# Bisciaro_Mn_wt_track and Bisciaro_Mg_wt_track are used

data_track_bisc &lt;- cbind(Bisciaro_al_wt_track[,2],
                     Bisciaro_ca_wt_track[,2],
                     Bisciaro_sial_wt_track[,2],
                     Bisciaro_Mn_wt_track[,2],
                     Bisciaro_Mg_wt_track[,2])

x_axis_bisc &lt;- Bisciaro_al_wt_track[,1]


bisc_retrack &lt;- retrack_wt_MC(wt_list = wt_list_bisc,
             data_track = data_track_bisc,
             x_axis = x_axis_bisc,
             nr_simulations = 20,
             seed_nr = 1337,
             verbose = FALSE,
             genplot = FALSE,
             keep_editable = FALSE,
             create_GIF = FALSE,
             plot_GIF = FALSE,
             width_plt =  600,
             height_plt = 450,
            period_up  =  1.5,
             period_down = 0.5,
             plot.COI = TRUE,
             n.levels = 100,
             palette_name = "rainbow",
             color_brewer = "grDevices",
             periodlab = "Period (metres)",
             x_lab = "depth (metres)",
             add_avg = FALSE,
             time_dir = TRUE,
             file_name = NULL,
             run_multicore = FALSE,
             output = 5,
             n_imgs = 50,
             plot_horizontal = TRUE,
             empty_folder = FALSE)

bisc_retrack_age_incl_unc &lt;- curve2time_unc(tracked_cycle_curve = bisc_retrack,
tracked_cycle_period = 110,
tracked_cycle_period_unc = ((135-110)+(110-95))/2,
tracked_cycle_period_unc_dist = "n",
n_simulations = 20,
output = 1)



</code></pre>

<hr>
<h2 id='curve2time_unc_anchor'>Anchor an age model including its uncertainty to a single radiometric data</h2><span id='topic+curve2time_unc_anchor'></span>

<h3>Description</h3>

<p>Anchor an age model including its uncertainty to a single radiometric which has a known uncertainty
and a known uncertainty in bed location. the model also allows for the addition of gap(s) in the
record with a known durations. if no single radiometric date is specified then the gap(s) will be added
to the original age-model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve2time_unc_anchor(
  tracked_cycle_curve = NULL,
  tracked_cycle_period = NULL,
  tracked_cycle_period_unc = NULL,
  tracked_cycle_period_unc_dist = "n",
  achor_age = NULL,
  achor_SD = NULL,
  achor_depth = NULL,
  achor_depth_unc = NULL,
  achor_depth_unc_dist = "u",
  gap_depth = NULL,
  gap_dur = NULL,
  gap_unc = NULL,
  gap_unc_dist = "n",
  n_simulations = NULL,
  output = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve2time_unc_anchor_+3A_tracked_cycle_curve">tracked_cycle_curve</code></td>
<td>
<p>Curve of the cycle tracked using the
<code><a href="#topic+retrack_wt_MC">retrack_wt_MC</a></code> function <br />
Any input (matrix or data frame) with 3 columns in which column 1 is the
x-axis, column 2 is the  mean tracked frequency (in cycles/metres) column 3
1 standard deviation</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period of the tracked curve in kyr.</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_tracked_cycle_period_unc">tracked_cycle_period_unc</code></td>
<td>
<p>uncertainty in the period of the tracked cycle</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_tracked_cycle_period_unc_dist">tracked_cycle_period_unc_dist</code></td>
<td>
<p>distribution of the uncertainty of the
tracked cycle value need to be either &quot;u&quot; for uniform distribution or
&quot;n&quot; for normal distribution  <code>Default="n"</code></p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_achor_age">achor_age</code></td>
<td>
<p>age (in kyr) of the anchor</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_achor_sd">achor_SD</code></td>
<td>
<p>uncertainty given as 1 sd (in kyr) of the anchor</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_achor_depth">achor_depth</code></td>
<td>
<p>depth in (m) of the anchor</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_achor_depth_unc">achor_depth_unc</code></td>
<td>
<p>uncertainty in (m) of the anchor</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_achor_depth_unc_dist">achor_depth_unc_dist</code></td>
<td>
<p>distribution of the uncertainty of the
anchor age, value need to be either &quot;u&quot; for uniform distribution or
&quot;n&quot; for normal distribution  <code>Default="n"</code></p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_gap_depth">gap_depth</code></td>
<td>
<p>depth(s) at which a gap is present</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_gap_dur">gap_dur</code></td>
<td>
<p>duration in  (kyr) of the gap</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_gap_unc">gap_unc</code></td>
<td>
<p>uncertainty in the duration (kyr) of the gap</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_gap_unc_dist">gap_unc_dist</code></td>
<td>
<p>distribution of the uncertainty of the
duration of the value need to be either &quot;u&quot; for uniform distribution or
&quot;n&quot; for normal distribution  <code>Default="n"</code></p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_n_simulations">n_simulations</code></td>
<td>
<p>number of time series to be modeled</p>
</td></tr>
<tr><td><code id="curve2time_unc_anchor_+3A_output">output</code></td>
<td>
<p>if output = 1 a matrix with the predicted ages given the input for each run
is given
If output = 2 a matrix with 6 columns is generated, the first column is
depth/height, the other columns are the quantile
(0.025,0.373,0.5,0.6827,0.975) age values of the runs
if output = 3 a matrix with 4 columns is generated with the first column
being depth/height, column 2 is the mean tracked duration (in kyrs) column 3
is mean duration + 1 standard deviation and column 4  is mean duration -  1
standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If output = 1 a matrix with the predicted ages given the input for each run
is given
If output = 2 a matrix with 6 columns is generated, the first column is
depth/height, the other columns are the quantile
(0.025,0.373,0.5,0.6827,0.975) age values of the runs
if output = 3 a matrix with 4 columns is generated with the first column
being depth/height, column 2 is the mean tracked duration (in kyrs) column 3
is mean duration + 1 standard deviation and column 4  is mean duration -  1
standard deviation
</p>


<h3>Author(s)</h3>

<p>Part of the code is based on the <a href="astrochron.html#topic+sedrate2time">sedrate2time</a>
function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Re-track the 110kyr eccentricity cycle in the wavelet scalogram
# from the XRF record of the Bisciaro data set of Arts (2014) and then
# add anchor it a U/Pb date of an ash bed and generate and anchored age model including uncertainty

Bisciaro_al &lt;- Bisciaro_XRF[, c(1, 61)]
Bisciaro_al &lt;- astrochron::sortNave(Bisciaro_al,verbose=FALSE,genplot=FALSE)
Bisciaro_al &lt;- astrochron::linterp(Bisciaro_al, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_al &lt;- Bisciaro_al[Bisciaro_al[, 1] &gt; 2, ]

Bisciaro_al_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_al,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_al_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_al_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
# Bisciaro_al_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_al_wt,
#   tracked_curve = Bisciaro_al_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_al_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_al_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )

Bisciaro_ca &lt;- Bisciaro_XRF[, c(1, 55)]
Bisciaro_ca &lt;- astrochron::sortNave(Bisciaro_ca,verbose=FALSE,genplot=FALSE)
Bisciaro_ca &lt;- astrochron::linterp(Bisciaro_ca, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_ca &lt;- Bisciaro_ca[Bisciaro_ca[, 1] &gt; 2, ]

Bisciaro_ca_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_ca,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_ca_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_ca_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
# Bisciaro_ca_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_ca_wt,
#   tracked_curve = Bisciaro_ca_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_ca_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_ca_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE)

Bisciaro_sial &lt;- Bisciaro_XRF[,c(1,64)]
Bisciaro_sial &lt;- astrochron::sortNave(Bisciaro_sial,verbose=FALSE,genplot=FALSE)
Bisciaro_sial &lt;- astrochron::linterp(Bisciaro_sial, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_sial &lt;- Bisciaro_sial[Bisciaro_sial[, 1] &gt; 2, ]

Bisciaro_sial_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_sial,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_sial_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_sial_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_sial_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_sial_wt,
#   tracked_curve = Bisciaro_sial_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_sial_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_sial_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )


Bisciaro_Mn &lt;- Bisciaro_XRF[,c(1,46)]
Bisciaro_Mn &lt;- astrochron::sortNave(Bisciaro_Mn,verbose=FALSE,genplot=FALSE)
Bisciaro_Mn &lt;- astrochron::linterp(Bisciaro_Mn, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_Mn &lt;- Bisciaro_Mn[Bisciaro_Mn[, 1] &gt; 2, ]

Bisciaro_Mn_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_Mn,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_Mn_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_Mn_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_Mn_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_Mn_wt,
#   tracked_curve = Bisciaro_Mn_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
# Bisciaro_Mn_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_Mn_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )

Bisciaro_Mg &lt;- Bisciaro_XRF[,c(1,71)]
Bisciaro_Mg &lt;- astrochron::sortNave(Bisciaro_Mg,verbose=FALSE,genplot=FALSE)
Bisciaro_Mg &lt;- astrochron::linterp(Bisciaro_Mg, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_Mg &lt;- Bisciaro_Mg[Bisciaro_Mg[, 1] &gt; 2, ]

Bisciaro_Mg_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_Mg,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_Mg_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_Mg_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_Mg_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_Mg_wt,
#   tracked_curve = Bisciaro_Mg_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_Mg_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_Mg_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE)




wt_list_bisc &lt;- list(Bisciaro_al_wt,
               Bisciaro_ca_wt,
               Bisciaro_sial_wt,
               Bisciaro_Mn_wt,
               Bisciaro_Mg_wt)

#Instead of tracking, the tracked solution data sets Bisciaro_al_wt_track,
#Bisciaro_ca_wt_track, Bisciaro_sial_wt_track, Bisciaro_Mn_wt_track,
# Bisciaro_Mn_wt_track and Bisciaro_Mg_wt_track are used

data_track_bisc &lt;- cbind(Bisciaro_al_wt_track[,2],
                     Bisciaro_ca_wt_track[,2],
                     Bisciaro_sial_wt_track[,2],
                     Bisciaro_Mn_wt_track[,2],
                     Bisciaro_Mg_wt_track[,2])

x_axis_bisc &lt;- Bisciaro_al_wt_track[,1]


bisc_retrack &lt;- retrack_wt_MC(wt_list = wt_list_bisc,
             data_track = data_track_bisc,
             x_axis = x_axis_bisc,
             nr_simulations = 20,
             seed_nr = 1337,
             verbose = FALSE,
             genplot = FALSE,
             keep_editable = FALSE,
             create_GIF = FALSE,
             plot_GIF = FALSE,
             width_plt =  600,
             height_plt = 450,
            period_up  =  1.5,
             period_down = 0.5,
             plot.COI = TRUE,
             n.levels = 100,
             palette_name = "rainbow",
             color_brewer = "grDevices",
             periodlab = "Period (metres)",
             x_lab = "depth (metres)",
             add_avg = FALSE,
             time_dir = TRUE,
             file_name = NULL,
             run_multicore = FALSE,
             output = 5,
             n_imgs = 50,
             plot_horizontal = TRUE,
             empty_folder = FALSE)

bisc_retrack_age_incl_unc &lt;- curve2time_unc_anchor(tracked_cycle_curve = bisc_retrack,
tracked_cycle_period = 110,
tracked_cycle_period_unc = ((135-110)+(110-95))/2,
tracked_cycle_period_unc_dist = "n",
achor_age = 20609,
achor_SD = 40,
achor_depth = 7.25,
achor_depth_unc = 0.25,
achor_depth_unc_dist = "n",
gap_depth = NULL,
gap_dur = NULL,
gap_unc =  NULL,
gap_unc_dist = "n",
n_simulations = 20,
output = 1)


</code></pre>

<hr>
<h2 id='curve2tune'>Convert data from the depth to the time domain</h2><span id='topic+curve2tune'></span>

<h3>Description</h3>

<p>Converts a data set from the depth to the time domain
using a tracked curve/cycle to depth domain an assigning a duration (in kyr) set
tracked curve/cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve2tune(
  data = NULL,
  tracked_cycle_curve = NULL,
  tracked_cycle_period = NULL,
  genplot = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve2tune_+3A_data">data</code></td>
<td>
<p>Data set (matrix with 2 columns 1st column depth 2nd column proxy value)
which was used as input for the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function. <br />
That result was then used to tracked a cycle using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function</p>
</td></tr>
<tr><td><code id="curve2tune_+3A_tracked_cycle_curve">tracked_cycle_curve</code></td>
<td>
<p>Tracking result of a cycle tracked using the
<code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function <br />
Any input (matrix or data frame) in which the first column
is depth in meters and the second column is period in meters can be used.</p>
</td></tr>
<tr><td><code id="curve2tune_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period of the tracked curve (in kyr).</p>
</td></tr>
<tr><td><code id="curve2tune_+3A_genplot">genplot</code></td>
<td>
<p>If <code>genplot=TRUE</code> 3 plots stacked on top of each other will be plotted.
Plot 1: the original data set.
Plot 2: the depth time plot.
Plot 3: the data set in the time domain.</p>
</td></tr>
<tr><td><code id="curve2tune_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a matrix with 2 columns.
The first column is time.
The second column sedimentation proxy value.
</p>
<p>If <code>genplot=TRUE</code> then 3 plots stacked on top of each other will be plotted.
Plot 1: the original data set.
Plot 2: the depth time plot.
Plot 3: the data set in the time domain.
</p>


<h3>Author(s)</h3>

<p>Part of the code is based on the <a href="astrochron.html#topic+sedrate2time">sedrate2time</a>
function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#The example uses the magnetic susceptibility data set of Pas et al., (2018).
# perform the CWT
mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (meters)",
#                                   x_lab = "depth (meters)")

#Instead of tracking, the tracked solution data set mag_track_solution is used
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE
)

# smooth the tracking of the 405 kyr eccentricity cycle
mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE)

mag_track_time&lt;- curve2tune(data=mag,
                           tracked_cycle_curve=mag_track_complete,
                           tracked_cycle_period=405,
                           genplot = FALSE,
                           keep_editable=FALSE)

</code></pre>

<hr>
<h2 id='delpts_tracked_period_wt'>Remove tracking points which were tracked in a wavelet spectra</h2><span id='topic+delpts_tracked_period_wt'></span>

<h3>Description</h3>

<p>Interactively select points for deletion
With the  <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function it is possible to track points in a wavelet spectra,
however errors can be made and as such it is possible to delete these points with the <code><a href="#topic+delpts_tracked_period_wt">delpts_tracked_period_wt</a></code> function.
This function allows one to select points for deletion.
#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delpts_tracked_period_wt(
  tracking_pts = NULL,
  wavelet = NULL,
  n.levels = 100,
  periodlab = "Period (metres)",
  x_lab = "depth (metres)",
  palette_name = "rainbow",
  color_brewer = "grDevices"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delpts_tracked_period_wt_+3A_tracking_pts">tracking_pts</code></td>
<td>
<p>Points tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="delpts_tracked_period_wt_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="delpts_tracked_period_wt_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of color levels <code>Default=100</code>.</p>
</td></tr>
<tr><td><code id="delpts_tracked_period_wt_+3A_periodlab">periodlab</code></td>
<td>
<p>label for the y-axis <code>Default="Period (metres)"</code>.</p>
</td></tr>
<tr><td><code id="delpts_tracked_period_wt_+3A_x_lab">x_lab</code></td>
<td>
<p>label for the x-axis <code>Default="depth (metres)"</code>.</p>
</td></tr>
<tr><td><code id="delpts_tracked_period_wt_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="delpts_tracked_period_wt_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results of the deletion of the tracking points is a matrix with 3 columns.
The first column is depth/time
The second column is the period of the tracked cycle
The third column is the sedimentation rate based on the duration (in time) of the tracked cycle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Track the 405kyr eccentricity cycle in the magnetic susceptibility record
# of the Sullivan core of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)"
#                                    palette_name ="rainbow",
#                                    color_brewer ="grDevices)

#load the mag_track_solution data set to get an example data set from which
#data points can be deleted


mag_track_corr &lt;- delpts_tracked_period_wt(tracking_pts = mag_track_solution,
                                    wavelet = mag_wt,
                                    n.levels = 100,
                                    periodlab = "Period (metres)",
                                    x_lab = "depth (metres)",
                                   palette_name ="rainbow",
                                   color_brewer ="grDevices")


</code></pre>

<hr>
<h2 id='depth_rank_example'>An example depth rank series</h2><span id='topic+depth_rank_example'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+depth_rank_example">depth_rank_example</a></code> example data set is a depth rank series which <br />
can be used as input for the <code><a href="#topic+lithlog_disc">lithlog_disc</a></code> function which creates a <br />
discritzed record which can then be used as input in the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code><br />
function
</p>


<h3>Details</h3>

<p>Column 1: depth (meters)<br />
Column 2: depth rank <br />
</p>

<hr>
<h2 id='dur_gaps'>calculate the duration of stratigraphic gaps using astronomical cycles</h2><span id='topic+dur_gaps'></span>

<h3>Description</h3>

<p>calculate the duration of stratigraphic gaps using the duration
of stable astronomical cycles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dur_gaps(
  proxies = NULL,
  retracked_period_1 = NULL,
  retracked_period_2 = NULL,
  min_max = NULL,
  n_simulations = 10,
  tracked_cycle_period = NULL,
  tracked_cycle_period_unc = NULL,
  tracked_cycle_period_unc_dist = "u",
  pts = 5,
  dj = 1/200,
  lowerPeriod = 1,
  upperPeriod = 3200,
  period_max = NULL,
  period_min = NULL,
  missing_cycle_dur = NULL,
  n_cycles_missing = 1,
  missing_cycle_unc = NULL,
  missing_cycle_unc_dist = "u",
  run_multicore = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dur_gaps_+3A_proxies">proxies</code></td>
<td>
<p>list of proxies which were used to create a astrochronological
age model and which are used to calculate the duration of the gap</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_retracked_period_1">retracked_period_1</code></td>
<td>
<p>A matrix of 3 columns in which the first column
is depth/height.The second column is the period of the tracked cycle.
The thirds column is uncertainty given as 1 standard deviation for the
period of the tracked cycle. The gap to be modeled should be located
in between retracked_period_1 and retracked_period_2</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_retracked_period_2">retracked_period_2</code></td>
<td>
<p>A matrix of 3 columns in which the first column
is depth/height.The second column is the period of the tracked cycle.
The thirds column is uncertainty given as 1 standard deviation for the
period of the tracked cycle. The gap to be modeled should be located
in between retracked_period_1 and retracked_period_2</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_min_max">min_max</code></td>
<td>
<p>list of &quot;min&quot; or &quot;max&quot; indicating whether time should be
estimated between minima or maxima for each proxy</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_n_simulations">n_simulations</code></td>
<td>
<p>number of gap duration to calculate</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>period in time of the tracked cycle</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_tracked_cycle_period_unc">tracked_cycle_period_unc</code></td>
<td>
<p>uncertainty in the period of the tracked cycle</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_tracked_cycle_period_unc_dist">tracked_cycle_period_unc_dist</code></td>
<td>
<p>distribution of the uncertainty of the
tracked cycle value need to be either &quot;u&quot; for uniform distribution or
&quot;n&quot; for normal distribution  <code>Default="u"</code></p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_pts">pts</code></td>
<td>
<p>the pts parameter specifies how many points to the left/right up/down the peak detect algorithm goes in detecting
a peak. The peak detecting algorithm works by comparing the values left/right up/down of it, if the values are both higher or lower
then the value a peak. To deal with error produced by this algorithm the pts parameter can be changed which can
aid in peak detection. Usually increasing the pts parameter means more peak certainty, however it also means that minor peaks might not be
picked up by the algorithm <code>Default=5</code>#'</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales. The CWT analyses analyses the signal using successive periods
which increase by the power of 2 (e.g.2^0=1,2^1=2,2^2=4,2^3=8,2^4=16). To have more resolution
in-between these steps the dj parameter exists, the dj parameter specifies how many extra steps/spacing in-between
the power of 2 scaled CWT is added. The amount of steps is 1/x with a higher x indicating a smaller spacing.
Increasing the increases the computational time of the CWT <code>Default=1/200</code>.</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_lowerperiod">lowerPeriod</code></td>
<td>
<p>Lowest period to be analyzed <code>Default=2</code>.
The CWT analyses the signal starting from the lowerPeriod to the upperPeriod so the proper selection these
parameters allows to analyze the signal for a specific range of cycles.
scaling is done using power 2 so for the best plotting results select a value to the power or 2.</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_upperperiod">upperPeriod</code></td>
<td>
<p>Upper period to be analyzed <code>Default=1024</code>.
The CWT analyses the signal starting from the lowerPeriod to the upperPeriod so the proper selection these
parameters allows to analyze the signal for a specific range of cycles.
scaling is done using power 2 so for the best plotting results select a value to the power or 2.</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_period_max">period_max</code></td>
<td>
<p>Maximum period (upper boundary) to be used to extract a cycle.</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_period_min">period_min</code></td>
<td>
<p>Minimum period (lower boundary) to be used to extract a cycle.</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_missing_cycle_dur">missing_cycle_dur</code></td>
<td>
<p>duration of the missing cycles</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_n_cycles_missing">n_cycles_missing</code></td>
<td>
<p>number of missing cycles <code>Default=1</code></p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_missing_cycle_unc">missing_cycle_unc</code></td>
<td>
<p>duration uncertainty of the missing cycle</p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_missing_cycle_unc_dist">missing_cycle_unc_dist</code></td>
<td>
<p>distribution of the uncertainty of the
tracked cycle value need to be either &quot;u&quot; for uniform distribution or
&quot;n&quot; for normal distribution  <code>Default="u"</code></p>
</td></tr>
<tr><td><code id="dur_gaps_+3A_run_multicore">run_multicore</code></td>
<td>
<p>Run function using multiple cores <code>Default="FALSE"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with all the calculated gap durations
</p>

<hr>
<h2 id='extract_amplitude'>Extract amplitude from a signal</h2><span id='topic+extract_amplitude'></span>

<h3>Description</h3>

<p>Extracts the amplitude from a signal using the continuous wavelet transform using a Morlet wavelet.
The extraction of the amplitude is useful for cyclostratigraphic studies because the amplitude of
an astronomical cycle is modulated by higher order astronomical cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_amplitude(
  signal = NULL,
  pts = 3,
  genplot = FALSE,
  remean = TRUE,
  ver_results = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_amplitude_+3A_signal">signal</code></td>
<td>
<p>Input signal from which the amplitude is extracted any signal in which the first column is
depth/time and the second column is the proxy record from which the amplitude is extracted</p>
</td></tr>
<tr><td><code id="extract_amplitude_+3A_pts">pts</code></td>
<td>
<p>The pts parameter specifies how many points to the left/right up/down the peak detect algorithm goes in detecting
a peak. The peak detecting algorithm works by comparing the values left/right up/down of it, if the values are both higher or lower
then the value a peak. To deal with error produced by this algorithm the pts parameter can be changed which can
aid in peak detection. Usually increasing the pts parameter means more peak certainty, however it also means that minor peaks might not be
picked up by the algorithm <code>Default=3</code></p>
</td></tr>
<tr><td><code id="extract_amplitude_+3A_genplot">genplot</code></td>
<td>
<p>If set to TRUE a plot with extracted amplitude will be displayed <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_amplitude_+3A_remean">remean</code></td>
<td>
<p>Prior to analysis the mean is subtracted from the data set to re-mean set <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="extract_amplitude_+3A_ver_results">ver_results</code></td>
<td>
<p>To verify the amplitude extraction is representative of the amplitude
extracted using the <code><a href="#topic+extract_amplitude">extract_amplitude</a></code> function the results can be compared to the amplitude extracted
using the <code><a href="#topic+Hilbert_transform">Hilbert_transform</a></code> if the mean difference is more then 5
whether the input contains a reliable enough signal with high a enough amplitude modulation to actually extract an amplitude from. <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_amplitude_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns.
The first column is depth/time.
The second column is the extracted amplitude
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+reconstruct">reconstruct</a> function of the 'WaveletComp' R package
which is based on the wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo.
The assignment of the standard deviation of the uncertainty of the wavelet
is based on the work of Gabor (1946) and Russell et al., (2016)
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Extract amplitude of the 405 kyr eccentricity cycle from the the magnetic
# susceptibility data set of De pas et al., (2018)
#Perform the CWT on the magnetic susceptibility data set of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)")

#Instead of tracking, the tracked solution data set mag_track_solution
#is used
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE
)

#Smooth the completed tracking of the 405 kyr eccentricity cycle in the wavelet spectra

mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE)




mag_405_ecc  &lt;- extract_signal(
tracked_cycle_curve = mag_track_complete,
wavelet = mag_wt,
period_up = 1.2,
period_down = 0.8,
add_mean = TRUE,
tracked_cycle_period = 405,
extract_cycle = 405,
tune = FALSE,
plot_residual = FALSE
)

#extract the amplitude  of the 405 kyr eccentricity cycle
mag_ampl &lt;- extract_amplitude(
signal = mag_405_ecc,
pts=3,
genplot = FALSE,
ver_results = FALSE,
keep_editable=FALSE)


</code></pre>

<hr>
<h2 id='extract_power'>Extract power from a wavelet spectra</h2><span id='topic+extract_power'></span>

<h3>Description</h3>

<p>Extracts the  spectral power from a wavelet spectra in the depth domain using a traced period
and boundaries surround the traced period.
The extraction of spectral is useful for cyclostratigraphic studies because the spectral power of an
astronomical cycle is modulated by higher order astronomical cycles.
The spectral power record from an astronomical cycle can thus be used as a proxy for
amplitude modulating cycles
The traced period result from the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code>
function with boundaries is used to extract spectral power in the depth domain from a wavelet spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_power(
  completed_series = NULL,
  wavelet = NULL,
  period_up = 1.2,
  period_down = 0.8,
  tracked_cycle_period = NULL,
  extract_cycle_power = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_power_+3A_completed_series">completed_series</code></td>
<td>
<p>Traced period result from the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code>
function completed using the <code><a href="#topic+completed_series">completed_series</a></code>.
The input can be pre-smoothed using the the <code><a href="#topic+loess_auto">loess_auto</a></code> function.</p>
</td></tr>
<tr><td><code id="extract_power_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="extract_power_+3A_period_up">period_up</code></td>
<td>
<p>Upper period as a factor of the to be extracted power <code>Default=1.2</code>.</p>
</td></tr>
<tr><td><code id="extract_power_+3A_period_down">period_down</code></td>
<td>
<p>Lower period as a factor of the to be extracted power <code>Default=0.8</code>.</p>
</td></tr>
<tr><td><code id="extract_power_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period of the tracked cycle (make sure that
<code>tracked_cycle_period</code>) and <code>extract_cycle_power</code>) are of the same
unit (either depth or time domain).</p>
</td></tr>
<tr><td><code id="extract_power_+3A_extract_cycle_power">extract_cycle_power</code></td>
<td>
<p>Period of the cycle for which the power will be
extracted (make sure that <code>extract_cycle_power</code>) and
<code>tracked_cycle_period</code>) are of the same unit (either depth or time domain).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 3 columns.
The first column is depth/time.
The second column is extracted power.
The third column is extracted power/total power.
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+reconstruct">reconstruct</a> function of the 'WaveletComp' R package
which is based on the wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo.
The assignment of the standard deviation of the uncertainty of the wavelet
is based on the work of Gabor (1946) and Russell et al., (2016)
The functionality of this function is is inspired by the
<a href="astrochron.html#topic+integratePower">integratePower</a> function of the 'astrochron' R package.
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Extract the power of the 405 kyr eccentricity cycle from the the magnetic
# susceptibility data set of De pas et al., (2018)
#Perform the CWT on the magnetic susceptibility data set of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)")

#Instead of tracking, the tracked solution data set mag_track_solution
#is used
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE
)

#Smooth the completed tracking of the 405 kyr eccentricity cycle in the wavelet spectra

mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE)

#extract the spectral power of the 405 kyr eccentricity cycle
mag_power &lt;- extract_power(
completed_series = mag_track_complete,
wavelet = mag_wt,
period_up = 1.2,
period_down = 0.8,
tracked_cycle_period = 405,
extract_cycle_power = 405
)

</code></pre>

<hr>
<h2 id='extract_power_stable'>Extract power from a wavelet spectra by using a constant period/duration</h2><span id='topic+extract_power_stable'></span>

<h3>Description</h3>

<p>Extract spectral power from the wavelet using a constant period/duration and
boundaries as selection criteria. The extraction of spectral is useful for cyclostratigraphic studies because the spectral power of an
astronomical cycle is modulated by higher order astronomical cycles.
The spectral power record from an astronomical cycle can thus be used as a proxy for
amplitude modulating cycles. The spectral power is extracted from a wavelet spectra
which was created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code>
function for a given, <code>cycle</code>, <code>period_up</code> and <code>period_down</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_power_stable(
  wavelet = NULL,
  cycle = NULL,
  period_up = 1.2,
  period_down = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_power_stable_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="extract_power_stable_+3A_cycle">cycle</code></td>
<td>
<p>Period of cycle for which the power will be extracted from the record.</p>
</td></tr>
<tr><td><code id="extract_power_stable_+3A_period_up">period_up</code></td>
<td>
<p>Species the upper period of the to be extracted power <code>Default=1.2</code>.</p>
</td></tr>
<tr><td><code id="extract_power_stable_+3A_period_down">period_down</code></td>
<td>
<p>specifies the lower period of the to be extracted power <code>Default=0.8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 3 columns.
The first column is depth/time.
The second column is extracted power.
The third column is extracted power/total power.
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+reconstruct">reconstruct</a> function of the 'WaveletComp' R package
which is based on the wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo (1998).
The functionality of this function is is inspired by the
<a href="astrochron.html#topic+integratePower">integratePower</a> function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Extract the spectral power of the 210 yr de Vries cycle from the Total Solar
#Irradiance data set of Steinhilber et al., (2012).

TSI_wt &lt;-
 analyze_wavelet(
   data = TSI,
   dj = 1/200,
   lowerPeriod = 16,
   upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )
TSI_wt_pwr_de_Vries_cycle &lt;-  extract_power_stable(
 wavelet = TSI_wt,
 cycle = 210,
 period_up = 1.2,
 period_down = 0.8
)


</code></pre>

<hr>
<h2 id='extract_signal'>Extract signal from a wavelet spectra using a traced period curve</h2><span id='topic+extract_signal'></span>

<h3>Description</h3>

<p>Extract signal power from the wavelet in the depth domain using the traced period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_signal(
  tracked_cycle_curve = NULL,
  wavelet = NULL,
  period_up = 1.2,
  period_down = 0.8,
  add_mean = TRUE,
  tracked_cycle_period = NULL,
  extract_cycle = NULL,
  tune = FALSE,
  plot_residual = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_signal_+3A_tracked_cycle_curve">tracked_cycle_curve</code></td>
<td>
<p>Traced period result from the <code>track_period_wavelet</code>
function completed using the <code>completed_series</code>.
The input can be pre-smoothed using the the <code>loess_auto</code> function.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_wavelet">wavelet</code></td>
<td>
<p>wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_period_up">period_up</code></td>
<td>
<p>Upper period as a factor of the to be extracted cycle <code>Default=1.2</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_period_down">period_down</code></td>
<td>
<p>Lower period as a factor of the to be extracted cycle <code>Default=0.8</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_add_mean">add_mean</code></td>
<td>
<p>Add mean to the extracted cycle <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period in time of the traced cycle.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_extract_cycle">extract_cycle</code></td>
<td>
<p>Period of the to be extracted cycle.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_tune">tune</code></td>
<td>
<p>Convert record from the depth to the time domain using the traced period <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_plot_residual">plot_residual</code></td>
<td>
<p>Plot the residual signal after extraction of set cycle <code>Default=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns
The first column is depth/time
The second column is extracted signal
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+reconstruct">reconstruct</a> function of the 'WaveletComp' R package
which is based on the wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo (1998).
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Extract the 405 kyr eccentricity cycle from the the magnetic susceptibility \cr
#record of the Sullivan core and use the Gabor uncertainty principle to define \cr
#the mathematical uncertainty of the analysis and use a factor of that standard \cr
#deviation to define boundaries.

#Perform the CWT
mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)")

#Instead of tracking, the tracked solution data set \code{\link{mag_track_solution}} is used \cr
mag_track &lt;- mag_track_solution


mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE
)

# smooth the tracking of the 405 kyr eccentricity cycle
mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE)

# extract the 405 kyr eccentricity cycle from the wavelet spectrum and use the \cr
# tracked cycle curve and set factors of the extracted cycle as boundaries

mag_405_ecc  &lt;- extract_signal(
tracked_cycle_curve = mag_track_complete,
wavelet = mag_wt,
period_up = 1.2,
period_down = 0.8,
add_mean = TRUE,
tracked_cycle_period = 405,
extract_cycle = 405,
tune = FALSE,
plot_residual = FALSE
)

</code></pre>

<hr>
<h2 id='extract_signal_stable'>Extract a signal/cycle from a wavelet spectra using a set period and boundaries</h2><span id='topic+extract_signal_stable'></span>

<h3>Description</h3>

<p>Extracts a cycle from the wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code>
function using a fixed period and fixed period boundaries defined as factors of the original cycle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_signal_stable(
  wavelet = NULL,
  cycle = NULL,
  period_up = 1.2,
  period_down = 0.8,
  add_mean = TRUE,
  plot_residual = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_signal_stable_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_+3A_cycle">cycle</code></td>
<td>
<p>Period of the cycle which needs to be extracted.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_+3A_period_up">period_up</code></td>
<td>
<p>Specifies the upper period as a factor of the to be extracted cycle <code>Default=1.2</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_+3A_period_down">period_down</code></td>
<td>
<p>Specifies the lower period as a factor of the to be extracted cycle <code>Default=0.8</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_+3A_add_mean">add_mean</code></td>
<td>
<p>Add mean to the extracted cycle <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_+3A_plot_residual">plot_residual</code></td>
<td>
<p>plot the residual signal after extraction of set cycle <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>#'Returns a matrix with 2 columns.
The first column is time/depth.
The second column is the extracted signal/cycle.
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+reconstruct">reconstruct</a> function of the 'WaveletComp' R package
which is based on the wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo (1998).
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example in which the ~210yr de Vries cycle is extracted from the Total Solar
#Irradiance data set of Steinhilber et al., (2012)

#Perform the CWT
TSI_wt &lt;-
analyze_wavelet(
data = TSI,
dj = 1/200,
lowerPeriod = 16,
upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )

#Extract the 210 yr de Vries cycle from the wavelet spectra
de_Vries_cycle &lt;- extract_signal_stable(wavelet=TSI_wt,
cycle=210,
period_up =1.25,
period_down = 0.75,
add_mean=TRUE,
plot_residual=FALSE,
keep_editable=FALSE)

</code></pre>

<hr>
<h2 id='extract_signal_stable_V2'>Extract signal from a wavelet spectrum using a upper and lower period boundary</h2><span id='topic+extract_signal_stable_V2'></span>

<h3>Description</h3>

<p>Extract a signal from the wavelet using a upper and lower period boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_signal_stable_V2(
  wavelet = NULL,
  period_max = NULL,
  period_min = NULL,
  add_mean = TRUE,
  plot_residual = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_signal_stable_V2_+3A_wavelet">wavelet</code></td>
<td>
<p>wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_V2_+3A_period_max">period_max</code></td>
<td>
<p>Maximum period (upper boundary) to be used to extract a cycle.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_V2_+3A_period_min">period_min</code></td>
<td>
<p>Minimum period (lower boundary) to be used to extract a cycle.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_V2_+3A_add_mean">add_mean</code></td>
<td>
<p>Add mean to the extracted cycle <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_V2_+3A_plot_residual">plot_residual</code></td>
<td>
<p>Plot the signal from which the extracted cycle is subtracted <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_stable_V2_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Signal extracted from the wavelet spectra.
Output is a matrix with the first column being depth/time
and the second column is the cycle extracted from the proxy record.
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+reconstruct">reconstruct</a> function of the 'WaveletComp' R package
which is based on the wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo (1998).
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example in which the ~210yr de Vries cycle is extracted from the Total Solar
# Irradiance data set of Steinhilber et al., (2012)

TSI_wt &lt;-
analyze_wavelet(
data = TSI,
dj = 1/200,
lowerPeriod = 16,
upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )

de_Vries_cycle &lt;- extract_signal_stable_V2(wavelet=TSI_wt,
period_max = 240,
period_min = 180,
add_mean=TRUE,
plot_residual=FALSE,
keep_editable=FALSE)


</code></pre>

<hr>
<h2 id='extract_signal_standard_deviation'>Extract a signal using standard deviation</h2><span id='topic+extract_signal_standard_deviation'></span>

<h3>Description</h3>

<p>Extract signal from a
wavelet spectra in the depth domain using a the standard deviation of the omega (number of cycles)
as boundaries. The uncertainty is based on the Gabor uncertainty principle applied to the
continuous wavelet transform using a Morlet wavelet. The calculated uncertainty is the underlying
analytical uncertainty which is the result of applying the Gabor uncertainty principle to the
continuous wavelet transform using a Morlet wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_signal_standard_deviation(
  wavelet = NULL,
  tracked_cycle_curve = NULL,
  multi = 1,
  extract_cycle = NULL,
  tracked_cycle_period = NULL,
  add_mean = TRUE,
  tune = FALSE,
  genplot_uncertainty_wt = FALSE,
  genplot_extracted = FALSE,
  keep_editable = FALSE,
  palette_name = "rainbow",
  color_brewer = "grDevices"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_signal_standard_deviation_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_tracked_cycle_curve">tracked_cycle_curve</code></td>
<td>
<p>Curve of the cycle tracked using the
<code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function. Any input (matrix or data frame)
in which the first column is depth or time and the second column is period should work.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_multi">multi</code></td>
<td>
<p>multiple of the standard deviation to be used as boundaries for the cycle extraction
<code>Default=1</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_extract_cycle">extract_cycle</code></td>
<td>
<p>Period of the cycle to be extracted.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_tracked_cycle_period">tracked_cycle_period</code></td>
<td>
<p>Period of the tracked cycle.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_add_mean">add_mean</code></td>
<td>
<p>Add mean to the extracted cycle <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_tune">tune</code></td>
<td>
<p>Tune data set using the <code>Default=tracked_cycle_curve</code> curve <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_genplot_uncertainty_wt">genplot_uncertainty_wt</code></td>
<td>
<p>Generate a wavelet spectra plot with the tracked curve and its
analytical uncertainty based the Gabor uncertainty principle applied
continuous wavelet transform using a Morlet wavelet on superimposed on top of it.
In the plot the red curve and blue curves are the upper and lower bounds
based on the <code>multi</code> parameter which x-times the standard deviation of uncertainty.
The black curve is the <code>Default=FALSE</code> curve.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_genplot_extracted">genplot_extracted</code></td>
<td>
<p>Generates a plot with the data set and
the extracted cycle on top <code>Default=FALSE</code> of it.</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="extract_signal_standard_deviation_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Signal extracted from the wavelet spectra.
Output is a matrix with the first column being depth/time
and the second column is the astronomical cycle extracted from the proxy record
</p>
<p>If <code>genplot_uncertainty_wt=TRUE</code> then a wavelet spectra will be plotted
with the uncertainty superimposed on top of it. In the plot the red curve and
blue curves are the upper and lower bounds
based on the <code>multi</code> parameter.The black curve is the <code>Default=tracked_cycle_curve</code> curve.
If <code>genplot_extracted=TRUE</code> plot with the data set and
the extracted cycle on top of it will be plotted.
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+reconstruct">reconstruct</a> function of the 'WaveletComp' R package
which is based on the wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo (1998).
The assignment of the standard deviation of the uncertainty of the wavelet
is based on the work of Gabor (1946) and Russell et al., (2016)
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Gabor, Dennis. &quot;Theory of communication. Part 1: The analysis of information.&quot;
Journal of the Institution of Electrical Engineers-part III: radio and
communication engineering 93, no. 26 (1946): 429-441.<a href="http://genesis.eecg.toronto.edu/gabor1946.pdf">http://genesis.eecg.toronto.edu/gabor1946.pdf</a>
</p>
<p>Russell, Brian, and Jiajun Han. &quot;Jean Morlet and the continuous wavelet transform.
&quot; CREWES Res. Rep 28 (2016): 115. <a href="https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf">https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Extract the 405 kyr eccentricity cycle from the magnetic susceptibility
#record of the Sullivan core of Pas et al., (2018) and use the Gabor
# uncertainty principle to define the mathematical uncertainty of the
# analysis and use a factor of that standard deviation to define
# boundaries

# perform the CWT
mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)",
#                                   palette_name="rainbow",
#                                   color_brewer="grDevices")

#Instead of tracking, the tracked solution data set mag_track_solution is used
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE
)

# smooth the tracking of the 405 kyr eccentricity cycle
mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE)

# extract the 405 kyr eccentricity cycle from the wavelet spectrum and use
# the Gabor uncertainty principle to define the mathematical uncertainty of
# the analysis and use a multiple of the derived standard deviation to define boundaries

mag_405_ecc &lt;- extract_signal_standard_deviation(
wavelet = mag_wt,
tracked_cycle_curve = mag_track_complete,
multi = 1,
extract_cycle = 405,
tracked_cycle_period = 405,
add_mean = TRUE,
tune = FALSE,
genplot_uncertainty_wt = FALSE,
genplot_extracted = FALSE,
keep_editable=FALSE,
palette_name="rainbow",
color_brewer="grDevices"
)

</code></pre>

<hr>
<h2 id='flmw'>Fit linear models to spectral peaks extracted from the wavelet spectra to astronomical cycles multiplied by sedimentation rate x</h2><span id='topic+flmw'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+flmw">flmw</a></code> function is used calculate the linear correlation
for a list of astronomical cycles transformed using a range of sedimentation rates and then compared
to spectral peaks of a wavelet spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flmw(
  wavelet = NULL,
  sedrate_low = NULL,
  sedrate_high = NULL,
  spacing = NULL,
  cycles = c(NULL),
  x_lab = "depth",
  y_lab = "sedrate",
  run_random = FALSE,
  rand_simulations = 1000,
  run_multicore = FALSE,
  genplot = FALSE,
  palette_name = "rainbow",
  color_brewer = "grDevices",
  plot_res = 2,
  keep_editable = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flmw_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function</p>
</td></tr>
<tr><td><code id="flmw_+3A_sedrate_low">sedrate_low</code></td>
<td>
<p>Minimum sedimentation rate (cm/kyr)for which the sum of maximum spectral power is calculated for.</p>
</td></tr>
<tr><td><code id="flmw_+3A_sedrate_high">sedrate_high</code></td>
<td>
<p>Maximum sedimentation rate (cm/kyr) for which the sum of maximum spectral power is calculated  for.</p>
</td></tr>
<tr><td><code id="flmw_+3A_spacing">spacing</code></td>
<td>
<p>Spacing (cm/kyr) between sedimentation rates</p>
</td></tr>
<tr><td><code id="flmw_+3A_cycles">cycles</code></td>
<td>
<p>Astronomical cycles (in kyr) for which the combined sum of maximum spectral power is calculated for</p>
</td></tr>
<tr><td><code id="flmw_+3A_x_lab">x_lab</code></td>
<td>
<p>label for the y-axis <code>Default="depth"</code></p>
</td></tr>
<tr><td><code id="flmw_+3A_y_lab">y_lab</code></td>
<td>
<p>label for the y-axis <code>Default="sedrate"</code></p>
</td></tr>
<tr><td><code id="flmw_+3A_run_random">run_random</code></td>
<td>
<p>run multiple simulation to calculate percentile against the 0 hypothesis</p>
</td></tr>
<tr><td><code id="flmw_+3A_rand_simulations">rand_simulations</code></td>
<td>
<p>nr of simulations to calculate percentile against the 0 hypothesis</p>
</td></tr>
<tr><td><code id="flmw_+3A_run_multicore">run_multicore</code></td>
<td>
<p>run simulation using multiple cores <code>Default=FALSE</code>
the simulation is run at x-2 cores to allow the 2 remaining processes to run background processes</p>
</td></tr>
<tr><td><code id="flmw_+3A_genplot">genplot</code></td>
<td>
<p>Generate plot <code>Default="FALSE"</code></p>
</td></tr>
<tr><td><code id="flmw_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="flmw_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="flmw_+3A_plot_res">plot_res</code></td>
<td>
<p>options 1-8 option 1: slope coefficient, option 2: r squared,
option 3: nr of components, option 4: difference to the  origin , option 5: slope coefficient percentile
option 6: r squared percentile, option 7: nr of components percentile,
option 8: difference to the origin percentile <code>Default=2</code></p>
</td></tr>
<tr><td><code id="flmw_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="flmw_+3A_verbose">verbose</code></td>
<td>
<p>Print text <code>Default=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list which contains 10 elements
element 1: slope coefficient
element 2: r squared
element 3: nr of components
element 4: difference to the origin
element 5: slope coefficient percentile
element 6: r squared percentile
element 7: nr of components percentile,
element 8: difference to the origin percentile
element 9: y-axis values of the matrices which is sedimentation rate
element 10: x-axis values of the matrices which is depth
</p>


<h3>Author(s)</h3>

<p>Based on the <a href="astrochron.html#topic+eAsm">eAsm</a> function of the 'astrochron' R package and the 'eCOCO' and 'COCO' function of the 'Acycle' software
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>
<p>Acycle: Time-series analysis software for paleoclimate research and education,
Mingsong Li, Linda Hinnov, Lee Kump,
Computers &amp; Geosciences,Volume 127,2019,Pages 12-22,ISSN 0098-3004,
&lt;doi:10.1016/j.cageo.2019.02.011&gt;
</p>
<p>Tracking variable sedimentation rates and astronomical forcing in Phanerozoic paleoclimate proxy series with evolutionary correlation coefficients and hypothesis testing,
Mingsong Li, Lee R. Kump, Linda A. Hinnov, Michael E. Mann,
Earth and Planetary Science Letters,Volume 501,
T2018,Pages 165-179,ISSN 0012-821X,&lt;doi:10.1016/j.epsl.2018.08.041&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#estimate sedimentation rate for the magnetic susceptibility record
# of the Sullivan core of Pas et al., (2018).

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

sedrates &lt;- flmw(wavelet = mag_wt,
    sedrate_low = 0.5,
    sedrate_high = 4,
    spacing = 0.05,
    cycles = c(2376,1600,1180,696,406,110),
    x_lab = "depth",
    y_lab = "sedrate",
    run_random = FALSE,
    rand_simulations = 50, # increase to get better constrainted resutls
    run_multicore = FALSE,
    genplot = FALSE,
    palette_name = "rainbow",
    color_brewer = "grDevices",
    plot_res = 2,
    keep_editable=FALSE,
    verbose=FALSE)


</code></pre>

<hr>
<h2 id='geo_col'>Generate standard color codes for the Geological Time Scale</h2><span id='topic+geo_col'></span>

<h3>Description</h3>

<p>Generates the R color code which corresponds its respective
geological subdivision
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_col(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_col_+3A_name">name</code></td>
<td>
<p>Name of the geologchronological subdivision</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the color code of the geological subdivision
</p>


<h3>References</h3>

<p>Ogg, Gabi &amp; Ogg, James &amp; Gradstein, Felix. (2021).
Recommended color coding of stages - Appendix 1
from Geologic Time Scale 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate the Silurian part of the GTS
plot.new()
plot(
 x = c(0, 1),
 y = c(419.2, 443.8),
 col = "white",
 xlab = "",
 ylab = "Time (Ma)",
 xaxt = "n",
 xaxs = "i",
 yaxs = "i",
 ylim = rev(c(419, 444))
)            # Draw empty plot

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Rhuddanian"),
 col =geo_col("Rhuddanian")
)

text(
 0.85,geo_mid("Rhuddanian"),
 "Rhuddanian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Aeronian"),
 col =geo_col("Aeronian")
)

text(
 0.85,geo_mid("Aeronian"),
 "Aeronian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Telychian"),
 col =geo_col("Telychian")
)

text(
 0.85,geo_mid("Telychian"),
 "Telychian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Sheinwoodian"),
 col =geo_col("Sheinwoodian")
)

text(
 0.85,geo_mid("Sheinwoodian"),
 "Sheinwoodian",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Homerian"),
 col =geo_col("Homerian")
)

text(
 0.85,geo_mid("Homerian"),
 "Homerian",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Gorstian"),
 col =geo_col("Gorstian")
)

text(
 0.85,geo_mid("Gorstian"),
 "Gorstian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Ludfordian"),
 col =geo_col("Ludfordian")
)

text(
 0.85,geo_mid("Ludfordian"),
 "Ludfordian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Pridoli_Age"),
 col =geo_col("Pridoli_Age")
)



polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Pridoli"),
 col =geo_col("Pridoli")
)

text(
 0.5,geo_mid("Pridoli"),
 "Pridoli",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Ludlow"),
 col =geo_col("Ludlow")
)

text(
 0.5,geo_mid("Ludlow"),
 "Ludlow",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Wenlock"),
 col =geo_col("Wenlock")
)

text(
 0.5,geo_mid("Wenlock"),
 "Wenlock",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Llandovery"),
 col =geo_col("Llandovery")
)

text(
 0.5,geo_mid("Llandovery"),
 "Llandovery",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0, 0.33, 0.33, 0),
 y = geo_loc("Silurian"),
 col =geo_col("Silurian")
)

text(
 0.165,geo_mid("Silurian"),
 "Silurian",
 cex = 1,
 col = "black",
 srt = 0
)


</code></pre>

<hr>
<h2 id='geo_loc'>Generates  ages for the boundaries of a geochronological subdivision</h2><span id='topic+geo_loc'></span>

<h3>Description</h3>

<p>Generates  ages for the boundaries of a
geochronological subdivision which is based on the Geological Time Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_loc(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_loc_+3A_name">name</code></td>
<td>
<p>Name of the geologchronological subdivision</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ages of the boundary of a geochronological subdivision
which can then be added to a polygon object
</p>


<h3>References</h3>

<p>Ogg, Gabi &amp; Ogg, James &amp; Gradstein, Felix. (2021).
Recommended color coding of stages - Appendix 1
from Geologic Time Scale 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate the Silurian part of the GTS
plot.new()
plot(
 x = c(0, 1),
 y = c(419.2, 443.8),
 col = "white",
 xlab = "",
 ylab = "Time (Ma)",
 xaxt = "n",
 xaxs = "i",
 yaxs = "i",
 ylim = rev(c(419, 444))
)            # Draw empty plot

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Rhuddanian"),
 col =geo_col("Rhuddanian")
)

text(
 0.85,geo_mid("Rhuddanian"),
 "Rhuddanian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Aeronian"),
 col =geo_col("Aeronian")
)

text(
 0.85,geo_mid("Aeronian"),
 "Aeronian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Telychian"),
 col =geo_col("Telychian")
)

text(
 0.85,geo_mid("Telychian"),
 "Telychian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Sheinwoodian"),
 col =geo_col("Sheinwoodian")
)

text(
 0.85,geo_mid("Sheinwoodian"),
 "Sheinwoodian",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Homerian"),
 col =geo_col("Homerian")
)

text(
 0.85,geo_mid("Homerian"),
 "Homerian",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Gorstian"),
 col =geo_col("Gorstian")
)

text(
 0.85,geo_mid("Gorstian"),
 "Gorstian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Ludfordian"),
 col =geo_col("Ludfordian")
)

text(
 0.85,geo_mid("Ludfordian"),
 "Ludfordian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Pridoli_Age"),
 col =geo_col("Pridoli_Age")
)



polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Pridoli"),
 col =geo_col("Pridoli")
)

text(
 0.5,geo_mid("Pridoli"),
 "Pridoli",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Ludlow"),
 col =geo_col("Ludlow")
)

text(
 0.5,geo_mid("Ludlow"),
 "Ludlow",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Wenlock"),
 col =geo_col("Wenlock")
)

text(
 0.5,geo_mid("Wenlock"),
 "Wenlock",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Llandovery"),
 col =geo_col("Llandovery")
)

text(
 0.5,geo_mid("Llandovery"),
 "Llandovery",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0, 0.33, 0.33, 0),
 y = geo_loc("Silurian"),
 col =geo_col("Silurian")
)

text(
 0.165,geo_mid("Silurian"),
 "Silurian",
 cex = 1,
 col = "black",
 srt = 0
)


</code></pre>

<hr>
<h2 id='geo_mid'>Generate the mean age of a geological subdivision</h2><span id='topic+geo_mid'></span>

<h3>Description</h3>

<p>Generates the mean age of a
geological subdivision which is based on the Geological Time Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_mid(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_mid_+3A_name">name</code></td>
<td>
<p>Name of the geologchronological subdivision</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mean age of the geochronological subdivision
</p>


<h3>References</h3>

<p>Ogg, Gabi &amp; Ogg, James &amp; Gradstein, Felix. (2021).
Recommended color coding of stages - Appendix 1
from Geologic Time Scale 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate the Silurian part of the GTS
plot.new()
plot(
 x = c(0, 1),
 y = c(419.2, 443.8),
 col = "white",
 xlab = "",
 ylab = "Time (Ma)",
 xaxt = "n",
 xaxs = "i",
 yaxs = "i",
 ylim = rev(c(419, 444))
)            # Draw empty plot

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Rhuddanian"),
 col =geo_col("Rhuddanian")
)

text(
 0.85,geo_mid("Rhuddanian"),
 "Rhuddanian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Aeronian"),
 col =geo_col("Aeronian")
)

text(
 0.85,geo_mid("Aeronian"),
 "Aeronian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Telychian"),
 col =geo_col("Telychian")
)

text(
 0.85,geo_mid("Telychian"),
 "Telychian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Sheinwoodian"),
 col =geo_col("Sheinwoodian")
)

text(
 0.85,geo_mid("Sheinwoodian"),
 "Sheinwoodian",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Homerian"),
 col =geo_col("Homerian")
)

text(
 0.85,geo_mid("Homerian"),
 "Homerian",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Gorstian"),
 col =geo_col("Gorstian")
)

text(
 0.85,geo_mid("Gorstian"),
 "Gorstian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Ludfordian"),
 col =geo_col("Ludfordian")
)

text(
 0.85,geo_mid("Ludfordian"),
 "Ludfordian",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.66, 1, 1, 0.66),
 y = geo_loc("Pridoli_Age"),
 col =geo_col("Pridoli_Age")
)



polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Pridoli"),
 col =geo_col("Pridoli")
)

text(
 0.5,geo_mid("Pridoli"),
 "Pridoli",
 cex = 1,
 col = "black",
 srt = 0
)


polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Ludlow"),
 col =geo_col("Ludlow")
)

text(
 0.5,geo_mid("Ludlow"),
 "Ludlow",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Wenlock"),
 col =geo_col("Wenlock")
)

text(
 0.5,geo_mid("Wenlock"),
 "Wenlock",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0.33, 0.66, 0.66, 0.33),
 y = geo_loc("Llandovery"),
 col =geo_col("Llandovery")
)

text(
 0.5,geo_mid("Llandovery"),
 "Llandovery",
 cex = 1,
 col = "black",
 srt = 0
)

polygon(
 x = c(0, 0.33, 0.33, 0),
 y = geo_loc("Silurian"),
 col =geo_col("Silurian")
)

text(
 0.165,geo_mid("Silurian"),
 "Silurian",
 cex = 1,
 col = "black",
 srt = 0
)


</code></pre>

<hr>
<h2 id='grey'>Grey scale record IODP 926 of Zeeden et al., (2013)</h2><span id='topic+grey'></span>

<h3>Description</h3>

<p>IODP 926 grey scale record of Zeeden et al., (2013) for the (154-174m) interval.
The (154-174m) interval spans the Miocene.
</p>


<h3>Details</h3>

<p>Column 1: depth (meters)<br />
Column 2: greyscale value<br />
</p>


<h3>References</h3>

<p>Christian Zeeden, Frederik Hilgen, Thomas Westerhold, Lucas Lourens, Ursula Röhl, Torsten Bickert,
Revised Miocene splice, astronomical tuning and calcareous plankton biochronology of ODP Site 926 between 5 and 14.4Ma,
Palaeogeography, Palaeoclimatology, Palaeoecology,Volume 369,2013,Pages 430-451,ISSN 0031-0182,
&lt;doi:10.1016/j.palaeo.2012.11.009&gt;
</p>

<hr>
<h2 id='grey_track'>Tracking points of the precession (22 kyr cycle) IODP 926 grey scale (154-174m) record of Zeeden et al., (2013)</h2><span id='topic+grey_track'></span>

<h3>Description</h3>

<p>Example data which consists of tracking points of the precession (22 kyr cycle) in the wavelet
scalogram of the IODP 926 grey scale (154-174m) record of Zeeden et al., (2013)
</p>


<h3>Details</h3>

<p>Column 1: Depth (meters)<br />
Column 2: period (meters)<br />
</p>


<h3>References</h3>

<p>Christian Zeeden, Frederik Hilgen, Thomas Westerhold, Lucas Lourens, Ursula Röhl, Torsten Bickert,
Revised Miocene splice, astronomical tuning and calcareous plankton biochronology of ODP Site 926 between 5 and 14.4Ma,
Palaeogeography, Palaeoclimatology, Palaeoecology,Volume 369,2013,Pages 430-451,ISSN 0031-0182,
&lt;doi:10.1016/j.palaeo.2012.11.009&gt;
</p>

<hr>
<h2 id='GTS_info'>Information of the Geological timescale 2020</h2><span id='topic+GTS_info'></span>

<h3>Description</h3>

<p>GTS_info data set consists the information of the Geological
timescale 2020 including the color data of Ogg et al., (2021)
The ages, durations, uncertainties and colors of the Geological
timescale 2020 are included in the data set
</p>


<h3>Details</h3>

<p>Column 1: name	<br />
Column 2: type	<br />
Column 1: top age<br />
Column 1: top error<br />
Column 1: bottom age<br />
Column 1: bottom error<br />
Column 1: Cyan value<br />
Column 1: Magenta value<br />
Column 1: Yellow value<br />
Column 1: Key  value<br />
Column 1: Red Value<br />
Column 1: Green value<br />
Column 1: Blue value	<br />
Column 1: font style	<br />
Column 1: font color<br />
</p>


<h3>References</h3>

<p>Ogg, Gabi &amp; Ogg, James &amp; Gradstein, Felix. (2021).
Recommended color coding of stages - Appendix 1
from Geologic Time Scale 2020.
</p>

<hr>
<h2 id='Hilbert_transform'>Perform a Hilbert transform on a signal</h2><span id='topic+Hilbert_transform'></span>

<h3>Description</h3>

<p>Extract the amplitude modulation using the Hilbert transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hilbert_transform(data = NULL, demean = TRUE, nr_pad = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hilbert_transform_+3A_data">data</code></td>
<td>
<p>Input is a time series with the first column being depth or time and the second column being a proxy.</p>
</td></tr>
<tr><td><code id="Hilbert_transform_+3A_demean">demean</code></td>
<td>
<p>Remove the mean from the time series.</p>
</td></tr>
<tr><td><code id="Hilbert_transform_+3A_nr_pad">nr_pad</code></td>
<td>
<p>nr of points added tot the top and bottom of the data set
to mitigate the edging effect of the Hilbert transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns.
The first column is depth/time.
The second column is the Hilbert transform of the signal.
</p>


<h3>Author(s)</h3>

<p>Based on the the <a href="DecomposeR.html#topic+inst.pulse">inst.pulse</a> function of the 'DecomposeR' R package.
</p>


<h3>References</h3>

<p>Wouters, S., Crucifix, M., Sinnesael, M., Da Silva, A.C., Zeeden, C., Zivanovic, M., Boulvain, F.,
Devleeschouwer, X., 2022, &quot;A decomposition approach to cyclostratigraphic signal processing&quot;.
Earth-Science Reviews 225 (103894). &lt;doi:10.1016/j.earscirev.2021.103894&gt;
</p>
<p>Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold, Xianyao Chen, and Karin Blank. 2009.
&quot;On Instantaneous Frequency&quot;. Advances in Adaptive Data Analysis 01 (02): 177–229. &lt;doi:10.1142/S1793536909000096&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example in which the Hilbert transform (eg. amplitude modulation) of the ~210yr
#de Vries cycle is extracted from the Total Solar Irradiance data set of
#Steinhilber et al., (2012)

#Perform the CWT
TSI_wt &lt;-
analyze_wavelet(
data = TSI,
dj = 1/200,
lowerPeriod = 16,
upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )

#Extract the 210 yr de Vries cycle from the wavelet spectra
de_Vries_cycle &lt;- extract_signal_stable(wavelet=TSI_wt,
cycle=210,
period_up =1.25,
period_down = 0.75,
add_mean=TRUE,
plot_residual=FALSE)

#Perform the Hilbert transform on the amplitude record of the 210 yr de Vries
# cycle which was extracted from the wavelet spectra

de_Vries_cycle_hilbert &lt;- Hilbert_transform(data=de_Vries_cycle,demean=TRUE)

</code></pre>

<hr>
<h2 id='lithlog_disc'>Discriticizes lithologs</h2><span id='topic+lithlog_disc'></span>

<h3>Description</h3>

<p>Discriticizes lithologs to allow further time-series analysis first the
Greatest common divisor/highest common factor is calculated which is then used to discriticize
the litholog to an evenly sampled data series. The function is designed to place the boundary
at the original depth level of the bed boundaries. The Greatest common divisor/highest common factor can
be a very small number as such the discriticized data set can be large which impacts computational
performance later on therefore a linear interpolation option is added to downscale the data to allow
for computational efficiency later on. This is made to discriticize lithologs created using the
'StratigrapheR' package. as such the same data format for input is used.
eg. column 1 is bottom of the bed, column 2 is top of bed, column is depth rank/proxy value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lithlog_disc(
  litholog = NULL,
  subset_fact = 10,
  lin_interp = FALSE,
  dt = NULL,
  genplot = FALSE,
  x_lab = "rank",
  y_lab = "depth (m)",
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lithlog_disc_+3A_litholog">litholog</code></td>
<td>
<p>litholog input matrix with 3 columns column 1 is bottom of the bed,
column 2 is top of bed, column is depth rank/proxy value</p>
</td></tr>
<tr><td><code id="lithlog_disc_+3A_subset_fact">subset_fact</code></td>
<td>
<p>subset factor which is x times the greatest common divider <code>Default=10</code>.</p>
</td></tr>
<tr><td><code id="lithlog_disc_+3A_lin_interp">lin_interp</code></td>
<td>
<p>Linear interpolation of the data set <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="lithlog_disc_+3A_dt">dt</code></td>
<td>
<p>step size  <code>Default=NULL</code>.</p>
</td></tr>
<tr><td><code id="lithlog_disc_+3A_genplot">genplot</code></td>
<td>
<p>generate plot  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="lithlog_disc_+3A_x_lab">x_lab</code></td>
<td>
<p>label for the y-axis <code>Default="rank"</code></p>
</td></tr>
<tr><td><code id="lithlog_disc_+3A_y_lab">y_lab</code></td>
<td>
<p>label for the y-axis <code>Default="depth (m)"</code></p>
</td></tr>
<tr><td><code id="lithlog_disc_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns, the first column is depth the second columns is the depth/rank proxy
If genplot is <code>Default=TRUE</code> then a plot of the discriticizes time series is plotted
</p>


<h3>References</h3>

<p>Wouters, S., Da Silva, A.-C., Boulvain, F., and Devleeschouwer, X.. 2021.
StratigrapheR: Concepts for Litholog Generation in R.
The R Journal. &lt;doi:10.32614/RJ-2021-039&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert depth rank record to a discrete proxy record to allow for further
# analysis in which discrete time series are needed
depth_rank_example_disc &lt;- lithlog_disc(litholog = depth_rank_example,
           subset_fact = 10,
           genplot = FALSE,
           x_lab = "rank",
           y_lab = "depth (m)",
           keep_editable=FALSE)


</code></pre>

<hr>
<h2 id='loess_auto'>Perform an automatically loess based smoothing of a time series</h2><span id='topic+loess_auto'></span>

<h3>Description</h3>

<p>Perform an automatically loess based smoothing of a time series.
The local polynomial regression with automatic smoothing parameter selection is based on an
optimization using the 'aicc' bias-corrected 'AIC' criterion and the 'gcv' generalized cross-validation criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loess_auto(
  time_series = NULL,
  genplot = FALSE,
  print_span = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loess_auto_+3A_time_series">time_series</code></td>
<td>
<p>Input is a time series with the first column being depth or time and the second column being a proxy</p>
</td></tr>
<tr><td><code id="loess_auto_+3A_genplot">genplot</code></td>
<td>
<p>Option to generate plot <code>Default=TRUE</code>. <br />
The plot will consist of the original signal in blue, the smoothed plot is displayed
in black and the + and - 1 sd bounds of the smoothing are displayed in red.</p>
</td></tr>
<tr><td><code id="loess_auto_+3A_print_span">print_span</code></td>
<td>
<p>Print span length as a fraction of the total length of the record.</p>
</td></tr>
<tr><td><code id="loess_auto_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 3 columns.
The first column is depth/time.
The second column is the smoothed curve.
The third column is difference between the original curve and the smoothed curve.
</p>


<h3>Author(s)</h3>

<p>Based on the the <code><a href="fANCOVA.html#topic+loess.as">loess.as</a></code> function of the 'fANCOVA' R package.
</p>


<h3>References</h3>

<p>Cleveland, W. S. (1979) Robust locally weighted regression and smoothing scatter plots. Journal of the American Statistical Association. 74, 829–836. &lt;doi:10.1080/01621459.1979.10481038&gt;
Hurvich, C.M., Simonoff, J.S., and Tsai, C.L. (1998), Smoothing Parameter Selection in Nonparametric Regression Using an Improved Akaike Information Criterion. Journal of the Royal Statistical Society B. 60, 271–293 &lt;doi:10.1111/1467-9868.00125&gt;
Golub, G., Heath, M. and Wahba, G. (1979). Generalized cross validation as a method for choosing a good ridge parameter. Technometrics. 21, 215–224. &lt;doi:10.2307/1268518&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#'smooth the period curve of the 405 kyr eccentricity cycle extracted from
# the magnetic susceptibility data set of Pas et al., (2018)
#perform the CWT on the magnetic susceptibility data set of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)")

#Instead of tracking, the tracked solution data set mag_track_solution is used
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = TRUE,
  genplot = FALSE,
  keep_editable=FALSE
)

#Smooth the completed tracking of the 405 kyr eccentricity cycle as tracked in the wavelet spectra
mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
genplot = FALSE, print_span = FALSE,keep_editable=FALSE)

</code></pre>

<hr>
<h2 id='mag'>Magnetic susceptibility data of the Sullivan core of Pas et al., (2018)</h2><span id='topic+mag'></span>

<h3>Description</h3>

<p>The magnetic susceptibility data set consists
of the magnetic susceptibility measurements of Pas et al., (2018), which measured the magnetic
susceptibility on the Sullivan core which is of Famennian age.
</p>


<h3>Details</h3>

<p>Column 1: depth value (meters depoth)<br />
Column 2: magnetic susceptibility  value<br />
</p>


<h3>References</h3>

<p>Damien Pas, Linda Hinnov, James E. (Jed) Day, Kenneth Kodama, Matthias Sinnesael, Wei Liu,
Cyclostratigraphic calibration of the Famennian stage (Late Devonian, Illinois Basin, USA),
Earth and Planetary Science Letters,
Volume 488,
2018,
Pages 102-114,
ISSN 0012-821X,
&lt;doi:1016/j.epsl.2018.02.010&gt;
</p>

<hr>
<h2 id='mag_track_solution'>Period of the 405 kyr ecc cycle in the magnetic susceptibility record of the Sullivan core</h2><span id='topic+mag_track_solution'></span>

<h3>Description</h3>

<p>Data points which give the period (in meters) of the 405 kyr eccentricity cycle tracked
in the wavelet scalogram of the magnetic susceptibility record of the Sullivan core <br />
The period was tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function<br />
The tracking is based on the original age model of Pas et al., (2018)<br />
</p>


<h3>Details</h3>

<p>Column 1: Depth (meters)<br />
Column 2: tracked period of 405 kyr eccentricity cycle (meters)<br />
</p>


<h3>References</h3>

<p>Damien Pas, Linda Hinnov, James E. (Jed) Day, Kenneth Kodama, Matthias Sinnesael, Wei Liu,
Cyclostratigraphic calibration of the Famennian stage (Late Devonian, Illinois Basin, USA),
Earth and Planetary Science Letters,
Volume 488,
2018,
Pages 102-114,
ISSN 0012-821X,
&lt;doi:10.1016/j.epsl.2018.02.010&gt;
</p>

<hr>
<h2 id='max_detect'>Detect and filter out all maxima in a signal</h2><span id='topic+max_detect'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+max_detect">max_detect</a></code> function is used
to detect and filter out local maxima in a sinusoidal signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_detect(data = NULL, pts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_detect_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with the first column being depth or time
and the second column being a proxy</p>
</td></tr>
<tr><td><code id="max_detect_+3A_pts">pts</code></td>
<td>
<p>The pts parameter specifies how many points to the left/right up/down the peak detect algorithm goes in detecting
a peak. The peak detecting algorithm works by comparing the values left/right up/down of it, if the values are both higher or lower
then the value a peak. To deal with error produced by this algorithm the pts parameter can be changed which can
aid in peak detection. Usually increasing the pts parameter means more peak certainty, however it also means that minor peaks might not be
picked up by the algorithm <code>Default=3</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>#Returns a matrix with 2 columns
first column is depth/time
the second column are local maxima values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example in which the ~210yr de Vries cycle is extracted from the Total Solar
#Irradiance data set of Steinhilber et al., (2012)
#after which all maxima are extracted

TSI_wt &lt;-
analyze_wavelet(
data = TSI,
dj = 1/200,
lowerPeriod = 16,
upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )

de_Vries_cycle &lt;- extract_signal_stable(wavelet=TSI_wt,
cycle=210,
period_up =1.25,
period_down = 0.75,
add_mean=TRUE,
plot_residual=FALSE)


min_de_Vries_cycle &lt;- min_detect(de_Vries_cycle)

</code></pre>

<hr>
<h2 id='min_detect'>Detect and filter out all minima in a signal</h2><span id='topic+min_detect'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+min_detect">min_detect</a></code> function is used to detect and
filter out local minima in a sinusoidal signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_detect(data = NULL, pts = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_detect_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with first column being depth or time and
the second column being a proxy</p>
</td></tr>
<tr><td><code id="min_detect_+3A_pts">pts</code></td>
<td>
<p>the pts parameter specifies how many points to the left/right up/down the peak detect algorithm goes in detecting
a peak. The peak detecting algorithm works by comparing the values left/right up/down of it, if the values are both higher or lower
then the value a peak. To deal with error produced by this algorithm the pts parameter can be changed which can
aid in peak detection. Usually increasing the pts parameter means more peak certainty, however it also means that minor peaks might not be
picked up by the algorithm <code>Default=3</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>#Returns a matrix with 2 columns
first column is depth/time
the second column are local minima values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example in which the ~210yr de Vries cycle is extracted from the Total Solar
#Irradiance data set of Steinhilber et al., (2012)
#after which all minima are extracted

TSI_wt &lt;-
analyze_wavelet(
data = TSI,
dj = 1/200,
lowerPeriod = 16,
upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )

de_Vries_cycle &lt;- extract_signal_stable(wavelet=TSI_wt,
cycle=210,
period_up =1.25,
period_down = 0.75,
add_mean=TRUE,
plot_residual=FALSE)


min_de_Vries_cycle &lt;- min_detect(de_Vries_cycle)

</code></pre>

<hr>
<h2 id='minimal_tuning'>Create an age model using minimal tuning</h2><span id='topic+minimal_tuning'></span>

<h3>Description</h3>

<p>Create an age model using the minimal tuning technique.
This means that the distance between 2 peaks of an extracted cycle are set
to duration of the interpreted astronomical cycle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal_tuning(
  data = NULL,
  pts = 5,
  cycle = 405,
  tune_opt = "max",
  output = 0,
  genplot = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimal_tuning_+3A_data">data</code></td>
<td>
<p>Input is an cycle extracted filtered in the depth domain</p>
</td></tr>
<tr><td><code id="minimal_tuning_+3A_pts">pts</code></td>
<td>
<p>The pts parameter specifies how many points to the left/right up/down the peak detect algorithm goes in detecting
a peak. The peak detecting algorithm works by comparing the values left/right up/down of it, if the values are both higher or lower
then the value a peak. To deal with error produced by this algorithm the pts parameter can be changed which can
aid in peak detection. Usually increasing the pts parameter means more peak certainty, however it also means that minor peaks might not be
picked up by the algorithm <code>Default=5</code></p>
</td></tr>
<tr><td><code id="minimal_tuning_+3A_cycle">cycle</code></td>
<td>
<p>duration in kyr of the filtered/extracted cycle</p>
</td></tr>
<tr><td><code id="minimal_tuning_+3A_tune_opt">tune_opt</code></td>
<td>
<p>tuning options &quot;min&quot;, &quot;max&quot; and &quot;minmax&quot; use minima, maxima or both
of the cyclic signal to create the age model <code>Default="max"</code></p>
</td></tr>
<tr><td><code id="minimal_tuning_+3A_output">output</code></td>
<td>
<p>#'The output depends on the output setting
If output = 0 output is a matrix of with 4 columns being; depth,proxy,sedimentation rate and time
If output = 1 output is a matrix of with 2 columns being; depth and sedimentation rate
#'If output = 2 output is a matrix of with 2 columns being; depth and time</p>
</td></tr>
<tr><td><code id="minimal_tuning_+3A_genplot">genplot</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="minimal_tuning_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output depends on the output setting
If output = 0 output is a matrix of with 4 columns being (depth,proxy,sedimentation rate and time)
If genplot = TRUE 4 plots are generated; depth vs proxy, depth vs sedimentation rate, depth vs time and time vs proxy
If output = 1 output is a matrix of with 2 columns being (depth and sedimentation rate )
If genplot = TRUE a plot of depth vs sedimentation rate is generated
If output = 2 output is a matrix of with 2 columns being (depth and time)
If genplot = TRUE a plot of depth vs time is generated
</p>


<h3>Author(s)</h3>

<p>Part of the code is based on the <a href="astrochron.html#topic+sedrate2time">sedrate2time</a>
function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Extract the 405kyr eccentricity cycle from the wavelet scalogram
# from the magnetic susceptibility record f the Sullivan core
# of Pas et al., (2018) and then create a age model using minimal tuning
# (e.g.) set the distance between peaks to 405 kyr

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)


mag_405 &lt;- extract_signal_stable_V2(
 wavelet = mag_wt,
 period_max = 4,
 period_min = 2,
 add_mean = FALSE,
 plot_residual = FALSE,
 keep_editable = FALSE
)

mag_405_min_tuning &lt;- minimal_tuning(data = mag_405,
pts = 5,
cycle = 405,
tune_opt = "max",
output = 0,
genplot = FALSE,
keep_editable = FALSE)




</code></pre>

<hr>
<h2 id='model_red_noise_wt'>Models average spectral power based curves based on a red-noise signal
generated using the characteristics of an input signal.</h2><span id='topic+model_red_noise_wt'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+model_red_noise_wt">model_red_noise_wt</a></code> function is used to generate
average spectral power curves based on and input signal and set wavelet settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_red_noise_wt(
  wavelet = NULL,
  n_simulations = NULL,
  run_multicore = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_red_noise_wt_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="model_red_noise_wt_+3A_n_simulations">n_simulations</code></td>
<td>
<p>Number of red noise simulations.</p>
</td></tr>
<tr><td><code id="model_red_noise_wt_+3A_run_multicore">run_multicore</code></td>
<td>
<p>run simulation using multiple cores <code>Default=FALSE</code>
the simulation is run at x-2 cores to allow the 2 remaining processes to run background processes.</p>
</td></tr>
<tr><td><code id="model_red_noise_wt_+3A_verbose">verbose</code></td>
<td>
<p>Print text <code>Default=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix in which each column represents the average spectral
power resulting from a red-noise run.
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+analyze.wavelet">analyze.wavelet</a> function of the 'WaveletComp' R package
and <a href="biwavelet.html#topic+wt">wt</a> function of the 'biwavelet' R package which are based on the
wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo (1998).
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#'#generate average spectral power curves based on red noise curves which are
# based on the magnetic susceptibility record of the Sullivan core of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#increase n_simulations to better define the red noise spectral power curve
mag_wt_red_noise &lt;- model_red_noise_wt(wavelet=mag_wt,
n_simulations=10, # increase number for better constrained results
run_multicore=FALSE,
verbose=FALSE)



</code></pre>

<hr>
<h2 id='percentile_from_red_noise'>Calculate average spectral power from red noise curves for a given percentile</h2><span id='topic+percentile_from_red_noise'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+percentile_from_red_noise">percentile_from_red_noise</a></code> function is
used to generate and average spectral power curve based on
a set percentile based. To generate the percentile curve the results of
the <code><a href="#topic+model_red_noise_wt">model_red_noise_wt</a></code> function are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentile_from_red_noise(red_noise = NULL, wavelet = NULL, percentile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentile_from_red_noise_+3A_red_noise">red_noise</code></td>
<td>
<p>Red noise curves generated using the <code><a href="#topic+model_red_noise_wt">model_red_noise_wt</a></code> function.</p>
</td></tr>
<tr><td><code id="percentile_from_red_noise_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="percentile_from_red_noise_+3A_percentile">percentile</code></td>
<td>
<p>Percentile value (0-1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns.<br />
The first column is the period (m). <br />
The second column is the spectral power at percentile x based on <br />
the red noise modelling runs. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#'#generate average spectral power curves based on red noise curves which are
# based on the magnetic susceptibility record of the Sullivan core of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#increase n_simulations to better define the red noise spectral power curve
mag_wt_red_noise &lt;- model_red_noise_wt(wavelet=mag_wt,
n_simulations=10, # Increase number for a better constrained result
run_multicore=FALSE,
verbose=FALSE)


prob_curve &lt;- percentile_from_red_noise(
red_noise = mag_wt_red_noise,
wavelet = mag_wt,
percentile = 0.9)



</code></pre>

<hr>
<h2 id='plot_astro_anchor'>Plot proxy record anchored to an astronomical solution</h2><span id='topic+plot_astro_anchor'></span>

<h3>Description</h3>

<p>Plot the results of the anchoring  the extracted signal to an astronomical solution using
which was conducted using the <code><a href="#topic+astro_anchor">astro_anchor</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_astro_anchor(
  astro_solution = NULL,
  proxy_signal = NULL,
  anchor_points = NULL,
  time_dir = TRUE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_astro_anchor_+3A_astro_solution">astro_solution</code></td>
<td>
<p>Input is an astronomical solution with with the the proxy record was be anchored to,
the input should be a matrix or data frame with the first column being
age and the second column should be a insolation/angle/value</p>
</td></tr>
<tr><td><code id="plot_astro_anchor_+3A_proxy_signal">proxy_signal</code></td>
<td>
<p>Input is the proxy data set which will which was
anchored to an astronomical solution, the input should be a matrix or
data frame with the first column being  depth/time and the second column should be a proxy value.</p>
</td></tr>
<tr><td><code id="plot_astro_anchor_+3A_anchor_points">anchor_points</code></td>
<td>
<p>Anchor points generated using the <code><a href="#topic+astro_anchor">astro_anchor</a></code> function</p>
</td></tr>
<tr><td><code id="plot_astro_anchor_+3A_time_dir">time_dir</code></td>
<td>
<p>The direction of the proxy record which was assumed during anchoring if time increases with increasing depth/time values
(e.g. bore hole data which gets older with increasing depth ) then time_dir should be set to TRUE
if time decreases with depth/time values (eg stratospheric logs where 0m is the bottom of the section)
then time_dir should be set to FALSE <code>time_dir=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_astro_anchor_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a set of 2 plots connected by lines
The top plot is the proxy record with anchor points on top of it
The bottom plot is the astronomical solution
The lines connect the anchor points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use the grey_track example tracking points to anchor the grey scale data set
# of Zeeden et al., (2013) to the p-0.5t la2004 solution

grey_wt &lt;-
 analyze_wavelet(
   data = grey,
   dj = 1/200,
   lowerPeriod = 0.02,
   upperPeriod = 256,
   verbose = FALSE,
   omega_nr = 8
 )

#Use the pretracked grey_track curve which traced the precession cycle
grey_track &lt;- completed_series(
 wavelet = grey_wt,
 tracked_curve  = grey_track,
 period_up  = 1.25,
 period_down  = 0.75,
 extrapolate = TRUE,
genplot = FALSE
)
# Extract precession, obliquity and eccentricity to create a synthetic insolation curve

grey_prec &lt;- extract_signal(
tracked_cycle_curve = grey_track[,c(1,2)],
wavelet = grey_wt,
period_up = 1.2,
period_down = 0.8,
add_mean = FALSE,
tracked_cycle_period = 22,
extract_cycle = 22,
tune = FALSE,
plot_residual = FALSE
)

grey_obl &lt;- extract_signal(
 tracked_cycle_curve = grey_track[,c(1,2)],
 wavelet = grey_wt,
 period_up = 1.2,
 period_down = 0.8,
 add_mean = FALSE,
 tracked_cycle_period = 22,
 extract_cycle = 110,
 tune = FALSE,
 plot_residual = FALSE
)

grey_ecc &lt;- extract_signal(
 tracked_cycle_curve = grey_track[,c(1,2)],
 wavelet = grey_wt,
 period_up = 1.25,
 period_down = 0.75,
 add_mean = FALSE,
 tracked_cycle_period = 22,
 extract_cycle = 40.8,
 tune = FALSE,
 plot_residual = FALSE
)

insolation_extract &lt;- cbind(grey_ecc[,1],grey_prec[,2]+grey_obl[,2]+grey_ecc[,2]+mean(grey[,2]))
insolation_extract &lt;- as.data.frame(insolation_extract)
insolation_extract_mins &lt;- min_detect(insolation_extract,pts=3)

#use the astrosignal_example to tune to which is an \cr
# ETP solution (p-0.5t la2004 solution).

astrosignal_example &lt;- na.omit(astrosignal_example)
astrosignal_example[,2] &lt;- -1*astrosignal_example[,2]
astrosignal &lt;- as.data.frame(astrosignal_example)

#anchor the synthetic insolation curve extracted from the
# grey scale record to the insolation curve.
#use the anchor_points_grey data set to plot the
#result of using the astro_anchor function

#anchor_points_grey &lt;- astro_anchor(
#astro_solution = astrosignal,
#proxy_signal = insolation_extract,
#proxy_min_or_max = "min",
#clip_astrosolution = FALSE,
#astrosolution_min_or_max = "min",
#clip_high = NULL,
#clip_low = NULL,
#extract_astrosolution  = FALSE,
#astro_period_up  = NULL,
#astro_period_down  = NULL,
#astro_period_cycle  = NULL,
#extract_proxy_signal  = FALSE,
#proxy_period_up  = NULL,
#proxy_period_down  = NULL,
#proxy_period_cycle  = NULL,
#pts=3,
#verbose=FALSE,
#genplot=FALSE # set verbose to TRUE to allow for anchoring using text feedback commands
#)


plot_astro_anchor(astro_solution = astrosignal,
proxy_signal = insolation_extract,
anchor_points = anchor_points_grey,
time_dir = FALSE,
keep_editable = FALSE)



</code></pre>

<hr>
<h2 id='plot_avg_wavelet'>Plot the average spectral power of a wavelet spectra</h2><span id='topic+plot_avg_wavelet'></span>

<h3>Description</h3>

<p>Plot the average spectral power of a wavelet spectra using the results of
the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_avg_wavelet(
  wavelet = NULL,
  y_lab = "Power",
  x_lab = "period (metres)",
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_avg_wavelet_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_avg_wavelet_+3A_y_lab">y_lab</code></td>
<td>
<p>Label for the y-axis <code>Default="Power"</code>.</p>
</td></tr>
<tr><td><code id="plot_avg_wavelet_+3A_x_lab">x_lab</code></td>
<td>
<p>Label for the x-axis <code>Default="depth (metres)"</code>.</p>
</td></tr>
<tr><td><code id="plot_avg_wavelet_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a plot of the average spectral power of a wavelet spectra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example 1. Plot the average spectral power of the wavelet spectra of
# the Total Solar Irradiance data set of Steinhilber et al., (2012)
TSI_wt &lt;-
 analyze_wavelet(
   data = TSI,
   dj = 1/200,
   lowerPeriod = 16,
   upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )

plot_avg_wavelet(wavelet=TSI_wt,
                 y_lab= "power",
                 x_lab="period (years)",
                 keep_editable=FALSE)


#Example 2. Plot the average spectral power of the wavelet spectra of \cr
# the magnetic susceptibility data set of Pas et al., (2018)
mag_wt &lt;-
analyze_wavelet(
data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10
)
plot_avg_wavelet(wavelet=mag_wt,
                 y_lab= "power",
                 x_lab="period (metres)",
                 keep_editable=FALSE)



#Example 3. Plot the average spectral power of the wavelet spectra of
#the greyscale data set of Zeeden et al., (2013)
grey_wt &lt;-
 analyze_wavelet(
   data = grey,
   dj = 1/200,
   lowerPeriod = 0.02,
   upperPeriod = 256,
   verbose = FALSE,
   omega_nr = 8
 )

plot_avg_wavelet(wavelet=grey_wt,
                 y_lab= "power",
                 x_lab="period (metres)",
                 keep_editable=FALSE)


</code></pre>

<hr>
<h2 id='plot_sed_model'>Plot sedimentation modelling results</h2><span id='topic+plot_sed_model'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+plot_sed_model">plot_sed_model</a></code> function is used plot/re-plot the results from the
<code><a href="#topic+flmw">flmw</a></code> and  <code><a href="#topic+sum_power_sedrate">sum_power_sedrate</a></code> functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sed_model(
  model_results = NULL,
  plot_res = 1,
  x_lab = "depth (m)",
  y_lab = "sed rate cm/kyr",
  keep_editable = FALSE,
  palette_name = "rainbow",
  color_brewer = "grDevices"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sed_model_+3A_model_results">model_results</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function</p>
</td></tr>
<tr><td><code id="plot_sed_model_+3A_plot_res">plot_res</code></td>
<td>
<p>Numbers to be used as input form the <code><a href="#topic+flmw">flmw</a></code>output
options 1-8 option 1: slope coefficient, option 2: r squared,
option 3: nr of components, option 4: difference to origin, option 5: slope coefficient percentile
option 6: r squared percentile, option 7: nr of components percentile,
option 8: difference to origin percentile. If the output of the  <code><a href="#topic+sum_power_sedrate">sum_power_sedrate</a></code> function is used
then input should be option 1: sum max power option 2: nr of components</p>
</td></tr>
<tr><td><code id="plot_sed_model_+3A_x_lab">x_lab</code></td>
<td>
<p>Label for x-axis <code>Default="depth (m)"</code></p>
</td></tr>
<tr><td><code id="plot_sed_model_+3A_y_lab">y_lab</code></td>
<td>
<p>Label for y-axis <code>Default=""sed rate cm/kyr""</code></p>
</td></tr>
<tr><td><code id="plot_sed_model_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="plot_sed_model_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="plot_sed_model_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of sedimentation rates vs depth and a value which was generated using
the <code><a href="#topic+flmw">flmw</a></code> or <code><a href="#topic+sum_power_sedrate">sum_power_sedrate</a></code> functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#estimate sedimentation rate for the the magnetic susceptibility record
# of the Sullivan core of Pas et al., (2018).

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#increase n_simulations to better define the red noise spectral power curve
mag_wt_red_noise &lt;- model_red_noise_wt(wavelet=mag_wt,
n_simulations=10, # increase for a better constrained result
run_multicore=FALSE,
verbose=FALSE)

sedrates &lt;- sum_power_sedrate(red_noise=mag_wt_red_noise,
wavelet=mag_wt,
percentile=0.75,
sedrate_low = 0.5,
sedrate_high = 4,
spacing = 0.05,
cycles = c(2376,1600,1180,696,406,110),
x_lab="depth",
y_lab="sedrate",
run_multicore=FALSE,
genplot = FALSE,
palette_name = "rainbow",
color_brewer= "grDevices",
verbose=FALSE)

plot_sed_model(model_results=sedrates,
plot_res=1,
x_lab = "depth (m)",
y_lab = "sed rate cm/kyr",
keep_editable=FALSE,
palette_name = "rainbow",
color_brewer= "grDevices")



</code></pre>

<hr>
<h2 id='plot_wavelet'>Plots a wavelet power spectra</h2><span id='topic+plot_wavelet'></span>

<h3>Description</h3>

<p>Plot wavelet spectra using the outcome of the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_wavelet(
  wavelet = NULL,
  lowerPeriod = NULL,
  upperPeriod = NULL,
  plot.COI = TRUE,
  n.levels = 100,
  palette_name = "rainbow",
  color_brewer = "grDevices",
  useRaster = TRUE,
  periodlab = "Period (metres)",
  x_lab = "depth (metres)",
  keep_editable = FALSE,
  dev_new = TRUE,
  plot_dir = TRUE,
  add_lines = NULL,
  add_points = NULL,
  add_abline_h = NULL,
  add_abline_v = NULL,
  add_MTM_peaks = FALSE,
  add_data = TRUE,
  add_avg = FALSE,
  add_MTM = FALSE,
  siglvl = 0.95,
  demean_mtm = TRUE,
  detrend_mtm = TRUE,
  padfac_mtm = 5,
  tbw_mtm = 3,
  plot_horizontal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_wavelet_+3A_wavelet">wavelet</code></td>
<td>
<p>wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_lowerperiod">lowerPeriod</code></td>
<td>
<p>Lowest period value which will be plotted</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_upperperiod">upperPeriod</code></td>
<td>
<p>Highest period value which will be plotted</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_plot.coi">plot.COI</code></td>
<td>
<p>Option to plot the cone of influence <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of color levels <code>Default=100</code>.</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_useraster">useRaster</code></td>
<td>
<p>Plot as a raster or vector image <code>Default=TRUE</code>.
WARNING plotting as a vector image is computationally intensive.</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_periodlab">periodlab</code></td>
<td>
<p>Label for the y-axis <code>Default="Period (metres)"</code>.</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_x_lab">x_lab</code></td>
<td>
<p>Label for the x-axis <code>Default="depth (metres)"</code>.</p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_dev_new">dev_new</code></td>
<td>
<p>Opens a new plotting window to plot the plot, this guarantees a &quot;nice&quot; looking plot however when plotting in an R markdown
document the plot might not plot  <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_plot_dir">plot_dir</code></td>
<td>
<p>The direction of the proxy record which is assumed for tuning if time increases with increasing depth/time values
(e.g. bore hole data which gets older with increasing depth ) then plot_dir should be set to TRUE
if time decreases with depth/time values (eg stratospheric logs where 0m is the bottom of the section)
then plot_dir should be set to FALSE <code>plot_dir=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_lines">add_lines</code></td>
<td>
<p>Add  lines to the wavelet plot input should be matrix with first axis being depth/time the columns after that
should be period values  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_points">add_points</code></td>
<td>
<p>Add points to the wavelet plot input should be matrix with first axis being depth/time and columns after that
should be period values <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_abline_h">add_abline_h</code></td>
<td>
<p>Add horizontal lines to the plot. Specify the lines as a vector e.g. c(2,3,5,6)  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_abline_v">add_abline_v</code></td>
<td>
<p>Add vertical lines to the plot. Specify the lines as a vector e.g. c(2,3,5,6)  <code>Default=NULL</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_mtm_peaks">add_MTM_peaks</code></td>
<td>
<p>Add the MTM peak periods as horizontal lines <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_data">add_data</code></td>
<td>
<p>Plot the data on top of the wavelet <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_avg">add_avg</code></td>
<td>
<p>Plot the average wavelet spectral power to the side of the wavelet <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_add_mtm">add_MTM</code></td>
<td>
<p>Add the MTM  plot next to the wavelet plot <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_siglvl">siglvl</code></td>
<td>
<p>Set the significance level for the MTM analysis (0-1) <code>Default=0.95</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_demean_mtm">demean_mtm</code></td>
<td>
<p>Remove mean from data before conducting the MTM analysis <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_detrend_mtm">detrend_mtm</code></td>
<td>
<p>Remove mean from data before conducting the MTM analysis <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_padfac_mtm">padfac_mtm</code></td>
<td>
<p>Pad factor for the MTM analysis <code>Default=5</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_tbw_mtm">tbw_mtm</code></td>
<td>
<p>time bandwidth product of the MTM analysis  <code>Default=3</code></p>
</td></tr>
<tr><td><code id="plot_wavelet_+3A_plot_horizontal">plot_horizontal</code></td>
<td>
<p>plot the wavelet horizontal or vertical eg y axis is depth or y axis power <code>Default=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a plot of a wavelet spectra.
if add_MTM_peaks = TRUE then the output of the MTM analysis will given as matrix
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+analyze.wavelet">analyze.wavelet</a> and <a href="WaveletComp.html#topic+wt.image">wt.image</a> functions of the 'WaveletComp' R package
and <a href="biwavelet.html#topic+wt">wt</a> function of the 'biwavelet' R package which are based on the
wavelet MATLAB code written by Christopher Torrence and Gibert P. Compo (1998).
The MTM analysis is from the astrochron R package of Meyers et al., (2012)
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>
<p>S.R. Meyers, 2012, Seeing Red in Cyclic Stratigraphy: Spectral Noise Estimation for
Astrochronology: Paleoceanography, 27, PA3228, &lt;doi:10.1029/2012PA002307&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example 1. A plot of a wavelet spectra using the Total Solar Irradiance
# data set of Steinhilber et al., (2012)

TSI_wt &lt;-
 analyze_wavelet(
   data = TSI,
   dj = 1/200,
   lowerPeriod = 16,
   upperPeriod = 8192,
   verbose = FALSE,
   omega_nr = 6
 )

plot_wavelet(
 wavelet = TSI_wt,
 lowerPeriod = NULL,
 upperPeriod = NULL,
 plot.COI = TRUE,
 n.levels = 100,
 palette_name = "rainbow",
color_brewer= "grDevices",
 useRaster = TRUE,
 periodlab = "Period (metres)",
 x_lab = "depth (metres)",
 keep_editable = FALSE,
 dev_new=TRUE,
 plot_dir = TRUE,
 add_lines = NULL,
 add_points= NULL,
 add_abline_h = NULL,
 add_abline_v = NULL,
 add_MTM_peaks = FALSE,
 add_data = TRUE,
 add_avg = TRUE,
 add_MTM = FALSE,
 siglvl = 0.95,
 demean_mtm = TRUE,
 detrend_mtm = TRUE,
 padfac_mtm = 5,
 tbw_mtm = 3,
 plot_horizontal=TRUE)

#Example 2. A plot of a wavelet spectra using the magnetic susceptibility
#data set of Pas et al., (2018)
mag_wt &lt;-
analyze_wavelet(
data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10
)

plot_wavelet(
wavelet = mag_wt,
lowerPeriod = NULL,
upperPeriod = NULL,
plot.COI = TRUE,
n.levels = 100,
palette_name = "rainbow",
color_brewer= "grDevices",
useRaster = TRUE,
periodlab = "Period (metres)",
x_lab = "depth (metres)",
keep_editable = FALSE,
dev_new=TRUE,
plot_dir = TRUE,
add_lines= NULL,
add_points= NULL,
add_abline_h = NULL,
add_abline_v = NULL,
add_MTM_peaks = FALSE,
add_data = TRUE,
add_avg = TRUE,
add_MTM = FALSE,
siglvl = 0.95,
demean_mtm = TRUE,
detrend_mtm = TRUE,
padfac_mtm = 5,
tbw_mtm = 3,
plot_horizontal=TRUE)


#Example 3. A plot of a wavelet spectra using the greyscale
# data set of Zeeden et al., (2013)
grey_wt &lt;-
 analyze_wavelet(
   data = grey,
   dj = 1/200,
   lowerPeriod = 0.02,
   upperPeriod = 256,
   verbose = FALSE,
   omega_nr = 8
 )

plot_wavelet(
wavelet = grey_wt,
lowerPeriod = NULL,
upperPeriod = NULL,
plot.COI = TRUE,
n.levels = 100,
palette_name = "rainbow",
color_brewer= "grDevices",
useRaster = TRUE,
periodlab = "Period (metres)",
x_lab = "depth (metres)",
keep_editable = FALSE,
dev_new=TRUE,
plot_dir = TRUE,
add_lines = NULL,
add_points= NULL,
add_abline_h = NULL,
add_abline_v = NULL,
add_MTM_peaks = FALSE,
add_data = TRUE,
add_avg = TRUE,
add_MTM = FALSE,
siglvl = 0.95,
demean_mtm = TRUE,
detrend_mtm = TRUE,
padfac_mtm = 5,
tbw_mtm = 3,
plot_horizontal=TRUE)



</code></pre>

<hr>
<h2 id='plot_win_fft'>Plot windowed fft based spectral analysis results</h2><span id='topic+plot_win_fft'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+plot_win_fft">plot_win_fft</a></code> function allows for the (re)plotting of the results of the <code><a href="#topic+win_fft">win_fft</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_win_fft(
  win_fft = NULL,
  x_lab = c("depth (m)"),
  y_lab = c("frequency cycle/metre"),
  plot_res = 1,
  perc_vis = 0,
  freq_max = NULL,
  freq_min = NULL,
  keep_editable = FALSE,
  palette_name = "rainbow",
  color_brewer = "grDevices",
  plot_horizontal = TRUE,
  dev_new = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_win_fft_+3A_win_fft">win_fft</code></td>
<td>
<p>list which is the results of the <code><a href="#topic+win_fft">win_fft</a></code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_x_lab">x_lab</code></td>
<td>
<p>label for the y-axis <code>Default="depth"</code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_y_lab">y_lab</code></td>
<td>
<p>label for the y-axis <code>Default="sedrate"</code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_plot_res">plot_res</code></td>
<td>
<p>plot 1 of 8 options option 1: Amplitude matrix,
option 2: Power matrix,
option 3: Phase matrix,
option 4: AR1_CL matrix,
option 5: AR1_Fit matrix ,
option 6: AR1_90_power matrix,
option 7: AR1_95_power matrix,
option 8: AR1_99_power matrix, <code>Default=1</code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_perc_vis">perc_vis</code></td>
<td>
<p>Cutoff percentile when plotting <code>Default=0</code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_freq_max">freq_max</code></td>
<td>
<p>Maximum frequency to plot</p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_freq_min">freq_min</code></td>
<td>
<p>Minimum frequency to plot</p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_plot_horizontal">plot_horizontal</code></td>
<td>
<p>plot the wavelet horizontal or vertical eg y axis is depth or y axis power  <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_win_fft_+3A_dev_new">dev_new</code></td>
<td>
<p>Opens a new plotting window to plot the plot, this guarantees  a &quot;nice&quot; looking plot however when plotting in an R markdown
document the plot might not plot  <code>Default=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of, which plot 1 of 8 options,
option 1: Amplitude matrix
option 2: Power matrix
option 3: Phase matrix
option 4: AR1_CL matrix
option 5: AR1_Fit matrix
option 6: AR1_90_power matrix
option 7: AR1_95_power matrix
option 8: AR1_99_power matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Conduct a windowed fft on the magnetic susceptibility record \cr
# of the Sullivan core of Pas et al., (2018).

mag_win_fft &lt;- win_fft(data= mag,
                   padfac = 5,
                   window_size = 12.5,
                   run_multicore = FALSE,
                   genplot = FALSE,
                   palette_name = "rainbow",
                   color_brewer="grDevices",
                   x_lab = c("depth (m)"),
                   y_lab = c("frequency cycle/meter"),
                   plot_res = 1,
                   perc_vis = 0.5,
                   freq_max = 5,
                   freq_min = 0.001,
                   keep_editable=FALSE,
                   verbose=FALSE)

# Plot the amplitude spectra
plot_win_fft(win_fft= mag_win_fft,
x_lab = c("depth (m)"),
y_lab = c("frequency cycle/meter"),
plot_res = 1,
perc_vis = 0.5,
freq_max = 5,
freq_min = 0.001,
keep_editable=FALSE,
palette_name = "rainbow",
color_brewer="grDevices",
plot_horizontal=TRUE,
dev_new=TRUE)



</code></pre>

<hr>
<h2 id='retrack_wt_MC'>Re-track cycles using a Monte-Carlo simulation</h2><span id='topic+retrack_wt_MC'></span>

<h3>Description</h3>

<p>When analyzing multi-proxy records an age-model can be created
for each proxy. These age-models can be in general agreement but might also
indicate conflicting deposition rates. Picking one age-model out of the all
multi-proxy age-models and stating that, that age-model is the best overlooks
the information contained within the other proxies and hence a degree of error
remains the age-model exists.To combine the multiple age-models all the age
models can be averaged out and the uncertainty can be calculated by means
of the standard deviation. The result is an age-model which takes into
account all the age-models from the proxy records. The averaged out age-model
does not take into account any small user errors during  the creation of the
individual age-models nor does the averaging take into account the differences
between the age-models and how the initial age-model of a certain proxy might
be off in certain intervals. the link[WaverideR]retrack_wt_MC mitigates
these problems by re-tracking periods of astronomical cycles in the wavelet
spectra. The re-tracking is based on the information provided by the
age-models constructed from the different proxy records.
First a synthetic tracked curve is created by adding up fractions (0-1) of
the tracked periods of the different proxy records. This synthetic curve is
then used to re-track the period/spectral peaks of an astronomical cycle
in a randomly select wavelet scalogram. This process is repeated x times.
The result x tracked curves which take into account all the original
age-models. From the re-tracked curves one can calculate the mean period and
the standard deviation. The resulting  standard deviation is a good
indicator of the quality of the imprint of of astronomical cycles in the
proxy records. A small standard deviation indicates that given the input
of the different tracked cycles similar periods keep on being tracked
indicating the an astronomical is well recorded in the proxy records and as
such the age-model is very reliable in set interval. A high standard
deviation on the other hand means that the tracking results in vastly
different periods of the tracked astronomical cycle, as such the quality of
the imprint of the astronomical cycle proxy records is poor and hence the
age-model is less-reliable in this interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrack_wt_MC(
  wt_list = NULL,
  data_track = NULL,
  x_axis = NULL,
  nr_simulations = 50,
  seed_nr = 1337,
  verbose = FALSE,
  genplot = FALSE,
  keep_editable = FALSE,
  create_GIF = FALSE,
  plot_GIF = FALSE,
  width_plt = 600,
  height_plt = 450,
  period_up = 1.5,
  period_down = 0.5,
  plot.COI = TRUE,
  n.levels = 100,
  palette_name = "rainbow",
  color_brewer = "grDevices",
  periodlab = "Period (metres)",
  x_lab = "depth (metres)",
  add_avg = FALSE,
  time_dir = TRUE,
  file_name = NULL,
  run_multicore = FALSE,
  output = 1,
  n_imgs = 50,
  plot_horizontal = TRUE,
  empty_folder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrack_wt_MC_+3A_wt_list">wt_list</code></td>
<td>
<p>a list containing all the wavelet objects created using the
link[WaverideR]analyze_wavelet wavelet function
To create a list use the link[base]list function</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_data_track">data_track</code></td>
<td>
<p>a matrix containing all the tracked period values.
To create the matrix use the link[base]cbind function and only add the
tracked period values so do not add the depth axis. When combining the
tracked period values make sure that all curves have a similar depth
spacing.</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_x_axis">x_axis</code></td>
<td>
<p>The x-axis of the tracked period values</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_nr_simulations">nr_simulations</code></td>
<td>
<p>The number of Monte-Carlo simulations which are to be
conducted<code>Default=50</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_seed_nr">seed_nr</code></td>
<td>
<p>The seed number of the Monte-Carlo simulations.
<code>Default=1337</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_verbose">verbose</code></td>
<td>
<p>Print text when running the function  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_genplot">genplot</code></td>
<td>
<p>Plot a plot with the mean period and + and - standard
deviation <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting
<code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_create_gif">create_GIF</code></td>
<td>
<p>Create a GIF with the re-tracked lines in the wavelet
scalograms <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_plot_gif">plot_GIF</code></td>
<td>
<p>Plot a GIF with the re-tracked lines in the wavelet
scalograms<code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_width_plt">width_plt</code></td>
<td>
<p>width of the re-tracked plot <code>Default=600</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_height_plt">height_plt</code></td>
<td>
<p>width of the re-tracked plot <code>Default=450</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_period_up">period_up</code></td>
<td>
<p>The period_up parameter is the factor with which the linear interpolated tracked_curve
curve is multiplied by. This linear interpolated tracked_curve multiplied by the period_up factor is
the upper boundary which is used  for detecting the spectral peak nearest to the linear interpolated tracked_curve
curve. If no spectral peak is detected within the specified boundary the interpolated
value is used instead. between spectral peaks <code>Default=1.5</code>,</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_period_down">period_down</code></td>
<td>
<p>The period_down parameter is the factor with which the linear interpolated tracked_curve
curve is multiplied by. This linear interpolated tracked_curve multiplied by the period_down factor is
the lower boundary which is used  for detecting the spectral peak nearest to the linear interpolated tracked_curve
curve. If no spectral peak is detected within the specified boundary the interpolated
value is used instead. between spectral peaks <code>Default=0.5</code>,</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_plot.coi">plot.COI</code></td>
<td>
<p>Option to plot the cone of influence <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of color levels <code>Default=100</code>.</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_periodlab">periodlab</code></td>
<td>
<p>Label for the y-axis <code>Default="Period (metres)"</code>.</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_x_lab">x_lab</code></td>
<td>
<p>Label for the x-axis <code>Default="depth (metres)"</code>.</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_add_avg">add_avg</code></td>
<td>
<p>Plot the average wavelet spectral power to the side of the wavelet <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_time_dir">time_dir</code></td>
<td>
<p>The direction of the proxy record which is assumed for tuning if time increases with increasing depth/time values
(e.g. bore hole data which gets older with increasing depth ) then time_dir should be set to TRUE
if time decreases with depth/time values (eg stratospheric logs where 0m is the bottom of the section)
then time_dir should be set to FALSE <code>time_dir=TRUE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_file_name">file_name</code></td>
<td>
<p>Name of the images created using this function. Each file
gets a number added to it which corresponds to which number of simulation it was
the files are saved in a folder with a similar name created in the current
directory</p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_run_multicore">run_multicore</code></td>
<td>
<p>Run function using multiple cores <code>Default="FALSE"</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_output">output</code></td>
<td>
<p>#'If output = 1, output is a list which contain 3 objects.
object 1 is a matrix with the x-axis and the mean tracked frequency and
standard deviation. #'object 2 is a matrix with all the tracked periods.
Object 3 is a GIF in which #'all the tracked periods are plotted.
If output = 2, output is a list which contain 2 objects. object 1 is a matrix
with the x-axis and the mean tracked frequency and standard deviation.
object 2 is a matrix with all the tracked periods.
If output = 3, output is a list which contain 2 objects. object 1 is a matrix
with the x-axis and the mean tracked frequency and standard deviation.
Object 2 is a GIF in which
all the tracked periods are plotted.
If output = 4, output is a list which contain 3 objects. Object 1 is a matrix
with all the tracked periods. Object 2 is a GIF in which  all the tracked
periods are plotted.
If output = 4 output is a list which contain 3 objects. Object 1 is a matrix
with all the tracked periods. Object 2 is a GIF in which  all the tracked
periods are plotted.
If output = 5 a matrix with the x-axis and the mean tracked frequency and
standard deviation is returned.
If output = 6, a matrix with all the tracked periods is returned.
If output = 7, a GIF in which all the tracked periods are plotted is returned.
<code>Default=1</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_n_imgs">n_imgs</code></td>
<td>
<p>Number images used in creating the GIF a high number of images
is computationally intensive and will create a large sized GIF <code>Default=50</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_plot_horizontal">plot_horizontal</code></td>
<td>
<p>plot the wavelet horizontal or vertical eg y axis
is depth or y axis power <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="retrack_wt_MC_+3A_empty_folder">empty_folder</code></td>
<td>
<p>Empty the folder in which the images created using
this function are saved <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output depends on the output setting
If genplot = TRUE a plot will be generated in which the mean period and
standard deviation is plotted
if plot_GIF = TRUE a GIF with n number of n_imgs will be plotted in which the
retraced curve is plotted in a wavelet scalogram
If output = 1, output is a list which contain 3 objects. object 1 is a matrix
with the x-axis and the mean tracked frequency and standard deviation.
object 2 is a matrix with all the tracked periods. Object 3 is a GIF in which
all the tracked periods are plotted.
If output = 2, output is a list which contain 2 objects. object 1 is a matrix
with the x-axis and the mean tracked frequency and standard deviation.
object 2 is a matrix with all the tracked periods.
If output = 3, output is a list which contain 2 objects. object 1 is a matrix
with the x-axis and the mean tracked frequency and standard deviation.
Object 2 is a GIF in which
all the tracked periods are plotted.
If output = 4, output is a list which contain 3 objects. Object 1 is a matrix
with all the tracked periods. Object 2 is a GIF in which  all the tracked
periods are plotted.
If output = 4 output is a list which contain 3 objects. Object 1 is a matrix
with all the tracked periods. Object 2 is a GIF in which  all the tracked
periods are plotted.
If output = 5 a matrix with the x-axis and the mean tracked period and
standard deviation is returned.
If output = 6, a matrix with all the tracked periods is returned.
If output = 7, a GIF in which all the tracked periods are plotted is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Re-track the 110kyr eccentricity cycle in the wavelet scalogram
# from the XRF record of the Bisciaro data set of Arts (2014)

Bisciaro_al &lt;- Bisciaro_XRF[, c(1, 61)]
Bisciaro_al &lt;- astrochron::sortNave(Bisciaro_al,verbose=FALSE,genplot=FALSE)
Bisciaro_al &lt;- astrochron::linterp(Bisciaro_al, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_al &lt;- Bisciaro_al[Bisciaro_al[, 1] &gt; 2, ]

Bisciaro_al_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_al,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_al_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_al_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
# Bisciaro_al_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_al_wt,
#   tracked_curve = Bisciaro_al_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_al_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_al_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )

Bisciaro_ca &lt;- Bisciaro_XRF[, c(1, 55)]
Bisciaro_ca &lt;- astrochron::sortNave(Bisciaro_ca,verbose=FALSE,genplot=FALSE)
Bisciaro_ca &lt;- astrochron::linterp(Bisciaro_ca, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_ca &lt;- Bisciaro_ca[Bisciaro_ca[, 1] &gt; 2, ]

Bisciaro_ca_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_ca,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_ca_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_ca_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
# Bisciaro_ca_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_ca_wt,
#   tracked_curve = Bisciaro_ca_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_ca_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_ca_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE)

Bisciaro_sial &lt;- Bisciaro_XRF[,c(1,64)]
Bisciaro_sial &lt;- astrochron::sortNave(Bisciaro_sial,verbose=FALSE,genplot=FALSE)
Bisciaro_sial &lt;- astrochron::linterp(Bisciaro_sial, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_sial &lt;- Bisciaro_sial[Bisciaro_sial[, 1] &gt; 2, ]

Bisciaro_sial_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_sial,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_sial_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_sial_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_sial_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_sial_wt,
#   tracked_curve = Bisciaro_sial_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_sial_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_sial_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )


Bisciaro_Mn &lt;- Bisciaro_XRF[,c(1,46)]
Bisciaro_Mn &lt;- astrochron::sortNave(Bisciaro_Mn,verbose=FALSE,genplot=FALSE)
Bisciaro_Mn &lt;- astrochron::linterp(Bisciaro_Mn, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_Mn &lt;- Bisciaro_Mn[Bisciaro_Mn[, 1] &gt; 2, ]

Bisciaro_Mn_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_Mn,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_Mn_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_Mn_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_Mn_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_Mn_wt,
#   tracked_curve = Bisciaro_Mn_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
# Bisciaro_Mn_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_Mn_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE
#   )

Bisciaro_Mg &lt;- Bisciaro_XRF[,c(1,71)]
Bisciaro_Mg &lt;- astrochron::sortNave(Bisciaro_Mg,verbose=FALSE,genplot=FALSE)
Bisciaro_Mg &lt;- astrochron::linterp(Bisciaro_Mg, dt = 0.01,verbose=FALSE,genplot=FALSE)
Bisciaro_Mg &lt;- Bisciaro_Mg[Bisciaro_Mg[, 1] &gt; 2, ]

Bisciaro_Mg_wt &lt;-
 analyze_wavelet(
   data = Bisciaro_Mg,
   dj = 1 /200 ,
   lowerPeriod = 0.01,
   upperPeriod = 50,
   verbose = FALSE,
   omega_nr = 8
 )

# Bisciaro_Mg_wt_track &lt;-
#   track_period_wavelet(
#     astro_cycle = 110,
#     wavelet = Bisciaro_Mg_wt,
#     n.levels = 100,
#     periodlab = "Period (metres)",
#     x_lab = "depth (metres)"
#   )
#
#
# Bisciaro_Mg_wt_track &lt;- completed_series(
#   wavelet = Bisciaro_Mg_wt,
#   tracked_curve = Bisciaro_Mg_wt_track,
#   period_up = 1.2,
#   period_down = 0.8,
#   extrapolate = TRUE,
#   genplot = FALSE,
#   keep_editable = FALSE
# )
#
# Bisciaro_Mg_wt_track &lt;-
#   loess_auto(
#     time_series = Bisciaro_Mg_wt_track,
#     genplot = FALSE,
#     print_span = FALSE,
#     keep_editable = FALSE)




wt_list_bisc &lt;- list(Bisciaro_al_wt,
               Bisciaro_ca_wt,
               Bisciaro_sial_wt,
               Bisciaro_Mn_wt,
               Bisciaro_Mg_wt)

#Instead of tracking, the tracked solution data sets Bisciaro_al_wt_track,
#Bisciaro_ca_wt_track, Bisciaro_sial_wt_track, Bisciaro_Mn_wt_track,
# Bisciaro_Mn_wt_track and Bisciaro_Mg_wt_track are used

data_track_bisc &lt;- cbind(Bisciaro_al_wt_track[,2],
                     Bisciaro_ca_wt_track[,2],
                     Bisciaro_sial_wt_track[,2],
                     Bisciaro_Mn_wt_track[,2],
                     Bisciaro_Mg_wt_track[,2])

x_axis_bisc &lt;- Bisciaro_al_wt_track[,1]


bisc_retrack &lt;- retrack_wt_MC(wt_list = wt_list_bisc,
             data_track = data_track_bisc,
             x_axis = x_axis_bisc,
             nr_simulations = 20,
             seed_nr = 1337,
             verbose = FALSE,
             genplot = FALSE,
             keep_editable = FALSE,
             create_GIF = FALSE,
             plot_GIF = FALSE,
             width_plt =  600,
             height_plt = 450,
            period_up  =  1.5,
             period_down = 0.5,
             plot.COI = TRUE,
             n.levels = 100,
             palette_name = "rainbow",
             color_brewer = "grDevices",
             periodlab = "Period (metres)",
             x_lab = "depth (metres)",
             add_avg = FALSE,
             time_dir = TRUE,
             file_name = NULL,
             run_multicore = FALSE,
             output = 1,
             n_imgs = 50,
             plot_horizontal = TRUE,
             empty_folder = FALSE)




</code></pre>

<hr>
<h2 id='sedrate2tune'>Use a sedimentation curve to convert data to the time domain</h2><span id='topic+sedrate2tune'></span>

<h3>Description</h3>

<p>Convert a proxy record from the depth to time domain using
a sedimentation rate curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sedrate2tune(
  data = NULL,
  sed_curve = NULL,
  genplot = FALSE,
  keep_editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sedrate2tune_+3A_data">data</code></td>
<td>
<p>Input should be a matrix of 2 columns with first column being depth and the second column
is a proxy value</p>
</td></tr>
<tr><td><code id="sedrate2tune_+3A_sed_curve">sed_curve</code></td>
<td>
<p>Input should be a matrix of 2 columns with first column being depth and the second column
is the sedimentation rate is cm/kyr</p>
</td></tr>
<tr><td><code id="sedrate2tune_+3A_genplot">genplot</code></td>
<td>
<p>Generates a plot of the proxy record in  the time domain <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="sedrate2tune_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a matrix with 2 columns.
The first column is time
The second column is the proxy value
If <code>genplot=TRUE</code> then a time vs proxy value plot will be plotted.
</p>


<h3>Author(s)</h3>

<p>Part of the code is based on the <a href="astrochron.html#topic+sedrate2time">sedrate2time</a>
function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Extract the 405kyr eccentricity cycle from the wavelet scalogram
# from the magnetic susceptibility record of the Sullivan core
# of Pas et al., (2018) and then create a age model using minimal tuning
# (e.g.) set the distance between peaks to 405 kyr. The age model
# (sedimentation rate curve) is then used to convert the data
# from the depth to the time domain

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)


mag_405 &lt;- extract_signal_stable_V2(
 wavelet = mag_wt,
 period_max = 4,
 period_min = 2,
 add_mean = TRUE,
 plot_residual = FALSE,
 keep_editable = FALSE
)

mag_405_min_tuning &lt;- minimal_tuning(data = mag_405,
pts = 5,
cycle = 405,
tune_opt = "max",
output = 1,
genplot = FALSE,
keep_editable = FALSE)

mag_time &lt;- sedrate2tune(
data=mag,
sed_curve=mag_405_min_tuning,
genplot=FALSE,
keep_editable=FALSE)


</code></pre>

<hr>
<h2 id='sum_power_sedrate'>Calculate sum of maximum spectral power for sedimentation rates
for a wavelet spectra</h2><span id='topic+sum_power_sedrate'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+sum_power_sedrate">sum_power_sedrate</a></code> function is used calculate the sum of
maximum spectral power for a list of astronomical cycles from a wavelet spectra.
The data is first normalized using the average spectral power curves
for a given percentile based on results of the <code><a href="#topic+model_red_noise_wt">model_red_noise_wt</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_power_sedrate(
  red_noise = NULL,
  wavelet = NULL,
  percentile = NULL,
  sedrate_low = NULL,
  sedrate_high = NULL,
  spacing = NULL,
  cycles = c(NULL),
  x_lab = "depth",
  y_lab = "sedrate",
  run_multicore = FALSE,
  genplot = FALSE,
  plot_res = 1,
  keep_editable = FALSE,
  palette_name = "rainbow",
  color_brewer = "grDevices",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_power_sedrate_+3A_red_noise">red_noise</code></td>
<td>
<p>Red noise curves generated using the <code><a href="#topic+model_red_noise_wt">model_red_noise_wt</a></code> function</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_percentile">percentile</code></td>
<td>
<p>Percentile value (0-1) of the rednoise runs which is used to normalize the data for.
To account for the distribution/distortion of the spectral power distribution based on the analytical technique and
random red-noise the data is normalized against a percentile based red-noise curve which is the results of the
'<code><a href="#topic+model_red_noise_wt">model_red_noise_wt</a></code> modelling runs.</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_sedrate_low">sedrate_low</code></td>
<td>
<p>Minimum sedimentation rate (cm/kyr)for which the sum of maximum spectral power is calculated for.</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_sedrate_high">sedrate_high</code></td>
<td>
<p>Maximum sedimentation rate (cm/kyr) for which the sum of maximum spectral power is calculated  for.</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_spacing">spacing</code></td>
<td>
<p>Spacing (cm/kyr) between sedimentation rates</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_cycles">cycles</code></td>
<td>
<p>Astronomical cycles (in kyr) for which the combined sum of maximum spectral power is calculated for</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_x_lab">x_lab</code></td>
<td>
<p>label for the y-axis <code>Default="depth"</code></p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_y_lab">y_lab</code></td>
<td>
<p>label for the y-axis <code>Default="sedrate"</code></p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_run_multicore">run_multicore</code></td>
<td>
<p>run simulation using multiple cores <code>Default=FALSE</code>
the simulation is run at x-2 cores to allow the 2 remaining processes to run background processes</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_genplot">genplot</code></td>
<td>
<p>Generate plot <code>Default="FALSE"</code></p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_plot_res">plot_res</code></td>
<td>
<p>plot options are 1: sum max power or 2: nr of components <code>Default=2</code></p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="sum_power_sedrate_+3A_verbose">verbose</code></td>
<td>
<p>Print text <code>Default=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list which contains 4 elements
element 1: sum of maximum spectral power
element 2: number of cycles used in the sum of maximum spectral power
element 3: y-axis values of the matrices which is sedimentation rate
element 4: x-axis values of the matrices which is depth
</p>
<p>If <code>Default="TRUE"</code> a plot is created with 3 subplots.
Subplot 1 is plot in which the the sum of maximum spectral power for a
given sedimentation rate or nr of cycles is plotted for each depth given depth.
Subplot 2 is a plot in which the average sum of maximum spectral power is plotted fro each sedimentation
Subplot 3 is a color scale for subplot 1.
</p>


<h3>Author(s)</h3>

<p>Based on the <a href="astrochron.html#topic+asm">asm</a> and <a href="astrochron.html#topic+eAsm">eAsm</a>
functions of the 'astrochron' R package
and the 'eCOCO' and 'COCO' functions of the 'Acycle' software
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>
<p>Acycle: Time-series analysis software for paleoclimate research and education,
Mingsong Li, Linda Hinnov, Lee Kump,
Computers &amp; Geosciences,Volume 127,2019,Pages 12-22,ISSN 0098-3004,
&lt;doi:10.1016/j.cageo.2019.02.011&gt;
</p>
<p>Tracking variable sedimentation rates and astronomical forcing in Phanerozoic paleoclimate proxy series with evolutionary correlation coefficients and hypothesis testing,
Mingsong Li, Lee R. Kump, Linda A. Hinnov, Michael E. Mann,
Earth and Planetary Science Letters,Volume 501,
T2018,Pages 165-179,ISSN 0012-821X,&lt;doi:10.1016/j.epsl.2018.08.041&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#estimate sedimentation rate for the the magnetic susceptibility record
# of the Sullivan core of Pas et al., (2018).

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#increase n_simulations to better define the red noise spectral power curve
mag_wt_red_noise &lt;- model_red_noise_wt(wavelet=mag_wt,
n_simulations=10,
run_multicore=FALSE,
verbose=FALSE)

sedrates &lt;- sum_power_sedrate(red_noise=mag_wt_red_noise,
wavelet=mag_wt,
percentile=0.75,
sedrate_low = 0.5,
sedrate_high = 4,
spacing = 0.05,
cycles = c(2376,1600,1180,696,406,110),
x_lab="depth",
y_lab="sedrate",
run_multicore=FALSE,
genplot = FALSE,
plot_res=1,
keep_editable=FALSE,
palette_name = "rainbow",
color_brewer="grDevices",
verbose=FALSE)



</code></pre>

<hr>
<h2 id='track_period_wavelet'>Track the period of a cycle in a wavelet spectra</h2><span id='topic+track_period_wavelet'></span>

<h3>Description</h3>

<p>Interactively select points in a wavelet spectra to trace a period in a wavelet spectra.
The <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function plots a wavelet spectra in which spectral peaks can selected
allowing one to track a ridge hence one can track the a cycle with a changing period.
Tracking points can be selected in the Interactive interface and will be shown as white dots
when one wants to deselect a point the white dots can be re-clicked/re-selected and will turn red which
indicates that the previously selected point is deselected. Deselecting points can be quite tricky
due to the close spacing of  points and such the <code><a href="#topic+delpts_tracked_period_wt">delpts_tracked_period_wt</a></code> can be used to
delete points were previously selected using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_period_wavelet(
  astro_cycle = 405,
  wavelet = NULL,
  n.levels = 100,
  track_peaks = TRUE,
  periodlab = "Period (metres)",
  x_lab = "depth (metres)",
  palette_name = "rainbow",
  color_brewer = "grDevices",
  plot_horizontal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_period_wavelet_+3A_astro_cycle">astro_cycle</code></td>
<td>
<p>Duration (in kyr) of the cycle which traced.</p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_wavelet">wavelet</code></td>
<td>
<p>Wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of color levels <code>Default=100</code>.</p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_track_peaks">track_peaks</code></td>
<td>
<p>Setting which indicates whether tracking is restricted
to spectral peaks (track_peaks=TRUE) or whether any point within the wavelet
spectra can be selected (track_peaks=FALSE) <code>Default=TRUE</code>.</p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_periodlab">periodlab</code></td>
<td>
<p>label for the y-axis <code>Default="Period (metres)"</code>.</p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_x_lab">x_lab</code></td>
<td>
<p>label for the x-axis <code>Default="depth (metres)"</code>.</p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="track_period_wavelet_+3A_plot_horizontal">plot_horizontal</code></td>
<td>
<p>plot the wavelet horizontal or vertical eg y axis is depth or y axis power  <code>Default=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results of the tracking of a cycle in the wavelet spectra is a matrix with 3 columns.
The first column is depth/time
The second column is the period of the tracked cycle
The third column is the sedimentation rate based on the duration (in time) of the tracked cycle
</p>


<h3>Author(s)</h3>

<p>The function is based/inspired on the <a href="astrochron.html#topic+traceFreq">traceFreq</a>
function of the 'astrochron' R package
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Track the 405kyr eccentricity cycle in the magnetic susceptibility record
# of the Sullivan core of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

mag_track &lt;- track_period_wavelet(astro_cycle = 405,
                                  wavelet=mag_wt,
                                  n.levels = 100,
                                  track_peaks=TRUE,
                                  periodlab = "Period (metres)",
                                  x_lab = "depth (metres)",
                                 palette_name = "rainbow",
                                 color_brewer="grDevices",
                                 plot_horizontal=TRUE)


</code></pre>

<hr>
<h2 id='TSI'>Total solar irradiation data (0-9400ka) of steinhilber et al., (2012)</h2><span id='topic+TSI'></span>

<h3>Description</h3>

<p>The Total solar irradiation data set consists of the TSI values of Steinhilber et al., (2012)
</p>


<h3>Details</h3>

<p>Column 1: Age (kyr)<br />
Column 2: Total solar Irradiation (TSI)<br />
</p>


<h3>References</h3>

<p>Steinhilber, Friedhelm &amp; Abreu, Jacksiel &amp; Beer, Juerg &amp; Brunner,
Irene &amp; Christl, Marcus &amp; Fischer, Hubertus &amp; Heikkilä, U. &amp; Kubik,
Peter &amp; Mann, Mathias &amp; Mccracken, K. &amp; Miller, Heinrich &amp; Miyahara,
Hiroko &amp; Oerter, Hans &amp; Wilhelms, Frank. (2012).
9,400 Years of cosmic radiation and solar activity from ice cores and tree rings.
Proceedings of the National Academy of Sciences of the United States of America.
109. 5967-71. 10.1073/pnas.1118965109.
&lt;doi:10.1073/pnas.1118965109&gt;
</p>

<hr>
<h2 id='wavelet_uncertainty'>Calculate the uncertainty associated with the wavelet analysis based on the Gabor uncertainty principle</h2><span id='topic+wavelet_uncertainty'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+wavelet_uncertainty">wavelet_uncertainty</a></code> function is used to calculate uncertainties associated
with the wavelet analysis based on the Gabor uncertainty principle applied to the
continuous wavelet transform using a Morlet wavelet. The calculated uncertainty is the underlying
analytical uncertainty which is the result of applying the Gabor uncertainty principle to the
continuous wavelet transform using a Morlet wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavelet_uncertainty(
  tracked_cycle = NULL,
  period_of_tracked_cycle = NULL,
  wavelet = NULL,
  multi = 1,
  verbose = FALSE,
  genplot_time = FALSE,
  genplot_uncertainty = FALSE,
  genplot_uncertainty_wt = FALSE,
  keep_editable = FALSE,
  palette_name = "rainbow",
  color_brewer = "grDevices"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wavelet_uncertainty_+3A_tracked_cycle">tracked_cycle</code></td>
<td>
<p>Curve of the cycle tracked using the <code><a href="#topic+track_period_wavelet">track_period_wavelet</a></code> function
Any input (matrix or data frame) in which the first column is depth or
time and the second column is period should work</p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_period_of_tracked_cycle">period_of_tracked_cycle</code></td>
<td>
<p>period of the tracked curve (in kyr).</p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_wavelet">wavelet</code></td>
<td>
<p>wavelet object created using the <code><a href="#topic+analyze_wavelet">analyze_wavelet</a></code> function.</p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_multi">multi</code></td>
<td>
<p>multiple of the standard deviation to be used for defining uncertainty <code>Default=1</code>.</p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_verbose">verbose</code></td>
<td>
<p>Print text <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_genplot_time">genplot_time</code></td>
<td>
<p>plot time curves with a upper and lower uncertainty based on Gabor uncertainty principle applied to the
continuous wavelet transform using a Morlet wavelet, which uses which uses the omega number (number
of cycles in the wavelet) at one standard deviation to define the analytical uncertainty <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_genplot_uncertainty">genplot_uncertainty</code></td>
<td>
<p>Plot period curves with upper and lower uncertainty based on Gabor uncertainty principle applied to the
continuous wavelet transform using a Morlet wavelet, which uses which uses the omega number
(number of cycles in the wavelet) to define uncertainty at one standard deviation <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_genplot_uncertainty_wt">genplot_uncertainty_wt</code></td>
<td>
<p>generate a wavelet plot with the uncertainty based on Gabor uncertainty
principle applied to the continuous wavelet transform using a Morlet wavelet superimposed on top of
original wavelet plot. The red curve is period of the tracked curve plus the analytical uncertainty.
The blue curve is period of the tracked curve min the analytical uncertainty.
The  black curve is the curve tracked using the '<code>Default=tracked_cycle_curve</code> function <code>Default=TRUE</code></p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="wavelet_uncertainty_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results pertaining to the uncertainty calculated based on the Gabor uncertainty principle.<br />
If the genplot_time is TRUE then a depth time plot will be plotted with 3 lines, the mean age,age plus
x times the standard deviation and age minus x times the standard deviation . <br />
If the genplot_uncertainty is TRUE then a curve will be plotted with the mean period, the tracked period plus
x times the standard deviation and the tracked period minus x times the standard deviation. <br />
If the genplot_uncertainty_wt is TRUE a wavelet spectra will be plotted with the tracked period, the tracked period plus
x times the standard deviation,the tracked period minus x times the standard deviation and the area in between will be shaded in grey.<br />
</p>
<p>Returns a matrix with 8 columns.<br />
The first column is called &quot;depth&quot; eg. depth <br />
The second column is &quot;period&quot; of the originally tracked period. <br />
The third column is &quot;frequency&quot; of the originally tracked period. <br />
The fourth column &quot;uncertainty in frequency FWHM&quot; is the uncertainty in frequency based on the Gabor uncertainty principle defined as
(FWHM) full width at half maximum. <br />
The fifth column &quot;uncertainty in frequency x_times SD&quot; is the uncertainty in frequency based on the Gabor uncertainty principle defined as
times x standard deviations. <br />
The sixth column &quot;time mean&quot; is the mean time based on the tracked period. <br />
The seventh column &quot;time plus x_times sd&quot; is the time based on the tracked period plus x times the standard deviation. <br />
The eight column &quot;time min x_times sd&quot; is the time based on the tracked period min x times the standard deviation. <br />
</p>


<h3>Author(s)</h3>

<p>Code based on the <a href="WaveletComp.html#topic+analyze.wavelet">analyze.wavelet</a> function of the 'WaveletComp' R package
and <a href="biwavelet.html#topic+wt">wt</a> function of the 'biwavelet' R package which are based on the
wavelet 'MATLAB' code written by Christopher Torrence and Gibert P. Compo (1998).
The assignment of the standard deviation of the uncertainty of the wavelet
is based on the work of Gabor (1946) and Russell et al., (2016)
</p>


<h3>References</h3>

<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a>
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021). R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a>
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a>
</p>
<p>Gabor, Dennis. &quot;Theory of communication. Part 1: The analysis of information.&quot;
Journal of the Institution of Electrical Engineers-part III: radio and
communication engineering 93, no. 26 (1946): 429-441.<a href="http://genesis.eecg.toronto.edu/gabor1946.pdf">http://genesis.eecg.toronto.edu/gabor1946.pdf</a>
</p>
<p>Russell, Brian, and Jiajun Han. &quot;Jean Morlet and the continuous wavelet transform.
&quot; CREWES Res. Rep 28 (2016): 115. <a href="https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf">https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf</a>
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a>
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#calculate the Gabor uncertainty derived mathematical uncertainty of the
#magnetic susceptibility record of the Sullivan core of Pas et al., (2018)

mag_wt &lt;- analyze_wavelet(data = mag,
dj = 1/100,
lowerPeriod = 0.1,
upperPeriod = 254,
verbose = FALSE,
omega_nr = 10)

#Track the 405 kyr eccentricity cycle in a wavelet spectra

#mag_track &lt;- track_period_wavelet(astro_cycle = 405,
#                                   wavelet=mag_wt,
#                                   n.levels = 100,
#                                   periodlab = "Period (metres)",
#                                   x_lab = "depth (metres)",
#                                palette_name="rainbow",
#                                color_brewer= "grDevices")

#Instead of tracking, the tracked solution data set mag_track_solution is used
mag_track &lt;- mag_track_solution

mag_track_complete &lt;- completed_series(
  wavelet = mag_wt,
  tracked_curve = mag_track,
  period_up = 1.2,
  period_down = 0.8,
  extrapolate = FALSE,
  genplot = FALSE,
  keep_editable=FALSE
)

mag_track_complete &lt;- loess_auto(time_series = mag_track_complete,
 genplot = FALSE, print_span = FALSE,keep_editable=FALSE)

uncertainty &lt;- wavelet_uncertainty(
  tracked_cycle = mag_track_complete,
  period_of_tracked_cycle = 405,
  wavelet = mag_wt,
  multi=1,
  verbose = FALSE,
  genplot_time = FALSE,
  genplot_uncertainty = FALSE,
  genplot_uncertainty_wt = FALSE,
  keep_editable=FALSE,
  palette_name="rainbow",
  color_brewer= "grDevices"
)

</code></pre>

<hr>
<h2 id='WaverideR'>Extracting Signals from Wavelet Spectra</h2><span id='topic+WaverideR'></span>

<h3>Description</h3>

<p>The continuous wavelet transform enables the observation of
transient/non-stationary cyclicity in time-series. The goal of
cyclostratigraphic studies is to define frequency/period in the
depth/time domain. By conducting the continuous wavelet transform
on cyclostratigraphic data series one can observe and extract cyclic
signals/signatures from signals. These results can then be visualized
and interpreted enabling one to identify/interpret cyclicity in the
geological record, which can be used to construct astrochronological
age-models and identify and interpret cyclicity in past and present
climate systems.
</p>


<h3>Details</h3>

<p>Package: 'WaverideR'
</p>
<p>Type: R package
</p>
<p>Version: 0.3.2 (begin of 2023)
</p>
<p>License: GPL (= 2)
</p>


<h3>Note</h3>

<p>If you want to use this package for publication or research
purposes, please cite:
</p>
<p>Arts, M.C.M (2023).
WaverideR: Extracting Signals from Wavelet Spectra.
https://CRAN.R-project.org/package=WaverideR
</p>


<h3>Author(s)</h3>

<p>Michiel Arts
</p>
<p>Maintainer: Michiel Arts <a href="mailto:michiel.arts@stratigraphy.eu">michiel.arts@stratigraphy.eu</a>
</p>


<h3>References</h3>

<p>The 'WaverideR' package builds upon existing literature and existing codebase.
The following list of articles is relevant for the 'WaverideR' R package and
its functions. Individual articles are also cited in the descriptions of
function when relative for set function. The articles in the list below can
be grouped in four subjects: (1) Cyclostratigraphic data analysis, (2)
example data sets, (3) the (continuous) wavelet transform and (4)
astronomical solutions). For each of these categories the
relevance of set articles will be explained in the framework of
the 'WaverideR' R package.
</p>
<p># 1. Cyclostratigraphic data analysis
</p>
<p>Stephen R. Meyers, Cyclostratigraphy and the problem of astrochronologic
testing, Earth-Science Reviews,Volume 190,2019,Pages 190-223,ISSN 0012-8252
<a href="https://doi.org/10.1016/j.earscirev.2018.11.015">doi:10.1016/j.earscirev.2018.11.015</a> <br />
The 'astrochron' R package is the most extensive R package with regards to
cyclostratigraphic analysis. As such many of the functionalities of the
'WaverideR' R package are #' inspired/based on the 'astrochron' R package.
The major difference between #' the 'astrochron' R package and the 'WaverideR'
package is that the #' astrochron' R package relies on the Fast Fourier Transform whereas
</p>
<p>S.R. Meyers, 2012, Seeing Red in Cyclic Stratigraphy: Spectral Noise
Estimation for Astrochronology: Paleoceanography, 27, PA3228,
<a href="https://doi.org/10.1029/2012PA002307">doi:10.1029/2012PA002307</a> <br />
The article of Meyers (2012) explains how the (Multitaper method) MTM technique
implemented into The 'astrochron' R package The MTM method can be used
to assign confidence levels to spectral peaks and distinguish spectral peaks
from harmonic spectral peaks.
</p>
<p>Acycle: Time-series analysis software for paleoclimate research and education,
Mingsong Li, Linda Hinnov, Lee Kump, Computers &amp; Geosciences,Volume 127,2019,
Pages 12-22,ISSN 0098-3004, <a href="https://doi.org/10.1016/j.cageo.2019.02.011">doi:10.1016/j.cageo.2019.02.011</a> <br />
The 'Acycle' software package is a 'Matlab' based program, which is used for
cyclostratigraphic studies. Acycle relies mostly on the Fast Fourier Transform.
The 'Coco' and 'eCoco' functions from Acycle formed the inspiration for the
<a href="#topic+flmw">flmw</a> <a href="#topic+sum_power_sedrate">sum_power_sedrate</a> functions of the
‘Waverider’ R package.
</p>
<p>Tracking variable sedimentation rates and astronomical forcing in Phanerozoic
paleoclimate proxy series with evolutionary correlation coefficients and
hypothesis testing, Mingsong Li, Lee R. Kump, Linda A. Hinnov, Michael
E. Mann, Earth and Planetary Science Letters,Volume 501, 2018,Pages 165-179,
ISSN 0012-821X, <a href="https://doi.org/10.1016/j.epsl.2018.08.041">doi:10.1016/j.epsl.2018.08.041</a> <br />
Li et al., (2019) introduces the Coco and eCoco functions of the Acycle
software package. the 'Coco' and 'eCoco' function of the 'Acycle' software
are able to estimate the sedimentation rate based on spectral
characteristics of astronomical cycles. The 'Coco' and 'eCoco' function and
form the inspiration for the  <a href="#topic+flmw">flmw</a> and  <a href="#topic+sum_power_sedrate">sum_power_sedrate</a>
functions of the 'WaverideR' Package.
</p>
<p>Wouters, S., Crucifix, M., Sinnesael, M., Da Silva, A.C., Zeeden, C.,
Zivanovic, M., Boulvain, F., Devleeschouwer, X., 2022,
&quot;A decomposition approach to cyclostratigraphic signal processing&quot;.
Earth-Science Reviews 225 (103894).<a href="https://doi.org/10.1016/j.earscirev.2021.103894">doi:10.1016/j.earscirev.2021.103894</a> <br />
Wouters et al., (2022) introduces the Empirical Mode Decomposition (EMD) as
part of the 'DecomposeR' R package. EMD is a non-Fast Fourier Transform
based spectral analysis technique. The Hilbert transform function
<a href="DecomposeR.html#topic+inst.pulse">inst.pulse</a> of this package is used in WaverideR
functions <a href="#topic+extract_amplitude">extract_amplitude</a> and <a href="#topic+Hilbert_transform">Hilbert_transform</a>.
</p>
<p>Wouters, S., Da Silva, A.-C., Boulvain, F., and Devleeschouwer, X.. 2021.
StratigrapheR: Concepts for Litholog Generation in R. The R Journal.
<a href="https://doi.org/10.32614/RJ-2021-039">doi:10.32614/RJ-2021-039</a> <br />
Wouters et al., (2021) introduces the <a href="StratigrapheR.html#topic+StratigrapheR">StratigrapheR</a> R
package. This package contains functions which format, process, and plot lithologs.
The litholog format of Wouters et al., (2021) is used as the standardized input
format to convert lithologs to a time series format using the <a href="#topic+lithlog_disc">lithlog_disc</a>
function. The time series can then be analysed for the imprint of cycles.
</p>
<p>#'Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold, Xianyao Chen,
and Karin Blank. 2009. &quot;On Instantaneous Frequency&quot;. Advances in Adaptive
Data Analysis 01 (02): 177–229. <a href="https://doi.org/10.1142/S1793536909000096">doi:10.1142/S1793536909000096</a> <br />
The Hilbert transform function <a href="DecomposeR.html#topic+inst.pulse">inst.pulse</a> of the 'DecomposeR'
R package is based on the work of Huang et al., (2009).
</p>
<p>Cleveland, W. S. (1979) Robust locally weighted regression and smoothing scatter plots.
Journal of the American Statistical Association. 74, 829–836. <a href="https://doi.org/10.1080/01621459.1979.10481038">doi:10.1080/01621459.1979.10481038</a> <br />
Cleveland (1979) explains how the robust locally weighted regression works
and how it can be used to smooth data sets. This theory is applied in the
<a href="#topic+loess_auto">loess_auto</a> function of the ‘WaverideR’ package.
</p>
<p>#'Hurvich, C.M., Simonoff, J.S., and Tsai, C.L. (1998), Smoothing Parameter
Selection in Nonparametric Regression Using an Improved Akaike Information
Criterion. Journal of the Royal Statistical Society B. 60, 271–293
<a href="https://doi.org/10.1111/1467-9868.00125">doi:10.1111/1467-9868.00125</a> <br />
Hurvich et al., (1998) explains how
the Improved Akaike Information Criterion can be used to optimally smooth data sets
This theory is applied in the <a href="#topic+loess_auto">loess_auto</a> function of the ‘WaverideR’ package.
</p>
<p>#'Golub, G., Heath, M. and Wahba, G. (1979). Generalized cross validation as
a method for choosing a good ridge parameter. Technometrics. 21, 215–224. <a href="https://doi.org/10.2307/1268518">doi:10.2307/1268518</a><br />
Golub et al., (1979) explains how the Generalized cross validation can be
used to optimally smooth data sets. This theory is applied in the <a href="#topic+loess_auto">loess_auto</a>
function of the ‘WaverideR’ package.
</p>
<p># 2. Example data sets
</p>
<p>Damien Pas, Linda Hinnov, James E. (Jed) Day, Kenneth Kodama, Matthias Sinnesael, Wei Liu,
Cyclostratigraphic calibration of the Famennian stage (Late Devonian, Illinois Basin, USA),
Earth and Planetary Science Letters,
Volume 488,2018,Pages 102-114,ISSN 0012-821X,
<a href="https://doi.org/10.1016/j.epsl.2018.02.010">doi:10.1016/j.epsl.2018.02.010</a> <br />
The data set of Pas et al, (2018) is a
magnetic susceptibility data measured on the Fammennian aged shales of
the from the Illinois basin in the USA. The data set contains the imprint of
astronomical cycles in the a Paleozoic succession making it a good example for
times (250Ma) when no astronomical solutions are available.
</p>
<p>Steinhilber, Friedhelm &amp; Abreu, Jacksiel &amp; Beer, Juerg &amp; Brunner,
Irene &amp; Christl, Marcus &amp; Fischer, Hubertus &amp; Heikkilä, U. &amp; Kubik,
Peter &amp; Mann, Mathias &amp; Mccracken, K. &amp; Miller, Heinrich &amp; Miyahara,
Hiroko &amp; Oerter, Hans &amp; Wilhelms, Frank. (2012).
9,400 Years of cosmic radiation and solar activity from ice cores and tree rings.
Proceedings of the National Academy of Sciences of the United States of America.
109. 5967-71. 10.1073/pnas.1118965109.
<a href="https://doi.org/10.1073/pnas.1118965109">doi:10.1073/pnas.1118965109</a> <br />
The Total Solar Irradiance record of Steinhilber et al., (2012) is a Holocene record of normalized
Total Solar Irradiance in the time domain. The data set is a good example for
studying/extracting sub-Milankovitch 5000yr from a relatively (geologically) speaking young record.
</p>
<p>Christian Zeeden, Frederik Hilgen, Thomas Westerhold, Lucas Lourens, Ursula Röhl, Torsten Bickert,
Revised Miocene splice, astronomical tuning and calcareous plankton biochronology of ODP Site 926 between 5 and 14.4Ma,
Palaeogeography, Palaeoclimatology, Palaeoecology,Volume 369,2013,Pages 430-451,ISSN 0031-0182,
10.1016/j.palaeo.2012.11.009<br />
The record of Zeeden et al., (2013) consists of a grey scale record from Miocene sediment cores from offshore
Brazil. The record contains a clear imprint of astronomical cycles as such it is a good Neogene example data set
to demonstrate the functionalities of the 'WaverideR' R package
</p>
<p># 3. The (continuous) wavelet transform
</p>
<p>Morlet, Jean, Georges Arens, Eliane Fourgeau, and Dominique Glard.
&quot;Wave propagation and sampling theory—Part I: Complex signal and scattering in multilayered media.
&quot; Geophysics 47, no. 2 (1982): 203-221.
<a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I">https://pubs.geoscienceworld.org/geophysics/article/47/2/203/68601/Wave-propagation-and-sampling-theory-Part-I</a><br />
Morlet et al., (1982a) together with Morlet et al., (1982b) are the original publications which explain the
use of the wavelet to analyse signal.
</p>
<p>J. Morlet, G. Arens, E. Fourgeau, D. Giard;
Wave propagation and sampling theory; Part II, Sampling theory and complex waves.
Geophysics 1982 47 (2): 222–236. <a href="https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II">https://pubs.geoscienceworld.org/geophysics/article/47/2/222/68604/Wave-propagation-and-sampling-theory-Part-II</a><br />
Morlet et al., (1982a) together with Morlet et al., (1982b) are the original publications which explain the
use of the wavelet to analyse signal.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
Bulletin of the American Meteorological Society 79:61-78.
<a href="https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf">https://paos.colorado.edu/research/wavelets/bams_79_01_0061.pdf</a> <br />
'Torrence and Compo (1998) shows how the continuous wavelet transform can be used to analyse
cyclicity in paleo-climatic data-sets. The equations in this publication forms the basis for many
wavelet based packages/software applications.
</p>
<p>Gouhier TC, Grinsted A, Simko V (2021).
R package biwavelet: Conduct Univariate and Bivariate Wavelet Analyses. (Version 0.20.21),
<a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a><br />
Gouhier et al., (2021) is the implementation of equations of Torrence and Compo (1998) in the form of the
'biwavelet' R package
</p>
<p>Angi Roesch and Harald Schmidbauer (2018). WaveletComp: Computational
Wavelet Analysis. R package version 1.1.
<a href="https://CRAN.R-project.org/package=WaveletComp">https://CRAN.R-project.org/package=WaveletComp</a><br />
Roesch and Schmidbauer et al., (2018) is the article of the 'WaveletComp' R package which
is a built upon the functionalities of the 'biwavelet' R package
</p>
<p>Russell, Brian, and Jiajun Han. &quot;Jean Morlet and the continuous wavelet transform.
&quot; CREWES Res. Rep 28 (2016): 115. <a href="https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf">https://www.crewes.org/Documents/ResearchReports/2016/CRR201668.pdf</a><br />
Russell and Han (2016) gives a concise summary of the work of Morlet et al., (1982a) and Morlet et al., (1982b) and the
developments since then. The publication also describes how the Gabor uncertainty principle (Gabor 1946) affects the frequency
uncertainty of the wavelet which can be used to calculate the analytical uncertainty of a given wavelet spectra.
</p>
<p>Gabor, Dennis. &quot;Theory of communication. Part 1: The analysis of information.&quot;
Journal of the Institution of Electrical Engineers-part III: radio and
communication engineering 93, no. 26 (1946): 429-441. <a href="http://genesis.eecg.toronto.edu/gabor1946.pdf">http://genesis.eecg.toronto.edu/gabor1946.pdf</a><br />
Gabor (1946) describes the Gabor uncertainty principle which states how the uncertainty in time and frequency are related
in time series analysis.
</p>
<p># 4. Astronomical solutions
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004,
A long term numerical solution for the insolation quantities of the Earth: Astron. Astrophys.,
Volume 428, 261-285. <a href="https://doi.org/10.1051/0004-6361%3A20041335">doi:10.1051/0004-6361:20041335</a><br />
Laskar et al., (2004) is an astronomical solution which can be used to anchor geological data to absolute ages.
</p>
<p>Laskar, J., Fienga, A., Gastineau, M., Manche, H., 2011a,
La2010: A new orbital solution for the long-term motion of the Earth: Astron. Astrophys.,
Volume 532, A89 <a href="https://doi.org/10.1051/0004-6361/201116836">doi:10.1051/0004-6361/201116836</a><br />
Laskar et al., (2011a) is an astronomical solution which can be used to anchor geological data to absolute ages.
</p>
<p>Laskar, J., Gastineau, M., Delisle, J.-B., Farres, A., Fienga, A.:
2011b, Strong chaos induced by close encounters with Ceres and Vesta, Astron: Astrophys.,
Volume 532, L4.  <a href="https://doi.org/10.1051/0004-6361/201117504">doi:10.1051/0004-6361/201117504</a><br />
Laskar et al., (2011b) is an astronomical solution which can be used to anchor geological data to absolute ages.
</p>
<p>J. Laskar,Chapter 4 - Astrochronology,Editor(s): Felix M. Gradstein, James G. Ogg, Mark D. Schmitz, Gabi M. Ogg,Geologic Time Scale 2020,Elsevier,2020,Pages 139-158,ISBN 9780128243602,
'<a href="https://doi.org/10.1016/B978-0-12-824360-2.00004-8">doi:10.1016/B978-0-12-824360-2.00004-8</a><br />
Laskar et al., (2019) explains how astronomical solutions are created and how they should/can be used
</p>
<p>Zeebe, Richard E. &quot;Numerical solutions for the orbital motion of the Solar System over the past 100 Myr: limits and new results.&quot;
The Astronomical Journal 154, no. 5 (2017): 193. <a href="https://doi.org/10.3847/1538-3881/aa8cce">doi:10.3847/1538-3881/aa8cce</a> <br />
Zeebe (2017) is an astronomical solution which can be used to anchor geological data to absolute ages.
</p>
<p>Richard E. Zeebe Lucas J. Lourens ,Solar System chaos and the Paleocene–Eocene boundary age constrained by geology and astronomy.Science365,926-929(2019)
<a href="https://doi.org/10.1126/science.aax0612">doi:10.1126/science.aax0612</a><br />
Zeebe and Lourens (2019) is an astronomical solution which can be used to anchor geological data to absolute ages.
</p>
<p>Zeebe, R. E. and Lourens, L. J.
Geologically constrained astronomical solutions for the Cenozoic era,
Earth and Planetary Science Letters, 2022 <a href="https://doi.org/10.1016/j.epsl.2022.117595">doi:10.1016/j.epsl.2022.117595</a> <br />
Zeebe and Lourens (2022) is an astronomical solution which can be used to anchor geological data to absolute ages.
</p>

<hr>
<h2 id='WaverideR_Datasets'>Example data sets for the 'WaverideR' package</h2><span id='topic+WaverideR_Datasets'></span>

<h3>Description</h3>

<p>Data sets for testing the 'WaverideR' R package:<br />
The <code>age_model_zeeden</code> data set is and age model (anchor points) for<br />
the IODP 926 grey scale (154-174m) record of Zeeden et al., (2013)<br />
<br />
The <code>astrosignal_example</code> data set consists of pre-generated ETP (eccentricity-tilt-precession)<br />
data set based on the p-0.5t  la2004 solution and was generated using <br />
the <a href="astrochron.html#topic+etp">etp</a> function of the 'astrochron' R package <br />
<br />
The <code>depth_rank_example</code> data set is synthetic succession of sedimentary<br />
The <code>grey</code> data set is the grey scale record of IODP 926 for the interval (154-174m) which originates<br /> from
Zeeden et al., (2013) <br />
<br />
The <code>grey_track</code> data set consists of tracking points of the<br />
precession (22 kyr cycle) in the IODP 926 grey scale (154-174m) record of Zeeden et al., (2013)<br />
<br />
The <code>mag</code> data set is the magnetic susceptibility record of Pas et al., (2018)<br />
<br />
The <code>mag_track_solution</code> is the period of the 405 kyr eccentricity cycle in<br />
the magnetic susceptibility record of from Pas et al., (2018)<br />
<br />
The <code>TSI</code> data set is the Total Solar Irradiance record of Steinhilber et al., (2012)<br />
<br />
The <code>Bisciaro_Mg_wt_track</code> data set is the 110-kyr (short eccentricity) <br />
cycle tracked in the wavelet scalogram of the Magnesium (XRF) record of Arts (2014)<br />
<br />
The <code>Bisciaro_Mn_wt_track</code> data set is the 110-kyr (short eccentricity) <br />
cycle tracked in the wavelet scalogram of the Manganese (XRF)record of Arts (2014)<br />
<br />
The <code>Bisciaro_al_wt_track</code> data set is the 110-kyr (short eccentricity) <br />
cycle tracked in the wavelet scalogram of the Aluminum (XRF) record of Arts (2014)<br />
<br />
The <code>Bisciaro_ca_wt_track</code> data set is the 110-kyr (short eccentricity) <br />
cycle tracked in the wavelet scalogram of the Calcium (XRF) record of Arts (2014)<br />
<br />
The <code>Bisciaro_sial_wt_track</code> data set is the 110-kyr (short eccentricity) <br />
cycle tracked in the wavelet scalogram of the Silicon/Aluminum (XRF) record of Arts (2014)<br />
<br />
The <code>Bisciaro_XRF</code> is the XRF data set of Arts (2014)<br />
<br />
</p>
<p>The <code>anchor_points_Bisciaro_al</code> data set consist of the tie points between the
Bisciaro_al record of Arts (2014) and the la2011 solution of laskar et al., (20111)<br />
<br />
</p>
<p>The <code>GTS_info</code> data set contains the color coding and ages and uncertainties
of Geologic Time Scale 2020 of Ogg (et al., 2021)<br />
<br />
</p>


<h3>References</h3>

<p>Damien Pas, Linda Hinnov, James E. (Jed) Day, Kenneth Kodama, Matthias Sinnesael, Wei Liu,
Cyclostratigraphic calibration of the Famennian stage (Late Devonian, Illinois Basin, USA),
Earth and Planetary Science Letters,
Volume 488,2018,Pages 102-114,ISSN 0012-821X,
&lt;doi:10.1016/j.epsl.2018.02.010&gt;
</p>
<p>Steinhilber, Friedhelm &amp; Abreu, Jacksiel &amp; Beer, Juerg &amp; Brunner,
Irene &amp; Christl, Marcus &amp; Fischer, Hubertus &amp; Heikkilä, U. &amp; Kubik,
Peter &amp; Mann, Mathias &amp; Mccracken, K. &amp; Miller, Heinrich &amp; Miyahara,
Hiroko &amp; Oerter, Hans &amp; Wilhelms, Frank. (2012).
9,400 Years of cosmic radiation and solar activity from ice cores and tree rings.
Proceedings of the National Academy of Sciences of the United States of America.
109. 5967-71. 10.1073/pnas.1118965109.
&lt;doi:10.1073/pnas.1118965109&gt;
</p>
<p>Christian Zeeden, Frederik Hilgen, Thomas Westerhold, Lucas Lourens, Ursula Röhl, Torsten Bickert,
Revised Miocene splice, astronomical tuning and calcareous plankton biochronology of ODP Site 926 between 5 and 14.4Ma,
Palaeogeography, Palaeoclimatology, Palaeoecology,Volume 369,2013,Pages 430-451,ISSN 0031-0182,
&lt;doi:10.1016/j.palaeo.2012.11.009&gt;
</p>
<p>Stephen R. Meyers,Cyclostratigraphy and the problem of astrochronologic testing,
Earth-Science Reviews,Volume 190,2019,Pages 190-223,ISSN 0012-8252
&lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004,
A long term numerical solution for the insolation quantities of the Earth: Astron. Astrophys.,
Volume 428, 261-285. &lt;doi:10.1051/0004-6361:20041335&gt; <br />
</p>
<p>Laskar, J., M. Gastineau, J. B. Delisle, A. Farrés, and A. Fienga (2011b),
Strong chaos induced by close encounters with Ceres and Vesta, Astron. Astrophys.,
532, L4,&lt;doi:10.1051/0004-6361/201117504&gt; <br />
</p>
<p>M.C.M. Arts, 2014,
Magnetostratigrpahy and geochemical analysis of the early Miocene Bisciaro Formation
in the Contessa Valley (Northern Italy). Unpublished Bsc. thesis <br />
</p>
<p>Ogg, Gabi &amp; Ogg, James &amp; Gradstein, Felix. (2021).
Recommended color coding of stages - Appendix 1
from Geologic Time Scale 2020.
</p>

<hr>
<h2 id='win_fft'>Windowed fft based spectral analysis</h2><span id='topic+win_fft'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+win_fft">win_fft</a></code> function for conducts a windowed spectral analysis based on the fft
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win_fft(
  data = NULL,
  padfac = 5,
  window_size = NULL,
  run_multicore = FALSE,
  genplot = FALSE,
  x_lab = c("depth (m)"),
  y_lab = c("frequency cycle/metre"),
  plot_res = 1,
  perc_vis = 0,
  freq_max = NULL,
  freq_min = NULL,
  palette_name = "rainbow",
  color_brewer = "grDevices",
  keep_editable = FALSE,
  verbose = FALSE,
  dev_new = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win_fft_+3A_data">data</code></td>
<td>
<p>Input data set  should consist of a matrix with 2 columns with first column being depth and the second column being a proxy</p>
</td></tr>
<tr><td><code id="win_fft_+3A_padfac">padfac</code></td>
<td>
<p>Pad record with zero, zero padding smooths out the spectra</p>
</td></tr>
<tr><td><code id="win_fft_+3A_window_size">window_size</code></td>
<td>
<p>size of the running window</p>
</td></tr>
<tr><td><code id="win_fft_+3A_run_multicore">run_multicore</code></td>
<td>
<p>Run function using multiple cores <code>Default="FALSE"</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_genplot">genplot</code></td>
<td>
<p>Generate plot <code>Default="FALSE"</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_x_lab">x_lab</code></td>
<td>
<p>label for the y-axis <code>Default="depth"</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_y_lab">y_lab</code></td>
<td>
<p>label for the y-axis <code>Default="sedrate"</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_plot_res">plot_res</code></td>
<td>
<p>plot 1 of 8 options option 1: Amplitude matrix,
option 2: Power matrix,
option 3: Phase matrix,
option 4: AR1_CL matrix,
option 5: AR1_Fit matrix ,
option 6: AR1_90_power matrix,
option 7: AR1_95_power matrix,
option 8: AR1_99_power matrix, <code>Default=1</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_perc_vis">perc_vis</code></td>
<td>
<p>Cutoff percentile when plotting <code>Default=0</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_freq_max">freq_max</code></td>
<td>
<p>Maximum frequency to plot</p>
</td></tr>
<tr><td><code id="win_fft_+3A_freq_min">freq_min</code></td>
<td>
<p>Minimum frequency to plot</p>
</td></tr>
<tr><td><code id="win_fft_+3A_palette_name">palette_name</code></td>
<td>
<p>Name of the color palette which is used for plotting.
The color palettes than can be chosen depends on which the R package is specified in
the color_brewer parameter. The included R packages from which palettes can be chosen
from are; the 'RColorBrewer', 'grDevices', 'ColorRamps' and 'Viridis' R packages.
There are many options to choose from so please
read the documentation of these packages <code>Default=rainbow</code>.
The R package 'viridis' has the color palette options: “magma”, “plasma”,
“inferno”, “viridis”, “mako”, and “rocket”  and “turbo”
To see the color palette options of the The R pacakge 'RColorBrewer' run
the RColorBrewer::brewer.pal.info() function
The R package 'colorRamps' has the color palette options:&quot;blue2green&quot;,
&quot;blue2green2red&quot;, &quot;blue2red&quot;,    &quot;blue2yellow&quot;, &quot;colorRamps&quot;,    &quot;cyan2yellow&quot;,
&quot;green2red&quot;, &quot;magenta2green&quot;, &quot;matlab.like&quot;, &quot;matlab.like2&quot; and    &quot;ygobb&quot;
The R package 'grDevices' has the built in  palette options:&quot;rainbow&quot;,
&quot;heat.colors&quot;, &quot;terrain.colors&quot;,&quot;topo.colors&quot; and &quot;cm.colors&quot;
To see even more color palette options of the The R pacakge 'grDevices' run
the grDevices::hcl.pals() function</p>
</td></tr>
<tr><td><code id="win_fft_+3A_color_brewer">color_brewer</code></td>
<td>
<p>Name of the R package from which the color palette is chosen from.
The included R packages from which palettes can be chosen
are; the RColorBrewer, grDevices, ColorRamps and Viridis R packages.
There are many options to choose from so please
read the documentation of these packages. &quot;<code>Default=grDevices</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_keep_editable">keep_editable</code></td>
<td>
<p>Keep option to add extra features after plotting  <code>Default=FALSE</code></p>
</td></tr>
<tr><td><code id="win_fft_+3A_verbose">verbose</code></td>
<td>
<p>Print text <code>Default=FALSE</code>.</p>
</td></tr>
<tr><td><code id="win_fft_+3A_dev_new">dev_new</code></td>
<td>
<p>Opens a new plotting window to plot the plot, this guarantees  a &quot;nice&quot; looking plot however when plotting in an R markdown
document the plot might not plot  <code>Default=FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list which contains 10 elements
element 1: Amplitude matrix
element 2: Power matrix
element 3: Phase matrix
element 4: AR1_CL matrix
element 5: AR1_Fit matrix
element 6: AR1_90_power matrix
element 7: AR1_95_power matrix
element 8: AR1_99_power matrix
element 9: depth
element 10: y_axis
If genplot is <code>Default=TRUE</code> then a plot of one of the elements 1:8 is plotted
</p>


<h3>Author(s)</h3>

<p>Based on the <a href="astrochron.html#topic+periodogram">periodogram</a>
function of the 'astrochron' R package.
</p>


<h3>References</h3>

<p>Routines for astrochronologic testing, astronomical time scale construction, and
time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Conduct a windowed ftt on the magnetic susceptibility record
#of the Sullivan core of Pas et al., (2018).

mag_win_fft &lt;- win_fft(data= mag,
                   padfac = 5,
                   window_size = 12.5,
                   run_multicore = FALSE,
                   genplot = FALSE,
                   x_lab = c("depth (m)"),
                   y_lab = c("frequency cycle/metre"),
                   plot_res = 1,
                   perc_vis = 0.5,
                   freq_max = 5,
                   freq_min = 0.001,
                   palette_name ="rainbow",
                   color_brewer= "grDevices",
                   keep_editable=FALSE,
                   verbose=FALSE,
                   dev_new=FALSE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
