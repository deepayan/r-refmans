<!DOCTYPE html><html lang="en"><head><title>Help for package classifly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {classifly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#advantage'><p>Calculate the advantage the most likely class has over the next most</p>
likely.</a></li>
<li><a href='#classifly'><p>Classifly provides a convenient method to fit a classification function</p>
and then explore the results in the original high dimensional space.</a></li>
<li><a href='#classify'><p>Extract classifications from a variety of methods.</p></a></li>
<li><a href='#explore'><p>Default method for exploring objects</p></a></li>
<li><a href='#generate_classification_data'><p>Generate classification data.</p></a></li>
<li><a href='#generate_data'><p>Generate new data from a data frame.</p></a></li>
<li><a href='#knnf'><p>A wrapper function for <code>knn</code> to allow use</p>
with classifly.</a></li>
<li><a href='#olives'><p>Olives</p></a></li>
<li><a href='#posterior'><p>Extract posterior group probabilities</p></a></li>
<li><a href='#simvar'><p>Simulate observations from a vector</p></a></li>
<li><a href='#variables'><p>Extract predictor and response variables for a model object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Explore Classification Models in High Dimensions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham &lt;h.wickham@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;h.wickham@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Given $p$-dimensional training data containing $d$ groups
    (the design space), a classification algorithm (classifier) predicts
    which group new data belongs to.  Generally the input to these
    algorithms is high dimensional, and the boundaries between groups will
    be high dimensional and perhaps curvilinear or multi-faceted. This
    package implements methods for understanding the division of space
    between the groups.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://had.co.nz/classifly">http://had.co.nz/classifly</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>class, plyr, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>e1071, MASS, rpart</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-20 00:23:13 UTC; hadleywickham</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-20 06:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='advantage'>Calculate the advantage the most likely class has over the next most
likely.</h2><span id='topic+advantage'></span>

<h3>Description</h3>

<p>This is used to identify the boundaries between classification regions.
Points with low (close to 0) advantage are likely to be near boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advantage(post)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="advantage_+3A_post">post</code></td>
<td>
<p>matrix of posterior probabilities</p>
</td></tr>
</table>

<hr>
<h2 id='classifly'>Classifly provides a convenient method to fit a classification function
and then explore the results in the original high dimensional space.</h2><span id='topic+classifly'></span><span id='topic+package-classifly'></span>

<h3>Description</h3>

<p>This is a convenient function to fit a classification function and
then explore the results using GGobi.  You can also do this in two
separate steps using the classification function and then
<code><a href="#topic+explore">explore</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifly(
  data,
  model,
  classifier,
  ...,
  n = 10000,
  method = "nonaligned",
  type = "range"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classifly_+3A_data">data</code></td>
<td>
<p>Data set use for classification</p>
</td></tr>
<tr><td><code id="classifly_+3A_model">model</code></td>
<td>
<p>Classification formula, usually of the form
<code>response ~ predictors</code></p>
</td></tr>
<tr><td><code id="classifly_+3A_classifier">classifier</code></td>
<td>
<p>Function to use for the classification, eg.
<code><a href="MASS.html#topic+lda">lda</a></code></p>
</td></tr>
<tr><td><code id="classifly_+3A_...">...</code></td>
<td>
<p>Other arguments passed to classification function.  For
example. if you use <code><a href="e1071.html#topic+svm">svm</a></code> you need to use
<code>probabiltiy = TRUE</code> so that posterior probabilities can be
retrieved.</p>
</td></tr>
<tr><td><code id="classifly_+3A_n">n</code></td>
<td>
<p>Number of points to simulate.  To maintain the illusion of a
filled solid this needs to increase with dimension.  10,000 points seems
adequate for up to four of five dimensions, but if you have more
predictors than that, you will need to increase this number.</p>
</td></tr>
<tr><td><code id="classifly_+3A_method">method</code></td>
<td>
<p>method to simulate points: grid, random or nonaligned
(default).  See <code><a href="#topic+simvar">simvar</a></code> for more details on the methods
used.</p>
</td></tr>
<tr><td><code id="classifly_+3A_type">type</code></td>
<td>
<p>type of scaling to apply to data.  Defaults to commmon range.
See <code><a href="reshape.html#topic+rescaler">rescaler</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default in GGobi, points that are not on the boundary (ie. that have an
advantage greater than the 5
to brush mode and choose include shadowed points from the brush menu on
the plot window.  You can then brush them yourself to explore how the
certainty of classification varies throughout the space
</p>
<p>Special notes:
</p>

<ul>
<li><p> You should make sure the response variable is a factor
</p>
</li>
<li><p> For SVM, make sure to include <code>probability = TRUE</code> in the
arguments to <code>classifly</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+explore">explore</a></code>, <a href="http://had.co.nz/classifly">http://had.co.nz/classifly</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kyphosis, package = "rpart")
library(MASS)
classifly(kyphosis, Kyphosis ~ . , lda)
classifly(kyphosis, Kyphosis ~ . , qda)
classifly(kyphosis, Kyphosis ~ . , glm, family="binomial")
classifly(kyphosis, Kyphosis ~ . , knnf, k=3)

library(rpart)
classifly(kyphosis, Kyphosis ~ . , rpart)


if (require("e1071")) {
classifly(kyphosis, Kyphosis ~ . , svm, probability=TRUE)
classifly(kyphosis, Kyphosis ~ . , svm, probability=TRUE, kernel="linear")
classifly(kyphosis, Kyphosis ~ . , best.svm, probability=TRUE,
   kernel="linear")

# Also can use explore directorly
bsvm &lt;- best.svm(Species~., data = iris, gamma = 2^(-1:1),
  cost = 2^(2:+ 4), probability=TRUE)
explore(bsvm, iris)
}

</code></pre>

<hr>
<h2 id='classify'>Extract classifications from a variety of methods.</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>If the classification method can produce a matrix of posterior
probabilities (see <code><a href="#topic+posterior">posterior</a></code>), then that will be used to
calculate the <code><a href="#topic+advantage">advantage</a></code>.  Otherwise, the classify method
will be used and the advantage calculated using a k-nearest neighbours
approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="classify_+3A_data">data</code></td>
<td>
<p>data set used in model</p>
</td></tr>
<tr><td><code id="classify_+3A_...">...</code></td>
<td>
<p>other argument passed on to methods</p>
</td></tr>
</table>

<hr>
<h2 id='explore'>Default method for exploring objects</h2><span id='topic+explore'></span>

<h3>Description</h3>

<p>The default method currently works for classification
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore(model, data, n = 10000, method = "nonaligned", advantage = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explore_+3A_model">model</code></td>
<td>
<p>classification object</p>
</td></tr>
<tr><td><code id="explore_+3A_data">data</code></td>
<td>
<p>data set used with classifier</p>
</td></tr>
<tr><td><code id="explore_+3A_n">n</code></td>
<td>
<p>number of points to generate when searching for boundaries</p>
</td></tr>
<tr><td><code id="explore_+3A_method">method</code></td>
<td>
<p>method to generate points, see <code><a href="#topic+generate_data">generate_data</a></code></p>
</td></tr>
<tr><td><code id="explore_+3A_advantage">advantage</code></td>
<td>
<p>only display boundaries</p>
</td></tr>
<tr><td><code id="explore_+3A_...">...</code></td>
<td>
<p>other arguments not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It generates a data set filling the design space, finds
class boundaries (if desired) and then displays in a new
ggobi instance.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+invisible">invisible</a></code> data frame of class <code>classifly</code>
that contains all the simulated and true data.  This can be saved and
then printed later to open with rggobi.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_classification_data">generate_classification_data</a></code>,
<a href="http://had.co.nz/classifly">http://had.co.nz/classifly</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("e1071")) {
bsvm &lt;- best.svm(Species~., data = iris, gamma = 2^(-1:1),
  cost = 2^(2:+ 4), probability=TRUE)
explore(bsvm, iris)
}
</code></pre>

<hr>
<h2 id='generate_classification_data'>Generate classification data.</h2><span id='topic+generate_classification_data'></span>

<h3>Description</h3>

<p>Given a model, this function generates points within
the range of the data, classifies them, and attempts to locate boundaries
by looking at advantage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_classification_data(model, data, n, method, advantage)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_classification_data_+3A_model">model</code></td>
<td>
<p>classification model</p>
</td></tr>
<tr><td><code id="generate_classification_data_+3A_data">data</code></td>
<td>
<p>data set used in model</p>
</td></tr>
<tr><td><code id="generate_classification_data_+3A_n">n</code></td>
<td>
<p>number of points to generate</p>
</td></tr>
<tr><td><code id="generate_classification_data_+3A_method">method</code></td>
<td>
<p>method to use, currently either grid (an evenly spaced grid),
random (uniform random distribution across cube), or nonaligned (grid +
some random peturbationb)</p>
</td></tr>
<tr><td><code id="generate_classification_data_+3A_advantage">advantage</code></td>
<td>
<p>if <code>TRUE</code>, compute advantage, otherwise don't</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If posterior probabilities of classification are available, then the
<code><a href="#topic+advantage">advantage</a></code> will be calculated directly.  If not,
<code><a href="class.html#topic+knn">knn</a></code> is used calculate the advantage based on the number of
neighbouring points that share the same classification.  Because knn is
$O(n^2)$ this method is rather slow for large (&gt;20,000 say) data sets.
</p>
<p>By default, the boundary points are identified
as those below the 5th-percentile for advantage.
</p>


<h3>Value</h3>

<p>data.frame of classified data
</p>

<hr>
<h2 id='generate_data'>Generate new data from a data frame.</h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p>This method generates new data that fills the range of
the supplied datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(data, n = 10000, method = "grid")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="generate_data_+3A_n">n</code></td>
<td>
<p>desired number of new observations</p>
</td></tr>
<tr><td><code id="generate_data_+3A_method">method</code></td>
<td>
<p>method to use, see <code><a href="#topic+simvar">simvar</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='knnf'>A wrapper function for <code><a href="class.html#topic+knn">knn</a></code> to allow use
with classifly.</h2><span id='topic+knnf'></span>

<h3>Description</h3>

<p>A wrapper function for <code><a href="class.html#topic+knn">knn</a></code> to allow use
with classifly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knnf(formula, data, k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knnf_+3A_formula">formula</code></td>
<td>
<p>classification formula</p>
</td></tr>
<tr><td><code id="knnf_+3A_data">data</code></td>
<td>
<p>training data set</p>
</td></tr>
<tr><td><code id="knnf_+3A_k">k</code></td>
<td>
<p>number of neighbours to use</p>
</td></tr>
</table>

<hr>
<h2 id='olives'>Olives</h2><span id='topic+olives'></span>

<h3>Description</h3>

<p>The olive oil data consists of the percentage composition of 8 fatty
acids (palmitic, palmitoleic, stearic, oleic, linoleic, linolenic,
arachidic, eicosenoic) found in the lipid fraction of 572 Italian
olive oils. There are 9 collection areas, 4 from southern Italy (North
and South Apulia, Calabria, Sicily), two from Sardinia (Inland and
Coastal) and 3 from northern Italy (Umbria, East and West
Liguria).
</p>


<h3>Format</h3>

<p>A data frame with 244 rows and 7 variables
</p>


<h3>References</h3>

<p>Forina, M. and Armanino, C. and Lanteri, S. and
Tiscornia, E., Classification of olive oils from their fatty acid
composition, 1983, in Food Research and Data Analysis, edited by
Martens, H. and Russwurm Jr, H, pages 189-214.
</p>

<hr>
<h2 id='posterior'>Extract posterior group probabilities</h2><span id='topic+posterior'></span>

<h3>Description</h3>

<p>Every classification method seems to provide a slighly different
way of retrieving the posterior probability of group membership.  This
function provides a common interface to all of them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior(model, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="posterior_+3A_data">data</code></td>
<td>
<p>data set used in model</p>
</td></tr>
</table>

<hr>
<h2 id='simvar'>Simulate observations from a vector</h2><span id='topic+simvar'></span>

<h3>Description</h3>

<p>Given a vector of data this function will simulate
data that could have come from that vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simvar(x, n = 10, method = "grid")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simvar_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="simvar_+3A_n">n</code></td>
<td>
<p>desired number of points (will not always be achieved)</p>
</td></tr>
<tr><td><code id="simvar_+3A_method">method</code></td>
<td>
<p>grid simulation method.  See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three methods to choose from:
</p>

<ul>
<li><p> nonaligned (default): grid + some random peturbation
</p>
</li>
<li><p> grid: grid of evenly spaced observations.  If a factor,
all levels in a factor will be used, regardless of n
</p>
</li>
<li><p> random: a random uniform sample from the range of the variable
</p>
</li></ul>


<hr>
<h2 id='variables'>Extract predictor and response variables for a model object.</h2><span id='topic+variables'></span>

<h3>Description</h3>

<p>Due to the way that most model objects are stored, you
also need to supply the data set you used with the original
data set.  It currently doesn't support models fitted without
using a data argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variables(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variables_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing response and predictor variables
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
