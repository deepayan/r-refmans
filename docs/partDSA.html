<!DOCTYPE html><html><head><title>Help for package partDSA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {partDSA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dumpDSA'><p>dumpDSA</p></a></li>
<li><a href='#loglevel'><p>Set Logging Level</p></a></li>
<li><a href='#partDSA'><p>partDSA</p></a></li>
<li><a href='#predict.dsa'><p>predict.dsa</p></a></li>
<li><a href='#print.dsa'><p>Print a partDSA Object</p></a></li>
<li><a href='#showDSA'><p>showDSA</p></a></li>
<li><a href='#trim'><p>trim</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Partitioning Using Deletion, Substitution, and Addition Moves</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.14</td>
</tr>
<tr>
<td>Author:</td>
<td>Annette Molinaro &lt;annette.molinaro@ucsf.edu&gt;,
        Adam Olshen &lt;olshena@biostat.ucsf.edu&gt;,
        Karen Lostritto &lt;karen.lostritto@yale.edu&gt;, 
        Gregory Ryslik &lt;gregory.ryslik@yale.edu&gt;,
        Steve Weston &lt;stephen.weston@yale.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Annette Molinaro &lt;annette.molinaro@ucsf.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A novel tool for generating a piecewise
        constant estimation list of increasingly complex predictors
        based on an intensive and comprehensive search over the entire
        covariate space.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5), survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, MASS, TH.data, VGAM</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-04 18:44:19 UTC; annettemolinaro</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-05 10:39:59</td>
</tr>
</table>
<hr>
<h2 id='dumpDSA'>dumpDSA</h2><span id='topic+dumpDSA'></span>

<h3>Description</h3>

<p><code>dumpDSA</code> is used to create an XML file containing
visualization information for a partDSA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dumpDSA(x, file=stdout())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dumpDSA_+3A_x">x</code></td>
<td>
<p><code>partDSA</code> or <code>dsa</code> object to be dumped.</p>
</td></tr>
<tr><td><code id="dumpDSA_+3A_file">file</code></td>
<td>
<p>file to write data to.</p>
</td></tr>
</table>

<hr>
<h2 id='loglevel'>Set Logging Level</h2><span id='topic+loglevel'></span>

<h3>Description</h3>

<p><code>loglevel</code> is used to set the logging level for the DSA package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglevel(lev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglevel_+3A_lev">lev</code></td>
<td>
<p>The default level to use.  The level can be specified
as <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>,
or <code>verbose</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>loglevel(debug)
</code></pre>

<hr>
<h2 id='partDSA'>partDSA</h2><span id='topic+partDSA'></span><span id='topic+DSA.control'></span>

<h3>Description</h3>

<p><em>partDSA</em> is a novel tool for generating a piecewise constant
estimation sieve of candidate estimators based on an intensive and
comprehensive search over the entire covariate space. The strength of
this algorithm is that it builds <em>'and'</em> and <em>'or'</em>
statements. This allows combinations and substitutions of regions for
the purpose of discovering intricate correlations patterns and
interactions in addition to main effects. Depending on the application,
this approach will supersede methods such as CART by being not only
more aggressive but also more flexible. As such, <em>partDSA</em> provides
the user an additional tool for their statistical toolbox.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
partDSA(x, y, wt=rep(1, nrow(x)), x.test=x, y.test=y, wt.test,
        control=DSA.control(), sleigh)
DSA.control(vfold=10, minsplit = 20, minbuck=round(minsplit/3), 
                        cut.off.growth=10, MPD=0.1, missing="impute.at.split", 
                        loss.function="default", wt.method="KM", brier.vec=NULL,
                        leafy=0, leafy.random.num.variables.per.split=4,
                        leafy.num.trees=50, leafy.subsample=0, save.input=FALSE, 
                        boost=0, boost.rounds=100, cox.vec=NULL,IBS.wt=NULL, partial=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partDSA_+3A_x">x</code></td>
<td>
<p>The matrix or data frame of predictor variables for the training set,
used to build the model.
Each row corresponds to an observation, and each column corresponds to
a variable.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_y">y</code></td>
<td>
<p>The outcome (response) vector, either continuous or categorical,
representing the true response values for observations in <code>x</code>.
The length of this vector should equal the number of rows in <code>x</code>.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_wt">wt</code></td>
<td>
<p>Optional vector  of training weights with length equal to the
number of observations in <code>x</code>.
Default is a vector of ones with length equal to the number of training
set observations.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_x.test">x.test</code></td>
<td>
<p>The matrix or data frame of predictor variables used to
build the model.
The number of columns (variables) of <code>x.test</code> should equal the number
of columns as <code>x</code>.
The default is <code>x</code>.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_y.test">y.test</code></td>
<td>
<p>The outcome (response) vector, either continuous or categorical,
representing the true response values for observations in <code>x.test</code>.
The length of this vector should equal the number of rows in <code>x.test</code>.
The default value is <code>y</code>.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_wt.test">wt.test</code></td>
<td>
<p>Optional vector of test weights with length equal to the
number of test set observations.
Default value is <code>wt</code> if <code>x.test</code> wasn't specified, otherwise
it is a vector of ones with length  equal to the number of test
set observations.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_control">control</code></td>
<td>
<p>A list object used to specify additional control parameters.
This is normally created by calling the <code>DSA.control</code> function.
Default value is the result of calling <code>DSA.control</code> with no arguments.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_sleigh">sleigh</code></td>
<td>
<p>Optional <code>sleigh</code> object to allow the cross-validation
to be performed in parallel using the <code>nws</code> package.
If not specified, the cross-validation will be executed sequentially.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_vfold">vfold</code></td>
<td>
<p>The number of folds of cross-validation for the model
building process.
The default value is 10.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of observations in order to split a partition into two paritions. 
The default value is 20.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_minbuck">minbuck</code></td>
<td>
<p>The minimum number of observations in any terminal partition.
The default value is round(minsplit/3).</p>
</td></tr>
<tr><td><code id="partDSA_+3A_cut.off.growth">cut.off.growth</code></td>
<td>
<p>The maximum number of terminal partitions to be
considered when building the model.
The default value is 10.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_mpd">MPD</code></td>
<td>
<p>Minimum Percent Difference.
The model fit must improve by this percentage in order to be considered.
This saves time in the model building process.
The default value is 0.1.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_missing">missing</code></td>
<td>
<p>Character string specifying how missing data should be
handled.  The default value is &quot;no.&quot; See the details section from more information.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_loss.function">loss.function</code></td>
<td>
<p>The function to be minimized when building the model.
For categorical outcomes, &quot;entropy&quot; (default) or &quot;gini&quot; can be specified.
For continuous outcomes, the L2 loss function is used.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_wt.method">wt.method</code></td>
<td>
<p>Not documented yet.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_brier.vec">brier.vec</code></td>
<td>
<p>Not documented yet.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_cox.vec">cox.vec</code></td>
<td>
<p>Not documented yet.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_ibs.wt">IBS.wt</code></td>
<td>
<p>Not documented yet.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_leafy">leafy</code></td>
<td>
<p>Set to 1 to run Bagged partDSA.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_leafy.random.num.variables.per.split">leafy.random.num.variables.per.split</code></td>
<td>
<p>Number of variables to use
if utilizing random variable selection in Bagged partDSA.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_leafy.num.trees">leafy.num.trees</code></td>
<td>
<p>Numbed in trees in Bagged partDSA.  Default is 50.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_leafy.subsample">leafy.subsample</code></td>
<td>
<p>Numeric value between 0 and 1.  The value 0 is
used for bootstrap sampling (sampling witht replacement).  If the
value is greater than 0, it corresponds to the proportion of samples
used to build the model, such as 0.632.  The default is 0.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_save.input">save.input</code></td>
<td>
<p>Indicates if <code>x</code> and <code>y</code> should be saved
in the object returned by partDSA.  If <code>FALSE</code>, <code>x</code> and <code>y</code>
are set to <code>NULL</code>.  The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_boost">boost</code></td>
<td>
<p>Set to 1 to run Boosted partDSA.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_boost.rounds">boost.rounds</code></td>
<td>
<p>Maximum number of rounds of boosting.  Default is
100.</p>
</td></tr>
<tr><td><code id="partDSA_+3A_partial">partial</code></td>
<td>
<p>If set to &quot;deciles,&quot; step partial importance is computed
on deciles of data rather than actual data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>missing</code> set to &quot;no&quot; indicates that there is no missing data and
will create an error if missing data is found in the dataset. Setting missing=&quot;impute.at.split&quot; will use a data
imputation method similar to that in CRUISE (Kim and Loh, 2001). At each
split, the non-missing observations for a given variable will be used
to find the best split, and the missing observations will be imputed
based on the mean or mode (depending on whether the variable is
categorical or continuous) of the non-missing observations in that node.
Once the node assignment of these missing observations is determined
using the imputed values, the imputed values are returned to their
missing status. For missing values in the test set, the grand mean or
mode from the corresponding variables in the training set are used.
Including variables which are entirely missing will result in an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
set.seed(6442)

n &lt;- nrow(Boston)
tr.n &lt;- floor(n / 2)
train.index &lt;- sample(1:n, tr.n, replace=FALSE)
test.index &lt;- (1:n)[-train.index]

x &lt;- Boston[train.index, -14]
y &lt;- Boston[train.index, 14]
x.test &lt;- Boston[test.index, -14]
y.test &lt;- Boston[test.index, 14]

control &lt;- DSA.control(vfold=1)  # no cross-validation
partDSA(x, y, x.test=x.test, y.test=y.test, control=control)
</code></pre>

<hr>
<h2 id='predict.dsa'>predict.dsa</h2><span id='topic+predict.dsa'></span>

<h3>Description</h3>

<p>Predicted values based on the DSA algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsa'
predict(object, newdata1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dsa_+3A_object">object</code></td>
<td>
<p>a <code>partDSA</code> or <code>dsa</code> object.</p>
</td></tr>
<tr><td><code id="predict.dsa_+3A_newdata1">newdata1</code></td>
<td>
<p>a data frame in which to look for variables with
which to predict.</p>
</td></tr>
<tr><td><code id="predict.dsa_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>

<hr>
<h2 id='print.dsa'>Print a partDSA Object</h2><span id='topic+print.partDSA'></span><span id='topic+print.dsa'></span>

<h3>Description</h3>

<p>These functions print <code>partDSA</code> and <code>dsa</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partDSA'
print(x, ...)
## S3 method for class 'dsa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dsa_+3A_x">x</code></td>
<td>

<p>fitted model object of class <code>partDSA</code> or <code>dsa</code>.
These are the result of calling the <code>partDSA</code>
or <code>rss.dsa</code> functions.
</p>
</td></tr>
<tr><td><code id="print.dsa_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>

<hr>
<h2 id='showDSA'>showDSA</h2><span id='topic+showDSA'></span><span id='topic+showDSA.dsa'></span><span id='topic+showDSA.character'></span>

<h3>Description</h3>

<p><code>showDSA</code> is a convenience function that starts the Java
visualization program (included in the partDSA package) to display
information about the model created by <code>partDSA</code> function.
There are two methods: one taking a partDSA/dsa object, the
other taking the name of a visualization file created via the
<code>dumpDSA</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showDSA(x, javacmd=getOption("javacmd"), quietly=FALSE, ...)
## S3 method for class 'dsa'
showDSA(x, javacmd=getOption("javacmd"), quietly=FALSE, ...)
## S3 method for class 'character'
showDSA(x, javacmd=getOption("javacmd"), quietly=FALSE, wait=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showDSA_+3A_x">x</code></td>
<td>
<p><code>dsa</code> object or the name of the visualization file to be shown.</p>
</td></tr>
<tr><td><code id="showDSA_+3A_javacmd">javacmd</code></td>
<td>
<p>A character string giving the path of the Java interpreter.
Defaults to <code>getOption("javacmd")</code>, which is not set by default,
in which case, &quot;java&quot; is used.</p>
</td></tr>
<tr><td><code id="showDSA_+3A_quietly">quietly</code></td>
<td>
<p>A logical value indicating if messages should be suppressed.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="showDSA_+3A_wait">wait</code></td>
<td>
<p>A logical value indicating if the R session should wait until the
the Java program exits before continuing.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="showDSA_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Java 1.5 or greater is required to run these functions, although Java 1.6
is recommended.  The Java interpreter should be in the command search
path, unless either the <code>javacmd</code> option is set, or the
<code>javacmd</code> argument is specified.
</p>

<hr>
<h2 id='trim'>trim</h2><span id='topic+trim'></span><span id='topic+trim.partDSA'></span><span id='topic+trim.dsa'></span>

<h3>Description</h3>

<p><code>trim</code> is used to trim, or prune, the model object
returned by the <code>partDSA</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(object, ...)
## S3 method for class 'partDSA'
trim(object, cut.off.growth, ...)
## S3 method for class 'dsa'
trim(object, cut.off.growth, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_object">object</code></td>
<td>
<p><code>partDSA</code> or <code>dsa</code> object to be trimmed.</p>
</td></tr>
<tr><td><code id="trim_+3A_cut.off.growth">cut.off.growth</code></td>
<td>
<p>number of the level to trim to.</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
