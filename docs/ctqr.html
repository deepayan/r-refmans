<!DOCTYPE html><html lang="en"><head><title>Help for package ctqr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctqr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ctqr-package'><p>Censored and Truncated Quantile Regression</p></a></li>
<li><a href='#ctqr'>
<p>Censored and Truncated Quantile Regression</p></a></li>
<li><a href='#ctqr.control'>
<p>Auxiliary Function for Root Search</p></a></li>
<li><a href='#internals'><p>Internal Functions</p></a></li>
<li><a href='#plot.ctqr'>
<p>Plot Quantile Regression Coefficients</p></a></li>
<li><a href='#predict.ctqr'>
<p>Prediction After Quantile Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Censored and Truncated Quantile Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Paolo Frumento</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paolo Frumento &lt;paolo.frumento@unipi.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of quantile regression models for survival data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, pch (&ge; 2.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car, lmtest</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 17:39:44 UTC; a020554</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 19:30:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='ctqr-package'>Censored and Truncated Quantile Regression</h2><span id='topic+ctqr-package'></span>

<h3>Description</h3>

<p>Fit quantile regression models to survival data, allowing for right censoring, left truncation, and interval censoring.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ctqr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main function <code><a href="#topic+ctqr">ctqr</a></code> is used for model fitting. Other documented functions are <code><a href="#topic+predict.ctqr">predict.ctqr</a></code>, to obtain prediction from a <code>ctqr</code> object, <code><a href="#topic+plot.ctqr">plot.ctqr</a></code>, to plot quantile regression coefficients, and <code><a href="#topic+ctqr.control">ctqr.control</a></code>, that can be used to set the operational parameters for the estimation algorithm.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento
</p>
<p>Maintainer: Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>References</h3>

<p>Frumento, P., and Bottai, M. (2017). An estimating equation for censored and truncated quantile regression. <em>Computational Statistics and Data Analysis</em>, Vol.113, pp.53-63. ISSN: 0167-9473.
</p>
<p>Frumento, P. (2022). A quantile regression estimator for interval-censored data. <em>The International Journal of Biostatistics</em>, 19 (1), pp. 81-96.
</p>


<h3>See Also</h3>

<p><code>pchreg</code>, that is used to compute a preliminary estimate of the conditional outcome distribution.
</p>

<hr>
<h2 id='ctqr'>
Censored and Truncated Quantile Regression
</h2><span id='topic+ctqr'></span>

<h3>Description</h3>

<p>Fits a quantile regression model to possibly censored and truncated data, e.g., survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctqr(formula, data, weights, p = 0.5, CDF, control = ctqr.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctqr_+3A_formula">formula</code></td>
<td>

<p>an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo;: a symbolic description of the regression model. 
The response must be a <kbd>Surv</kbd> object as returned by <code><a href="survival.html#topic+Surv">Surv</a></code> (see &lsquo;Details&rsquo;).
</p>
</td></tr>
<tr><td><code id="ctqr_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model.
</p>
</td></tr>
<tr><td><code id="ctqr_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. The weights will always be normalized to sum to the sample size. This implies that, for example, using double weights will not halve the standard errors.
</p>
</td></tr>
<tr><td><code id="ctqr_+3A_p">p</code></td>
<td>

<p>numerical vector indicating the order of the quantile(s) to be fitted.
</p>
</td></tr>
<tr><td><code id="ctqr_+3A_cdf">CDF</code></td>
<td>

<p>an object of class &ldquo;<code>pch</code>&rdquo;, i.e., the result of a call to <code>pchreg</code>. If missing, 
it will be computed internally with default settings. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="ctqr_+3A_control">control</code></td>
<td>

<p>a list of operational parameters for the optimization algorithm, usually passed via <code><a href="#topic+ctqr.control">ctqr.control</a></code>.
</p>
</td></tr>
<tr><td><code id="ctqr_+3A_...">...</code></td>
<td>
<p>for future arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the method described in Frumento and Bottai (2017) for censored, truncated quantile regression, and Frumento (2022) for interval-censored quantile regression.
</p>
<p>The left side of <kbd>formula</kbd> must be of the form <kbd>Surv(time, event)</kbd> if the data are right-censored, <kbd>Surv(time0, time, event)</kbd> if the data are right-censored and left-truncated (<kbd>time0 &lt; time</kbd>, <code>time0</code> can be <kbd>-Inf</kbd>), and <kbd>Surv(time1, time2, type = "interval2")</kbd> if the data are interval-censored (use <kbd>time1 = time2</kbd> for exact observations, <kbd>time1 = -Inf</kbd> or <kbd>NA</kbd> for left-censored, and <kbd>time2 = Inf</kbd> or <kbd>NA</kbd> for right-censored). Using <kbd>Surv(time)</kbd> is also allowed and indicates that the data are neither censored nor truncated.
</p>
<p>The conditional distribution function (<code>CDF</code>) of the response variable represents a nuisance parameter 
and is estimated preliminarly via <code>pchreg</code>. If missing, <code>CDF = pchreg(formula)</code> is used as default. See the &ldquo;Note&rdquo; and the documentation of <code>pchreg</code>.
</p>
<p>Estimation is carried out using an algorithm for gradient-based optimization. 
To estimate the asymptotic covariance matrix, standard two-step procedures are used
(e.g., Ackerberg et al., 2012).
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>ctqr</code>&rdquo;, which is a list with the following items:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>the quantile(s) being estimated.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector or matrix of quantile regression coefficients.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. The convergence status.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used.</p>
</td></tr>
<tr><td><code>mf</code></td>
<td>
<p>the model frame used.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>the estimated asymptotic covariance matrix.</p>
</td></tr>
<tr><td><code>CDF</code></td>
<td>
<p>the used <code>CDF</code>.</p>
</td></tr>
</table>
<p>Note that the dimension of all items, except <code>call</code>, <code>terms</code>, <code>mf</code>, and <code>CDF</code>,
is the same as the dimension of <kbd>p</kbd>. For example, if <code>p = c(0.25,0.5,0.75)</code>, <code>coefficients</code>
and <code>fitted</code> will be 3-columns matrices; <code>n.it</code> and <code>converged</code> will be vectors of 3 elements; 
and <code>covar</code> will be a list of three covariance matrices.
</p>
<p>The generic accessor functions <code>summary</code>, <code>plot</code>, <code>predict</code>, <code>coef</code>, <code>terms</code>, <code>nobs</code>, 
can be used to extract information from the model. The functions
<code>waldtest</code> (from the package <span class="pkg">lmtest</span>), and <code>linearHypothesis</code> (from the package <span class="pkg">car</span>) can be 
used to perform Wald test, and to test linear restrictions. These functions, however, 
will only work if <code>p</code> is scalar.
</p>


<h3>Note</h3>

<p>NOTE 1. The first-step estimator (the <kbd>CDF</kbd> argument) is computed using the <code>pchreg</code> function of the
<span class="pkg">pch</span> package. To be correctly embedded in <kbd>ctqr</kbd>, a <kbd>pch</kbd> object must be constructed using  
the same observations, in the same order. 
</p>
<p>If the first-step estimator is biased, and there is censoring or truncation,
the estimates of the quantile regression coefficients and their standard errors will also be biased. 
</p>
<p>If the data are neither censored nor truncated, the <code>CDF</code> does not enter the estimating equation of the model. However, since the first-step estimator is used to compute the starting points, 
the final estimates may be sensitive to the supplied <code>CDF</code>.
</p>
<p>NOTE 2. Right-censoring is a special case of interval censoring, in which exact events are identified by <code>time2 = time1</code>, while censored observations have <code>time2 = Inf</code>. Note, however, that <code>ctqr(Surv(time1, time2, type = "interval2") ~ x)</code> will not be identical to <code>ctqr(Surv(time = time1, event = (time2 &lt; Inf)) ~ x)</code>. The estimating equation used for interval-censored data is that described in Frumento (2022), while that used for right-censored data is that of Frumento and Bottai (2017). The two estimating equations are only asymptotically equivalent.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>References</h3>

<p>Ackerberg, D., Chen, X., and Hahn, J. (2012). A practical asymptotic variance estimator 
for two-step semiparametric estimators. The Review of Economics and Statistics, 94 (2), 481-498.
</p>
<p>Frumento, P., and Bottai, M. (2017). An estimating equation for censored and truncated quantile regression. <em>Computational Statistics and Data Analysis</em>, Vol.113, pp.53-63. ISSN: 0167-9473.
</p>
<p>Frumento, P. (2022). A quantile regression estimator for interval-censored data. <em>The International Journal of Biostatistics</em>, 19 (1), pp. 81-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ctqr">plot.ctqr</a></code>, <code><a href="#topic+predict.ctqr">predict.ctqr</a></code>, <code>pchreg</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using simulated data


# Example 1 - censored data ####################################################

n &lt;- 1000
x1 &lt;- runif(n); x2 &lt;- runif(n)   # covariates
t &lt;- runif(n, 0, 1 + x1 + x2)    # time variable (e.g., time to death)
c &lt;- runif(n,0,5)                # censoring variable (e.g., end of follow-up)
y &lt;- pmin(t,c)                   # observed variable = min(t,c)
d &lt;- (t &lt;= c)                    # 1 = event (e.g., death), 0 = censored

CDF1 &lt;- pchreg(Surv(y,d) ~ x1 + x2)
model1 &lt;- ctqr(Surv(y,d) ~ x1 + x2, p = 0.5, CDF = CDF1)
model2 &lt;- ctqr(Surv(y,d) ~ x1, p = 0.5, CDF = CDF1)

# model1 is identical to ctqr(Surv(y,d) ~ x1 + x2, p = 0.5)
# model2 is NOT identical to ctqr(Surv(y,d) ~ x1, p = 0.5), 
  # which would have default CDF = pchreg(Surv(y,d) ~ x1)


# Example 2 - censored and truncated data ######################################

n &lt;- 1000
x1 &lt;- runif(n); x2 &lt;- runif(n)   # covariates
t &lt;- runif(n, 0, 1 + x1 + x2)    # time variable
c &lt;- runif(n,0,5)                # censoring variable
y &lt;- pmin(t,c)                   # observed variable = min(t,c)
d &lt;- (t &lt;= c)                    # 1 = event, 0 = censored

z &lt;- rnorm(n) # truncation variable (e.g., time at enrollment)
w &lt;- which(y &gt; z) # data are only observed when y &gt; z
z &lt;- z[w]; y &lt;- y[w]; d &lt;- d[w]; x1 &lt;- x1[w]; x2 &lt;- x2[w]

# implement various CDFs and choose the model with smallest AIC

CDFs &lt;- list(
  pchreg(Surv(z,y,d) ~ x1 + x2, breaks = 5),
  pchreg(Surv(z,y,d) ~ x1 + x2, breaks = 10),
  pchreg(Surv(z,y,d) ~ x1 + x2 + x1:x2, breaks = 5),
  pchreg(Surv(z,y,d) ~ x1 + x2 + x1^2 + x2^2, breaks = 10)
)

CDF &lt;- CDFs[[which.min(sapply(CDFs, function(obj) AIC(obj)))]]
summary(ctqr(Surv(z,y,d) ~ x1 + x2, p = 0.5, CDF = CDF))


# Example 3 - interval-censored data ###########################################
# t is only known to be in the interval (t1,t2) ################################

n &lt;- 1000
x1 &lt;- runif(n); x2 &lt;- runif(n)     # covariates
t &lt;- runif(n, 0, 10*(1 + x1 + x2)) # time variable
t1 &lt;- floor(t)                     # lower extreme of the interval
t2 &lt;- ceiling(t)                   # upper extreme of the interval

model &lt;- ctqr(Surv(t1,t2, type = "interval2") ~ x1 + x2, p = 0.5)
</code></pre>

<hr>
<h2 id='ctqr.control'>
Auxiliary Function for Root Search
</h2><span id='topic+ctqr.control'></span>

<h3>Description</h3>

<p>This functions can be used within a call to <code><a href="#topic+ctqr">ctqr</a></code>, 
to control the operational parameters of the root search algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctqr.control(tol = 1e-06, maxit = 1000, a = 0.5, b = 1.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctqr.control_+3A_tol">tol</code></td>
<td>

<p>positive convergence tolerance: the algorithm stops when the maximum 
absolute change between two consecutive estimates is smaller than <kbd>tol</kbd>.
</p>
</td></tr>
<tr><td><code id="ctqr.control_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="ctqr.control_+3A_a">a</code>, <code id="ctqr.control_+3A_b">b</code></td>
<td>

<p>numeric scalar with <kbd>0 &lt; a &lt; 1</kbd> and <kbd>b &gt; 1</kbd>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a current estimate <kbd>beta</kbd>, a new estimate is computed as 
<kbd>beta_new = beta + delta*s(beta)</kbd>, where <kbd>s(beta)</kbd> is the current 
value of the estimating equation and <kbd>delta</kbd> is a positive multiplier. 
If <kbd>sum(s(beta_new)^2) &lt; sum(s(beta)^2)</kbd>, the iteration is accepted and 
<kbd>delta</kbd> is multiplied by <kbd>b</kbd>. Otherwise, <kbd>beta_new</kbd> is rejected and 
<kbd>delta</kbd> is multiplied by <kbd>a</kbd>. By default, <kbd>a = 0.5</kbd> and <kbd>b = 1.25</kbd>. 
Choosing <kbd>a,b</kbd> closer to <kbd>1</kbd> may result in a more accurate estimate, 
but will require a larger number of iterations.
</p>


<h3>Value</h3>

<p>The function returns its arguments. If some was not correctly specified, it is set to its default and a warning message is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctqr">ctqr</a></code>
</p>

<hr>
<h2 id='internals'>Internal Functions</h2><span id='topic+internals'></span><span id='topic+findagoodestimator'></span><span id='topic+safe.pch'></span><span id='topic+quickpred'></span><span id='topic+check.in.ctqr'></span><span id='topic+start'></span><span id='topic+ee.u'></span><span id='topic+ee.cens'></span><span id='topic+ee.cens.trunc'></span><span id='topic+ee.icens'></span><span id='topic+qr_gs'></span><span id='topic+nobs.ctqr'></span><span id='topic+vcov.ctqr'></span><span id='topic+coef.ctqr'></span><span id='topic+print.ctqr'></span><span id='topic+summary.ctqr'></span><span id='topic+print.summary.ctqr'></span><span id='topic+firstep.ct'></span><span id='topic+firstep.ic'></span><span id='topic+asy.qr.ct'></span><span id='topic+asy.qr.ic'></span><span id='topic+safesolve'></span><span id='topic+regularize_corr'></span>

<h3>Description</h3>

<p>Functions for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findagoodestimator(dat,w,type)
safe.pch(obj, eps = 1e-6)
quickpred(obj,y)
check.in.ctqr(z,y,d,x,off,weights, breaks)
start(CDF, p, x, y, off, weights) 
ee.u(beta, tau, CDF, V)
ee.cens(beta, tau, CDF, V)
ee.cens.trunc(beta, tau, CDF, V)
ee.icens(beta, tau, CDF, V)
qr_gs(beta0, check, p, CDF, a = 0.5, b = 1.5, maxit = 1000, tol = 1e-6, type)

## S3 method for class 'ctqr'
nobs(object, ...)
## S3 method for class 'ctqr'
vcov(object, ...)
## S3 method for class 'ctqr'
coef(object, ...)
## S3 method for class 'ctqr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'ctqr'
summary(object, ...)
## S3 method for class 'ctqr'
print.summary(x, digits = max(3L, getOption("digits") - 3L), ...)

firstep.ct(obj, z,y,d,w)
firstep.ic(obj, y)
asy.qr.ct(z,y,d,x, weights, p, fit, fit.ok)
asy.qr.ic(z,y,d,x, weights, p, fit, fit.ok)

safesolve(A)
regularize_corr(A, c = 0.9)
</code></pre>

<hr>
<h2 id='plot.ctqr'>
Plot Quantile Regression Coefficients
</h2><span id='topic+plot.ctqr'></span>

<h3>Description</h3>

<p>Plots quantile regression coefficients 
<code class="reqn">\beta(p)</code> as a function of <code class="reqn">p</code>,
based on a fitted model of class &ldquo;<code>ctqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctqr'
plot(x, which = NULL, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ctqr_+3A_x">x</code></td>
<td>

<p>an object of class &ldquo;<code>ctqr</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="plot.ctqr_+3A_which">which</code></td>
<td>

<p>an optional numerical vector indicating which coefficient(s) to plot. If <kbd>which = NULL</kbd>, 
all coefficients are plotted.
</p>
</td></tr>
<tr><td><code id="plot.ctqr_+3A_ask">ask</code></td>
<td>
<p>logical. If <kbd>which = NULL</kbd> and <kbd>ask = TRUE</kbd> (the default), you will be asked
interactively which coefficients to plot.</p>
</td></tr>
<tr><td><code id="plot.ctqr_+3A_...">...</code></td>
<td>
<p>additional graphical parameters, that can include <kbd>xlim, ylim, xlab, ylab, col, lwd</kbd>. 
See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this command, a plot of <code class="reqn">\beta(p)</code> versus <code class="reqn">p</code> is created, provided that at least
two quantiles have been estimated. Dashed lines represent 95% confidence intervals, while the horizontal dotted line indicates the zero.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctqr">ctqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # using simulated data
  
  n &lt;- 1000
  x &lt;- runif(n)
  t &lt;- 1 + x + rexp(n)
  c &lt;- runif(n, 1,10)
  y &lt;- pmin(c,t)
  d &lt;- (t &lt;= c)
  
  par(mfrow = c(1,2))
  plot(ctqr(Surv(y,d) ~ x, p = seq(0.05,0.95,0.05)), ask = FALSE) 
</code></pre>

<hr>
<h2 id='predict.ctqr'>
Prediction After Quantile Regression
</h2><span id='topic+predict.ctqr'></span>

<h3>Description</h3>

<p>This function returns predictions for an object of class &ldquo;<code>ctqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctqr'
predict(object, newdata, se.fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ctqr_+3A_object">object</code></td>
<td>

<p>a <code>ctqr</code> object.
</p>
</td></tr>
<tr><td><code id="predict.ctqr_+3A_newdata">newdata</code></td>
<td>

<p>optional data frame in which to look for variables with which to predict. It must include all the covariates that enter the quantile regression model. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.ctqr_+3A_se.fit">se.fit</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, standard errors of the predictions are also computed.
</p>
</td></tr>
<tr><td><code id="predict.ctqr_+3A_...">...</code></td>
<td>

<p>for future methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces predicted values obtained by evaluating the regression function at <code>newdata</code> (which defaults to <kbd>model.frame(object)</kbd>).
</p>


<h3>Value</h3>

<p>If <kbd>se = FALSE</kbd>, a matrix of fitted values, with rows corresponding to different observations, and one column for each value of <kbd>object$p</kbd>. If <kbd>se = TRUE</kbd>, a list with two items:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a matrix of fitted values, as described above.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>a matrix of estimated standard errors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctqr">ctqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using simulated data

n &lt;- 1000
x1 &lt;- runif(n)
x2 &lt;- runif(n)
t &lt;- 1 + x1 + x2 + runif(n, -1,1)
c &lt;- rnorm(n,3,1)
y &lt;- pmin(t,c)
d &lt;- (t &lt;= c)

model &lt;- ctqr(Surv(y,d) ~ x1 + x2, p = c(0.25,0.5))
pred &lt;- predict(model) # the same as fitted(model)
predict(model, newdata = data.frame(x1 = c(0.2,0.6), x2 = c(0.1,0.9)), se.fit = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
