<!DOCTYPE html><html><head><title>Help for package MKinfer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MKinfer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baplot'><p> Bland-Altman Plots</p></a></li>
<li><a href='#binomCI'><p> Confidence Intervals for Binomial Proportions</p></a></li>
<li><a href='#binomDiffCI'><p> Confidence Intervals for Difference of Two Binomial Proportions</p></a></li>
<li><a href='#boot.t.test'><p>Bootstrap t-Test</p></a></li>
<li><a href='#cvCI'><p> Confidence Intervals for Coefficient of Variation</p></a></li>
<li><a href='#fingsys'><p> Systolic Blood Pressure Dataset used in Bland and Altman (1995)</p></a></li>
<li><a href='#hsu.t.test'><p>Hsu Two-Sample t-Test</p></a></li>
<li><a href='#imputeSD'><p> Impute Standard Deviations for Changes from Baseline</p></a></li>
<li><a href='#mi.t.test'><p>Multiple Imputation Student's t-Test</p></a></li>
<li><a href='#mi.wilcox.test'><p>Multiple Wilcoxon Rank Sum and Signed Rank Tests</p></a></li>
<li><a href='#MKinfer-package'>
<p>Inferential Statistics.</p></a></li>
<li><a href='#normCI'><p> Confidence Intervals for Mean and Standard Deviation</p></a></li>
<li><a href='#normDiffCI'><p> Confidence Intervals for Difference of Means</p></a></li>
<li><a href='#p2ses'><p> Compute SES from p value.</p></a></li>
<li><a href='#pairwise.ext.t.test'><p> Compute Pairwise t Tests</p></a></li>
<li><a href='#pairwise.fun'><p> Compute pairwise values for a given function</p></a></li>
<li><a href='#pairwise.wilcox.exact'><p> Compute Pairwise Wilcoxon Tests</p></a></li>
<li><a href='#perm.t.test'><p>Permutation t-Test</p></a></li>
<li><a href='#quantileCI'><p> Confidence Intervals for Quantiles</p></a></li>
<li><a href='#rm.oneway.test'><p>Test for Equal Means in a Repeated Measures One-Way Layout</p></a></li>
<li><a href='#volcano'><p> Volcano Plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Inferential Statistics</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl <a href="https://orcid.org/0000-0001-9514-8910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MKdescr, boot, arrangements, nlme, ggplot2,
exactRankTests, miceadds</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, Amelia, mice</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of various confidence intervals (Altman et al. (2000), ISBN:978-0-727-91375-3; Hedderich and Sachs (2018), ISBN:978-3-662-56657-2) including bootstrapped versions (Davison and Hinkley (1997), ISBN:978-0-511-80284-3) as well as Hsu (Hedderich and Sachs (2018), ISBN:978-3-662-56657-2), permutation (Janssen (1997), &lt;<a href="https://doi.org/10.1016%2FS0167-7152%2897%2900043-6">doi:10.1016/S0167-7152(97)00043-6</a>&gt;), bootstrap (Davison and Hinkley (1997), ISBN:978-0-511-80284-3) and multiple imputation (Barnard and Rubin (1999), &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F86.4.948">doi:10.1093/biomet/86.4.948</a>&gt;) t-test and Wilcoxon tests. Graphical visualization by volcano and Bland-Altman plots (Bland and Altman (1986), &lt;<a href="https://doi.org/10.1016%2FS0140-6736%2886%2990837-8">doi:10.1016/S0140-6736(86)90837-8</a>&gt;; Shieh (2018), &lt;<a href="https://doi.org/10.1186%2Fs12874-018-0505-y">doi:10.1186/s12874-018-0505-y</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stamats/MKinfer">https://github.com/stamats/MKinfer</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-17 06:41:36 UTC; kohlm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-17 08:20:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='baplot'> Bland-Altman Plots </h2><span id='topic+baplot'></span>

<h3>Description</h3>

<p>Produce classical parametric as well as nonparametric Bland-Altman plots 
including confidence intervals for the mean of the differences and 
the lower and upper limit of agreement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baplot(x, y, loa.level = 0.95, conf.level = 0.95, 
       xlab = "Difference", ylab = "Mean", 
       title = "Bland-Altman Plot", xlim = NULL, ylim = NULL,
       type = c("parametric", "nonparametric"), 
       loa.type = c("unbiased", "biased"), ci.diff = TRUE, ci.loa = TRUE, 
       ci.type = c("exact", "approximate", "boot"), 
       bootci.type = NULL, R = 9999, print.res = TRUE,
       color.low = "#4575B4", color.upp = "#D73027", 
       alpha = 1, shape = 19, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baplot_+3A_x">x</code></td>
<td>
<p> numeric, measurements of method 1.</p>
</td></tr>
<tr><td><code id="baplot_+3A_y">y</code></td>
<td>
<p> numeric, measurements of method 2.</p>
</td></tr>
<tr><td><code id="baplot_+3A_loa.level">loa.level</code></td>
<td>
<p> single numeric, level of the level of agreement.</p>
</td></tr>
<tr><td><code id="baplot_+3A_conf.level">conf.level</code></td>
<td>
<p> single numeric, significance level.</p>
</td></tr>
<tr><td><code id="baplot_+3A_xlab">xlab</code></td>
<td>
<p> label of x-axis.</p>
</td></tr>
<tr><td><code id="baplot_+3A_ylab">ylab</code></td>
<td>
<p> label of y-axis.</p>
</td></tr>
<tr><td><code id="baplot_+3A_title">title</code></td>
<td>
<p> title of plot.</p>
</td></tr>
<tr><td><code id="baplot_+3A_xlim">xlim</code></td>
<td>
<p> optional numeric vector of length 2, limits of x-axis.</p>
</td></tr>
<tr><td><code id="baplot_+3A_ylim">ylim</code></td>
<td>
<p> optional numeric vector of length 2, limits of y-axis.</p>
</td></tr>
<tr><td><code id="baplot_+3A_type">type</code></td>
<td>
<p> single character, either <code>"parametric"</code> (default) or <code>"nonparametric"</code>; see also Details below.</p>
</td></tr>
<tr><td><code id="baplot_+3A_loa.type">loa.type</code></td>
<td>
<p> single character, either <code>"unbiased"</code> (default) or <code>"biased"</code>; see also Details below.</p>
</td></tr>
<tr><td><code id="baplot_+3A_ci.diff">ci.diff</code></td>
<td>
<p> single logical, plot confidence interval for the mean of the differences.</p>
</td></tr>
<tr><td><code id="baplot_+3A_ci.loa">ci.loa</code></td>
<td>
<p> single logical, plot confidence intervals for the lower and upper limit of agreement.</p>
</td></tr>
<tr><td><code id="baplot_+3A_ci.type">ci.type</code></td>
<td>
<p> single character, either <code>"exact"</code> (default) or <code>"approximate"</code> or <code>"boot"</code>; see also Details below.</p>
</td></tr>
<tr><td><code id="baplot_+3A_bootci.type">bootci.type</code></td>
<td>
<p> single character, type of bootstrap interval; see <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> and also Details below. </p>
</td></tr>
<tr><td><code id="baplot_+3A_r">R</code></td>
<td>
<p> single numeric, number of bootstrap replicates. </p>
</td></tr>
<tr><td><code id="baplot_+3A_print.res">print.res</code></td>
<td>
<p> single logical, print results of computations in addition to plotting.</p>
</td></tr>
<tr><td><code id="baplot_+3A_color.low">color.low</code></td>
<td>
<p> single color (character), color for lower limit of agreement.</p>
</td></tr>
<tr><td><code id="baplot_+3A_color.upp">color.upp</code></td>
<td>
<p> single color (character), color for upper limit of agreement.</p>
</td></tr>
<tr><td><code id="baplot_+3A_alpha">alpha</code></td>
<td>
<p> blending factor (default: no blending.</p>
</td></tr>
<tr><td><code id="baplot_+3A_shape">shape</code></td>
<td>
<p> point shape used.</p>
</td></tr>
<tr><td><code id="baplot_+3A_na.rm">na.rm</code></td>
<td>
<p> single logical, remove <code>NA</code> values before plotting.</p>
</td></tr>
<tr><td><code id="baplot_+3A_...">...</code></td>
<td>
<p> further arguments passed to function <code><a href="boot.html#topic+boot">boot</a></code>,
e.g. for parallel computing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot generates a <code>ggplot2</code> object that is shown.
</p>
<p>Setting <code>type = "parametric"</code> (default), a classical Bland-Altman plot 
with mean of the differences and standard lower and upper limit of agreement 
(mean +/- 1.96 SD) will be generated (<code>loa.level = 0.95</code>); 
see Altman and Bland (1983,1986).
</p>
<p>Setting <code>type = "nonparametric"</code>, a nonparametric Bland-Altman plot with 
median of the differences and empirical 2.5% and 97.5% quantiles 
(<code>loa.level = 0.95</code>) as lower and upper limit of agreement will be generated.
</p>
<p>By changing <code>loa.level</code> the lower and upper limit of agreement will 
correspond to the <code>(1-loa.level)/2</code> and the <code>1 - (1-low.level)/2</code>
quantile.
</p>
<p>Setting <code>loa.type = "unbiased"</code>, the unbiased estimator of the standard
deviation will be used; see Shieh (2018).
</p>
<p>Setting <code>loa.type = "biased"</code>, the standard deviation will be estimated
by function <code>sd</code>.
</p>
<p>Setting <code>ci.type = "exact"</code>, the exact confidence intervals of Shieh (2018) 
will be used for the lower and upper limit of agreement.
</p>
<p>Setting <code>ci.type = "approximate"</code>, the approximate confidence intervals
of Bland and Altman (1986, 1999) will be used.
</p>
<p>Setting <code>ci.type = "boot"</code>, bootstrap confidence intervals will be used.
In the case of parametric Bland-Altman plots, the studentized bootstrap method will
be used by default. In the case of nonparametric Bland-Altman plots, the 
bootstrap percentile method will be used by default.
</p>
<p>The argument <code>bootci.type</code> can be set to <code>"stud"</code> (studentized bootstrap),
<code>"perc"</code> (bootstrap percentile) or <code>"bca"</code> (adjusted bootstrap percentile).
</p>


<h3>Value</h3>

<p>Object of class <code>gg</code> and <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Altman DG, Bland JM (1983). Measurement in Medicine: the Analysis of Method Comparison Studies. 
<em>The Statistician</em> 32:307-317.
</p>
<p>Bland JM, Altman DG (1986). Statistical methods for assessing agreement between two methods 
of clinical measurement. <em>Lancet</em> 327(8476):307-10
</p>
<p>Bland JM, Altman DG (1999). Measuring agreement in method comparison studies. 
<em>Stat Methods Med Res</em> 8:135-160.
</p>
<p>Shieh G (2018). The appropriateness of Bland-Altman's approximate confidence intervals 
for limits of agreement. <em>BMC Med Res Methodol</em> 18:45.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fingsys)
## classical parametric Bland-Altman plot with exact confidence intervals
baplot(x = fingsys$armsys, y = fingsys$fingsys, 
       xlab = "Mean of arm and finger [mm Hg]",
       ylab = "Difference (arm - finger) [mm Hg]")

## nonparametric Bland-Altman plot with exact confidence intervals
baplot(x = fingsys$armsys, y = fingsys$fingsys, type = "nonparametric",
       xlab = "Mean of arm and finger [mm Hg]",
       ylab = "Difference (arm - finger) [mm Hg]",
       title = "Nonparametric Bland-Altman Plot")
</code></pre>

<hr>
<h2 id='binomCI'> Confidence Intervals for Binomial Proportions </h2><span id='topic+binomCI'></span>

<h3>Description</h3>

<p>This function can be used to compute confidence intervals for binomial proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomCI(x, n, conf.level = 0.95, method = "wilson", rand = 123, 
        R = 9999, bootci.type = "all", 
        alternative = c("two.sided", "less", "greater"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomCI_+3A_x">x</code></td>
<td>
<p> number of successes </p>
</td></tr>
<tr><td><code id="binomCI_+3A_n">n</code></td>
<td>
<p> number of trials </p>
</td></tr>
<tr><td><code id="binomCI_+3A_conf.level">conf.level</code></td>
<td>
<p> confidence level </p>
</td></tr>
<tr><td><code id="binomCI_+3A_method">method</code></td>
<td>
<p> character string specifing which method to use; see details. </p>
</td></tr>
<tr><td><code id="binomCI_+3A_rand">rand</code></td>
<td>
<p> seed for random number generator; see details. </p>
</td></tr>
<tr><td><code id="binomCI_+3A_r">R</code></td>
<td>
<p> number of bootstrap replicates. </p>
</td></tr>
<tr><td><code id="binomCI_+3A_bootci.type">bootci.type</code></td>
<td>
<p> type of bootstrap interval; see <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>. </p>
</td></tr>
<tr><td><code id="binomCI_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying one- or two-sided confidence intervals. 
Must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot; (one-sided intervals). 
You can specify just the initial letter. </p>
</td></tr>
<tr><td><code id="binomCI_+3A_...">...</code></td>
<td>
<p> further arguments passed to function <code><a href="boot.html#topic+boot">boot</a></code>,
e.g. for parallel computing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wald interval is obtained by inverting the acceptance region of the Wald
large-sample normal test. There is also a Wald interval with continuity 
correction (<code>"wald-cc"</code>).
</p>
<p>The Wilson interval, which is the default, was introduced by Wilson (1927) and is
the inversion of the CLT approximation to the family of equal tail tests of p = p0.
The Wilson interval is recommended by Agresti and Coull (1998) as well as by
Brown et al (2001).
</p>
<p>The Agresti-Coull interval was proposed by Agresti and Coull (1998) and is a slight
modification of the Wilson interval. The Agresti-Coull intervals are never shorter
than the Wilson intervals; cf. Brown et al (2001).
</p>
<p>The Jeffreys interval is an implementation of the equal-tailed Jeffreys prior interval
as given in Brown et al (2001).
</p>
<p>The modified Wilson interval is a modification of the Wilson interval for x close to 0
or n as proposed by Brown et al (2001).
</p>
<p>The modified Jeffreys interval is a modification of the Jeffreys interval for
<code>x == 0 | x == 1</code> and <code>x == n-1 | x == n</code> as proposed by
Brown et al (2001).
</p>
<p>The Clopper-Pearson interval is based on quantiles of corresponding beta
distributions. This is sometimes also called exact interval.
</p>
<p>The arcsine interval is based on the variance stabilizing distribution for the binomial
distribution.
</p>
<p>The logit interval is obtained by inverting the Wald type interval for the log odds.
</p>
<p>The Witting interval (cf. Beispiel 2.106 in Witting (1985)) uses randomization to
obtain uniformly optimal lower and upper confidence bounds (cf. Satz 2.105 in
Witting (1985)) for binomial proportions.
</p>
<p>The bootstrap interval is calculated by using function <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>.
</p>
<p>For more details we refer to Brown et al (2001) as well as Witting (1985).
</p>


<h3>Value</h3>

<p>A list with class <code>"confint"</code> containing the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p> the estimated probability of success. </p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p> a confidence interval for the probability of success. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>A first version of this function appeared in R package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>A. Agresti and B.A. Coull (1998). Approximate is better than &quot;exact&quot; for interval
estimation of binomial proportions.
<em>American Statistician</em>, <b>52</b>, 119-126.
</p>
<p>L.D. Brown, T.T. Cai and A. Dasgupta (2001). Interval estimation for a binomial
proportion. <em>Statistical Science</em>, <b>16</b>(2), 101-133.
</p>
<p>H. Witting (1985). <em>Mathematische Statistik I</em>. Stuttgart: Teubner.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+binom.test">binom.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>binomCI(x = 42, n = 43, method = "wald")
binomCI(x = 42, n = 43, method = "wald-cc")
binomCI(x = 42, n = 43, method = "wilson")
binomCI(x = 42, n = 43, method = "agresti-coull")
binomCI(x = 42, n = 43, method = "jeffreys")
binomCI(x = 42, n = 43, method = "modified wilson")
binomCI(x = 42, n = 43, method = "modified jeffreys")
binomCI(x = 42, n = 43, method = "clopper-pearson")
binomCI(x = 42, n = 43, method = "arcsine")
binomCI(x = 42, n = 43, method = "logit")
binomCI(x = 42, n = 43, method = "witting")
## bootstrap intervals (R = 999 to reduce computation time for R checks)
binomCI(x = 42, n = 43, method = "boot", R = 999) # may generate values &gt; 1!

## the confidence interval computed by binom.test
## corresponds to the Clopper-Pearson interval
binomCI(x = 42, n = 43, method = "clopper-pearson")$conf.int
binom.test(x = 42, n = 43)$conf.int

## one-sided intervals
binomCI(x = 10, n = 43, alternative = "less")
binomCI(x = 10, n = 43, alternative = "less", method = "boot", 
        bootci.type = "bca", R = 999)
binomCI(x = 10, n = 43, alternative = "greater", method = "boot", 
        bootci.type = "perc", R = 999)
        

## parallel computing for bootstrap
binomCI(x = 10, n = 43, method = "boot", R = 9999, 
        parallel = "multicore", ncpus = 2)

</code></pre>

<hr>
<h2 id='binomDiffCI'> Confidence Intervals for Difference of Two Binomial Proportions </h2><span id='topic+binomDiffCI'></span>

<h3>Description</h3>

<p>This function can be used to compute confidence intervals for the difference 
of two binomial proportions. It includes methods for the independent and the 
paired case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomDiffCI(a, b, c, d, conf.level = 0.95, paired = FALSE, 
            method = ifelse(paired, "wilson-cc", "wilson"), 
            R = 9999, bootci.type = "all", 
            alternative = c("two.sided", "less", "greater"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomDiffCI_+3A_a">a</code></td>
<td>
<p> independent: number of successes of group 1; 
paired: number of cases with success in group 1 and 2. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_b">b</code></td>
<td>
<p> independent: number of successes of group 2; 
paired: number of cases with success in group 1 and failure in group 2. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_c">c</code></td>
<td>
<p> independent: number of failures of group 1; 
paired: number of cases with failure in group 1 and success in group 2. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_d">d</code></td>
<td>
<p> independent: number of failures of group 2; 
paired: number of cases with failure in group 1 and 2. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_conf.level">conf.level</code></td>
<td>
<p> confidence level </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_paired">paired</code></td>
<td>
<p> a logical value indicating whether the two groups are paired. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_method">method</code></td>
<td>
<p> character string specifing which method to use; see details. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_r">R</code></td>
<td>
<p> number of bootstrap replicates. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_bootci.type">bootci.type</code></td>
<td>
<p> type of bootstrap interval; see <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying one- or two-sided confidence intervals. 
Must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot; (one-sided intervals). 
You can specify just the initial letter. </p>
</td></tr>
<tr><td><code id="binomDiffCI_+3A_...">...</code></td>
<td>
<p> further arguments passed to function <code><a href="boot.html#topic+boot">boot</a></code>,
e.g. for parallel computing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wald intervals (independent and paired) are obtained by applying the normal 
approximation. There are also Wald intervals with continuity correction.
</p>
<p>The Wilson intervals are recommended by Newcombe and Altman (2000); see
Chapter 6 of Altman et al. (2000). In the paired case, the continuity corrected
version of the interval is recommended. The intervals are proposed in 
Newcombe (1998a) and Newcombe (1998b).
</p>
<p>The bootstrap interval is calculated by using function <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"confint"</code> containing the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p> the estimated probability of success. </p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p> a confidence interval for the probability of success. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>D. Altman, D. Machin, T. Bryant, M. Gardner (eds). <em>Statistics with Confidence:
Confidence Intervals and Statistical Guidelines</em>, 2nd edition.
John Wiley and Sons 2000.
</p>
<p>R.G. Newcombe (1998a). Interval estimation for the difference between independent 
proportions: comparison of eleven methods. <em>Stat Med</em>, <b>17</b>(8), 873-890.
</p>
<p>R.G. Newcombe (1998b). Improved confidence intervals for the difference between 
binomial proportions based on paired data. <em>Stat Med</em>, <b>17</b>(22), 2635-2650.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prop.test">prop.test</a></code>, <code><a href="boot.html#topic+boot.ci">boot.ci</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Altman et al. (2000, p. 49)
## the confidence interval computed by prop.test
prop.test(c(63, 38), c(93, 92))$conf.int
## wald / simple asymptotic interval
binomDiffCI(a = 63, b = 38, c = 30, d = 54, method = "wald")
## wald / simple asymptotic interval with continuity correction
binomDiffCI(a = 63, b = 38, c = 30, d = 54, method = "wald-cc")
## wilson
binomDiffCI(a = 63, b = 38, c = 30, d = 54)
## bootstrap intervals (R = 999 to reduce computation time for R checks)
binomDiffCI(a = 63, b = 38, c = 30, d = 54, method = "boot", R = 999)
## one-sided
binomDiffCI(a = 63, b = 38, c = 30, d = 54, alternative = "greater")
## bootstrap intervals (R = 999 to reduce computation time for R checks)
binomDiffCI(a = 63, b = 38, c = 30, d = 54, method = "boot", R = 999,
            bootci.type = "bca", alternative = "greater")


## Example 2: Altman et al. (2000, p. 50)
## the confidence interval computed by prop.test
prop.test(c(5, 0), c(56, 29))$conf.int
## wald / simple asymptotic interval
binomDiffCI(a = 5, b = 0, c = 51, d = 29, method = "wald")
## wald / simple asymptotic interval with continuity correction
binomDiffCI(a = 5, b = 0, c = 51, d = 29, method = "wald-cc")
## wilson
binomDiffCI(a = 5, b = 0, c = 51, d = 29)
## bootstrap intervals (R = 999 to reduce computation time for R checks)
binomDiffCI(a = 5, b = 0, c = 51, d = 29, method = "boot", R = 999)
## one-sided
binomDiffCI(a = 5, b = 0, c = 51, d = 29, alternative = "less")
## bootstrap intervals (R = 999 to reduce computation time for R checks)
binomDiffCI(a = 5, b = 0, c = 51, d = 29, method = "boot", R = 999,
            bootci.type = "perc", alternative = "less")


## Example 3: Altman et al. (2000, p. 51)
## wald / simple asymptotic interval
binomDiffCI(a = 14, b = 5, c = 0, d = 22, paired = TRUE, method = "wald")
## wald / simple asymptotic interval with continuity correction
binomDiffCI(a = 14, b = 5, c = 0, d = 22, paired = TRUE, method = "wald-cc")
## wilson
binomDiffCI(a = 14, b = 5, c = 0, d = 22, paired = TRUE, method = "wilson")
## wilson with continuity correction
binomDiffCI(a = 14, b = 5, c = 0, d = 22, paired = TRUE)
## bootstrap intervals (R = 999 to reduce computation time for R checks)
binomDiffCI(a = 14, b = 5, c = 0, d = 22, paired = TRUE, method = "boot", R = 999)

## Example 4: Altman et al. (2000, p. 51)
## wald / simple asymptotic interval
binomDiffCI(a = 212, b = 144, c = 256, d = 707, paired = TRUE, method = "wald")
## wald / simple asymptotic interval with continuity correction
binomDiffCI(a = 212, b = 144, c = 256, d = 707, paired = TRUE, method = "wald-cc")
## wilson
binomDiffCI(a = 212, b = 144, c = 256, d = 707, paired = TRUE, method = "wilson")
## wilson with continuity correction
binomDiffCI(a = 212, b = 144, c = 256, d = 707, paired = TRUE)
## bootstrap intervals (R = 999 to reduce computation time for R checks)
binomDiffCI(a = 212, b = 144, c = 256, d = 707, paired = TRUE, method = "boot",
            bootci.type = c("norm", "basic", "stud", "perc"), R = 999) ## type = "bca" gives error


binomDiffCI(a = 63, b = 38, c = 30, d = 54, method = "boot", R = 9999, 
        parallel = "multicore", ncpus = 2)

</code></pre>

<hr>
<h2 id='boot.t.test'>Bootstrap t-Test</h2><span id='topic+boot.t.test'></span><span id='topic+boot.t.test.default'></span><span id='topic+boot.t.test.formula'></span>

<h3>Description</h3>

<p>Performs one and two sample bootstrap t-tests on vectors of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.t.test(x, ...)

## Default S3 method:
boot.t.test(x, y = NULL,
       alternative = c("two.sided", "less", "greater"),
       mu = 0, paired = FALSE, var.equal = FALSE,
       conf.level = 0.95, R = 9999, symmetric = FALSE, ...)

## S3 method for class 'formula'
boot.t.test(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.t.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_y">y</code></td>
<td>
<p>an optional (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or
difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired
t-test.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the
two variances as being equal. If <code>TRUE</code> then the pooled
variance is used to estimate the variance otherwise the Welch
(or Satterthwaite) approximation to the degrees of freedom is used.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_r">R</code></td>
<td>
<p> number of bootstrap replicates. </p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_symmetric">symmetric</code></td>
<td>
<p>a logical variable indicating whether to assume symmetry
in the two-sided test. If <code>TRUE</code> then the symmetric bootstrap p value 
otherwise the equal-tail boostrap p value is computed.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="boot.t.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented test corresponds to the proposal of Chapter 16 of
Efron and Tibshirani (1993).
</p>
<p>The function returns bootstrapped p values and confidence intervals
as well as the results ot the t-test without bootstrap.
</p>
<p>The formula interface is only applicable for the 2-sample tests.
</p>
<p><code>alternative = "greater"</code> is the alternative that <code>x</code> has a
larger mean than <code>y</code>.
</p>
<p>If <code>paired</code> is <code>TRUE</code> then both <code>x</code> and <code>y</code> must
be specified and they must be the same length.  Missing values are
silently removed (in pairs if <code>paired</code> is <code>TRUE</code>).  If
<code>var.equal</code> is <code>TRUE</code> then the pooled estimate of the
variance is used.  By default, if <code>var.equal</code> is <code>FALSE</code>
then the variance is estimated separately for both groups and the
Welch modification to the degrees of freedom is used.
</p>
<p>If the input data are effectively constant (compared to the larger of the
two means) an error is generated.
</p>


<h3>Value</h3>

<p>A list with class <code>"boot.htest"</code> (derived from class <code>htest</code>) 
containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the t-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the t-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>boot.p.value</code></td>
<td>
<p>the bootstrapped p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the mean appropriate to the
specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>boot.conf.int</code></td>
<td>
<p>a bootstrap percentile confidence interval for the mean 
appropriate to the specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean or difference in means depending on
whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>boot.estimate</code></td>
<td>
<p> bootstrapped estimate.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean
difference depending on whether it was a one-sample test or a
two-sample test.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>the standard error of the mean (difference), used as
denominator in the t-statistic formula.</p>
</td></tr>
<tr><td><code>boot.stderr</code></td>
<td>
<p> bootstrapped standard error.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of t-test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Code and documentation are for large parts identical to function 
<code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>


<h3>References</h3>

<p>B. Efron, R.J. Tibshirani. <em>An Introduction to the Bootstrap</em>.
Chapman and Hall/CRC 1993.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="#topic+meanCI">meanCI</a></code>, <code><a href="#topic+meanDiffCI">meanDiffCI</a></code>,
<code><a href="#topic+perm.t.test">perm.t.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

t.test(1:10, y = c(7:20))      # P = .00001855
boot.t.test(1:10, y = c(7:20))

t.test(1:10, y = c(7:20, 200)) # P = .1245    -- NOT significant anymore
boot.t.test(1:10, y = c(7:20, 200))


## Classical example: Student's sleep data
plot(extra ~ group, data = sleep)
## Traditional interface
with(sleep, t.test(extra[group == 1], extra[group == 2]))
with(sleep, boot.t.test(extra[group == 1], extra[group == 2]))
## Formula interface
t.test(extra ~ group, data = sleep)
boot.t.test(extra ~ group, data = sleep)
</code></pre>

<hr>
<h2 id='cvCI'> Confidence Intervals for Coefficient of Variation </h2><span id='topic+cvCI'></span>

<h3>Description</h3>

<p>This function can be used to compute confidence intervals for the (classical)
coefficient of variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvCI(x, conf.level = 0.95, method = "miller", R = 9999, 
     bootci.type = c("norm", "basic", "perc", "bca"), na.rm = FALSE,
     alternative = c("two.sided", "less", "greater"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvCI_+3A_x">x</code></td>
<td>
<p> numeric vector with positive numbers. </p>
</td></tr>
<tr><td><code id="cvCI_+3A_conf.level">conf.level</code></td>
<td>
<p> confidence level </p>
</td></tr>
<tr><td><code id="cvCI_+3A_method">method</code></td>
<td>
<p> character string specifing which method to use; see details. </p>
</td></tr>
<tr><td><code id="cvCI_+3A_r">R</code></td>
<td>
<p> number of bootstrap replicates; see details. </p>
</td></tr>
<tr><td><code id="cvCI_+3A_bootci.type">bootci.type</code></td>
<td>
<p> type of bootstrap interval; see <code>boot.ci</code>. 
Type <code>"student"</code> does not work.</p>
</td></tr>
<tr><td><code id="cvCI_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="cvCI_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying one- or two-sided confidence intervals. 
Must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot; (one-sided intervals). 
You can specify just the initial letter. </p>
</td></tr>
<tr><td><code id="cvCI_+3A_...">...</code></td>
<td>
<p> further arguments passed to function <code><a href="boot.html#topic+boot">boot</a></code>,
e.g. for parallel computing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the confidence intervals we refer to Gulhar et al (2012) and
Arachchige et al (2019).
</p>
<p>In case of bootstrap intervals type <code>"student"</code> does not work, since
no standard error of CV is provided.
</p>


<h3>Value</h3>

<p>A list with class <code>"confint"</code> containing the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p> the estimated coefficient of variation. </p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p> a confidence interval for the coefficient of variation. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>C.N.P.G. Arachchige, L.A. Prendergast and R.G. Staudte (2019). Robust analogues
to the Coefficient of Variation. https://arxiv.org/abs/1907.01110.
</p>
<p>M. Gulhar, G. Kibria, A. Albatineh, N.U. Ahmed (2012). A comparison of some
confidence intervals for estimating the population coefficient of variation:
a simulation study. <em>Sort</em>, <b>36</b>(1), 45-69.
</p>


<h3>See Also</h3>

<p><code><a href="MKdescr.html#topic+CV">CV</a></code>, <code><a href="boot.html#topic+boot.ci">boot.ci</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100, mean = 10, sd = 2) # CV = 0.2
cvCI(x, method = "miller")
cvCI(x, method = "sharma")
cvCI(x, method = "curto")
cvCI(x, method = "mckay")
cvCI(x, method = "vangel")
cvCI(x, method = "panichkitkosolkul")
cvCI(x, method = "medmiller")
cvCI(x, method = "medmckay")
cvCI(x, method = "medvangel")
cvCI(x, method = "medcurto")
cvCI(x, method = "gulhar")
cvCI(x, method = "boot", R = 999) # R = 999 to reduce computation time for R checks

## one-sided
cvCI(x, alternative = "less")
cvCI(x, alternative = "greater")
cvCI(x, method = "boot", bootci.type = "bca", alternative = "less", R = 999)


## parallel computing for bootstrap
cvCI(x, method = "boot", R = 9999, parallel = "multicore", ncpus = 2)

</code></pre>

<hr>
<h2 id='fingsys'> Systolic Blood Pressure Dataset used in Bland and Altman (1995) </h2><span id='topic+fingsys'></span>

<h3>Description</h3>

<p>This dataset was used in Band and Altman (1995) to demonstrate why plotting 
difference against standard method is misleading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fingsys)</code></pre>


<h3>Format</h3>

<p>A data.frame with two colums
</p>

<dl>
<dt><code>armsys</code></dt><dd><p> systolic blood pressure (mm Hg) measured by a standard arm cuff. </p>
</dd>
<dt><code>fingsys</code></dt><dd><p> systolic blood pressure (mm Hg) measured by a finger monitor. </p>
</dd>
</dl>

<p>For more details see Close et al. (1986) as well as Bland and Altman (1995).
</p>


<h3>Details</h3>

<p>The dataset is a random subset of 200 observations from a larger dataset
of Close et al. (1986) that was used in Bland and Altman (1995) to demonstrate
why plotting difference against standard method is misleading.
</p>


<h3>Source</h3>

<p>The data set was obtained from
<a href="https://www-users.york.ac.uk/~mb55/datasets/fingsys.dct">https://www-users.york.ac.uk/~mb55/datasets/fingsys.dct</a>
</p>


<h3>References</h3>

<p>Close A, Hamilton G, Muriss S (1986). Finger systolic pressure: its use in screening 
for hypertension and monitoring. <em>Brit Med J</em> 293:775-778.
</p>
<p>Bland JM, Altman DG. (1995) Comparing methods of measurement: why plotting difference against 
standard method is misleading. <em>Lancet</em> 346, 1085-7. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(fingsys)
  str(fingsys)
  head(fingsys)
  tail(fingsys)
</code></pre>

<hr>
<h2 id='hsu.t.test'>Hsu Two-Sample t-Test</h2><span id='topic+hsu.t.test'></span><span id='topic+hsu.t.test.default'></span><span id='topic+hsu.t.test.formula'></span>

<h3>Description</h3>

<p>Performs Hsu two sample t-tests on vectors of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsu.t.test(x, ...)

## Default S3 method:
hsu.t.test(x, y,
       alternative = c("two.sided", "less", "greater"),
       mu = 0, conf.level = 0.95, ...)

## S3 method for class 'formula'
hsu.t.test(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsu.t.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_y">y</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or
difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="hsu.t.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function and its documentation was adapted from <code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>
<p><code>alternative = "greater"</code> is the alternative that <code>x</code> has a
larger mean than <code>y</code>.
</p>
<p>If the input data are effectively constant (compared to the larger of the
two means) an error is generated.
</p>
<p>One should at least have six observations per group to apply the test; see
Section 6.8.3 and 7.4.4.2 of Hedderich and Sachs (2018).
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the t-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the t-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the mean appropriate to the
specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated means and standard deviations.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean
difference depending on whether it was a one-sample test or a
two-sample test.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>the standard error of the difference in means, used as
denominator in the t-statistic formula.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of t-test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Hedderich, L. Sachs. <em>Angewandte Statistik: Methodensammlung mit R</em>.
Springer 2018.
</p>
<p>Hsu, P. (1938). Contribution to the theory of &ldquo;student's&rdquo; t-test as 
applied to the problem of two samples. <em>Statistical Research Memoirs</em> <b>2</b>, 
1-24.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples taken and adapted from function t.test
t.test(1:10, y = c(7:20))      # P = .00001855
t.test(1:10, y = c(7:20, 200)) # P = .1245    -- NOT significant anymore
hsu.t.test(1:10, y = c(7:20))
hsu.t.test(1:10, y = c(7:20, 200))

## Traditional interface
with(sleep, t.test(extra[group == 1], extra[group == 2]))
with(sleep, hsu.t.test(extra[group == 1], extra[group == 2]))
## Formula interface
t.test(extra ~ group, data = sleep)
hsu.t.test(extra ~ group, data = sleep)
</code></pre>

<hr>
<h2 id='imputeSD'> Impute Standard Deviations for Changes from Baseline </h2><span id='topic+imputeSD'></span>

<h3>Description</h3>

<p>The function imputes standard deviations for changes from baseline
adopting the approach describe in the Cochrane handbook, Section 16.1.3.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeSD(SD1, SD2, SDchange, corr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeSD_+3A_sd1">SD1</code></td>
<td>
<p> numeric vector, baseline SD. </p>
</td></tr>
<tr><td><code id="imputeSD_+3A_sd2">SD2</code></td>
<td>
<p> numeric vector, follow-up SD.</p>
</td></tr>
<tr><td><code id="imputeSD_+3A_sdchange">SDchange</code></td>
<td>
<p> numeric vector, SD for changes from baseline. </p>
</td></tr>
<tr><td><code id="imputeSD_+3A_corr">corr</code></td>
<td>
<p> optional numeric vector of correlations; see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function imputes standard deviations for changes from baseline
adopting the approach describe in the Cochrane handbook (2019), Section 6.5.2.8.
</p>
<p>1) Missing <code>SD1</code> are replaced by correspondig values of <code>SD2</code> and
vice versa.
</p>
<p>2) Correlations for complete data (rows) are computed. Alternatively, correlations 
can be provided via argument <code>corr</code>. This option may particularly be
useful, if no complete data is available.
</p>
<p>3) Minimum, mean and maximum correlation (over rows) are computed.
</p>
<p>4) Missing values of SDchange are computed by the formula provided in
the handbook. The minimum, mean and maximum correlation are used leading
to maximal, mean and minimal SD values that may be used for imputation as
well as a sensitivity analysis.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with possibly imputed SD1 and SD2 values as well as the
given SDchange values are returen. Moreover, the computed correlations as
well as possible values for the imputation of SDchange are returned.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Higgins JPT, Green S (editors). Cochrane Handbook for Systematic Reviews
of Interventions Version 5.1.0 [updated March 2011]. The Cochrane
Collaboration, 2011. Available from www.handbook.cochrane.org.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SD1 &lt;- c(0.149, 0.022, 0.036, 0.085, 0.125, NA, 0.139, 0.124, 0.038)
SD2 &lt;- c(NA, 0.039, 0.038, 0.087, 0.125, NA, 0.135, 0.126, 0.038)
SDchange &lt;- c(NA, NA, NA, 0.026, 0.058, NA, NA, NA, NA)
imputeSD(SD1, SD2, SDchange)
SDchange2 &lt;- rep(NA, 9)
imputeSD(SD1, SD2, SDchange2, corr = c(0.85, 0.9, 0.95))
</code></pre>

<hr>
<h2 id='mi.t.test'>Multiple Imputation Student's t-Test</h2><span id='topic+mi.t.test'></span><span id='topic+mi.t.test.default'></span><span id='topic+mi.t.test.amelia'></span><span id='topic+mi.t.test.mids'></span>

<h3>Description</h3>

<p>Performs one and two sample t-tests on multiple imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.t.test(miData, ...)

## Default S3 method:
mi.t.test(miData, x, y = NULL,
        alternative = c("two.sided", "less", "greater"), mu = 0,
        paired = FALSE, var.equal = FALSE, conf.level = 0.95,
        subset = NULL, ...)

## S3 method for class 'amelia'
mi.t.test(miData, x, y = NULL,
        alternative = c("two.sided", "less", "greater"), mu = 0,
        paired = FALSE, var.equal = FALSE, conf.level = 0.95,
        subset = NULL, ...)

## S3 method for class 'mids'
mi.t.test(miData, x, y = NULL,
        alternative = c("two.sided", "less", "greater"), mu = 0,
        paired = FALSE, var.equal = FALSE, conf.level = 0.95,
        subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.t.test_+3A_midata">miData</code></td>
<td>
<p>list of multiple imputed datasets.</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_x">x</code></td>
<td>
<p>name of a variable that shall be tested.</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_y">y</code></td>
<td>
<p>an optional name of a variable that shall be tested (paired test)
or a variable that shall be used to split into groups (unpaired test).</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or
difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired
t-test.</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the
two variances as being equal. If <code>TRUE</code> then the pooled
variance is used to estimate the variance otherwise the Welch
(or Satterthwaite) approximation to the degrees of freedom is used.</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="mi.t.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alternative = "greater"</code> is the alternative that <code>x</code> has a
larger mean than <code>y</code>.
</p>
<p>If <code>paired</code> is <code>TRUE</code> then both <code>x</code> and <code>y</code> must
be specified and they must be the same length.  Missing values are
not allowed as they should have been imputed.  If
<code>var.equal</code> is <code>TRUE</code> then the pooled estimate of the
variance is used.  By default, if <code>var.equal</code> is <code>FALSE</code>
then the variance is estimated separately for both groups and the
Welch modification to the degrees of freedom is used.
</p>
<p>We use the approach of Rubin (1987) in combination with the adjustment of
Barnard and Rubin (1999).
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the t-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the t-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the mean appropriate to the
specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean (one-sample test), difference in means
(paired test), or estimated means (two-sample test) as well as the
respective standard deviations.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean
difference depending on whether it was a one-sample test or a
two-sample test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of t-test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rubin, D. (1987). <em>Multiple Imputation for Nonresponse in Surveys</em>.
John Wiley and Sons, New York.
</p>
<p>Barnard, J. and Rubin, D. (1999). Small-Sample Degrees of Freedom with
Multiple Imputation. <em>Biometrika</em>, <b>86</b>(4), 948-955.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data
set.seed(123)
x &lt;- rnorm(25, mean = 1)
x[sample(1:25, 5)] &lt;- NA
y &lt;- rnorm(20, mean = -1)
y[sample(1:20, 4)] &lt;- NA
pair &lt;- c(rnorm(25, mean = 1), rnorm(20, mean = -1))
g &lt;- factor(c(rep("yes", 25), rep("no", 20)))
D &lt;- data.frame(ID = 1:45, response = c(x, y), pair = pair, group = g)

## Use Amelia to impute missing values
library(Amelia)
res &lt;- amelia(D, m = 10, p2s = 0, idvars = "ID", noms = "group")

## Per protocol analysis (Welch two-sample t-test)
t.test(response ~ group, data = D)
## Intention to treat analysis (Multiple Imputation Welch two-sample t-test)
mi.t.test(res, x = "response", y = "group")

## Per protocol analysis (Two-sample t-test)
t.test(response ~ group, data = D, var.equal = TRUE)
## Intention to treat analysis (Multiple Imputation two-sample t-test)
mi.t.test(res, x = "response", y = "group", var.equal = TRUE)

## Specifying alternatives
mi.t.test(res, x = "response", y = "group", alternative = "less")
mi.t.test(res, x = "response", y = "group", alternative = "greater")

## One sample test
t.test(D$response[D$group == "yes"])
mi.t.test(res, x = "response", subset = D$group == "yes")
mi.t.test(res, x = "response", mu = -1, subset = D$group == "yes",
          alternative = "less")
mi.t.test(res, x = "response", mu = -1, subset = D$group == "yes",
          alternative = "greater")

## paired test
t.test(D$response, D$pair, paired = TRUE)
mi.t.test(res, x = "response", y = "pair", paired = TRUE)

## Use mice to impute missing values
library(mice)
res.mice &lt;- mice(D, m = 10, print = FALSE)
mi.t.test(res.mice, x = "response", y = "group")
</code></pre>

<hr>
<h2 id='mi.wilcox.test'>Multiple Wilcoxon Rank Sum and Signed Rank Tests</h2><span id='topic+mi.wilcox.test'></span><span id='topic+mi.wilcox.test.default'></span><span id='topic+mi.wilcox.test.amelia'></span><span id='topic+mi.wilcox.test.mids'></span>

<h3>Description</h3>

<p>Performs one and two sample Wilcoxon tests on multiple imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.wilcox.test(miData, ...)

## Default S3 method:
mi.wilcox.test(miData, x, y = NULL,
        alternative = c("two.sided", "less", "greater"), mu = 0,
        paired = FALSE, exact = NULL, conf.int = TRUE,
        conf.level = 0.95, subset = NULL, ...)

## S3 method for class 'amelia'
mi.wilcox.test(miData, x, y = NULL,
        alternative = c("two.sided", "less", "greater"), mu = 0,
        paired = FALSE, exact = NULL, conf.int = TRUE,
        conf.level = 0.95, subset = NULL, ...)

## S3 method for class 'mids'
mi.wilcox.test(miData, x, y = NULL,
        alternative = c("two.sided", "less", "greater"), mu = 0,
        paired = FALSE, exact = NULL, conf.int = TRUE,
        conf.level = 0.95, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.wilcox.test_+3A_midata">miData</code></td>
<td>
<p>list of multiple imputed datasets.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_x">x</code></td>
<td>
<p>name of a variable that shall be tested.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_y">y</code></td>
<td>
<p>an optional name of a variable that shall be tested (paired test)
or a variable that shall be used to split into groups (unpaired test).</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or
difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired
t-test.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_exact">exact</code></td>
<td>
<p>a logical indicating whether an exact p-value should be computed.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_conf.int">conf.int</code></td>
<td>
<p>a logical indicating whether a confidence interval should be computed.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="mi.wilcox.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the tests see <code><a href="exactRankTests.html#topic+wilcox.exact">wilcox.exact</a></code>
</p>
<p>We use the median p rule (MPR) for the computation of the p value of the test; see 
Section 5.3.2 of van Buuren (2018) or Section 13.3 in Heymans and Eekhout (2019).
The approach seems to work well in many situations such as logistic regression
(Eekhout et al. (2017)) or GAM (Bolt et al. (2022)). However, we are not aware 
of any work that has investigated the MPR approach for Wilcoxon tests. Hence,
this function should be regarded as experimental.
</p>
<p>We recommend to use an odd number of imputations.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>he value of the test statistic with a name describing it.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>pointprob</code></td>
<td>
<p>this gives the probability of observing the test statistic itself 
(called point-prob).</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the location parameter mu.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the location parameter. 
(Only present if argument conf.int = TRUE.)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Hodges-Lehmann estimate of the location parameter. 
(Only present if argument conf.int = TRUE.)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>van Buuren, S. (2018). <em>Flexible Imputation of Missing Data</em>.
Chapman &amp; Hall/CRC. <a href="https://stefvanbuuren.name/fimd/">https://stefvanbuuren.name/fimd/</a>.
</p>
<p>Heymans, M.W. and Eekhout, I. (2019). <em>Applied Missing Data Analysis With SPSS 
and (R)Studio</em>. Self-publishing. <a href="https://bookdown.org/mwheymans/bookmi/">https://bookdown.org/mwheymans/bookmi/</a>.
</p>
<p>Eekhout, I, van de Wiel, MA, Heymans, MW (2017). Methods for significance testing 
of categorical covariates in logistic regression models after multiple imputation: 
power and applicability analysis. <em>BMC Med Res Methodol</em>, <b>17</b>, 1:129.
<a href="https://doi.org/10.1186/s12874-017-0404-7">doi:10.1186/s12874-017-0404-7</a>
</p>
<p>Bolt, MA, MaWhinney, S, Pattee, JW, Erlandson, KM, Badesch, DB, Peterson, RA (2022). 
Inference following multiple imputation for generalized additive models: an 
investigation of the median p-value rule with applications to the Pulmonary 
Hypertension Association Registry and Colorado COVID-19 hospitalization data. 
<em>BMC Med Res Methodol</em>, <b>22</b>, 1:148. <a href="https://doi.org/10.1186/s12874-022-01613-w">doi:10.1186/s12874-022-01613-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="exactRankTests.html#topic+wilcox.exact">wilcox.exact</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data
set.seed(123)
x &lt;- rnorm(25, mean = 1)
x[sample(1:25, 5)] &lt;- NA
y &lt;- rnorm(20, mean = -1)
y[sample(1:20, 4)] &lt;- NA
pair &lt;- c(rnorm(25, mean = 1), rnorm(20, mean = -1))
g &lt;- factor(c(rep("yes", 25), rep("no", 20)))
D &lt;- data.frame(ID = 1:45, response = c(x, y), pair = pair, group = g)

## Use Amelia to impute missing values
library(Amelia)
res &lt;- amelia(D, m = 9, p2s = 0, idvars = "ID", noms = "group")

## Per protocol analysis (Exact Wilcoxon rank sum test)
library(exactRankTests)
wilcox.exact(response ~ group, data = D, conf.int = TRUE)
## Intention to treat analysis (Multiple Imputation Exact Wilcoxon rank sum test)
mi.wilcox.test(res, x = "response", y = "group")

## Specifying alternatives
mi.wilcox.test(res, x = "response", y = "group", alternative = "less")
mi.wilcox.test(res, x = "response", y = "group", alternative = "greater")

## One sample test
wilcox.exact(D$response[D$group == "yes"], conf.int = TRUE)
mi.wilcox.test(res, x = "response", subset = D$group == "yes")
mi.wilcox.test(res, x = "response", mu = -1, subset = D$group == "yes",
               alternative = "less")
mi.wilcox.test(res, x = "response", mu = -1, subset = D$group == "yes",
               alternative = "greater")

## paired test
wilcox.exact(D$response, D$pair, paired = TRUE, conf.int = TRUE)
mi.wilcox.test(res, x = "response", y = "pair", paired = TRUE)

## Use mice to impute missing values
library(mice)
res.mice &lt;- mice(D, m = 9, print = FALSE)
mi.wilcox.test(res.mice, x = "response", y = "group")
</code></pre>

<hr>
<h2 id='MKinfer-package'>
Inferential Statistics.
</h2><span id='topic+MKinfer-package'></span><span id='topic+MKinfer'></span>

<h3>Description</h3>

<p>Computation of various confidence intervals (Altman et al. (2000), ISBN:978-0-727-91375-3; 
Hedderich and Sachs (2018), ISBN:978-3-662-56657-2) including bootstrapped 
versions (Davison and Hinkley (1997), ISBN:978-0-511-80284-3) as well as 
Hsu (Hedderich and Sachs (2018), ISBN:978-3-662-56657-2), 
permutation (Janssen (1997), &lt;doi:10.1016/S0167-7152(97)00043-6&gt;), 
bootstrap (Davison and Hinkley (1997), ISBN:978-0-511-80284-3) and 
multiple imputation (Barnard and Rubin (1999), &lt;doi:10.1093/biomet/86.4.948&gt;) t-test
and Wilcoxon tests. Graphical visualization by volcano and Bland-Altman plots 
(Bland and Altman (1986), &lt;doi:10.1016/S0140-6736(86)90837-8&gt;; Shieh (2018), &lt;doi:10.1186/s12874-018-0505-y&gt;).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MKinfer</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 4.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, MKdescr, boot, arrangements, nlme, ggplot2, exactRankTests</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> Amelia, knitr, rmarkdown, mice, miceadds</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/stamats/MKinfer</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>library(MKinfer)
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="https://www.stamats.de">https://www.stamats.de</a>
</p>
<p>Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>

<hr>
<h2 id='normCI'> Confidence Intervals for Mean and Standard Deviation </h2><span id='topic+normCI'></span><span id='topic+meanCI'></span><span id='topic+sdCI'></span>

<h3>Description</h3>

<p>This function can be used to compute confidence intervals for mean and
standard deviation of a normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normCI(x, mean = NULL, sd = NULL, conf.level = 0.95, 
       boot = FALSE, R = 9999, bootci.type = "all", na.rm = TRUE, 
       alternative = c("two.sided", "less", "greater"), ...)
meanCI(x, conf.level = 0.95, boot = FALSE, R = 9999, bootci.type = "all", 
       na.rm = TRUE, alternative = c("two.sided", "less", "greater"), ...)
sdCI(x, conf.level = 0.95, boot = FALSE, R = 9999, bootci.type = "all", 
     na.rm = TRUE, alternative = c("two.sided", "less", "greater"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normCI_+3A_x">x</code></td>
<td>
<p> vector of observations. </p>
</td></tr>
<tr><td><code id="normCI_+3A_mean">mean</code></td>
<td>
<p> mean if known otherwise <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="normCI_+3A_sd">sd</code></td>
<td>
<p> standard deviation if known otherwise <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="normCI_+3A_conf.level">conf.level</code></td>
<td>
<p> confidence level. </p>
</td></tr>
<tr><td><code id="normCI_+3A_boot">boot</code></td>
<td>
<p> a logical value indicating whether bootstrapped confidence intervals shall be computed. </p>
</td></tr>
<tr><td><code id="normCI_+3A_r">R</code></td>
<td>
<p> number of bootstrap replicates. </p>
</td></tr>
<tr><td><code id="normCI_+3A_bootci.type">bootci.type</code></td>
<td>
<p> type of bootstrap interval; see <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>. </p>
</td></tr>
<tr><td><code id="normCI_+3A_na.rm">na.rm</code></td>
<td>
<p> a logical value indicating whether NA values should be stripped before the computation proceeds. </p>
</td></tr>
<tr><td><code id="normCI_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying one- or two-sided confidence intervals. 
Must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot; (one-sided intervals). 
You can specify just the initial letter. </p>
</td></tr>
<tr><td><code id="normCI_+3A_...">...</code></td>
<td>
<p> further arguments passed to function <code><a href="boot.html#topic+boot">boot</a></code>,
e.g. for parallel computing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard confidence intervals for mean and standard deviation are
computed that can be found in many textbooks, e.g. Chapter 4 in Altman et al. (2000).
</p>
<p>In addition, bootstrap confidence intervals for mean and/or SD can be computed,
where function <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> is applied.
</p>


<h3>Value</h3>

<p>A list with class <code>"confint"</code> containing the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p> the estimated mean and sd. </p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p> confidence interval(s) for mean and/or sd. </p>
</td></tr>
<tr><td><code>Infos</code></td>
<td>
<p> additional information. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>D. Altman, D. Machin, T. Bryant, M. Gardner (eds). Statistics with Confidence:
Confidence Intervals and Statistical Guidelines, 2nd edition 2000.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(50)
## mean and sd unknown
normCI(x)
meanCI(x)
sdCI(x)

## one-sided
normCI(x, alternative = "less")
meanCI(x, alternative = "greater")
sdCI(x, alternative = "greater")

## bootstrap intervals (R = 999 to reduce computation time for R checks)
normCI(x, boot = TRUE, R = 999)
meanCI(x, boot = TRUE, R = 999)
sdCI(x, boot = TRUE, R = 999)

normCI(x, boot = TRUE, R = 999, alternative = "less")
meanCI(x, boot = TRUE, R = 999, alternative = "less")
sdCI(x, boot = TRUE, R = 999, alternative = "greater")

## sd known
normCI(x, sd = 1)
## bootstrap intervals only for mean (sd is ignored)
## (R = 999 to reduce computation time for R checks)
normCI(x, sd = 1, boot = TRUE, R = 999)

## mean known
normCI(x, mean = 0)
## bootstrap intervals only for sd (mean is ignored)
## (R = 999 to reduce computation time for R checks)
normCI(x, mean = 0, boot = TRUE, R = 999)


## parallel computing for bootstrap
normCI(x, boot = TRUE, R = 9999, parallel = "multicore", ncpus = 2)

</code></pre>

<hr>
<h2 id='normDiffCI'> Confidence Intervals for Difference of Means </h2><span id='topic+normDiffCI'></span><span id='topic+meanDiffCI'></span>

<h3>Description</h3>

<p>This function can be used to compute confidence intervals for difference
of means assuming normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normDiffCI(x, y, conf.level = 0.95, paired = FALSE, method = "welch", 
           boot = FALSE, R = 9999, bootci.type = "all", na.rm = TRUE, 
           alternative = c("two.sided", "less", "greater"), ...)
meanDiffCI(x, y, conf.level = 0.95, paired = FALSE, method = "welch", 
           boot = FALSE, R = 9999, bootci.type = "all", na.rm = TRUE, 
           alternative = c("two.sided", "less", "greater"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normDiffCI_+3A_x">x</code></td>
<td>
<p> numeric vector of data values of group 1. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_y">y</code></td>
<td>
<p> numeric vector of data values of group 2. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_conf.level">conf.level</code></td>
<td>
<p> confidence level. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_paired">paired</code></td>
<td>
<p> a logical value indicating whether the two groups are paired. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_method">method</code></td>
<td>
<p> a character string specifing which method to use in the unpaired case; see details. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_boot">boot</code></td>
<td>
<p> a logical value indicating whether bootstrapped confidence intervals shall be computed. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_r">R</code></td>
<td>
<p> number of bootstrap replicates. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_bootci.type">bootci.type</code></td>
<td>
<p> type of bootstrap interval; see <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_na.rm">na.rm</code></td>
<td>
<p> a logical value indicating whether <code>NA</code> values should be stripped before the computation proceeds. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying one- or two-sided confidence intervals. 
Must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot; (one-sided intervals). 
You can specify just the initial letter. </p>
</td></tr>
<tr><td><code id="normDiffCI_+3A_...">...</code></td>
<td>
<p> further arguments passed to function <code><a href="boot.html#topic+boot">boot</a></code>,
e.g. for parallel computing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard confidence intervals for the difference of means are
computed that can be found in many textbooks, e.g. Chapter 4 in Altman et al. (2000).
</p>
<p>The method <code>"classical"</code> assumes equal variances whereas methods
<code>"welch"</code> and <code>"hsu"</code> allow for unequal variances. The latter two
methods use different formulas for computing the degrees of freedom of the
respective t-distribution providing the quantiles in the confidence interval.
Instead of the Welch-Satterhwaite equation the method of Hsu uses the minimum
of the group sample sizes minus 1; see Section 6.8.3 of Hedderich and Sachs (2018).
</p>


<h3>Value</h3>

<p>A list with class <code>"confint"</code> containing the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p> point estimate (mean of differences or difference in means). </p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p> confidence interval. </p>
</td></tr>
<tr><td><code>Infos</code></td>
<td>
<p> additional information. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>D. Altman, D. Machin, T. Bryant, M. Gardner (eds). <em>Statistics with Confidence:
Confidence Intervals and Statistical Guidelines</em>, 2nd edition.
John Wiley and Sons 2000.
</p>
<p>J. Hedderich, L. Sachs. <em>Angewandte Statistik: Methodensammlung mit R</em>.
Springer 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100, sd = 2)
## paired
normDiffCI(x, y, paired = TRUE)
## (R = 999 to reduce computation time for R checks)
normDiffCI(x, y, paired = TRUE, boot = TRUE, R = 999)
## compare
normCI(x-y)
## (R = 999 to reduce computation time for R checks)
normCI(x-y, boot = TRUE, R = 999)

## unpaired
y &lt;- rnorm(90, mean = 1, sd = 2)
## classical
normDiffCI(x, y, method = "classical")
## (R = 999 to reduce computation time for R checks)
normDiffCI(x, y, method = "classical", boot = TRUE, R = 999)
## Welch (default as in case of function t.test)
normDiffCI(x, y, method = "welch")
## (R = 999 to reduce computation time for R checks)
normDiffCI(x, y, method = "welch", boot = TRUE, R = 999)
## Hsu
normDiffCI(x, y, method = "hsu")
## In case of bootstrap there is no difference between welch and hsu
## (R = 999 to reduce computation time for R checks)
normDiffCI(x, y, method = "hsu", boot = TRUE, R = 999)

## one-sided
normDiffCI(x, y, alternative = "less")
normDiffCI(x, y, boot = TRUE, R = 999, alternative = "greater")


## parallel computing for bootstrap
normDiffCI(x, y, method = "welch", boot = TRUE, R = 9999, 
           parallel = "multicore", ncpus = 2)



## Monte-Carlo simulation: coverage probability
M &lt;- 100 # increase for more stable/realistic results!
CIhsu &lt;- CIwelch &lt;- CIclass &lt;- matrix(NA, nrow = M, ncol = 2)
for(i in 1:M){
  x &lt;- rnorm(10)
  y &lt;- rnorm(30, sd = 0.1)
  CIclass[i,] &lt;- normDiffCI(x, y, method = "classical")$conf.int
  CIwelch[i,] &lt;- normDiffCI(x, y, method = "welch")$conf.int
  CIhsu[i,] &lt;- normDiffCI(x, y, method = "hsu")$conf.int
}
## coverage probabilies
## classical
sum(CIclass[,1] &lt; 0 &amp; 0 &lt; CIclass[,2])/M
## Welch
sum(CIwelch[,1] &lt; 0 &amp; 0 &lt; CIwelch[,2])/M
## Hsu
sum(CIhsu[,1] &lt; 0 &amp; 0 &lt; CIhsu[,2])/M

</code></pre>

<hr>
<h2 id='p2ses'> Compute SES from p value. </h2><span id='topic+p2ses'></span>

<h3>Description</h3>

<p>The function computes the SES (standardized effect size) from the p value 
for permutation/randomisation tests as proposed by Botta-Dukat (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2ses(p, alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2ses_+3A_p">p</code></td>
<td>
<p> numeric vector of p values. </p>
</td></tr>
<tr><td><code id="p2ses_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying the alternative hypothesis, 
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>. 
You can specify just the initial letter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the probit transformation (<code>qnorm</code>) to compute 
an alternative SES based on p values from a permutation/randomization test 
as proposed by Botta-Dukat (2018) for skewed distributions. 
</p>


<h3>Value</h3>

<p>SES</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Botta-Dukat, Z (2018). Cautionary note on calculating standardized effect size (SES) 
in randomization test. Community Ecology 19(1), 77-83.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## symmetric case
x &lt;- rnorm(100)
res &lt;- perm.t.test(x)
p2ses(res$p.value)
abs(res$statistic)

## skewed case
x &lt;- rgamma(100, shape = 5)
res &lt;- perm.t.test(x, mu = 5)
p2ses(res$p.value)
abs(res$statistic)
</code></pre>

<hr>
<h2 id='pairwise.ext.t.test'> Compute Pairwise t Tests </h2><span id='topic+pairwise.ext.t.test'></span>

<h3>Description</h3>

<p>The function computes pairwise t tests using functions <code>t.test</code>, 
<code>boot.t.test</code> or <code>perm.t.test</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.ext.t.test(x, g, method = "t.test", p.adjust.method = "holm", 
                    paired = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.ext.t.test_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="pairwise.ext.t.test_+3A_g">g</code></td>
<td>
<p> grouping vector or factor </p>
</td></tr>
<tr><td><code id="pairwise.ext.t.test_+3A_method">method</code></td>
<td>
<p> character giving the name of the function to be applied; that is, 
<code>"t.test"</code>, <code>"hsu.t.test"</code>, <code>"boot.t.test"</code> or 
<code>"perm.t.test"</code>. </p>
</td></tr>
<tr><td><code id="pairwise.ext.t.test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p> method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>). 
Can be abbreviated. </p>
</td></tr>
<tr><td><code id="pairwise.ext.t.test_+3A_paired">paired</code></td>
<td>
<p> a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="pairwise.ext.t.test_+3A_...">...</code></td>
<td>
<p> additional arguments to fun. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes pairwise t tests using function <code><a href="stats.html#topic+t.test">t.test</a></code>,
<code><a href="#topic+hsu.t.test">hsu.t.test</a></code>, <code><a href="#topic+boot.t.test">boot.t.test</a></code> or <code><a href="#topic+perm.t.test">perm.t.test</a></code>.
</p>
<p>The implementation is in certain aspects analogously to 
<code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>. However, a more detailed 
output is generated.
</p>


<h3>Value</h3>

<p>Object of class <code>"pw.htest"</code> containing the following components:
</p>
<table>
<tr><td><code>data.name</code></td>
<td>
<p> a character string giving the names of the data. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> the type of test applied. </p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> the location parameter mu. </p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p> a character string describing the alternative hypothesis. </p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p> confidence level of the confidence interval. </p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p> a data.frame containing the results of function 
<code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="#topic+boot.t.test">boot.t.test</a></code> 
or <code><a href="#topic+perm.t.test">perm.t.test</a></code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100)
g &lt;- factor(sample(1:4, 100, replace = TRUE))
levels(g) &lt;- c("a", "b", "c", "d")
pairwise.ext.t.test(x, g)
## in contrast to
pairwise.t.test(x, g, pool.sd = FALSE)
## moreover
pairwise.ext.t.test(x, g, method = "hsu.t.test")
pairwise.ext.t.test(x, g, method = "boot.t.test")
pairwise.ext.t.test(x, g, method = "perm.t.test")
</code></pre>

<hr>
<h2 id='pairwise.fun'> Compute pairwise values for a given function </h2><span id='topic+pairwise.fun'></span>

<h3>Description</h3>

<p>The function computes pairwise values for a given function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.fun(x, g, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.fun_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="pairwise.fun_+3A_g">g</code></td>
<td>
<p> grouping vector or factor </p>
</td></tr>
<tr><td><code id="pairwise.fun_+3A_fun">fun</code></td>
<td>
<p> some function where the first two arguments have to be
numeric vectors for which the function computes some
quantity; see example section below. </p>
</td></tr>
<tr><td><code id="pairwise.fun_+3A_...">...</code></td>
<td>
<p> additional arguments to fun. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes pairwise values for a given function.
</p>
<p>The implementation is in certain aspects analogously to 
<code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>.
</p>


<h3>Value</h3>

<p>Vector with pairwise function values.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100)
g &lt;- factor(sample(1:4, 100, replace = TRUE))
levels(g) &lt;- c("a", "b", "c", "d")
pairwise.fun(x, g, fun = function(x, y) t.test(x,y)$p.value)
## in contrast to
pairwise.t.test(x, g, p.adjust.method = "none", pool.sd = FALSE)
</code></pre>

<hr>
<h2 id='pairwise.wilcox.exact'> Compute Pairwise Wilcoxon Tests </h2><span id='topic+pairwise.wilcox.exact'></span>

<h3>Description</h3>

<p>The function computes pairwise Wilcoxon rank sum and signed rank tests
using function <code>wilcox.exact</code> of package exactRankTests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.wilcox.exact(x, g, p.adjust.method = "holm", paired = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.wilcox.exact_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="pairwise.wilcox.exact_+3A_g">g</code></td>
<td>
<p> grouping vector or factor </p>
</td></tr>
<tr><td><code id="pairwise.wilcox.exact_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p> method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>). 
Can be abbreviated. </p>
</td></tr>
<tr><td><code id="pairwise.wilcox.exact_+3A_paired">paired</code></td>
<td>
<p> a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="pairwise.wilcox.exact_+3A_...">...</code></td>
<td>
<p> additional arguments to fun. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes pairwise Wilcoxon rank sum and signed rank tests.
</p>
<p>The implementation is in certain aspects analogously to 
<code><a href="stats.html#topic+pairwise.wilcox.test">pairwise.wilcox.test</a></code>. However, a more detailed 
output is generated.
</p>


<h3>Value</h3>

<p>Object of class <code>"pw.htest"</code> containing the following components:
</p>
<table>
<tr><td><code>data.name</code></td>
<td>
<p> a character string giving the names of the data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> the type of test applied.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> the location parameter mu.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p> a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p> confidence level of the confidence interval.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p> a data.frame containing the results of function 
<code><a href="exactRankTests.html#topic+wilcox.exact">wilcox.exact</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="exactRankTests.html#topic+wilcox.exact">wilcox.exact</a></code>, 
<code><a href="stats.html#topic+pairwise.wilcox.test">pairwise.wilcox.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100)
g &lt;- factor(sample(1:4, 100, replace = TRUE))
levels(g) &lt;- c("a", "b", "c", "d")
pairwise.wilcox.exact(x, g)
## in contrast to
pairwise.wilcox.test(x, g)
</code></pre>

<hr>
<h2 id='perm.t.test'>Permutation t-Test</h2><span id='topic+perm.t.test'></span><span id='topic+perm.t.test.default'></span><span id='topic+perm.t.test.formula'></span>

<h3>Description</h3>

<p>Performs one and two sample permutation t-tests on vectors of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm.t.test(x, ...)

## Default S3 method:
perm.t.test(x, y = NULL,
       alternative = c("two.sided", "less", "greater"),
       mu = 0, paired = FALSE, var.equal = FALSE,
       conf.level = 0.95, R = 9999, symmetric = TRUE, ...)

## S3 method for class 'formula'
perm.t.test(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm.t.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_y">y</code></td>
<td>
<p>an optional (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or
difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired
t-test.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the
two variances as being equal. If <code>TRUE</code> then the pooled
variance is used to estimate the variance otherwise the Welch
(or Satterthwaite) approximation to the degrees of freedom is used.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_r">R</code></td>
<td>
<p> number of (Monte-Carlo) permutations. </p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_symmetric">symmetric</code></td>
<td>
<p>a logical variable indicating whether to assume symmetry
in the two-sided test. If <code>TRUE</code> then the symmetric permutation p value 
otherwise the equal-tail permutation p value is computed.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="perm.t.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented test corresponds to the proposal of Chapter 15 of
Efron and Tibshirani (1993) for equal variances as well as Janssen (1997)
respectively Chung and Romano (2013) for unequal variances.
</p>
<p>The function returns permutation p values and confidence intervals
as well as the results ot the t-test without permutations.
</p>
<p>The formula interface is only applicable for the 2-sample tests.
</p>
<p><code>alternative = "greater"</code> is the alternative that <code>x</code> has a
larger mean than <code>y</code>.
</p>
<p>If <code>paired</code> is <code>TRUE</code> then both <code>x</code> and <code>y</code> must
be specified and they must be the same length.  Missing values are
silently removed (in pairs if <code>paired</code> is <code>TRUE</code>).  If
<code>var.equal</code> is <code>TRUE</code> then the pooled estimate of the
variance is used.  By default, if <code>var.equal</code> is <code>FALSE</code>
then the variance is estimated separately for both groups and the
Welch modification to the degrees of freedom is used.
</p>
<p>If the input data are effectively constant (compared to the larger of the
two means) an error is generated.
</p>


<h3>Value</h3>

<p>A list with class <code>"perm.htest"</code> (derived from class <code>htest</code>) 
containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the t-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the t-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>perm.p.value</code></td>
<td>
<p>the (Monte-Carlo) permutation p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the mean appropriate to the
specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>perm.conf.int</code></td>
<td>
<p>a (Monte-Carlo) permutation percentile confidence interval 
for the mean appropriate to the specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean or difference in means depending on
whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>perm.estimate</code></td>
<td>
<p> (Monte-Carlo) permutation estimate.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean
difference depending on whether it was a one-sample test or a
two-sample test.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>the standard error of the mean (difference), used as
denominator in the t-statistic formula.</p>
</td></tr>
<tr><td><code>perm.stderr</code></td>
<td>
<p> (Monte-Carlo) permutation standard error.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of t-test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Code and documentation are for large parts identical to function 
<code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>


<h3>References</h3>

<p>B. Efron, R.J. Tibshirani. <em>An Introduction to the Bootstrap</em>.
Chapman and Hall/CRC 1993.
</p>
<p>A. Janssen (1997). Studentized permutation tests for non-i.i.d, hypotheses 
and the generalized Behrens-Fisher problem. 
<em>Statistics and Probability Letters</em>, <b>36</b>, 9-21.
</p>
<p>E. Chung, J.P. Romano (2013). Exact and asymptotically robust permutation
tests. <em>The Annals of Statistics</em>, <b>41</b>(2), 484-507.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="#topic+meanCI">meanCI</a></code>, <code><a href="#topic+meanDiffCI">meanDiffCI</a></code>,
<code><a href="#topic+boot.t.test">boot.t.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

t.test(1:10, y = c(7:20))      # P = .00001855
perm.t.test(1:10, y = c(7:20))

t.test(1:10, y = c(7:20, 200)) # P = .1245    -- NOT significant anymore
perm.t.test(1:10, y = c(7:20, 200)) # perm.conf.int affected by outlier!


## Classical example: Student's sleep data
plot(extra ~ group, data = sleep)
## Traditional interface
with(sleep, t.test(extra[group == 1], extra[group == 2]))
with(sleep, perm.t.test(extra[group == 1], extra[group == 2]))
## Formula interface
t.test(extra ~ group, data = sleep)
perm.t.test(extra ~ group, data = sleep)
</code></pre>

<hr>
<h2 id='quantileCI'> Confidence Intervals for Quantiles </h2><span id='topic+quantileCI'></span><span id='topic+medianCI'></span><span id='topic+madCI'></span>

<h3>Description</h3>

<p>These functions can be used to compute confidence intervals for quantiles
(including median and MAD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileCI(x, prob = 0.5, conf.level = 0.95, method = "exact",
           R = 9999, bootci.type = c("norm", "basic", "perc", "bca"), 
           na.rm = FALSE, alternative = c("two.sided", "less", "greater"), ...)
medianCI(x, conf.level = 0.95, method = "exact",
         R = 9999, bootci.type = c("norm", "basic", "perc", "bca"), 
         na.rm = FALSE, alternative = c("two.sided", "less", "greater"), ...)
madCI(x, conf.level = 0.95, method = "exact", 
      R = 9999, bootci.type = c("norm", "basic", "perc", "bca"), 
      na.rm = FALSE, constant = 1.4826, 
      alternative = c("two.sided", "less", "greater"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileCI_+3A_x">x</code></td>
<td>
<p> numeric data vector </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_prob">prob</code></td>
<td>
<p> quantile </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_conf.level">conf.level</code></td>
<td>
<p> confidence level </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_method">method</code></td>
<td>
<p> character string specifing which method to use; see details. </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_r">R</code></td>
<td>
<p> number of bootstrap replicates. </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_bootci.type">bootci.type</code></td>
<td>
<p> type of bootstrap interval; see <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>. </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_na.rm">na.rm</code></td>
<td>
<p> logical, remove <code>NA</code> values. </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_constant">constant</code></td>
<td>
<p> scale factor (see <code><a href="stats.html#topic+mad">mad</a></code>). </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying one- or two-sided confidence intervals. 
Must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot; (one-sided intervals). 
You can specify just the initial letter. </p>
</td></tr>
<tr><td><code id="quantileCI_+3A_...">...</code></td>
<td>
<p> further arguments passed to function <code><a href="boot.html#topic+boot">boot</a></code>,
e.g. for parallel computing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact confidence interval (<code>method = "exact"</code>) is computed using binomial
probabilities; see Section 6.8.1 in Sachs and Hedderich (2009). If the result is not
unique, i.e. there is more than one interval with coverage proability closest to
<code>conf.level</code>, the shortest confidence interval is returned.
</p>
<p>The asymptotic confidence interval (<code>method = "asymptotic"</code>) is based on the
normal approximation of the binomial distribution; see Section 6.8.1 in Sachs and Hedderich (2009).
</p>
<p>In case of discrete data, there are alternative bootstrap approaches that might 
give better results; see Jentsch and Leucht (2016).
</p>
<p>Since <code>madCI</code> is computed as the median confidence interval of the 
absolut deviations from the sample median and ignores the variablity of the 
sample median, the exact and asymptotic confidence intervals might be too short.
We recommend to use bootstrap confidence intervals.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p> the sample quantile. </p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p> a confidence interval for the sample quantile. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>L. Sachs and J. Hedderich (2009). <em>Angewandte Statistik</em>. Springer.
</p>
<p>C. Jentsch and A. Leucht (2016). Bootstrapping sample quantiles of discrete data.
<em>Ann Inst Stat Math</em>, <b>68</b>: 491-539.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## To get a non-trivial exact confidence interval for the median
## one needs at least 6 observations
x &lt;- rnorm(5)
medianCI(x)

## asymptotic confidence interval
medianCI(x, method = "asymptotic")
madCI(x, method = "asymptotic")

## bootstrap confidence interval
x &lt;- rnorm(50)
medianCI(x)
medianCI(x, method = "asymptotic")
## (R = 999 to reduce computation time for R checks)
medianCI(x, method = "boot", R = 999)

madCI(x)
madCI(x, method = "asymptotic")
## (R = 999 to reduce computation time for R checks)
madCI(x, method = "boot", R = 999)

## confidence interval for quantiles
quantileCI(x, prob = 0.25)
quantileCI(x, prob = 0.25, method = "asymptotic")

quantileCI(x, prob = 0.75)
## (R = 999 to reduce computation time for R checks)
quantileCI(x, prob = 0.75, method = "boot", R = 999)

## one-sided
quantileCI(x, prob = 0.75, alternative = "greater")
medianCI(x, alternative = "less", method = "asymptotic")
madCI(x, alternative = "greater", method = "boot", R = 999)


## parallel computing for bootstrap
medianCI(x, method = "boot", R = 9999, parallel = "multicore", 
         ncpus = 2)

</code></pre>

<hr>
<h2 id='rm.oneway.test'>Test for Equal Means in a Repeated Measures One-Way Layout</h2><span id='topic+rm.oneway.test'></span>

<h3>Description</h3>

<p>Test whether two or more samples have the same locations in a repeated
measures setting. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.oneway.test(x, g, id, method = "aov")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.oneway.test_+3A_x">x</code></td>
<td>
<p> numeric, response (outcome, dependent) variable.</p>
</td></tr>
<tr><td><code id="rm.oneway.test_+3A_g">g</code></td>
<td>
<p> factor, grouping (independent) variable.</p>
</td></tr>
<tr><td><code id="rm.oneway.test_+3A_id">id</code></td>
<td>
<p> factor, subject id (blocking variable).</p>
</td></tr>
<tr><td><code id="rm.oneway.test_+3A_method">method</code></td>
<td>
<p> name of method, possible methods are <code>"aov"</code>, <code>"lme"</code>, 
<code>"friedman"</code>, <code>"quade"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function wraps the functions <code><a href="stats.html#topic+aov">aov</a></code>, <code><a href="nlme.html#topic+lme">lme</a></code>, 
<code><a href="stats.html#topic+friedman.test">friedman.test</a></code> and <code><a href="stats.html#topic+quade.test">quade.test</a></code> into one function 
for a repeated measures one-way layout.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom of the exact or approximate F
distribution of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambers, J. M., Freeny, A and Heiberger, R. M. (1992), 
<em>Analysis of variance; designed experiments. Chapter 5 of Statistical Models in S</em>,
eds J. M. Chambers and T. J. Hastie, Wadsworth and Brooks/Cole.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000), <em>Mixed-Effects Models in S and S-PLUS</em>, 
Springer.
</p>
<p>Myles Hollander and Douglas A. Wolfe (1973), <em>Nonparametric Statistical Methods</em>. 
New York: John Wiley and Sons. Pages 139-146.
</p>
<p>D. Quade (1979), Using weighted rankings in the analysis of complete blocks 
with additive block effects. <em>Journal of the American Statistical Association</em> 
<b>74</b>, 680-683.
</p>
<p>William J. Conover (1999), <em>Practical nonparametric statistics</em>. 
New York: John Wiley and Sons. Pages 373-380.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aov">aov</a></code>, <code><a href="nlme.html#topic+lme">lme</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>, 
<code><a href="stats.html#topic+quade.test">quade.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
outcome &lt;- c(rnorm(10), rnorm(10, mean = 1.5), rnorm(10, mean = 1))
timepoints &lt;- factor(rep(1:3, each = 10))
patients &lt;- factor(rep(1:10, times = 3))
rm.oneway.test(outcome, timepoints, patients)
rm.oneway.test(outcome, timepoints, patients, method = "lme")
rm.oneway.test(outcome, timepoints, patients, method = "friedman")
rm.oneway.test(outcome, timepoints, patients, method = "quade")
</code></pre>

<hr>
<h2 id='volcano'> Volcano Plots </h2><span id='topic+volcano'></span><span id='topic+volcano.default'></span>

<h3>Description</h3>

<p>Produce volcano plot(s) of the given effect size and p values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volcano(x, ...)

## Default S3 method:
volcano(x, pval, effect0 = 0, sig.level = 0.05, 
                            effect.low = NULL, effect.high = NULL,
                            color.low = "#4575B4", color.high = "#D73027",
                            xlab = "effect size", ylab = "-log10(p value)",
                            title = "Volcano Plot", alpha = 1, shape = 19, 
                            na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volcano_+3A_x">x</code></td>
<td>
<p> in case of default method: measure of effect size.</p>
</td></tr>
<tr><td><code id="volcano_+3A_pval">pval</code></td>
<td>
<p> numeric, (adjusted) p values.</p>
</td></tr>
<tr><td><code id="volcano_+3A_effect0">effect0</code></td>
<td>
<p> single numeric, value for no effect.</p>
</td></tr>
<tr><td><code id="volcano_+3A_sig.level">sig.level</code></td>
<td>
<p> single numeric, significance level.</p>
</td></tr>
<tr><td><code id="volcano_+3A_effect.low">effect.low</code></td>
<td>
 <p><code>NULL</code> or single numeric, boundary for low effect sizes.</p>
</td></tr>
<tr><td><code id="volcano_+3A_effect.high">effect.high</code></td>
<td>
 <p><code>NULL</code> or single numeric, boundary for low effect sizes.</p>
</td></tr>
<tr><td><code id="volcano_+3A_color.low">color.low</code></td>
<td>
<p> color used if effect size smaller than <code>effect.low</code> and 
(adjusted) p value smaller than <code>sig.level</code>.</p>
</td></tr>
<tr><td><code id="volcano_+3A_color.high">color.high</code></td>
<td>
<p> color used if effect size larger than <code>effect.high</code> and 
(adjusted) p value smaller than <code>sig.level</code>.</p>
</td></tr>
<tr><td><code id="volcano_+3A_xlab">xlab</code></td>
<td>
<p> label of x-axis.</p>
</td></tr>
<tr><td><code id="volcano_+3A_ylab">ylab</code></td>
<td>
<p> label of y-axis.</p>
</td></tr>
<tr><td><code id="volcano_+3A_title">title</code></td>
<td>
<p> title of plot.</p>
</td></tr>
<tr><td><code id="volcano_+3A_alpha">alpha</code></td>
<td>
<p> blending factor (default: no blending.</p>
</td></tr>
<tr><td><code id="volcano_+3A_shape">shape</code></td>
<td>
<p> point shape used.</p>
</td></tr>
<tr><td><code id="volcano_+3A_na.rm">na.rm</code></td>
<td>
<p> single logical, remove <code>NA</code> values before plotting.</p>
</td></tr>
<tr><td><code id="volcano_+3A_...">...</code></td>
<td>
<p> further arguments that may be passed through.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot generates a <code>ggplot2</code> object that is shown. 
</p>


<h3>Value</h3>

<p>Object of class <code>gg</code> and <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Wikipedia contributors, <em>Volcano plot (statistics)</em>, Wikipedia, The Free Encyclopedia, 
<a href="https://en.wikipedia.org/w/index.php?title=Volcano_plot_(statistics)&amp;oldid=900217316">https://en.wikipedia.org/w/index.php?title=Volcano_plot_(statistics)&amp;oldid=900217316</a> 
(accessed December 25, 2019). 
</p>
<p>For more sophisticated and flexible volcano plots see for instance:
Blighe K, Rana S, Lewis M (2019). EnhancedVolcano: Publication-ready volcano 
plots with enhanced colouring and labeling. R/Bioconductor package.
<a href="https://github.com/kevinblighe/EnhancedVolcano">https://github.com/kevinblighe/EnhancedVolcano</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data
x &lt;- matrix(rnorm(1000, mean = 10), nrow = 10)
g1 &lt;- rep("control", 10)
y1 &lt;- matrix(rnorm(500, mean = 11.75), nrow = 10)
y2 &lt;- matrix(rnorm(500, mean = 9.75, sd = 3), nrow = 10)
g2 &lt;- rep("treatment", 10)
group &lt;- factor(c(g1, g2))
Data &lt;- rbind(x, cbind(y1, y2))
pvals &lt;- apply(Data, 2, function(x, group) hsu.t.test(x ~ group)$p.value,
               group = group)
## compute log-fold change
logfc &lt;- function(x, group){
  res &lt;- tapply(x, group, mean)
  log2(res[1]/res[2])
}
lfcs &lt;- apply(Data, 2, logfc, group = group)

volcano(lfcs, pvals, xlab = "log-fold change")
volcano(lfcs, pvals, effect.low = -0.25, effect.high = 0.25, 
        xlab = "log-fold change")
volcano(lfcs, p.adjust(pvals, method = "fdr"), 
        effect.low = -0.25, effect.high = 0.25, 
        xlab = "log-fold change", ylab = "-log10(adj. p value)")
volcano(2^lfcs, pvals, effect0 = 1, effect.low = 1/2^0.25, effect.high = 2^0.25,
        xlab = "mean difference")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
