<!DOCTYPE html><html><head><title>Help for package asnipe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {asnipe}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asnipe-package'>
<p>Animal Social Network inference and Permutation: asnipe</p></a></li>
<li><a href='#gbi'>
<p>Detections of Individuals Forming Flocks at Bird Feeders</p></a></li>
<li><a href='#get_associations_points_tw'>
<p>Calculate Group Membership using Time Window (please read warnings before using this method)</p></a></li>
<li><a href='#get_group_by_individual'>
<p>Convert group or individual data into a group by individual matrix</p></a></li>
<li><a href='#get_network'>
<p>Calculating Weighted Network</p></a></li>
<li><a href='#get_sampling_periods'>
<p>Convert group or individual data into sampling periods</p></a></li>
<li><a href='#gmmevents'>
<p>Infer gathering events</p></a></li>
<li><a href='#identified_individuals'>
<p>Raw Observation Data of Individual Birds Feeding at Flocks</p></a></li>
<li><a href='#inds'>
<p>Data on the Individual Birds Contained in the Group by Individual data</p></a></li>
<li><a href='#LAR'>
<p>Mean Lagged Association Rate</p></a></li>
<li><a href='#LRA'>
<p>Dyadic Lagged Association Rate</p></a></li>
<li><a href='#mrqap.custom.null'>
<p>MRQAP function with custom permutation networks</p></a></li>
<li><a href='#mrqap.dsp'>
<p>MRQAP with Double-Semi-Partialing (DSP)</p></a></li>
<li><a href='#network_permutation'>
<p>Perform Permutation</p></a></li>
<li><a href='#network_swap'>
<p>Perform one (or more) random swap</p></a></li>
<li><a href='#print.mrqap.dsp'>
<p>Print function for mrqap.dsp</p></a></li>
<li><a href='#times'>
<p>Observation Time for each Flock Contained in the Group by Individual data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Animal Social Network Inference and Permutations for Ecologists</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.17</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Damien R. Farine &lt;dfarine@ab.mpg.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Damien R. Farine &lt;dfarine@ab.mpg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements several tools that are used in animal social network analysis, as described in Whitehead (2007) Analyzing Animal Societies &lt;University of Chicago Press&gt; and Farine &amp; Whitehead (2015) &lt;<a href="https://doi.org/10.1111%2F1365-2656.12418">doi:10.1111/1365-2656.12418</a>&gt;. In particular, this package provides the tools to infer groups and generate networks from observation data, perform permutation tests on the data, calculate lagged association rates, and performed multiple regression analysis on social network data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-15 06:03:52 UTC; damienfarine</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, raster, sna</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-15 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asnipe-package'>
Animal Social Network inference and Permutation: asnipe
</h2><span id='topic+asnipe-package'></span><span id='topic+asnipe'></span>

<h3>Description</h3>

<p>Provides functions for infering associations, building social networks, performing permutations, and regression testing
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> asnipe</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.17</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-15</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Written by Damien R. Farine
</p>
<p>Maintainer: Damien R. Farine &lt;dfarine@ab.mpg.de&gt;
</p>

<hr>
<h2 id='gbi'>
Detections of Individuals Forming Flocks at Bird Feeders
</h2><span id='topic+gbi'></span>

<h3>Description</h3>

<p>Dataset consisting of 151 individuals of 5 passerine species in Wytham Woods, UK: 78 blue tits (Cyanistes caeruleus), 7 coal tits (Periparus ater), 51 great tits (Parus major), 11 marsh tits (Poecile palustris), 3 nuthatches (Sitta europaea) and 1 individual of unknown species. Individuals were all fitted with individually-encoded passive integrated transponder (PIT) tags  that were logged by radio frequency identification (RFID) antennae fitted to each hole on regular sunflower feeders (we used unhusked sunflower seed). Data were collected from 4 feeders spaced approximately 300m over the course of one day. Feeders logged the presence of individuals at a sub-second resolution, and detections were assigned to flocks using a machine learning algorithm (a Gaussian Mixture Model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("group_by_individual")</code></pre>


<h3>Format</h3>

<p>Data are formatted in a group by individual matrix. Each row represents one flock, each column represents one individual.
</p>


<h3>Source</h3>

<p>Farine, D.R., Garroway, C.J., Sheldon, B.C. (2012) Social Network Analysis of mixed-species flocks: exploring the structure and evolution of interspecific social behaviour. Animal Behaviour 84: 1271-1277.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("group_by_individual")
str(gbi) # see the structure of the data
</code></pre>

<hr>
<h2 id='get_associations_points_tw'>
Calculate Group Membership using Time Window (please read warnings before using this method)
</h2><span id='topic+get_associations_points_tw'></span>

<h3>Description</h3>

<p>A time window approach to calculate group co-memberships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_associations_points_tw(point_data, time_window = 180, which_days = NULL, 
	which_locations = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_associations_points_tw_+3A_point_data">point_data</code></td>
<td>

<p>dataframe of four columns: <code>Date  Time  ID  Location</code>.  This requirement is strict (see details).
</p>
</td></tr>
<tr><td><code id="get_associations_points_tw_+3A_time_window">time_window</code></td>
<td>

<p>window around each individual for calculating associations
</p>
</td></tr>
<tr><td><code id="get_associations_points_tw_+3A_which_days">which_days</code></td>
<td>

<p>subset of <code>Date</code> to include
</p>
</td></tr>
<tr><td><code id="get_associations_points_tw_+3A_which_locations">which_locations</code></td>
<td>

<p>subset of <code>Locations</code> to include
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates an ego-centric approach to group membership (see warning).  For each detection, a group is created with and all associates within the time window at the same location are included.  
</p>
<p>Input data must be of the following form:  Date is an integer for day (usually starting at 1 on the first day).  Time are the number of seconds elapsed from the start (continuous across all dates).  ID is a unique character string for each individual.  Location is a unique character string for each location.
</p>


<h3>Value</h3>

<p>Returns a list with three objects:
1. group by individual matrix (K rows by N columns)
2. an vector of times for each group
3. a vector of dates for each group
4. a vector of locations for each group
</p>


<h3>Warning </h3>

<p>This method biases associations of dyads occuring in large groups because it creates one row in the association matrix for each detection of an individual. For this reason, this function should not be used (see also Psorakis et al. 2015 Behavioural Ecology &amp; Sociobiology). One way to circumvent this is by including only groups centered around the focal individual when calculating associations. However, none of the functions in this package are implement this way.
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("identified_individuals")

## calculate group_by_individual for first day at one location
group_by_individual &lt;- get_associations_points_tw(identified_individuals, time_window=180, 
	which_days=1,which_locations="1B")

## split the resulting list
times &lt;- group_by_individual[[2]]
dates &lt;- group_by_individual[[3]]
locations &lt;- group_by_individual[[4]]
group_by_individual &lt;- group_by_individual[[1]]

</code></pre>

<hr>
<h2 id='get_group_by_individual'>
Convert group or individual data into a group by individual matrix
</h2><span id='topic+get_group_by_individual'></span>

<h3>Description</h3>

<p>Converts several different types of data storage into a group by individual matrix for calculating or permuting networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group_by_individual(association_data, identities = NULL, 
location = NULL, data_format = c("groups", "individuals"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_group_by_individual_+3A_association_data">association_data</code></td>
<td>

<p>Can be either a group by individual matrix or a list containing group members in each element
</p>
</td></tr>
<tr><td><code id="get_group_by_individual_+3A_identities">identities</code></td>
<td>

<p>Optional identities for each individual in the dataset
</p>
</td></tr>
<tr><td><code id="get_group_by_individual_+3A_location">location</code></td>
<td>

<p>Returns these spatial locations for each group
</p>
</td></tr>
<tr><td><code id="get_group_by_individual_+3A_data_format">data_format</code></td>
<td>

<p>Format of the input data
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate an <code>K x N</code> matrix representing <code>K</code> groups and <code>N</code> individuals. If locations are included, these will be returned in the row names.
</p>


<h3>Value</h3>

<p>Returns a <code>K x N</code> matrix, where each <code>K</code> row is an group defined from the input data. Column names of the matrix are given the identity where available. The K row names are given either the time or time_location for each group.
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define group memberships (these would be read from a file)
individuals &lt;- data.frame(ID=c("C695905","H300253","H300253",
	"H300283","H839876","F464557","H300296","H300253",
	"F464557","H300296","C695905","H300283","H839876"),
	GROUP=c(1,1,2,2,2,3,3,4,5,5,6,6,6))

## create a time column
individuals &lt;- cbind(individuals,
	DAY=c(1,1,1,1,1,2,2,2,3,3,3,3,3))

gbi &lt;- get_group_by_individual(individuals, 
	data_format="individuals")
	
## define group memberships (these would be read from a file)
groups &lt;- list(G1=c("C695905","H300253"),
	G2=c("H300253","H300283","H839876"),
	G3=c("F464557","H300296"),
	G4=c("H300253"),
	G5=c("F464557","H300296"),
	G6=c("C695905","H300283","H839876"))

## create a time variable
days &lt;- c(1,1,2,2,3,3)

gbi &lt;- get_group_by_individual(groups, 
	data_format="groups")

</code></pre>

<hr>
<h2 id='get_network'>
Calculating Weighted Network
</h2><span id='topic+get_network'></span>

<h3>Description</h3>

<p>Calculate a network from a group by individual matrix.  This function allows various levels of subsetting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network(association_data, data_format = "GBI", 
	association_index = "SRI", identities = NULL, 
	which_identities = NULL, times = NULL, occurrences = NULL,
	locations = NULL, which_locations = NULL, start_time = NULL, 
	end_time = NULL, classes = NULL, which_classes = NULL,
	enter_time = NULL, exit_time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_network_+3A_association_data">association_data</code></td>
<td>

<p>a <code>K x N</code> matrix of K groups (observations, gathering events, etc.) and N individuals (all individuals that are present in at least one group) OR a <code>K x N x N</code> array of sampling periods.
</p>
</td></tr>
<tr><td><code id="get_network_+3A_data_format">data_format</code></td>
<td>

<p><code>"GBI"</code> expect a group by individual matrix, <code>"SP"</code> Expect a sampling periods array
</p>
</td></tr>
<tr><td><code id="get_network_+3A_association_index">association_index</code></td>
<td>

<p><code>"SRI"</code> Simple ratio index, <code>"HWI"</code> Half-weight index (more to come)
</p>
</td></tr>
<tr><td><code id="get_network_+3A_identities">identities</code></td>
<td>

<p>N vector of identifiers for each individual (column) in the group by individual matrix
</p>
</td></tr>
<tr><td><code id="get_network_+3A_which_identities">which_identities</code></td>
<td>

<p>vector of identities to include in the network (subset of identities)
</p>
</td></tr>
<tr><td><code id="get_network_+3A_times">times</code></td>
<td>

<p>K vector of times defining the middle of each group/event
</p>
</td></tr>
<tr><td><code id="get_network_+3A_occurrences">occurrences</code></td>
<td>

<p>N x S matrix with the occurrence of each individual in each sampling period (see details) containing only 0s and 1s
</p>
</td></tr>
<tr><td><code id="get_network_+3A_locations">locations</code></td>
<td>

<p>K vector of locations defining the location of each group/event
</p>
</td></tr>
<tr><td><code id="get_network_+3A_which_locations">which_locations</code></td>
<td>

<p>vector of locations to include in the network (subset of locations)
</p>
</td></tr>
<tr><td><code id="get_network_+3A_start_time">start_time</code></td>
<td>

<p>element describing the starting time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="get_network_+3A_end_time">end_time</code></td>
<td>

<p>element describing the ending time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="get_network_+3A_classes">classes</code></td>
<td>

<p>N vector of types or class of each individual (column) in the group by individual matrix (for subsetting)
</p>
</td></tr>
<tr><td><code id="get_network_+3A_which_classes">which_classes</code></td>
<td>

<p>vector of class(es)/type(s) to include in the network (subset of classes)
</p>
</td></tr>
<tr><td><code id="get_network_+3A_enter_time">enter_time</code></td>
<td>

<p>N vector of times when each individual entered the population
</p>
</td></tr>
<tr><td><code id="get_network_+3A_exit_time">exit_time</code></td>
<td>

<p>N vector of times when each individual departed the population 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides the ability to generate networks from one group by individual matrix and subsetting within the function.  This is particularly useful for generating several networks with different characteristics from the same group by individual matrix (for example networks from a given location or set of locations, or of a particular sex).
</p>
<p>Including occurrence data is recommended when using sampling periods (not required for GBI data). If an individual is only observed alone in a sampling period, then it will not be included in the sampling period matrices (as these record only associations or interactions, not presence). Thus, a matrix containing N (for number of individuals) rows and S (for number of sampling periods) is required. See the get_sampling_periods function for help generating this matrix.
</p>
<p>In some situations it is useful to calculate the network based only on the period in which each dyad overlapped within the population. In such cases, the entry_time and/or the exit_time variables can be given. These must given in the same format as the times variable, and all need to be in a format capable of doing time or date comparisons using &gt; and &lt; operators. The easiest is YYYYMMDD, whereas MMDDYYYY or DDMMYYYY will not work properly.
</p>


<h3>Value</h3>

<p><code>N x N</code> matrix of association weights for each dyad.
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Whitehead (2008) <em>Analyzing Animal Societies</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("group_by_individual")
data("times")

# subset GBI (to reduce run time of the example)
gbi &lt;- gbi[,1:80]

## define to 2 x N x N network to hold two association matrices
networks &lt;- array(0, c(2, ncol(gbi), ncol(gbi)))

## calculate network for first half of the time
networks[1,,] &lt;- get_network(gbi, data_format="GBI",
	association_index="SRI", times=times, start_time=0, 
	end_time=max(times)/2)
networks[2,,] &lt;- get_network(gbi, data_format="GBI",
	association_index="SRI", times=times, 
	start_time=max(times)/2, end_time=max(times))

## test if one predicts the other via a mantel test (must be loaded externally)
library(ape)
mantel.test(networks[1,,],networks[2,,])

## convert to igraph network and calculate degree of the first network
## Not run: 
library(igraph)
net &lt;- graph.adjacency(networks[1,,], mode="undirected", diag=FALSE, weighted=TRUE)
deg_weighted &lt;- graph.strength(net)
detach(package:igraph)


## alternatively package SNA can use matrix stacks directly
library(sna)
deg_weighted &lt;- degree(networks,gmode="graph", g=c(1,2), ignore.eval=FALSE)
detach(package:sna)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_sampling_periods'>
Convert group or individual data into sampling periods
</h2><span id='topic+get_sampling_periods'></span>

<h3>Description</h3>

<p>Converts several different types of data storage into sampling periods for calculating or permuting networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sampling_periods(association_data, association_times, sampling_period, 
identities = NULL, location = NULL, within_locations = FALSE, 
data_format = c("gbi", "groups", "individuals"), return="SP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sampling_periods_+3A_association_data">association_data</code></td>
<td>

<p>Can be either a group by individual matrix, a list containing group members in each element, or a two-column data frame with individual ID in the first column and group ID in the second column
</p>
</td></tr>
<tr><td><code id="get_sampling_periods_+3A_association_times">association_times</code></td>
<td>

<p>Because sampling periods are inferred over time, each group must contain some time data (can be in any format, such as seconds, days, etc.). One time must be provided for each row of the association data.
</p>
</td></tr>
<tr><td><code id="get_sampling_periods_+3A_sampling_period">sampling_period</code></td>
<td>

<p>The number of time periods over which data are combined (for example 10 days, 3600 seconds)
</p>
</td></tr>
<tr><td><code id="get_sampling_periods_+3A_identities">identities</code></td>
<td>

<p>Optional identities for each individual in the dataset
</p>
</td></tr>
<tr><td><code id="get_sampling_periods_+3A_location">location</code></td>
<td>

<p>If spatial disaggregation need to be maintained, samping periods can be calculated per time per location
</p>
</td></tr>
<tr><td><code id="get_sampling_periods_+3A_within_locations">within_locations</code></td>
<td>

<p>Flag whether to include location information
</p>
</td></tr>
<tr><td><code id="get_sampling_periods_+3A_data_format">data_format</code></td>
<td>

<p>Format of the input data
</p>
</td></tr>
<tr><td><code id="get_sampling_periods_+3A_return">return</code></td>
<td>

<p>By default (&quot;SP&quot;) returns the sampling periods. Anything else will return the occurrence data (see get_network function)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate an association matrix for each sampling period. If locations are included, these will be treated independently.
</p>


<h3>Value</h3>

<p>Returns a <code>K x N x N</code> stack of matrices, where each <code>N x N</code> slice is an association matrix. Row names and Column names of these slices are given the identity where available. The K slice names are given either the time or time_location for each sampling period. Alternatively (return != &quot;SP&quot;) the function returns the occurrence of each individual in each sampling period, with individuals as rows and sampling periods as columns.
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define group memberships (these would be read from a file)
individuals &lt;- data.frame(ID=c("C695905","H300253","H300253",
	"H300283","H839876","F464557","H300296","H300253",
	"F464557","H300296","C695905","H300283","H839876"),
	GROUP=c(1,1,2,2,2,3,3,4,5,5,6,6,6))

## create a time column
individuals &lt;- cbind(individuals,
	DAY=c(1,1,1,1,1,2,2,2,3,3,3,3,3))

SPs &lt;- get_sampling_periods(individuals[,c(1,2)],
	individuals[,3],1,data_format="individuals")
occurs &lt;- get_sampling_periods(individuals[,c(1,2)],
	individuals[,3],1,data_format="individuals", return="occ")
	
## define group memberships (these would be read from a file)
groups &lt;- list(G1=c("C695905","H300253"),
	G2=c("H300253","H300283","H839876"),
	G3=c("F464557","H300296"),
	G4=c("H300253"),
	G5=c("F464557","H300296"),
	G6=c("C695905","H300283","H839876"))

## create a time variable
days &lt;- c(1,1,2,2,3,3)

SPs &lt;- get_sampling_periods(groups,
	days,1,data_format="groups")
occurs &lt;- get_sampling_periods(groups,
	days,1,data_format="groups", return="occ")

</code></pre>

<hr>
<h2 id='gmmevents'>
Infer gathering events
</h2><span id='topic+gmmevents'></span>

<h3>Description</h3>

<p>Infer gathering events (groups or flocks) from a temporal datastream of observations, such as PIT tag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmmevents(time, identity, location, global_ids=NULL, verbose=TRUE, splitGroups=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmmevents_+3A_time">time</code></td>
<td>

<p>The timestamp for the observation. Must be a real number (i.e. not a date or time format). See details below.
</p>
</td></tr>
<tr><td><code id="gmmevents_+3A_identity">identity</code></td>
<td>

<p>The identify of the individual in each observation (can be a number or a string, e.g. PIT tag code).
</p>
</td></tr>
<tr><td><code id="gmmevents_+3A_location">location</code></td>
<td>

<p>The location of the observation (can be a number or a string).
</p>
</td></tr>
<tr><td><code id="gmmevents_+3A_global_ids">global_ids</code></td>
<td>

<p>A vector of all the IDs in the study, used if consistency needs to be maintained across datasets.
</p>
</td></tr>
<tr><td><code id="gmmevents_+3A_verbose">verbose</code></td>
<td>

<p>Whether to print out progress and information.
</p>
</td></tr>
<tr><td><code id="gmmevents_+3A_splitgroups">splitGroups</code></td>
<td>

<p>Whether or not to split overlappling groups (see details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gmmevents function has 3 primary inputs: time, identity, and location:
</p>
<p>The time must be a number representing a real valued time stamp. This can be number of seconds since the start of the day, number of seconds since the start of the study, hour of the day, Julian date, etc. The time stamps should represent a meaningful scale given the group membership definition - for example if an edge is the propensity to observe an individual at the same location on the same day, then time stamps should be the day value. In the example below, the time stamps are in seconds, because flocks of birds visit feeders over a matter of minutes and the group definition is being in the same flock (and these occur over seconds to minutes). The input must be numeric whole numbers.
</p>
<p>The identity is the unique identifier for each individual. This should be consistent across all of the data sets. In the example here, PIT tags are given, but in broader analyses, we would convert these to ring (band) numbers because individuals can have different PIT tag numbers in the course of the study but never change ring numbers. The function will accept any string or numeric input.
</p>
<p>The location is where the observation took place. This should reflect meaningful observation locations for the study. The function will accept any string or numeric inputs.
</p>
<p>If the analysis is being conducted as part of a broader analysis in the same populations, it can be useful to get the results in a consistent form each time. In that case, the global_ids variable can be used to maintain consistency each time an analysis is run, regardless of which individuals were identified in the current input data. That is, the group by individual (gbi) matrix will include a column for every individual provided in global_ids.
</p>
<p>Further notes on usage:
</p>
<p>The gmm_events functions requires a few careful considerations. First, the amount of memory used is the square of the amount of data - so having many observations in a given location can run out of memory. With 16gb of RAM, generally up to 10,000 observations per location (per day - see next point) seems to be a safe limit.
</p>
<p>The input data provided for each location should take into account any artificial gaps in the observation stream. For example, if there are gaps in data collection at a given location, then the location information provided into the gmm_events function should be split into two 'locations' to represent each continuous set of observations. For example, in the PIT tag data set provided there are 8 days of sampling. Providing gmm_events with only the location data from the original data will cause the gap between days to override any gaps between groups (or flocks) within a given day. To overcome this, instead of providing the gmm_events function with just the location, it is important to provide a location by day variable. This variable is then returned in the metadata and the information extracted out again (using strsplit - see example below). 
</p>
<p>Finally, I have included a new variable called splitGroups. The original function (in both Matlab and R) would return the occasional group that overlapped other groups. This occured when a small group was extracted from the data, and then the remaining observations were formed into a larger group that spanned the smaller group from the same location. For example, say detections of individuals are made in the same location at 2,8,10,11,12,14,20 seconds, and the first group extracted contains 10,11,12 then the remaining data look like an evenly-spread group (2,8,14,20). Setting splitGroups=TRUE identifies such incidences and would split the data into three groups (2,8), (10,11,12), and (14,20). 
</p>


<h3>Value</h3>

<p>Returns a list containing three items:
</p>
<p>The first item is the group by individual matrix (gbi), which is a matrix where each row is a gathering event - or group - and each column is an individual. Cells in the matrix have a value of 1 if the individual was observed in that gathering event, and 0 if not. 
</p>
<p>The second item is a matrix containing three columns: the start time, end time, and location of each detected event. The number of rows in this events matrix matches the number of rows in the gbi file, and the rows correspond to one another (thus, row 3 of the gbi has the start and end times, and location, of row 3 of the events matrix).
</p>
<p>The third item has the same structure as the group by individual matrix, but instead of being binary (0 or 1), it contains the number of observations of each individual in each event.
</p>


<h3>Author(s)</h3>

<p>Ioannis Psorakis (original code) <br />
Julian Evans (R implementation) <br />
Damien R. Farine (current implementation)
</p>


<h3>References</h3>

<p>Psorakis, I., Roberts, S. J., Rezek, I., &amp; Sheldon, B. C. (2012). Inferring social network structure in ecological systems from spatio-temporal data streams. Journal of the Royal Society Interface, 9(76), 3055-3066. doi:10.1098/Rsif.2012.0223 <br />
Psorakis, I., Voelkl, B., Garroway, C. J., Radersma, R., Aplin, L. M., Crates, R. A., Culina, A., Farine, D. R., Firth, J.A., Hinde, C.A., Kidd, L.R., Milligan, N.D., Roberts, S.J., Verhelst, B., Sheldon, B. C. (2015). Inferring social structure from temporal data. Behavioral Ecology and Sociobiology, 69(5), 857-866. doi:10.1007/s00265-015-1906-0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


	library(asnipe)
	data("identified_individuals")
	
	# Create unique locations in time
	identified_individuals$Loc_date &lt;- 
		paste(identified_individuals$Location,
		identified_individuals$Date,sep="_")

	# Provide global identity list (including individuals 
	# not found in these data, but that need to be included).
	# Not including this will generate gbi with only the
	# individuals provided in the data set (in this case 151
	# individuals)
	global_ids &lt;- levels(identified_individuals$ID)
	
	# Generate GMM data
	gmm_data &lt;- gmmevents(time=identified_individuals$Time,
		identity=identified_individuals$ID,
		location=identified_individuals$Loc_date,
		global_ids=global_ids)

	# Extract output
	gbi &lt;- gmm_data$gbi
	events &lt;- gmm_data$metadata
	observations_per_event &lt;- gmm_data$B

	# Can also subset gbi to only individuals observed
	# in the dataset to give same answer as if 
	# global_ids had not been provided
	gbi &lt;- gbi[,which(colSums(gbi)&gt;0)]

	# Split up location and date data
	tmp &lt;- strsplit(events$Location,"_")
	tmp &lt;- do.call("rbind",tmp)
	events$Location &lt;- tmp[,1]
	events$Date &lt;- tmp[,2]



</code></pre>

<hr>
<h2 id='identified_individuals'>
Raw Observation Data of Individual Birds Feeding at Flocks
</h2><span id='topic+identified_individuals'></span>

<h3>Description</h3>

<p>Contains the raw observation data, of which the first day was used to form the group by individual file. IDs correspond to TAG in the &quot;individuals&quot; data (note that some tags are error codes, which have not been removed, and thus do not occur in the individuals data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("identified_individuals")</code></pre>


<h3>Format</h3>

<p>Data frame containing 4 columns:
Date - The observation day (1 to 8, where days 1-2 are the first weekend, 3-4 the second weekend, etc..)
Time - The time in seconds since the very first observation
ID - The PIT tag code of the individual
Location - The location where the detection was made (1B, 1C, 1D, 1E)
</p>


<h3>Source</h3>

<p>Farine, D.R., Garroway, C.J., Sheldon, B.C. (2012) Social Network Analysis of mixed-species flocks: exploring the structure and evolution of interspecific social behaviour. Animal Behaviour 84: 1271-1277.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("identified_individuals")
head(identified_individuals)
table(identified_individuals$Location)
</code></pre>

<hr>
<h2 id='inds'>
Data on the Individual Birds Contained in the Group by Individual data
</h2><span id='topic+inds'></span>

<h3>Description</h3>

<p>Information about the PIT tag number, ring number, species, and sex (where available) for each individual in the group by individual data. Each row represents one column in the group by individual file, and the order is maintained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("individuals")</code></pre>


<h3>Format</h3>

<p>Data frame containing:
TAG - A 10 character hexadecimal code unique to each individual
RING.NUMBER - A 7 character unique ring (or band) number for each individual
SPECIES - Each species, where BLUTI=blue tit, COATI=coal tit, GRETI=great tit, MARTI=marsh tit, and NUTHA=nuthatch
</p>


<h3>Source</h3>

<p>Farine, D.R., Garroway, C.J., Sheldon, B.C. (2012) Social Network Analysis of mixed-species flocks: exploring the structure and evolution of interspecific social behaviour. Animal Behaviour 84: 1271-1277.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("individuals")
data("group_by_individual")
colnames(gbi) &lt;- inds$RING.NUMBER
</code></pre>

<hr>
<h2 id='LAR'>
Mean Lagged Association Rate
</h2><span id='topic+LAR'></span>

<h3>Description</h3>

<p>Calculate lagged association rate <code>g(tau)</code> from Whitehead (2008)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LAR(group_by_individual, times, timejump, min_time = NULL, max_time = NULL, 
	identities = NULL, which_identities = NULL, locations = NULL, 
	which_locations = NULL, start_time = NULL, end_time = NULL, classes = NULL, 
	which_classes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LAR_+3A_group_by_individual">group_by_individual</code></td>
<td>

<p>a <code>K x N</code> matrix of K groups (observations, gathering events, etc.) and N individuals (all individuals that are present in at least one group)
</p>
</td></tr>
<tr><td><code id="LAR_+3A_times">times</code></td>
<td>

<p>K vector of times defining the middle of each group/event
</p>
</td></tr>
<tr><td><code id="LAR_+3A_timejump">timejump</code></td>
<td>

<p>step length for <code>tau</code>
</p>
</td></tr>
<tr><td><code id="LAR_+3A_min_time">min_time</code></td>
<td>

<p>minimum/starting value of <code>tau</code>
</p>
</td></tr>
<tr><td><code id="LAR_+3A_max_time">max_time</code></td>
<td>

<p>maximum/ending value of <code>tau</code>
</p>
</td></tr>
<tr><td><code id="LAR_+3A_identities">identities</code></td>
<td>

<p>N vector of identifiers for each individual (column) in the group by individual matrix
</p>
</td></tr>
<tr><td><code id="LAR_+3A_which_identities">which_identities</code></td>
<td>

<p>vector of identities to include in the network (subset of identities)
</p>
</td></tr>
<tr><td><code id="LAR_+3A_locations">locations</code></td>
<td>

<p>K vector of locations defining the location of each group/event
</p>
</td></tr>
<tr><td><code id="LAR_+3A_which_locations">which_locations</code></td>
<td>

<p>vector of locations to include in the network (subset of locations)
</p>
</td></tr>
<tr><td><code id="LAR_+3A_start_time">start_time</code></td>
<td>

<p>element describing the starting time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="LAR_+3A_end_time">end_time</code></td>
<td>

<p>element describing the ending time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="LAR_+3A_classes">classes</code></td>
<td>

<p>N vector of types or class of each individual (column) in the group by individual matrix (for subsetting)
</p>
</td></tr>
<tr><td><code id="LAR_+3A_which_classes">which_classes</code></td>
<td>

<p>vector of class(es)/type(s) to include in the network (subset of classes)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the lagged association rate for given timesteps.
</p>


<h3>Value</h3>

<p>Returns a matrix with Log(time) in the first column and the lagged association rate in the second
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Whitehead (2008) <em>Analyzing Animal Societies</em> section 5.5.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("group_by_individual")
data("times")
data("individuals")

## calculate lagged association rate for great tits
lagged_rates &lt;- LAR(gbi,times,3600, classes=inds$SPECIES, which_classes="GRETI")

## plot the results
plot(lagged_rates, type='l', axes=FALSE, xlab="Time (hours)", ylab="LAR", ylim=c(0,1))
axis(2)
axis(1, at=lagged_rates[,1], labels=c(1:nrow(lagged_rates)))

</code></pre>

<hr>
<h2 id='LRA'>
Dyadic Lagged Association Rate
</h2><span id='topic+LRA'></span>

<h3>Description</h3>

<p>Calculate lagged association rate <code>g(tau)</code> from Whitehead (2008) for each dyad individually
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRA(group_by_individual, times, timejump, output_style = 1, min_time = NULL, 
	max_time = NULL, identities = NULL, which_identities = NULL, locations = NULL, 
	which_locations = NULL, start_time = NULL, end_time = NULL, classes = NULL, 
	which_classes = NULL, association_rate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRA_+3A_group_by_individual">group_by_individual</code></td>
<td>

<p>a <code>K x N</code> matrix of K groups (observations, gathering events, etc.) and N individuals (all individuals that are present in at least one group)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_times">times</code></td>
<td>

<p>K vector of times defining the middle of each group/event
</p>
</td></tr>
<tr><td><code id="LRA_+3A_timejump">timejump</code></td>
<td>

<p>step length for <code>tau</code>
</p>
</td></tr>
<tr><td><code id="LRA_+3A_output_style">output_style</code></td>
<td>

<p>either 1 or 2, see details
</p>
</td></tr>
<tr><td><code id="LRA_+3A_min_time">min_time</code></td>
<td>

<p>minimum/starting value of <code>tau</code>
</p>
</td></tr>
<tr><td><code id="LRA_+3A_max_time">max_time</code></td>
<td>

<p>maximum/ending value of <code>tau</code>
</p>
</td></tr>
<tr><td><code id="LRA_+3A_identities">identities</code></td>
<td>

<p>N vector of identifiers for each individual (column) in the group by individual matrix
</p>
</td></tr>
<tr><td><code id="LRA_+3A_which_identities">which_identities</code></td>
<td>

<p>vector of identities to include in the network (subset of identities)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_locations">locations</code></td>
<td>

<p>K vector of locations defining the location of each group/event
</p>
</td></tr>
<tr><td><code id="LRA_+3A_which_locations">which_locations</code></td>
<td>

<p>vector of locations to include in the network (subset of locations)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_start_time">start_time</code></td>
<td>

<p>element describing the starting time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_end_time">end_time</code></td>
<td>

<p>element describing the ending time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_classes">classes</code></td>
<td>

<p>N vector of types or class of each individual (column) in the group by individual matrix (for subsetting)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_which_classes">which_classes</code></td>
<td>

<p>vector of class(es)/type(s) to include in the network (subset of classes)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_association_rate">association_rate</code></td>
<td>

<p>calculate lagged rate of association (see details)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the dyadic lagged association rate.  The lagged rate of association incorporates the number of observations of each individuals as a simple ratio index within each time period, leading to a better estimation of the assocation rate for data where many observations of individuals can be made within a single time period.
</p>


<h3>Value</h3>

<p>If <code>output_style == 1</code> then a stack of matrices is returned that is <code>N x N x tau</code>.
If <code>output_style == 2</code> then a dataframe is returned containing the focal ID, associate, <code>tau</code>, and lagged association rate.
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Expanded from Whitehead (2008)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("group_by_individual")
data("times")
data("individuals")

## calculate lagged association rate
lagged_rates &lt;- LRA(gbi,times,3600, classes=inds$SPECIES, which_classes="GRETI", output_style=2)

## do something (run a model, plot a surface, etc..)
</code></pre>

<hr>
<h2 id='mrqap.custom.null'>
MRQAP function with custom permutation networks
</h2><span id='topic+mrqap.custom.null'></span>

<h3>Description</h3>

<p>Calculate MRQAP with random networks provides (i.e. generated by a custom model of user's choice)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrqap.custom.null(formula, random.y, intercept = TRUE, directed = "undirected",
	diagonal = FALSE, test.statistic = "t-value", 
	tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrqap.custom.null_+3A_formula">formula</code></td>
<td>

<p>input formula (e.g. y ~ x1 + x2), where y and each x are NxN matrices
</p>
</td></tr>
<tr><td><code id="mrqap.custom.null_+3A_random.y">random.y</code></td>
<td>

<p>a k x N x N matrix containing a set of random networks generated by some permutation method
</p>
</td></tr>
<tr><td><code id="mrqap.custom.null_+3A_intercept">intercept</code></td>
<td>

<p>calculate intercept (TRUE or FALSE value)
</p>
</td></tr>
<tr><td><code id="mrqap.custom.null_+3A_directed">directed</code></td>
<td>

<p>whether the network is directed or undirected (enter either &quot;directed&quot; or &quot;undirected&quot;)
</p>
</td></tr>
<tr><td><code id="mrqap.custom.null_+3A_diagonal">diagonal</code></td>
<td>

<p>whether to include self-loop values (TRUE or FALSE)
</p>
</td></tr>
<tr><td><code id="mrqap.custom.null_+3A_test.statistic">test.statistic</code></td>
<td>

<p>what to calculate P-value, either t-statistic (&quot;t-value&quot;) or regression coefficient (&quot;beta&quot;)
</p>
</td></tr>
<tr><td><code id="mrqap.custom.null_+3A_tol">tol</code></td>
<td>

<p>tolerance value for the qr function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the regression coefficient for each input matrix using MRQAP but where the random networks are provided. This is in contrast to mrqap.dsp which has a built-in node permutation (which I have shown has higher rates of type II errors - see Farine &amp; Whitehead 2015 and Farine in prep.). This method can easily be interfaced with the network_permutation method. Note however that this method tests whether y is related to x1 and x2 together because the different fixed effects are not permuted independently (as suggested by Dekker et al 2007). Whilst the potential to avoid type II errors may warrant this approach, further theoretical testing is needed to confirm this approach is appropriate.
</p>


<h3>Value</h3>

<p>Returns a mrqap.dsp object containing the regression coefficient and P-values for each indendent matrix (x) and associated statistics
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Dekker, D., Krackhard, D., Snijders, T.A.B (2007) Sensitivity of MRQAP tests to collinearity and autocorellation conditions. <em>Psychometrika</em> 72(4): 563-581.
Farine, D. R., &amp; Whitehead, H. (2015) Constructing, conducting, and interpreting animal social network analysis. Journal of Animal Ecology, 84(5), 1144-1163.
Farine, D. R. (in prep) Why and how to use null models in animal social network analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(asnipe)
data("individuals")
data("group_by_individual")

# Generate network
network &lt;- get_network(gbi)

# Create a species similarity matrix
species &lt;- array(0,dim(network))

# Create a sex similarity matrix
sex &lt;- array(0,dim(network))

# Fill each matrix with 1 (same) or 0 (different)
for (i in 1:nrow(network)) {
	species[i,-i] &lt;- as.numeric(inds$SPECIES[i] == inds$SPECIES[-i])
	sex[i,-i] &lt;- as.numeric(inds$SEX[i] == inds$SEX[-i])
}

# Perform network randomisation
# Note randomisations are limited to 10 to reduce runtime
networks_rand &lt;- network_permutation(gbi, association_matrix=network, permutations=10)

# Run mrqap.custom.null
# Note randomisations are limited to 10 to reduce runtime
reg &lt;- mrqap.custom.null(network ~ species + sex, random.y=networks_rand)

# Look at results
reg

</code></pre>

<hr>
<h2 id='mrqap.dsp'>
MRQAP with Double-Semi-Partialing (DSP)
</h2><span id='topic+mrqap.dsp'></span>

<h3>Description</h3>

<p>Calculate MRQAP with Double-Semi-Partialing (DSP) from Dekker et al (2007)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrqap.dsp(formula, intercept = TRUE, directed = "undirected",
	diagonal = FALSE, test.statistic = "t-value", 
	tol = 1e-07, randomisations = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrqap.dsp_+3A_formula">formula</code></td>
<td>

<p>input formula (e.g. y ~ x1 + x2), where y and each x are NxN matrices
</p>
</td></tr>
<tr><td><code id="mrqap.dsp_+3A_intercept">intercept</code></td>
<td>

<p>calculate intercept (TRUE or FALSE value)
</p>
</td></tr>
<tr><td><code id="mrqap.dsp_+3A_directed">directed</code></td>
<td>

<p>whether the network is directed or undirected (enter either &quot;directed&quot; or &quot;undirected&quot;)
</p>
</td></tr>
<tr><td><code id="mrqap.dsp_+3A_diagonal">diagonal</code></td>
<td>

<p>whether to include self-loop values (TRUE or FALSE)
</p>
</td></tr>
<tr><td><code id="mrqap.dsp_+3A_test.statistic">test.statistic</code></td>
<td>

<p>what to calculate P-value, either t-statistic (&quot;t-value&quot;) or regression coefficient (&quot;beta&quot;)
</p>
</td></tr>
<tr><td><code id="mrqap.dsp_+3A_tol">tol</code></td>
<td>

<p>tolerance value for the qr function
</p>
</td></tr>
<tr><td><code id="mrqap.dsp_+3A_randomisations">randomisations</code></td>
<td>

<p>number of randomisations to perform for calculating P-value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the regression coefficient for each input matrix using the DSP method in Dekker et al (2007). This method randomises the residuals from the regression on each independent variable (fixed effect) in order to calculate the P value. This is the same as testing whether y is related to x1 on y while controlling for x2. This differs from regular mrqap, where the dependent (y) value is randomised, testing for whether y is related to x1 and x2 together.
</p>


<h3>Value</h3>

<p>Returns a mrqap.dsp object containing the regression coefficient and P-values for each indendent matrix (x) and associated statistics
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Dekker, D., Krackhard, D., Snijders, T.A.B (2007) Sensitivity of MRQAP tests to collinearity and autocorellation conditions. <em>Psychometrika</em> 72(4): 563-581.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(asnipe)
data("individuals")
data("group_by_individual")

# Generate network
network &lt;- get_network(gbi)

# Create a species similarity matrix
species &lt;- array(0,dim(network))

# Create a sex similarity matrix
sex &lt;- array(0,dim(network))

# Fill each matrix with 1 (same) or 0 (different)
for (i in 1:nrow(network)) {
	species[i,-i] &lt;- as.numeric(inds$SPECIES[i] == inds$SPECIES[-i])
	sex[i,-i] &lt;- as.numeric(inds$SEX[i] == inds$SEX[-i])
}

# Run mrqap.dsp
# Note randomisations are limited to 10 to reduce runtime
reg &lt;- mrqap.dsp(network ~ species + sex, randomisations=10)

# Look at results
reg

</code></pre>

<hr>
<h2 id='network_permutation'>
Perform Permutation
</h2><span id='topic+network_permutation'></span>

<h3>Description</h3>

<p>Performs permutations on the data and calculates network for each step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_permutation(association_data, data_format = "GBI", permutations = 1000, 
	returns=1, association_index = "SRI", association_matrix = NULL, 
	identities = NULL, which_identities = NULL, times = NULL, occurrences = NULL,
	locations = NULL,  which_locations = NULL, start_time = NULL, 
	end_time = NULL, classes = NULL, which_classes = NULL, 
	days = NULL, within_day = FALSE, within_location = FALSE, within_class = FALSE,
	enter_time = NULL, exit_time = NULL, symmetric=TRUE, trialSwap=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_permutation_+3A_association_data">association_data</code></td>
<td>

<p>a <code>K x N</code> matrix of K groups (observations, gathering events, etc.) and N individuals (all individuals that are present in at least one group) OR a <code>K x N x N</code> array of sampling periods.
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_data_format">data_format</code></td>
<td>

<p><code>"GBI"</code> expect a group by individual matrix, <code>"SP"</code> Expect a sampling periods array
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_permutations">permutations</code></td>
<td>

<p>number of permutations (default = 1000)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_returns">returns</code></td>
<td>

<p>number of swaps to perform between each association matrix that is returned (default = 1)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_association_index">association_index</code></td>
<td>

<p><code>"SRI"</code> Simple ratio index, <code>"HWI"</code> Half-weight index (more to come)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_association_matrix">association_matrix</code></td>
<td>

<p>provide a starting association matrix (see details)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_identities">identities</code></td>
<td>

<p>N vector of identifiers for each individual (column) in the group by individual matrix
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_which_identities">which_identities</code></td>
<td>

<p>vector of identities to include in the network (subset of identities)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_times">times</code></td>
<td>

<p>K vector of times defining the middle of each group/event
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_occurrences">occurrences</code></td>
<td>

<p>N x S matrix with the occurrence of each individual in each sampling period (see details) containing only 0s and 1s
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_locations">locations</code></td>
<td>

<p>K vector of locations defining the location of each group/event
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_which_locations">which_locations</code></td>
<td>

<p>vector of locations to include in the network (subset of locations)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_start_time">start_time</code></td>
<td>

<p>element describing the starting time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_end_time">end_time</code></td>
<td>

<p>element describing the ending time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_classes">classes</code></td>
<td>

<p>N vector of types or class of each individual (column) in the group by individual matrix (for subsetting)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_which_classes">which_classes</code></td>
<td>

<p>vector of class(es)/type(s) to include in the network (subset of classes)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_days">days</code></td>
<td>

<p>K vector of day stamp for each event (can be integer or string representing any period of time)
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_within_day">within_day</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the time periods
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_within_location">within_location</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the given locations
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_within_class">within_class</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the given classes
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_enter_time">enter_time</code></td>
<td>

<p>N vector of times when each individual entered the population
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_exit_time">exit_time</code></td>
<td>

<p>N vector of times when each individual departed the population 
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_symmetric">symmetric</code></td>
<td>

<p>Boolean to ensure that permutations maintain symmetry within sampling periods if using <code>data_format="SP"</code>
</p>
</td></tr>
<tr><td><code id="network_permutation_+3A_trialswap">trialSwap</code></td>
<td>

<p>Boolean to include trial swaps (if true, then every attempted permutation is returned)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs permutations on the group by individual matrix as given by Whitehead (2008).  In order to save computing, only the recently swapped individuals are recalculated, hence why the association matrix of the original data can be provided or is recalculated.
</p>
<p>This implementation allows permutations (swaps) to be restricted to within any of three classes.  Though each class is labelled, the function is flexible.  Hence, days can represent any time period (months, hours, etc.).
</p>
<p>Swaps are implemented in a hybrid between the trial swaps proposed by Miklos and Podani (2004) and full swaps (a swap every permutation). Every permutation, a candidate edge is selected (as opposed to a dyad which could or could not have an edge, as proposed by Miklos and Podani). Then a second possible dyad is selected, from all dyads. If the selected portions of the data satisfy the baseline rules (e.g. the checkerboard pattern), then either the selection is attempted again <code>trialSwap = FALSE</code> or not <code>trialSwap = TRUE</code>. This should be set to TRUE, but the option for FALSE is provided for legacy analyses (full swap).
</p>
<p>See get_network function for additional details on each field.
</p>


<h3>Value</h3>

<p>Returns a <code>p x N x N</code> stack of matrices with the dyadic association rates of each pair of individuals after each swap or after a number of swaps, where p = ceiling(permutations/returns)
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Whitehead (2008) <em>Analyzing Animal Societies</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### USING TIMES, ETC.

data("group_by_individual")
data("times")

# subset GBI (to reduce run time of the example)
gbi &lt;- gbi[,1:80]

## define to 2 x N x N network to hold two association matrices
networks &lt;- array(0, c(2, ncol(gbi), ncol(gbi)))

## calculate network for first half of the time
networks[1,,] &lt;- get_network(gbi, data_format="GBI", 
	association_index="SRI", times=times, start_time=0, 
	end_time=max(times)/2)
networks[2,,] &lt;- get_network(gbi, data_format="GBI",
	association_index="SRI", times=times, 
	start_time=max(times)/2, end_time=max(times))

## calculate the weighted degree
library(sna)
deg_weighted &lt;- degree(networks,gmode="graph", g=c(1,2), ignore.eval=FALSE)

## perform the permutations constricting within hour of observation
## note permutations are limited to 10 to reduce runtime
network1_perm &lt;- network_permutation(gbi, data_format="GBI",
	association_matrix=networks[1,,], times=times, start_time=0, 
	end_time=max(times)/2, days=floor(times/3600), within_day=TRUE,
	permutations=10)
network2_perm &lt;- network_permutation(gbi, data_format="GBI",
	association_matrix=networks[2,,], times=times, 
	start_time=max(times)/2, end_time=max(times), days=floor(times/3600), within_day=TRUE,
	permutations=10)

## calculate the weighted degree for each permutation
deg_weighted_perm1 &lt;- degree(network1_perm,gmode="graph", g=c(1:10), ignore.eval=FALSE)
deg_weighted_perm2 &lt;- degree(network2_perm,gmode="graph", g=c(1:10), ignore.eval=FALSE)
detach(package:sna)

## plot the distribution of permutations with the original data overlaid
par(mfrow=c(1,2))
hist(colMeans(deg_weighted_perm1),breaks=100, 
	main=paste("P = ", 
	sum(mean(deg_weighted[,1]) &lt; colMeans(deg_weighted_perm1))/ncol(deg_weighted_perm1)), 
	xlab="Weighted degree", ylab="Probability")
abline(v=mean(deg_weighted[,1]), col='red')
hist(colMeans(deg_weighted_perm2),breaks=100, 
	main=paste("P = ",
	sum(mean(deg_weighted[,2]) &lt; colMeans(deg_weighted_perm2))/ncol(deg_weighted_perm2)), 
	xlab="Weighted degree", ylab="Probability")
abline(v=mean(deg_weighted[,2]), col='red')



#### DOUBLE PERMUTATION EXAMPLE (see Farine &amp; Carter 2021)

## Load data
data("group_by_individual")
data("times")

# subset GBI (to reduce run time of the example)
gbi &lt;- gbi[,1:40]

# Specify metric
metric &lt;- "DEGREE"

# calculate observed network
network &lt;- get_network(gbi, data_format="GBI", 
	association_index="SRI", times=times)

# Calculate observed metric (degree)
degrees &lt;- rowSums(network)

# Do randomisation (as above, permutations should be &gt;=1000)
networks.perm &lt;- network_permutation(gbi, data_format="GBI",
	association_matrix=network, times=times, permutations=10)

# Now calculate the same metric on all the random networks
degrees.rand &lt;- apply(networks.perm,1,function(x) { rowSums(x)})

# Now substract each individual's median from the observed
degree.controlled &lt;- degrees - apply(degrees.rand,1,median)

#### Now use degree.controlled for any later test. For example, to related against a trait:

# Make a trait
trait &lt;- rnorm(length(degree.controlled))

# get the coefficient of this:
coef &lt;- summary(lm(degree.controlled~trait))$coefficients[2,3]

# Compare this to a node permutation 
# (here just randomising the trait values)
# note this should be done &gt;= 1000 times
n.node.perm &lt;- 10
coefs.random &lt;- rep(NA, n.node.perm)

for (i in 1:n.node.perm) {
	trait.random &lt;- sample(trait)
	coefs.random[i] &lt;- summary(lm(degree.controlled~trait.random))$coefficients[2,3]
}

# calculate P value (note this is only one sided)
P &lt;- sum(coef &lt;= coefs.random)/n.node.perm


</code></pre>

<hr>
<h2 id='network_swap'>
Perform one (or more) random swap
</h2><span id='topic+network_swap'></span>

<h3>Description</h3>

<p>Performs one (or more) random swap on the data and re-calculates network, returning both the new network and the data stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_swap(association_data, data_format = "GBI", swaps = 1, 
	association_index = "SRI", association_matrix = NULL, 
	identities = NULL, which_identities = NULL, times = NULL, 
	occurrences = NULL, locations = NULL, which_locations = NULL, 
	start_time = NULL, end_time = NULL, classes = NULL, 
	which_classes = NULL, days = NULL, within_day = FALSE, 
	within_location = FALSE, within_class = FALSE, symmetric=TRUE,
	trialSwap=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_swap_+3A_association_data">association_data</code></td>
<td>

<p>a <code>K x N</code> matrix of K groups (observations, gathering events, etc.) and N individuals (all individuals that are present in at least one group) OR a <code>K x N x N</code> array of sampling periods.
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_data_format">data_format</code></td>
<td>

<p><code>"GBI"</code> expect a group by individual matrix, <code>"SP"</code> Expect a sampling periods array
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_swaps">swaps</code></td>
<td>

<p>number of swaps (default = 1000)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_association_index">association_index</code></td>
<td>

<p><code>"SRI"</code> Simple ratio index, <code>"HWI"</code> Half-weight index (more to come)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_association_matrix">association_matrix</code></td>
<td>

<p>provide a starting association matrix (see details)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_identities">identities</code></td>
<td>

<p>N vector of identifiers for each individual (column) in the group by individual matrix
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_which_identities">which_identities</code></td>
<td>

<p>vector of identities to include in the network (subset of identities)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_times">times</code></td>
<td>

<p>K vector of times defining the middle of each group/event
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_occurrences">occurrences</code></td>
<td>

<p>N x S matrix with the occurrence of each individual in each sampling period (see details) containing only 0s and 1s
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_locations">locations</code></td>
<td>

<p>K vector of locations defining the location of each group/event
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_which_locations">which_locations</code></td>
<td>

<p>vector of locations to include in the network (subset of locations)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_start_time">start_time</code></td>
<td>

<p>element describing the starting time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_end_time">end_time</code></td>
<td>

<p>element describing the ending time for inclusion in the network (useful for temporal analysis)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_classes">classes</code></td>
<td>

<p>N vector of types or class of each individual (column) in the group by individual matrix (for subsetting)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_which_classes">which_classes</code></td>
<td>

<p>vector of class(es)/type(s) to include in the network (subset of classes)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_days">days</code></td>
<td>

<p>K vector of day stamp for each event (can be integer or string representing any period of time)
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_within_day">within_day</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the time periods
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_within_location">within_location</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the given locations
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_within_class">within_class</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the given classes
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_symmetric">symmetric</code></td>
<td>

<p>Boolean to ensure that permutations maintain symmetry within sampling periods if using <code>data_format="SP"</code>
</p>
</td></tr>
<tr><td><code id="network_swap_+3A_trialswap">trialSwap</code></td>
<td>

<p>Boolean to include trial swaps (if TRUE, then every attempted permutation is returned)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs one or more permutation swaps on the group by individual matrix as given by Whitehead (2008).  In order to save on memory use, this function computers the number of swaps and returns the association matrix and the data stream resulting from these, thus not needing to create a large stack of networks to store each permutation. This can then be implemented in a loop as shown in the example below. Note that this method is quite a bit slower than the network_permutation function.
</p>
<p>This implementation allows permutations (swaps) to be restricted to within any of three classes.  Though each class is labelled, the function is flexible.  Hence, days can represent any time period (months, hours, etc.). However, unlike the network_permutation, the subsetting of the data must be done outside of this function (for reasons that might be obvious) - see the example below.
</p>
<p>Trial swaps are implemented following Miklos and Podani (2004). Every permutation, a candidate swap is selected. If the selected portions of the data satisfy the baseline rules (e.g. the checkerboard pattern), then either the selection is attempted again <code>trialSwap = FALSE</code> or not <code>trialSwap = TRUE</code>. This should be set to TRUE, but the option for FALSE is provided for legacy analyses.
</p>


<h3>Value</h3>

<p>Returns a list containing an <code>N x N</code> matrix with the dyadic association rates of each pair of individuals after performing the swaps, and the <code>N x N</code> data stream post-swap, as two list elements.
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Whitehead (2008) <em>Analyzing Animal Societies</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data("group_by_individual")
data("times")

# subset GBI (to reduce run time of the example)
gbi &lt;- gbi[,1:80]

# calculate network for data based on morning associations
network &lt;- get_network(gbi, association_index="SRI", 
	times=times, start_time=0, end_time=max(times)/2)

# perform 100 permutations and calculate the coefficient
# of variance after each permutation.
# note that the subsetting is done outside of the function
library(raster)
cvs &lt;- rep(NA,100)
network_perm = list(network,gbi[which(times &lt;= max(times)/2),])
hours &lt;- floor(times/3600)[which(times &lt;= max(times)/2)]
for (i in 1:100) {
	network_perm &lt;- network_swap(network_perm[[2]], swaps=1, 
		association_matrix=network_perm[[1]], days=hours, 
		within_day=TRUE)
	cvs[i] &lt;- cv(network_perm[[1]])
}

# plot the results with the original network as a red dot
plot(cvs,pch=20,cex=0.5)
points(0,cv(network),cex=1,pch=20,col="red")

</code></pre>

<hr>
<h2 id='print.mrqap.dsp'>
Print function for mrqap.dsp
</h2><span id='topic+print.mrqap.dsp'></span>

<h3>Description</h3>

<p>Print function for MRQAP DSP function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrqap.dsp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mrqap.dsp_+3A_x">x</code></td>
<td>

<p>an mrqap.dsp object (from function in asnipe package)
</p>
</td></tr>
<tr><td><code id="print.mrqap.dsp_+3A_...">...</code></td>
<td>
<p> Further arguments passed to or from print methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print formatted results.
</p>


<h3>Value</h3>

<p>Prints formatted results
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>see mrqap.dsp function
</p>

<hr>
<h2 id='times'>
Observation Time for each Flock Contained in the Group by Individual data
</h2><span id='topic+times'></span>

<h3>Description</h3>

<p>The start time for each flock in the group by individual data since the first flock observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("times")</code></pre>


<h3>Format</h3>

<p>An integer array with the time (in seconds since the first flock of the day).
</p>


<h3>Source</h3>

<p>Farine, D.R., Garroway, C.J., Sheldon, B.C. (2012) Social Network Analysis of mixed-species flocks: exploring the structure and evolution of interspecific social behaviour. Animal Behaviour 84: 1271-1277.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("times")
data("group_by_individual")
rownames(gbi) &lt;- times
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
