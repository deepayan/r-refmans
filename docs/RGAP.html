<!DOCTYPE html><html><head><title>Help for package RGAP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RGAP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.accessDfSystem'><p>Accesses the internal data frame dfSystem which contains data on the parameters to be</p>
estimated.</a></li>
<li><a href='#.aggregate'><p>Temporally Aggregates time series.</p></a></li>
<li><a href='#.assignGibbsFUN'><p>Assigns the appropriate function and its input variables for the Gibbs procedure.</p></a></li>
<li><a href='#.BayesFitNAWRU'><p>Estimates the parameters and states of a two-dimensional state-space model by Bayesian</p>
methods to obtain the nawru.</a></li>
<li><a href='#.BayesFitTFP'><p>Estimates the parameters and states of a two-dimensional state-space model by Bayesian</p>
methods to obtain the tfp trend.</a></li>
<li><a href='#.checkBayesInput'><p>Checks the input parameters of <code>.BayesFitTFP</code> and <code>.BayesFitNAWRU</code> for</p>
consistency.</a></li>
<li><a href='#.checkBoundaries'><p>Checks whether estimated parameters lie on boundaries.</p></a></li>
<li><a href='#.checkCubs'><p>Checks the input variables for the procedure <code>cubs</code> for consistency and validity.</p></a></li>
<li><a href='#.checkCV'><p>Checks the covariance matrix for invertibility and negative entries on the diagonal.</p></a></li>
<li><a href='#.checkKuttner'><p>Checks the input variables for the procedure <code>KuttnerModel</code> for consistency and validity.</p></a></li>
<li><a href='#.checkModelMLEfit'><p>Checks whether model, prior and MLE fit match.</p></a></li>
<li><a href='#.checkModelPrior'><p>Checks whether model and prior match.</p></a></li>
<li><a href='#.checkNawru'><p>Checks the input variables for the procedure <code>NAWRUmodel</code> for consistency and</p>
validity.</a></li>
<li><a href='#.checkParRestr'><p>Checks the given variance restrictions for consistency.</p></a></li>
<li><a href='#.checkPrior'><p>Checks the given prior information for consistency and applicability.</p></a></li>
<li><a href='#.checkTfp'><p>Checks the input variables for the procedure <code>TFPmodel</code> for consistency and validity.</p></a></li>
<li><a href='#.covAR'><p>Computes the covariance of an AR(q) process.</p></a></li>
<li><a href='#.covCUBS'><p>computes the unconditional variance of the cubs equation with p lags of cubs and k</p>
additional lags of the cycle. The cycle follows an AR process of order l.</a></li>
<li><a href='#.cubsTa'><p>Adjusts the frequency of cubs input series.</p></a></li>
<li><a href='#.deltaMethodObs'><p>Computes standard errors of the observation equation using the delta method (for forecast).</p></a></li>
<li><a href='#.deltaMethodState'><p>Computes standard errors of the state using the delta method.</p></a></li>
<li><a href='#.getXYcubs'><p>defines Y and X in the CUBS equation.</p></a></li>
<li><a href='#.getXYpcInd'><p>defines Y and X for the Phillips curve.</p></a></li>
<li><a href='#.gibbsStep2Eq'><p>Draws from the posterior of the parameters of the cubs equation, conditional on the states.</p></a></li>
<li><a href='#.gibbsStepAR'><p>Draws from the posterior of the parameters of the AR(p), <code>p = 1,2</code> cycle equation,</p>
conditional on the states.</a></li>
<li><a href='#.gibbsStepDT'><p>Draws from the posterior of the parameters of the damped trend equation, conditional on</p>
the states.</a></li>
<li><a href='#.gibbsStepRAR2'><p>Draws from the posterior of the parameters of the RAR2 cycle equation, conditional on the</p>
states.</a></li>
<li><a href='#.initializeLoc'><p>Initializes the location file containing default parameter constraints, among other things.</p></a></li>
<li><a href='#.initializeVar'><p>Initializes variance restrictions.</p></a></li>
<li><a href='#.intervalIGamma'><p>Computes confidence interval of Inverse Gamma distributed variable with given mean and</p>
standard deviation.</a></li>
<li><a href='#.meanStd2Beta'><p>Converts the mean and standard deviation of a (possibly scaled) Beta-distributed variable</p>
into the two shape parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.</a></li>
<li><a href='#.meanStd2GammasNu'><p>Converts the mean and standard deviation of a Gamma-distributed variable into the</p>
parameters <code class="reqn">s</code> and <code class="reqn">\nu</code>.</a></li>
<li><a href='#.MLEfitNAWRU'><p>Estimates a two-dimensional state-space model and performs filtering and smoothing to</p>
obtain the nawru.</a></li>
<li><a href='#.MLEfitTFP'><p>Estimates a two-dimensional state-space model and performs filtering and smoothing</p>
to obtain the tfp trend.</a></li>
<li><a href='#.modifySSSystem'><p>Modifies a an object of type <code>NAWRUmodel</code> or <code>TFPmodel</code> in case the variance</p>
constraint for the trend is set to zero or in case a signal-to-noise ratio is specified.</a></li>
<li><a href='#.mvrnorm'><p>Draws from the multivariate normal distribution.</p></a></li>
<li><a href='#.normalize'><p>Normalizes a time series / vector.</p></a></li>
<li><a href='#.postAR1'><p>Draws from the posterior the autoregressive parameter of a stationary AR(1) process</p>
without starting values.</a></li>
<li><a href='#.postARp'><p>Draws from the posterior of the autoregressive paramteres of a stationary AR(p),</p>
<code class="reqn">p &gt; 1</code> process without starting values.</a></li>
<li><a href='#.postNIG'><p>Draws from the posterior of parameters of a normal model with normal inverse gamma prior.</p></a></li>
<li><a href='#.postRW'><p>Draws from the posterior of the variance parameter of a random walk or a random walk with</p>
constant or stochastic drift.</a></li>
<li><a href='#.printGeweke'><p>Prints the results of the Geweke test for the states and the parameters.</p></a></li>
<li><a href='#.printSSModel'><p>Prints the model specifications.</p></a></li>
<li><a href='#.printSSModelFit'><p>Prints the model fit and possibly specifications.</p></a></li>
<li><a href='#.priorMSd2Parameter'><p>Transforms the prior distribution defined by mean and standard deviation to the</p>
appropriate input parameters.</a></li>
<li><a href='#.RAR2transform'><p>Transforms the parameters of an AR(2) process to its re-parametrized version RAR(2) and</p>
vice versa.</a></li>
<li><a href='#.SSmodelfit'><p>Computes figures regarding the model fit of the maximum likelihood estimation.</p></a></li>
<li><a href='#.SSresults'><p>Computes additional results of the Kalman filter and smoother.</p></a></li>
<li><a href='#.SSresultsBayesian'><p>Computes additional results of the Kalman filter and smoother for Bayesian output.</p></a></li>
<li><a href='#.SSSystem'><p>Prepares state space model system matrices to create an object of type <code>NAWRUmodel</code></p>
or <code>TFPmodel</code>.</a></li>
<li><a href='#.updateParConstraints'><p>Updates the parameter constraints for on object of class <code>NAWRUmodel</code> or</p>
<code>TFPmodel</code>.</a></li>
<li><a href='#.updateSSSystem'><p>Updates the system matrices of an object of class <code>NAWRUmodel</code> or <code>TFPmodel</code></p>
during optimization or during a Bayesian Gibbs procedure.</a></li>
<li><a href='#amecoData2input'><p>Data for estimation</p></a></li>
<li><a href='#assignConstraints'><p>Applies suitable contraining functions to parameters.</p></a></li>
<li><a href='#autoGapProd'><p>Fit best production function model</p></a></li>
<li><a href='#autoNAWRUmodel'><p>NAWRU model suggestion</p></a></li>
<li><a href='#autoTFPmodel'><p>TFP model suggestion</p></a></li>
<li><a href='#computeCovar'><p>Computes the covariance of the estimated parameters given restrictions.</p></a></li>
<li><a href='#constraint'><p>Applies contraints to parameters.</p></a></li>
<li><a href='#cubs'><p>CUBS indicator</p></a></li>
<li><a href='#cycleOptim'><p>Find suitable cycle specification</p></a></li>
<li><a href='#dateTsList'><p>Finds first/last starting/end date in list of time series deepening on the input functions.</p></a></li>
<li><a href='#Dconstraint'><p>Extracts the derivative of the applied restriction function.</p></a></li>
<li><a href='#extract_ameco_data'><p>Extracts the relevant 'AMECO' data</p></a></li>
<li><a href='#extract_indicator_data'><p>Extracts the relevant 'AMECO' indicator data.</p></a></li>
<li><a href='#fetchAmecoData'><p>Current 'AMECO' data vintage</p></a></li>
<li><a href='#firstLetterUp'><p>Capitalizes the first letter of a string.</p></a></li>
<li><a href='#fit'><p>Fit Method</p></a></li>
<li><a href='#fit.KuttnerModel'><p>Maximum likelihood estimation of a <code>KuttnerModel</code></p></a></li>
<li><a href='#fit.NAWRUmodel'><p>Estimation of a <code>NAWRUmodel</code></p></a></li>
<li><a href='#fit.TFPmodel'><p>Estimation of a <code>TFPmodel</code></p></a></li>
<li><a href='#FUNcov'><p>Computes mean and variance of the part of the posterior distribution that relies on</p>
starting values. It then computes the density of the first p observations of Y.</a></li>
<li><a href='#gap'><p>gap data set</p></a></li>
<li><a href='#gapHP'><p>HP-filter output gap</p></a></li>
<li><a href='#gapProd'><p>Production function output gap</p></a></li>
<li><a href='#gewekeTest'><p>Conducts a Geweke test for convergence of the draws.</p></a></li>
<li><a href='#growth'><p>Growth rate</p></a></li>
<li><a href='#helper_fit_comparison'><p>model selection fit comparison helper function</p></a></li>
<li><a href='#helper_model_comparison'><p>model comparison helper function</p></a></li>
<li><a href='#helper_model_fit'><p>model selection helper function</p></a></li>
<li><a href='#HPDinterval'><p>Computes the approximate highest posterior density interval (HPDI).</p></a></li>
<li><a href='#hpfilter'><p>HP filter</p></a></li>
<li><a href='#indicator'><p>Indicators fo CUBS</p></a></li>
<li><a href='#inference'><p>Computes standard errors, t-statistics, and p-values for the estimated state space parameters</p>
using the delta method.</a></li>
<li><a href='#initializeExo'><p>Initialization of exogenous variables</p></a></li>
<li><a href='#initializePrior'><p>Initialization of prior distributions</p></a></li>
<li><a href='#initializeRestr'><p>Initialization of parameter restrictions</p></a></li>
<li><a href='#is.gap'><p><code>gap</code> object check</p></a></li>
<li><a href='#is.KuttnerFit'><p><code>KuttnerFit</code> object check</p></a></li>
<li><a href='#is.KuttnerModel'><p><code>KuttnerModel</code> object check</p></a></li>
<li><a href='#is.NAWRUfit'><p><code>NAWRUfit</code> object check</p></a></li>
<li><a href='#is.NAWRUmodel'><p><code>NAWRUodel</code> object check</p></a></li>
<li><a href='#is.TFPfit'><p><code>TFPfit</code> object check</p></a></li>
<li><a href='#is.TFPmodel'><p><code>TFPmodel</code> object check</p></a></li>
<li><a href='#KuttnerModel'><p>Kuttner model</p></a></li>
<li><a href='#matmult3d'><p>Capitalizes the first letter of a string.</p></a></li>
<li><a href='#mcmcSummary'><p>Computes MCMC summary statistics.</p></a></li>
<li><a href='#NAWRUmodel'><p>NAWRU model</p></a></li>
<li><a href='#obs2Optim'><p>Find suitable 2nd observation specification</p></a></li>
<li><a href='#operTsLists'><p>Performs a mathematical operation to the ts elements of two lists with the same names</p></a></li>
<li><a href='#plot_gibbs_output'><p>Plots the diagnostic plots of the posterior distribution.</p></a></li>
<li><a href='#plot.gap'><p>Plots for a <code>gap</code> object</p></a></li>
<li><a href='#plot.KuttnerFit'><p>Plots for a <code>KuttnerFit</code> object</p></a></li>
<li><a href='#plot.NAWRUfit'><p>Plots for a <code>NAWRUfit</code> object</p></a></li>
<li><a href='#plot.TFPfit'><p>Plots for a <code>TFPfit</code> object</p></a></li>
<li><a href='#plotGap'><p>Plots the trend series and the (fitted) second observation equation and gives diagnostic</p>
plots based on standardized residuals.</a></li>
<li><a href='#plotSSprediction'><p>Plots the trend series and the (fitted) second observation equation and gives diagnostic</p>
plots based on standardized residuals.</a></li>
<li><a href='#plotSSresults'><p>Plots the trend series and the (fitted) second observation equation and gives diagnostic</p>
plots based on standardized residuals.</a></li>
<li><a href='#predict.fit'><p>Predictions</p></a></li>
<li><a href='#predictBayes'><p>Predictions for Bayesian estimation</p></a></li>
<li><a href='#predictMLE'><p>Predictions for MLE</p></a></li>
<li><a href='#print.gap'><p>Print <code>gap</code> object</p></a></li>
<li><a href='#print.KuttnerFit'><p>Print <code>KuttnerFit</code> object</p></a></li>
<li><a href='#print.KuttnerModel'><p>Print <code>KuttnerModel</code> object</p></a></li>
<li><a href='#print.NAWRUfit'><p>Print <code>NAWRUfit</code> object</p></a></li>
<li><a href='#print.NAWRUmodel'><p>Print <code>NAWRUmodel</code> object</p></a></li>
<li><a href='#print.TFPfit'><p>Print <code>TFPfit</code> object</p></a></li>
<li><a href='#print.TFPmodel'><p>Print <code>TFPmodel</code> object</p></a></li>
<li><a href='#TFPmodel'><p>TFP trend model</p></a></li>
<li><a href='#trendAnchor'><p>Trend anchor</p></a></li>
<li><a href='#trendOptim'><p>Find suitable trend specification</p></a></li>
<li><a href='#trendVolaMeasures'><p>Trend volatility measures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Production Function Output Gap Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>The output gap indicates the percentage difference between the actual output of an economy and its potential. Since potential output is a latent process, the estimation of the output gap poses a challenge and numerous filtering techniques have been proposed. 'RGAP' facilitates the estimation of a Cobb-Douglas production function type output gap, as suggested by the European Commission (Havik et al. 2014) <a href="https://ideas.repec.org/p/euf/ecopap/0535.html">https://ideas.repec.org/p/euf/ecopap/0535.html</a>. To that end, the non-accelerating wage rate of unemployment (NAWRU) and the trend of total factor productivity (TFP) can be estimated in two bivariate unobserved component models by means of Kalman filtering and smoothing. 'RGAP' features a flexible modeling framework for the appropriate state-space models and offers frequentist as well as Bayesian estimation techniques. Additional functionalities include direct access to the 'AMECO' <a href="https://economy-finance.ec.europa.eu/economic-research-and-databases/economic-databases/ameco-database_en">https://economy-finance.ec.europa.eu/economic-research-and-databases/economic-databases/ameco-database_en</a> database and automated model selection procedures. See the paper by Streicher (2022) <a href="http://hdl.handle.net/20.500.11850/552089">http://hdl.handle.net/20.500.11850/552089</a> for details. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, KFAS, zoo, dlm, openxlsx, ggplot2, gridExtra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-02 07:56:36 UTC; sinast</td>
</tr>
<tr>
<td>Author:</td>
<td>Sina Streicher <a href="https://orcid.org/0000-0001-7848-1842"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sina Streicher &lt;streicher@kof.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-02 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.accessDfSystem'>Accesses the internal data frame dfSystem which contains data on the parameters to be
estimated.</h2><span id='topic+.accessDfSystem'></span>

<h3>Description</h3>

<p>Accesses the internal data frame dfSystem which contains data on the parameters to be
estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.accessDfSystem(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".accessDfSystem_+3A_model">model</code></td>
<td>
<p>A model of class <code>NAWRUmodel</code> or <code>TFPmodel</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing information on each involved parameter, for instance
its corresponding system matrix, variable names, and parameter restrictions.
</p>

<hr>
<h2 id='.aggregate'>Temporally Aggregates time series.</h2><span id='topic+.aggregate'></span>

<h3>Description</h3>

<p>Temporally Aggregates time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.aggregate(x, freqLow, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".aggregate_+3A_x">x</code></td>
<td>
<p>A time series object.</p>
</td></tr>
<tr><td><code id=".aggregate_+3A_freqlow">freqLow</code></td>
<td>
<p>Frequency of low frequency series.</p>
</td></tr>
<tr><td><code id=".aggregate_+3A_fun">FUN</code></td>
<td>
<p>A function for aggregation.</p>
</td></tr>
</table>

<hr>
<h2 id='.assignGibbsFUN'>Assigns the appropriate function and its input variables for the Gibbs procedure.</h2><span id='topic+.assignGibbsFUN'></span>

<h3>Description</h3>

<p>Assigns the appropriate function and its input variables for the Gibbs procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.assignGibbsFUN(
  loc,
  type,
  trend,
  cycle,
  cubsAR,
  cycleLag,
  errorARMA,
  exoNames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".assignGibbsFUN_+3A_loc">loc</code></td>
<td>
<p>A data frame containing information on each involved parameter, for instance
its corresponding system matrix, variable names, and parameter restrictions.</p>
</td></tr>
<tr><td><code id=".assignGibbsFUN_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of the Phillip's curve.
<code>type = "TKP"</code> denotes the traditional Keynesian Phillip's curve and
<code>type = "NKP"</code> the New Keynesian Phillip's curve, see details. The default is
<code>type = "TKP"</code>.</p>
</td></tr>
<tr><td><code id=".assignGibbsFUN_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "DT"</code>.</p>
</td></tr>
<tr><td><code id=".assignGibbsFUN_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an AR(2) process, <code>cycle = "RAR2"</code> a
reparametrized AR(2) process. The default is <code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id=".assignGibbsFUN_+3A_cubsar">cubsAR</code></td>
<td>
<p>A non-negative integer specifying the maximum CUBS lag that is included
in the CUBS equation. The default is <code>cubsAR = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".assignGibbsFUN_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A non-negative integer specifying the maximum cycle lag that is included
in the CUBD equation. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".assignGibbsFUN_+3A_errorarma">errorARMA</code></td>
<td>
<p>A vector with non-negative integers specifying the AR
and MA degree of the error term in the second observation equation.</p>
</td></tr>
<tr><td><code id=".assignGibbsFUN_+3A_exonames">exoNames</code></td>
<td>
<p>A character vector containing the names of the exogenous variables.</p>
</td></tr>
</table>

<hr>
<h2 id='.BayesFitNAWRU'>Estimates the parameters and states of a two-dimensional state-space model by Bayesian
methods to obtain the nawru.</h2><span id='topic+.BayesFitNAWRU'></span>

<h3>Description</h3>

<p>Estimates the parameters and states of a two-dimensional state-space model by Bayesian
methods to obtain the nawru.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.BayesFitNAWRU(
  model,
  prior = initializePrior(model),
  R = 10000,
  burnin = ceiling(R/10),
  thin = 1,
  HPDIprob = 0.85,
  FUN = mean,
  MLEfit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".BayesFitNAWRU_+3A_model">model</code></td>
<td>
<p>An object of class NAWRUmodel.</p>
</td></tr>
<tr><td><code id=".BayesFitNAWRU_+3A_prior">prior</code></td>
<td>
<p>A list of matrices with parameters for the prior distribution and box
constraints. By default, <code>prior</code> is initialized by <code>initializePrior(model)</code>.
See details. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitNAWRU_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of MCMC draws. The default is <code>R = 10000</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitNAWRU_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the burn-in phase of the MCMC chain. The default is
<code>burnin = ceiling(R / 10)</code>. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitNAWRU_+3A_thin">thin</code></td>
<td>
<p>An integer specifying the thinning interval between consecutive draws. The
default is <code>thin = 1</code>, implying that no draws are dopped. For <code>thin = 2</code>,
every second draw is dropped and so on. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitNAWRU_+3A_hpdiprob">HPDIprob</code></td>
<td>
<p>A numeric in the interval <code>(0,1)</code> specifying the target probability
of the highest posterior density intervals. The default is <code>HPDIprob = 0.9</code>. Only
used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitNAWRU_+3A_fun">FUN</code></td>
<td>
<p>A function to be used to compute estimates from the posterior distribution.
Possible options are <code>"mean"</code> and <code>"median"</code>. The default is <code>FUN = "mean"</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitNAWRU_+3A_mlefit">MLEfit</code></td>
<td>
<p>(Optional) An object of class <code>NAWRUfit</code> which is used for
initialization. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.BayesFitTFP'>Estimates the parameters and states of a two-dimensional state-space model by Bayesian
methods to obtain the tfp trend.</h2><span id='topic+.BayesFitTFP'></span>

<h3>Description</h3>

<p>Estimates the parameters and states of a two-dimensional state-space model by Bayesian
methods to obtain the tfp trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.BayesFitTFP(
  model,
  prior = initializePrior(model),
  R = 10000,
  burnin = ceiling(R/10),
  thin = 1,
  HPDIprob = 0.85,
  FUN = mean,
  MLEfit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".BayesFitTFP_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id=".BayesFitTFP_+3A_prior">prior</code></td>
<td>
<p>A list of matrices with parameters for the prior distribution and box
constraints. By default, <code>prior</code> is initialized by <code>initializePrior(model)</code>.
See details. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitTFP_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of MCMC draws. The default is <code>R = 10000</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitTFP_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the burn-in phase of the MCMC chain. The default is
<code>burnin = ceiling(R / 10)</code>. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitTFP_+3A_thin">thin</code></td>
<td>
<p>An integer specifying the thinning interval between consecutive draws. The
default is <code>thin = 1</code>, implying that no draws are dopped. For <code>thin = 2</code>,
every second draw is dropped and so on. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitTFP_+3A_hpdiprob">HPDIprob</code></td>
<td>
<p>A numeric in the interval <code>(0,1)</code> specifying the target probability
of the highest posterior density intervals. The default is <code>HPDIprob = 0.9</code>. Only
used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitTFP_+3A_fun">FUN</code></td>
<td>
<p>A function to be used to compute estimates from the posterior distribution.
Possible options are <code>"mean"</code> and <code>"median"</code>. The default is <code>FUN = "mean"</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".BayesFitTFP_+3A_mlefit">MLEfit</code></td>
<td>
<p>(Optional) An object of class <code>TFPfit</code> which is used for
initialization. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkBayesInput'>Checks the input parameters of <code>.BayesFitTFP</code> and <code>.BayesFitNAWRU</code> for
consistency.</h2><span id='topic+.checkBayesInput'></span>

<h3>Description</h3>

<p>Checks the input parameters of <code>.BayesFitTFP</code> and <code>.BayesFitNAWRU</code> for
consistency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkBayesInput(
  model,
  type,
  prior = NULL,
  R = NULL,
  burnin = NULL,
  thin = NULL,
  HPDIprob = NULL,
  FUN = NULL,
  MLEfit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkBayesInput_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_type">type</code></td>
<td>
<p>A character specifying whether a &quot;nawru&quot; or &quot;tfp&quot; model should be checked.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_prior">prior</code></td>
<td>
<p>A list of matrices with parameters for the prior distribution and box
constraints. By default, <code>prior</code> is initialized by <code>initializePrior(model)</code>.
See details. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of MCMC draws. The default is <code>R = 10000</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the burn-in phase of the MCMC chain. The default is
<code>burnin = ceiling(R / 10)</code>. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_thin">thin</code></td>
<td>
<p>An integer specifying the thinning interval between consecutive draws. The
default is <code>thin = 1</code>, implying that no draws are dopped. For <code>thin = 2</code>,
every second draw is dropped and so on. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_hpdiprob">HPDIprob</code></td>
<td>
<p>A numeric in the interval <code>(0,1)</code> specifying the target probability
of the highest posterior density intervals. The default is <code>HPDIprob = 0.9</code>. Only
used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_fun">FUN</code></td>
<td>
<p>A function to be used to compute estimates from the posterior distribution.
Possible options are <code>"mean"</code> and <code>"median"</code>. The default is <code>FUN = "mean"</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".checkBayesInput_+3A_mlefit">MLEfit</code></td>
<td>
<p>(Optional) An object of class <code>TFPfit</code> which is used for
initialization. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkBoundaries'>Checks whether estimated parameters lie on boundaries.</h2><span id='topic+.checkBoundaries'></span>

<h3>Description</h3>

<p>Checks whether estimated parameters lie on boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkBoundaries(fit, loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkBoundaries_+3A_fit">fit</code></td>
<td>
<p>Output of <code>fitSSM</code> from <code>KFAS</code>.</p>
</td></tr>
<tr><td><code id=".checkBoundaries_+3A_loc">loc</code></td>
<td>
<p>A data frame containing information on each involved parameter (list element
of objects of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, <code>KuttnerModel</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='.checkCubs'>Checks the input variables for the procedure <code>cubs</code> for consistency and validity.</h2><span id='topic+.checkCubs'></span>

<h3>Description</h3>

<p>Checks the input variables for the procedure <code>cubs</code> for consistency and validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkCubs(tsCU, tsVA, lambda, frequency)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkCubs_+3A_tscu">tsCU</code></td>
<td>
<p>A multiple time series containing three survey time series, the first
element needs to be capacity utilization in industry, see details. Alternatively, a list
of time series can be supplied.</p>
</td></tr>
<tr><td><code id=".checkCubs_+3A_tsva">tsVA</code></td>
<td>
<p>A multiple time series containing three value added series that correspond to
<code>tsCU</code>. Alternatively, a list of time series can be supplied.</p>
</td></tr>
<tr><td><code id=".checkCubs_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing parameter for the application of the HP filter (see details).
If not supplied, <code>lambda = 6.25</code> is used for yearly data and <code>lambda = 1600</code> 
for quarterly data.</p>
</td></tr>
<tr><td><code id=".checkCubs_+3A_frequency">frequency</code></td>
<td>
<p>The frequency of the computed cubs indicator. Possible entries are
<code>frequency = 1</code> (annual), <code>frequency = 4</code> (quarterly). The default is
<code>frequency = 1</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkCV'>Checks the covariance matrix for invertibility and negative entries on the diagonal.</h2><span id='topic+.checkCV'></span>

<h3>Description</h3>

<p>Checks the covariance matrix for invertibility and negative entries on the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkCV(fit, loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkCV_+3A_fit">fit</code></td>
<td>
<p>Output of <code>fitSSM</code> from <code>KFAS</code>.</p>
</td></tr>
<tr><td><code id=".checkCV_+3A_loc">loc</code></td>
<td>
<p>A data frame containing information on each involved parameter (list element
of objects of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, <code>KuttnerModel</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='.checkKuttner'>Checks the input variables for the procedure <code>KuttnerModel</code> for consistency and validity.</h2><span id='topic+.checkKuttner'></span>

<h3>Description</h3>

<p>Checks the input variables for the procedure <code>KuttnerModel</code> for consistency and validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkKuttner(
  tsl,
  trend,
  cycle,
  cycleLag,
  errorARMA,
  start,
  end,
  anchor,
  anchor.h
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkKuttner_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "RW1"</code>.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an AR(2) process. The default is
<code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A non-negative integer specifying the maximum cycle lag that is included
in the inflation equation. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_errorarma">errorARMA</code></td>
<td>
<p>A vector with non-negative integers specifying the AR
and MA degree of the error term in the inflation equation.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_start">start</code></td>
<td>
<p>(Optional) Start vector for the estimation, e.g. <code>c(1980, 1)</code>.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_end">end</code></td>
<td>
<p>(Optional) End vector for the estimation, e.g. <code>c(2020, 1)</code>.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_anchor">anchor</code></td>
<td>
<p>(Optional) Anchor value for the logarithm of trend gdp.</p>
</td></tr>
<tr><td><code id=".checkKuttner_+3A_anchor.h">anchor.h</code></td>
<td>
<p>(Optional) Anchor horizon in the frequency of the given time series.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkModelMLEfit'>Checks whether model, prior and MLE fit match.</h2><span id='topic+.checkModelMLEfit'></span>

<h3>Description</h3>

<p>Checks whether model, prior and MLE fit match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkModelMLEfit(model, MLEfit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkModelMLEfit_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id=".checkModelMLEfit_+3A_mlefit">MLEfit</code></td>
<td>
<p>(Optional) An object of class <code>TFPfit</code> which is used for
initialization. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkModelPrior'>Checks whether model and prior match.</h2><span id='topic+.checkModelPrior'></span>

<h3>Description</h3>

<p>Checks whether model and prior match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkModelPrior(model, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkModelPrior_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id=".checkModelPrior_+3A_prior">prior</code></td>
<td>
<p>A list of matrices with parameters for the prior distribution and box
constraints. By default, <code>prior</code> is initialized by <code>initializePrior(model)</code>.
See details. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkNawru'>Checks the input variables for the procedure <code>NAWRUmodel</code> for consistency and
validity.</h2><span id='topic+.checkNawru'></span>

<h3>Description</h3>

<p>Checks the input variables for the procedure <code>NAWRUmodel</code> for consistency and
validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkNawru(
  tsl,
  trend,
  cycle,
  type,
  cycleLag,
  errorARMA,
  exoNames,
  exoType,
  start,
  end,
  anchor,
  anchor.h
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkNawru_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "RW2"</code>.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an <code>AR(2)</code> process. The default is
<code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of the Phillip's curve.
<code>type = "TKP"</code> denotes the traditional Keynesian Phillip's curve and
<code>type = "NKP"</code> the New Keynesian Phillip's curve, see details. The default is
<code>type = "TKP"</code>.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A vector specifying the cycle lags that are included in the Phillip's
curve. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_errorarma">errorARMA</code></td>
<td>
<p>A vector with non-negative integers specifying the AR
and MA degree of the error term in the Phillip's curve equation.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_exonames">exoNames</code></td>
<td>
<p>A character vector containing the names of the exogenous variables.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_exotype">exoType</code></td>
<td>
<p>An optional <code>n x m x 2</code> array specifying the possible difference
and lag transformation for the variables. <code>exoType</code> can be initialized using the
function <code>inizializeExo</code>. The column names give the variable names.
<code>exoType[, , 1]</code> contains the difference transformations and <code>exoType[, , 2]</code>
the subsequent lag transformations, see details.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_start">start</code></td>
<td>
<p>(Optional) Start vector for the estimation, e.g. <code>c(1980, 1)</code>.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_end">end</code></td>
<td>
<p>(Optional) End vector for the estimation, e.g. <code>c(2020, 1)</code>.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_anchor">anchor</code></td>
<td>
<p>(Optional) Anchor value for the unemployment rate.</p>
</td></tr>
<tr><td><code id=".checkNawru_+3A_anchor.h">anchor.h</code></td>
<td>
<p>(Optional) Anchor horizon in the frequency of the given time series.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkParRestr'>Checks the given variance restrictions for consistency.</h2><span id='topic+.checkParRestr'></span>

<h3>Description</h3>

<p>Checks the given variance restrictions for consistency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkParRestr(model, parRestr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkParRestr_+3A_model">model</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code> or <code>TFPmodel</code>.</p>
</td></tr>
<tr><td><code id=".checkParRestr_+3A_parrestr">parRestr</code></td>
<td>
<p>list of matrices containing the parameter restrictions for the cycle,
trend, and the second observation equation (Phillips curve, CUBS equation). Each matrix
contains the lower and upper bound of the involved parameters. <code>NA</code> implies that no
restriction is present.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkPrior'>Checks the given prior information for consistency and applicability.</h2><span id='topic+.checkPrior'></span>

<h3>Description</h3>

<p>Checks the given prior information for consistency and applicability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkPrior(model, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkPrior_+3A_model">model</code></td>
<td>
<p>An object of class <code>TFPmodel</code>.</p>
</td></tr>
<tr><td><code id=".checkPrior_+3A_prior">prior</code></td>
<td>
<p>A list of matrices with parameters for the prior distribution and box
constraints.</p>
</td></tr>
</table>

<hr>
<h2 id='.checkTfp'>Checks the input variables for the procedure <code>TFPmodel</code> for consistency and validity.</h2><span id='topic+.checkTfp'></span>

<h3>Description</h3>

<p>Checks the input variables for the procedure <code>TFPmodel</code> for consistency and validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkTfp(
  tsl,
  trend,
  cycle,
  cycleLag,
  cubsAR,
  errorARMA,
  start,
  end,
  anchor,
  anchor.h
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkTfp_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "DT"</code>.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an AR(2) process, <code>cycle = "RAR2"</code> a
reparametrized AR(2) process. The default is <code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A non-negative integer specifying the maximum cycle lag that is included
in the CUBD equation. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_cubsar">cubsAR</code></td>
<td>
<p>A non-negative integer specifying the maximum CUBS lag that is included
in the CUBS equation. The default is <code>cubsAR = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_errorarma">errorARMA</code></td>
<td>
<p>A vector with non-negative integers specifying the AR
and MA degree of the error term in the CUBS equation.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_start">start</code></td>
<td>
<p>(Optional) Start vector for the estimation, e.g. <code>c(1980, 1)</code>.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_end">end</code></td>
<td>
<p>(Optional) End vector for the estimation, e.g. <code>c(2020, 1)</code>.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_anchor">anchor</code></td>
<td>
<p>(Optional) Snchor value for the log of the TFP trend.</p>
</td></tr>
<tr><td><code id=".checkTfp_+3A_anchor.h">anchor.h</code></td>
<td>
<p>(Optional) Anchor horizon in the frequency of the given time series.</p>
</td></tr>
</table>

<hr>
<h2 id='.covAR'>Computes the covariance of an AR(q) process.</h2><span id='topic+.covAR'></span>

<h3>Description</h3>

<p>Computes the covariance of an AR(q) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.covAR(k, phi, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".covAR_+3A_k">k</code></td>
<td>
<p>integer indicating the lag length of the covariance.</p>
</td></tr>
<tr><td><code id=".covAR_+3A_phi">phi</code></td>
<td>
<p><code>q x 1</code> vector of parameters.</p>
</td></tr>
<tr><td><code id=".covAR_+3A_sigma">sigma</code></td>
<td>
<p>the innovation variance of the AR(q) process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>k x k</code> covariance matrix.
</p>

<hr>
<h2 id='.covCUBS'>computes the unconditional variance of the cubs equation with p lags of cubs and k
additional lags of the cycle. The cycle follows an AR process of order l.</h2><span id='topic+.covCUBS'></span>

<h3>Description</h3>

<p>computes the unconditional variance of the cubs equation with p lags of cubs and k
additional lags of the cycle. The cycle follows an AR process of order l.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.covCUBS(mu, phi, beta, sigma, phiC, sigmaC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".covCUBS_+3A_mu">mu</code></td>
<td>
<p>constant.</p>
</td></tr>
<tr><td><code id=".covCUBS_+3A_phi">phi</code></td>
<td>
<p><code>p x 1</code> vector of parameters for cubs lags.</p>
</td></tr>
<tr><td><code id=".covCUBS_+3A_beta">beta</code></td>
<td>
<p><code>k x 1</code> vector of parameters for contemporaneous cycle and cycle lags.</p>
</td></tr>
<tr><td><code id=".covCUBS_+3A_sigma">sigma</code></td>
<td>
<p>the innovation variance of the cubs process.</p>
</td></tr>
<tr><td><code id=".covCUBS_+3A_phic">phiC</code></td>
<td>
<p><code>l x 1</code> vector of cycle process parameters.</p>
</td></tr>
<tr><td><code id=".covCUBS_+3A_sigmac">sigmaC</code></td>
<td>
<p>the innovation variance of the cycle process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a two covariance matrices; the first one depicts the covariance
between the cycle and cubs and the second onf the covariance of cubs.
</p>

<hr>
<h2 id='.cubsTa'>Adjusts the frequency of cubs input series.</h2><span id='topic+.cubsTa'></span>

<h3>Description</h3>

<p>Adjusts the frequency of cubs input series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cubsTa(tsObj, conversion, frequency)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cubsTa_+3A_tsobj">tsObj</code></td>
<td>
<p>A time series object.</p>
</td></tr>
<tr><td><code id=".cubsTa_+3A_conversion">conversion</code></td>
<td>
<p>An appropriate conversion method, i.e., <code>"average"</code> or <code>"sum"</code>.</p>
</td></tr>
<tr><td><code id=".cubsTa_+3A_frequency">frequency</code></td>
<td>
<p>The frequency of the aggregated time series, i.e., <code>frequency = 4</code> for
quarterly and <code>frequency = 1</code> for annual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>frequency == 1</code>, then the values for the latest and the first year are
averaged over the existing months/quarters. However, for the latest year, this is only
done if the third quarter is available.
</p>

<hr>
<h2 id='.deltaMethodObs'>Computes standard errors of the observation equation using the delta method (for forecast).</h2><span id='topic+.deltaMethodObs'></span>

<h3>Description</h3>

<p>Computes standard errors of the observation equation using the delta method (for forecast).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.deltaMethodObs(out, nameObs, model, constant = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".deltaMethodObs_+3A_out">out</code></td>
<td>
<p>The return object of the function <code>KFS</code> from the package <code>KFAS</code>.</p>
</td></tr>
<tr><td><code id=".deltaMethodObs_+3A_nameobs">nameObs</code></td>
<td>
<p>The name of the observation equation as character.</p>
</td></tr>
<tr><td><code id=".deltaMethodObs_+3A_model">model</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, or <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code id=".deltaMethodObs_+3A_constant">constant</code></td>
<td>
<p>A constant used in the transformation functions.</p>
</td></tr>
</table>

<hr>
<h2 id='.deltaMethodState'>Computes standard errors of the state using the delta method.</h2><span id='topic+.deltaMethodState'></span>

<h3>Description</h3>

<p>Computes standard errors of the state using the delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.deltaMethodState(out, nameState, constant = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".deltaMethodState_+3A_out">out</code></td>
<td>
<p>The return object of the function <code>KFS</code> from the package <code>KFAS</code>.</p>
</td></tr>
<tr><td><code id=".deltaMethodState_+3A_namestate">nameState</code></td>
<td>
<p>The name of the state as character.</p>
</td></tr>
<tr><td><code id=".deltaMethodState_+3A_constant">constant</code></td>
<td>
<p>A constant used in the transformation functions.</p>
</td></tr>
</table>

<hr>
<h2 id='.getXYcubs'>defines Y and X in the CUBS equation.</h2><span id='topic+.getXYcubs'></span>

<h3>Description</h3>

<p>defines Y and X in the CUBS equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getXYcubs(stateSmoothed, model, cycleLag, cubsAR, names, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getXYcubs_+3A_statesmoothed">stateSmoothed</code></td>
<td>
<p>The smoothed states.</p>
</td></tr>
<tr><td><code id=".getXYcubs_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id=".getXYcubs_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A non-negative integer specifying the maximum cycle lag that is included
in the CUBD equation. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".getXYcubs_+3A_cubsar">cubsAR</code></td>
<td>
<p>A non-negative integer specifying the maximum CUBS lag that is included
in the CUBS equation. The default is <code>cubsAR = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".getXYcubs_+3A_names">names</code></td>
<td>
<p>The names of the columns.</p>
</td></tr>
<tr><td><code id=".getXYcubs_+3A_trim">trim</code></td>
<td>
<p>A logical indicating whether NAs should be trimmed.</p>
</td></tr>
</table>

<hr>
<h2 id='.getXYpcInd'>defines Y and X for the Phillips curve.</h2><span id='topic+.getXYpcInd'></span>

<h3>Description</h3>

<p>defines Y and X for the Phillips curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getXYpcInd(stateSmoothed, model, cycleLag, pcIndAR, names, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getXYpcInd_+3A_statesmoothed">stateSmoothed</code></td>
<td>
<p>The smoothed states.</p>
</td></tr>
<tr><td><code id=".getXYpcInd_+3A_model">model</code></td>
<td>
<p>An object of class NAWRUmodel.</p>
</td></tr>
<tr><td><code id=".getXYpcInd_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A vector specifying the cycle lags that are included in the Phillip's
curve. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".getXYpcInd_+3A_pcindar">pcIndAR</code></td>
<td>
<p>Lag of the Phillips curve indicator.</p>
</td></tr>
<tr><td><code id=".getXYpcInd_+3A_names">names</code></td>
<td>
<p>The names of the columns.</p>
</td></tr>
<tr><td><code id=".getXYpcInd_+3A_trim">trim</code></td>
<td>
<p>A logical indicating whether NAs should be trimmed.</p>
</td></tr>
</table>

<hr>
<h2 id='.gibbsStep2Eq'>Draws from the posterior of the parameters of the cubs equation, conditional on the states.</h2><span id='topic+.gibbsStep2Eq'></span>

<h3>Description</h3>

<p>Draws from the posterior of the parameters of the cubs equation, conditional on the states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.gibbsStep2Eq(
  Y,
  X,
  p,
  pk,
  pa,
  betaLast,
  sigmaLast,
  betaDistr,
  sigmaDistr,
  phiLast = NULL,
  phiDistr = NULL,
  phiC,
  sigmaC
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".gibbsStep2Eq_+3A_y">Y</code></td>
<td>
<p>a <code>Tn x 1</code> vector.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_x">X</code></td>
<td>
<p>a <code>Tn x n</code> matrix, includes a constant, the contemporaneous cycle, cycle
lags, and lags of cubs.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_p">p</code></td>
<td>
<p>integer, lag of cubs.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_pk">pk</code></td>
<td>
<p>integer, contemporaneous cycle and cycle lags.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_pa">pa</code></td>
<td>
<p>integer, autoregressive order of error term.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_betalast">betaLast</code></td>
<td>
<p>last draw from posterior of beta.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_sigmalast">sigmaLast</code></td>
<td>
<p>last draw from posterior of cubs innovation variance.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_betadistr">betaDistr</code></td>
<td>
<p>prior distribution of beta.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_sigmadistr">sigmaDistr</code></td>
<td>
<p>prior distribution of cubs innovation variance.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_philast">phiLast</code></td>
<td>
<p>(optional) vector, last draw from posterior of the autoregressive
parameter of the error term.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_phidistr">phiDistr</code></td>
<td>
<p>(optional) prior of the autoregressive parameter of the error term.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_phic">phiC</code></td>
<td>
<p>parameter vector of the cycle equation.</p>
</td></tr>
<tr><td><code id=".gibbsStep2Eq_+3A_sigmac">sigmaC</code></td>
<td>
<p>innovation variance of the cycle equation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter vector beta and the innovation variance are Normal-inverse Gamma
distributed. A draw from their posterior is obtained by conjugacy.
</p>
<p>If there are additional lags of the cycle or cubs, conjugacy does not apply
since the starting values are not given. In this case, a Metropolis-Hasting step is
implemented.
</p>
<p>If the error term is an AR(1) or AR(2) process, an additional Gibbs step draws
from the posterior of the autoregressive parameter, given all other parameters.
</p>

<hr>
<h2 id='.gibbsStepAR'>Draws from the posterior of the parameters of the AR(p), <code>p = 1,2</code> cycle equation,
conditional on the states.</h2><span id='topic+.gibbsStepAR'></span>

<h3>Description</h3>

<p>Draws from the posterior of the parameters of the AR(p), <code>p = 1,2</code> cycle equation,
conditional on the states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.gibbsStepAR(Y, parLast, parDistr, varNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".gibbsStepAR_+3A_y">Y</code></td>
<td>
<p>a <code>Tn x 1</code> vector.</p>
</td></tr>
<tr><td><code id=".gibbsStepAR_+3A_parlast">parLast</code></td>
<td>
<p>A <code>(p + 1) x 1</code> vector containing the last draw for the
autoregressive coefficients and the innovation variance (in that order).</p>
</td></tr>
<tr><td><code id=".gibbsStepAR_+3A_pardistr">parDistr</code></td>
<td>
<p>A <code>4 x (p + 1)</code> matrix with prior distribution and box constraints for
the parameters of each variable (the order of the columns is as for parLast). In each
column, the first two entries contain the prior hyperparameters and the last two entries
the upper and lower bound.</p>
</td></tr>
<tr><td><code id=".gibbsStepAR_+3A_varnames">varNames</code></td>
<td>
<p>A vector with parameter names in the correct order, i.e., autoregressive
coefficients, variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The autoregressive parameter and the innovation variance are drawn sequentially.
</p>
<p>If the cycle is AR(1) process, the posterior is obtained by conjugacy. If it is
an AR(2) process, a Metropolis-Hastings step is implemented.
</p>
<p>Conditional on the autoregressive parameters, the innovation variance is drawn
from the Inverse Gamma posterior which is obtained by conjugacy.
</p>

<hr>
<h2 id='.gibbsStepDT'>Draws from the posterior of the parameters of the damped trend equation, conditional on
the states.</h2><span id='topic+.gibbsStepDT'></span>

<h3>Description</h3>

<p>Draws from the posterior of the parameters of the damped trend equation, conditional on
the states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.gibbsStepDT(Y, par, distr, varName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".gibbsStepDT_+3A_y">Y</code></td>
<td>
<p>A <code>Tn x 1</code> vector.</p>
</td></tr>
<tr><td><code id=".gibbsStepDT_+3A_par">par</code></td>
<td>
<p>A <code>3 x 1</code> vector with parameters.</p>
</td></tr>
<tr><td><code id=".gibbsStepDT_+3A_distr">distr</code></td>
<td>
<p>A <code>4 x 3</code> matrix with prior parameters and box constraints.</p>
</td></tr>
<tr><td><code id=".gibbsStepDT_+3A_varname">varName</code></td>
<td>
<p>A <code>3 x 1</code> vector with parameter names in the correct order, i.e.,
mean reversion, autoregressive parameter, variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three parameters are drawn sequentially in a Gibbs procedure. (conditional
on the two other parameters).
</p>
<p>The parameter <code class="reqn">\omega</code> is drawn from a normal posterior which is obtained
by conjugancy.
</p>
<p>The autoregressive parameter <code class="reqn">\phi</code> is drawn via a Metropolis-Hastings step.
</p>
<p>The innovation variance is drwan from the Inverse-Gamma distribution which
obtained by conjugacy.
</p>

<hr>
<h2 id='.gibbsStepRAR2'>Draws from the posterior of the parameters of the RAR2 cycle equation, conditional on the
states.</h2><span id='topic+.gibbsStepRAR2'></span>

<h3>Description</h3>

<p>Draws from the posterior of the parameters of the RAR2 cycle equation, conditional on the
states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.gibbsStepRAR2(Y, parLast, parDistr, varNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".gibbsStepRAR2_+3A_y">Y</code></td>
<td>
<p>a <code>Tn x 1</code> vector.</p>
</td></tr>
<tr><td><code id=".gibbsStepRAR2_+3A_parlast">parLast</code></td>
<td>
<p>A <code>3 x 1</code> vector containing the last draw for amplitude,
mean cycle periodicity, innovation variance (in that order).</p>
</td></tr>
<tr><td><code id=".gibbsStepRAR2_+3A_pardistr">parDistr</code></td>
<td>
<p>A <code>4 x 3</code> matrix with prior distribution and box constraints for
the parameters of each variable (the order of the columns is as for parLast). In each
column, the first two entries contain the prior hyperparameters and the last two entries
the upper and lower bound.</p>
</td></tr>
<tr><td><code id=".gibbsStepRAR2_+3A_varnames">varNames</code></td>
<td>
<p>A vector with parameter names in the correct order, i.e., amplitude,
mean cycle periodicity, variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code class="reqn">A</code> and <code class="reqn">\tau</code> are Beta distributed and the variance
<code class="reqn">\sigma^2</code> is Gamma distributed.
</p>
<p>The posterior is not available in closed form, instead it is obtained via an ARMS
step.
</p>


<h3>Value</h3>

<p>A list with the draws.
</p>

<hr>
<h2 id='.initializeLoc'>Initializes the location file containing default parameter constraints, among other things.</h2><span id='topic+.initializeLoc'></span>

<h3>Description</h3>

<p>Initializes the location file containing default parameter constraints, among other things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.initializeLoc(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".initializeLoc_+3A_model">model</code></td>
<td>
<p>A model of class <code>NAWRUmodel</code> or <code>TFPmodel</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing information on each involved parameter, for instance
its corresponding system matrix, variable names, and parameter restrictions.
</p>

<hr>
<h2 id='.initializeVar'>Initializes variance restrictions.</h2><span id='topic+.initializeVar'></span>

<h3>Description</h3>

<p>Initializes variance restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.initializeVar(
  model,
  type = NULL,
  lambda = NULL,
  prior = FALSE,
  errorARMA = c(0, 0),
  q = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".initializeVar_+3A_model">model</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, or <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code id=".initializeVar_+3A_type">type</code></td>
<td>
<p>The variance restriction type. Possible options are <code>"basic"</code>,
<code>"hp"</code>, see details. The default is <code>type = "basic"</code>.</p>
</td></tr>
<tr><td><code id=".initializeVar_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing constant for the HP-filter if <code>type = "hp"</code>.</p>
</td></tr>
<tr><td><code id=".initializeVar_+3A_prior">prior</code></td>
<td>
<p>A logical indicating whether prior parameters should be returned.</p>
</td></tr>
<tr><td><code id=".initializeVar_+3A_errorarma">errorARMA</code></td>
<td>
<p>The ARMA order of the second equation error process.</p>
</td></tr>
<tr><td><code id=".initializeVar_+3A_q">q</code></td>
<td>
<p>Quantile for the Inverse Gamma distribution (only used if <code>type = "hp"</code>). The 
default is <code>q = 0.01</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.intervalIGamma'>Computes confidence interval of Inverse Gamma distributed variable with given mean and 
standard deviation.</h2><span id='topic+.intervalIGamma'></span>

<h3>Description</h3>

<p>Computes confidence interval of Inverse Gamma distributed variable with given mean and 
standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.intervalIGamma(mu, sd, qlower = 0.025, qupper = 1 - qlower)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".intervalIGamma_+3A_mu">mu</code></td>
<td>
<p>A <code>k x 1</code> vector of means.</p>
</td></tr>
<tr><td><code id=".intervalIGamma_+3A_sd">sd</code></td>
<td>
<p>A <code>k x 1</code> vector of standard deviations.</p>
</td></tr>
<tr><td><code id=".intervalIGamma_+3A_qlower">qlower</code></td>
<td>
<p>A <code>k x 1</code> vector of lower quantiles.</p>
</td></tr>
<tr><td><code id=".intervalIGamma_+3A_qupper">qupper</code></td>
<td>
<p>A <code>k x 1</code> vector of upper quantiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>2 x k</code> matrix containing the lower and upper bounds of the intervals.
</p>

<hr>
<h2 id='.meanStd2Beta'>Converts the mean and standard deviation of a (possibly scaled) Beta-distributed variable
into the two shape parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.</h2><span id='topic+.meanStd2Beta'></span>

<h3>Description</h3>

<p>Converts the mean and standard deviation of a (possibly scaled) Beta-distributed variable
into the two shape parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.meanStd2Beta(m, std, lb = 0, ub = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".meanStd2Beta_+3A_m">m</code></td>
<td>
<p>mean parameter</p>
</td></tr>
<tr><td><code id=".meanStd2Beta_+3A_std">std</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code id=".meanStd2Beta_+3A_lb">lb</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id=".meanStd2Beta_+3A_ub">ub</code></td>
<td>
<p>upper bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with shape parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>

<hr>
<h2 id='.meanStd2GammasNu'>Converts the mean and standard deviation of a Gamma-distributed variable into the
parameters <code class="reqn">s</code> and <code class="reqn">\nu</code>.</h2><span id='topic+.meanStd2GammasNu'></span>

<h3>Description</h3>

<p>Converts the mean and standard deviation of a Gamma-distributed variable into the
parameters <code class="reqn">s</code> and <code class="reqn">\nu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.meanStd2GammasNu(m, std)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".meanStd2GammasNu_+3A_m">m</code></td>
<td>
<p>mean parameter</p>
</td></tr>
<tr><td><code id=".meanStd2GammasNu_+3A_std">std</code></td>
<td>
<p>standard deviation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>s</code> and <code>nu</code> are related to the regular shape
<code class="reqn">\alpha</code> and rate <code class="reqn">\beta</code> parametrization in the following way:
<code class="reqn">\alpha = \nu / 2</code>
<code class="reqn">\beta = s / 2</code>
</p>


<h3>Value</h3>

<p>A vector with parameters <code class="reqn">s</code> and <code class="reqn">\nu</code>.
</p>

<hr>
<h2 id='.MLEfitNAWRU'>Estimates a two-dimensional state-space model and performs filtering and smoothing to
obtain the nawru.</h2><span id='topic+.MLEfitNAWRU'></span>

<h3>Description</h3>

<p>Estimates a two-dimensional state-space model and performs filtering and smoothing to
obtain the nawru.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.MLEfitNAWRU(
  model,
  parRestr = initializeRestr(model = model),
  signalToNoise = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".MLEfitNAWRU_+3A_model">model</code></td>
<td>
<p>An object of class NAWRUmodel.</p>
</td></tr>
<tr><td><code id=".MLEfitNAWRU_+3A_parrestr">parRestr</code></td>
<td>
<p>A list of matrices containing the parameter restrictions for the cycle,
trend, and the Phillip's curve. Each matrix contains the lower and upper bound of the
involved parameters. <code>NA</code> implies that no restriction is present. Autoregressive
parameters are automatically restricted to the stationary region unless box constraints
are specified. By default, <code>parRestr</code> is initialized by the function
<code>initializeRestr(model)</code>. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id=".MLEfitNAWRU_+3A_signaltonoise">signalToNoise</code></td>
<td>
<p>(Optional) signal to noise ratio. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id=".MLEfitNAWRU_+3A_control">control</code></td>
<td>
<p>(Optional) A list of control arguments to be passed on to <code>optim</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.MLEfitTFP'>Estimates a two-dimensional state-space model and performs filtering and smoothing
to obtain the tfp trend.</h2><span id='topic+.MLEfitTFP'></span>

<h3>Description</h3>

<p>Estimates a two-dimensional state-space model and performs filtering and smoothing
to obtain the tfp trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.MLEfitTFP(
  model,
  parRestr = initializeRestr(model),
  signalToNoise = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".MLEfitTFP_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id=".MLEfitTFP_+3A_parrestr">parRestr</code></td>
<td>
<p>A list of matrices containing the parameter restrictions for the cycle,
trend, and the CUBS equation. Each matrix contains the lower and upper bound of the
involved parameters. <code>NA</code> implies that no restriction is present. Autoregressive
parameters are automatically restricted to the stationary region unless box constraints
are specified. By default, <code>parRestr</code> is initialized by the function
<code>initializeRestr(model)</code>. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id=".MLEfitTFP_+3A_signaltonoise">signalToNoise</code></td>
<td>
<p>(Optional) signal to noise ratio. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id=".MLEfitTFP_+3A_control">control</code></td>
<td>
<p>(Optional) A list of control arguments to be passed on to <code>optim</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.modifySSSystem'>Modifies a an object of type <code>NAWRUmodel</code> or <code>TFPmodel</code> in case the variance
constraint for the trend is set to zero or in case a signal-to-noise ratio is specified.</h2><span id='topic+.modifySSSystem'></span>

<h3>Description</h3>

<p>Modifies a an object of type <code>NAWRUmodel</code> or <code>TFPmodel</code> in case the variance
constraint for the trend is set to zero or in case a signal-to-noise ratio is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.modifySSSystem(model, signalToNoise)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".modifySSSystem_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id=".modifySSSystem_+3A_signaltonoise">signalToNoise</code></td>
<td>
<p>(Optional) signal to noise ratio. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.mvrnorm'>Draws from the multivariate normal distribution.</h2><span id='topic+.mvrnorm'></span>

<h3>Description</h3>

<p>Draws from the multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mvrnorm(mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".mvrnorm_+3A_mu">mu</code></td>
<td>
<p>A <code>n x 1</code> vector, the mean vector.</p>
</td></tr>
<tr><td><code id=".mvrnorm_+3A_sigma">sigma</code></td>
<td>
<p>A <code>n x n</code> matrix, the covariance matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='.normalize'>Normalizes a time series / vector.</h2><span id='topic+.normalize'></span>

<h3>Description</h3>

<p>Normalizes a time series / vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.normalize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".normalize_+3A_x">x</code></td>
<td>
<p>E.g. a time series.</p>
</td></tr>
</table>

<hr>
<h2 id='.postAR1'>Draws from the posterior the autoregressive parameter of a stationary AR(1) process
without starting values.</h2><span id='topic+.postAR1'></span>

<h3>Description</h3>

<p>Draws from the posterior the autoregressive parameter of a stationary AR(1) process
without starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.postAR1(Y, phi, phi0, Q0, sigma, lb = -Inf, ub = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".postAR1_+3A_y">Y</code></td>
<td>
<p>a <code>Tn x 1</code> vector.</p>
</td></tr>
<tr><td><code id=".postAR1_+3A_phi">phi</code></td>
<td>
<p>a scalar containing the last draw of the autoregressive parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id=".postAR1_+3A_phi0">phi0</code></td>
<td>
<p>a scalar containing the prior mean for <code>phi</code>.</p>
</td></tr>
<tr><td><code id=".postAR1_+3A_q0">Q0</code></td>
<td>
<p>a scalar containing the prior precision for <code>phi</code>.</p>
</td></tr>
<tr><td><code id=".postAR1_+3A_sigma">sigma</code></td>
<td>
<p>a scalar containing the innovation variance.</p>
</td></tr>
<tr><td><code id=".postAR1_+3A_lb">lb</code></td>
<td>
<p>(optional) lower bound for <code>phi</code>.</p>
</td></tr>
<tr><td><code id=".postAR1_+3A_ub">ub</code></td>
<td>
<p>(optional) upper bound for <code>phi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corresponding model is given by <code class="reqn">Y_t = \phi Y_{t-1} + e_t</code>, where
<code class="reqn">e_t ~ N(0, \sigma)</code> with prior distribution
<code class="reqn">p(\phi) = N(\phi_0, 1/Q_0 )</code>.
</p>
<p>Conditional on the variance <code class="reqn">\sigma</code>, the posterior is normal and known.
</p>
<p>Stationarity and box constraints are enforced. If the stationarity constraint
is not fulfilled, the last draw is returned.
</p>

<hr>
<h2 id='.postARp'>Draws from the posterior of the autoregressive paramteres of a stationary AR(p),
<code class="reqn">p &gt; 1</code> process without starting values.</h2><span id='topic+.postARp'></span>

<h3>Description</h3>

<p>Draws from the posterior of the autoregressive paramteres of a stationary AR(p),
<code class="reqn">p &gt; 1</code> process without starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.postARp(Y, phi, phi0, Q0, sigma, lb = -Inf, ub = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".postARp_+3A_y">Y</code></td>
<td>
<p>A <code>Tn x 1</code> vector with the time series.</p>
</td></tr>
<tr><td><code id=".postARp_+3A_phi">phi</code></td>
<td>
<p>a <code>1 x p</code> vector containing the last draw of the autoregressive parameters
<code class="reqn">\phi</code>. <code>p</code> has to be larger than one.</p>
</td></tr>
<tr><td><code id=".postARp_+3A_phi0">phi0</code></td>
<td>
<p>a <code>1 x p</code> vector containing the prior mean for <code>phi</code>.</p>
</td></tr>
<tr><td><code id=".postARp_+3A_q0">Q0</code></td>
<td>
<p>a <code>p x p</code> matrix containing the prior precision for <code>phi</code>.</p>
</td></tr>
<tr><td><code id=".postARp_+3A_sigma">sigma</code></td>
<td>
<p>a scalar containing the innovation variance.</p>
</td></tr>
<tr><td><code id=".postARp_+3A_lb">lb</code></td>
<td>
<p>(optional) <code>1 x p</code> vector with lower bounds for <code>phi</code>.</p>
</td></tr>
<tr><td><code id=".postARp_+3A_ub">ub</code></td>
<td>
<p>(optional) <code>1 x p</code> vector with upper bounds for <code>phi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corresponding model is given by
<code class="reqn">Y_t = \phi_1 Y_{t-1} + ... + \phi_p Y_{t-p} + e_t</code>, where
<code class="reqn">e_t ~ N(0, \sigma)</code> with prior distribution <code class="reqn">p(\phi) = N(\phi_0, 1/Q_0 )</code>.
</p>
<p>The posterior draw is obtained via a Metropolis Hastings step with proposal density
<code class="reqn"> q = \prod_{t=p+1}^Tn p(Y_t, \phi, \sigma, Y_{t-1}, ..., Y_{t-p} )</code> which is
known due to conjugacy. The acceptance probability is given by
<code class="reqn"> \alpha = \min{1, p(Y_1, ... Y_p | \phi_r, \sigma) / p(Y_1, ... Y_p | \phi_{r-1}, \sigma)}</code>
where the subscript <code class="reqn">r</code> denotes the r-th draw. <code class="reqn">p(Y_1, ... Y_p | \phi_r, \sigma)</code>
is itself normal.
</p>
<p>Stationarity and box constraints are enforced. If the constraints
are not fulfilled, the last draw is returned.
</p>

<hr>
<h2 id='.postNIG'>Draws from the posterior of parameters of a normal model with normal inverse gamma prior.</h2><span id='topic+.postNIG'></span>

<h3>Description</h3>

<p>Draws from the posterior of parameters of a normal model with normal inverse gamma prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.postNIG(Y, X, betaLast, betaDistr, sigmaDistr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".postNIG_+3A_y">Y</code></td>
<td>
<p>A <code>Tn x 1</code> vector with the dependent variable.</p>
</td></tr>
<tr><td><code id=".postNIG_+3A_x">X</code></td>
<td>
<p>A <code>Tn x k</code> matrix with the <code>k</code> explanatory variables.</p>
</td></tr>
<tr><td><code id=".postNIG_+3A_betalast">betaLast</code></td>
<td>
<p>A <code>k x 1</code> vector containing the last draw.</p>
</td></tr>
<tr><td><code id=".postNIG_+3A_betadistr">betaDistr</code></td>
<td>
<p>A <code>4 x k</code> matrix with prior distribution and box constraints for
the parameters of each variable. In each column, the first two entries contain the
prior hyperparameters and the last two entries the upper and lower bound.</p>
</td></tr>
<tr><td><code id=".postNIG_+3A_sigmadistr">sigmaDistr</code></td>
<td>
<p>A <code>1 x k</code> matrix with prior distribution and box constraints for
the innovation variance. The first two entries contain the prior hyperparameters and
the last two entries the upper and lower bound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws from the posterior are obtained by conjugacy of the Normal-Inverse-Gamma
distribution.
</p>


<h3>Value</h3>

<p>A list with a draws for beta and the innovation variance.
</p>

<hr>
<h2 id='.postRW'>Draws from the posterior of the variance parameter of a random walk or a random walk with
constant or stochastic drift.</h2><span id='topic+.postRW'></span>

<h3>Description</h3>

<p>Draws from the posterior of the variance parameter of a random walk or a random walk with
constant or stochastic drift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.postRW(Y, sigmaDistr, sigmaLast = NULL, muDistr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".postRW_+3A_y">Y</code></td>
<td>
<p>A <code>Tn x 1</code> vector with the dependent variable.</p>
</td></tr>
<tr><td><code id=".postRW_+3A_sigmadistr">sigmaDistr</code></td>
<td>
<p>A <code>1 x k</code> matrix with prior distribution and box constraints for
the innovation variance. The first two entries contain the prior hyperparameters and
the last two entries the upper and lower bound.</p>
</td></tr>
<tr><td><code id=".postRW_+3A_sigmalast">sigmaLast</code></td>
<td>
<p>A scalar containing the last draw of the innovation variance.</p>
</td></tr>
<tr><td><code id=".postRW_+3A_mudistr">muDistr</code></td>
<td>
<p>A <code>k x 1</code> matrix with prior distribution and box constraints for
the constant trend. The first two entries contain the prior hyperparameters and
the last two entries the upper and lower bound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the process follows a random walk with constant drift, the two parameters are
drawn sequentially (conditional on the other parameter). The constant is drawn from a
normal posterior given by conjugacy.
</p>
<p>The innovation variance is drawn from a Inverse-Gamma posterior given by
conjugacy.
</p>

<hr>
<h2 id='.printGeweke'>Prints the results of the Geweke test for the states and the parameters.</h2><span id='topic+.printGeweke'></span>

<h3>Description</h3>

<p>Prints the results of the Geweke test for the states and the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.printGeweke(tsl, df, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".printGeweke_+3A_tsl">tsl</code></td>
<td>
<p>A multiple time series list containing the Geweke test statistic for the
states.</p>
</td></tr>
<tr><td><code id=".printGeweke_+3A_df">df</code></td>
<td>
<p>A data frame containing the Geweke test statistic for the parameters.</p>
</td></tr>
<tr><td><code id=".printGeweke_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used to reach a test decision, a scalar between zero
and one.</p>
</td></tr>
</table>

<hr>
<h2 id='.printSSModel'>Prints the model specifications.</h2><span id='topic+.printSSModel'></span>

<h3>Description</h3>

<p>Prints the model specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.printSSModel(x, call = TRUE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".printSSModel_+3A_x">x</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, or <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code id=".printSSModel_+3A_call">call</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the call will be printed.</p>
</td></tr>
<tr><td><code id=".printSSModel_+3A_check">check</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the model class will be checked.</p>
</td></tr>
</table>

<hr>
<h2 id='.printSSModelFit'>Prints the model fit and possibly specifications.</h2><span id='topic+.printSSModelFit'></span>

<h3>Description</h3>

<p>Prints the model fit and possibly specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.printSSModelFit(x, call = TRUE, check = TRUE, print.model = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".printSSModelFit_+3A_x">x</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, or <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code id=".printSSModelFit_+3A_call">call</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the call will be printed.</p>
</td></tr>
<tr><td><code id=".printSSModelFit_+3A_check">check</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the model class will be checked.</p>
</td></tr>
<tr><td><code id=".printSSModelFit_+3A_print.model">print.model</code></td>
<td>
<p>A logical indicating whether the model specification should be printed.</p>
</td></tr>
</table>

<hr>
<h2 id='.priorMSd2Parameter'>Transforms the prior distribution defined by mean and standard deviation to the
appropriate input parameters.</h2><span id='topic+.priorMSd2Parameter'></span>

<h3>Description</h3>

<p>Transforms the prior distribution defined by mean and standard deviation to the
appropriate input parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.priorMSd2Parameter(
  prior,
  restr,
  namesInvGammaDistr,
  namesNormalDistr,
  namesBetaDistr
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".priorMSd2Parameter_+3A_prior">prior</code></td>
<td>
<p>A matrix containing the mean and standard deviation of the priors.</p>
</td></tr>
<tr><td><code id=".priorMSd2Parameter_+3A_restr">restr</code></td>
<td>
<p>A matrix containing box constraints for the parameters.</p>
</td></tr>
<tr><td><code id=".priorMSd2Parameter_+3A_namesinvgammadistr">namesInvGammaDistr</code></td>
<td>
<p>A character vector specifying the names of all inverse Gamma
distributed parameters.</p>
</td></tr>
<tr><td><code id=".priorMSd2Parameter_+3A_namesnormaldistr">namesNormalDistr</code></td>
<td>
<p>A character vector specifying the names of all normally
distributed parameters.</p>
</td></tr>
<tr><td><code id=".priorMSd2Parameter_+3A_namesbetadistr">namesBetaDistr</code></td>
<td>
<p>A character vector specifying the names of all Beta distributed
parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='.RAR2transform'>Transforms the parameters of an AR(2) process to its re-parametrized version RAR(2) and
vice versa.</h2><span id='topic+.RAR2transform'></span>

<h3>Description</h3>

<p>Transforms the parameters of an AR(2) process to its re-parametrized version RAR(2) and
vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.RAR2transform(par, phi2Atau = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".RAR2transform_+3A_par">par</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id=".RAR2transform_+3A_phi2atau">phi2Atau</code></td>
<td>
<p>logical indicating whether the transformation should be from AR(2) to
RAR(2) or vice versa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the transformed parameters
</p>

<hr>
<h2 id='.SSmodelfit'>Computes figures regarding the model fit of the maximum likelihood estimation.</h2><span id='topic+.SSmodelfit'></span>

<h3>Description</h3>

<p>Computes figures regarding the model fit of the maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.SSmodelfit(out, nPar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".SSmodelfit_+3A_out">out</code></td>
<td>
<p>The return object of the function <code>KFS</code> from the package <code>KFAS</code>.</p>
</td></tr>
<tr><td><code id=".SSmodelfit_+3A_npar">nPar</code></td>
<td>
<p>A scalar specifying the number of estimated parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='.SSresults'>Computes additional results of the Kalman filter and smoother.</h2><span id='topic+.SSresults'></span>

<h3>Description</h3>

<p>Computes additional results of the Kalman filter and smoother.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.SSresults(out, model, prediction = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".SSresults_+3A_out">out</code></td>
<td>
<p>The return object of the function <code>KFS</code> from the package <code>KFAS</code>.</p>
</td></tr>
<tr><td><code id=".SSresults_+3A_model">model</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, or <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code id=".SSresults_+3A_prediction">prediction</code></td>
<td>
<p>Logical indicating whether <code>out</code> includes predictions.</p>
</td></tr>
</table>

<hr>
<h2 id='.SSresultsBayesian'>Computes additional results of the Kalman filter and smoother for Bayesian output.</h2><span id='topic+.SSresultsBayesian'></span>

<h3>Description</h3>

<p>Computes additional results of the Kalman filter and smoother for Bayesian output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.SSresultsBayesian(model, HPDIprob, state, obsFitted, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".SSresultsBayesian_+3A_model">model</code></td>
<td>
<p>The return object of the function <code>fitSSM</code> from the package <code>KFAS</code>.</p>
</td></tr>
<tr><td><code id=".SSresultsBayesian_+3A_hpdiprob">HPDIprob</code></td>
<td>
<p>A numeric in the interval <code>(0,1)</code> specifying the target probability
of the highest posterior density intervals. The default is <code>HPDIprob = 0.9</code>. Only
used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id=".SSresultsBayesian_+3A_state">state</code></td>
<td>
<p>An array with the smoothed state.</p>
</td></tr>
<tr><td><code id=".SSresultsBayesian_+3A_obsfitted">obsFitted</code></td>
<td>
<p>An array with the fitted observables.</p>
</td></tr>
</table>

<hr>
<h2 id='.SSSystem'>Prepares state space model system matrices to create an object of type <code>NAWRUmodel</code>
or <code>TFPmodel</code>.</h2><span id='topic+.SSSystem'></span>

<h3>Description</h3>

<p>Prepares state space model system matrices to create an object of type <code>NAWRUmodel</code>
or <code>TFPmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.SSSystem(tsl, cycle, trend, cycleLag, type = NULL, errorARMA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".SSSystem_+3A_tsl">tsl</code></td>
<td>
<p>A list of input time series computed during the procedure <code>NAWRUmodel</code>
or <code>TFPmodel</code>.</p>
</td></tr>
<tr><td><code id=".SSSystem_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an <code>AR(2)</code> process. The default is
<code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id=".SSSystem_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "RW2"</code>.</p>
</td></tr>
<tr><td><code id=".SSSystem_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A vector specifying the cycle lags that are included in the Phillip's
curve. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id=".SSSystem_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of the Phillip's curve.
<code>type = "TKP"</code> denotes the traditional Keynesian Phillip's curve and
<code>type = "NKP"</code> the New Keynesian Phillip's curve, see details. The default is
<code>type = "TKP"</code>.</p>
</td></tr>
<tr><td><code id=".SSSystem_+3A_errorarma">errorARMA</code></td>
<td>
<p>A vector with non-negative integers specifying the AR and MA degree of
the error term in the second observation equation.</p>
</td></tr>
</table>

<hr>
<h2 id='.updateParConstraints'>Updates the parameter constraints for on object of class <code>NAWRUmodel</code> or
<code>TFPmodel</code>.</h2><span id='topic+.updateParConstraints'></span>

<h3>Description</h3>

<p>Updates the parameter constraints for on object of class <code>NAWRUmodel</code> or
<code>TFPmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.updateParConstraints(model, parRestr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".updateParConstraints_+3A_model">model</code></td>
<td>
<p>A model of class <code>NAWRUmodel</code> or <code>TFPmodel</code>.</p>
</td></tr>
<tr><td><code id=".updateParConstraints_+3A_parrestr">parRestr</code></td>
<td>
<p>A list of matrices containing the parameter restrictions for the cycle,
trend, and the Phillip's curve. Each matrix contains the lower and upper bound of the
involved parameters. <code>NA</code> implies that no restriction is present. Autoregressive
parameters are automatically restricted to the stationary region unless box constraints
are specified. By default, <code>parRestr</code> is initialized by the function
<code>initializeRestr(model)</code>. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same model with updated list item <code>loc</code>.
</p>

<hr>
<h2 id='.updateSSSystem'>Updates the system matrices of an object of class <code>NAWRUmodel</code> or <code>TFPmodel</code>
during optimization or during a Bayesian Gibbs procedure.</h2><span id='topic+.updateSSSystem'></span>

<h3>Description</h3>

<p>Updates the system matrices of an object of class <code>NAWRUmodel</code> or <code>TFPmodel</code>
during optimization or during a Bayesian Gibbs procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.updateSSSystem(
  pars,
  SSModel,
  loc,
  cycle,
  trend,
  errorARMA,
  signalToNoise = NULL,
  type = NULL,
  bayes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".updateSSSystem_+3A_pars">pars</code></td>
<td>
<p>A vector of parameters.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_ssmodel">SSModel</code></td>
<td>
<p>An object of class <code>SSModel</code> specifying the state-space model.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_loc">loc</code></td>
<td>
<p>A data frame containing information on each involved parameter, for instance
its corresponding system matrix, variable names, and parameter restrictions.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an <code>AR(2)</code> process. The default is
<code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "RW2"</code>.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_errorarma">errorARMA</code></td>
<td>
<p>A vector with non-negative integers specifying the AR
and MA degree of the error term in the second observation equation.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_signaltonoise">signalToNoise</code></td>
<td>
<p>(Optional) signal to noise ratio. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of the Phillip's curve.
<code>type = "TKP"</code> denotes the traditional Keynesian Phillip's curve and
<code>type = "NKP"</code> the New Keynesian Phillip's curve, see details. The default is
<code>type = "TKP"</code>.</p>
</td></tr>
<tr><td><code id=".updateSSSystem_+3A_bayes">bayes</code></td>
<td>
<p>A logical indicating whether the update is part of a Bayesian procedure, i.e.,
the parameter constraints do not need to be enforced.</p>
</td></tr>
</table>

<hr>
<h2 id='amecoData2input'>Data for estimation</h2><span id='topic+amecoData2input'></span>

<h3>Description</h3>

<p>Computes the necessary input data for the EC output gap estimation on the basis of AMECO
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amecoData2input(tslAmeco, alpha = 0.65)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amecoData2input_+3A_tslameco">tslAmeco</code></td>
<td>
<p>A time series list or a multiple time series object containing AMECO
data.</p>
</td></tr>
<tr><td><code id="amecoData2input_+3A_alpha">alpha</code></td>
<td>
<p>A number between <code>0</code> and <code>1</code> indicating the labor share. The
default is <code>alpha = 0.65</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of time series <code>tslAmeco</code> needs to have the following components:
</p>

<dl>
<dt>popw</dt><dd><p>Population: 15 to 64 years (unit: 1000 persons, code: NPAN)</p>
</dd>
<dt>ur</dt><dd><p>Unemployment rate, total; Member States: definition EUROSTAT (unit: Percentage of civilian labor force, code: ZUTN)</p>
</dd>
<dt>etd</dt><dd><p>Employment, persons: total economy (National accounts) (unit: 1000 persons, code: NETN)</p>
</dd>
<dt>et</dt><dd><p>Employment, persons: all domestic industries (National accounts) (unit: 1000 persons, code: NETD)</p>
</dd>
<dt>eet</dt><dd><p>Employees, persons: all domestic industries (National accounts) (unit: 1000 persons, code: NWTD)</p>
</dd>
<dt>pconsp</dt><dd><p>Price deflator private final consumption expenditure (unit: National currency reference year = 100, code: PCPH)</p>
</dd>
<dt>ngdp</dt><dd><p>Gross domestic product at current prices (unit: bn National currency, code: UVGD)</p>
</dd>
<dt>gdp</dt><dd><p>Gross domestic product at constant prices (unit: bn National currency, code: OVGD)</p>
</dd>
<dt>l</dt><dd><p>Total annual hours worked: total economy (unit: millions, code: NLHT)</p>
</dd>
<dt>wtotal</dt><dd><p>Compensation of employees: total economy (unit: bn National currency, code: UWCD)</p>
</dd>
<dt>nulc</dt><dd><p>Nominal unit labour costs: total economy (Ratio of compensation per employee to real GDP per person employed.) (unit: National currency reference year = 100, code: PLCD)</p>
</dd>
<dt>k</dt><dd><p>Net capital stock at constant prices: total economy (unit: bn National currency, code: OKND)</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of time series containing the same components as the input list <code>tslAmeco</code>
and the following additional components:
</p>
<table>
<tr><td><code>gdpdefl</code></td>
<td>
<p>Gross domestic product deflator</p>
</td></tr>
<tr><td><code>tfp</code></td>
<td>
<p>Total factor productivity</p>
</td></tr>
<tr><td><code>lfnd</code></td>
<td>
<p>Labor force non-domestic (unit: 1000 persons)</p>
</td></tr>
<tr><td><code>parts</code></td>
<td>
<p>Participation rate</p>
</td></tr>
<tr><td><code>ahours</code></td>
<td>
<p>Average hours worked (unit: hours)</p>
</td></tr>
<tr><td><code>prod</code></td>
<td>
<p>Labor productivity (unit: real output in millions per person)</p>
</td></tr>
<tr><td><code>tot</code></td>
<td>
<p>Terms of trade (pconcp / gdpdefl)</p>
</td></tr>
<tr><td><code>ws</code></td>
<td>
<p>Wage share (unit: compensation per unit of nominal output)</p>
</td></tr>
<tr><td><code>winfl</code></td>
<td>
<p>Wage inflation</p>
</td></tr>
<tr><td><code>rulc</code></td>
<td>
<p>Real unit labor costs</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load data for Germany
data("gap")
country &lt;- "Germany"
tsListRaw &lt;- gap[[country]]
tsListInput &lt;- amecoData2input(tslAmeco = tsListRaw)
</code></pre>

<hr>
<h2 id='assignConstraints'>Applies suitable contraining functions to parameters.</h2><span id='topic+assignConstraints'></span>

<h3>Description</h3>

<p>Applies suitable contraining functions to parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignConstraints(par, loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignConstraints_+3A_par">par</code></td>
<td>
<p>names vector with parameters</p>
</td></tr>
<tr><td><code id="assignConstraints_+3A_loc">loc</code></td>
<td>
<p>A data frame containing information on each involved parameter (list element
of objects of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, <code>KuttnerModel</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='autoGapProd'>Fit best production function model</h2><span id='topic+autoGapProd'></span>

<h3>Description</h3>

<p>Finds the most suitable model for the NAWRU and the TFP trend according to 
the BIC or the RMSE. The function computes the output gap based on the chosen models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoGapProd(
  tsl,
  type = "hp",
  q = 0.01,
  method = "MLE",
  criterion = "BIC",
  fast = TRUE,
  nModels = 5,
  nawruPoss = list(maxCycleLag = 2, trend = c("RW2", "DT"), cycle = c("AR1", "AR2"),
    errorARmax = 1, errorMAmax = 0, type = c("TKP", "NKP"), exoNames = c("ws", "prod",
    "tot"), signalToNoise = NULL),
  tfpPoss = list(maxCycleLag = 2, trend = c("RW2", "DT"), cycle = c("AR1", "AR2",
    "RAR2"), cubsARmax = 0, errorARmax = 1, errorMAmax = 0, signalToNoise = NULL),
  auto = "gap"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoGapProd_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_type">type</code></td>
<td>
<p>The variance restriction type. Possible options are <code>"basic"</code>,
<code>"hp"</code>, see <code>initializeRestr</code>. The default is <code>type = "hp"</code>.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_q">q</code></td>
<td>
<p>Quantile for the Inverse Gamma distribution (only used if <code>type = "hp"</code>), 
see <code>initializeRestr</code>. The default is <code>q = 0.01</code>.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_method">method</code></td>
<td>
<p>The estimation method. Options are maximum likelihood estimation <code>"MLE"</code>
and bayesian estimation <code>"bayesian"</code>. If <code>method = c("MLE", "bayesian")</code> the 
NAWRU is fitted by MLE and the TFP trend by Bayesian methods. The default is 
<code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_criterion">criterion</code></td>
<td>
<p>Model selection criterion. Options are the Bayesian information criterion 
<code>"BIC"</code> and the root mean squared error <code>"RMSE"</code>, both computed for the second 
observation equation. The default is <code>criterion = "BIC"</code>. For Bayesian estimation 
and  <code>criterion = "RMSE"</code>, the mean RMSE is used.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_fast">fast</code></td>
<td>
<p>Boolean, indicating whether a &quot;fast&quot; procedure should be used, see details.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_nmodels">nModels</code></td>
<td>
<p>Integer, the maximum number of models for each unobserved component model.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_nawruposs">nawruPoss</code></td>
<td>
<p>List with possible model specifications for the NAWRU, see details.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_tfpposs">tfpPoss</code></td>
<td>
<p>List with possible model specifications for the NAWRU, see details.</p>
</td></tr>
<tr><td><code id="autoGapProd_+3A_auto">auto</code></td>
<td>
<p>If <code>auto = "NAWRU"</code> or <code>auto = "TFP"</code>, the function only 
finds the most suitable NAWRU or TFP model, respectively. The default is 
<code>auto = "gap"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>fast = TRUE</code>, the function pre-selects suitable models by applying the 
following procedure: A HP-filtered trend is computed based on which the best trend and 
cycle models are chosen according to the BIC. Also based on the HP trend, a variety of 
different specifications for the second observation equation are estimated in a 
univariate regression and the best models are selected via the BIC. The <code>nModels</code> 
best models are subsequently estimated in the usual bivariate unobserved component 
model. For <code>fast = FALSE</code>, a variety of models is estimated in the usual bivariate 
unobserved component framework.
</p>
<p>The input component <code>nawruPoss</code> is a list containing a (sub-) set of the 
following components: 
</p>

<dl>
<dt>maxCycleLag</dt><dd><p>Maximum cycle lag included in the second observation equation.</p>
</dd>
<dt>trend</dt><dd><p>Trend model specification.</p>
</dd>
<dt>cycle</dt><dd><p>Cycle model specification.</p>
</dd>
<dt>errorARmax</dt><dd><p>Maximum autoregressive order of the error term in the second 
observation equation.</p>
</dd>
<dt>errorMAmax</dt><dd><p>Maximum moving average order of the error term in the second 
observation equation.</p>
</dd>
<dt>type</dt><dd><p>Type of Phillip's curve.</p>
</dd>
<dt>exoNames</dt><dd><p>Names of the exogenous variables potentially included in the Phillip's 
curve (need to be included in the list of time series <code>tsl</code>).</p>
</dd>
<dt>signal-to-noise</dt><dd><p>Signal-to-noise ratio.</p>
</dd>
</dl>

<p>The input component <code>tfpPoss</code> is a list containing a (sub-) set of the 
following components: 
</p>

<dl>
<dt>maxCycleLag</dt><dd><p>Maximum cycle lag included in the second observation equation.</p>
</dd>
<dt>trend</dt><dd><p>Trend model specification.</p>
</dd>
<dt>cycle</dt><dd><p>Cycle model specification.</p>
</dd>
<dt>cubsARmax</dt><dd><p>Maximum CUBS autoregressive order.</p>
</dd>
<dt>errorARmax</dt><dd><p>Maximum autoregressive order of the error term in the second 
observation equation.</p>
</dd>
<dt>errorMAmax</dt><dd><p>Maximum moving average order of the error term in the second 
observation equation.</p>
</dd>
<dt>signal-to-noise</dt><dd><p>Signal-to-noise ratio.</p>
</dd>
</dl>

<p>The list of time series <code>tsl</code> needs to have the following components 
(plus those series included in the list component <code>exoNames</code> in <code>nawruPoss</code>):
</p>

<dl>
<dt>ur</dt><dd><p>Unemployment rate.</p>
</dd>
<dt>nulc</dt><dd><p>Nominal Unit labor costs, if <code>type = "TKP"</code>.</p>
</dd>
<dt>rulc</dt><dd><p>Real unit labor costs, if <code>type = "NKP"</code>.</p>
</dd>
<dt>tfp</dt><dd><p>Total factor productivity.</p>
</dd>
<dt>cubs</dt><dd><p>Capacity utilization economic sentiment indicator.</p>
</dd>
<dt>lfnd</dt><dd><p>Labor force non-domestic (unit: 1000 persons).</p>
</dd>
<dt>parts</dt><dd><p>Participation rate.</p>
</dd>
<dt>ahours</dt><dd><p>Average hours worked (unit: hours).</p>
</dd>
<dt>gdp</dt><dd><p>Gross domestic product at constant prices (unit: bn National currency, code: OVGD).</p>
</dd>
<dt>k</dt><dd><p>Net capital stock at constant prices: total economy (unit: bn National currency, code: OKND).</p>
</dd>
<dt>popw</dt><dd><p>Population: 15 to 64 years (unit: 1000 persons, code: NPAN).</p>
</dd>
</dl>

<p>The set of tested models is extensive but not exhaustive. The best model is 
solely based on convergence and the chosen criterion (RMSE or BIC). A manual check 
of the results is highly recommended.
</p>
<p>In some cases, more than <code>nModels</code> are checked. For instance, if a 
re-parametrized and regular AR(2) process are options for the cycle.
</p>


<h3>Value</h3>

<p>A list containing three components: <code>gap</code> (the best model of class <code>"gap"</code>), 
<code>tfp</code> (a nested list of TFP models, fitted objects and model fit criteria), <code>nawru</code> 
(a nested list of NAWRU models, fitted objects and model fit criteria). The lists <code>nawru</code>
and <code>tfp</code> contain a list of models, a list of fitted objects and a dataframe <code>info</code>,
which contains
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood function at optimum</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion</p>
</td></tr>
<tr><td><code>HQC</code></td>
<td>
<p>Hannan-Quinn information criterion</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root mean squared error</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>Coefficient of determination (R squared)</p>
</td></tr>
<tr><td><code>signal-to-noise</code></td>
<td>
<p>Signal-to-noise ratio</p>
</td></tr>
<tr><td><code>LjungBox</code></td>
<td>
<p>p-value of Ljung-Box test for autocorrelation (H0 = no autocorrelation)</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>0 indicates convergence of the optimization</p>
</td></tr>
<tr><td><code>rrange</code></td>
<td>
<p>relative range of trend series w.r.t original series</p>
</td></tr>
<tr><td><code>neg</code></td>
<td>
<p>1 indicates that negative values are present in the trend series</p>
</td></tr>
<tr><td><code>rev</code></td>
<td>
<p>relative excess volatility w.r.t. original series (stationary series)</p>
</td></tr>
<tr><td><code>rsd</code></td>
<td>
<p>relative standard deviation w.r.t. original series (stationary series)</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>correlation between trend and original series (stationary series)</p>
</td></tr>
<tr><td><code>msdtg</code></td>
<td>
<p>mean standardized deviation (stationary trend)</p>
</td></tr>
<tr><td><code>magtg</code></td>
<td>
<p>mean absolute growth of trend (stationaty trend)</p>
</td></tr>
<tr><td><code>drop</code></td>
<td>
<p>1 indicates the model should be dropped</p>
</td></tr>
</table>

<hr>
<h2 id='autoNAWRUmodel'>NAWRU model suggestion</h2><span id='topic+autoNAWRUmodel'></span>

<h3>Description</h3>

<p>Finds the most suitable NAWRU models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoNAWRUmodel(tsl, poss, nModels = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoNAWRUmodel_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="autoNAWRUmodel_+3A_poss">poss</code></td>
<td>
<p>A list with the characteristics of possible models (see <code>autoGapProd)</code></p>
</td></tr>
<tr><td><code id="autoNAWRUmodel_+3A_nmodels">nModels</code></td>
<td>
<p>Integer, the maximum number of models for each unobserved component model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list with one model specification per list entry.
</p>

<hr>
<h2 id='autoTFPmodel'>TFP model suggestion</h2><span id='topic+autoTFPmodel'></span>

<h3>Description</h3>

<p>Finds the most suitable TFP models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoTFPmodel(tsl, poss, nModels = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoTFPmodel_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="autoTFPmodel_+3A_poss">poss</code></td>
<td>
<p>A list with the characteristics of possible models (see <code>autoGapProd)</code></p>
</td></tr>
<tr><td><code id="autoTFPmodel_+3A_nmodels">nModels</code></td>
<td>
<p>Integer, the maximum number of models for each unobserved component model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list with one model specification per list entry.
</p>

<hr>
<h2 id='computeCovar'>Computes the covariance of the estimated parameters given restrictions.</h2><span id='topic+computeCovar'></span>

<h3>Description</h3>

<p>Computes the covariance of the estimated parameters given restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCovar(par, loc, CV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCovar_+3A_par">par</code></td>
<td>
<p>names vector with parameters</p>
</td></tr>
<tr><td><code id="computeCovar_+3A_loc">loc</code></td>
<td>
<p>A data frame containing information on each involved parameter (list element
of objects of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, <code>KuttnerModel</code>).</p>
</td></tr>
<tr><td><code id="computeCovar_+3A_cv">CV</code></td>
<td>
<p>unconstrained variance covariance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='constraint'>Applies contraints to parameters.</h2><span id='topic+constraint'></span>

<h3>Description</h3>

<p>Applies contraints to parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraint(par, type = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraint_+3A_par">par</code></td>
<td>
<p>names vector with parameters</p>
</td></tr>
<tr><td><code id="constraint_+3A_type">type</code></td>
<td>
<p>character with constraint type</p>
</td></tr>
</table>

<hr>
<h2 id='cubs'>CUBS indicator</h2><span id='topic+cubs'></span>

<h3>Description</h3>

<p>Computes the capacity utilization economic sentiment (CUBS) indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubs(tsCU, tsVA, frequency = 1, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubs_+3A_tscu">tsCU</code></td>
<td>
<p>A multiple time series containing three survey time series, the first
element needs to be capacity utilization in industry, see details. Alternatively, a list
of time series can be supplied.</p>
</td></tr>
<tr><td><code id="cubs_+3A_tsva">tsVA</code></td>
<td>
<p>A multiple time series containing three value added series that correspond to
<code>tsCU</code>. Alternatively, a list of time series can be supplied.</p>
</td></tr>
<tr><td><code id="cubs_+3A_frequency">frequency</code></td>
<td>
<p>The frequency of the computed cubs indicator. Possible entries are
<code>frequency = 1</code> (annual), <code>frequency = 4</code> (quarterly). The default is
<code>frequency = 1</code>.</p>
</td></tr>
<tr><td><code id="cubs_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing parameter for the application of the HP filter (see details).
If not supplied, <code>lambda = 6.25</code> is used for yearly data and <code>lambda = 1600</code> 
for quarterly data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>tslCU</code> contains capacity utilization in industry, and the relevant
survey outcomes of the construction and service sector. The first list object needs to
contain capacity utilization in industry.
</p>
<p>The list <code>tslVA</code> contains the real value added series for the industry,
construction and service sector in the same order as <code>tslCU</code>.
</p>
<p>The computed CUBS indicator consists exclusively of capacity utilization in
industry until both other series become available.
</p>


<h3>Value</h3>

<p>A list containing the two time series capacity utilization in industry <code>cu</code>
and the CUBS indicator <code>cubs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data for Germany
data("gap")
country &lt;- "Germany"

# compute cubs indicator
namesCubs &lt;- c("indu", "serv", "buil")
namesVACubs &lt;- paste0("va", namesCubs)
tscubs &lt;- cubs(
  tsCU = gap[[country]][, namesCubs],
  tsVA = gap[[country]][, namesVACubs]
)
</code></pre>

<hr>
<h2 id='cycleOptim'>Find suitable cycle specification</h2><span id='topic+cycleOptim'></span>

<h3>Description</h3>

<p>Finds the most suitable cycle model according to the BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycleOptim(x, opt = c("AR1", "AR2", "RAR2"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycleOptim_+3A_x">x</code></td>
<td>
<p>A time series.</p>
</td></tr>
<tr><td><code id="cycleOptim_+3A_opt">opt</code></td>
<td>
<p>A character vector with the cycle models to be tested. The default is 
<code>opt = c("AR1", "AR2", "RAR2")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the chosen cycle model.
</p>

<hr>
<h2 id='dateTsList'>Finds first/last starting/end date in list of time series deepening on the input functions.</h2><span id='topic+dateTsList'></span>

<h3>Description</h3>

<p>Finds first/last starting/end date in list of time series deepening on the input functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateTsList(x, FUN1 = start, FUN2 = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dateTsList_+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="dateTsList_+3A_fun1">FUN1</code></td>
<td>
<p>A function, namely either <code>start</code> or <code>end</code> from <code>stats</code>.</p>
</td></tr>
<tr><td><code id="dateTsList_+3A_fun2">FUN2</code></td>
<td>
<p>A function, namely either <code>max</code> or <code>min</code> from <code>base</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Dconstraint'>Extracts the derivative of the applied restriction function.</h2><span id='topic+Dconstraint'></span>

<h3>Description</h3>

<p>Extracts the derivative of the applied restriction function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dconstraint(par, type = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dconstraint_+3A_par">par</code></td>
<td>
<p>names vector with parameters</p>
</td></tr>
<tr><td><code id="Dconstraint_+3A_type">type</code></td>
<td>
<p>character with constraint type</p>
</td></tr>
</table>

<hr>
<h2 id='extract_ameco_data'>Extracts the relevant 'AMECO' data</h2><span id='topic+extract_ameco_data'></span>

<h3>Description</h3>

<p>Extracts the relevant 'AMECO' data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_ameco_data(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_ameco_data_+3A_df">df</code></td>
<td>
<p>A data frame containing all macro-economic 'AMECO' data.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_indicator_data'>Extracts the relevant 'AMECO' indicator data.</h2><span id='topic+extract_indicator_data'></span>

<h3>Description</h3>

<p>Extracts the relevant 'AMECO' indicator data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_indicator_data(folder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_indicator_data_+3A_folder">folder</code></td>
<td>
<p>A file path with relevant files.</p>
</td></tr>
</table>

<hr>
<h2 id='fetchAmecoData'>Current 'AMECO' data vintage</h2><span id='topic+fetchAmecoData'></span>

<h3>Description</h3>

<p>Fetches the 'AMECO' data for the EC output gap estimation from the current
vintage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetchAmecoData(country = NULL, cubs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetchAmecoData_+3A_country">country</code></td>
<td>
<p>The country name. If left unspecified, data for all countries will be
returned.</p>
</td></tr>
<tr><td><code id="fetchAmecoData_+3A_cubs">cubs</code></td>
<td>
<p>A logical indicating whether the CUBS indicator should be computed if
possible (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the computation of CUBS, the following three seasonally adjusted series are
used: the utilization indicators in the service industry, the building and construction
industry, and capacity utilization in manufacturing/industry.
</p>
<p>The confidence indicator in the service industry is composed of question 1, 2,
and 3 of the monthly service sector survey  ((Q1 + Q2 + Q3)/3). The underlying survey
questions are as follows:
</p>

<ul>
<li><p> Q1 Business situation development over the past 3 months
</p>
</li>
<li><p> Q2 Evolution of the demand over the past 3 months
</p>
</li>
<li><p> Q3 Expectation of the demand over the next 3 months
</p>
</li></ul>

<p>The confidence indicator in the building and construction industry is composed of
question 3 and 4 of the monthly building and construction sector survey
((Q3 and Q4)/2). The underlying survey questions are as follows:
</p>

<ul>
<li><p> Q3 Evolution of your current overall order books
</p>
</li>
<li><p> Q4 Employment expectations over the next 3 months
</p>
</li></ul>

<p>The indicator for capacity utilization in manufacturing/industry is based on question 13
of the quarterly industry sector survey. The underlying survey question is as follows:
</p>

<ul>
<li><p> Q3 Current level of capacity utilization
</p>
</li></ul>



<h3>Value</h3>

<p>A list with multiple time series objects for each country. If <code>country</code> is
specified, a multiple time series object is returned. For each country, the following
series are included:
</p>
<table>
<tr><td><code>popw</code></td>
<td>
<p>Population: 15 to 64 years (unit: 1000 persons, code: NPAN)</p>
</td></tr>
<tr><td><code>ur</code></td>
<td>
<p>Unemployment rate, total; Member States: definition EUROSTAT (unit: Percentage of civilian labor force, code: ZUTN)</p>
</td></tr>
<tr><td><code>etd</code></td>
<td>
<p>Employment, persons: total economy (National accounts) (unit: 1000 persons, code: NETN)</p>
</td></tr>
<tr><td><code>et</code></td>
<td>
<p>Employment, persons: all domestic industries (National accounts) (unit: 1000 persons, code: NETD)</p>
</td></tr>
<tr><td><code>eet</code></td>
<td>
<p>Employees, persons: all domestic industries (National accounts) (unit: 1000 persons, code: NWTD)</p>
</td></tr>
<tr><td><code>vaind</code></td>
<td>
<p>Gross value added at constant prices: manufacturing industry (unit: bn National currency, code: OVGM)</p>
</td></tr>
<tr><td><code>vaserv</code></td>
<td>
<p>Gross value added at constant prices: services (unit: bn National currency, code: OVG5)</p>
</td></tr>
<tr><td><code>vabuil</code></td>
<td>
<p>Gross value added at constant prices: building and construction (unit: bn National currency, code: OVG4)</p>
</td></tr>
<tr><td><code>pconsp</code></td>
<td>
<p>Price deflator private final consumption expenditure (unit: National currency reference year = 100, code: PCPH)</p>
</td></tr>
<tr><td><code>cpih</code></td>
<td>
<p>Harmonised consumer price index (All-items, 2015 = 100, code: ZCPIH)</p>
</td></tr>
<tr><td><code>cpin</code></td>
<td>
<p>National consumer price index (All-items, 2015 = 100, code: ZCPIN)</p>
</td></tr>
<tr><td><code>ngdp</code></td>
<td>
<p>Gross domestic product at current prices (unit: bn National currency, code: UVGD)</p>
</td></tr>
<tr><td><code>gdp</code></td>
<td>
<p>Gross domestic product at constant prices (unit: bn National currency, code: OVGD)</p>
</td></tr>
<tr><td><code>gdpdefl</code></td>
<td>
<p>Price deflator gross domestic product (unit: National currency reference year = 100, code: PVGD)</p>
</td></tr>
<tr><td><code>ahours</code></td>
<td>
<p>Average annual hours worked per person employed (unit: Hours, code: NLHA)</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>Total annual hours worked: total economy (unit: millions, code: NLHT)</p>
</td></tr>
<tr><td><code>wtotal</code></td>
<td>
<p>Compensation of employees: total economy (unit: bn National currency, code: UWCD)</p>
</td></tr>
<tr><td><code>nulc</code></td>
<td>
<p>Nominal unit labour costs: total economy (Ratio of compensation per employee to real GDP per person employed.) (unit: National currency reference year = 100, code: PLCD)</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Net capital stock at constant prices: total economy (unit: bn National currency, code: OKND)</p>
</td></tr>
<tr><td><code>serv</code></td>
<td>
<p>Confidence indicator in the service industry</p>
</td></tr>
<tr><td><code>buil</code></td>
<td>
<p>Confidence indicator in the bulding and construction industry</p>
</td></tr>
<tr><td><code>indu</code></td>
<td>
<p>Capacity utilization in manufacturing/industry</p>
</td></tr>
</table>
<p>Additionally, if <code>cubs = TRUE</code>, the capacity utilization economic sentiment
indicator <code>cubs</code> will be returned.
</p>


<h3>Source</h3>

<p><a href="https://economy-finance.ec.europa.eu/economic-research-and-databases/economic-databases/ameco-database/download-annual-data-set-macro-economic-database-ameco_en">https://economy-finance.ec.europa.eu/economic-research-and-databases/economic-databases/ameco-database/download-annual-data-set-macro-economic-database-ameco_en</a>
</p>
<p><a href="https://economy-finance.ec.europa.eu/economic-forecast-and-surveys/business-and-consumer-surveys_en">https://economy-finance.ec.europa.eu/economic-forecast-and-surveys/business-and-consumer-surveys_en</a>
</p>

<hr>
<h2 id='firstLetterUp'>Capitalizes the first letter of a string.</h2><span id='topic+firstLetterUp'></span>

<h3>Description</h3>

<p>Capitalizes the first letter of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstLetterUp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstLetterUp_+3A_x">x</code></td>
<td>
<p>A character.</p>
</td></tr>
</table>

<hr>
<h2 id='fit'>Fit Method</h2><span id='topic+fit'></span>

<h3>Description</h3>

<p>Defines the fit method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_model">model</code></td>
<td>
<p>Some model.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>Some stuff passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the model object, see documentation of specific methods.
</p>


<h3>See Also</h3>

<p>Other fitting methods: 
<code><a href="#topic+fit.KuttnerModel">fit.KuttnerModel</a>()</code>,
<code><a href="#topic+fit.NAWRUmodel">fit.NAWRUmodel</a>()</code>,
<code><a href="#topic+fit.TFPmodel">fit.TFPmodel</a>()</code>
</p>

<hr>
<h2 id='fit.KuttnerModel'>Maximum likelihood estimation of a <code>KuttnerModel</code></h2><span id='topic+fit.KuttnerModel'></span>

<h3>Description</h3>

<p>Estimates a two-dimensional state-space model and performs filtering and
smoothing to obtain the output gap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KuttnerModel'
fit(
  model,
  parRestr = initializeRestr(model),
  signalToNoise = NULL,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.KuttnerModel_+3A_model">model</code></td>
<td>
<p>An object of class KuttnerModel.</p>
</td></tr>
<tr><td><code id="fit.KuttnerModel_+3A_parrestr">parRestr</code></td>
<td>
<p>A list of matrices containing the parameter restrictions for the cycle,
trend, and the inflation equation. Each matrix contains the lower and upper bound of the
involved parameters. <code>NA</code> implies that no restriction is present. Autoregressive
parameters are automatically restricted to the stationary region unless box constraints
are specified. By default, <code>parRestr</code> is intitialized by the function
<code>initializeRestr(model)</code>.</p>
</td></tr>
<tr><td><code id="fit.KuttnerModel_+3A_signaltonoise">signalToNoise</code></td>
<td>
<p>(Optional) signal to noise ratio.</p>
</td></tr>
<tr><td><code id="fit.KuttnerModel_+3A_control">control</code></td>
<td>
<p>(Optional) A list of control arguments to be passed on to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fit.KuttnerModel_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the methods functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>KuttnerFit</code> containing the following components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The input object of class <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code>SSMfit</code></td>
<td>
<p>The estimation output from the funtcion <code>fitSSM</code> from <code>KFAS</code>.</p>
</td></tr>
<tr><td><code>SSMout</code></td>
<td>
<p>The filtering and smoothing output from the funtcion <code>KFS</code> from
<code>KFAS</code>.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame containing the estimated parameters, including standard
errors, t-statistics, and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A list of model fit criteria (see below).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function. </p>
</td></tr>
</table>
<p>The list component <code>fit</code> contains the following model fit criteria:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood function value.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Hannan-Quinn information criterion.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root mean squared error of the inflation equation.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R squared of the inflation equation.</p>
</td></tr>
<tr><td><code>LjungBox</code></td>
<td>
<p>Ljung-Box test output of the inflation equation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fitting methods: 
<code><a href="#topic+fit.NAWRUmodel">fit.NAWRUmodel</a>()</code>,
<code><a href="#topic+fit.TFPmodel">fit.TFPmodel</a>()</code>,
<code><a href="#topic+fit">fit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data for the Netherlands
data("gap")
country &lt;- "Netherlands"
tsList &lt;- as.list(gap[[country]][, c("cpih", "gdp")])
tsList$infl &lt;- diff(tsList$cpih)
model &lt;- KuttnerModel(tsl = tsList, trend = "RW2", cycleLag = 1, cycle = "AR2", start = 1980)

# estimate Kutter's model
parRestr &lt;- initializeRestr(model = model, type = "hp")

gapKuttner &lt;- fit(model, parRestr, signalToNoise = 1 / 10)

</code></pre>

<hr>
<h2 id='fit.NAWRUmodel'>Estimation of a <code>NAWRUmodel</code></h2><span id='topic+fit.NAWRUmodel'></span>

<h3>Description</h3>

<p>Estimates a two-dimensional state-space model and performs filtering and
smoothing to obtain the NAWRU using either maximum likelihood estimation or bayesian
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NAWRUmodel'
fit(
  model,
  parRestr = initializeRestr(model = model),
  signalToNoise = NULL,
  method = "MLE",
  control = NULL,
  prior = initializePrior(model),
  R = 10000,
  burnin = ceiling(R/10),
  thin = 1,
  HPDIprob = 0.85,
  pointEstimate = "mean",
  MLEfit = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.NAWRUmodel_+3A_model">model</code></td>
<td>
<p>An object of class NAWRUmodel.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_parrestr">parRestr</code></td>
<td>
<p>A list of matrices containing the parameter restrictions for the cycle,
trend, and the Phillip's curve. Each matrix contains the lower and upper bound of the
involved parameters. <code>NA</code> implies that no restriction is present. Autoregressive
parameters are automatically restricted to the stationary region unless box constraints
are specified. By default, <code>parRestr</code> is initialized by the function
<code>initializeRestr(model)</code>. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_signaltonoise">signalToNoise</code></td>
<td>
<p>(Optional) signal to noise ratio. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_method">method</code></td>
<td>
<p>The estimation method. Options are maximum likelihood estimation <code>"MLE"</code>
and bayesian estimation <code>"bayesian"</code>. The default is <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_control">control</code></td>
<td>
<p>(Optional) A list of control arguments to be passed on to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_prior">prior</code></td>
<td>
<p>A list of matrices with parameters for the prior distribution and box
constraints. By default, <code>prior</code> is initialized by <code>initializePrior(model)</code>.
See details. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of MCMC draws. The default is <code>R = 10000</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the burn-in phase of the MCMC chain. The default is
<code>burnin = ceiling(R / 10)</code>. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_thin">thin</code></td>
<td>
<p>An integer specifying the thinning interval between consecutive draws. The
default is <code>thin = 1</code>, implying that no draws are dopped. For <code>thin = 2</code>,
every second draw is dropped and so on. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_hpdiprob">HPDIprob</code></td>
<td>
<p>A numeric in the interval <code>(0,1)</code> specifying the target probability
of the highest posterior density intervals. The default is <code>HPDIprob = 0.9</code>. Only
used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_pointestimate">pointEstimate</code></td>
<td>
<p>Posterior distribution's statistic of central tendency. Possible
options are <code>"mean"</code> and <code>"median"</code>. The default is <code>pointEstimate = "mean"</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_mlefit">MLEfit</code></td>
<td>
<p>(Optional) An object of class <code>NAWRUfit</code> which is used for
initialization. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.NAWRUmodel_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the methods functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list object <code>prior</code> contains three list elements <code>cycle</code>,
<code>trend</code>, and <code>pcInd</code>. Each list element is a <code>4 x n</code> matrix where <code>n</code>
denotes the number of parameters involved in the respective equation. The upper two
elements specify the distribution, the lower two parameters specify box constraints.
<code>NA</code> denotes no constraints. Autoregressive parameters are automatically restricted
to the stationary region unless box constraints are specified. For instance,
<code>prior$cycle[, 1]</code> contains the mean, standard deviation, lower and upper bound for
the first variable, in that respective order.
</p>
<p>The respective prior distributions are defined through their mean and standard
deviation.
</p>
<p>The Gibbs sampling procedure is as follows. For each <code class="reqn">r = 1, ..., R</code>
</p>
<ul>
<li><p> The states are sampled by running the Kalman filter and smoother
conditional on the parameters of the previous step, <code class="reqn">\theta_{r-1}</code>
</p>
</li>
<li><p> Trend equation parameters <code class="reqn">\theta_{trend}</code>: Conditional on the
states <code class="reqn">\alpha_r</code>, a draw <code class="reqn">\theta_{trend,k}</code> is obtained either
by a sequential Gibbs step, a Metropolis Hasting step, or by conjugacy,
depending on the trend model specification.
</p>
</li>
<li><p> Cycle equation parameters <code class="reqn">\theta_{cycle}</code>: Conditional on the
states <code class="reqn">\alpha_r</code>, a draw <code class="reqn">\theta_{cycle,k}</code> is obtained either
by a sequential Gibbs step, a Metropolis Hasting step, or by conjugacy,
depending on the cycle model specification.
</p>
</li>
<li><p> Phillip's curve equation parameters <code class="reqn">\theta_{pcInd}</code>: Conditional on the
states <code class="reqn">\alpha_r</code>, a draw <code class="reqn">\theta_{pcInd,k}</code> is obtained either
by a sequential Gibbs step, a Metropolis Hasting step, a combination
thereof, or by conjugacy, depending on the Phillip's curve equation specification.</p>
</li></ul>



<h3>Value</h3>

<p>For maximum likelihood estimation, an object of class <code>NAWRUfit</code> containing
the following components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The input object of class <code>NAWRUmodel</code>.</p>
</td></tr>
<tr><td><code>SSMfit</code></td>
<td>
<p>The estimation output from the function <code>fitSSM</code> from <code>KFAS</code>.</p>
</td></tr>
<tr><td><code>SSMout</code></td>
<td>
<p>The filtering and smoothing output from the function <code>KFS</code> from
<code>KFAS</code>.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame containing the estimated parameters, including standard
errors, t-statistics, and p-values.</p>
</td></tr>
<tr><td><code>parRestr</code></td>
<td>
<p>A list of matrices containing the enforced parameter constraints.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A list of model fit criteria (see below).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function. </p>
</td></tr>
</table>
<p>The list component <code>fit</code> contains the following model fit criteria:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood function values.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Hannan-Quinn information criterion.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>root mean squared error of the Phillip's curve equation.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R squared of the Phillip's curve equation.</p>
</td></tr>
<tr><td><code>LjungBox</code></td>
<td>
<p>Ljung-Box test output of the Phillip's curve equation.</p>
</td></tr>
<tr><td><code>signal-to-noise</code></td>
<td>
<p>Signal-to-noise ratio.</p>
</td></tr>
</table>
<p>For bayesian estimation, an object of class <code>NAWRUfit</code> containing the following
components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The input object of class <code>NAWRUmodel</code>.</p>
</td></tr>
<tr><td><code>tsl</code></td>
<td>
<p>A list of time series containing the estimated states.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame containing the estimated parameters, including standard
errors, highest posterior density credible sets.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>A list of matrices containing the used prior distributions.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A list of model fit criteria (see below).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function. </p>
</td></tr>
</table>
<p>The list component <code>fit</code> contains the following model fit criteria:
</p>
<table>
<tr><td><code>R2</code></td>
<td>
<p>R squared of the phillips curve equation,</p>
</td></tr>
<tr><td><code>signal-to-noise</code></td>
<td>
<p>Signal-to-noise ratio.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fitting methods: 
<code><a href="#topic+fit.KuttnerModel">fit.KuttnerModel</a>()</code>,
<code><a href="#topic+fit.TFPmodel">fit.TFPmodel</a>()</code>,
<code><a href="#topic+fit">fit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define nawru model for France
data("gap")
country &lt;- "France"
tsList &lt;- amecoData2input(gap[[country]])
model &lt;- NAWRUmodel(tsl = tsList)
# estimate nawru model via MLE
parRestr &lt;- initializeRestr(model = model, type = "hp")

f &lt;- fit(model = model, parRestr = parRestr)

# initialize priors and estimate model via Bayesian methods
prior &lt;- initializePrior(model = model)

f &lt;- fit(model = model, method = "bayesian", prior = prior, R = 5000, thin = 2)

</code></pre>

<hr>
<h2 id='fit.TFPmodel'>Estimation of a <code>TFPmodel</code></h2><span id='topic+fit.TFPmodel'></span>

<h3>Description</h3>

<p>Estimates a two-dimensional state-space model and performs filtering and
smoothing to obtain the TFP trend using either maximum likelihood estimation or
bayesian methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TFPmodel'
fit(
  model,
  parRestr = initializeRestr(model = model),
  signalToNoise = NULL,
  method = "MLE",
  control = NULL,
  prior = initializePrior(model),
  R = 10000,
  burnin = ceiling(R/10),
  thin = 1,
  HPDIprob = 0.85,
  pointEstimate = "mean",
  MLEfit = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.TFPmodel_+3A_model">model</code></td>
<td>
<p>An object of class TFPmodel.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_parrestr">parRestr</code></td>
<td>
<p>A list of matrices containing the parameter restrictions for the cycle,
trend, and the CUBS equation. Each matrix contains the lower and upper bound of the
involved parameters. <code>NA</code> implies that no restriction is present. Autoregressive
parameters are automatically restricted to the stationary region unless box constraints
are specified. By default, <code>parRestr</code> is initialized by the function
<code>initializeRestr(model)</code>. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_signaltonoise">signalToNoise</code></td>
<td>
<p>(Optional) signal to noise ratio. Only used if <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_method">method</code></td>
<td>
<p>The estimation method. Options are maximum likelihood estimation <code>"MLE"</code>
and bayesian estimation <code>"bayesian"</code>. The default is <code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_control">control</code></td>
<td>
<p>(Optional) A list of control arguments to be passed on to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_prior">prior</code></td>
<td>
<p>A list of matrices with parameters for the prior distribution and box
constraints. By default, <code>prior</code> is initialized by <code>initializePrior(model)</code>.
See details. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of MCMC draws. The default is <code>R = 10000</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the burn-in phase of the MCMC chain. The default is
<code>burnin = ceiling(R / 10)</code>. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_thin">thin</code></td>
<td>
<p>An integer specifying the thinning interval between consecutive draws. The
default is <code>thin = 1</code>, implying that no draws are dopped. For <code>thin = 2</code>,
every second draw is dropped and so on. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_hpdiprob">HPDIprob</code></td>
<td>
<p>A numeric in the interval <code>(0,1)</code> specifying the target probability
of the highest posterior density intervals. The default is <code>HPDIprob = 0.9</code>. Only
used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_pointestimate">pointEstimate</code></td>
<td>
<p>Posterior distribution's statistic of central tendency. Possible
options are <code>"mean"</code> and <code>"median"</code>. The default is <code>pointEstimate = "mean"</code>.
Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_mlefit">MLEfit</code></td>
<td>
<p>(Optional) An object of class <code>TFPfit</code> which is used for
initialization. Only used if <code>method = "bayesian"</code>.</p>
</td></tr>
<tr><td><code id="fit.TFPmodel_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the methods functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list object <code>prior</code> contains three list elements <code>cycle</code>,
<code>trend</code>, and <code>cubs</code>. Each list element is a <code>4 x n</code> matrix where <code>n</code>
denotes the number of parameters involved in the respective equation. The upper two
elements specify the distribution, the lower two parameters specify box constraints.
<code>NA</code> denotes no constraints. Autoregressive parameters are automatically restricted
to the stationary region unless box constraints are specified. For instance,
<code>prior$cycle[, 1]</code> contains the mean, standard deviation, lower and upper bound for
the first variable, in that respective order.
</p>
<p>The respective prior distributions are defined through their mean and standard
deviation.
</p>
<p>The Gibbs sampling procedure is as follows. For each <code class="reqn">r = 1, ..., R</code>
</p>
<ul>
<li><p> The states are sampled by running the Kalman filter and smoother
conditional on the parameters of the previous step, <code class="reqn">\theta_{r-1}</code>
</p>
</li>
<li><p> Trend equation parameters <code class="reqn">\theta_{trend}</code>: Conditional on the
states <code class="reqn">\alpha_r</code>, a draw <code class="reqn">\theta_{trend,k}</code> is obtained either
by a sequential Gibbs step, a Metropolis Hasting step, or by conjugacy,
depending on the trend model specification.
</p>
</li>
<li><p> Cycle equation parameters <code class="reqn">\theta_{cycle}</code>: Conditional on the
states <code class="reqn">\alpha_r</code>, a draw <code class="reqn">\theta_{cycle,k}</code> is obtained either
by a sequential Gibbs step, a Metropolis Hasting step, or by conjugacy,
depending on the cycle model specification.
</p>
</li>
<li><p> CUBS equation parameters <code class="reqn">\theta_{cubs}</code>: Conditional on the
states <code class="reqn">\alpha_r</code>, a draw <code class="reqn">\theta_{cubs,k}</code> is obtained either
by a sequential Gibbs step, a Metropolis Hasting step, a combination
thereof, or by conjugacy, depending on the CUBS equation specification.
</p>
</li></ul>



<h3>Value</h3>

<p>For maximum likelihood estimation, an object of class <code>TFPit</code> containing
the following components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The input object of class <code>TFPmodel</code>.</p>
</td></tr>
<tr><td><code>SSMfit</code></td>
<td>
<p>The estimation output from the funtcion <code>fitSSM</code> from <code>KFAS</code>.</p>
</td></tr>
<tr><td><code>SSMout</code></td>
<td>
<p>The filtering and smoothing output from the funtcion <code>KFS</code> from
<code>KFAS</code>.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame containing the estimated parameters, including standard
errors, t-statistic, and p-values.</p>
</td></tr>
<tr><td><code>parRestr</code></td>
<td>
<p>A list of matrices containing the enforced parameter constraints.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A list of model fit criteria (see below).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function. </p>
</td></tr>
</table>
<p>The list component <code>fit</code> contains the following model fit criteria:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood function values.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Hannan-Quinn information criterion.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>root mean squared error of the CUBS equation.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R squared of the CUBS equation.</p>
</td></tr>
<tr><td><code>LjungBox</code></td>
<td>
<p>Ljung-Box test output of the CUBS equation.</p>
</td></tr>
<tr><td><code>signal-to-noise</code></td>
<td>
<p>Signal-to-noise ratio.</p>
</td></tr>
</table>
<p>For bayesian estimation, an object of class <code>TFPfit</code> containing the following components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The input object of class <code>TFPmodel</code>.</p>
</td></tr>
<tr><td><code>tsl</code></td>
<td>
<p>A list of time series containing the estimated states.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame containing the estimated parameters, including standard
errors, highest posterior density credible sets.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>A list of matrices containing the used prior distributions.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A list of model fit criteria (see below).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function. </p>
</td></tr>
</table>
<p>The list component <code>fit</code> contains the following model fit criteria:
</p>
<table>
<tr><td><code>R2</code></td>
<td>
<p>R squared of the CUBS equation.</p>
</td></tr>
<tr><td><code>signal-to-noise</code></td>
<td>
<p>Signal-to-noise ratio.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fitting methods: 
<code><a href="#topic+fit.KuttnerModel">fit.KuttnerModel</a>()</code>,
<code><a href="#topic+fit.NAWRUmodel">fit.NAWRUmodel</a>()</code>,
<code><a href="#topic+fit">fit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data for Italy
data("gap")
country &lt;- "Italy"
tsList &lt;- amecoData2input(gap[[country]])
# define tfp model
model &lt;- TFPmodel(tsl = tsList, cycle = "RAR2")
# initialize parameter restrictions and estimate model
parRestr &lt;- initializeRestr(model = model, type = "hp")

f &lt;- fit(model = model, parRestr = parRestr)

# Bayesian estimation
prior &lt;- initializePrior(model = model)

f &lt;- fit(model = model, method = "bayesian", prior = prior, R = 5000, thin = 2)

</code></pre>

<hr>
<h2 id='FUNcov'>Computes mean and variance of the part of the posterior distribution that relies on
starting values. It then computes the density of the first p observations of Y.</h2><span id='topic+FUNcov'></span>

<h3>Description</h3>

<p>Computes mean and variance of the part of the posterior distribution that relies on
starting values. It then computes the density of the first p observations of Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FUNcov(Xcubs, Xc, Y, mu, phi, beta, sigma, phiC, sigmaC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FUNcov_+3A_xcubs">Xcubs</code></td>
<td>
<p>matrix containing lags of cubs.</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_xc">Xc</code></td>
<td>
<p>matrix containing the contemporaneous cycle and lags thereof..</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_y">Y</code></td>
<td>
<p>a <code>Tn x 1</code> vector.</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_mu">mu</code></td>
<td>
<p>constant parameter.</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_phi">phi</code></td>
<td>
<p>cubs lag coeefficients.</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_beta">beta</code></td>
<td>
<p>cycle coefficients.</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_sigma">sigma</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_phic">phiC</code></td>
<td>
<p>cycle process parameter vector.</p>
</td></tr>
<tr><td><code id="FUNcov_+3A_sigmac">sigmaC</code></td>
<td>
<p>cycle innovation variance</p>
</td></tr>
</table>

<hr>
<h2 id='gap'>gap data set</h2><span id='topic+gap'></span>

<h3>Description</h3>

<p>A dataset containing economic data on various countries from the 'AMECO' 2018 autumn vintage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gap
</code></pre>


<h3>Format</h3>

<p>A list object with 53 country time series objects. Each time series object contains 14 variables:
</p>

<dl>
<dt>popw</dt><dd><p>Population: 15 to 64 years (unit: 1000 persons, code: NPAN)</p>
</dd>
<dt>ur</dt><dd><p>Unemployment rate, total; Member States: definition EUROSTAT (unit: Percentage of civilian labor force, code: ZUTN)</p>
</dd>
<dt>etd</dt><dd><p>Employment, persons: total economy (National accounts) (unit: 1000 persons, code: NETN)</p>
</dd>
<dt>et</dt><dd><p>Employment, persons: all domestic industries (National accounts) (unit: 1000 persons, code: NETD)</p>
</dd>
<dt>eet</dt><dd><p>Employees, persons: all domestic industries (National accounts) (unit: 1000 persons, code: NWTD)</p>
</dd>
<dt>vaind</dt><dd><p>Gross value added at 2010 prices: manufacturing industry (unit: bn National currency, code: OVGM)</p>
</dd>
<dt>vaserv</dt><dd><p>Gross value added at 2010 prices: services (unit: bn National currency, code: OVG5)</p>
</dd>
<dt>vabuil</dt><dd><p>Gross value added at 2010 prices: building and construction (unit: bn National currency, code: OVG4)</p>
</dd>
<dt>pconsp</dt><dd><p>Price deflator private final consumption expenditure (unit: National currency 2010 = 100, code: PCPH)</p>
</dd>
<dt>cpih</dt><dd><p>Harmonised consumer price index (All-items, 2015 = 100, code: ZCPIH)</p>
</dd>
<dt>cpin</dt><dd><p>National consumer price index (All-items, 2015 = 100, code: ZCPIN)</p>
</dd>
<dt>ngdp</dt><dd><p>Gross domestic product at current prices (unit: bn National currency, code: UVGD)</p>
</dd>
<dt>gdp</dt><dd><p>Gross domestic product at 2010 reference levels (unit: bn National currency, code: OVGD)</p>
</dd>
<dt>gdpdefl</dt><dd><p>Price deflator gross domestic product (unit: National currency 2010 = 100, code: PVGD)</p>
</dd>
<dt>ahours</dt><dd><p>Average annual hours worked per person employed (unit: Hours, code: NLHA)</p>
</dd>
<dt>l</dt><dd><p>Total annual hours worked: total economy (unit: millions, code: NLHT)</p>
</dd>
<dt>wtotal</dt><dd><p>Compensation of employees: total economy (unit: bn National currency, code: UWCD)</p>
</dd>
<dt>nulc</dt><dd><p>Nominal unit labour costs: total economy (Ratio of compensation per employee to real GDP per person employed.) (unit: National currency 2010 = 100, code: PLCD)</p>
</dd>
<dt>k</dt><dd><p>Net capital stock at 2010 prices: total economy (unit: bn National currency, code: OKND)</p>
</dd>
<dt>serv</dt><dd><p>Confidence indicator in the service industry</p>
</dd>
<dt>buil</dt><dd><p>Confidence indicator in the bulding and construction industry</p>
</dd>
<dt>indu</dt><dd><p>Capacity utilization in manufacturing/industry</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://economy-finance.ec.europa.eu/economic-research-and-databases/economic-databases/ameco-database_en">https://economy-finance.ec.europa.eu/economic-research-and-databases/economic-databases/ameco-database_en</a>
</p>

<hr>
<h2 id='gapHP'>HP-filter output gap</h2><span id='topic+gapHP'></span>

<h3>Description</h3>

<p>Computes a HP filtered output gap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapHP(x, lambda = NULL, end = NULL, start = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapHP_+3A_x">x</code></td>
<td>
<p>A time series object containing gdp.</p>
</td></tr>
<tr><td><code id="gapHP_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing parameter for the application of the HP filter. If not supplied,
<code>lambda = 6.25</code> for yearly data, <code>lambda = 1600</code> for quarterly data, and <code>lambda = 129600</code>
for monthly data.</p>
</td></tr>
<tr><td><code id="gapHP_+3A_end">end</code></td>
<td>
<p>(optional) A two element vector containing a year and a period specifying the end point for the
filter application.</p>
</td></tr>
<tr><td><code id="gapHP_+3A_start">start</code></td>
<td>
<p>(optional) A two element vector containing a year and a period specifying the start point for the
filter application.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>gap</code>, which is a list containing the two elements <code>potential</code> and
<code>gap</code> and additionally the original time series.
</p>

<hr>
<h2 id='gapProd'>Production function output gap</h2><span id='topic+gapProd'></span>

<h3>Description</h3>

<p>Computes potential output and the output gap based on a production function
methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapProd(
  tsl,
  NAWRUfit,
  TFPfit,
  alpha = 0.65,
  start = NULL,
  end = NULL,
  lambda = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapProd_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="gapProd_+3A_nawrufit">NAWRUfit</code></td>
<td>
<p>An object of class <code>NAWRUfit</code> obtained via the function <code>fit</code>.</p>
</td></tr>
<tr><td><code id="gapProd_+3A_tfpfit">TFPfit</code></td>
<td>
<p>An object of class <code>TFPfit</code> obtained via the function <code>fit</code>.</p>
</td></tr>
<tr><td><code id="gapProd_+3A_alpha">alpha</code></td>
<td>
<p>A scalar between zero and one depicting the labor share. The default is
<code>alpha = 0.65</code>.</p>
</td></tr>
<tr><td><code id="gapProd_+3A_start">start</code></td>
<td>
<p>(optional) A two element vector containing a year and a period specifying
the start point for the estimation.</p>
</td></tr>
<tr><td><code id="gapProd_+3A_end">end</code></td>
<td>
<p>(optional) A two element vector containing a year and a period specifying the
end point for the estimation.</p>
</td></tr>
<tr><td><code id="gapProd_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing parameter for the application of the HP filter (see details).
If not supplied, <code>lambda = 6.25</code> for yearly data, <code>lambda = 1600</code> for quarterly
data, and <code>lambda = 129600</code> for monthly data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of time series <code>tsl</code> needs to have the following components:
</p>

<dl>
<dt>lfnd</dt><dd><p>Labor force non-domestic (unit: 1000 persons). (Set to zero if left unspecified).</p>
</dd>
<dt>parts</dt><dd><p>Participation rate.</p>
</dd>
<dt>ahours</dt><dd><p>Average hours worked (unit: hours).</p>
</dd>
<dt>gdp</dt><dd><p>Gross domestic product at constant prices (unit: bn National currency, code: OVGD).</p>
</dd>
<dt>k</dt><dd><p>Net capital stock at constant prices: total economy (unit: bn National currency, code: OKND).</p>
</dd>
<dt>popw</dt><dd><p>Population: 15 to 64 years (unit: 1000 persons, code: NPAN).</p>
</dd>
</dl>

<p>The trend of the list components <code>parts, ahours and lfnd</code> (if available)
is computed using the Hodrick-Prescott filter with the smoothing constant
<code>lambda</code>, unless the supplied time series list <code>tsl</code> contains their trend 
(for instance, denoted by <code>partsTrend</code>).
</p>


<h3>Value</h3>

<p>Object of class <code>gap</code>, which is a list with the following components:
</p>
<table>
<tr><td><code>tsl</code></td>
<td>
<p>List of time series including potential output <code>potential</code>, the
output gap <code>gap</code>, all HP-filtered trend series, and all original series.</p>
</td></tr>
<tr><td><code>NAWRUfit</code></td>
<td>
<p>Provided <code>NAWRUfit</code> object.</p>
</td></tr>
<tr><td><code>TFPfit</code></td>
<td>
<p>Provided <code>TFPfit</code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># compute the output gap given the previously obtained nawru and trend tfp
data("gap")
country &lt;- "Belgium"
tsList &lt;- amecoData2input(gap[[country]])
modelNAWRU &lt;- NAWRUmodel(tsl = tsList)
modelTFP &lt;- TFPmodel(tsl = tsList, cycle = "RAR2")


fittedNAWRU &lt;- fit(model = modelNAWRU)
fittedTFP &lt;- fit(model = modelTFP)

gapProd(tsl = tsList, NAWRUfit = fittedNAWRU, TFPfit = fittedTFP)

</code></pre>

<hr>
<h2 id='gewekeTest'>Conducts a Geweke test for convergence of the draws.</h2><span id='topic+gewekeTest'></span>

<h3>Description</h3>

<p>Conducts a Geweke test for convergence of the draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gewekeTest(x, frac1 = 0.1, frac2 = 0.5, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gewekeTest_+3A_x">x</code></td>
<td>
<p>A <code>R x n</code> matrix with <code>R</code> draws of <code>n</code> variables.</p>
</td></tr>
<tr><td><code id="gewekeTest_+3A_frac1">frac1</code></td>
<td>
<p>The probability mass of the first interval, a scalar between zero and one.</p>
</td></tr>
<tr><td><code id="gewekeTest_+3A_frac2">frac2</code></td>
<td>
<p>The probability mass of the second interval, a scalar between zero and one.</p>
</td></tr>
<tr><td><code id="gewekeTest_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used to compute the test decision, a scalar between
zero and one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the H0 of convergence, the test statistic is standard normally distributed.
</p>
<p>Naturally, <code>frac1 + frac2</code> is between zero and one.
</p>


<h3>Value</h3>

<p>A list with the following items
</p>

<dl>
<dt>h</dt><dd><p>Test decision.</p>
</dd>
<dt>CD</dt><dd><p>Convergence Diagnostic (test statistic)</p>
</dd>
<dt>pvalue</dt><dd><p>The p-value.</p>
</dd>
<dt>alpha</dt><dd><p>The applied signifcicance level.</p>
</dd>
<dt>frac1</dt><dd><p>The fraction of data contained in the first interval.</p>
</dd>
<dt>frac2</dt><dd><p>The fraction of data contained in the second interval.</p>
</dd>
</dl>


<hr>
<h2 id='growth'>Growth rate</h2><span id='topic+growth'></span>

<h3>Description</h3>

<p>Computes growth rates for time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth(ts, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_+3A_ts">ts</code></td>
<td>
<p>A time series object.</p>
</td></tr>
<tr><td><code id="growth_+3A_k">k</code></td>
<td>
<p>An integer specifying the lag size in the growth computation. The default is
<code>k = 1</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='helper_fit_comparison'>model selection fit comparison helper function</h2><span id='topic+helper_fit_comparison'></span>

<h3>Description</h3>

<p>Defines and fits models given the input parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_fit_comparison(fit, E1name, E1Trendname, E1trans = identity, fitBayes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_fit_comparison_+3A_fit">fit</code></td>
<td>
<p>Fitted object.</p>
</td></tr>
<tr><td><code id="helper_fit_comparison_+3A_e1name">E1name</code></td>
<td>
<p>Name of first observation equation.</p>
</td></tr>
<tr><td><code id="helper_fit_comparison_+3A_e1trendname">E1Trendname</code></td>
<td>
<p>Name of trend of first observation equation.</p>
</td></tr>
<tr><td><code id="helper_fit_comparison_+3A_e1trans">E1trans</code></td>
<td>
<p>Transformation function for the first observation equation..</p>
</td></tr>
<tr><td><code id="helper_fit_comparison_+3A_fitbayes">fitBayes</code></td>
<td>
<p>Fitted Bayesian object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with information criteria, other goodness-of-fit measures, 
convergence status, trend volatility measures.
</p>

<hr>
<h2 id='helper_model_comparison'>model comparison helper function</h2><span id='topic+helper_model_comparison'></span>

<h3>Description</h3>

<p>Gets model attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_model_comparison(models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_model_comparison_+3A_models">models</code></td>
<td>
<p>A list of models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with model attributes
</p>

<hr>
<h2 id='helper_model_fit'>model selection helper function</h2><span id='topic+helper_model_fit'></span>

<h3>Description</h3>

<p>Defines and fits models given the input parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_model_fit(FUNmodel, FUNfit, tsl, comb, poss, method, type, q, modelName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_model_fit_+3A_funmodel">FUNmodel</code></td>
<td>
<p>The model fitting function.</p>
</td></tr>
<tr><td><code id="helper_model_fit_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="helper_model_fit_+3A_comb">comb</code></td>
<td>
<p>A nested list with one model specification per list entry.</p>
</td></tr>
<tr><td><code id="helper_model_fit_+3A_poss">poss</code></td>
<td>
<p>A list with the characteristics of possible models (see <code>autoGapProd)</code></p>
</td></tr>
<tr><td><code id="helper_model_fit_+3A_method">method</code></td>
<td>
<p>The estimation method. Options are maximum likelihood estimation <code>"MLE"</code>
and bayesian estimation <code>"bayesian"</code>. If <code>method = c("MLE", "bayesian")</code> the 
NAWRU is fitted by MLE and the TFP trend by Bayesian methods. The default is 
<code>method = "MLE"</code>.</p>
</td></tr>
<tr><td><code id="helper_model_fit_+3A_type">type</code></td>
<td>
<p>The variance restriction type. Possible options are <code>"basic"</code>,
<code>"hp"</code>, see <code>initializeRestr</code>. The default is <code>type = "hp"</code>.</p>
</td></tr>
<tr><td><code id="helper_model_fit_+3A_q">q</code></td>
<td>
<p>Quantile for the Inverse Gamma distribution (only used if <code>type = "hp"</code>), 
see <code>initializeRestr</code>. The default is <code>q = 0.01</code>.</p>
</td></tr>
<tr><td><code id="helper_model_fit_+3A_modelname">modelName</code></td>
<td>
<p>Name of the model, i.e., NAWRU or TFP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list with the models and fitted objects.
</p>

<hr>
<h2 id='HPDinterval'>Computes the approximate highest posterior density interval (HPDI).</h2><span id='topic+HPDinterval'></span>

<h3>Description</h3>

<p>Computes the approximate highest posterior density interval (HPDI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDinterval(x, prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPDinterval_+3A_x">x</code></td>
<td>
<p>A <code>R x n</code> matrix with <code>R</code> draws of <code>n</code> variables.</p>
</td></tr>
<tr><td><code id="HPDinterval_+3A_prob">prob</code></td>
<td>
<p>The probability mass of the interval, a scalar between zero and one.</p>
</td></tr>
</table>

<hr>
<h2 id='hpfilter'>HP filter</h2><span id='topic+hpfilter'></span>

<h3>Description</h3>

<p>Applies the Hodrick Prescott Filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpfilter(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpfilter_+3A_x">x</code></td>
<td>
<p>A univariate time series object.</p>
</td></tr>
<tr><td><code id="hpfilter_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A univariate time series object containing the trend of the original time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get data for France
data("gap")
country &lt;- "France"
tsList &lt;- amecoData2input(gap[[country]], alpha = 0.65)
hp &lt;- hpfilter(x = tsList$gdp, lambda = 6.25)
</code></pre>

<hr>
<h2 id='indicator'>Indicators fo CUBS</h2><span id='topic+indicator'></span>

<h3>Description</h3>

<p>A dataset containing the service sector confidence indicator, the construction sector confidence indicator and the capacity utilization in manufacturing/industry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indicator
</code></pre>


<h3>Format</h3>

<p>A list with 53 nested country lists with time series objects. Each country list contains 3 time series variables:
</p>

<dl>
<dt>serv</dt><dd><p>Confidence indicator in the service industry.</p>
</dd>
<dt>buil</dt><dd><p>Confidence indicator in the bulding and construction industry.</p>
</dd>
<dt>indu</dt><dd><p>Capacity utilization in manufacturing/industry.</p>
</dd>
</dl>



<h3>Details</h3>

<p>A dataset containing the seasonally adjusted utilization indicators in the service industry, the building and construction industry,
and capacity utilization in manufacturing/industry for all EU countries and some neighboring countries at different frequencies.
</p>
<p>The confidence indicator in the service industry is composed of question 1, 2, and 3 of the monthly service sector survey  ((Q1 + Q2 + Q3)/3).
The underlying survey questions are as follows:
</p>

<ul>
<li><p> Q1 Business situation development over the past 3 months
</p>
</li>
<li><p> Q2 Evolution of the demand over the past 3 months
</p>
</li>
<li><p> Q3 Expectation of the demand over the next 3 months
</p>
</li></ul>

<p>The confidence indicator in the building and construction industry is composed of question 3 and 4 of the monthly building and construction sector survey  ((Q3 and Q4)/2).
The underlying survey questions are as follows:
</p>

<ul>
<li><p> Q3 Evolution of your current overall order books
</p>
</li>
<li><p> Q4 Employment expectations over the next 3 months
</p>
</li></ul>

<p>The indicator for capacity utilization in manufacturing/industry is based on question 13 of the quarterly industry sector survey.
The underlying survey question is as follows:
</p>

<ul>
<li><p> Q3 Current level of capacity utilization
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://economy-finance.ec.europa.eu/economic-forecast-and-surveys/business-and-consumer-surveys_en">https://economy-finance.ec.europa.eu/economic-forecast-and-surveys/business-and-consumer-surveys_en</a>
</p>

<hr>
<h2 id='inference'>Computes standard errors, t-statistics, and p-values for the estimated state space parameters
using the delta method.</h2><span id='topic+inference'></span>

<h3>Description</h3>

<p>Computes standard errors, t-statistics, and p-values for the estimated state space parameters
using the delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inference(parOptim, hessian, loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inference_+3A_paroptim">parOptim</code></td>
<td>
<p>The vector of optimized parameters, without transformations.</p>
</td></tr>
<tr><td><code id="inference_+3A_hessian">hessian</code></td>
<td>
<p>The hessian from the optimization.</p>
</td></tr>
<tr><td><code id="inference_+3A_loc">loc</code></td>
<td>
<p>A <code>3 x n</code> array where <code>n</code> is the number of optimized parameters. The array
contains information on the estimated parameters's name (<code>loc[1, ]</code>), its location
(<code>loc[2, ]</code>) and possible parameter constraints (<code>loc[3, ]</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='initializeExo'>Initialization of exogenous variables</h2><span id='topic+initializeExo'></span>

<h3>Description</h3>

<p>Initializes the transformations applied to exogenous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializeExo(varNames, D = NULL, L = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initializeExo_+3A_varnames">varNames</code></td>
<td>
<p>A <code>(k x 1)</code> character vector containing the names of the exogenous
variables.</p>
</td></tr>
<tr><td><code id="initializeExo_+3A_d">D</code></td>
<td>
<p>A <code>(n x k)</code> matrix containing the difference transformations, see details.</p>
</td></tr>
<tr><td><code id="initializeExo_+3A_l">L</code></td>
<td>
<p>A <code>(n x k)</code> matrix containing the lag transformations, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the matrices <code>D</code> and <code>L</code>, the rows denote different transformations 
to each of the variables in the columns. <code>NA</code> indicates no transformation.
</p>


<h3>Value</h3>

<p>An array of size <code>(n, k, 2)</code>. The <code>[, , 1]</code> specifies
the difference order and <code>[, , 2]</code> the lag order.
</p>

<hr>
<h2 id='initializePrior'>Initialization of prior distributions</h2><span id='topic+initializePrior'></span>

<h3>Description</h3>

<p>Initializes the prior distributions for a model of class <code>TFPmodel</code> or
<code>NAWRUmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializePrior(model, MLE = !is.null(MLEfit), MLEfit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initializePrior_+3A_model">model</code></td>
<td>
<p>An object of class <code>TFPmodel</code> or <code>NAWRUmodel</code>.</p>
</td></tr>
<tr><td><code id="initializePrior_+3A_mle">MLE</code></td>
<td>
<p>(Optional) A logical indicating whether the MLE estimates should be used for
the initialization. The default is <code>MLE = FALSE</code> if <code>MLEfit</code> is not provided
and vice versa.</p>
</td></tr>
<tr><td><code id="initializePrior_+3A_mlefit">MLEfit</code></td>
<td>
<p>(Optional) An object of class <code>TFPfit</code> or <code>NAWRUfit</code> which is
used if <code>MLE = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three matrices with parameters for the prior distribution and box
constraints. Each list item refers to an equation, namely the <code>cycle</code>, <code>trend</code>,
and second observation equation. Each list element is a <code>4 x n</code> matrix where <code>n</code>
denotes the number of parameters involved in the respective equation. The upper two
elements specify the distribution, the lower two parameters specify box constraints.
<code>NA</code> denotes no constraints. Autoregressive parameters are automatically restricted
to the stationary region unless box constraints are specified. The respective prior
distributions are defined through their mean and standard deviation. For instance,
<code>prior$cycle[, 1]</code> contains the mean, standard deviation, lower and upper bound for
the first variable, in that respective order.
</p>

<hr>
<h2 id='initializeRestr'>Initialization of parameter restrictions</h2><span id='topic+initializeRestr'></span>

<h3>Description</h3>

<p>Initializes parameter restrictions for objects of class <code>NAWRUmodel</code>,
<code>TFPmodel</code>, or <code>KuttnerModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializeRestr(model, type = "basic", lambda = NULL, q = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initializeRestr_+3A_model">model</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code>, <code>TFPmodel</code>, or <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code id="initializeRestr_+3A_type">type</code></td>
<td>
<p>The variance restriction type. Possible options are <code>"basic"</code>,
<code>"hp"</code>, see details. The default is <code>type = "basic"</code>.</p>
</td></tr>
<tr><td><code id="initializeRestr_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing constant for the HP-filter if <code>type = "hp"</code>.</p>
</td></tr>
<tr><td><code id="initializeRestr_+3A_q">q</code></td>
<td>
<p>Quantile for the Inverse Gamma distribution (only used if <code>type = "hp"</code>). The 
default is <code>q = 0.01</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type = "hp"</code>, the HP filter is applied to the appropriately differences 
first observation series to obtain its trend and cycle. Subsequently, the specified trend 
and cycle models are fitted to obtain its innovation variance. Moreover, the second 
observation series (according to its specification) is fitted to obtain its innovation 
variance. Lastly, the obtained innovations variances are used to get lower and upper 
bounds. To that end, the <code>q</code> and <code>1-q</code> quantiles of the inverse gamma 
distribution are used, with mean and standard deviation set to the estimated variances.
</p>


<h3>Value</h3>

<p>A list of three matrices containing the parameter restrictions for the cycle,
trend, and the second observation equation. Each matrix contains the lower and upper
bound of the involved parameters. <code>NA</code> implies that no
restriction is present.
</p>

<hr>
<h2 id='is.gap'><code>gap</code> object check</h2><span id='topic+is.gap'></span>

<h3>Description</h3>

<p>Tests whether the input object is a valid object of class <code>gap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.gap(object, return.logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.gap_+3A_object">object</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
<tr><td><code id="is.gap_+3A_return.logical">return.logical</code></td>
<td>
<p>If <code>return.logical = FALSE</code> (default), an error message is printed
if the object is not of class <code>gap</code>. If <code>return.logical = TRUE</code>, a logical
value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value or nothing, depending on the value of <code>return.logical</code>.
</p>

<hr>
<h2 id='is.KuttnerFit'><code>KuttnerFit</code> object check</h2><span id='topic+is.KuttnerFit'></span>

<h3>Description</h3>

<p>Tests whether the input object is a valid object of class <code>KuttnerFit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.KuttnerFit(object, return.logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.KuttnerFit_+3A_object">object</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
<tr><td><code id="is.KuttnerFit_+3A_return.logical">return.logical</code></td>
<td>
<p>If <code>return.logical = FALSE</code> (default), an error message is printed
if the object is not of class <code>KuttnerFit</code>. If <code>return.logical = TRUE</code>, a logical
value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value or nothing, depending on the value of <code>return.logical</code>.
</p>

<hr>
<h2 id='is.KuttnerModel'><code>KuttnerModel</code> object check</h2><span id='topic+is.KuttnerModel'></span>

<h3>Description</h3>

<p>Tests whether the input object is a valid object of class <code>KuttnerModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.KuttnerModel(object, return.logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.KuttnerModel_+3A_object">object</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
<tr><td><code id="is.KuttnerModel_+3A_return.logical">return.logical</code></td>
<td>
<p>If <code>return.logical = FALSE</code> (default), an error message is printed
if the object is not of class <code>KuttnerModel</code>. If <code>return.logical = TRUE</code>, a logical
value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value or nothing, depending on the value of <code>return.logical</code>.
</p>

<hr>
<h2 id='is.NAWRUfit'><code>NAWRUfit</code> object check</h2><span id='topic+is.NAWRUfit'></span>

<h3>Description</h3>

<p>Tests whether the input object is a valid object of class <code>NAWRUfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.NAWRUfit(object, return.logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.NAWRUfit_+3A_object">object</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
<tr><td><code id="is.NAWRUfit_+3A_return.logical">return.logical</code></td>
<td>
<p>If <code>return.logical = FALSE</code> (default), an error message is printed
if the object is not of class <code>NAWRUfit</code>. If <code>return.logical = TRUE</code>, a logical
value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value or nothing, depending on the value of <code>return.logical</code>.
</p>

<hr>
<h2 id='is.NAWRUmodel'><code>NAWRUodel</code> object check</h2><span id='topic+is.NAWRUmodel'></span>

<h3>Description</h3>

<p>Tests whether the input object is a valid object of class <code>NAWRUmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.NAWRUmodel(object, return.logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.NAWRUmodel_+3A_object">object</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
<tr><td><code id="is.NAWRUmodel_+3A_return.logical">return.logical</code></td>
<td>
<p>If <code>return.logical = FALSE</code> (default), an error message is printed
if the object is not of class <code>NAWRUmodel</code>. If <code>return.logical = TRUE</code>, a logical
value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value or nothing, depending on the value of <code>return.logical</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data for France
data("gap")
tsList &lt;- amecoData2input(gap$France, alpha = 0.65)

# Traditional phillips curve
model &lt;- NAWRUmodel(tsl = tsList, trend = "RW2", cycle = "AR2", type = "NKP", cycleLag = 0:1)
is.NAWRUmodel(model, return.logical = TRUE)
attr(model, "phillips curve")$cycleLag &lt;- 0
is.NAWRUmodel(model, return.logical = TRUE)
</code></pre>

<hr>
<h2 id='is.TFPfit'><code>TFPfit</code> object check</h2><span id='topic+is.TFPfit'></span>

<h3>Description</h3>

<p>Tests whether the input object is a valid object of class <code>TFPfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.TFPfit(object, return.logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.TFPfit_+3A_object">object</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
<tr><td><code id="is.TFPfit_+3A_return.logical">return.logical</code></td>
<td>
<p>If <code>return.logical = FALSE</code> (default), an error message is printed
if the object is not of class <code>TFPfit</code>. If <code>return.logical = TRUE</code>, a logical
value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value or nothing, depending on the value of <code>return.logical</code>.
</p>

<hr>
<h2 id='is.TFPmodel'><code>TFPmodel</code> object check</h2><span id='topic+is.TFPmodel'></span>

<h3>Description</h3>

<p>Tests whether the input object is a valid object of class <code>TFPmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.TFPmodel(object, return.logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.TFPmodel_+3A_object">object</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
<tr><td><code id="is.TFPmodel_+3A_return.logical">return.logical</code></td>
<td>
<p>If <code>return.logical = FALSE</code> (default), an error message is printed
if the object is not of class <code>TFPmodel</code>. If <code>return.logical = TRUE</code>, a logical
value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value or nothing, depending on the value of <code>return.logical</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data for Germany
data("gap")
data("indicator")
country &lt;- "Germany"
tsList &lt;- amecoData2input(gap[[country]], alpha = 0.65)

# compute cubs indicator
namesCubs &lt;- c("indu", "serv", "buil")
namesVACubs &lt;- paste0("va", namesCubs)
tscubs &lt;- cubs(
  tsCU = gap[[country]][, namesCubs],
  tsVA = gap[[country]][, namesVACubs]
)
tsList &lt;- c(tsList, tscubs)

# define tfp model
model &lt;- TFPmodel(
  tsl = tsList, trend = "DT", cycle = "RAR2",
  cycleLag = 2, cubsErrorARMA = c(1, 0)
)
is.TFPmodel(model, return.logical = TRUE)
attr(model, "cubs")$cycleLag &lt;- 1
is.TFPmodel(model, return.logical = TRUE)
</code></pre>

<hr>
<h2 id='KuttnerModel'>Kuttner model</h2><span id='topic+KuttnerModel'></span>

<h3>Description</h3>

<p>Creates a state space object object of class <code>KuttnerModel</code> which can be 
fitted using <code>fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KuttnerModel(
  tsl,
  cycle = "AR2",
  cycleLag = 1,
  trend = "RW1",
  inflErrorARMA = c(0, 3),
  start = NULL,
  end = NULL,
  anchor = NULL,
  anchor.h = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KuttnerModel_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an AR(2) process. The default is
<code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A non-negative integer specifying the maximum cycle lag that is included
in the inflation equation. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "RW1"</code>.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_inflerrorarma">inflErrorARMA</code></td>
<td>
<p>A <code>2 x 1</code> vector with non-negative integers specifying the AR
and MA degree of the error term in the inflation equation. The default is
<code>inflErrorARMA = c(0, 3)</code>, see details.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_start">start</code></td>
<td>
<p>(Optional) Start vector for the estimation, e.g. <code>c(1980, 1)</code>.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_end">end</code></td>
<td>
<p>(Optional) End vector for the estimation, e.g. <code>c(2020, 1)</code>.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_anchor">anchor</code></td>
<td>
<p>(Optional) Anchor value for the logarithm of trend gdp.</p>
</td></tr>
<tr><td><code id="KuttnerModel_+3A_anchor.h">anchor.h</code></td>
<td>
<p>(Optional) Anchor horizon in the frequency of the given time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of time series <code>tsl</code> needs to have the following components:
</p>

<dl>
<dt>gdp</dt><dd><p>Real gross domestic product.</p>
</dd>
<dt>infl</dt><dd><p>Inflation.</p>
</dd>
</dl>

<p>A <code>cycleLag</code> equal to <code>0</code> implies that only the contemporaneous cycle
is included in the inflation equation.  A <code>cycleLag</code> equal to <code>0:1</code> implies that
the contemporaneous as well as the lagged cycle are included.
</p>
<p>A <code>inflErrorARMA</code> equal to <code>c(0, 0)</code> implies that the error term in the
inflation equation is white noise. <code>inflErrorARMA = c(1, 0)</code> implies that the error is
an AR(1) process and for <code>inflErrorARMA = c(1, 2)</code> the error follows an ARMA(1, 2)
process.
</p>


<h3>Value</h3>

<p>Object of class <code>KuttnerModel</code>, which is a list with the following components:
</p>
<table>
<tr><td><code>tsl</code></td>
<td>
<p>A list of used time series.</p>
</td></tr>
<tr><td><code>SSModel</code></td>
<td>
<p>An object of class SSModel specifying the state-space model.</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>A data frame containing information on each involved parameter, for instance
its corresponding system matrix, variable names, and parameter restrictions.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function. </p>
</td></tr>
</table>
<p>In addition, the object contains the following attributes:
</p>
<table>
<tr><td><code>cycle</code></td>
<td>
<p>Cycle specification.</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>Trend specification.</p>
</td></tr>
<tr><td><code>inflation equation</code></td>
<td>
<p>A list containing the components <code>cycleLag, errorARMA, exoVariables</code>.</p>
</td></tr>
<tr><td><code>anchor</code></td>
<td>
<p>A list containing the components <code>value, horizon</code>.</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>A list containing the components <code>start, end, frequency</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load data for the Netherlands
data("gap")
country &lt;- "Netherlands"
tsList &lt;- as.list(gap[[country]][, c("cpih", "gdp")])
tsList$infl &lt;- diff(tsList$cpih)
model &lt;- KuttnerModel(tsl = tsList, trend = "RW2", start = 1980)
</code></pre>

<hr>
<h2 id='matmult3d'>Capitalizes the first letter of a string.</h2><span id='topic+matmult3d'></span>

<h3>Description</h3>

<p>Capitalizes the first letter of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matmult3d(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matmult3d_+3A_a">a</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='mcmcSummary'>Computes MCMC summary statistics.</h2><span id='topic+mcmcSummary'></span>

<h3>Description</h3>

<p>Computes MCMC summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcSummary(x, HPDIprob, frac1 = 0.1, frac2 = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcSummary_+3A_x">x</code></td>
<td>
<p>A <code>R x n</code> matrix with <code>R</code> draws of <code>n</code> variables.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_hpdiprob">HPDIprob</code></td>
<td>
<p>The probability mass of the HPDI, a scalar between zero and one.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_frac1">frac1</code></td>
<td>
<p>The probability mass of the first interval used for the Geweke test, a scalar
between zero and one.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_frac2">frac2</code></td>
<td>
<p>The probability mass of the second interval used for the Geweke test, a scalar
between zero and one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Naturally, <code>frac1 + frac2</code> is between zero and one.
</p>


<h3>Value</h3>

<p>A data frame with the following columns
</p>

<dl>
<dt>Mean</dt><dd><p>The posterior mean.</p>
</dd>
<dt>Median</dt><dd><p>The posterior median.</p>
</dd>
<dt>SD</dt><dd><p>Standard deviation.</p>
</dd>
<dt>HPDI-LB</dt><dd><p>Highest posterior density credible interval lower bound</p>
</dd>
<dt>HPDI-UB</dt><dd><p>Highest posterior density credible interval upper bound</p>
</dd>
<dt>Naive SE</dt><dd><p>Naive Standard error of the mean (ignoring chain autocorrelation.</p>
</dd>
<dt>Time-series SE</dt><dd><p>Time-series standard error (based on spectral density at 0).</p>
</dd>
<dt>Geweke statistic</dt><dd><p>The Geweke test statistic.</p>
</dd>
<dt>frac1</dt><dd><p>The fraction of data contained in the first interval.</p>
</dd>
<dt>frac2</dt><dd><p>The fraction of data contained in the second interval.</p>
</dd>
</dl>


<hr>
<h2 id='NAWRUmodel'>NAWRU model</h2><span id='topic+NAWRUmodel'></span>

<h3>Description</h3>

<p>Creates a state space object object of class <code>NAWRUmodel</code> which can be 
fitted using <code>fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NAWRUmodel(
  tsl,
  trend = "RW2",
  cycle = "AR2",
  type = "TKP",
  cycleLag = 0,
  pcErrorARMA = c(0, 0),
  exoType = NULL,
  start = NULL,
  end = NULL,
  anchor = NULL,
  anchor.h = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NAWRUmodel_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "RW2"</code>.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an <code>AR(2)</code> process. The default is
<code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of the Phillip's curve.
<code>type = "TKP"</code> denotes the traditional Keynesian Phillip's curve and
<code>type = "NKP"</code> the New Keynesian Phillip's curve, see details. The default is
<code>type = "TKP"</code>.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A vector specifying the cycle lags that are included in the Phillip's
curve. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_pcerrorarma">pcErrorARMA</code></td>
<td>
<p>A <code>2 x 1</code> vector with non-negative integers specifying the AR
and MA degree of the error term in the Phillip's curve equation. The default is
<code>pcErrorARMA = c(0, 0)</code>, see details.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_exotype">exoType</code></td>
<td>
<p>An optional <code>n x m x 2</code> array specifying the possible difference
and lag transformation for the variables. <code>exoType</code> can be initialized using the
function <code>inizializeExo</code>. The column names give the variable names.
<code>exoType[, , 1]</code> contains the difference transformations and <code>exoType[, , 2]</code>
the subsequent lag transformations, see details.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_start">start</code></td>
<td>
<p>(Optional) Start vector for the estimation, e.g. <code>c(1980, 1)</code>.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_end">end</code></td>
<td>
<p>(Optional) End vector for the estimation, e.g. <code>c(2020, 1)</code>.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_anchor">anchor</code></td>
<td>
<p>(Optional) Anchor value for the unemployment rate.</p>
</td></tr>
<tr><td><code id="NAWRUmodel_+3A_anchor.h">anchor.h</code></td>
<td>
<p>(Optional) Anchor horizon in the frequency of the given time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of time series <code>tsl</code> needs to have the following components:
</p>

<dl>
<dt>ur</dt><dd><p>Unemployment rate.</p>
</dd>
<dt>nulc</dt><dd><p>Nominal Unit labor costs, if <code>type = "TKP"</code>.</p>
</dd>
<dt>rulc</dt><dd><p>Real unit labor costs, if <code>type = "NKP"</code>.</p>
</dd>
</dl>

<p>and optionally other variables included in <code>exoType</code>.
</p>
<p>A <code>cycleLag</code> equal to <code>0</code> implies that only the contemporaneous cycle
is included in the Phillip's curve.  A <code>cycleLag</code> equal to <code>0:1</code> implies that
the contemporaneous as well as the lagged cycle are included.
</p>
<p>A <code>pcErrorARMA</code> equal to <code>c(0, 0)</code> implies that the error term in the
Phillip's curve is white noise. <code>pcErrorARMA = c(1, 0)</code> implies that the error is
an AR(1) process and for <code>pcErrorARMA = c(1, 2)</code> the error follows an ARMA(1, 2)
process.
</p>
<p>For the New Keynesian Phillip's curve, the <code>cycleLag</code> cannot be chosen.
<code>cycleLag</code> will be set to <code>0</code> if <code>cycle = "AR1"</code> and to <code>1</code> if
<code>cycle = "AR2"</code>. In the latter case, the forward solution of the Phillip's curve
implies parameter restrictions for the lagged cycle on the Phillip's curve. Moreover,
exogenous variables will be ignored in the case of the New Keynesian Phillip's curve.
</p>
<p>The array <code>exoType</code> consists of non-negative integers or <code>NA</code>s.
<code>exoType[, , 1] = c(NA,1)</code> and <code>exoType[, , 2] = c(NA,2)</code> implies that
the first variable is not included in the Phillip's curve whereas the second lag of
the first difference of the second variable is included.
</p>


<h3>Value</h3>

<p>Object of class <code>NAWRUmodel</code>, which is a list with the following components:
</p>
<table>
<tr><td><code>tsl</code></td>
<td>
<p>A list of used time series.</p>
</td></tr>
<tr><td><code>SSModel</code></td>
<td>
<p>An object of class SSModel specifying the state-space model.</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>A data frame containing information on each involved parameter, for instance
its corresponding system matrix, variable names, and parameter restrictions.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function.</p>
</td></tr>
</table>
<p>In addition, the object contains the following attributes:
</p>
<table>
<tr><td><code>cycle</code></td>
<td>
<p>Cycle specification.</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>Trend specification.</p>
</td></tr>
<tr><td><code>phillipsCurve</code></td>
<td>
<p>A list containing the components <code>type, cycleLag, errorARMA, exoVariables</code>.</p>
</td></tr>
<tr><td><code>anchor</code></td>
<td>
<p>A list containing the components <code>value, horizon</code>.</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>A list containing the components <code>start, end, frequency</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load data for France
data("gap")
tsList &lt;- amecoData2input(gap$France, alpha = 0.65)
# Traditional phillips curve
model &lt;- NAWRUmodel(tsl = tsList, trend = "RW2", cycle = "AR2", type = "TKP", cycleLag = 0)

# New-Keynesian Phillips curve
model &lt;- NAWRUmodel(tsl = tsList, trend = "RW2", cycle = "AR2", type = "NKP", cycleLag = 0:1)

# Traditional Phillips curve with 6 exogenous variables
# specify exogenous variable transformations
D &lt;- matrix(c(2, 2, 2, 1, 1, 1), 2, 3, byrow = TRUE)
L &lt;- matrix(c(0, 0, 0, 1, 1, 1), 2, 3, byrow = TRUE)
exoType &lt;- initializeExo(varNames = c("tot", "prod","ws"), D = D, L = L)
model &lt;- NAWRUmodel(tsl = tsList, cycleLag = 0:1, exoType = exoType)
</code></pre>

<hr>
<h2 id='obs2Optim'>Find suitable 2nd observation specification</h2><span id='topic+obs2Optim'></span>

<h3>Description</h3>

<p>Finds the most suitable model for the second observation equation according 
to the BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs2Optim(
  x1,
  x2,
  xexo = NULL,
  errorARmax = 2,
  errorMAmax = 2,
  maxCycleLag = 2,
  maxAR = 2,
  nModels = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obs2Optim_+3A_x1">x1</code></td>
<td>
<p>A time series, the second observation equation.</p>
</td></tr>
<tr><td><code id="obs2Optim_+3A_xexo">xexo</code></td>
<td>
<p>(Optional) A (multiple) time series with exogenous variables.</p>
</td></tr>
<tr><td><code id="obs2Optim_+3A_errorarmax">errorARmax</code></td>
<td>
<p>Integer, maximal AR order of the error process of the 2nd observation 
equation.</p>
</td></tr>
<tr><td><code id="obs2Optim_+3A_errormamax">errorMAmax</code></td>
<td>
<p>Integer, maximal MA order of the error process of the 2nd observation 
equation.</p>
</td></tr>
<tr><td><code id="obs2Optim_+3A_maxcyclelag">maxCycleLag</code></td>
<td>
<p>Integer, maximal cycle lag included in the 2nd observation 
equation.</p>
</td></tr>
<tr><td><code id="obs2Optim_+3A_maxar">maxAR</code></td>
<td>
<p>Integer, maximal AR order of the time series <code>x2</code> in the 2nd observation 
equation. <code>0</code> means that no lag is included.</p>
</td></tr>
<tr><td><code id="obs2Optim_+3A_nmodels">nModels</code></td>
<td>
<p>Integer, maximum number of models chosen to be fitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the chosen parameters: <code>errorAR, errorMA, cycleLag, ar, exo</code>.
</p>

<hr>
<h2 id='operTsLists'>Performs a mathematical operation to the ts elements of two lists with the same names</h2><span id='topic+operTsLists'></span>

<h3>Description</h3>

<p>Performs a mathematical operation to the ts elements of two lists with the same names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>operTsLists(x, y, operator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operTsLists_+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="operTsLists_+3A_y">y</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="operTsLists_+3A_operator">operator</code></td>
<td>
<p>mathematical operator in quotation marks, e.g., &quot;*&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_gibbs_output'>Plots the diagnostic plots of the posterior distribution.</h2><span id='topic+plot_gibbs_output'></span>

<h3>Description</h3>

<p>Plots the diagnostic plots of the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gibbs_output(
  path = NULL,
  draws,
  parName,
  burnin,
  mu = NULL,
  prec = NULL,
  shape = NULL,
  scale = NULL,
  shape1 = NULL,
  shape2 = NULL,
  ub = NULL,
  lb = NULL,
  prefix = NULL,
  device,
  width,
  height
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gibbs_output_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_draws">draws</code></td>
<td>
<p>the number of draws.</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_parname">parName</code></td>
<td>
<p>the name of the parameter.</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_burnin">burnin</code></td>
<td>
<p>length of thw burnin phase.</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_mu">mu</code></td>
<td>
<p>mean for normal distribution</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_prec">prec</code></td>
<td>
<p>precision for normal distribution</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_shape">shape</code></td>
<td>
<p>shape for Gamma distribution</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_scale">scale</code></td>
<td>
<p>scale for Gamma distribution</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_shape1">shape1</code></td>
<td>
<p>shape1 for Beta distribution</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_shape2">shape2</code></td>
<td>
<p>shape2 for Beta distribution</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_ub">ub</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_lb">lb</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_prefix">prefix</code></td>
<td>
<p>An optional character string to be added to the names of the plots in case
<code>path</code> is specified.</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plot_gibbs_output_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.gap'>Plots for a <code>gap</code> object</h2><span id='topic+plot.gap'></span>

<h3>Description</h3>

<p>Plots potential output growth and the output gap based on an objects of
class <code>gap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gap'
plot(
  x,
  contribution = FALSE,
  path = NULL,
  combine = TRUE,
  prefix = NULL,
  device = "png",
  width = 10,
  height = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gap_+3A_x">x</code></td>
<td>
<p>An object of class <code>gap</code>.</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_contribution">contribution</code></td>
<td>
<p>A boolean indicating whether the contributions to potential output
growth and the output gap should be plotted (only applicable for production function
type output gaps).</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_combine">combine</code></td>
<td>
<p>A logical indicating whether the plots should be combined or not, the
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_prefix">prefix</code></td>
<td>
<p>An optional character string to be added to the names of the plots in case
<code>path</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
<tr><td><code id="plot.gap_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots are printed.
</p>

<hr>
<h2 id='plot.KuttnerFit'>Plots for a <code>KuttnerFit</code> object</h2><span id='topic+plot.KuttnerFit'></span>

<h3>Description</h3>

<p>Plots potential growth and the output gap and gives diagnostic plots based on
standardized residuals for objects of class <code>KuttnerFit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KuttnerFit'
plot(
  x,
  alpha = 0.05,
  bounds = TRUE,
  path = NULL,
  combine = TRUE,
  prefix = NULL,
  device = "png",
  width = 10,
  height = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.KuttnerFit_+3A_x">x</code></td>
<td>
<p>An object of class <code>KuttnerFit</code>.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the trend (<code>alpha in [0,1]</code>). Only used if
<code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_bounds">bounds</code></td>
<td>
<p>A logical indicating whether significance intervals should be plotted around
gdp. The default is <code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_combine">combine</code></td>
<td>
<p>A logical indicating whether the diagnostic plots should be combined or not,
the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_prefix">prefix</code></td>
<td>
<p>An optional character string to be added to the names of the plots in case
<code>path</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
<tr><td><code id="plot.KuttnerFit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots are printed.
</p>

<hr>
<h2 id='plot.NAWRUfit'>Plots for a <code>NAWRUfit</code> object</h2><span id='topic+plot.NAWRUfit'></span>

<h3>Description</h3>

<p>Plots the NAWRU and the Phillip's curve and gives diagnostic plots based on
standardized residuals for objects of class <code>NAWRUfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NAWRUfit'
plot(
  x,
  alpha = 0.05,
  bounds = TRUE,
  path = NULL,
  combine = TRUE,
  prefix = NULL,
  posterior = FALSE,
  device = "png",
  width = 10,
  height = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NAWRUfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>NAWRUfit</code>.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the NAWRU (<code>alpha in [0,1]</code>). Only used if
<code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_bounds">bounds</code></td>
<td>
<p>A logical indicating whether significance intervals should be plotted around
the nawru. The default is <code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_combine">combine</code></td>
<td>
<p>A logical indicating whether the diagnostic plots should be combined or not,
the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_prefix">prefix</code></td>
<td>
<p>An optional character string to be added to the names of the plots in case
<code>path</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_posterior">posterior</code></td>
<td>
<p>A logical indicating whether posterior diagnostics should be plotted. The
default is <code>FALSE</code>. Only applied in the case of bayesian estimation.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
<tr><td><code id="plot.NAWRUfit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots are printed.
</p>

<hr>
<h2 id='plot.TFPfit'>Plots for a <code>TFPfit</code> object</h2><span id='topic+plot.TFPfit'></span>

<h3>Description</h3>

<p>Plots the TFP trend and the CUBS equation and gives diagnostic plots based on
standardized residuals for objects of class <code>TFPfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TFPfit'
plot(
  x,
  alpha = 0.05,
  bounds = TRUE,
  path = NULL,
  combine = TRUE,
  prefix = NULL,
  posterior = FALSE,
  device = "png",
  width = 10,
  height = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TFPfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>TFPfit</code>.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the TFP trend (<code>alpha in [0,1]</code>). Only used if
<code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_bounds">bounds</code></td>
<td>
<p>A logical indicating whether significance intervals should be plotted around
tfp growth. The default is <code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_combine">combine</code></td>
<td>
<p>A logical indicating whether the diagnostic plots should be combined or not,
the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_prefix">prefix</code></td>
<td>
<p>An optional character string to be added to the names of the plots in case
<code>path</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_posterior">posterior</code></td>
<td>
<p>A logical indicating whether posterior diagnostics should be plotted. The
default is <code>FALSE</code>. Only applied in the case of bayesian estimation.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
<tr><td><code id="plot.TFPfit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots are printed.
</p>

<hr>
<h2 id='plotGap'>Plots the trend series and the (fitted) second observation equation and gives diagnostic
plots based on standardized residuals.</h2><span id='topic+plotGap'></span>

<h3>Description</h3>

<p>Plots the trend series and the (fitted) second observation equation and gives diagnostic
plots based on standardized residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGap(
  tsl,
  legend,
  title,
  boundName,
  contribution,
  res = NULL,
  namesPrint,
  bounds,
  combine,
  path,
  device,
  width,
  height
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGap_+3A_tsl">tsl</code></td>
<td>
<p>A list with two multiple time series objects for the first and second plot,
respectively.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_legend">legend</code></td>
<td>
<p>A list with two character vectors. The first contains the legend names for
the first plot and so on.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_title">title</code></td>
<td>
<p>A list with the titles for the first three plots.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_boundname">boundName</code></td>
<td>
<p>The legend name of the confidence bounds.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_contribution">contribution</code></td>
<td>
<p>A boolean indicating whether the contributions to potential output
growth and the output gap should be plotted (only applicable for production function
type output gaps).</p>
</td></tr>
<tr><td><code id="plotGap_+3A_res">res</code></td>
<td>
<p>The residual series as time series. If <code>res = NULL</code>, all graphs related
to the residual series will not be plotted.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_namesprint">namesPrint</code></td>
<td>
<p>A character vector containing two names for the first two plots. The
remaining names are creates automatically if <code>combine = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_bounds">bounds</code></td>
<td>
<p>A logical indicating whether significance intervals should be plotted around
the nawru. The default is <code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_combine">combine</code></td>
<td>
<p>A logical indicating whether the diagnostic plots should be combined or not,
the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
</table>

<hr>
<h2 id='plotSSprediction'>Plots the trend series and the (fitted) second observation equation and gives diagnostic
plots based on standardized residuals.</h2><span id='topic+plotSSprediction'></span>

<h3>Description</h3>

<p>Plots the trend series and the (fitted) second observation equation and gives diagnostic
plots based on standardized residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSSprediction(
  tsl,
  legend,
  title,
  n.ahead,
  boundName,
  res = NULL,
  namesPrint,
  bounds,
  combine,
  path,
  device,
  width,
  height
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSSprediction_+3A_tsl">tsl</code></td>
<td>
<p>A list with two multiple time series objects for the first and second plor,
respectively.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_legend">legend</code></td>
<td>
<p>A list with two character vectors. The first contains the legend names for
the first plot and so on.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_title">title</code></td>
<td>
<p>A list with the titles for the first three plots.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer indicating the forecast horizon.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_boundname">boundName</code></td>
<td>
<p>The legend name of the confidence bounds.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_res">res</code></td>
<td>
<p>The residual series as time series. If <code>res = NULL</code>, all graphs realted
to the residual series will not be plotted.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_namesprint">namesPrint</code></td>
<td>
<p>A character vector containing two names for the first two plots. The
remaining names are creates automatically if <code>combine = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_bounds">bounds</code></td>
<td>
<p>A logical indicating whether significance intervals should be plotted around
the nawru. The default is <code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_combine">combine</code></td>
<td>
<p>A logical indicating whether the diagnostic plots should be combined or not,
the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plotSSprediction_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
</table>

<hr>
<h2 id='plotSSresults'>Plots the trend series and the (fitted) second observation equation and gives diagnostic
plots based on standardized residuals.</h2><span id='topic+plotSSresults'></span>

<h3>Description</h3>

<p>Plots the trend series and the (fitted) second observation equation and gives diagnostic
plots based on standardized residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSSresults(
  tsl,
  legend,
  title,
  boundName,
  res = NULL,
  namesPrint,
  bounds,
  combine,
  path,
  device,
  width,
  height
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSSresults_+3A_tsl">tsl</code></td>
<td>
<p>A list with two multiple time series objects for the first and second plor,
respectively.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_legend">legend</code></td>
<td>
<p>A list with two character vectors. The first contains the legend names for
the first plot and so on.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_title">title</code></td>
<td>
<p>A list with the titles for the first three plots.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_boundname">boundName</code></td>
<td>
<p>The legend name of the confidence bounds.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_res">res</code></td>
<td>
<p>The residual series as time series. If <code>res = NULL</code>, all graphs realted
to the residual series will not be plotted.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_namesprint">namesPrint</code></td>
<td>
<p>A character vector containing two names for the first two plots. The
remaining names are creates automatically if <code>combine = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_bounds">bounds</code></td>
<td>
<p>A logical indicating whether significance intervals should be plotted around
the nawru. The default is <code>bounds = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_combine">combine</code></td>
<td>
<p>A logical indicating whether the diagnostic plots should be combined or not,
the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_path">path</code></td>
<td>
<p>An optional file path. If specified, the plots will be saved using the format
in <code>device</code> under the given path.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_device">device</code></td>
<td>
<p>Device passed on to <code>ggplot</code> for plot saving. Options are 
<code>"eps", "ps", "tex"</code> (pictex), <code>"pdf", "jpeg", "tiff", "png", "bmp", "svg"</code> 
or <code>"wmf"</code>.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_width">width</code></td>
<td>
<p>The plot width in case of printing.</p>
</td></tr>
<tr><td><code id="plotSSresults_+3A_height">height</code></td>
<td>
<p>The plot height in case of printing.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.fit'>Predictions</h2><span id='topic+predict.fit'></span>

<h3>Description</h3>

<p>Computes predictions for an object of class <code>NAWRUfit, TFPfit</code>, or 
<code>KuttnerFit</code> estimated via MLE or Bayesian methods (objects of class <code>fit</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit'
predict(object, n.ahead = 10, exogenous = "mean", returnFit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>NAWRUfit</code>, <code>TFPfit</code>, or <code>KuttnerFit</code> 
(objects of class <code>fit</code>).</p>
</td></tr>
<tr><td><code id="predict.fit_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the prediction horizon.</p>
</td></tr>
<tr><td><code id="predict.fit_+3A_exogenous">exogenous</code></td>
<td>
<p>A character string specifying the computation of exogenous variables 
included in the model (if applicable). Valid options are <code>exogenous = "mean"</code> and 
<code>exogenous = "last".</code></p>
</td></tr>
<tr><td><code id="predict.fit_+3A_returnfit">returnFit</code></td>
<td>
<p>A logical. If <code>TRUE</code>, an object of the same class as <code>fit</code>
where the list entry <code>tsl</code> is replaced. If <code>FALSE</code>, only the new time series 
list is returned.</p>
</td></tr>
<tr><td><code id="predict.fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fitted object with an updated time series list <code>tsl</code>. If 
<code>returnFit = FALSE</code>, only the updated time series list is returned.
</p>

<hr>
<h2 id='predictBayes'>Predictions for Bayesian estimation</h2><span id='topic+predictBayes'></span>

<h3>Description</h3>

<p>Computes predictions for an object of class <code>NAWRUfit, TFPfit</code>
estimated via Bayesian methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictBayes(fit, n.ahead = 10, exogenous = "mean", returnFit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictBayes_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the prediction horizon.</p>
</td></tr>
<tr><td><code id="predictBayes_+3A_exogenous">exogenous</code></td>
<td>
<p>A character string specifying the computation of exogenous variables 
included in the model (if applicable). Valid options are <code>exogenous = "mean"</code> and 
<code>exogenous = "last".</code></p>
</td></tr>
<tr><td><code id="predictBayes_+3A_returnfit">returnFit</code></td>
<td>
<p>A logical. If <code>TRUE</code>, an object of the same class as <code>fit</code>
where the list entry <code>tsl</code> is replaced. If <code>FALSE</code>, only the new time series 
list is returned.</p>
</td></tr>
</table>

<hr>
<h2 id='predictMLE'>Predictions for MLE</h2><span id='topic+predictMLE'></span>

<h3>Description</h3>

<p>Computes predictions for an object of class <code>NAWRUfit, TFPfit, KuttnerFit</code>
estimated via MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictMLE(fit, n.ahead = 10, exogenous = "mean", returnFit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictMLE_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the prediction horizon.</p>
</td></tr>
<tr><td><code id="predictMLE_+3A_exogenous">exogenous</code></td>
<td>
<p>A character string specifying the computation of exogenous variables 
included in the model (if applicable). Valid options are <code>exogenous = "mean"</code> and 
<code>exogenous = "last".</code></p>
</td></tr>
<tr><td><code id="predictMLE_+3A_returnfit">returnFit</code></td>
<td>
<p>A logical. If <code>TRUE</code>, an object of the same class as <code>fit</code>
where the list entry <code>tsl</code> is replaced. If <code>FALSE</code>, only the new time series 
list is returned.</p>
</td></tr>
</table>

<hr>
<h2 id='print.gap'>Print <code>gap</code> object</h2><span id='topic+print.gap'></span>

<h3>Description</h3>

<p>Prints the model specifications of an object of class <code>gap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gap'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gap_+3A_x">x</code></td>
<td>
<p>An object of class <code>gap</code>.</p>
</td></tr>
<tr><td><code id="print.gap_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, results are printed.
</p>

<hr>
<h2 id='print.KuttnerFit'>Print <code>KuttnerFit</code> object</h2><span id='topic+print.KuttnerFit'></span>

<h3>Description</h3>

<p>Prints the model specifications and the estimation results of an object of
class <code>KuttnerFit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KuttnerFit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.KuttnerFit_+3A_x">x</code></td>
<td>
<p>An object of class <code>KuttnerFit</code>.</p>
</td></tr>
<tr><td><code id="print.KuttnerFit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, results are printed.
</p>

<hr>
<h2 id='print.KuttnerModel'>Print <code>KuttnerModel</code> object</h2><span id='topic+print.KuttnerModel'></span>

<h3>Description</h3>

<p>Prints the model specifications of an object of class <code>KuttnerModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KuttnerModel'
print(x, call = TRUE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.KuttnerModel_+3A_x">x</code></td>
<td>
<p>An object of class <code>KuttnerModel</code>.</p>
</td></tr>
<tr><td><code id="print.KuttnerModel_+3A_call">call</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the call will be printed.</p>
</td></tr>
<tr><td><code id="print.KuttnerModel_+3A_check">check</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the model class will be checked.</p>
</td></tr>
<tr><td><code id="print.KuttnerModel_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, model information is printed.
</p>

<hr>
<h2 id='print.NAWRUfit'>Print <code>NAWRUfit</code> object</h2><span id='topic+print.NAWRUfit'></span>

<h3>Description</h3>

<p>Prints the model specifications and the estimation results of an object of class <code>NAWRUfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NAWRUfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NAWRUfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>NAWRUfit</code>.</p>
</td></tr>
<tr><td><code id="print.NAWRUfit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, results are printed.
</p>

<hr>
<h2 id='print.NAWRUmodel'>Print <code>NAWRUmodel</code> object</h2><span id='topic+print.NAWRUmodel'></span>

<h3>Description</h3>

<p>Prints the model specifications of an object of class <code>NAWRUmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NAWRUmodel'
print(x, call = TRUE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NAWRUmodel_+3A_x">x</code></td>
<td>
<p>An object of class <code>NAWRUmodel</code>.</p>
</td></tr>
<tr><td><code id="print.NAWRUmodel_+3A_call">call</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the call will be printed.</p>
</td></tr>
<tr><td><code id="print.NAWRUmodel_+3A_check">check</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the model class will be checked.</p>
</td></tr>
<tr><td><code id="print.NAWRUmodel_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, model information is printed.
</p>

<hr>
<h2 id='print.TFPfit'>Print <code>TFPfit</code> object</h2><span id='topic+print.TFPfit'></span>

<h3>Description</h3>

<p>Prints the model specifications and the estimation results of an object of class <code>TFPfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TFPfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TFPfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>TFPfit</code>.</p>
</td></tr>
<tr><td><code id="print.TFPfit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, results are printed.
</p>

<hr>
<h2 id='print.TFPmodel'>Print <code>TFPmodel</code> object</h2><span id='topic+print.TFPmodel'></span>

<h3>Description</h3>

<p>Prints the model specifications of an object of class <code>TFPmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TFPmodel'
print(x, call = TRUE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TFPmodel_+3A_x">x</code></td>
<td>
<p>An object of class <code>TFPmodel</code>.</p>
</td></tr>
<tr><td><code id="print.TFPmodel_+3A_call">call</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the call will be printed.</p>
</td></tr>
<tr><td><code id="print.TFPmodel_+3A_check">check</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the model class will be checked.</p>
</td></tr>
<tr><td><code id="print.TFPmodel_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, model information is printed.
</p>

<hr>
<h2 id='TFPmodel'>TFP trend model</h2><span id='topic+TFPmodel'></span>

<h3>Description</h3>

<p>Creates a state space object object of class <code>TFPmodel</code> which can be 
fitted using <code>fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFPmodel(
  tsl,
  trend = "DT",
  cycle = "AR2",
  cycleLag = 0,
  cubsAR = 0,
  cubsErrorARMA = c(0, 0),
  start = NULL,
  end = NULL,
  anchor = NULL,
  anchor.h = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TFPmodel_+3A_tsl">tsl</code></td>
<td>
<p>A list of time series objects, see details.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_trend">trend</code></td>
<td>
<p>A character string specifying the trend model. <code>trend = "RW1"</code> denotes
a first order random walk, <code>trend = "RW2"</code> a second order random walk (local linear
trend) and <code>trend = "DT"</code> a damped trend model. The default is <code>trend = "DT"</code>.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_cycle">cycle</code></td>
<td>
<p>A character string specifying the cycle model. <code>cycle = "AR1"</code> denotes
an AR(1) process, <code>cycle = "AR2"</code> an AR(2) process, <code>cycle = "RAR2"</code> a
reparametrized AR(2) process. The default is <code>cycle = "AR2"</code>.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_cyclelag">cycleLag</code></td>
<td>
<p>A non-negative integer specifying the maximum cycle lag that is included
in the CUBD equation. The default is <code>cycleLag = 0</code>, see details.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_cubsar">cubsAR</code></td>
<td>
<p>A non-negative integer specifying the maximum CUBS lag that is included
in the CUBS equation. The default is <code>cubsAR = 0</code>, see details.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_cubserrorarma">cubsErrorARMA</code></td>
<td>
<p>A vector with non-negative integers specifying the AR
and MA degree of the error term in the CUBS equation. The default is
<code>cubsErrorARMA = c(0, 0)</code>, see details.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_start">start</code></td>
<td>
<p>(Optional) Start vector for the estimation, e.g. <code>c(1980, 1)</code>.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_end">end</code></td>
<td>
<p>(Optional) End vector for the estimation, e.g. <code>c(2020, 1)</code>.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_anchor">anchor</code></td>
<td>
<p>(Optional) Snchor value for the log of the TFP trend.</p>
</td></tr>
<tr><td><code id="TFPmodel_+3A_anchor.h">anchor.h</code></td>
<td>
<p>(Optional) Anchor horizon in the frequency of the given time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of time series <code>tsl</code> needs to have the following components:
</p>

<dl>
<dt>tfp</dt><dd><p>Total factor productivity.</p>
</dd>
<dt>cubs</dt><dd><p>Capacity utilization economic sentiment indicator.</p>
</dd>
</dl>

<p>A <code>cycleLag</code> equal to <code>0</code> implies that only the contemporaneous cycle
is included in the CUBS equation.  A <code>cycleLag</code> equal to <code>0:1</code> implies that
the contemporaneous as well as the lagged cycle are included.
</p>
<p>A <code>cubsAR</code> equal to <code>0</code> implies that no autoregressive term is
included in the CUBS equation.  <code>cubsAR = 1</code> implies that a lagged term is
included, <code>cubsAR = 2</code> implies that a two lags are included, and so on.
</p>
<p>A <code>cubsErrorARMA</code> equal to <code>c(0, 0)</code> implies that the error term in the
CUBS equation is white noise. <code>cubsErrorARMA = c(1, 0)</code> implies that the error is
an AR(1) process and for <code>cubsErrorARMA = c(1, 2)</code> the error follows an ARMA(1, 2)
process.
</p>


<h3>Value</h3>

<p>Object of class TFPmodel, which is a list with the following components:
</p>
<table>
<tr><td><code>tsl</code></td>
<td>
<p>A list of used time series.</p>
</td></tr>
<tr><td><code>SSModel</code></td>
<td>
<p>An object of class SSModel specifying the state-space model.</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>A data frame containing information on each involved parameter, for instance
its corresponding system matrix, variable names, and parameter restrictions.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to the function. </p>
</td></tr>
</table>
<p>In addition, the object contains the following attributes:
</p>
<table>
<tr><td><code>cycle</code></td>
<td>
<p>Cycle specification.</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>Trend specification.</p>
</td></tr>
<tr><td><code>cubs</code></td>
<td>
<p>A list containing the components <code>cycleLag, cubsAR, errorARMA, exoVariables</code>.</p>
</td></tr>
<tr><td><code>anchor</code></td>
<td>
<p>A list containing the components <code>value, horizon</code>.</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>A list containing the components <code>start, end, frequency</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load data for Germany
data("gap")
data("indicator")
country &lt;- "Germany"
tsList &lt;- amecoData2input(gap[[country]], alpha = 0.65)

# compute cubs indicator
namesCubs &lt;- c("indu", "serv", "buil")
namesVACubs &lt;- paste0("va", namesCubs)
tscubs &lt;- cubs(
  tsCU = gap[[country]][, namesCubs],
  tsVA = gap[[country]][, namesVACubs]
)
tsList &lt;- c(tsList, tscubs)

# define tfp model
model &lt;- TFPmodel(tsl = tsList, cycle = "RAR2", cubsErrorARMA = c(1,0))
</code></pre>

<hr>
<h2 id='trendAnchor'>Trend anchor</h2><span id='topic+trendAnchor'></span>

<h3>Description</h3>

<p>Computes the anchored trend given a fitted object of class <code>NAWRUfit</code>,
<code>TFPfit</code>, or <code>KuttnerFit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trendAnchor(fit, anchor = NULL, h = NULL, returnFit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trendAnchor_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>NAWRUfit</code>, <code>TFPfit</code>, or <code>KuttnerFit</code>.</p>
</td></tr>
<tr><td><code id="trendAnchor_+3A_anchor">anchor</code></td>
<td>
<p>A numeric specifying the anchor value. If unspecified, <code>anchor</code> is
taken from the object <code>fit</code> (if specified).</p>
</td></tr>
<tr><td><code id="trendAnchor_+3A_h">h</code></td>
<td>
<p>An integer specifying the anchor horizon in the frequency of the underlying model.
If unspecified, <code>h</code> is taken from the object <code>fit</code> (if specified).</p>
</td></tr>
<tr><td><code id="trendAnchor_+3A_returnfit">returnFit</code></td>
<td>
<p>A logical. If <code>TRUE</code>, an object of the same class as <code>fit</code>
including the anchored trend is returned. If <code>FALSE</code>, only the anchored trend time
series is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted object if <code>returnFit = TRUE</code> or a time series with the anchored 
trend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define nawru model for France
data("gap")
tsList &lt;- amecoData2input(gap$France)
model &lt;- NAWRUmodel(tsl = tsList)

# estimate nawru model

f &lt;- fit(model = model)

# compute anchored nawru
anchoredNawru &lt;- trendAnchor(fit = f, anchor = 6.5, h = 10)

</code></pre>

<hr>
<h2 id='trendOptim'>Find suitable trend specification</h2><span id='topic+trendOptim'></span>

<h3>Description</h3>

<p>Finds the most suitable trend model according to the BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trendOptim(x, opt = c("RW1", "RW2", "DT"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trendOptim_+3A_x">x</code></td>
<td>
<p>A time series.</p>
</td></tr>
<tr><td><code id="trendOptim_+3A_opt">opt</code></td>
<td>
<p>A character vector with the trend models to be tested. The default is 
<code>opt = c("RW1", "RW2", "DT")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the chosen trend model.
</p>

<hr>
<h2 id='trendVolaMeasures'>Trend volatility measures</h2><span id='topic+trendVolaMeasures'></span>

<h3>Description</h3>

<p>Computes trend volatility measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trendVolaMeasures(tsOriginal, tsTrend, nDiff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trendVolaMeasures_+3A_tsoriginal">tsOriginal</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="trendVolaMeasures_+3A_tstrend">tsTrend</code></td>
<td>
<p>The trend time series.</p>
</td></tr>
<tr><td><code id="trendVolaMeasures_+3A_ndiff">nDiff</code></td>
<td>
<p>Integer indicating the order of differencing applied to the input series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the different measures.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
