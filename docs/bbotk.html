<!DOCTYPE html><html><head><title>Help for package bbotk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bbotk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Archive'><p>Logging object for objective function evaluations</p></a></li>
<li><a href='#ArchiveBest'><p>Minimal logging object for objective function evaluations</p></a></li>
<li><a href='#assign_result_default'><p>Default assign_result function</p></a></li>
<li><a href='#bb_optimize'><p>Black-Box Optimization</p></a></li>
<li><a href='#bbotk_assertions'><p>Assertion for bbotk objects</p></a></li>
<li><a href='#bbotk_reflections'><p>Reflections for bbotk</p></a></li>
<li><a href='#bbotk-package'><p>bbotk: Black-Box Optimization Toolkit</p></a></li>
<li><a href='#bbotk.backup'><p>Backup Archive Callback</p></a></li>
<li><a href='#branin'><p>Branin Function</p></a></li>
<li><a href='#callback_optimization'><p>Create Optimization Callback</p></a></li>
<li><a href='#CallbackOptimization'><p>Create Optimization Callback</p></a></li>
<li><a href='#Codomain'><p>Codomain of Function</p></a></li>
<li><a href='#ContextOptimization'><p>Optimization Context</p></a></li>
<li><a href='#is_dominated'><p>Calculate which points are dominated</p></a></li>
<li><a href='#mlr_optimizers'><p>Dictionary of Optimizer</p></a></li>
<li><a href='#mlr_optimizers_cmaes'><p>Optimization via Covariance Matrix Adaptation Evolution Strategy</p></a></li>
<li><a href='#mlr_optimizers_design_points'><p>Optimization via Design Points</p></a></li>
<li><a href='#mlr_optimizers_focus_search'><p>Optimization via Focus Search</p></a></li>
<li><a href='#mlr_optimizers_gensa'><p>Optimization via Generalized Simulated Annealing</p></a></li>
<li><a href='#mlr_optimizers_grid_search'><p>Optimization via Grid Search</p></a></li>
<li><a href='#mlr_optimizers_irace'><p>Optimization via Iterated Racing</p></a></li>
<li><a href='#mlr_optimizers_nloptr'><p>Optimization via Non-linear Optimization</p></a></li>
<li><a href='#mlr_optimizers_random_search'><p>Optimization via Random Search</p></a></li>
<li><a href='#mlr_terminators'><p>Dictionary of Terminators</p></a></li>
<li><a href='#mlr_terminators_clock_time'><p>Clock Time Terminator</p></a></li>
<li><a href='#mlr_terminators_combo'><p>Combine Terminators</p></a></li>
<li><a href='#mlr_terminators_evals'><p>Terminator that stops after a number of evaluations</p></a></li>
<li><a href='#mlr_terminators_none'><p>None Terminator</p></a></li>
<li><a href='#mlr_terminators_perf_reached'><p>Performance Level Terminator</p></a></li>
<li><a href='#mlr_terminators_run_time'><p>Run Time Terminator</p></a></li>
<li><a href='#mlr_terminators_stagnation'><p>Terminator that stops when optimization does not improve</p></a></li>
<li><a href='#mlr_terminators_stagnation_batch'><p>Terminator that stops when optimization does not improve</p></a></li>
<li><a href='#nds_selection'><p>Best points w.r.t. non dominated sorting with hypervolume contribution.</p></a></li>
<li><a href='#Objective'><p>Objective function with domain and co-domain</p></a></li>
<li><a href='#ObjectiveRFun'><p>Objective interface with custom R function</p></a></li>
<li><a href='#ObjectiveRFunDt'><p>Objective interface for basic R functions.</p></a></li>
<li><a href='#ObjectiveRFunMany'><p>Objective Interface with Custom R Function</p></a></li>
<li><a href='#opt'><p>Syntactic Sugar Optimizer Construction</p></a></li>
<li><a href='#OptimInstance'><p>Optimization Instance with budget and archive</p></a></li>
<li><a href='#OptimInstanceMultiCrit'><p>Optimization Instance with budget and archive</p></a></li>
<li><a href='#OptimInstanceSingleCrit'><p>Optimization Instance with budget and archive</p></a></li>
<li><a href='#optimize_default'><p>Default optimization function</p></a></li>
<li><a href='#Optimizer'><p>Optimizer</p></a></li>
<li><a href='#Progressor'><p>Progressor</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#search_start'><p>Get start values for optimizers</p></a></li>
<li><a href='#shrink_ps'><p>Shrink a ParamSet towards a point.</p></a></li>
<li><a href='#Terminator'><p>Abstract Terminator Class</p></a></li>
<li><a href='#transform_xdt_to_xss'><p>Calculates the transformed x-values</p></a></li>
<li><a href='#trm'><p>Syntactic Sugar Terminator Construction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Black-Box Optimization Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Features highly configurable search spaces via the 'paradox'
    package and optimizes every user-defined objective function. The package
    includes several optimization algorithms e.g. Random Search, Iterated
    Racing, Bayesian Optimization (in 'mlr3mbo') and Hyperband (in
    'mlr3hyperband'). bbotk is the base package of 'mlr3tuning', 'mlr3fselect'
    and 'miesmuschel'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bbotk.mlr-org.com">https://bbotk.mlr-org.com</a>, <a href="https://github.com/mlr-org/bbotk">https://github.com/mlr-org/bbotk</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/bbotk/issues">https://github.com/mlr-org/bbotk/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>paradox (&ge; 0.7.0), R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.0.0), data.table, lgr, methods, mlr3misc (&ge;
0.11.0), R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adagio, emoa, GenSA, irace (&ge; 3.5), knitr, nloptr,
progressr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Archive.R' 'ArchiveBest.R' 'CallbackOptimization.R'
'Codomain.R' 'ContextOptimization.R' 'Objective.R'
'ObjectiveRFun.R' 'ObjectiveRFunDt.R' 'ObjectiveRFunMany.R'
'OptimInstance.R' 'OptimInstanceMultiCrit.R'
'OptimInstanceSingleCrit.R' 'mlr_optimizers.R' 'Optimizer.R'
'OptimizerCmaes.R' 'OptimizerDesignPoints.R'
'OptimizerFocusSearch.R' 'OptimizerGenSA.R'
'OptimizerGridSearch.R' 'OptimizerIrace.R' 'OptimizerNLoptr.R'
'OptimizerRandomSearch.R' 'Progressor.R' 'mlr_terminators.R'
'Terminator.R' 'TerminatorClockTime.R' 'TerminatorCombo.R'
'TerminatorEvals.R' 'TerminatorNone.R'
'TerminatorPerfReached.R' 'TerminatorRunTime.R'
'TerminatorStagnation.R' 'TerminatorStagnationBatch.R'
'assertions.R' 'bb_optimize.R' 'bbotk_reflections.R'
'bibentries.R' 'helper.R' 'mlr_callbacks.R' 'nds_selection.R'
'reexport.R' 'sugar.R' 'zzz.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 11:21:34 UTC; marc</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Jakob Richter <a href="https://orcid.org/0000-0003-4481-5554"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bernd Bischl <a href="https://orcid.org/0000-0001-6002-6980"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Martin Binder [aut],
  Olaf Mersmann [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Becker &lt;marcbecker@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 12:52:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='Archive'>Logging object for objective function evaluations</h2><span id='topic+Archive'></span>

<h3>Description</h3>

<p>Container around a <a href="data.table.html#topic+data.table">data.table::data.table</a> which stores all performed
function calls of the Objective.
</p>


<h3>S3 Methods</h3>


<ul>
<li> <p><code>as.data.table(archive)</code><br />
<a href="#topic+Archive">Archive</a> -&gt; <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code><br />
Returns a tabular view of all performed function calls of the
Objective. The <code>x_domain</code> column is unnested to separate columns.
</p>
</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Search space of objective.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="#topic+Codomain">Codomain</a>)<br />
Codomain of objective function.</p>
</dd>
<dt><code>start_time</code></dt><dd><p>(<a href="base.html#topic+POSIXct">POSIXct</a>)<br />
Time stamp of when the optimization started. The time is set by the
<a href="#topic+Optimizer">Optimizer</a>.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Determines if points and results are checked for validity.</p>
</dd>
<dt><code>data</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
Contains all performed <a href="#topic+Objective">Objective</a> function calls.</p>
</dd>
<dt><code>data_extra</code></dt><dd><p>(named <code>list</code>)<br />
Data created by specific <code><a href="#topic+Optimizer">Optimizer</a></code>s that does not relate to any individual function evaluation and can therefore not be held in <code style="white-space: pre;">&#8288;$data&#8288;</code>.
Every optimizer should create and refer to its own entry in this list, named by its <code>class()</code>.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n_evals</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of evaluations stored in the archive.</p>
</dd>
<dt><code>n_batch</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of batches stored in the archive.</p>
</dd>
<dt><code>cols_x</code></dt><dd><p>(<code>character()</code>)<br />
Column names of search space parameters.</p>
</dd>
<dt><code>cols_y</code></dt><dd><p>(<code>character()</code>)<br />
Column names of codomain target parameters.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Archive-new"><code>Archive$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Archive-add_evals"><code>Archive$add_evals()</code></a>
</p>
</li>
<li> <p><a href="#method-Archive-best"><code>Archive$best()</code></a>
</p>
</li>
<li> <p><a href="#method-Archive-nds_selection"><code>Archive$nds_selection()</code></a>
</p>
</li>
<li> <p><a href="#method-Archive-format"><code>Archive$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Archive-print"><code>Archive$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Archive-clear"><code>Archive$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-Archive-clone"><code>Archive$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Archive-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$new(search_space, codomain, check_values = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies the search space for the <a href="#topic+Optimizer">Optimizer</a>. The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>
describes either a subset of the <code>domain</code> of the <a href="#topic+Objective">Objective</a> or it describes
a set of parameters together with a <code>trafo</code> function that transforms values
from the search space to values of the domain. Depending on the context, this
value defaults to the domain of the objective.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies codomain of function.
Most importantly the tags of each output &quot;Parameter&quot; define whether it should
be minimized or maximized.  The default is to minimize each component.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should x-values that are added to the archive be checked for validity?
Search space that is logged into archive.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Archive-add_evals"></a>



<h4>Method <code>add_evals()</code></h4>

<p>Adds function evaluations to the archive table.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$add_evals(xdt, xss_trafoed = NULL, ydt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Set of untransformed points / points from the <em>search space</em>.
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.
Column names have to match ids of the <code>search_space</code>.
However, <code>xdt</code> can contain additional columns.</p>
</dd>
<dt><code>xss_trafoed</code></dt><dd><p>(<code>list()</code>)<br />
Transformed point(s) in the <em>domain space</em>.</p>
</dd>
<dt><code>ydt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Optimal outcome.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Archive-best"></a>



<h4>Method <code>best()</code></h4>

<p>Returns the best scoring evaluation(s).
For single-crit optimization, the solution that minimizes / maximizes the objective function.
For multi-crit optimization, the Pareto set / front.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$best(batch = NULL, n_select = 1L, ties_method = "first")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>batch</code></dt><dd><p>(<code>integer()</code>)<br />
The batch number(s) to limit the best results to.
Default is all batches.</p>
</dd>
<dt><code>n_select</code></dt><dd><p>(<code>integer(1L)</code>)<br />
Amount of points to select.
Ignored for multi-crit optimization.</p>
</dd>
<dt><code>ties_method</code></dt><dd><p>(<code>character(1L)</code>)<br />
Method to break ties when multiple points have the same score.
Either <code>"first"</code> (default) or <code>"random"</code>.
Ignored for multi-crit optimization.
If <code>n_select &gt; 1L</code>, the tie method is ignored and the first point is returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-Archive-nds_selection"></a>



<h4>Method <code>nds_selection()</code></h4>

<p>Calculate best points w.r.t. non dominated sorting with hypervolume contribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$nds_selection(batch = NULL, n_select = 1, ref_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>batch</code></dt><dd><p>(<code>integer()</code>)<br />
The batch number(s) to limit the best points to. Default is
all batches.</p>
</dd>
<dt><code>n_select</code></dt><dd><p>(<code>integer(1L)</code>)<br />
Amount of points to select.</p>
</dd>
<dt><code>ref_point</code></dt><dd><p>(<code>numeric()</code>)<br />
Reference point for hypervolume.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-Archive-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Archive-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Archive-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Clear all evaluation results from archive.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$clear()</pre></div>


<hr>
<a id="method-Archive-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Archive$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ArchiveBest'>Minimal logging object for objective function evaluations</h2><span id='topic+ArchiveBest'></span>

<h3>Description</h3>

<p>The <a href="#topic+ArchiveBest">ArchiveBest</a> stores no data but records the best scoring evaluation
passed to <code style="white-space: pre;">&#8288;$add_evals()&#8288;</code>. The <a href="#topic+Archive">Archive</a> API is fully implemented but many
parameters are ignored and some methods do nothing. The archive still works
with <a href="#topic+TerminatorClockTime">TerminatorClockTime</a>, <a href="#topic+TerminatorEvals">TerminatorEvals</a>, <a href="#topic+TerminatorNone">TerminatorNone</a> and
<a href="#topic+TerminatorEvals">TerminatorEvals</a>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Archive">bbotk::Archive</a></code> -&gt; <code>ArchiveBest</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n_evals</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of evaluations stored in the archive.</p>
</dd>
<dt><code>n_batch</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of batches stored in the archive.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ArchiveBest-new"><code>ArchiveBest$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBest-add_evals"><code>ArchiveBest$add_evals()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBest-best"><code>ArchiveBest$best()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBest-clone"><code>ArchiveBest$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="clear"><a href='../../bbotk/html/Archive.html#method-Archive-clear'><code>bbotk::Archive$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="format"><a href='../../bbotk/html/Archive.html#method-Archive-format'><code>bbotk::Archive$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="nds_selection"><a href='../../bbotk/html/Archive.html#method-Archive-nds_selection'><code>bbotk::Archive$nds_selection()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="print"><a href='../../bbotk/html/Archive.html#method-Archive-print'><code>bbotk::Archive$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ArchiveBest-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBest$new(search_space, codomain, check_values = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies the search space for the <a href="#topic+Optimizer">Optimizer</a>. The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>
describes either a subset of the <code>domain</code> of the <a href="#topic+Objective">Objective</a> or it describes
a set of parameters together with a <code>trafo</code> function that transforms values
from the search space to values of the domain. Depending on the context, this
value defaults to the domain of the objective.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies codomain of function.
Most importantly the tags of each output &quot;Parameter&quot; define whether it should
be minimized or maximized.  The default is to minimize each component.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBest-add_evals"></a>



<h4>Method <code>add_evals()</code></h4>

<p>Stores the best result in <code>ydt</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBest$add_evals(xdt, xss_trafoed = NULL, ydt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Set of untransformed points / points from the <em>search space</em>.
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.
Column names have to match ids of the <code>search_space</code>.
However, <code>xdt</code> can contain additional columns.</p>
</dd>
<dt><code>xss_trafoed</code></dt><dd><p>(<code>list()</code>)<br />
Transformed point(s) in the <em>domain space</em>.</p>
</dd>
<dt><code>ydt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Optimal outcome.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBest-best"></a>



<h4>Method <code>best()</code></h4>

<p>Returns the best scoring evaluation. For single-crit optimization,
the solution that minimizes / maximizes the objective function.
For multi-crit optimization, the Pareto set / front.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBest$best(m = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m</code></dt><dd><p>(<code>integer()</code>)<br />
ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-ArchiveBest-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBest$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='assign_result_default'>Default assign_result function</h2><span id='topic+assign_result_default'></span>

<h3>Description</h3>

<p>Used internally in the <a href="#topic+Optimizer">Optimizer</a>.
It is the default way to determine the result by simply obtaining the best performing result from the archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_result_default(inst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_result_default_+3A_inst">inst</code></td>
<td>
<p><a href="#topic+OptimInstance">OptimInstance</a></p>
</td></tr>
</table>

<hr>
<h2 id='bb_optimize'>Black-Box Optimization</h2><span id='topic+bb_optimize'></span><span id='topic+bb_optimize.function'></span><span id='topic+bb_optimize.Objective'></span>

<h3>Description</h3>

<p>This function optimizes a function or <a href="#topic+Objective">Objective</a> with a given method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bb_optimize(
  x,
  method = "random_search",
  max_evals = 1000,
  max_time = NULL,
  ...
)

## S3 method for class ''function''
bb_optimize(
  x,
  method = "random_search",
  max_evals = 1000,
  max_time = NULL,
  lower = NULL,
  upper = NULL,
  maximize = FALSE,
  ...
)

## S3 method for class 'Objective'
bb_optimize(
  x,
  method = "random_search",
  max_evals = 1000,
  max_time = NULL,
  search_space = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bb_optimize_+3A_x">x</code></td>
<td>
<p>(<code>function</code> | <a href="#topic+Objective">Objective</a>).</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_method">method</code></td>
<td>
<p>(<code>character(1)</code> | <a href="#topic+Optimizer">Optimizer</a>)<br />
Key to retrieve optimizer from <a href="#topic+mlr_optimizers">mlr_optimizers</a> dictionary or <a href="#topic+Optimizer">Optimizer</a>.</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_max_evals">max_evals</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of allowed evaluations.</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_max_time">max_time</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Maximum allowed time in seconds.</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to objective function. Ignored if <a href="#topic+Objective">Objective</a> is
optimized.</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_lower">lower</code></td>
<td>
<p>(<code>numeric()</code>)<br />
Lower bounds on the parameters. If named, names are used to create the
domain.</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_upper">upper</code></td>
<td>
<p>(<code>numeric()</code>)<br />
Upper bounds on the parameters.</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_maximize">maximize</code></td>
<td>
<p>(<code>logical()</code>)<br />
Logical vector used to create the codomain e.g. c(TRUE, FALSE) -&gt; ps(y1 = p_dbl(tags = &quot;maximize&quot;), y2 = pd_dbl(tags = &quot;minimize&quot;)).
If named, names are used to create the codomain.</p>
</td></tr>
<tr><td><code id="bb_optimize_+3A_search_space">search_space</code></td>
<td>
<p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of
</p>

<ul>
<li> <p><code>"par"</code> - Best found parameters
</p>
</li>
<li> <p><code>"value"</code> - Optimal outcome
</p>
</li>
<li> <p><code>"instance"</code> - <a href="#topic+OptimInstanceSingleCrit">OptimInstanceSingleCrit</a> | <a href="#topic+OptimInstanceMultiCrit">OptimInstanceMultiCrit</a>
</p>
</li></ul>



<h3>Note</h3>

<p>If both <code>max_evals</code> and <code>max_time</code> are <code>NULL</code>, <a href="#topic+TerminatorNone">TerminatorNone</a> is used. This
is useful if the <a href="#topic+Optimizer">Optimizer</a> can terminate itself. If both are given,
<a href="#topic+TerminatorCombo">TerminatorCombo</a> is created and the optimization stops if the time or
evaluation budget is exhausted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># function and bounds
fun = function(xs) {
  -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + 10
}

bb_optimize(fun, lower = c(-10, -5), upper = c(10, 5), max_evals = 10)

# function and constant
fun = function(xs, c) {
  -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + c
}

bb_optimize(fun, lower = c(-10, -5), upper = c(10, 5), max_evals = 10, c = 1)

# objective
fun = function(xs) {
  c(z = -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + 10)
}

# define domain and codomain using a `ParamSet` from paradox
domain = ps(x1 = p_dbl(-10, 10), x2 = p_dbl(-5, 5))
codomain = ps(z = p_dbl(tags = "minimize"))
objective = ObjectiveRFun$new(fun, domain, codomain)

bb_optimize(objective, method = "random_search", max_evals = 10)
</code></pre>

<hr>
<h2 id='bbotk_assertions'>Assertion for bbotk objects</h2><span id='topic+bbotk_assertions'></span><span id='topic+assert_terminator'></span><span id='topic+assert_terminable'></span><span id='topic+assert_set'></span><span id='topic+assert_optimizer'></span><span id='topic+assert_instance_properties'></span>

<h3>Description</h3>

<p>Most assertion functions ensure the right class attribute, and optionally
additional properties. Additionally, the following compound assertions are
implemented:
</p>

<ul>
<li> <p><code>assert_terminable(terminator, instance)</code><br />
(<a href="#topic+Terminator">Terminator</a>, <a href="#topic+OptimInstance">OptimInstance</a>) -&gt; <code>NULL</code><br />
Checks if the terminator is applicable to the optimization.
</p>
</li>
<li> <p><code>assert_instance_properties(optimizer, instance)</code><br />
(<a href="#topic+Optimizer">Optimizer</a>, <a href="#topic+OptimInstance">OptimInstance</a>) -&gt; <code>NULL</code><br />
Checks if the instance is applicable to the optimizer.
</p>
</li></ul>

<p>If an assertion fails, an exception is raised. Otherwise, the input object is
returned invisibly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_terminator(terminator, instance = NULL)

assert_terminable(terminator, instance)

assert_set(x, empty = TRUE, .var.name = vname(x))

assert_optimizer(optimizer)

assert_instance_properties(optimizer, inst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbotk_assertions_+3A_terminator">terminator</code></td>
<td>
<p>(<a href="#topic+Terminator">Terminator</a>).</p>
</td></tr>
<tr><td><code id="bbotk_assertions_+3A_instance">instance</code></td>
<td>
<p>(<a href="#topic+OptimInstance">OptimInstance</a>).</p>
</td></tr>
<tr><td><code id="bbotk_assertions_+3A_x">x</code></td>
<td>
<p>(any)</p>
</td></tr>
<tr><td><code id="bbotk_assertions_+3A_empty">empty</code></td>
<td>
<p>(<code>logical(1)</code>)</p>
</td></tr>
<tr><td><code id="bbotk_assertions_+3A_.var.name">.var.name</code></td>
<td>
<p>(<code>character(1)</code>)</p>
</td></tr>
<tr><td><code id="bbotk_assertions_+3A_optimizer">optimizer</code></td>
<td>
<p>(<a href="#topic+Optimizer">Optimizer</a>).</p>
</td></tr>
</table>

<hr>
<h2 id='bbotk_reflections'>Reflections for bbotk</h2><span id='topic+bbotk_reflections'></span>

<h3>Description</h3>

<p>Environment which stores various information to allow objects to examine and
introspect their structure and properties
(c.f. <a href="https://www.wikiwand.com/en/Reflection_(computer_programming)">Reflections</a>).
</p>
<p>This environment be modified by third-party packages.
</p>
<p>The following objects are set by <a href="https://CRAN.R-project.org/package=bbotk"><span class="pkg">bbotk</span></a>:
</p>

<ul>
<li> <p><code>optimizer_properties</code> (<code>character()</code>)<br />
Properties of an optimizer, e.g. &quot;dependencies&quot;.
</p>
</li>
<li> <p><code>objective_properties</code> (<code>character()</code>)<br />
Properties of an objective, e.g. &quot;noisy&quot;.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bbotk_reflections
</code></pre>


<h3>Format</h3>

<p><a href="base.html#topic+environment">environment</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ls.str(bbotk_reflections)
</code></pre>

<hr>
<h2 id='bbotk-package'>bbotk: Black-Box Optimization Toolkit</h2><span id='topic+bbotk'></span><span id='topic+bbotk-package'></span>

<h3>Description</h3>

<p>Features highly configurable search spaces via the 'paradox' package and optimizes every user-defined objective function. The package includes several optimization algorithms e.g. Random Search, Iterated Racing, Bayesian Optimization (in 'mlr3mbo') and Hyperband (in 'mlr3hyperband'). bbotk is the base package of 'mlr3tuning', 'mlr3fselect' and 'miesmuschel'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jakob Richter <a href="mailto:jakob1richter@gmail.com">jakob1richter@gmail.com</a> (<a href="https://orcid.org/0000-0003-4481-5554">ORCID</a>)
</p>
</li>
<li><p> Michel Lang <a href="mailto:michellang@gmail.com">michellang@gmail.com</a> (<a href="https://orcid.org/0000-0001-9754-0393">ORCID</a>)
</p>
</li>
<li><p> Bernd Bischl <a href="mailto:bernd_bischl@gmx.net">bernd_bischl@gmx.net</a> (<a href="https://orcid.org/0000-0001-6002-6980">ORCID</a>)
</p>
</li>
<li><p> Martin Binder <a href="mailto:martin.binder@mail.com">martin.binder@mail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Olaf Mersmann <a href="mailto:olafm@statistik.tu-dortmund.de">olafm@statistik.tu-dortmund.de</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://bbotk.mlr-org.com">https://bbotk.mlr-org.com</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/bbotk">https://github.com/mlr-org/bbotk</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/bbotk/issues">https://github.com/mlr-org/bbotk/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bbotk.backup'>Backup Archive Callback</h2><span id='topic+bbotk.backup'></span>

<h3>Description</h3>

<p>This <a href="#topic+CallbackOptimization">CallbackOptimization</a> writes the <a href="#topic+Archive">Archive</a> after each batch to disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clbk("bbotk.backup", path = "backup.rds")
</code></pre>

<hr>
<h2 id='branin'>Branin Function</h2><span id='topic+branin'></span><span id='topic+branin_wu'></span>

<h3>Description</h3>

<p>Classic 2-D Branin function with noise <code>branin(x1, x2, noise)</code> and Branin function with fidelity parameter <code>branin_wu(x1, x2, fidelity)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branin(x1, x2, noise = 0)

branin_wu(x1, x2, fidelity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branin_+3A_x1">x1</code></td>
<td>
<p>(<code>numeric()</code>).</p>
</td></tr>
<tr><td><code id="branin_+3A_x2">x2</code></td>
<td>
<p>(<code>numeric()</code>).</p>
</td></tr>
<tr><td><code id="branin_+3A_noise">noise</code></td>
<td>
<p>(<code>numeric()</code>).</p>
</td></tr>
<tr><td><code id="branin_+3A_fidelity">fidelity</code></td>
<td>
<p>(<code>numeric()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric()</code>
</p>


<h3>Source</h3>

<p>Wu J, Toscano-Palmerin S, Frazier PI, Wilson AG (2019).
&ldquo;Practical Multi-fidelity Bayesian Optimization for Hyperparameter Tuning.&rdquo;
1903.04703.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>branin(x1 = 12, x2 = 2, noise = 0.05)
branin_wu(x1 = 12, x2 = 2, fidelity = 1)
</code></pre>

<hr>
<h2 id='callback_optimization'>Create Optimization Callback</h2><span id='topic+callback_optimization'></span>

<h3>Description</h3>

<p>Function to create a <a href="#topic+CallbackOptimization">CallbackOptimization</a>.
</p>
<p>Optimization callbacks can be called from different stages of optimization process.
The stages are prefixed with <code style="white-space: pre;">&#8288;on_*&#8288;</code>.
</p>
<div class="sourceCode"><pre>Start Optimization
     - on_optimization_begin
    Start Optimizer Batch
         - on_optimizer_before_eval
         - on_optimizer_after_eval
    End Optimizer Batch
     - on_result
     - on_optimization_end
End Optimization
</pre></div>
<p>See also the section on parameters for more information on the stages.
A optimization callback works with <a href="#topic+ContextOptimization">ContextOptimization</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callback_optimization(
  id,
  label = NA_character_,
  man = NA_character_,
  on_optimization_begin = NULL,
  on_optimizer_before_eval = NULL,
  on_optimizer_after_eval = NULL,
  on_result = NULL,
  on_optimization_end = NULL,
  fields = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callback_optimization_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_label">label</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Label for the new instance.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_man">man</code></td>
<td>
<p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_on_optimization_begin">on_optimization_begin</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called at the beginning of the optimization.
Called in <code>Optimizer$optimize()</code>.
The functions must have two arguments named <code>callback</code> and <code>context</code>.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_on_optimizer_before_eval">on_optimizer_before_eval</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after the optimizer proposes points.
Called in <code>OptimInstance$eval_batch()</code>.
The functions must have two arguments named <code>callback</code> and <code>context</code>.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_on_optimizer_after_eval">on_optimizer_after_eval</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after points are evaluated.
Called in <code>OptimInstance$eval_batch()</code>.
The functions must have two arguments named <code>callback</code> and <code>context</code>.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_on_result">on_result</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after result are written.
Called in <code>OptimInstance$assign_result()</code>.
The functions must have two arguments named <code>callback</code> and <code>context</code>.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_on_optimization_end">on_optimization_end</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called at the end of the optimization.
Called in <code>Optimizer$optimize()</code>.
The functions must have two arguments named <code>callback</code> and <code>context</code>.</p>
</td></tr>
<tr><td><code id="callback_optimization_+3A_fields">fields</code></td>
<td>
<p>(list of <code>any</code>)<br />
List of additional fields.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A callback can write data to its state (<code style="white-space: pre;">&#8288;$state&#8288;</code>), e.g. settings that affect the callback itself.
The <a href="#topic+ContextOptimization">ContextOptimization</a> allows to modify the instance, archive, optimizer and final result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># write archive to disk
callback_optimization("bbotk.backup",
  on_optimization_end = function(callback, context) {
    saveRDS(context$instance$archive, "archive.rds")
  }
)
</code></pre>

<hr>
<h2 id='CallbackOptimization'>Create Optimization Callback</h2><span id='topic+CallbackOptimization'></span>

<h3>Description</h3>

<p>Specialized <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a> for optimization.
Callbacks allow to customize the behavior of processes in bbotk.
The <code><a href="#topic+callback_optimization">callback_optimization()</a></code> function creates a <a href="#topic+CallbackOptimization">CallbackOptimization</a>.
Predefined callbacks are stored in the <a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_callbacks">mlr_callbacks</a> and can be retrieved with <code><a href="#topic+clbk">clbk()</a></code>.
For more information on optimization callbacks see <code><a href="#topic+callback_optimization">callback_optimization()</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a></code> -&gt; <code>CallbackOptimization</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>on_optimization_begin</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called at the beginning of the optimization.
Called in <code>Optimizer$optimize()</code>.</p>
</dd>
<dt><code>on_optimizer_before_eval</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after the optimizer proposes points.
Called in <code>OptimInstance$eval_batch()</code>.</p>
</dd>
<dt><code>on_optimizer_after_eval</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after points are evaluated.
Called in <code>OptimInstance$eval_batch()</code>.</p>
</dd>
<dt><code>on_result</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after result are written.
Called in <code>OptimInstance$assign_result()</code>.</p>
</dd>
<dt><code>on_optimization_end</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called at the end of the optimization.
Called in <code>Optimizer$optimize()</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CallbackOptimization-clone"><code>CallbackOptimization$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="call"><a href='../../mlr3misc/html/Callback.html#method-Callback-call'><code>mlr3misc::Callback$call()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="format"><a href='../../mlr3misc/html/Callback.html#method-Callback-format'><code>mlr3misc::Callback$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="help"><a href='../../mlr3misc/html/Callback.html#method-Callback-help'><code>mlr3misc::Callback$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="initialize"><a href='../../mlr3misc/html/Callback.html#method-Callback-initialize'><code>mlr3misc::Callback$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="print"><a href='../../mlr3misc/html/Callback.html#method-Callback-print'><code>mlr3misc::Callback$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CallbackOptimization-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CallbackOptimization$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># write archive to disk
callback_optimization("bbotk.backup",
  on_optimization_end = function(callback, context) {
    saveRDS(context$instance$archive, "archive.rds")
  }
)
</code></pre>

<hr>
<h2 id='Codomain'>Codomain of Function</h2><span id='topic+Codomain'></span>

<h3>Description</h3>

<p>A ParamSet defining the codomain of a function. The parameter
set must contain at least one target parameter tagged with <code>"minimize"</code> or
<code>"maximize"</code>. The codomain may contain extra parameters which are ignored
when calling the <a href="#topic+Archive">Archive</a> methods <code style="white-space: pre;">&#8288;$best()&#8288;</code>, <code style="white-space: pre;">&#8288;$nds_selection()&#8288;</code> and
<code style="white-space: pre;">&#8288;$cols_y&#8288;</code>. This class is usually constructed internally from a
ParamSet when <a href="#topic+Objective">Objective</a> is initialized.
</p>


<h3>Super class</h3>

<p><code><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a></code> -&gt; <code>Codomain</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>is_target</code></dt><dd><p>(named <code>logical()</code>)<br />
Position is <code>TRUE</code> for target parameters.</p>
</dd>
<dt><code>target_length</code></dt><dd><p>(<code>integer()</code>)<br />
Returns number of target parameters.</p>
</dd>
<dt><code>target_ids</code></dt><dd><p>(<code>character()</code>)<br />
IDs of contained target parameters.</p>
</dd>
<dt><code>target_tags</code></dt><dd><p>(named <code>list()</code> of <code>character()</code>)<br />
Tags of target parameters.</p>
</dd>
<dt><code>maximization_to_minimization</code></dt><dd><p>(<code>integer()</code>)<br />
Returns a numeric vector with values -1 and 1. Multiply with the outcome
of a maximization problem to turn it into a minimization problem.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Codomain-new"><code>Codomain$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Codomain-clone"><code>Codomain$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="add"><a href='../../paradox/html/ParamSet.html#method-ParamSet-add'><code>paradox::ParamSet$add()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="add_dep"><a href='../../paradox/html/ParamSet.html#method-ParamSet-add_dep'><code>paradox::ParamSet$add_dep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="assert"><a href='../../paradox/html/ParamSet.html#method-ParamSet-assert'><code>paradox::ParamSet$assert()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="assert_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-assert_dt'><code>paradox::ParamSet$assert_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check'><code>paradox::ParamSet$check()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check_dt'><code>paradox::ParamSet$check_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="format"><a href='../../paradox/html/ParamSet.html#method-ParamSet-format'><code>paradox::ParamSet$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="get_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-get_values'><code>paradox::ParamSet$get_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="ids"><a href='../../paradox/html/ParamSet.html#method-ParamSet-ids'><code>paradox::ParamSet$ids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="print"><a href='../../paradox/html/ParamSet.html#method-ParamSet-print'><code>paradox::ParamSet$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="search_space"><a href='../../paradox/html/ParamSet.html#method-ParamSet-search_space'><code>paradox::ParamSet$search_space()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="set_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-set_values'><code>paradox::ParamSet$set_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="subset"><a href='../../paradox/html/ParamSet.html#method-ParamSet-subset'><code>paradox::ParamSet$subset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test'><code>paradox::ParamSet$test()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test_dt'><code>paradox::ParamSet$test_dt()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Codomain-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Codomain$new(params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>(<code>list()</code>)<br />
Named list with which to initialize the codomain.
This argument is analogous to ParamSet's <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> <code>params</code> argument.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Codomain-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Codomain$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# define objective function
fun = function(xs) {
  c(y = -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + 10)
}

# set domain
domain = ps(
  x1 = p_dbl(-10, 10),
  x2 = p_dbl(-5, 5)
)

# set codomain
codomain = ps(
  y = p_dbl(tags = "maximize"),
  time = p_dbl()
)

# create Objective object
objective = ObjectiveRFun$new(
  fun = fun,
  domain = domain,
  codomain = codomain,
  properties = "deterministic"
)
</code></pre>

<hr>
<h2 id='ContextOptimization'>Optimization Context</h2><span id='topic+ContextOptimization'></span>

<h3>Description</h3>

<p>The <a href="#topic+ContextOptimization">ContextOptimization</a> allows <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a>s to access and modify data while optimization.
See section on active bindings for a list of modifiable objects.
See <code><a href="#topic+callback_optimization">callback_optimization()</a></code> for a list of stages which access <a href="#topic+ContextOptimization">ContextOptimization</a>.
</p>


<h3>Super class</h3>

<p><code><a href="mlr3misc.html#topic+Context">mlr3misc::Context</a></code> -&gt; <code>ContextOptimization</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>instance</code></dt><dd><p>(<a href="#topic+OptimInstance">OptimInstance</a>).</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>(<a href="#topic+Optimizer">Optimizer</a>).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>xdt</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
The points of the latest batch.
Contains the values in the search space i.e. transformations are not yet applied.</p>
</dd>
<dt><code>result</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
The result of the optimization.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ContextOptimization-new"><code>ContextOptimization$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ContextOptimization-clone"><code>ContextOptimization$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Context" data-id="format"><a href='../../mlr3misc/html/Context.html#method-Context-format'><code>mlr3misc::Context$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Context" data-id="print"><a href='../../mlr3misc/html/Context.html#method-Context-print'><code>mlr3misc::Context$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ContextOptimization-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ContextOptimization$new(instance, optimizer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instance</code></dt><dd><p>(<a href="#topic+OptimInstance">OptimInstance</a>).</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>(<a href="#topic+Optimizer">Optimizer</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ContextOptimization-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ContextOptimization$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='is_dominated'>Calculate which points are dominated</h2><span id='topic+is_dominated'></span>

<h3>Description</h3>

<p>Returns which points from a set are dominated by another point in the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dominated(ymat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dominated_+3A_ymat">ymat</code></td>
<td>
<p>(<code>matrix()</code>) <br />
A numeric matrix. Each column (!) contains one point.</p>
</td></tr>
</table>

<hr>
<h2 id='mlr_optimizers'>Dictionary of Optimizer</h2><span id='topic+mlr_optimizers'></span>

<h3>Description</h3>

<p>A simple <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> storing objects of class <a href="#topic+Optimizer">Optimizer</a>.
Each optimizer has an associated help page, see <code>mlr_optimizer_[id]</code>.
</p>
<p>This dictionary can get populated with additional optimizer by add-on packages.
</p>
<p>For a more convenient way to retrieve and construct optimizer, see <code><a href="#topic+opt">opt()</a></code>/<code><a href="#topic+opts">opts()</a></code>.
</p>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> object inheriting from <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>Methods</h3>

<p>See <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>S3 methods</h3>


<ul>
<li> <p><code>as.data.table(dict, ..., objects = FALSE)</code><br />
<a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> -&gt; <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code><br />
Returns a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with fields &quot;key&quot;, &quot;label&quot;, &quot;param_classes&quot;, &quot;properties&quot; and &quot;packages&quot; as columns.
If <code>objects</code> is set to <code>TRUE</code>, the constructed objects are returned in the list column named <code>object</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Sugar functions: <code><a href="#topic+opt">opt()</a></code>, <code><a href="#topic+opts">opts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.data.table(mlr_optimizers)
mlr_optimizers$get("random_search")
opt("random_search")
</code></pre>

<hr>
<h2 id='mlr_optimizers_cmaes'>Optimization via Covariance Matrix Adaptation Evolution Strategy</h2><span id='topic+mlr_optimizers_cmaes'></span><span id='topic+OptimizerCmaes'></span>

<h3>Description</h3>

<p><code>OptimizerCmaes</code> class that implements CMA-ES. Calls <code><a href="adagio.html#topic+cmaes">adagio::pureCMAES()</a></code>
from package <a href="https://CRAN.R-project.org/package=adagio"><span class="pkg">adagio</span></a>. The algorithm is typically applied to search
space dimensions between three and fifty. Lower search space dimensions might
crash.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Optimizer">Optimizer</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_optimizers">mlr_optimizers</a> or with the associated sugar function <code><a href="#topic+opt">opt()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("cmaes")
opt("cmaes")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>sigma</code></dt><dd><p><code>numeric(1)</code></p>
</dd>
<dt><code>start_values</code></dt><dd><p><code>character(1)</code><br />
Create <code>random</code> start values or based on <code>center</code> of search space? In the
latter case, it is the center of the parameters before a trafo is applied.</p>
</dd>
</dl>

<p>For the meaning of the control parameters, see <code><a href="adagio.html#topic+cmaes">adagio::pureCMAES()</a></code>. Note
that we have removed all control parameters which refer to the termination of
the algorithm and where our terminators allow to obtain the same behavior.
</p>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerCmaes</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerCmaes-new"><code>OptimizerCmaes$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerCmaes-clone"><code>OptimizerCmaes$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerCmaes-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerCmaes$new()</pre></div>


<hr>
<a id="method-OptimizerCmaes-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerCmaes$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("adagio")) {
  search_space = domain = ps(
    x1 = p_dbl(-10, 10),
    x2 = p_dbl(-5, 5)
  )

  codomain = ps(y = p_dbl(tags = "maximize"))

  objective_function = function(xs) {
    c(y = -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + 10)
  }

  objective = ObjectiveRFun$new(
    fun = objective_function,
    domain = domain,
    codomain = codomain)

  instance = OptimInstanceSingleCrit$new(
    objective = objective,
    search_space = search_space,
    terminator = trm("evals", n_evals = 10))

  optimizer = opt("cmaes")

  # modifies the instance by reference
  optimizer$optimize(instance)

  # returns best scoring evaluation
  instance$result

  # allows access of data.table of full path of all evaluations
  as.data.table(instance$archive$data)
}
</code></pre>

<hr>
<h2 id='mlr_optimizers_design_points'>Optimization via Design Points</h2><span id='topic+mlr_optimizers_design_points'></span><span id='topic+OptimizerDesignPoints'></span>

<h3>Description</h3>

<p><code>OptimizerDesignPoints</code> class that implements optimization w.r.t. fixed
design points. We simply search over a set of points fully specified by the
user. The points in the design are evaluated in order as given.
</p>
<p>In order to support general termination criteria and parallelization, we
evaluate points in a batch-fashion of size <code>batch_size</code>. Larger batches mean
we can parallelize more, smaller batches imply a more fine-grained checking
of termination criteria.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Optimizer">Optimizer</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_optimizers">mlr_optimizers</a> or with the associated sugar function <code><a href="#topic+opt">opt()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("design_points")
opt("design_points")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>batch_size</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of configurations to try in a batch.</p>
</dd>
<dt><code>design</code></dt><dd><p><a href="data.table.html#topic+data.table">data.table::data.table</a><br />
Design points to try in search, one per row.</p>
</dd>
</dl>



<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerDesignPoints</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerDesignPoints-new"><code>OptimizerDesignPoints$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerDesignPoints-clone"><code>OptimizerDesignPoints$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerDesignPoints-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerDesignPoints$new()</pre></div>


<hr>
<a id="method-OptimizerDesignPoints-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerDesignPoints$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
search_space = domain = ps(x = p_dbl(lower = -1, upper = 1))

codomain = ps(y = p_dbl(tags = "minimize"))

objective_function = function(xs) {
  list(y = as.numeric(xs)^2)
}

objective = ObjectiveRFun$new(
  fun = objective_function,
  domain = domain,
  codomain = codomain)

instance = OptimInstanceSingleCrit$new(
  objective = objective,
  search_space = search_space,
  terminator = trm("evals", n_evals = 10))

design = data.table(x = c(0, 1))

optimizer = opt("design_points", design = design)

# Modifies the instance by reference
optimizer$optimize(instance)

# Returns best scoring evaluation
instance$result

# Allows access of data.table of full path of all evaluations
as.data.table(instance$archive)
</code></pre>

<hr>
<h2 id='mlr_optimizers_focus_search'>Optimization via Focus Search</h2><span id='topic+mlr_optimizers_focus_search'></span><span id='topic+OptimizerFocusSearch'></span>

<h3>Description</h3>

<p><code>OptimizerFocusSearch</code> class that implements a Focus Search.
</p>
<p>Focus Search starts with evaluating <code>n_points</code> drawn uniformly at random.
For 1 to <code>maxit</code> batches, <code>n_points</code> are then drawn uniformly at random and
if the best value of a batch outperforms the previous best value over all
batches evaluated so far, the search space is shrinked around this new best
point prior to the next batch being sampled and evaluated.
</p>
<p>For details on the shrinking, see <a href="#topic+shrink_ps">shrink_ps</a>.
</p>
<p>Depending on the <a href="#topic+Terminator">Terminator</a> this procedure simply restarts after <code>maxit</code> is
reached.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Optimizer">Optimizer</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_optimizers">mlr_optimizers</a> or with the associated sugar function <code><a href="#topic+opt">opt()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("focus_search")
opt("focus_search")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>n_points</code></dt><dd><p><code>integer(1)</code><br />
Number of points to evaluate in each random search batch.</p>
</dd>
<dt><code>maxit</code></dt><dd><p><code>integer(1)</code><br />
Number of random search batches to run.</p>
</dd>
</dl>



<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerFocusSearch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerFocusSearch-new"><code>OptimizerFocusSearch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerFocusSearch-clone"><code>OptimizerFocusSearch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerFocusSearch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerFocusSearch$new()</pre></div>


<hr>
<a id="method-OptimizerFocusSearch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerFocusSearch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>search_space = domain = ps(x = p_dbl(lower = -1, upper = 1))

codomain = ps(y = p_dbl(tags = "minimize"))

objective_function = function(xs) {
  list(y = as.numeric(xs)^2)
}

objective = ObjectiveRFun$new(
 fun = objective_function,
 domain = domain,
 codomain = codomain)

instance = OptimInstanceSingleCrit$new(
 objective = objective,
 search_space = search_space,
 terminator = trm("evals", n_evals = 10))


optimizer = opt("focus_search")

# modifies the instance by reference
optimizer$optimize(instance)

# returns best scoring evaluation
instance$result

# allows access of data.table of full path of all evaluations
as.data.table(instance$archive$data)
</code></pre>

<hr>
<h2 id='mlr_optimizers_gensa'>Optimization via Generalized Simulated Annealing</h2><span id='topic+mlr_optimizers_gensa'></span><span id='topic+OptimizerGenSA'></span>

<h3>Description</h3>

<p><code>OptimizerGenSA</code> class that implements generalized simulated annealing. Calls
<code><a href="GenSA.html#topic+GenSA">GenSA::GenSA()</a></code> from package <a href="https://CRAN.R-project.org/package=GenSA"><span class="pkg">GenSA</span></a>.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Optimizer">Optimizer</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_optimizers">mlr_optimizers</a> or with the associated sugar function <code><a href="#topic+opt">opt()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("gensa")
opt("gensa")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>smooth</code></dt><dd><p><code>logical(1)</code></p>
</dd>
<dt><code>temperature</code></dt><dd><p><code>numeric(1)</code></p>
</dd>
<dt><code>acceptance.param</code></dt><dd><p><code>numeric(1)</code></p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>logical(1)</code></p>
</dd>
<dt><code>trace.mat</code></dt><dd><p><code>logical(1)</code></p>
</dd>
</dl>

<p>For the meaning of the control parameters, see <code><a href="GenSA.html#topic+GenSA">GenSA::GenSA()</a></code>. Note that we
have removed all control parameters which refer to the termination of the
algorithm and where our terminators allow to obtain the same behavior.
</p>
<p>In contrast to the <code><a href="GenSA.html#topic+GenSA">GenSA::GenSA()</a></code> defaults, we set <code>trace.mat = FALSE</code>.
Note that <code><a href="GenSA.html#topic+GenSA">GenSA::GenSA()</a></code> uses <code>smooth = TRUE</code> as a default.
In the case of using this optimizer for Hyperparameter Optimization you may
want to set <code>smooth = FALSE</code>.
</p>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerGenSA</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerGenSA-new"><code>OptimizerGenSA$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerGenSA-clone"><code>OptimizerGenSA$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerGenSA-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerGenSA$new()</pre></div>


<hr>
<a id="method-OptimizerGenSA-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerGenSA$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Tsallis C, Stariolo DA (1996).
&ldquo;Generalized simulated annealing.&rdquo;
<em>Physica A: Statistical Mechanics and its Applications</em>, <b>233</b>(1-2), 395&ndash;406.
<a href="https://doi.org/10.1016/s0378-4371%2896%2900271-3">doi:10.1016/s0378-4371(96)00271-3</a>.
</p>
<p>Xiang Y, Gubian S, Suomela B, Hoeng J (2013).
&ldquo;Generalized Simulated Annealing for Global Optimization: The GenSA Package.&rdquo;
<em>The R Journal</em>, <b>5</b>(1), 13.
<a href="https://doi.org/10.32614/rj-2013-002">doi:10.32614/rj-2013-002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("GenSA")) {

  search_space = domain = ps(x = p_dbl(lower = -1, upper = 1))

  codomain = ps(y = p_dbl(tags = "minimize"))

  objective_function = function(xs) {
    list(y = as.numeric(xs)^2)
  }

  objective = ObjectiveRFun$new(
    fun = objective_function,
    domain = domain,
    codomain = codomain)

  instance = OptimInstanceSingleCrit$new(
    objective = objective,
    search_space = search_space,
    terminator = trm("evals", n_evals = 10))

  optimizer = opt("gensa")

  # Modifies the instance by reference
  optimizer$optimize(instance)

  # Returns best scoring evaluation
  instance$result

  # Allows access of data.table of full path of all evaluations
  as.data.table(instance$archive$data)
}
</code></pre>

<hr>
<h2 id='mlr_optimizers_grid_search'>Optimization via Grid Search</h2><span id='topic+mlr_optimizers_grid_search'></span><span id='topic+OptimizerGridSearch'></span>

<h3>Description</h3>

<p><code>OptimizerGridSearch</code> class that implements grid search. The grid is
constructed as a Cartesian product over discretized values per parameter, see
<code><a href="paradox.html#topic+generate_design_grid">paradox::generate_design_grid()</a></code>. The points of the grid are evaluated in a
random order.
</p>
<p>In order to support general termination criteria and parallelization, we
evaluate points in a batch-fashion of size <code>batch_size</code>. Larger batches mean
we can parallelize more, smaller batches imply a more fine-grained checking
of termination criteria.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Optimizer">Optimizer</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_optimizers">mlr_optimizers</a> or with the associated sugar function <code><a href="#topic+opt">opt()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("grid_search")
opt("grid_search")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>resolution</code></dt><dd><p><code>integer(1)</code><br />
Resolution of the grid, see <code><a href="paradox.html#topic+generate_design_grid">paradox::generate_design_grid()</a></code>.</p>
</dd>
<dt><code>param_resolutions</code></dt><dd><p>named <code>integer()</code><br />
Resolution per parameter, named by parameter ID, see
<code><a href="paradox.html#topic+generate_design_grid">paradox::generate_design_grid()</a></code>.</p>
</dd>
<dt><code>batch_size</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of points to try in a batch.</p>
</dd>
</dl>



<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerGridSearch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerGridSearch-new"><code>OptimizerGridSearch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerGridSearch-clone"><code>OptimizerGridSearch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerGridSearch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerGridSearch$new()</pre></div>


<hr>
<a id="method-OptimizerGridSearch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerGridSearch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>search_space = domain = ps(x = p_dbl(lower = -1, upper = 1))

codomain = ps(y = p_dbl(tags = "minimize"))

objective_function = function(xs) {
  list(y = as.numeric(xs)^2)
}

objective = ObjectiveRFun$new(
 fun = objective_function,
 domain = domain,
 codomain = codomain)

instance = OptimInstanceSingleCrit$new(
 objective = objective,
 search_space = search_space,
 terminator = trm("evals", n_evals = 10))


optimizer = opt("grid_search")

# modifies the instance by reference
optimizer$optimize(instance)

# returns best scoring evaluation
instance$result

# allows access of data.table of full path of all evaluations
as.data.table(instance$archive$data)
</code></pre>

<hr>
<h2 id='mlr_optimizers_irace'>Optimization via Iterated Racing</h2><span id='topic+mlr_optimizers_irace'></span><span id='topic+OptimizerIrace'></span>

<h3>Description</h3>

<p><code>OptimizerIrace</code> class that implements iterated racing. Calls
<code><a href="irace.html#topic+irace">irace::irace()</a></code> from package <a href="https://CRAN.R-project.org/package=irace"><span class="pkg">irace</span></a>.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>instances</code></dt><dd><p><code>list()</code><br />
A list of instances where the configurations executed on.</p>
</dd>
<dt><code>targetRunnerParallel</code></dt><dd><p><code style="white-space: pre;">&#8288;function()&#8288;</code><br />
A function that executes the objective function with a specific parameter
configuration and instance. A default function is provided, see section
&quot;Target Runner and Instances&quot;.</p>
</dd>
</dl>

<p>For the meaning of all other parameters, see <code><a href="irace.html#topic+defaultScenario">irace::defaultScenario()</a></code>. Note
that we have removed all control parameters which refer to the termination of
the algorithm. Use <a href="#topic+TerminatorEvals">TerminatorEvals</a> instead. Other terminators do not work
with <code>OptimizerIrace</code>.
</p>
<p>In contrast to <code><a href="irace.html#topic+defaultScenario">irace::defaultScenario()</a></code>, we set <code>digits = 15</code>.
This represents double parameters with a higher precision and avoids rounding errors.
</p>


<h3>Target Runner and Instances</h3>

<p>The irace package uses a <code>targetRunner</code> script or R function to evaluate a
configuration on a particular instance. Usually it is not necessary to
specify a <code>targetRunner</code> function when using <code>OptimizerIrace</code>. A default
function is used that forwards several configurations and instances to the
user defined objective function. As usually, the user defined function has
a <code>xs</code>, <code>xss</code> or <code>xdt</code> parameter depending on the used <a href="#topic+Objective">Objective</a> class.
For irace, the function needs an additional <code>instances</code> parameter.
</p>
<div class="sourceCode"><pre>fun = function(xs, instances) {
 # function to evaluate configuration in `xs` on instance `instances`
}
</pre></div>


<h3>Archive</h3>

<p>The <a href="#topic+Archive">Archive</a> holds the following additional columns:
</p>

<ul>
<li> <p><code>"race"</code> (<code>integer(1)</code>)<br />
Race iteration.
</p>
</li>
<li> <p><code>"step"</code> (<code>integer(1)</code>)<br />
Step number of race.
</p>
</li>
<li> <p><code>"instance"</code> (<code>integer(1)</code>)<br />
Identifies instances across races and steps.
</p>
</li>
<li> <p><code>"configuration"</code> (<code>integer(1)</code>)<br />
Identifies configurations across races and steps.
</p>
</li></ul>



<h3>Result</h3>

<p>The optimization result (<code>instance$result</code>) is the best performing elite of
the final race. The reported performance is the average performance estimated
on all used instances.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Optimizer">Optimizer</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_optimizers">mlr_optimizers</a> or with the associated sugar function <code><a href="#topic+opt">opt()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("irace")
opt("irace")
</pre></div>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerIrace</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerIrace-new"><code>OptimizerIrace$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerIrace-clone"><code>OptimizerIrace$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerIrace-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerIrace$new()</pre></div>


<hr>
<a id="method-OptimizerIrace-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerIrace$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Lopez-Ibanez M, Dubois-Lacoste J, Caceres LP, Birattari M, Stuetzle T (2016).
&ldquo;The irace package: Iterated racing for automatic algorithm configuration.&rdquo;
<em>Operations Research Perspectives</em>, <b>3</b>, 43&ndash;58.
<a href="https://doi.org/10.1016/j.orp.2016.09.002">doi:10.1016/j.orp.2016.09.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

search_space = domain = ps(
  x1 = p_dbl(-5, 10),
  x2 = p_dbl(0, 15)
)

codomain = ps(y = p_dbl(tags = "minimize"))

# branin function with noise
# the noise generates different instances of the branin function
# the noise values are passed via the `instances` parameter
fun = function(xdt, instances) {
  ys = branin(xdt[["x1"]], xdt[["x2"]], noise = as.numeric(instances))
  data.table(y = ys)
}

# define objective with instances as a constant
objective = ObjectiveRFunDt$new(
 fun = fun,
 domain = domain,
 codomain = codomain,
 constants = ps(instances = p_uty()))

instance = OptimInstanceSingleCrit$new(
  objective = objective,
  search_space = search_space,
  terminator = trm("evals", n_evals = 1000))

# create instances of branin function
instances = rnorm(10, mean = 0, sd = 0.1)

# load optimizer irace and set branin instances
optimizer = opt("irace", instances = instances)

# modifies the instance by reference
optimizer$optimize(instance)

# best scoring configuration
instance$result

# all evaluations
as.data.table(instance$archive)
</code></pre>

<hr>
<h2 id='mlr_optimizers_nloptr'>Optimization via Non-linear Optimization</h2><span id='topic+mlr_optimizers_nloptr'></span><span id='topic+OptimizerNLoptr'></span>

<h3>Description</h3>

<p><code>OptimizerNLoptr</code> class that implements non-linear optimization. Calls
<code><a href="nloptr.html#topic+nloptr">nloptr::nloptr()</a></code> from package <a href="https://CRAN.R-project.org/package=nloptr"><span class="pkg">nloptr</span></a>.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>algorithm</code></dt><dd><p><code>character(1)</code></p>
</dd>
<dt><code>eval_g_ineq</code></dt><dd><p><code style="white-space: pre;">&#8288;function()&#8288;</code></p>
</dd>
<dt><code>xtol_rel</code></dt><dd><p><code>numeric(1)</code></p>
</dd>
<dt><code>xtol_abs</code></dt><dd><p><code>numeric(1)</code></p>
</dd>
<dt><code>ftol_rel</code></dt><dd><p><code>numeric(1)</code></p>
</dd>
<dt><code>ftol_abs</code></dt><dd><p><code>numeric(1)</code></p>
</dd>
<dt><code>start_values</code></dt><dd><p><code>character(1)</code><br />
Create <code>random</code> start values or based on <code>center</code> of search space? In the
latter case, it is the center of the parameters before a trafo is applied.</p>
</dd>
</dl>

<p>For the meaning of the control parameters, see <code><a href="nloptr.html#topic+nloptr">nloptr::nloptr()</a></code> and
<code><a href="nloptr.html#topic+nloptr.print.options">nloptr::nloptr.print.options()</a></code>.
</p>
<p>The termination conditions <code>stopval</code>, <code>maxtime</code> and <code>maxeval</code> of
<code><a href="nloptr.html#topic+nloptr">nloptr::nloptr()</a></code> are deactivated and replaced by the <a href="#topic+Terminator">Terminator</a>
subclasses. The x and function value tolerance termination conditions
(<code>xtol_rel = 10^-4</code>, <code>xtol_abs = rep(0.0, length(x0))</code>, <code>ftol_rel = 0.0</code> and
<code>ftol_abs = 0.0</code>) are still available and implemented with their package
defaults. To deactivate these conditions, set them to <code>-1</code>.
</p>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerNLoptr</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerNLoptr-new"><code>OptimizerNLoptr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerNLoptr-clone"><code>OptimizerNLoptr$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerNLoptr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerNLoptr$new()</pre></div>


<hr>
<a id="method-OptimizerNLoptr-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerNLoptr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Johnson, G S (2020).
&ldquo;The NLopt nonlinear-optimization package.&rdquo;
<a href="https://github.com/stevengj/nlopt">https://github.com/stevengj/nlopt</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("nloptr")) {

  search_space = domain = ps(x = p_dbl(lower = -1, upper = 1))

  codomain = ps(y = p_dbl(tags = "minimize"))

  objective_function = function(xs) {
    list(y = as.numeric(xs)^2)
  }

  objective = ObjectiveRFun$new(
    fun = objective_function,
    domain = domain,
    codomain = codomain)


  # We use the internal termination criterion xtol_rel
  terminator = trm("none")
  instance = OptimInstanceSingleCrit$new(
    objective = objective,
    search_space = search_space,
    terminator = terminator)


  optimizer = opt("nloptr", algorithm = "NLOPT_LN_BOBYQA")

  # Modifies the instance by reference
  optimizer$optimize(instance)

  # Returns best scoring evaluation
  instance$result

  # Allows access of data.table of full path of all evaluations
  as.data.table(instance$archive)
}


</code></pre>

<hr>
<h2 id='mlr_optimizers_random_search'>Optimization via Random Search</h2><span id='topic+mlr_optimizers_random_search'></span><span id='topic+OptimizerRandomSearch'></span>

<h3>Description</h3>

<p><code>OptimizerRandomSearch</code> class that implements a simple Random Search.
</p>
<p>In order to support general termination criteria and parallelization, we
evaluate points in a batch-fashion of size <code>batch_size</code>. Larger batches mean
we can parallelize more, smaller batches imply a more fine-grained checking
of termination criteria.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Optimizer">Optimizer</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_optimizers">mlr_optimizers</a> or with the associated sugar function <code><a href="#topic+opt">opt()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("random_search")
opt("random_search")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>batch_size</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of points to try in a batch.</p>
</dd>
</dl>



<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerRandomSearch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerRandomSearch-new"><code>OptimizerRandomSearch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerRandomSearch-clone"><code>OptimizerRandomSearch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerRandomSearch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerRandomSearch$new()</pre></div>


<hr>
<a id="method-OptimizerRandomSearch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerRandomSearch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Bergstra J, Bengio Y (2012).
&ldquo;Random Search for Hyper-Parameter Optimization.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>13</b>(10), 281&ndash;305.
<a href="https://jmlr.csail.mit.edu/papers/v13/bergstra12a.html">https://jmlr.csail.mit.edu/papers/v13/bergstra12a.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>search_space = domain = ps(x = p_dbl(lower = -1, upper = 1))

codomain = ps(y = p_dbl(tags = "minimize"))

objective_function = function(xs) {
  list(y = as.numeric(xs)^2)
}

objective = ObjectiveRFun$new(
 fun = objective_function,
 domain = domain,
 codomain = codomain)

instance = OptimInstanceSingleCrit$new(
 objective = objective,
 search_space = search_space,
 terminator = trm("evals", n_evals = 10))


optimizer = opt("random_search")

# modifies the instance by reference
optimizer$optimize(instance)

# returns best scoring evaluation
instance$result

# allows access of data.table of full path of all evaluations
as.data.table(instance$archive$data)
</code></pre>

<hr>
<h2 id='mlr_terminators'>Dictionary of Terminators</h2><span id='topic+mlr_terminators'></span>

<h3>Description</h3>

<p>A simple <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> storing objects of class <a href="#topic+Terminator">Terminator</a>.
Each terminator has an associated help page, see <code>mlr_terminators_[id]</code>.
</p>
<p>This dictionary can get populated with additional terminators by add-on packages.
</p>
<p>For a more convenient way to retrieve and construct terminator, see <code><a href="#topic+trm">trm()</a></code>/<code><a href="#topic+trms">trms()</a></code>.
</p>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> object inheriting from <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>Methods</h3>

<p>See <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>S3 methods</h3>


<ul>
<li> <p><code>as.data.table(dict, ..., objects = FALSE)</code><br />
<a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> -&gt; <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code><br />
Returns a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with fields &quot;key&quot;, &quot;label&quot;, &quot;properties&quot; and &quot;unit&quot; as columns.
If <code>objects</code> is set to <code>TRUE</code>, the constructed objects are returned in the list column named <code>object</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Sugar functions: <code><a href="#topic+trm">trm()</a></code>, <code><a href="#topic+trms">trms()</a></code>
</p>
<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.data.table(mlr_terminators)
mlr_terminators$get("evals")
trm("evals", n_evals = 10)
</code></pre>

<hr>
<h2 id='mlr_terminators_clock_time'>Clock Time Terminator</h2><span id='topic+mlr_terminators_clock_time'></span><span id='topic+TerminatorClockTime'></span>

<h3>Description</h3>

<p>Class to terminate the optimization after a fixed time point has been reached (as reported by <code><a href="base.html#topic+Sys.time">Sys.time()</a></code>).
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("clock_time")
trm("clock_time")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>stop_time</code></dt><dd><p><code>POSIXct(1)</code><br />
Terminator stops after this point in time.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorClockTime</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorClockTime-new"><code>TerminatorClockTime$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorClockTime-is_terminated"><code>TerminatorClockTime$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorClockTime-clone"><code>TerminatorClockTime$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorClockTime-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorClockTime$new()</pre></div>


<hr>
<a id="method-TerminatorClockTime-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorClockTime$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorClockTime-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorClockTime$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stop_time = as.POSIXct("2030-01-01 00:00:00")
trm("clock_time", stop_time = stop_time)
</code></pre>

<hr>
<h2 id='mlr_terminators_combo'>Combine Terminators</h2><span id='topic+mlr_terminators_combo'></span><span id='topic+TerminatorCombo'></span>

<h3>Description</h3>

<p>This class takes multiple <a href="#topic+Terminator">Terminator</a>s and terminates as soon as one or all
of the included terminators are positive.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("combo")
trm("combo")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>any</code></dt><dd><p><code>logical(1)</code><br />
Terminate iff any included terminator is positive? (not all).
Default is <code>TRUE</code>.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorCombo</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>terminators</code></dt><dd><p>(<code>list()</code>)<br />
List of objects of class <a href="#topic+Terminator">Terminator</a>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorCombo-new"><code>TerminatorCombo$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorCombo-is_terminated"><code>TerminatorCombo$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorCombo-print"><code>TerminatorCombo$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorCombo-remaining_time"><code>TerminatorCombo$remaining_time()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorCombo-status_long"><code>TerminatorCombo$status_long()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorCombo-clone"><code>TerminatorCombo$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorCombo-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorCombo$new(terminators = list(TerminatorNone$new()))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>terminators</code></dt><dd><p>(<code>list()</code>)<br />
List of objects of class <a href="#topic+Terminator">Terminator</a>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TerminatorCombo-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorCombo$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorCombo-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorCombo$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TerminatorCombo-remaining_time"></a>



<h4>Method <code>remaining_time()</code></h4>

<p>Returns the remaining runtime in seconds. If <code>any = TRUE</code>, the remaining
runtime is determined by the time-based terminator with the shortest time
remaining. If non-time-based terminators are used and <code>any = FALSE</code>,
the the remaining runtime is always <code>Inf</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorCombo$remaining_time(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>integer(1)</code>.
</p>


<hr>
<a id="method-TerminatorCombo-status_long"></a>



<h4>Method <code>status_long()</code></h4>

<p>Returns <code>max_steps</code> and <code>current_steps</code> for each terminator.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorCombo$status_long(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="data.table.html#topic+data.table">data.table::data.table</a>.
</p>


<hr>
<a id="method-TerminatorCombo-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorCombo$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trm("combo",
  list(trm("clock_time", stop_time = Sys.time() + 60),
    trm("evals", n_evals = 10)), any = FALSE
)
</code></pre>

<hr>
<h2 id='mlr_terminators_evals'>Terminator that stops after a number of evaluations</h2><span id='topic+mlr_terminators_evals'></span><span id='topic+TerminatorEvals'></span>

<h3>Description</h3>

<p>Class to terminate the optimization depending on the number of evaluations.
An evaluation is defined by one resampling of a parameter value.
The total number of evaluations <code class="reqn">B</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
   B = \mathtt{n\_evals} + \mathtt{k} * D
</code>
</p>

<p>where <code class="reqn">D</code> is the dimension of the search space.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("evals")
trm("evals")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>n_evals</code></dt><dd><p><code>integer(1)</code><br />
See formula above. Default is 100.</p>
</dd>
<dt><code>k</code></dt><dd><p><code>integer(1)</code><br />
See formula above. Default is 0.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorEvals</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorEvals-new"><code>TerminatorEvals$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorEvals-is_terminated"><code>TerminatorEvals$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorEvals-clone"><code>TerminatorEvals$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorEvals-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorEvals$new()</pre></div>


<hr>
<a id="method-TerminatorEvals-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorEvals$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorEvals-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorEvals$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TerminatorEvals$new()

# 5 evaluations in total
trm("evals", n_evals = 5)

# 3 * [dimension of search space] evaluations in total
trm("evals", n_evals = 0, k = 3)

# (3 * [dimension of search space] + 1) evaluations in total
trm("evals", n_evals = 1, k = 3)
</code></pre>

<hr>
<h2 id='mlr_terminators_none'>None Terminator</h2><span id='topic+mlr_terminators_none'></span><span id='topic+TerminatorNone'></span>

<h3>Description</h3>

<p>Mainly useful for optimization algorithms where the stopping is inherently controlled by the algorithm itself (e.g. <a href="#topic+OptimizerGridSearch">OptimizerGridSearch</a>).
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("none")
trm("none")
</pre></div>


<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorNone</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorNone-new"><code>TerminatorNone$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorNone-is_terminated"><code>TerminatorNone$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorNone-clone"><code>TerminatorNone$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorNone-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorNone$new()</pre></div>


<hr>
<a id="method-TerminatorNone-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorNone$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorNone-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorNone$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>

<hr>
<h2 id='mlr_terminators_perf_reached'>Performance Level Terminator</h2><span id='topic+mlr_terminators_perf_reached'></span><span id='topic+TerminatorPerfReached'></span>

<h3>Description</h3>

<p>Class to terminate the optimization after a performance level has been hit.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("perf_reached")
trm("perf_reached")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>level</code></dt><dd><p><code>numeric(1)</code><br />
Performance level that needs to be reached.
Default is 0.
Terminates if the performance exceeds (respective measure has to be maximized) or falls below (respective measure has to be minimized) this value.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorPerfReached</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorPerfReached-new"><code>TerminatorPerfReached$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorPerfReached-is_terminated"><code>TerminatorPerfReached$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorPerfReached-clone"><code>TerminatorPerfReached$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorPerfReached-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorPerfReached$new()</pre></div>


<hr>
<a id="method-TerminatorPerfReached-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorPerfReached$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorPerfReached-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorPerfReached$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TerminatorPerfReached$new()
trm("perf_reached")
</code></pre>

<hr>
<h2 id='mlr_terminators_run_time'>Run Time Terminator</h2><span id='topic+mlr_terminators_run_time'></span><span id='topic+TerminatorRunTime'></span>

<h3>Description</h3>

<p>Class to terminate the optimization after the optimization process took a number of seconds on the clock.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("run_time")
trm("run_time")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>secs</code></dt><dd><p><code>numeric(1)</code><br />
Maximum allowed time, in seconds, default is 100.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorRunTime</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorRunTime-new"><code>TerminatorRunTime$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorRunTime-is_terminated"><code>TerminatorRunTime$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorRunTime-clone"><code>TerminatorRunTime$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorRunTime-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorRunTime$new()</pre></div>


<hr>
<a id="method-TerminatorRunTime-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorRunTime$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorRunTime-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorRunTime$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>This terminator only works if <code>archive$start_time</code> is set. This is usually
done by the <a href="#topic+Optimizer">Optimizer</a>.
</p>


<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trm("run_time", secs = 1800)
</code></pre>

<hr>
<h2 id='mlr_terminators_stagnation'>Terminator that stops when optimization does not improve</h2><span id='topic+mlr_terminators_stagnation'></span><span id='topic+TerminatorStagnation'></span>

<h3>Description</h3>

<p>Class to terminate the optimization after the performance stagnates, i.e.
does not improve more than <code>threshold</code> over the last <code>iters</code> iterations.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("stagnation")
trm("stagnation")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Number of iterations to evaluate the performance improvement on, default
is 10.</p>
</dd>
<dt><code>threshold</code></dt><dd><p><code>numeric(1)</code><br />
If the improvement is less than <code>threshold</code>, optimization is stopped,
default is <code>0</code>.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorStagnation</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorStagnation-new"><code>TerminatorStagnation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorStagnation-is_terminated"><code>TerminatorStagnation$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorStagnation-clone"><code>TerminatorStagnation$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorStagnation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorStagnation$new()</pre></div>


<hr>
<a id="method-TerminatorStagnation-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorStagnation$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorStagnation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorStagnation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TerminatorStagnation$new()
trm("stagnation", iters = 5, threshold = 1e-5)
</code></pre>

<hr>
<h2 id='mlr_terminators_stagnation_batch'>Terminator that stops when optimization does not improve</h2><span id='topic+mlr_terminators_stagnation_batch'></span><span id='topic+TerminatorStagnationBatch'></span>

<h3>Description</h3>

<p>Class to terminate the optimization after the performance stagnates, i.e.
does not improve more than <code>threshold</code> over the last <code>n</code> batches.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+Terminator">Terminator</a> can be instantiated via the
<a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_terminators">mlr_terminators</a> or with the associated
sugar function <code><a href="#topic+trm">trm()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_terminators$get("stagnation_batch")
trm("stagnation_batch")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>n</code></dt><dd><p><code>integer(1)</code><br />
Number of batches to evaluate the performance improvement on, default
is 1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p><code>numeric(1)</code><br />
If the improvement is less than <code>threshold</code>, optimization is stopped,
default is <code>0</code>.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorStagnationBatch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorStagnationBatch-new"><code>TerminatorStagnationBatch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorStagnationBatch-is_terminated"><code>TerminatorStagnationBatch$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorStagnationBatch-clone"><code>TerminatorStagnationBatch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorStagnationBatch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorStagnationBatch$new()</pre></div>


<hr>
<a id="method-TerminatorStagnationBatch-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> iff the termination criterion is positive, and <code>FALSE</code>
otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorStagnationBatch$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-TerminatorStagnationBatch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorStagnationBatch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+Terminator">Terminator</a></code>,
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TerminatorStagnationBatch$new()
trm("stagnation_batch", n = 1, threshold = 1e-5)
</code></pre>

<hr>
<h2 id='nds_selection'>Best points w.r.t. non dominated sorting with hypervolume contribution.</h2><span id='topic+nds_selection'></span>

<h3>Description</h3>

<p>Select best subset of points by non dominated sorting with
hypervolume contribution for tie breaking. Works on an arbitrary dimension
of size two or higher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nds_selection(points, n_select, ref_point = NULL, minimize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nds_selection_+3A_points">points</code></td>
<td>
<p>(<code>matrix()</code>)<br />
Numeric matrix with each column corresponding to a point</p>
</td></tr>
<tr><td><code id="nds_selection_+3A_n_select">n_select</code></td>
<td>
<p>(<code>integer(1L)</code>)<br />
Amount of points to select.</p>
</td></tr>
<tr><td><code id="nds_selection_+3A_ref_point">ref_point</code></td>
<td>
<p>(<code>numeric()</code>)<br />
Reference point for hypervolume.</p>
</td></tr>
<tr><td><code id="nds_selection_+3A_minimize">minimize</code></td>
<td>
<p>('logical()')<br />
Should the ranking be based on minimization?
Can be specified for each dimension or for all.
Default is <code>TRUE</code> for each dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of indices of selected points
</p>

<hr>
<h2 id='Objective'>Objective function with domain and co-domain</h2><span id='topic+Objective'></span>

<h3>Description</h3>

<p>Describes a black-box objective function that maps an arbitrary domain to a
numerical codomain.
</p>


<h3>Technical details</h3>

<p><code>Objective</code> objects can have the following properties: <code>"noisy"</code>,
<code>"deterministic"</code>, <code>"single-crit"</code> and <code>"multi-crit"</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)).</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>).</p>
</dd>
<dt><code>domain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies domain of function, hence its input parameters, their types
and ranges.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies codomain of function, hence its feasible values.</p>
</dd>
<dt><code>constants</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>).<br />
Changeable constants or parameters that are not subject to tuning can be
stored and accessed here. Set constant values are passed to <code style="white-space: pre;">&#8288;$.eval()&#8288;</code>
and <code style="white-space: pre;">&#8288;$.eval_many()&#8288;</code> as named arguments.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br /></p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>xdim</code></dt><dd><p>(<code>integer(1)</code>)<br />
Dimension of domain.</p>
</dd>
<dt><code>ydim</code></dt><dd><p>(<code>integer(1)</code>)<br />
Dimension of codomain.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Objective-new"><code>Objective$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-format"><code>Objective$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-print"><code>Objective$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-eval"><code>Objective$eval()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-eval_many"><code>Objective$eval_many()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-eval_dt"><code>Objective$eval_dt()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-clone"><code>Objective$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Objective-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$new(
  id = "f",
  properties = character(),
  domain,
  codomain = ps(y = p_dbl(tags = "minimize")),
  constants = ps(),
  check_values = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>).</p>
</dd>
<dt><code>domain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies domain of function.
The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> should describe all possible input parameters of the objective function.
This includes their <code>id</code>, their types and the possible range.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies codomain of function.
Most importantly the tags of each output &quot;Parameter&quot; define whether it should
be minimized or maximized.  The default is to minimize each component.</p>
</dd>
<dt><code>constants</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Changeable constants or parameters that are not subject to tuning can be stored and accessed here.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should points before the evaluation and the results be checked for
validity?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Objective-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Objective-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$print()</pre></div>



<h5>Returns</h5>

<p><code>character()</code>.
</p>


<hr>
<a id="method-Objective-eval"></a>



<h4>Method <code>eval()</code></h4>

<p>Evaluates a single input value on the objective function. If
<code>check_values = TRUE</code>, the validity of the point as well as the validity
of the result is checked.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$eval(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>(<code>list()</code>)<br />
A list that contains a single x value, e.g. <code>list(x1 = 1, x2 = 2)</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list()</code> that contains the result of the evaluation, e.g. <code>list(y = 1)</code>.
The list can also contain additional <em>named</em> entries that will be stored in the
archive if called through the <a href="#topic+OptimInstance">OptimInstance</a>.
These extra entries are referred to as <em>extras</em>.
</p>


<hr>
<a id="method-Objective-eval_many"></a>



<h4>Method <code>eval_many()</code></h4>

<p>Evaluates multiple input values on the objective function. If
<code>check_values = TRUE</code>, the validity of the points as well as the validity
of the results are checked. <em>bbotk</em> does not take care of
parallelization. If the function should make use of parallel computing,
it has to be implemented by deriving from this class and overwriting this
function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$eval_many(xss)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xss</code></dt><dd><p>(<code>list()</code>)<br />
A list of lists that contains multiple x values, e.g.
<code>list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4))</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data.table::data.table()] that contains one y-column for
single-criteria functions and multiple y-columns for multi-criteria functions,
e.g.  <code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.
It may also contain additional columns that will be stored in the archive if
called through the <a href="#topic+OptimInstance">OptimInstance</a>.
These extra columns are referred to as <em>extras</em>.
</p>


<hr>
<a id="method-Objective-eval_dt"></a>



<h4>Method <code>eval_dt()</code></h4>

<p>Evaluates multiple input values on the objective function
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$eval_dt(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Set of untransformed points / points from the <em>search space</em>.
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.
Column names have to match ids of the <code>search_space</code>.
However, <code>xdt</code> can contain additional columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data.table::data.table()] that contains one y-column for
single-criteria functions and multiple y-columns for multi-criteria
functions, e.g.  <code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.
</p>


<hr>
<a id="method-Objective-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ObjectiveRFun'>Objective interface with custom R function</h2><span id='topic+ObjectiveRFun'></span>

<h3>Description</h3>

<p>Objective interface where the user can pass a custom R function that expects a list as input.
If the return of the function is unnamed, it is named with the ids of the codomain.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Objective">bbotk::Objective</a></code> -&gt; <code>ObjectiveRFun</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>fun</code></dt><dd><p>(<code>function</code>)<br />
Objective function.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ObjectiveRFun-new"><code>ObjectiveRFun$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveRFun-eval"><code>ObjectiveRFun$eval()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveRFun-clone"><code>ObjectiveRFun$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval_dt"><a href='../../bbotk/html/Objective.html#method-Objective-eval_dt'><code>bbotk::Objective$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval_many"><a href='../../bbotk/html/Objective.html#method-Objective-eval_many'><code>bbotk::Objective$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ObjectiveRFun-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFun$new(
  fun,
  domain,
  codomain = NULL,
  id = "function",
  properties = character(),
  constants = ps(),
  check_values = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt><dd><p>(<code>function</code>)<br />
R function that encodes objective and expects a list with the input for a single point
(e.g. <code>list(x1 = 1, x2 = 2)</code>) and returns the result either as a numeric vector or a
list (e.g. <code>list(y = 3)</code>).</p>
</dd>
<dt><code>domain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies domain of function.
The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> should describe all possible input parameters of the objective function.
This includes their <code>id</code>, their types and the possible range.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies codomain of function.
Most importantly the tags of each output &quot;Parameter&quot; define whether it should
be minimized or maximized.  The default is to minimize each component.</p>
</dd>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>).</p>
</dd>
<dt><code>constants</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Changeable constants or parameters that are not subject to tuning can be stored and accessed here.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should points before the evaluation and the results be checked for
validity?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ObjectiveRFun-eval"></a>



<h4>Method <code>eval()</code></h4>

<p>Evaluates input value(s) on the objective function. Calls the R function
supplied by the user.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFun$eval(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>Input values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ObjectiveRFun-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFun$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># define objective function
fun = function(xs) {
  -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + 10
}

# set domain
domain = ps(
  x1 = p_dbl(-10, 10),
  x2 = p_dbl(-5, 5)
)

# set codomain
codomain = ps(y = p_dbl(tags = "maximize"))

# create Objective object
obfun = ObjectiveRFun$new(
  fun = fun,
  domain = domain,
  codomain = codomain,
  properties = "deterministic"
)
</code></pre>

<hr>
<h2 id='ObjectiveRFunDt'>Objective interface for basic R functions.</h2><span id='topic+ObjectiveRFunDt'></span>

<h3>Description</h3>

<p>Objective interface where user can pass an R function that works on an <code>data.table()</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Objective">bbotk::Objective</a></code> -&gt; <code>ObjectiveRFunDt</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>fun</code></dt><dd><p>(<code>function</code>)<br />
Objective function.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ObjectiveRFunDt-new"><code>ObjectiveRFunDt$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveRFunDt-eval_many"><code>ObjectiveRFunDt$eval_many()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveRFunDt-eval_dt"><code>ObjectiveRFunDt$eval_dt()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveRFunDt-clone"><code>ObjectiveRFunDt$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ObjectiveRFunDt-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFunDt$new(
  fun,
  domain,
  codomain = NULL,
  id = "function",
  properties = character(),
  constants = ps(),
  check_values = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt><dd><p>(<code>function</code>)<br />
R function that encodes objective and expects an <code>data.table()</code> as input
whereas each point is represented by one row.</p>
</dd>
<dt><code>domain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies domain of function.
The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> should describe all possible input parameters of the objective function.
This includes their <code>id</code>, their types and the possible range.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies codomain of function.
Most importantly the tags of each output &quot;Parameter&quot; define whether it should
be minimized or maximized.  The default is to minimize each component.</p>
</dd>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>).</p>
</dd>
<dt><code>constants</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Changeable constants or parameters that are not subject to tuning can be stored and accessed here.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should points before the evaluation and the results be checked for
validity?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ObjectiveRFunDt-eval_many"></a>



<h4>Method <code>eval_many()</code></h4>

<p>Evaluates multiple input values received as a list, converted to a <code>data.table()</code> on the
objective function. Missing columns in xss are filled with <code>NA</code>s in <code>xdt</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFunDt$eval_many(xss)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xss</code></dt><dd><p>(<code>list()</code>)<br />
A list of lists that contains multiple x values, e.g.
<code>list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4))</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains one y-column for single-criteria functions
and multiple y-columns for multi-criteria functions, e.g.
<code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.
</p>


<hr>
<a id="method-ObjectiveRFunDt-eval_dt"></a>



<h4>Method <code>eval_dt()</code></h4>

<p>Evaluates multiple input values on the objective function supplied by the user.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFunDt$eval_dt(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Set of untransformed points / points from the <em>search space</em>.
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.
Column names have to match ids of the <code>search_space</code>.
However, <code>xdt</code> can contain additional columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data.table::data.table()] that contains one y-column for single-criteria functions
and multiple y-columns for multi-criteria functions, e.g.
<code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.
</p>


<hr>
<a id="method-ObjectiveRFunDt-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFunDt$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ObjectiveRFunMany'>Objective Interface with Custom R Function</h2><span id='topic+ObjectiveRFunMany'></span>

<h3>Description</h3>

<p>Objective interface where the user can pass a custom R function that expects a list of configurations as input.
If the return of the function is unnamed, it is named with the ids of the codomain.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Objective">bbotk::Objective</a></code> -&gt; <code>ObjectiveRFunMany</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>fun</code></dt><dd><p>(<code>function</code>)<br />
Objective function.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ObjectiveRFunMany-new"><code>ObjectiveRFunMany$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveRFunMany-eval_many"><code>ObjectiveRFunMany$eval_many()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveRFunMany-clone"><code>ObjectiveRFunMany$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval_dt"><a href='../../bbotk/html/Objective.html#method-Objective-eval_dt'><code>bbotk::Objective$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ObjectiveRFunMany-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFunMany$new(
  fun,
  domain,
  codomain = NULL,
  id = "function",
  properties = character(),
  constants = ps(),
  check_values = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt><dd><p>(<code>function</code>)<br />
R function that encodes objective and expects a list of lists that contains multiple x values, e.g. <code>list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4))</code>.
The function must return a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains one y-column for single-criteria functions and multiple y-columns for multi-criteria functions, e.g.  <code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.</p>
</dd>
<dt><code>domain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies domain of function.
The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> should describe all possible input parameters of the objective function.
This includes their <code>id</code>, their types and the possible range.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies codomain of function.
Most importantly the tags of each output &quot;Parameter&quot; define whether it should
be minimized or maximized.  The default is to minimize each component.</p>
</dd>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>).</p>
</dd>
<dt><code>constants</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Changeable constants or parameters that are not subject to tuning can be stored and accessed here.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should points before the evaluation and the results be checked for
validity?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ObjectiveRFunMany-eval_many"></a>



<h4>Method <code>eval_many()</code></h4>

<p>Evaluates input value(s) on the objective function.
Calls the R function supplied by the user.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFunMany$eval_many(xss)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xss</code></dt><dd><p>(<code>list()</code>)<br />
A list of lists that contains multiple x values, e.g. <code>list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4))</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains one y-column for single-criteria functions and multiple y-columns for multi-criteria functions, e.g.  <code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.
It may also contain additional columns that will be stored in the archive if called through the <a href="#topic+OptimInstance">OptimInstance</a>.
These extra columns are referred to as <em>extras</em>.
</p>


<hr>
<a id="method-ObjectiveRFunMany-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveRFunMany$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># define objective function
fun = function(xss) {
  res = lapply(xss, function(xs) -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + 10)
  data.table(y = as.numeric(res))
}

# set domain
domain = ps(
  x1 = p_dbl(-10, 10),
  x2 = p_dbl(-5, 5)
)

# set codomain
codomain = ps(y = p_dbl(tags = "maximize"))

# create Objective object
obfun = ObjectiveRFunMany$new(
  fun = fun,
  domain = domain,
  codomain = codomain,
  properties = "deterministic"
)
</code></pre>

<hr>
<h2 id='opt'>Syntactic Sugar Optimizer Construction</h2><span id='topic+opt'></span><span id='topic+opts'></span>

<h3>Description</h3>

<p>This function complements <a href="#topic+mlr_optimizers">mlr_optimizers</a> with functions in the spirit
of <code>mlr_sugar</code> from <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt(.key, ...)

opts(.keys, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_+3A_.key">.key</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Key passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve
the object.</p>
</td></tr>
<tr><td><code id="opt_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to the constructor, to be set as parameters in the
<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>, or to be set as public field. See
<code><a href="mlr3misc.html#topic+dictionary_sugar_get">mlr3misc::dictionary_sugar_get()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="opt_+3A_.keys">.keys</code></td>
<td>
<p>(<code>character()</code>)<br />
Keys passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve
multiple objects.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><a href="#topic+Optimizer">Optimizer</a> for <code>opt()</code>.
</p>
</li>
<li><p> list of <a href="#topic+Optimizer">Optimizer</a> for <code>opts()</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>opt("random_search", batch_size = 10)
</code></pre>

<hr>
<h2 id='OptimInstance'>Optimization Instance with budget and archive</h2><span id='topic+OptimInstance'></span>

<h3>Description</h3>

<p>Abstract base class.
</p>


<h3>Technical details</h3>

<p>The <a href="#topic+Optimizer">Optimizer</a> writes the final result to the <code>.result</code> field by using
the <code style="white-space: pre;">&#8288;$assign_result()&#8288;</code> method. <code>.result</code> stores a <a href="data.table.html#topic+data.table">data.table::data.table</a>
consisting of x values in the <em>search space</em>, (transformed) x values in the
<em>domain space</em> and y values in the <em>codomain space</em> of the <a href="#topic+Objective">Objective</a>. The
user can access the results with active bindings (see below).
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>objective</code></dt><dd><p>(<a href="#topic+Objective">Objective</a>).</p>
</dd>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>).</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="#topic+Terminator">Terminator</a>).</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
<dt><code>progressor</code></dt><dd><p>(<code>progressor()</code>)<br />
Stores <code>progressor</code> function.</p>
</dd>
<dt><code>objective_multiplicator</code></dt><dd><p>(<code>integer()</code>).</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(List of <a href="#topic+CallbackOptimization">CallbackOptimization</a>s).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>result</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
Get result</p>
</dd>
<dt><code>result_x_search_space</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
x part of the result in the <em>search space</em>.</p>
</dd>
<dt><code>result_x_domain</code></dt><dd><p>(<code>list()</code>)<br />
(transformed) x part of the result in the <em>domain space</em> of the objective.</p>
</dd>
<dt><code>result_y</code></dt><dd><p>(<code>numeric()</code>)<br />
Optimal outcome.</p>
</dd>
<dt><code>is_terminated</code></dt><dd><p>(<code>logical(1)</code>).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimInstance-new"><code>OptimInstance$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstance-format"><code>OptimInstance$format()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstance-print"><code>OptimInstance$print()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstance-eval_batch"><code>OptimInstance$eval_batch()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstance-assign_result"><code>OptimInstance$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstance-objective_function"><code>OptimInstance$objective_function()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstance-clear"><code>OptimInstance$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstance-clone"><code>OptimInstance$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OptimInstance-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$new(
  objective,
  search_space = NULL,
  terminator,
  keep_evals = "all",
  check_values = TRUE,
  callbacks = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objective</code></dt><dd><p>(<a href="#topic+Objective">Objective</a>).</p>
</dd>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies the search space for the <a href="#topic+Optimizer">Optimizer</a>. The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>
describes either a subset of the <code>domain</code> of the <a href="#topic+Objective">Objective</a> or it describes
a set of parameters together with a <code>trafo</code> function that transforms values
from the search space to values of the domain. Depending on the context, this
value defaults to the domain of the objective.</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="#topic+Terminator">Terminator</a>).</p>
</dd>
<dt><code>keep_evals</code></dt><dd><p>(<code>character(1)</code>)<br />
Keep <code>all</code> or only <code>best</code> evaluations in archive?</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should x-values that are added to the archive be checked for validity?
Search space that is logged into archive.</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a>)<br />
List of callbacks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstance-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstance-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstance-eval_batch"></a>



<h4>Method <code>eval_batch()</code></h4>

<p>Evaluates all input values in <code>xdt</code> by calling
the <a href="#topic+Objective">Objective</a>. Applies possible transformations to the input values
and writes the results to the <a href="#topic+Archive">Archive</a>.
</p>
<p>Before each batch-evaluation, the <a href="#topic+Terminator">Terminator</a> is checked, and if it
is positive, an exception of class <code>terminated_error</code> is raised. This
function should be internally called by the <a href="#topic+Optimizer">Optimizer</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$eval_batch(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code>data.table::data.table()</code>)<br />
x values as <code>data.table()</code> with one point per row. Contains the value in
the <em>search space</em> of the <a href="#topic+OptimInstance">OptimInstance</a> object. Can contain additional
columns for extra information.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstance-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>The <a href="#topic+Optimizer">Optimizer</a> object writes the best found point
and estimated performance value here. For internal use.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$assign_result(xdt, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code>data.table::data.table()</code>)<br />
x values as <code>data.table::data.table()</code> with one row. Contains the value in the
<em>search space</em> of the <a href="#topic+OptimInstance">OptimInstance</a> object. Can contain additional
columns for extra information.</p>
</dd>
<dt><code>y</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Optimal outcome.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstance-objective_function"></a>



<h4>Method <code>objective_function()</code></h4>

<p>Evaluates (untransformed) points of only numeric values. Returns a
numeric scalar for single-crit or a numeric vector for multi-crit. The
return value(s) are negated if the measure is maximized. Internally,
<code style="white-space: pre;">&#8288;$eval_batch()&#8288;</code> is called with a single row. This function serves as a
objective function for optimizers of numeric spaces - which should always
be minimized.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$objective_function(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(<code>numeric()</code>)<br />
Untransformed points.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Objective value as <code>numeric(1)</code>, negated for maximization problems.
</p>


<hr>
<a id="method-OptimInstance-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Reset terminator and clear all evaluation results from archive and results.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$clear()</pre></div>


<hr>
<a id="method-OptimInstance-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstance$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='OptimInstanceMultiCrit'>Optimization Instance with budget and archive</h2><span id='topic+OptimInstanceMultiCrit'></span>

<h3>Description</h3>

<p>Wraps a multi-criteria <a href="#topic+Objective">Objective</a> function with extra services for
convenient evaluation. Inherits from <a href="#topic+OptimInstance">OptimInstance</a>.
</p>

<ul>
<li><p> Automatic storing of results in an <a href="#topic+Archive">Archive</a> after evaluation.
</p>
</li>
<li><p> Automatic checking for termination. Evaluations of design points are
performed in batches. Before a batch is evaluated, the <a href="#topic+Terminator">Terminator</a> is
queried for the remaining budget. If the available budget is exhausted, an
exception is raised, and no further evaluations can be performed from this
point on.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code>OptimInstanceMultiCrit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>result_x_domain</code></dt><dd><p>(<code>list()</code>)<br />
(transformed) x part of the result in the <em>domain space</em> of the objective.</p>
</dd>
<dt><code>result_y</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Optimal outcome.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimInstanceMultiCrit-new"><code>OptimInstanceMultiCrit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstanceMultiCrit-assign_result"><code>OptimInstanceMultiCrit$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstanceMultiCrit-clone"><code>OptimInstanceMultiCrit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="eval_batch"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-eval_batch'><code>bbotk::OptimInstance$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="objective_function"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-objective_function'><code>bbotk::OptimInstance$objective_function()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="print"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-print'><code>bbotk::OptimInstance$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimInstanceMultiCrit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceMultiCrit$new(
  objective,
  search_space = NULL,
  terminator,
  keep_evals = "all",
  check_values = TRUE,
  callbacks = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objective</code></dt><dd><p>(<a href="#topic+Objective">Objective</a>).</p>
</dd>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies the search space for the <a href="#topic+Optimizer">Optimizer</a>. The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>
describes either a subset of the <code>domain</code> of the <a href="#topic+Objective">Objective</a> or it describes
a set of parameters together with a <code>trafo</code> function that transforms values
from the search space to values of the domain. Depending on the context, this
value defaults to the domain of the objective.</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="#topic+Terminator">Terminator</a>)<br />
Multi-criteria terminator.</p>
</dd>
<dt><code>keep_evals</code></dt><dd><p>(<code>character(1)</code>)<br />
Keep <code>all</code> or only <code>best</code> evaluations in archive?</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should x-values that are added to the archive be checked for validity?
Search space that is logged into archive.</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a>)<br />
List of callbacks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstanceMultiCrit-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>The <a href="#topic+Optimizer">Optimizer</a> object writes the best found points
and estimated performance values here (probably the Pareto set / front).
For internal use.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceMultiCrit$assign_result(xdt, ydt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Set of untransformed points / points from the <em>search space</em>.
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.
Column names have to match ids of the <code>search_space</code>.
However, <code>xdt</code> can contain additional columns.</p>
</dd>
<dt><code>ydt</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Optimal outcomes, e.g. the Pareto front.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstanceMultiCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceMultiCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='OptimInstanceSingleCrit'>Optimization Instance with budget and archive</h2><span id='topic+OptimInstanceSingleCrit'></span>

<h3>Description</h3>

<p>Wraps a single-criteria <a href="#topic+Objective">Objective</a> function with extra services for
convenient evaluation. Inherits from <a href="#topic+OptimInstance">OptimInstance</a>.
</p>

<ul>
<li><p> Automatic storing of results in an <a href="#topic+Archive">Archive</a> after evaluation.
</p>
</li>
<li><p> Automatic checking for termination. Evaluations of design points are
performed in batches. Before a batch is evaluated, the <a href="#topic+Terminator">Terminator</a> is
queried for the remaining budget. If the available budget is exhausted, an
exception is raised, and no further evaluations can be performed from this
point on.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code>OptimInstanceSingleCrit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimInstanceSingleCrit-new"><code>OptimInstanceSingleCrit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstanceSingleCrit-assign_result"><code>OptimInstanceSingleCrit$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimInstanceSingleCrit-clone"><code>OptimInstanceSingleCrit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="eval_batch"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-eval_batch'><code>bbotk::OptimInstance$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="objective_function"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-objective_function'><code>bbotk::OptimInstance$objective_function()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="print"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-print'><code>bbotk::OptimInstance$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimInstanceSingleCrit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceSingleCrit$new(
  objective,
  search_space = NULL,
  terminator,
  keep_evals = "all",
  check_values = TRUE,
  callbacks = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objective</code></dt><dd><p>(<a href="#topic+Objective">Objective</a>).</p>
</dd>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies the search space for the <a href="#topic+Optimizer">Optimizer</a>. The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>
describes either a subset of the <code>domain</code> of the <a href="#topic+Objective">Objective</a> or it describes
a set of parameters together with a <code>trafo</code> function that transforms values
from the search space to values of the domain. Depending on the context, this
value defaults to the domain of the objective.</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="#topic+Terminator">Terminator</a>).</p>
</dd>
<dt><code>keep_evals</code></dt><dd><p>(<code>character(1)</code>)<br />
Keep <code>all</code> or only <code>best</code> evaluations in archive?</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should x-values that are added to the archive be checked for validity?
Search space that is logged into archive.</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a>)<br />
List of callbacks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstanceSingleCrit-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>The <a href="#topic+Optimizer">Optimizer</a> object writes the best found point
and estimated performance value here. For internal use.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceSingleCrit$assign_result(xdt, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Set of untransformed points / points from the <em>search space</em>.
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.
Column names have to match ids of the <code>search_space</code>.
However, <code>xdt</code> can contain additional columns.</p>
</dd>
<dt><code>y</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Optimal outcome.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimInstanceSingleCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceSingleCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='optimize_default'>Default optimization function</h2><span id='topic+optimize_default'></span>

<h3>Description</h3>

<p>Used internally in the <a href="#topic+Optimizer">Optimizer</a>.
Brings together the private <code>.optimize()</code> method and the private <code>.assign_result()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_default(inst, self, private)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_default_+3A_inst">inst</code></td>
<td>
<p><a href="#topic+OptimInstance">OptimInstance</a></p>
</td></tr>
<tr><td><code id="optimize_default_+3A_self">self</code></td>
<td>
<p><a href="#topic+Optimizer">Optimizer</a></p>
</td></tr>
<tr><td><code id="optimize_default_+3A_private">private</code></td>
<td>
<p>(<code>environment()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="data.table.html#topic+data.table">data.table::data.table</a>
</p>

<hr>
<h2 id='Optimizer'>Optimizer</h2><span id='topic+Optimizer'></span>

<h3>Description</h3>

<p>Abstract <code>Optimizer</code> class that implements the base functionality each <code>Optimizer</code> subclass must provide.
A <code>Optimizer</code> object describes the optimization strategy.
A <code>Optimizer</code> object must write its result to the <code style="white-space: pre;">&#8288;$assign_result()&#8288;</code> method of the <a href="#topic+OptimInstance">OptimInstance</a> at the end in order to store the best point and its estimated performance vector.
</p>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a <a href="#topic+Terminator">Terminator</a>. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the object.
Used in tables, plot and text output.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>param_set</code></dt><dd><p><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a><br />
Set of control parameters.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character()</code>)<br />
Supported parameter classes that the optimizer can optimize, as given in the <code><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a></code> <code style="white-space: pre;">&#8288;$class&#8288;</code> field.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the optimizer.
Must be a subset of <code><a href="#topic+bbotk_reflections">bbotk_reflections$optimizer_properties</a></code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled by the constructor if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Optimizer-new"><code>Optimizer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Optimizer-format"><code>Optimizer$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Optimizer-print"><code>Optimizer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Optimizer-help"><code>Optimizer$help()</code></a>
</p>
</li>
<li> <p><a href="#method-Optimizer-optimize"><code>Optimizer$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-Optimizer-clone"><code>Optimizer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Optimizer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Optimizer$new(
  id = "optimizer",
  param_set,
  param_classes,
  properties,
  packages = character(),
  label = NA_character_,
  man = NA_character_
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Set of control parameters.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character()</code>)<br />
Supported parameter classes that the optimizer can optimize, as given in the <code><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a></code> <code style="white-space: pre;">&#8288;$class&#8288;</code> field.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the optimizer.
Must be a subset of <code><a href="#topic+bbotk_reflections">bbotk_reflections$optimizer_properties</a></code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled by the constructor if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Optimizer-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Optimizer$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Optimizer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Optimizer$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-Optimizer-help"></a>



<h4>Method <code>help()</code></h4>

<p>Opens the corresponding help page referenced by field <code style="white-space: pre;">&#8288;$man&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Optimizer$help()</pre></div>


<hr>
<a id="method-Optimizer-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Performs the optimization and writes optimization result into
<a href="#topic+OptimInstance">OptimInstance</a>. The optimization result is returned but the complete
optimization path is stored in <a href="#topic+Archive">Archive</a> of <a href="#topic+OptimInstance">OptimInstance</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Optimizer$optimize(inst)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="#topic+OptimInstance">OptimInstance</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="data.table.html#topic+data.table">data.table::data.table</a>.
</p>


<hr>
<a id="method-Optimizer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Optimizer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Progressor'>Progressor</h2><span id='topic+Progressor'></span>

<h3>Description</h3>

<p>Wraps <code>progressr::progressor()</code> function and stores current progress.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>progressor</code></dt><dd><p>(<code>progressr::progressor()</code>).</p>
</dd>
<dt><code>max_steps</code></dt><dd><p>(<code>integer(1)</code>).</p>
</dd>
<dt><code>current_steps</code></dt><dd><p>(<code>integer(1)</code>).</p>
</dd>
<dt><code>unit</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Progressor-new"><code>Progressor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Progressor-update"><code>Progressor$update()</code></a>
</p>
</li>
<li> <p><a href="#method-Progressor-clone"><code>Progressor$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Progressor-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Progressor$new(progressor, unit)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>progressor</code></dt><dd><p>(<code>progressr::progressor()</code>)<br />
Progressor function.</p>
</dd>
<dt><code>unit</code></dt><dd><p>(<code>character(1)</code>)<br />
Unit of progress.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Progressor-update"></a>



<h4>Method <code>update()</code></h4>

<p>Updates <code>progressr::progressor()</code> with current steps.
</p>


<h5>Usage</h5>

<div class="r"><pre>Progressor$update(terminator, archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>terminator</code></dt><dd><p>(<a href="#topic+Terminator">Terminator</a>).</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Progressor-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Progressor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+mlr_callbacks'></span><span id='topic+clbk'></span><span id='topic+clbks'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>mlr3misc</dt><dd><p><code><a href="mlr3misc.html#topic+clbk">clbk</a></code>, <code><a href="mlr3misc.html#topic+clbk">clbks</a></code>, <code><a href="mlr3misc.html#topic+mlr_callbacks">mlr_callbacks</a></code></p>
</dd>
</dl>

<hr>
<h2 id='search_start'>Get start values for optimizers</h2><span id='topic+search_start'></span>

<h3>Description</h3>

<p>Returns a named numeric vector with start
values for optimizers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_start(search_space, type = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_start_+3A_search_space">search_space</code></td>
<td>
<p>ParamSet.</p>
</td></tr>
<tr><td><code id="search_start_+3A_type">type</code></td>
<td>
<p>(<code>character(1)</code>)<br />
<code>random</code> start values or <code>center</code> of search space?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named 'numeric()'
</p>

<hr>
<h2 id='shrink_ps'>Shrink a ParamSet towards a point.</h2><span id='topic+shrink_ps'></span>

<h3>Description</h3>

<p>Shrinks a <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> towards a point.
Boundaries of numeric values are shrinked to an interval around the point of
half of the previous length, while for discrete variables, a random
(currently not chosen) level is dropped.
</p>
<p>Note that for <code><a href="paradox.html#topic+Domain">paradox::p_lgl()</a></code>s the value to be shrinked around is set as
the <code>default</code> value instead of dropping a level. Also, a tag <code>shrinked</code> is
added.
</p>
<p>Note that the returned <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> has lost all its original
<code>default</code>s, as they may have become infeasible.
</p>
<p>If the <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> has a trafo, <code>x</code> is expected to contain the
transformed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_ps(param_set, x, check.feasible = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink_ps_+3A_param_set">param_set</code></td>
<td>
<p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> to be shrinked.</p>
</td></tr>
<tr><td><code id="shrink_ps_+3A_x">x</code></td>
<td>
<p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
<a href="data.table.html#topic+data.table">data.table::data.table</a> with one row containing the point to shrink
around.</p>
</td></tr>
<tr><td><code id="shrink_ps_+3A_check.feasible">check.feasible</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Should feasibility of the parameters be checked?
If feasibility is not checked, and invalid values are present, no shrinking
will be done.
Must be turned off in the case of the <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a> having a trafo.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(paradox)
library(data.table)
param_set = ps(
  x = p_dbl(lower = 0, upper = 10),
  x2 = p_int(lower = -10, upper = 10),
  x3 = p_fct(levels = c("a", "b", "c")),
  x4 = p_lgl()
)
x = data.table(x1 = 5, x2 = 0, x3 = "b", x4 = FALSE)
shrink_ps(param_set, x = x)
</code></pre>

<hr>
<h2 id='Terminator'>Abstract Terminator Class</h2><span id='topic+Terminator'></span>

<h3>Description</h3>

<p>Abstract <code>Terminator</code> class that implements the base functionality each terminator must provide.
A terminator is an object that determines when to stop the optimization.
</p>
<p>Termination of optimization works as follows:
</p>

<ul>
<li><p> Evaluations in a instance are performed in batches.
</p>
</li>
<li><p> Before each batch evaluation, the <a href="#topic+Terminator">Terminator</a> is checked, and if it is positive, we stop.
</p>
</li>
<li><p> The optimization algorithm itself might decide not to produce any more points, or even might decide to do a smaller batch in its last evaluation.
</p>
</li></ul>

<p>Therefore the following note seems in order:
While it is definitely possible to execute a fine-grained control for termination, and for many optimization algorithms we can specify exactly when to stop, it might happen that too few or even too many evaluations are performed, especially if multiple points are evaluated in a single batch (c.f. batch size parameter of many optimization algorithms).
So it is advised to check the size of the returned archive, in particular if you are benchmarking multiple optimization algorithms.
</p>


<h3>Technical details</h3>

<p><code>Terminator</code> subclasses can overwrite <code>.status()</code> to support progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>.
The method must return the maximum number of steps (<code>max_steps</code>) and the currently achieved number of steps (<code>current_steps</code>) as a named integer vector.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the object.
Used in tables, plot and text output.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>param_set</code></dt><dd><p><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a><br />
Set of control parameters.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the terminator.
Must be a subset of <code><a href="#topic+bbotk_reflections">bbotk_reflections$terminator_properties</a></code>.</p>
</dd>
<dt><code>unit</code></dt><dd><p>(<code>character()</code>)<br />
Unit of steps.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Terminator-new"><code>Terminator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Terminator-format"><code>Terminator$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Terminator-print"><code>Terminator$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Terminator-status"><code>Terminator$status()</code></a>
</p>
</li>
<li> <p><a href="#method-Terminator-remaining_time"><code>Terminator$remaining_time()</code></a>
</p>
</li>
<li> <p><a href="#method-Terminator-clone"><code>Terminator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Terminator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Terminator$new(
  id,
  param_set = ps(),
  properties = character(),
  unit = "percent",
  label = NA_character_,
  man = NA_character_
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Set of control parameters.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the terminator.
Must be a subset of <code><a href="#topic+bbotk_reflections">bbotk_reflections$terminator_properties</a></code>.</p>
</dd>
<dt><code>unit</code></dt><dd><p>(<code>character()</code>)<br />
Unit of steps.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Terminator-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Terminator$format(with_params = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>with_params</code></dt><dd><p>(<code>logical(1)</code>)<br />
Add parameter values to format string.</p>
</dd>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Terminator-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Terminator$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Terminator-status"></a>



<h4>Method <code>status()</code></h4>

<p>Returns how many progression steps are made (<code>current_steps</code>) and the
amount steps needed for termination (<code>max_steps</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>Terminator$status(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>named <code>integer(2)</code>.
</p>


<hr>
<a id="method-Terminator-remaining_time"></a>



<h4>Method <code>remaining_time()</code></h4>

<p>Returns remaining runtime in seconds. If the terminator is not
time-based, the reaming runtime is <code>Inf</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Terminator$remaining_time(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+Archive">Archive</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>integer(1)</code>.
</p>


<hr>
<a id="method-Terminator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Terminator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Terminator: 
<code><a href="#topic+mlr_terminators">mlr_terminators</a></code>,
<code><a href="#topic+mlr_terminators_clock_time">mlr_terminators_clock_time</a></code>,
<code><a href="#topic+mlr_terminators_combo">mlr_terminators_combo</a></code>,
<code><a href="#topic+mlr_terminators_evals">mlr_terminators_evals</a></code>,
<code><a href="#topic+mlr_terminators_none">mlr_terminators_none</a></code>,
<code><a href="#topic+mlr_terminators_perf_reached">mlr_terminators_perf_reached</a></code>,
<code><a href="#topic+mlr_terminators_run_time">mlr_terminators_run_time</a></code>,
<code><a href="#topic+mlr_terminators_stagnation">mlr_terminators_stagnation</a></code>,
<code><a href="#topic+mlr_terminators_stagnation_batch">mlr_terminators_stagnation_batch</a></code>
</p>

<hr>
<h2 id='transform_xdt_to_xss'>Calculates the transformed x-values</h2><span id='topic+transform_xdt_to_xss'></span>

<h3>Description</h3>

<p>Transforms a given <code>data.table()</code> to a list with transformed x values.
If no trafo is defined it will just convert the <code>data.table()</code> to a list.
Mainly for internal usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_xdt_to_xss(xdt, search_space)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_xdt_to_xss_+3A_xdt">xdt</code></td>
<td>
<p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Set of untransformed points / points from the <em>search space</em>.
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.
Column names have to match ids of the <code>search_space</code>.
However, <code>xdt</code> can contain additional columns.</p>
</td></tr>
<tr><td><code id="transform_xdt_to_xss_+3A_search_space">search_space</code></td>
<td>
<p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Specifies the search space for the <a href="#topic+Optimizer">Optimizer</a>. The <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>
describes either a subset of the <code>domain</code> of the <a href="#topic+Objective">Objective</a> or it describes
a set of parameters together with a <code>trafo</code> function that transforms values
from the search space to values of the domain. Depending on the context, this
value defaults to the domain of the objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code>.
</p>

<hr>
<h2 id='trm'>Syntactic Sugar Terminator Construction</h2><span id='topic+trm'></span><span id='topic+trms'></span>

<h3>Description</h3>

<p>This function complements <a href="#topic+mlr_terminators">mlr_terminators</a> with functions in the spirit
of <code>mlr_sugar</code> from <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trm(.key, ...)

trms(.keys, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trm_+3A_.key">.key</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Key passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve
the object.</p>
</td></tr>
<tr><td><code id="trm_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to the constructor, to be set as parameters in the
<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>, or to be set as public field. See
<code><a href="mlr3misc.html#topic+dictionary_sugar_get">mlr3misc::dictionary_sugar_get()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="trm_+3A_.keys">.keys</code></td>
<td>
<p>(<code>character()</code>)<br />
Keys passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve
multiple objects.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><a href="#topic+Terminator">Terminator</a> for <code>trm()</code>.
</p>
</li>
<li><p> list of <a href="#topic+Terminator">Terminator</a> for <code>trms()</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>trm("evals", n_evals = 10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
