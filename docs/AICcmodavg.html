<!DOCTYPE html><html><head><title>Help for package AICcmodavg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AICcmodavg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AICcmodavg-package'>
<p>Model Selection and Multimodel Inference Based on (Q)AIC(c)</p></a></li>
<li><a href='#AICc'>
<p>Computing AIC, AICc, QAIC, and QAICc</p></a></li>
<li><a href='#AICcCustom'>
<p>Compute AIC, AICc, QAIC, and QAICc from User-supplied Input</p></a></li>
<li><a href='#AICcmodavg-defunct'>
<p>Defunct Functions in AICcmodavg Package</p></a></li>
<li><a href='#aictab'>
<p>Create Model Selection Tables</p></a></li>
<li><a href='#aictabCustom'>
<p>Create Model Selection Tables from User-supplied Input Based on (Q)AIC(c)</p></a></li>
<li><a href='#anovaOD'>
<p>Likelihood-Ratio Test Corrected for Overdispersion</p></a></li>
<li><a href='#beetle'>
<p>Flour Beetle Data</p></a></li>
<li><a href='#bictab'>
<p>Create Model Selection Tables Based on BIC</p></a></li>
<li><a href='#bictabCustom'>
<p>Create Model Selection Tables from User-supplied Input Based on (Q)BIC</p></a></li>
<li><a href='#boot.wt'>
<p>Compute Model Selection Relative Frequencies</p></a></li>
<li><a href='#bullfrog'>
<p>Bullfrog Occupancy and Common Reed Invasion</p></a></li>
<li><a href='#c_hat'>
<p>Estimate Dispersion for Poisson and Binomial GLM's and GLMM's</p></a></li>
<li><a href='#calcium'>
<p>Blood Calcium Concentration in Birds</p></a></li>
<li><a href='#cement'>
<p>Heat Expended Following Hardening of Portland Cement</p></a></li>
<li><a href='#checkConv'>
<p>Check Convergence of Fitted Model</p></a></li>
<li><a href='#checkParms'>
<p>Identify Parameters with Large Standard Errors</p></a></li>
<li><a href='#confset'>
<p>Computing Confidence Set for the Kullback-Leibler Best Model</p></a></li>
<li><a href='#countDist'>
<p>Compute Summary Statistics from Distance Sampling Data</p></a></li>
<li><a href='#countHist'>
<p>Compute Summary Statistics from Count Histories</p></a></li>
<li><a href='#covDiag'>
<p>Compute Covariance Diagnostic for Lambda in <em>N</em>-mixture Models</p></a></li>
<li><a href='#detHist'>
<p>Compute Summary Statistics from Detection Histories</p></a></li>
<li><a href='#detTime'>
<p>Compute Summary Statistics from Time to Detection Data</p></a></li>
<li><a href='#DIC'>
<p>Computing DIC</p></a></li>
<li><a href='#dictab'>
<p>Create Model Selection Tables from Bayesian Analyses</p></a></li>
<li><a href='#dry.frog'>
<p>Frog Dehydration Experiment on Three Substrate Types</p></a></li>
<li><a href='#evidence'>
<p>Compute Evidence Ratio Between Two Models</p></a></li>
<li><a href='#extractCN'>
<p>Compute Condition Number</p></a></li>
<li><a href='#extractLL'>
<p>Extract Log-Likelihood of Model</p></a></li>
<li><a href='#extractSE'>
<p>Extract SE of Fixed Effects</p></a></li>
<li><a href='#extractX'>
<p>Extract Predictors from Candidate Model List</p></a></li>
<li><a href='#fam.link.mer'>
<p>Extract Distribution Family and Link Function</p></a></li>
<li><a href='#fat'>
<p>Fat Data and Body Measurements</p></a></li>
<li><a href='#gpa'>
<p>GPA Data and Standardized Test Scores</p></a></li>
<li><a href='#ictab'>
<p>Create Model Selection Tables from User-supplied Information</p>
Criterion</a></li>
<li><a href='#importance'>
<p>Compute Importance Values of Variable</p></a></li>
<li><a href='#iron'>
<p>Iron Content in Food</p></a></li>
<li><a href='#lizards'>
<p>Habitat Preference of Lizards</p></a></li>
<li><a href='#mb.gof.test'>
<p>Compute MacKenzie and Bailey Goodness-of-fit Test for Single Season,</p>
Dynamic, and Royle-Nichols Occupancy Models</a></li>
<li><a href='#min.trap'>
<p>Anuran Larvae Counts in Minnow Traps Across Pond Type</p></a></li>
<li><a href='#modavg'>
<p>Compute Model-averaged Parameter Estimate (Multimodel Inference)</p></a></li>
<li><a href='#modavg.utility'>
<p>Various Utility Functions</p></a></li>
<li><a href='#modavgCustom'>
<p>Compute Model-averaged Parameter Estimate from User-supplied Input Based</p>
on (Q)AIC(c)</a></li>
<li><a href='#modavgEffect'>
<p>Compute Model-averaged Effect Sizes (Multimodel Inference on Group Differences)</p></a></li>
<li><a href='#modavgIC'>
<p>Compute Model-averaged Parameter Estimate from User-supplied Information</p>
Criterion</a></li>
<li><a href='#modavgPred'>
<p>Compute Model-averaged Predictions</p></a></li>
<li><a href='#modavgShrink'>
<p>Compute Model-averaged Parameter Estimate with Shrinkage (Multimodel Inference)</p></a></li>
<li><a href='#multComp'>
<p>Create Model Selection Tables based on Multiple Comparisons</p></a></li>
<li><a href='#newt'>
<p>Newt Capture-mark-recapture Data</p></a></li>
<li><a href='#Nmix.gof.test'>
<p>Compute Chi-square Goodness-of-fit Test for N-mixture Models</p></a></li>
<li><a href='#pine'>
<p>Strength of Pine Wood Based on the Density Adjusted for Resin Content</p></a></li>
<li><a href='#predictSE'>
<p>Computing Predicted Values and Standard Errors</p></a></li>
<li><a href='#salamander'>
<p>Salamander Capture-mark-recapture Data</p></a></li>
<li><a href='#summaryOD'>
<p>Display Model Summary Corrected for Overdispersion</p></a></li>
<li><a href='#tortoise'>
<p>Gopher Tortoise Distance Sampling Data</p></a></li>
<li><a href='#turkey'>
<p>Turkey Weight Gain</p></a></li>
<li><a href='#useBIC'>
<p>Computing BIC or QBIC</p></a></li>
<li><a href='#useBICCustom'>
<p>Custom Computation of BIC and QBIC from User-supplied Input</p></a></li>
<li><a href='#xtable'>
<p>Format Objects to LaTeX or HTML</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model Selection and Multimodel Inference Based on (Q)AIC(c)</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc J. Mazerolle &lt;marc.mazerolle@sbf.ulaval.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc J. Mazerolle &lt;marc.mazerolle@sbf.ulaval.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, lattice, MASS, Matrix, nlme, stats4,
survival, unmarked, VGAM, xtable</td>
</tr>
<tr>
<td>Suggests:</td>
<td>betareg, coxme, fitdistrplus, glmmTMB, lavaan, lme4, maxlike,
nnet, ordinal, pscl, R2jags, R2OpenBUGS, R2WinBUGS, jagsUI,
lmerTest</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to implement model selection and multimodel inference based on Akaike's information criterion (AIC) and the second-order AIC (AICc), as well as their quasi-likelihood counterparts (QAIC, QAICc) from various model object classes.  The package implements classic model averaging for a given parameter of interest or predicted values, as well as a shrinkage version of model averaging parameter estimates or effect sizes.  The package includes diagnostics and goodness-of-fit statistics for certain model types including those of 'unmarkedFit' classes estimating demographic parameters after accounting for imperfect detection probabilities.  Some functions also allow the creation of model selection tables for Bayesian models of the 'bugs', 'rjags', and 'jagsUI' classes.  Functions also implement model selection using BIC.  Objects following model selection and multimodel inference can be formatted to LaTeX using 'xtable' methods included in the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-16 17:48:43 UTC; mazerolm</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-16 22:33:58 UTC</td>
</tr>
</table>
<hr>
<h2 id='AICcmodavg-package'>
Model Selection and Multimodel Inference Based on (Q)AIC(c)
</h2><span id='topic+AICcmodavg-package'></span><span id='topic+AICcmodavg'></span>

<h3>Description</h3>

<p>Description:  This package includes functions to create model selection
tables based on Akaike's information criterion (AIC) and the
second-order AIC (AICc), as well as their quasi-likelihood counterparts
(QAIC, QAICc).  The package also features functions to conduct classic
model averaging (multimodel inference) for a given parameter of interest
or predicted values, as well as a shrinkage version of model averaging
parameter estimates.  Other handy functions enable the computation of
relative variable importance, evidence ratios, and confidence sets for
the best model.  The present version supports Cox proportional hazards
models and conditional logistic regression (<code>coxph</code> and
<code>coxme</code> classes), linear models (<code>lm</code> class), generalized
linear models (<code>glm</code>, <code>glm.nb</code>, <code>vglm</code>, <code>hurdle</code>,
and <code>zeroinfl</code> classes), linear models fit by generalized least
squares (<code>gls</code> class), linear mixed models (<code>lme</code> class),
generalized linear mixed models (<code>mer</code>, <code>merMod</code>, and
<code>glmmTMB</code> classes), multinomial and ordinal logistic regressions
(<code>multinom</code>, <code>polr</code>, <code>clm</code>, and <code>clmm</code> classes),
robust regression models (<code>rlm</code> class), beta regression models
(<code>betareg</code> class), parametric survival models (<code>survreg</code>
class), nonlinear models (<code>nls</code> and <code>gnls</code> classes), nonlinear
mixed models (<code>nlme</code> and <code>nlmerMod</code> classes), univariate models
(<code>fitdist</code> and <code>fitdistr</code> classes), and certain types of
latent variable models (<code>lavaan</code> class).  The package also supports
various models of <code>unmarkedFit</code> and <code>maxLikeFit</code> classes
estimating demographic parameters after accounting for imperfect
detection probabilities.  Some functions also allow the creation of
model selection tables for Bayesian models of the <code>bugs</code> and
<code>rjags</code> classes.  Objects following model selection and multimodel
inference can be formatted to LaTeX using <code>xtable</code> methods included
in the package. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> AICcmodavg</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.3-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-11-16</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2 )</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Many functions of the package require a list of models as the input to
conduct model selection and multimodel inference.  Thus, you should
start by organizing the output of the models in a list (See 'Examples'
below).
</p>
<p>This package contains several useful functions for model selection and
multimodel inference for several model classes:
</p>

<dl>
<dt><code><a href="#topic+AICc">AICc</a></code></dt><dd><p>Computes AIC, AICc, and their quasi-likelihood counterparts (QAIC, QAICc).</p>
</dd>
<dt><code><a href="#topic+aictab">aictab</a></code></dt><dd><p>Constructs model selection tables with
number of parameters, AIC, delta AIC, Akaike weights or variants based on AICc, QAIC, and QAICc for a set of candidate models.</p>
</dd>
<dt><code><a href="#topic+bictab">bictab</a></code></dt><dd><p>Constructs model selection tables with number of parameters, BIC, delta BIC, BIC weights for a set of
candidate models.</p>
</dd>
<dt><code><a href="#topic+boot.wt">boot.wt</a></code></dt><dd><p>Computes summary statistics from
detection histories.</p>
</dd>
<dt><code><a href="#topic+confset">confset</a></code></dt><dd><p>Determines the confidence set for the
best model based on one of three criteria.</p>
</dd>
<dt><code><a href="#topic+DIC">DIC</a></code></dt><dd><p>Extracts DIC.</p>
</dd>
<dt><code><a href="#topic+dictab">dictab</a></code></dt><dd><p>Constructs model selection tables with
number of parameters, DIC, delta DIC, DIC weights for a set of
candidate models.</p>
</dd>
<dt><code><a href="#topic+evidence">evidence</a></code></dt><dd><p>Computes the evidence ratio between the
highest-ranked model based on the information criteria selected and a
lower-ranked model.</p>
</dd>
<dt><code><a href="#topic+importance">importance</a></code></dt><dd><p>Computes importance values (w+) for
the support of a given parameter among set of candidate models.</p>
</dd>
<dt><code><a href="#topic+modavg">modavg</a></code></dt><dd><p>Computes model-averaged estimate,
unconditional standard error, and unconditional confidence interval of
a parameter of interest among a set of candidate models.</p>
</dd>
<dt><code><a href="#topic+modavgEffect">modavgEffect</a></code></dt><dd><p>Computes model-averaged effect
sizes between groups based on the entire candidate model set.</p>
</dd>
<dt><code><a href="#topic+modavgShrink">modavgShrink</a></code></dt><dd><p>Computes shrinkage version of
model-averaged estimate, unconditional standard error, and
unconditional confidence interval of a parameter of interest among
entire set of candidate models.</p>
</dd> 
<dt><code><a href="#topic+modavgPred">modavgPred</a></code></dt><dd><p>Computes model-average predictions, 
unconditional SE's, and confidence intervals among entire set of
candidate models.</p>
</dd>
<dt><code><a href="#topic+multComp">multComp</a></code></dt><dd><p>Performs multiple comparisons across
levels of a factor in a model selection framework.</p>
</dd>
<dt><code><a href="#topic+useBIC">useBIC</a></code></dt><dd><p>Computes BIC or a quasi-likelihood
counterparts (QBIC).</p>
</dd>
</dl>

<p>For models not yet supported by the functions above, the following
can be useful for model selection and multimodel inference conducted
from input values supplied by the user:
</p>

<dl>
<dt><code><a href="#topic+AICcCustom">AICcCustom</a></code></dt><dd><p>Computes AIC, AICc, QAIC, and QAICc from
user-supplied input values of log-likelihood and number of
parameters.</p>
</dd>
<dt><code><a href="#topic+aictabCustom">aictabCustom</a></code></dt><dd><p>Creates model selection tables based on
(Q)AIC(c) from user-supplied input values of log-likelihood and
number of parameters.</p>
</dd>
<dt><code><a href="#topic+bictabCustom">bictabCustom</a></code></dt><dd><p>Creates model selection tables based on
(Q)BIC from user-supplied input values of log-likelihood and number
of parameters.</p>
</dd>
<dt><code><a href="#topic+ictab">ictab</a></code></dt><dd><p>Creates model selection tables from user-supplied
values of an information criterion.</p>
</dd>
<dt><code><a href="#topic+modavgCustom">modavgCustom</a></code></dt><dd><p>Computes model-averaged parameter estimate
based on (Q)AIC(c) from user-supplied input values of
log-likelihood, number of parameters, parameter estimates, and
standard errors.</p>
</dd>
<dt><code><a href="#topic+modavgIC">modavgIC</a></code></dt><dd><p>Computes model-averaged parameter estimate
from user-supplied values of information criterion, parameter
estimates, and standard errors.</p>
</dd>
<dt><code><a href="#topic+useBICCustom">useBICCustom</a></code></dt><dd><p>Computes BIC and QBIC from user-supplied
input values of log-likelihoods and number of parameters.</p>
</dd>
</dl>

<p>A number of functions for model diagnostics are available:
</p>

<dl>
<dt><code><a href="#topic+c_hat">c_hat</a></code></dt><dd><p>Estimates variance inflation factor for
binomial or Poisson GLM's based on various estimators.</p>
</dd>
<dt><code><a href="#topic+checkConv">checkConv</a></code></dt><dd><p>Checks the convergence information of
the algorithm for the model.</p>
</dd>
<dt><code><a href="#topic+checkParms">checkParms</a></code></dt><dd><p>Checks the occurrence of parameter
estimates with high standard errors in a model.</p>
</dd>
<dt><code><a href="#topic+countDist">countDist</a></code></dt><dd><p>Computes summary statistics from
distance sampling data.</p>
</dd>
<dt><code><a href="#topic+countHist">countHist</a></code></dt><dd><p>Computes summary statistics from
count history data.</p>
</dd> 
<dt><code><a href="#topic+covDiag">covDiag</a></code></dt><dd><p>Computes covariance diagnostics for
lambda in <em>N</em>-mixture models.</p>
</dd>
<dt><code><a href="#topic+detHist">detHist</a></code></dt><dd><p>Computes summary statistics from
detection histories.</p>
</dd>
<dt><code><a href="#topic+detTime">detTime</a></code></dt><dd><p>Computes summary statistics from
time-to-detection data.</p>
</dd>
<dt><code><a href="#topic+extractCN">extractCN</a></code></dt><dd><p>Extracts condition number from models of
certain classes.</p>
</dd>
<dt><code><a href="#topic+mb.gof.test">mb.gof.test</a></code></dt><dd><p>Computes the MacKenzie and Bailey
goodness-of-fit test for single season and dynamic occupancy models
using the Pearson chi-square statistic.</p>
</dd>
<dt><code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code></dt><dd><p>Computes goodness-of-fit test for
<em>N</em>-mixture models based on the Pearson chi-square statistic.</p>
</dd>
</dl>

<p>Other utility functions include:
</p>

<dl>
<dt><code><a href="#topic+anovaOD">anovaOD</a></code></dt><dd><p>Computes likelihood-ratio test statistic
corrected for overdispersion between two models.</p>
</dd>
<dt><code><a href="#topic+extractLL">extractLL</a></code></dt><dd><p>Extracts log-likelihood from
models of certain classes.</p>
</dd>
<dt><code><a href="#topic+extractSE">extractSE</a></code></dt><dd><p>Extracts standard errors from models of
certain classes and adds the labels.</p>
</dd>
<dt><code><a href="#topic+extractX">extractX</a></code></dt><dd><p>Extracts the predictors and associated
information on variables from a list of candidate models.</p>
</dd>
<dt><code><a href="#topic+fam.link.mer">fam.link.mer</a></code></dt><dd><p>Extracts the distribution family and 
link function from a generalized linear mixed model of classes <code>mer</code>
and <code>merMod</code>.</p>
</dd>
<dt><code><a href="#topic+predictSE">predictSE</a></code></dt><dd><p>Computes predictions and associated 
standard errors models of certain classes.</p>
</dd>
<dt><code><a href="#topic+summaryOD">summaryOD</a></code></dt><dd><p>Displays summary of model output
adjusted for overdispersion.</p>
</dd>
<dt><code><a href="xtable.html#topic+xtable">xtable</a></code></dt><dd><p>Formats various objects resulting from
model selection and multimodel inference to LaTeX or HTML tables.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Marc J. Mazerolle &lt;marc.mazerolle@uqat.ca&gt;.
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based inference in the life sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., and Anderson, D. R. (2002) <em>Model selection and
multimodel inference: a practical information-theoretic approach</em>. Second
edition. Springer: New York. 
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Example 1:  Poisson GLM with offset
##anuran larvae example from Mazerolle (2006) 
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##set up candidate models in a list
Cand.mod &lt;- list()
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[2]] &lt;- glm(Num_anura ~ Type + log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[3]] &lt;- glm(Num_anura ~ Type + Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[4]] &lt;- glm(Num_anura ~ Type, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[5]] &lt;- glm(Num_anura ~ log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[6]] &lt;- glm(Num_anura ~ log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[7]] &lt;- glm(Num_anura ~ Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[8]] &lt;- glm(Num_anura ~ 1, family = poisson,
                     offset = log(Effort), data = min.trap) 
          
##check c-hat for global model
c_hat(Cand.mod[[1]], method = "pearson") #uses Pearson's chi-square/df
##note the very low overdispersion: in this case, the analysis could be
##conducted without correcting for c-hat as its value is reasonably close
##to 1  

##output of model corrected for overdispersion
summaryOD(Cand.mod[[1]], c.hat = 1.04)

##assign names to each model
Modnames &lt;- c("type + logperim + invertpred", "type + logperim",
              "type + invertpred", "type", "logperim + invertpred",
              "logperim", "invertpred", "intercept only") 

##model selection table based on AICc
aictab(cand.set = Cand.mod, modnames = Modnames)

##compute evidence ratio
evidence(aictab(cand.set = Cand.mod, modnames = Modnames))

##compute confidence set based on 'raw' method
confset(cand.set = Cand.mod, modnames = Modnames, second.ord = TRUE,
        method = "raw")  

##compute importance value for "TypeBOG" - same number of models
##with vs without variable
importance(cand.set = Cand.mod, modnames = Modnames, parm = "TypeBOG") 

##compute model-averaged estimate of "TypeBOG" using the natural average
modavg(cand.set = Cand.mod, modnames = Modnames, parm = "TypeBOG")

##compute model-averaged estimate of "TypeBOG" using shrinkage estimator
##same number of models with vs without variable
modavgShrink(cand.set = Cand.mod, modnames = Modnames,
             parm = "TypeBOG")

##compute model-averaged predictions for two types of ponds
##create a data set for predictions
dat.pred &lt;- data.frame(Type = factor(c("BOG", "UPLAND")),
                       log.Perimeter = mean(min.trap$log.Perimeter),
                       Num_ranatra = mean(min.trap$Num_ranatra),
                       Effort = mean(min.trap$Effort))

##model-averaged predictions across entire model set
modavgPred(cand.set = Cand.mod, modnames = Modnames,
           newdata = dat.pred, type = "response")

##compute model-averaged effect size between two groups
##'newdata' data frame must be limited to two rows
modavgEffect(cand.set = Cand.mod, modnames = Modnames,
             newdata = dat.pred, type = "link")


## Not run: 
##Example 2:  single-season occupancy model example modified from ?occu
require(unmarked)
##single season
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
## add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)),
                                sitevar2 = rnorm(numSites(pferUMF))) 
     
## observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) *
                                 obsNum(pferUMF))) 

##check detection history data from data object
detHist(pferUMF)

##set up candidate model set
fm1 &lt;- occu(~ obsvar1 ~ sitevar1, pferUMF)
##check detection history data from model object
detHist(fm1)

fm2 &lt;- occu(~ 1 ~ sitevar1, pferUMF)
fm3 &lt;- occu(~ obsvar1 ~ sitevar2, pferUMF)
fm4 &lt;- occu(~ 1 ~ sitevar2, pferUMF)
Cand.models &lt;- list(fm1, fm2, fm3, fm4)

##assign names to elements in list
##alternative to using 'modnames' argument
names(Cand.models) &lt;- c("fm1", "fm2", "fm3", "fm4")

##check GOF of global model and estimate c-hat
mb.gof.test(fm4, nsim = 100) #nsim should be &gt; 1000

##check for high SE's in models
lapply(Cand.models, checkParms, simplify = FALSE)

##compute table
print(aictab(cand.set = Cand.models,
             second.ord = TRUE), digits = 4)

##export as LaTeX table
if(require(xtable)) {
xtable(aictab(cand.set = Cand.models,
              second.ord = TRUE))
}

##compute evidence ratio
evidence(aictab(cand.set = Cand.models))
##evidence ratio between top model vs lowest-ranked model
evidence(aictab(cand.set = Cand.models), model.high = "fm2", model.low = "fm3")

##compute confidence set based on 'raw' method
confset(cand.set = Cand.models, second.ord = TRUE,
        method = "raw")  

##compute importance value for "sitevar1" on occupancy
##same number of models with vs without variable
importance(cand.set = Cand.models, parm = "sitevar1",
           parm.type = "psi") 

##compute model-averaged estimate of "sitevar1" on occupancy
##(natural average)
modavg(cand.set = Cand.models, parm = "sitevar1",
       parm.type = "psi")

##compute model-averaged estimate of "sitevar1"
##(shrinkage estimator)
##same number of models with vs without variable
modavgShrink(cand.set = Cand.models,
             parm = "sitevar1", parm.type = "psi")

##compute model-average predictions
##check explanatory variables appearing in models
extractX(Cand.models, parm.type = "psi")

##create a data set for predictions
dat.pred &lt;- data.frame(sitevar1 = seq(from = min(siteCovs(pferUMF)$sitevar1),
                         to = max(siteCovs(pferUMF)$sitevar1), by = 0.5),
                       sitevar2 = mean(siteCovs(pferUMF)$sitevar2))

##model-averaged predictions of psi across range of values
##of sitevar1 and entire model set
modavgPred(cand.set = Cand.models, newdata = dat.pred,
           parm.type = "psi")
detach(package:unmarked)

## End(Not run)

## Not run: 
##Example 3:  example with user-supplied values of log-likelihoods and
##number of parameters

##vector with model LL's
LL &lt;- c(-38.8876, -35.1783, -64.8970)
     
##vector with number of parameters
Ks &lt;- c(7, 9, 4)
     
##create a vector of names to trace back models in set
Modnames &lt;- c("Cm1", "Cm2", "Cm3")

##generate AICc table
aictabCustom(logL = LL, K = Ks, modnames = Modnames, nobs = 121,
             sort = TRUE) 
##generate AIC table
aictabCustom(logL = LL, K = Ks, modnames = Modnames,
             second.ord = FALSE, nobs = 121, sort = TRUE)

##model averaging parameter estimate
##vector of beta estimates for a parameter of interest
model.ests &lt;- c(0.0478, 0.0480, 0.0478)
     
##vector of SE's of beta estimates for a parameter of interest
model.se.ests &lt;- c(0.0028, 0.0028, 0.0034)
     
##compute model-averaged estimate and unconditional SE based on AICc
modavgCustom(logL = LL, K = Ks, modnames = Modnames, 
             estimate = model.ests, se = model.se.ests, nobs = 121)
##compute model-averaged estimate and unconditional SE based on BIC
modavgCustom(logL = LL, K = Ks, modnames = Modnames, 
             estimate = model.ests, se = model.se.ests, nobs = 121,
             useBIC = TRUE)

## End(Not run)

## Not run: 
##Example 4:  example with user-supplied values of information criterion
##model selection based on WAIC

##WAIC values
waic &lt;- c(105.74, 107.36, 108.24, 100.57)
##number of effective parameters
effK &lt;- c(7.45, 5.61, 6.14, 6.05)

##create a vector of names to trace back models in set
Modnames &lt;- c("global model", "interactive model",
              "additive model", "invertpred model")

##generate WAIC model selection table
ictab(ic = waic, K = effK, modnames = Modnames,
      sort = TRUE, ic.name = "WAIC")

##compute model-averaged estimate
##vector of predictions
Preds &lt;- c(0.106, 0.137, 0.067, 0.050)
##vector of SE's for prediction
Ses &lt;- c(0.128, 0.159, 0.054, 0.039)

##compute model-averaged estimate and unconditional SE based on WAIC
modavgIC(ic = waic, K = effK, modnames = Modnames, 
         estimate = Preds, se = Ses,
         ic.name = "WAIC")

##export as LaTeX table
if(require(xtable)) {
##model-averaged estimate and confidence interval
xtable(modavgIC(ic = waic, K = effK, modnames = Modnames, 
       estimate = Preds, se = Ses,
       ic.name = "WAIC"))
##model selection table with estimate and SE's from each model
xtable(modavgIC(ic = waic, K = effK, modnames = Modnames, 
       estimate = Preds, se = Ses,
       ic.name = "WAIC"), print.table = TRUE)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='AICc'>
Computing AIC, AICc, QAIC, and QAICc
</h2><span id='topic+AICc'></span><span id='topic+AICc.default'></span><span id='topic+AICc.aov'></span><span id='topic+AICc.betareg'></span><span id='topic+AICc.clm'></span><span id='topic+AICc.clmm'></span><span id='topic+AICc.coxme'></span><span id='topic+AICc.coxph'></span><span id='topic+AICc.fitdist'></span><span id='topic+AICc.fitdistr'></span><span id='topic+AICc.glm'></span><span id='topic+AICc.glmmTMB'></span><span id='topic+AICc.gls'></span><span id='topic+AICc.gnls'></span><span id='topic+AICc.hurdle'></span><span id='topic+AICc.lavaan'></span><span id='topic+AICc.lm'></span><span id='topic+AICc.lme'></span><span id='topic+AICc.lmekin'></span><span id='topic+AICc.maxlikeFit'></span><span id='topic+AICc.mer'></span><span id='topic+AICc.merMod'></span><span id='topic+AICc.lmerModLmerTest'></span><span id='topic+AICc.multinom'></span><span id='topic+AICc.negbin'></span><span id='topic+AICc.nlme'></span><span id='topic+AICc.nls'></span><span id='topic+AICc.polr'></span><span id='topic+AICc.rlm'></span><span id='topic+AICc.survreg'></span><span id='topic+AICc.unmarkedFit'></span><span id='topic+AICc.vglm'></span><span id='topic+AICc.zeroinfl'></span>

<h3>Description</h3>

<p>Functions to compute Akaike's information criterion (AIC), the
second-order AIC (AICc), as well as their quasi-likelihood
counterparts (QAIC, QAICc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc(mod, return.K = FALSE, second.ord = TRUE, nobs = NULL, ...) 

## S3 method for class 'aov'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'betareg'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'clm'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...) 

## S3 method for class 'clmm'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)  

## S3 method for class 'coxme'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...) 

## S3 method for class 'coxph'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...) 

## S3 method for class 'fitdist'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'fitdistr'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'glm'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, c.hat = 1, ...)

## S3 method for class 'glmmTMB'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, c.hat = 1, ...)

## S3 method for class 'gls'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'gnls'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'hurdle'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'lavaan'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'lm'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'lme'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'lmekin'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...) 

## S3 method for class 'maxlikeFit'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, c.hat = 1, ...)

## S3 method for class 'mer'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'merMod'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...) 

## S3 method for class 'lmerModLmerTest'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...) 

## S3 method for class 'multinom'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, c.hat = 1, ...)

## S3 method for class 'negbin'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'nlme'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'nls'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'polr'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'rlm'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'survreg'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)

## S3 method for class 'unmarkedFit'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, c.hat = 1, ...)

## S3 method for class 'vglm'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, c.hat = 1, ...)

## S3 method for class 'zeroinfl'
AICc(mod, return.K = FALSE, second.ord = TRUE,
     nobs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICc_+3A_mod">mod</code></td>
<td>

<p>an object of class <code>aov</code>, <code>betareg</code>, <code>clm</code>,
<code>clmm</code>, <code>clogit</code>, <code>coxme</code>, <code>coxph</code>,
<code>fitdist</code>, <code>fitdistr</code>, <code>glm</code>, <code>glmmTMB</code>,
<code>gls</code>, <code>gnls</code>, <code>hurdle</code>, <code>lavaan</code>, <code>lm</code>,
<code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code>, <code>multinom</code>,
<code>negbin</code>, <code>nlme</code>, <code>nls</code>, <code>polr</code>, <code>rlm</code>,
<code>survreg</code>, <code>vglm</code>, <code>zeroinfl</code>, and various
<code>unmarkedFit</code> classes containing the output of a model.
</p>
</td></tr>
<tr><td><code id="AICc_+3A_return.k">return.K</code></td>
<td>

<p>logical.  If <code>FALSE</code>, the function returns the information
criterion specified.  If <code>TRUE</code>, the function returns K (number
of estimated parameters) for a given model.
</p>
</td></tr>
<tr><td><code id="AICc_+3A_second.ord">second.ord</code></td>
<td>
 
<p>logical.  If <code>TRUE</code>, the function returns the second-order Akaike
information criterion (i.e., AICc). 
</p>
</td></tr>
<tr><td><code id="AICc_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total
sample size to compute the AICc (i.e., <code>nobs</code> defaults to total number
of observations).  This is relevant only for mixed models or various
models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the 
value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="AICc_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>AICc</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td></tr>
<tr><td><code id="AICc_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AICc</code> computes one of the following four information criteria:
</p>
<p>Akaike's information criterion (AIC, Akaike 1973), </p>
<p style="text-align: center;"><code class="reqn">-2 *
  log-likelihood + 2 * K,</code>
</p>
<p> where the log-likelihood is the maximum
log-likelihood of the model and <em>K</em> corresponds to the number of
estimated parameters.
</p>
<p>Second-order or small sample AIC (AICc, Sugiura   1978, Hurvich and
Tsai 1989, 1991), </p>
<p style="text-align: center;"><code class="reqn">-2 * log-likelihood + 2 * K  * (n/(n - K - 1)),</code>
</p>

<p>where <em>n</em> is the sample size of the data set.
</p>
<p>Quasi-likelihood AIC (QAIC, Burnham and Anderson 2002), </p>
<p style="text-align: center;"><code class="reqn">QAIC =
  \frac{-2 * log-likelihood}{c-hat} + 2 * K,</code>
</p>
<p> where <em>c-hat</em> is the
overdispersion parameter specified by the user with the argument
<code>c.hat</code>.
</p>
<p>Quasi-likelihood AICc (QAICc, Burnham and Anderson 2002), </p>
<p style="text-align: center;"><code class="reqn">QAIC = 
  \frac{-2 * log-likelihood}{c-hat} + 2 * K * (n/(n - K - 1))</code>
</p>
<p>. 
</p>
<p>Note that AIC and AICc values are meaningful to select among
<code>gls</code> or <code>lme</code> models fit by maximum likelihood. AIC and
AICc based on REML are valid to select among different models that
only differ in their random effects (Pinheiro and Bates 2000).
</p>


<h3>Value</h3>

<p><code>AICc</code> returns the AIC, AICc, QAIC, or QAICc, or the number of
estimated parameters, depending on the values of the arguments.
</p>


<h3>Note</h3>

<p>The actual (Q)AIC(c) values are not really interesting in themselves,
as they depend directly on the data, parameters estimated, and
likelihood function.  Furthermore, a single value does not tell much
about model fit.  Information criteria become relevant when compared
to one another for a given data set and set of candidate models.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Akaike, H. (1973) Information theory as an extension of the maximum
likelihood principle. In:  <em>Second International Symposium on
Information Theory</em>, pp. 267&ndash;281. Petrov, B.N., Csaki, F., Eds,
Akademiai Kiado, Budapest.
</p>
<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life
Sciences: a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>Hurvich, C. M., Tsai, C.-L. (1989) Regression and time series model
selection in small samples. <em>Biometrika</em> <b>76</b>, 297&ndash;307. 
</p>
<p>Hurvich, C. M., Tsai, C.-L. (1991) Bias of the corrected AIC
criterion for underfitted regression and time series
models. <em>Biometrika</em> <b>78</b>, 499&ndash;509. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Pinheiro, J. C., Bates, D. M. (2000) <em>Mixed-effect models in S and
S-PLUS</em>. Springer Verlag: New York.  
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>
<p>Sugiura, N. (1978) Further analysis of the data by Akaike's
information criterion and the finite corrections. <em>Communications
in Statistics:  Theory and Methods</em> <b>A7</b>, 13&ndash;26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICcCustom">AICcCustom</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+confset">confset</a></code>,
<code><a href="#topic+importance">importance</a></code>, <code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgShrink">modavgShrink</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>, <code><a href="#topic+useBIC">useBIC</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##cement data from Burnham and Anderson (2002, p. 101)
data(cement)
##run multiple regression - the global model in Table 3.2
glob.mod &lt;- lm(y ~ x1 + x2 + x3 + x4, data = cement)

##compute AICc with full likelihood
AICc(glob.mod, return.K = FALSE)

##compute AIC with full likelihood 
AICc(glob.mod, return.K = FALSE, second.ord = FALSE)
##note that Burnham and Anderson (2002) did not use full likelihood
##in Table 3.2 and that the MLE estimate of the variance was
##rounded to 2 digits after decimal point  


##compute AICc for mixed model on Orthodont data set in Pinheiro and
##Bates (2000)
## Not run: 
require(nlme)
m1 &lt;- lme(distance ~ age, random = ~1 | Subject, data = Orthodont,
          method= "ML")
AICc(m1, return.K = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='AICcCustom'>
Compute AIC, AICc, QAIC, and QAICc from User-supplied Input
</h2><span id='topic+AICcCustom'></span>

<h3>Description</h3>

<p>This function computes Akaike's information criterion (AIC), the
second-order AIC (AICc), as well as their quasi-likelihood
counterparts (QAIC, QAICc) from user-supplied input instead of
extracting the values automatically from a model object.  This
function is particularly useful for output imported from other
software or for model classes that are not currently supported by
<code>AICc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICcCustom(logL, K, return.K = FALSE, second.ord = TRUE, nobs = NULL,
           c.hat = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICcCustom_+3A_logl">logL</code></td>
<td>

<p>the value of the model log-likelihood.
</p>
</td></tr>
<tr><td><code id="AICcCustom_+3A_k">K</code></td>
<td>

<p>the number of estimated parameters in the model.
</p>
</td></tr>
<tr><td><code id="AICcCustom_+3A_return.k">return.K</code></td>
<td>

<p>logical.  If <code>FALSE</code>, the function returns the information
criterion specified.  If <code>TRUE</code>, the function returns K (number
of estimated parameters) for a given model.  
</p>
</td></tr>
<tr><td><code id="AICcCustom_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order Akaike
information criterion (i.e., AICc). 
</p>
</td></tr>
<tr><td><code id="AICcCustom_+3A_nobs">nobs</code></td>
<td>

<p>the sample size required to compute the AICc or QAICc.
</p>
</td></tr>
<tr><td><code id="AICcCustom_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>.  Note that values of
<code>c.hat</code> different from 1 are only appropriate for binomial GLM's
with trials &gt; 1 (i.e., success/trial or cbind(success, failure)
syntax), with Poisson GLM's, single-season or dynamic occupancy
models (MacKenzie et al. 2002, 2003), <em>N</em>-mixture models (Royle
2004, Dail and Madsen 2011), or capture-mark-recapture models (e.g.,
Lebreton et al. 1992).  If c.hat &gt; 1, <code>AICcCustom</code> will return
the quasi-likelihood analogue of the information criterion requested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AICcCustom</code> computes one of the following four information criteria:
</p>
<p>Akaike's information criterion (AIC, Akaike 1973), the  second-order
or small sample AIC (AICc, Sugiura   1978, Hurvich and Tsai 1989, 1991), the
quasi-likelihood AIC (QAIC, Burnham and Anderson 2002), and the
quasi-likelihood AICc (QAICc, Burnham and Anderson 2002).
</p>


<h3>Value</h3>

<p><code>AICcCustom</code> returns the AIC, AICc, QAIC, or QAICc, or the number
of estimated parameters, depending on the values of the arguments.
</p>


<h3>Note</h3>

<p>The actual (Q)AIC(c) values are not really interesting in themselves,
as they depend directly on the data, parameters estimated, and
likelihood function.  Furthermore, a single value does not tell much
about model fit.  Information criteria become relevant when compared
to one another for a given data set and set of candidate models.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Akaike, H. (1973) Information theory as an extension of the maximum
likelihood principle. In:  <em>Second International Symposium on
Information Theory</em>, pp. 267&ndash;281. Petrov, B.N., Csaki, F., Eds,
Akademiai Kiado, Budapest.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>Hurvich, C. M., Tsai, C.-L. (1989) Regression and time series model
selection in small samples. <em>Biometrika</em> <b>76</b>, 297&ndash;307.  
</p>
<p>Hurvich, C. M., Tsai, C.-L. (1991) Bias of the corrected AIC
criterion for underfitted regression and time series
models. <em>Biometrika</em> <b>78</b>, 499&ndash;509. 
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67&ndash;118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>
<p>Sugiura, N. (1978) Further analysis of the data by Akaike's
information criterion and the finite corrections. <em>Communications
in Statistics:  Theory and Methods</em> <b>A7</b>, 13&ndash;26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictabCustom">aictabCustom</a></code>, <code><a href="#topic+confset">confset</a></code>, 
<code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##cement data from Burnham and Anderson (2002, p. 101)
data(cement)
##run multiple regression - the global model in Table 3.2
glob.mod &lt;- lm(y ~ x1 + x2 + x3 + x4, data = cement)

##extract log-likelihood
LL &lt;- logLik(glob.mod)[1]

##extract number of parameters
K.mod &lt;- coef(glob.mod) + 1

##compute AICc with full likelihood
AICcCustom(LL, K.mod, nobs = nrow(cement))
</code></pre>

<hr>
<h2 id='AICcmodavg-defunct'>
Defunct Functions in AICcmodavg Package
</h2><span id='topic+AICcmodavg-defunct'></span><span id='topic+AICc.mult'></span><span id='topic+AICc.unmarked'></span><span id='topic+extract.LL'></span><span id='topic+extract.LL.coxph'></span><span id='topic+extract.LL.unmarked'></span><span id='topic+aictab.clm'></span><span id='topic+aictab.clmm'></span><span id='topic+aictab.coxph'></span><span id='topic+aictab.glm'></span><span id='topic+aictab.gls'></span><span id='topic+aictab.lm'></span><span id='topic+aictab.lme'></span><span id='topic+aictab.mer'></span><span id='topic+aictab.merMod'></span><span id='topic+aictab.mult'></span><span id='topic+aictab.nlme'></span><span id='topic+aictab.nls'></span><span id='topic+aictab.polr'></span><span id='topic+aictab.rlm'></span><span id='topic+aictab.unmarked'></span><span id='topic+dictab.bugs'></span><span id='topic+dictab.rjags'></span><span id='topic+modavg.clm'></span><span id='topic+modavg.clmm'></span><span id='topic+modavg.coxph'></span><span id='topic+modavg.glm'></span><span id='topic+modavg.gls'></span><span id='topic+modavg.lme'></span><span id='topic+modavg.clm'></span><span id='topic+modavg.mer'></span><span id='topic+modavg.merMod'></span><span id='topic+modavg.mult'></span><span id='topic+modavg.polr'></span><span id='topic+modavg.rlm'></span><span id='topic+modavg.unmarked'></span><span id='topic+modavg.effect'></span><span id='topic+modavg.effect.glm'></span><span id='topic+modavg.effect.gls'></span><span id='topic+modavg.effect.lme'></span><span id='topic+modavg.effect.mer'></span><span id='topic+modavg.effect.merMod'></span><span id='topic+modavg.effect.rlm'></span><span id='topic+modavg.effect.unmarked'></span><span id='topic+modavg.shrink'></span><span id='topic+modavg.shrink.clm'></span><span id='topic+modavg.shrink.clmm'></span><span id='topic+modavg.shrink.coxph'></span><span id='topic+modavg.shrink.glm'></span><span id='topic+modavg.shrink.gls'></span><span id='topic+modavg.shrink.lme'></span><span id='topic+modavg.shrink.mer'></span><span id='topic+modavg.shrink.merMod'></span><span id='topic+modavg.shrink.mult'></span><span id='topic+modavg.shrink.polr'></span><span id='topic+modavg.shrink.rlm'></span><span id='topic+modavg.shrink.unmarked'></span><span id='topic+modavgpred'></span><span id='topic+modavgpred.glm'></span><span id='topic+modavgpred.gls'></span><span id='topic+modavgpred.lme'></span><span id='topic+modavgpred.mer'></span><span id='topic+modavgpred.merMod'></span><span id='topic+modavgpred.rlm'></span><span id='topic+modavgpred.unmarked'></span><span id='topic+mult.comp'></span><span id='topic+predictSE.zip'></span>

<h3>Description</h3>

<p>The functions listed below have been removed from the
<code>AICcmodavg</code> package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc.mult(...)
AICc.unmarked(...)
extract.LL(...)
extract.LL.coxph(...)
extract.LL.unmarked(...)
aictab.clm(...)
aictab.clmm(...)
aictab.coxph(...)
aictab.glm(...)
aictab.gls(...)
aictab.lm(...)
aictab.lme(...)
aictab.mer(...)
aictab.merMod(...)
aictab.mult(...)
aictab.nlme(...)
aictab.nls(...)
aictab.polr(...)
aictab.rlm(...)
aictab.unmarked(...)
dictab.bugs(...)
dictab.rjags(...)
modavg.clm(...)
modavg.clmm(...)
modavg.coxph(...)
modavg.glm(...)
modavg.gls(...)
modavg.lme(...)
modavg.mer(...)
modavg.merMod(...)
modavg.mult(...)
modavg.polr(...)
modavg.rlm(...)
modavg.unmarked(...)
modavg.effect(...)
modavg.effect.glm(...)
modavg.effect.gls(...)
modavg.effect.lme(...)
modavg.effect.mer(...)
modavg.effect.merMod(...)
modavg.effect.rlm(...)
modavg.effect.unmarked(...)
modavg.shrink(...)
modavg.shrink.clm(...)
modavg.shrink.clmm(...)
modavg.shrink.coxph(...)
modavg.shrink.glm(...)
modavg.shrink.gls(...)
modavg.shrink.lme(...)
modavg.shrink.mer(...)
modavg.shrink.merMod(...)
modavg.shrink.mult(...)
modavg.shrink.polr(...)
modavg.shrink.rlm(...)
modavg.shrink.unmarked(...)
modavgpred(...)
modavgpred.glm(...)
modavgpred.gls(...)
modavgpred.lme(...)
modavgpred.mer(...)
modavgpred.merMod(...)
modavgpred.rlm(...)
modavgpred.unmarked(...)
mult.comp(...)
predictSE.zip(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICcmodavg-defunct_+3A_...">...</code></td>
<td>

<p>arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AICc.mult</code> has been replaced by <code>AICc.multinom</code>.
</p>
<p><code>AICc.unmarked</code> has been replaced by <code>AICc.unmarkedFit</code>.
</p>
<p><code>extract.LL</code> has been replaced by <code>extractLL</code>.
</p>
<p><code>extract.LL.coxph</code> has been replaced by <code>extractLL.coxph</code>.
</p>
<p><code>extract.LL.unmarked</code> has been replaced by
<code>extractLL.unmarkedFit</code>.
</p>
<p><code>aictab.clm</code> has been replaced by <code>aictab.AICsclm.clm</code>. 
</p>
<p><code>aictab.clmm</code> has been replaced by <code>aictab.AICclmm</code>.
</p>
<p><code>aictab.coxph</code> has been replaced by <code>aictab.AICcoxph</code>. 
</p>
<p><code>aictab.glm</code> has been replaced by <code>aictab.AICglm.lm</code>.
</p>
<p><code>aictab.gls</code> has been replaced by <code>aictab.AICgls</code>.
</p>
<p><code>aictab.lm</code> has been replaced by <code>aictab.AIClm</code>.
</p>
<p><code>aictab.lme</code> has been replaced by <code>aictab.AIClme</code>.
</p>
<p><code>aictab.mer</code> has been replaced by <code>aictab.AICmer</code>.
</p>
<p><code>aictab.merMod</code> has been replaced by <code>aictab.AIClmerMod</code>,
<code>aictab.AICglmerMod</code>, or <code>aictab.AICnlmerMod</code>,
depending on the class of the objects. 
</p>
<p><code>aictab.mult</code> has been replaced by
<code>aictab.AICmultinom.nnet</code>.
</p>
<p><code>aictab.nlme</code> has been replaced by <code>aictab.AICnlme</code>. 
</p>
<p><code>aictab.nls</code> has been replaced by <code>aictab.AICnls</code>.
</p>
<p><code>aictab.polr</code> has been replaced by <code>aictab.AICpolr</code>. 
</p>
<p><code>aictab.rlm</code> has been replaced by <code>aictab.AICrlm.lm</code>. 
</p>
<p><code>aictab.unmarked</code> has been replaced by
<code>aictab.AICunmarkedFitOccu</code>,
<code>aictab.AICunmarkedFitColExt</code>,
<code>aictab.AICunmarkedFitOccuRN</code>,
<code>aictab.AICunmarkedFitPCount</code>,
<code>aictab.AICunmarkedFitPCO</code>, <code>aictab.AICunmarkedFitDS</code>,
<code>aictab.AICunmarkedFitGDS</code>,
<code>aictab.AICunmarkedFitOccuFP</code>,
<code>aictab.AICunmarkedFitMPois</code>,
<code>aictab.AICunmarkedFitGMM</code>, or
<code>aictab.AICunmarkedFitGPC</code>, depending on the class of the
objects.
</p>
<p><code>dictab.bugs</code> has been replaced by <code>dictab.AICbugs</code>. 
</p>
<p><code>dictab.jags</code> has been replaced by <code>dictab.AICjags</code>. 
</p>
<p><code>modavg.clm</code> has been replaced by <code>modavg.AICsclm.clm</code>.
</p>
<p><code>modavg.clmm</code> has been replaced by <code>modavg.AICsclm.clm</code>.
</p>
<p><code>modavg.coxph</code> has been replaced by <code>modavg.AICcoxph</code>.
</p>
<p><code>modavg.glm</code> has been replaced by <code>modavg.AIClm</code> or
<code>modavg.AICglm.lm</code>, depending on the class of the objects.
</p>
<p><code>modavg.gls</code> has been replaced by <code>modavg.AICgls</code>.
</p>
<p><code>modavg.lme</code> has been replaced by <code>modavg.AIClme</code>.
</p>
<p><code>modavg.mer</code> has been replaced by <code>modavg.AICmer</code>.
</p>
<p><code>modavg.merMod</code> has been replaced by <code>modavg.AIClmerMod</code> or
<code>modavg.AICglmerMod</code>, depending on the class of the objects.
</p>
<p><code>modavg.mult</code> has been replaced by <code>modavg.AICmultinom.nnet</code>.
</p>
<p><code>modavg.polr</code> has been replaced by <code>modavg.AICpolr</code>.
</p>
<p><code>modavg.rlm</code> has been replaced by <code>modavg.AICrlm.lm</code>.
</p>
<p><code>modavg.unmarked</code> has been replaced by
<code>modavg.AICunmarkedFitOccu</code>,
<code>modavg.AICunmarkedFitColExt</code>,
<code>modavg.AICunmarkedFitOccuRN</code>,
<code>modavg.AICunmarkedFitPCount</code>,
<code>modavg.AICunmarkedFitPCO</code>, <code>modavg.AICunmarkedFitDS</code>,
<code>modavg.AICunmarkedFitGDS</code>,
<code>modavg.AICunmarkedFitOccuFP</code>,
<code>modavg.AICunmarkedFitMPois</code>,
<code>modavg.AICunmarkedFitGMM</code>, or
<code>modavg.AICunmarkedFitGPC</code>, depending on the class of the
objects.
</p>
<p><code>modavg.effect</code> has been replaced by <code>modavgEffect</code>.
</p>
<p><code>modavg.effect.glm</code> has been replaced by
<code>modavgEffect.AICglm.lm</code> or <code>modavgEffect.AIClm</code>,
depending on the class of the objects.
</p>
<p><code>modavg.effect.gls</code> has been replaced by
<code>modavgEffect.AICgls</code>.
</p>
<p><code>modavg.effect.lme</code> has been replaced by
<code>modavgEffect.AIClme</code>. 
</p>
<p><code>modavg.effect.mer</code> has been replaced by
<code>modavgEffect.AICmer</code>. 
</p>
<p><code>modavg.effect.merMod</code> has been replaced by
<code>modavgEffect.AICglmerMod</code> or
<code>modavgEffect.AIClmerMod</code>, depending on the class of the objects.
</p>
<p><code>modavg.effect.rlm</code> has been replaced by
<code>modavgEffect.AICrlm.lm</code>.
</p>
<p><code>modavg.effect.unmarked</code> has been replaced by
<code>modavgEffect.AICunmarkedFitOccu</code>, 
<code>modavgEffect.AICunmarkedFitColExt</code>,
<code>modavgEffect.AICunmarkedFitOccuRN</code>,
<code>modavgEffect.AICunmarkedFitPCount</code>,
<code>modavgEffect.AICunmarkedFitPCO</code>,
<code>modavgEffect.AICunmarkedFitDS</code>, 
<code>modavgEffect.AICunmarkedFitGDS</code>,
<code>modavgEffect.AICunmarkedFitOccuFP</code>,
<code>modavgEffect.AICunmarkedFitMPois</code>,
<code>modavgEffect.AICunmarkedFitGMM</code>, or
<code>modavgEffect.AICunmarkedFitGPC</code>, depending on the class of the
objects.
</p>
<p><code>modavg.shrink</code> has been replaced by <code>modavgShrink</code>. 
</p>
<p><code>modavg.shrink.clm</code> has been replaced by
<code>modavgShrink.AICsclm.clm</code>. 
</p>
<p><code>modavg.shrink.clmm</code> has been replaced by
<code>modavgShrink.AICclmm</code>. 
</p>
<p><code>modavg.shrink.coxph</code> has been replaced by
<code>modavgShrink.AICcoxph</code>. 
</p>
<p><code>modavg.shrink.glm</code> has been replaced by
<code>modavgShrink.AICglm.lm</code> or <code>modavgShrink.AICglm.lm</code>,
depending on the class of the objects. 
</p>
<p><code>modavg.shrink.gls</code> has been replaced by
<code>modavgShrink.AICgls</code>. 
</p>
<p><code>modavg.shrink.lme</code> has been replaced by
<code>modavgShrink.AIClme</code>. 
</p>
<p><code>modavg.shrink.mer</code> has been replaced by
<code>modavgShrink.AICmer</code>. 
</p>
<p><code>modavg.shrink.merMod</code> has been replaced by
<code>modavgShrink.AICglmerMod</code> or
<code>modavgShrink.AIClmerMod</code>, depending on the class of the
objects.
</p>
<p><code>modavg.shrink.mult</code> has been replaced by
<code>modavgShrink.AICmultinom.nnet</code>. 
</p>
<p><code>modavg.shrink.polr</code> has been replaced by
<code>modavgShrink.AICpolr</code>. 
</p>
<p><code>modavg.shrink.rlm</code> has been replaced by
<code>modavgShrink.AICrlm.lm</code> 
</p>
<p><code>modavg.shrink.unmarked</code> has been replaced by
<code>modavgShrink.AICunmarkedFitOccu</code>,
<code>modavgShrink.AICunmarkedFitColExt</code>, 
<code>modavgShrink.AICunmarkedFitOccuRN</code>,
<code>modavgShrink.AICunmarkedFitPCount</code>,
<code>modavgShrink.AICunmarkedFitPCO</code>,
<code>modavgShrink.AICunmarkedFitDS</code>, 
<code>modavgShrink.AICunmarkedFitGDS</code>,
<code>modavgShrink.AICunmarkedFitOccuFP</code>,
<code>modavgShrink.AICunmarkedFitMPois</code>,
<code>modavgShrink.AICunmarkedFitGMM</code>, or
<code>modavgShrink.AICunmarkedFitGPC</code>, depending on the class of
the objects.
</p>
<p><code>modavgpred</code> has been replaced by <code>modavgPred</code>.
</p>
<p><code>modavgpred.glm</code> has been replaced by
<code>modavgpred.AICglm.lm</code> or <code>modavgPred.AIClm</code>,
depending on the class of the objects.
</p>
<p><code>modavgpred.gls</code> has been replaced by <code>modavgPred.AICgls</code>.  
</p>
<p><code>modavgpred.lme</code> has been replaced by <code>modavgPred.AIClme</code>.
</p>
<p><code>modavgpred.mer</code> has been replaced by <code>modavgPred.AICmer</code>.
</p>
<p><code>modavgpred.merMod</code> has been replaced by
<code>modavgpred.AICglmerMod</code> or <code>modavgPred.AIClmerMod</code>,
depending on the class of the objects.
</p>
<p><code>modavgpred.rlm</code> has been replaced by
<code>modavgPred.AICrlm.lm</code>. 
</p>
<p><code>modavgpred.unmarked</code> has been replaced by
<code>modavgPred.AICunmarkedFitOccu</code>,
<code>modavgPred.AICunmarkedFitColExt</code>, 
<code>modavgPred.AICunmarkedFitOccuRN</code>,
<code>modavgPred.AICunmarkedFitPCount</code>,
<code>modavgPred.AICunmarkedFitPCO</code>,
<code>modavgPred.AICunmarkedFitDS</code>, 
<code>modavgPred.AICunmarkedFitGDS</code>,
<code>modavgPred.AICunmarkedFitOccuFP</code>,
<code>modavgPred.AICunmarkedFitMPois</code>,
<code>modavgPred.AICunmarkedFitGMM</code>, or
<code>modavgPred.AICunmarkedFitGPC</code>, depending on the class of
the objects.
</p>
<p><code>mult.comp</code> has been replaced by <code>multComp</code>.
</p>
<p><code>predictSE.zip</code> has been replaced by <code>predictSE</code>.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+dictab">dictab</a></code>, 
<code><a href="#topic+importance">importance</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+extractLL">extractLL</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgEffect">modavgEffect</a></code>,
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code>,
<code><a href="#topic+multComp">multComp</a></code>, <code><a href="#topic+predictSE">predictSE</a></code>
</p>

<hr>
<h2 id='aictab'>
Create Model Selection Tables
</h2><span id='topic+aictab'></span><span id='topic+aictab.default'></span><span id='topic+aictab.AICaov.lm'></span><span id='topic+aictab.AICbetareg'></span><span id='topic+aictab.AICsclm.clm'></span><span id='topic+aictab.AICclm'></span><span id='topic+aictab.AICclmm'></span><span id='topic+aictab.AICcoxme'></span><span id='topic+aictab.AICcoxph'></span><span id='topic+aictab.AICfitdist'></span><span id='topic+aictab.AICfitdistr'></span><span id='topic+aictab.AICglm.lm'></span><span id='topic+aictab.AICglmmTMB'></span><span id='topic+aictab.AICgls'></span><span id='topic+aictab.AICgnls.gls'></span><span id='topic+aictab.AIChurdle'></span><span id='topic+aictab.AIClavaan'></span><span id='topic+aictab.AIClm'></span><span id='topic+aictab.AIClme'></span><span id='topic+aictab.AIClmekin'></span><span id='topic+aictab.AICmaxlikeFit.list'></span><span id='topic+aictab.AICmer'></span><span id='topic+aictab.AIClmerMod'></span><span id='topic+aictab.AIClmerModLmerTest'></span><span id='topic+aictab.AICglmerMod'></span><span id='topic+aictab.AICnlmerMod'></span><span id='topic+aictab.AICmultinom.nnet'></span><span id='topic+aictab.AICnegbin.glm.lm'></span><span id='topic+aictab.AICnlme.lme'></span><span id='topic+aictab.AICnls'></span><span id='topic+aictab.AICpolr'></span><span id='topic+aictab.AICrlm.lm'></span><span id='topic+aictab.AICsurvreg'></span><span id='topic+aictab.AICunmarkedFitOccu'></span><span id='topic+aictab.AICunmarkedFitColExt'></span><span id='topic+aictab.AICunmarkedFitOccuRN'></span><span id='topic+aictab.AICunmarkedFitPCount'></span><span id='topic+aictab.AICunmarkedFitPCO'></span><span id='topic+aictab.AICunmarkedFitDS'></span><span id='topic+aictab.AICunmarkedFitGDS'></span><span id='topic+aictab.AICunmarkedFitOccuFP'></span><span id='topic+aictab.AICunmarkedFitMPois'></span><span id='topic+aictab.AICunmarkedFitGMM'></span><span id='topic+aictab.AICunmarkedFitGPC'></span><span id='topic+aictab.AICunmarkedFitOccuMulti'></span><span id='topic+aictab.AICunmarkedFitOccuMS'></span><span id='topic+aictab.AICunmarkedFitOccuTTD'></span><span id='topic+aictab.AICunmarkedFitMMO'></span><span id='topic+aictab.AICunmarkedFitDSO'></span><span id='topic+aictab.AICvglm'></span><span id='topic+aictab.AICzeroinfl'></span><span id='topic+print.aictab'></span>

<h3>Description</h3>

<p>This function creates a model selection table based on one of the
following information criteria:  AIC, AICc, QAIC, QAICc.  The table
ranks the models based on the selected information criteria and also
provides delta AIC and Akaike weights.  <code>aictab</code> selects the
appropriate function to create the model selection table based on the 
object class.  The current version works with lists containing objects
of <code>aov</code>, <code>betareg</code>, <code>clm</code>, <code>clmm</code>, <code>clogit</code>,
<code>coxme</code>, <code>coxph</code>, <code>fitdist</code>, <code>fitdistr</code>, <code>glm</code>,
<code>glmmTMB</code>, <code>gls</code>, <code>gnls</code>, <code>hurdle</code>, <code>lavaan</code>,
<code>lm</code>, <code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code>, <code>multinom</code>, <code>negbin</code>,
<code>nlme</code>, <code>nls</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>,
<code>vglm</code>, and <code>zeroinfl</code> classes as well as various models of
<code>unmarkedFit</code> classes but does not yet allow mixing of different
classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aictab(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, ...)

## S3 method for class 'AICaov.lm'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICbetareg'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICsclm.clm'
aictab(cand.set, modnames = NULL,
       second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICclmm'
aictab(cand.set, modnames = NULL,
       second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICclm'
aictab(cand.set, modnames = NULL,
       second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICcoxme'
aictab(cand.set, modnames = NULL,
       second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICcoxph'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICfitdist'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICfitdistr'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICglm.lm'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)  

## S3 method for class 'AICglmmTMB'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)  

## S3 method for class 'AICgls'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICgnls.gls'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIChurdle'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClavaan'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClm'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClme'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClmekin'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICmaxlikeFit.list'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...) 

## S3 method for class 'AICmer'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClmerMod'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClmerModLmerTest'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICglmerMod'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...) 

## S3 method for class 'AICnlmerMod'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICmultinom.nnet'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICnegbin.glm.lm'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...) 

## S3 method for class 'AICnlme.lme'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...) 

## S3 method for class 'AICnls'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICpolr'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICrlm.lm'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICsurvreg'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICunmarkedFitOccu'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitColExt'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitPCount'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitPCO'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitDS'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitGDS'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitMPois'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitGMM'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitGPC'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitMMO'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitDSO'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICvglm'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
aictab(cand.set, modnames = NULL,
        second.ord = TRUE, nobs = NULL, sort = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aictab_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="aictab_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models (i.e., a named
list).  If no names appear in the list and no character vector is
provided, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are supplied in
the table in the same order as in the list of candidate models.
</p>
</td></tr>
<tr><td><code id="aictab_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="aictab_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.
In such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="aictab_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the (Q)AIC(c) values.
</p>
</td></tr>
<tr><td><code id="aictab_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>aictab</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td></tr>
<tr><td><code id="aictab_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aictab</code> internally creates a new class for the <code>cand.set</code>
list of candidate models, according to the contents of the list. The
current function is implemented for <code>clogit</code>, <code>coxme</code>,
<code>coxph</code>, <code>fitdist</code>, <code>fitdistr</code>, <code>glm</code>,
<code>glmmTMB</code>, <code>gls</code>, <code>gnls</code>, <code>hurdle</code>, <code>lavaan</code>,
<code>lm</code>, <code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code>, <code>multinom</code>, <code>negbin</code>,
<code>nlme</code>, <code>nls</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>,
<code>vglm</code>, and <code>zeroinfl</code> classes as well as various
<code>unmarkedFit</code> classes.
</p>
<p>The function constructs a model selection table based on one of the four
information criteria: AIC, AICc, QAIC, and QAICc.
</p>
<p>Ten guidelines for model selection:
</p>
<p>1) Carefully construct your candidate model set.  Each model
should represent a specific (interesting) hypothesis to test.
</p>
<p>2) Keep your candidate model set short.  It is ill-advised to consider
as many models as there are data.
</p>
<p>3) Check model fit.  Use your global model (most complex model) or
subglobal models to determine if the assumptions are valid.  If none of
your models fit the data well, information criteria will only indicate
the most parsimonious of the poor models.  
</p>
<p>4) Avoid data dredging (i.e., looking for patterns after an initial round
of analysis). 
</p>
<p>5) Avoid overfitting models.  You should not estimate too many
parameters for the number of observations available in the sample.
</p>
<p>6) Be careful of missing values.  Remember that values that are missing
only for certain variables change the data set and sample size,
depending on which variable is included in any given model.  I suggest
to remove missing cases before starting model selection. 
</p>
<p>7) Use the same response variable for all models of the candidate model
set.  It is inappropriate to run some models with a transformed response
variable and others with the untransformed variable.  A workaround is to
use a different link function for some models (e.g., identity vs log link).
</p>
<p>8) When dealing with models with overdispersion, use the same value of
c-hat for all models in the candidate model set.  For binomial models
with trials &gt; 1 (i.e., success/trial or cbind(success, failure) syntax)
or with Poisson GLM's, you should estimate the c-hat from the most
complex model (global model).  If c-hat &gt; 1, you should use the same
value for each model of the candidate model set (where appropriate) and
include it in the count of parameters (K).  Similarly, for negative
binomial models, you should estimate the dispersion parameter from the
global model and use the same value across all models.  
</p>
<p>9) Burnham and Anderson (2002) recommend to avoid mixing the
information-theoretic approach and notions of significance (i.e., P
values).  It is best to provide estimates and a measure of their
precision (standard error, confidence intervals).
</p>
<p>10) Determining the ranking of the models is just the first step.
Akaike weights sum to 1 for the entire model set and can be interpreted
as the weight of evidence in favor of a given model being the best one
given the candidate model set considered and the data at hand.  Models
with large Akaike weights have strong support.  Evidence ratios,
importance values, and confidence sets for the best model are all
measures that assist in interpretation.  In cases where the top ranking
model has an  Akaike weight &gt; 0.9, one can base inference on this single
most parsimonious model.  When many models rank highly (i.e., delta
(Q)AIC(c) &lt; 4), one should model-average effect sizes for the parameters
with most support across the entire set of models.  Model averaging
consists in making inference based on the whole set of candidate models,
instead of basing conclusions on a single 'best' model.  It is an
elegant way of making inference based on the information contained in
the entire model set.  
</p>


<h3>Value</h3>

<p><code>aictab</code> creates an object of class <code>aictab</code> with the
following components:
</p>
<table>
<tr><td><code>Modname</code></td>
<td>
<p>the name of each model of the candidate model set.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of estimated parameters for each model.</p>
</td></tr>
<tr><td><code>(Q)AIC(c)</code></td>
<td>
<p>the information criterion requested for each model
(AIC, AICc, QAIC, QAICc).</p>
</td></tr>
<tr><td><code>Delta_(Q)AIC(c)</code></td>
<td>
<p>the appropriate delta AIC component depending on
the information criteria selected.</p>
</td></tr>
<tr><td><code>ModelLik</code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td></tr> 
<tr><td><code>(Q)AIC(c)Wt</code></td>
<td>
<p>the Akaike weights, also termed &quot;model
probabilities&quot; sensu Burnham and Anderson (2002) and Anderson (2008).
These measures indicate the level of support (i.e., weight of
evidence) in favor of any given model being the most parsimonious
among the candidate model set.</p>
</td></tr>
<tr><td><code>Cum.Wt</code></td>
<td>
<p>the cumulative Akaike weights.  These are only meaningful
if results in table are sorted in decreasing order of Akaike weights
(i.e., <code>sort = TRUE</code>).</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>if c.hat was specified as an argument, it is included in
the table.</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>if c.hat = 1 and parameters estimated by maximum likelihood,
the log-likelihood of each model.</p>
</td></tr>
<tr><td><code>Quasi.LL</code></td>
<td>
<p>if c.hat &gt; 1, the quasi log-likelihood of each model.</p>
</td></tr>
<tr><td><code>Res.LL</code></td>
<td>
<p>if parameters are estimated by restricted
maximum-likelihood (REML), the restricted log-likelihood of each
model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological Methods
and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictabCustom">aictabCustom</a></code>, <code><a href="#topic+bictab">bictab</a></code>,
<code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+importance">importance</a></code>, <code><a href="#topic+modavg">modavg</a></code>,
<code><a href="#topic+modavgEffect">modavgEffect</a></code>, <code><a href="#topic+modavgShrink">modavgShrink</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Mazerolle (2006) frog water loss example
data(dry.frog)

##setup a subset of models of Table 1
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)

##create a vector of names to trace back models in set
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = " ")

##generate AICc table
aictab(cand.set = Cand.models, modnames = Modnames, sort = TRUE)
##round to 4 digits after decimal point and give log-likelihood
print(aictab(cand.set = Cand.models, modnames = Modnames, sort = TRUE),
      digits = 4, LL = TRUE)



## Not run: 
##Burnham and Anderson (2002) flour beetle data
data(beetle)
##models as suggested by Burnham and Anderson p. 198          
Cand.set &lt;- list( )
Cand.set[[1]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "logit"), weights = Number_tested,
                     data = beetle)
Cand.set[[2]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "probit"), weights = Number_tested,
                     data = beetle)
Cand.set[[3]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link ="cloglog"), weights = Number_tested,
                     data = beetle)

##check c-hat
c_hat(Cand.set[[1]])
c_hat(Cand.set[[2]])
c_hat(Cand.set[[3]])
##lowest value of c-hat &lt; 1 for these non-nested models, thus use
##c.hat = 1 
       
##set up named list
names(Cand.set) &lt;- c("logit", "probit", "cloglog")

##compare models
##model names will be taken from the list if modnames is not specified
res.table &lt;- aictab(cand.set = Cand.set, second.ord = FALSE)
##note that delta AIC and Akaike weights are identical to Table 4.7
print(res.table, digits = 2, LL = TRUE) #print table with 2 digits and
##print log-likelihood in table
print(res.table, digits = 4, LL = FALSE) #print table with 4 digits and
##do not print log-likelihood

## End(Not run)


##two-way ANOVA with interaction
data(iron)
##full model
m1 &lt;- lm(Iron ~ Pot + Food + Pot:Food, data = iron)
##additive model
m2 &lt;- lm(Iron ~ Pot + Food, data = iron)
##null model
m3 &lt;- lm(Iron ~ 1, data = iron)

##candidate models
Cand.aov &lt;- list(m1, m2, m3)
Cand.names &lt;- c("full", "additive", "null")
aictab(Cand.aov, Cand.names)



##single-season occupancy model example modified from ?occu
## Not run: 
require(unmarked)
##single season example modified from ?occu
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
##add fake covariates
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)),
                                sitevar2 = runif(numSites(pferUMF))) 
     
##observation covariates
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) *
                                 obsNum(pferUMF))) 

##set up candidate model set
fm1 &lt;- occu(~ obsvar1 ~ sitevar1, pferUMF)
fm2 &lt;- occu(~ 1 ~ sitevar1, pferUMF)
fm3 &lt;- occu(~ obsvar1 ~ sitevar2, pferUMF)
fm4 &lt;- occu(~ 1 ~ sitevar2, pferUMF)

##assemble models in named list (alternative to using 'modnames' argument)
Cand.mods &lt;- list("fm1" = fm1, "fm2" = fm2, "fm3" = fm3, "fm4" = fm4)

##compute table
aictab(cand.set = Cand.mods, second.ord = TRUE)

detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='aictabCustom'>
Create Model Selection Tables from User-supplied Input Based on (Q)AIC(c)
</h2><span id='topic+aictabCustom'></span>

<h3>Description</h3>

<p>This function creates a model selection table from model input
(log-likelihood, number of estimated parameters) supplied by the user
instead of extracting the values automatically from a list of
candidate models.  The models are ranked based on one of the following
information criteria:  AIC, AICc, QAIC, QAICc.  The table ranks the
models based on the selected information criteria and also provides
delta AIC and Akaike weights.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aictabCustom(logL, K, modnames = NULL, second.ord = TRUE, nobs = NULL,
             sort = TRUE, c.hat = 1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aictabCustom_+3A_logl">logL</code></td>
<td>

<p>a vector of log-likelihood values for the models in the candidate
model set.
</p>
</td></tr>
<tr><td><code id="aictabCustom_+3A_k">K</code></td>
<td>

<p>a vector containing the number of estimated parameters for each
model in the candidate model set.
</p>
</td></tr>
<tr><td><code id="aictabCustom_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models (i.e., a named
list).  If no names appear in the list and no character vector is
provided, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are supplied in
the table in the same order as in the list of candidate models.
</p>
</td></tr>
<tr><td><code id="aictabCustom_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="aictabCustom_+3A_nobs">nobs</code></td>
<td>

<p>the sample size required to compute the AICc or QAICc.
</p>
</td></tr>
<tr><td><code id="aictabCustom_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the (Q)AIC(c) values.
</p>
</td></tr>
<tr><td><code id="aictabCustom_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>.  Note that values of
<code>c.hat</code> different from 1 are only appropriate for binomial GLM's
with trials &gt; 1 (i.e., success/trial or cbind(success, failure)
syntax), with Poisson GLM's, single-season or dynamic occupancy
models (MacKenzie et al. 2002, 2003), <em>N</em>-mixture models (Royle
2004, Dail and Madsen 2011), or capture-mark-recapture models (e.g.,
Lebreton et al. 1992).  If c.hat &gt; 1, <code>aictabCustom</code> will return the
quasi-likelihood analogue of the information criterion requested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aictabCustom</code> constructs a model selection table based on one of
the four information criteria: AIC, AICc, QAIC, and QAICc.  This
function is most useful when model input is imported into R from other
software (e.g., Program MARK, PRESENCE) or for model classes that are
not yet supported by <code>aictab</code>.
</p>


<h3>Value</h3>

<p><code>aictabCustom</code> creates an object of class <code>aictab</code> with the
following components:
</p>
<table>
<tr><td><code>Modname</code></td>
<td>
<p>the name of each model of the candidate model set.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of estimated parameters for each model.</p>
</td></tr>
<tr><td><code>(Q)AIC(c)</code></td>
<td>
<p>the information criteria requested for each model
(AICc, AICc, QAIC, QAICc).</p>
</td></tr>
<tr><td><code>Delta_(Q)AIC(c)</code></td>
<td>
<p>the appropriate delta AIC component depending on
the information criteria selected.</p>
</td></tr>
<tr><td><code>ModelLik</code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td></tr> 
<tr><td><code>(Q)AIC(c)Wt</code></td>
<td>
<p>the Akaike weights, also termed &quot;model
probabilities&quot; sensu Burnham and Anderson (2002) and Anderson (2008).
These measures indicate the level of support (i.e., weight of
evidence) in favor of any given model being the most parsimonious
among the candidate model set.</p>
</td></tr>
<tr><td><code>Cum.Wt</code></td>
<td>
<p>the cumulative Akaike weights.  These are only meaningful
if results in table are sorted in decreasing order of Akaike weights
(i.e., sort = TRUE).</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>if c.hat was specified as an argument, it is included in
the table.</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>if c.hat = 1 and parameters estimated by maximum likelihood,
the log-likelihood of each model.</p>
</td></tr>
<tr><td><code>Quasi.LL</code></td>
<td>
<p>if c.hat &gt; 1, the quasi log-likelihood of each model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67&ndash;118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICcCustom">AICcCustom</a></code>, <code><a href="#topic+bictabCustom">bictabCustom</a></code>,
<code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+ictab">ictab</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##vector with model LL's
LL &lt;- c(-38.8876, -35.1783, -64.8970)

##vector with number of parameters
Ks &lt;- c(7, 9, 4)

##create a vector of names to trace back models in set
Modnames &lt;- c("Cm1", "Cm2", "Cm3")

##generate AICc table
aictabCustom(logL = LL, K = Ks, modnames = Modnames, nobs = 121,
             sort = TRUE) 
</code></pre>

<hr>
<h2 id='anovaOD'>
Likelihood-Ratio Test Corrected for Overdispersion
</h2><span id='topic+anovaOD'></span><span id='topic+anovaOD.glm'></span><span id='topic+anovaOD.unmarkedFitOccu'></span><span id='topic+anovaOD.unmarkedFitColExt'></span><span id='topic+anovaOD.unmarkedFitOccuRN'></span><span id='topic+anovaOD.unmarkedFitPCount'></span><span id='topic+anovaOD.unmarkedFitPCO'></span><span id='topic+anovaOD.unmarkedFitDS'></span><span id='topic+anovaOD.unmarkedFitGDS'></span><span id='topic+anovaOD.unmarkedFitOccuFP'></span><span id='topic+anovaOD.unmarkedFitMPois'></span><span id='topic+anovaOD.unmarkedFitGMM'></span><span id='topic+anovaOD.unmarkedFitGPC'></span><span id='topic+anovaOD.unmarkedFitOccuMulti'></span><span id='topic+anovaOD.unmarkedFitOccuMS'></span><span id='topic+anovaOD.unmarkedFitOccuTTD'></span><span id='topic+anovaOD.unmarkedFitMMO'></span><span id='topic+anovaOD.unmarkedFitDSO'></span><span id='topic+anovaOD.glmerMod'></span><span id='topic+anovaOD.maxlikeFit'></span><span id='topic+anovaOD.multinom'></span><span id='topic+anovaOD.vglm'></span><span id='topic+print.anovaOD'></span>

<h3>Description</h3>

<p>Compute likelihood-ratio test between a given model and a simpler model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovaOD(mod.simple, mod.complex, c.hat = 1, 
        nobs = NULL, ...)

## S3 method for class 'glm'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitOccu'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitColExt'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitOccuRN'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitPCount'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitPCO'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitDS'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitGDS'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitOccuFP'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitMPois'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitGMM'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitGPC'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitOccuMS'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitOccuTTD'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitMMO'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'unmarkedFitDSO'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'glmerMod'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'maxlikeFit'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'multinom'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)

## S3 method for class 'vglm'
anovaOD(mod.simple, mod.complex, c.hat = 1,  
        nobs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anovaOD_+3A_mod.simple">mod.simple</code></td>
<td>

<p>an object of class <code>glm</code>, <code>glmmTMB</code>,
<code>maxlikeFit</code>, <code>mer</code>, <code>merMod</code>, <code>multinom</code>,  
<code>vglm</code>, and various <code>unmarkedFit</code> classes containing 
the output of a model.  This model should be a simpler version of
<code>mod.complex</code> resulting from a deletion of certain terms (i.e.,
nested model).
</p>
</td></tr>
<tr><td><code id="anovaOD_+3A_mod.complex">mod.complex</code></td>
<td>

<p>an object of the same class as <code>mod.simple</code>.
</p>
</td></tr>
<tr><td><code id="anovaOD_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>, <code>mb.gof.test</code>, or
<code>Nmix.gof.test</code>.  Typically, this value should be computed for
the most complex model and applied to simpler models.
</p>
</td></tr>
<tr><td><code id="anovaOD_+3A_nobs">nobs</code></td>
<td>

<p>the number of observations used in the analysis.  If <code>nobs =
    NULL</code>, the total number of rows are used as the sample size to
compute the residual degrees of freedom as <code class="reqn">nobs - K</code>, where
<em>K</em> is the number of estimated parameters.  This is relevant
only for mixed models or various models of <code>unmarkedFit</code>
classes where sample size is not straightforward.  In such cases,
one might use total number of observations or number of independent
clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="anovaOD_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a correction for overdispersion on the
likelihood-ratio test between a model and its simpler counterpart.
The simpler model must be nested within the more complex model,
typically as the result of deleting terms.  You should supply the
<code>c.hat</code> value of the most complex of the two models you are
comparing.
</p>
<p>When <code class="reqn">1 &lt; c.hat &lt; 4</code>, the likelihood-ratio test is computed
as:
</p>
<p style="text-align: center;"><code class="reqn">LR = \frac{-2 * (LL.simple - LL.complex)}{(K.complex - K.simple)
      * c.hat}</code>
</p>

<p>where <em>LL.simple</em> and <em>LL.complex</em> are the log-likelihoods
of the simple and complex models, respectively, and where
<em>K.complex</em> and <em>K.simple</em> are the number of estimated
parameters in each model.  The test statistic is approximately
distributed as <code class="reqn">F_{K.complex - K.simple, n - K.complex}</code>, where
<em>n</em> is the number of observations (i.e., <code>nobs</code>) used in the
analysis (Venables and Ripley 2002).
</p>
<p>When <code>nobs = NULL</code>, the number of observations is based on the
number of rows of the data frame used in the analysis.  For mixed
models or various models of <code>unmarkedFit</code>, sample size is less
straightforward, and <code>nobs</code> could be based on the total number of
observations or on the number of independent clusters (e.g., sites),
among other choices.
</p>
<p>When <code>c.hat = 1</code>, the likelihood-ratio test simplifies to:
</p>
<p style="text-align: center;"><code class="reqn">LR = -2 * (LL.simple - LL.complex)</code>
</p>

<p>where in this case the test statistic is distributed as a
<code class="reqn">\chi^2_{K.complex - K.simple}</code> (McCullagh and Nelder 1989).
</p>
<p>The function supports different model types such as Poisson GLM's and
GLMM's, single-season and dynamic occupancy models (MacKenzie et
al. 2002, 2003),  and various <em>N</em>-mixture models (Royle 2004,
Dail and Madsen 2011).
</p>


<h3>Value</h3>

<p><code>anovaOD</code> returns an object of class <code>anovaOD</code> as a list with
the following components:
</p>
<table>
<tr><td><code>form.simple</code></td>
<td>
<p>a character string of the parameters estimated in <code>mod.simple</code>.</p>
</td></tr>
<tr><td><code>form.complex</code></td>
<td>
<p>a character string of the parameters estimated in <code>mod.complex</code>.</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>the <code>c.hat</code> estimate used to adjust the
likelihood-ratio test.</p>
</td></tr> 
<tr><td><code>devMat</code></td>
<td>
<p>a matrix storing as columns the number of parameters
estimated (<code>K</code>), the log-likelihood of each model <code>logLik</code>,
the difference in estimated parameters between the two models
(<code>Kdiff</code>), minus twice the difference in log-likelihoods between
the models (<code>-2LL</code>), the test statistic, and the associated
P-value. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>
<p>McCullagh, P., Nelder, J. A. (1989) <em>Generalized Linear
Models</em>. Second edition. Chapman and Hall: New York.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>
<p>Venables, W. N., Ripley, B. D. (2002) <em>Modern Applied Statistics
with S</em>. Second edition. Springer-Verlag: New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+mb.gof.test">mb.gof.test</a></code>,
<code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>, <code><a href="#topic+summaryOD">summaryOD</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##anuran larvae example from Mazerolle (2006)
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##run model
m1 &lt;- glm(Num_anura ~ Type + log.Perimeter + Num_ranatra,
          family = poisson, offset = log(Effort),
          data = min.trap) 
##null model
m0 &lt;- glm(Num_anura ~ 1,
          family = poisson, offset = log(Effort),
          data = min.trap) 

##check c-hat for global model
c_hat(m1) #uses Pearson's chi-square/df

##likelihood ratio test corrected for overdispersion
anovaOD(mod.simple = m0, mod.complex = m1, c.hat = c_hat(m1))
##compare without overdispersion correction
anovaOD(mod.simple = m0, mod.complex = m1)


##example with occupancy model
## Not run: 
##load unmarked package
if(require(unmarked)){
   
   data(bullfrog)
     
   ##detection data
   detections &lt;- bullfrog[, 3:9]

   ##assemble in unmarkedFrameOccu
   bfrog &lt;- unmarkedFrameOccu(y = detections)
     
   ##run model
   fm &lt;- occu(~ 1 ~ Reed.presence, data = bfrog)
   ##null model
   fm0 &lt;- occu(~ 1 ~ 1, data = bfrog)

   ##check GOF
   ##GOF &lt;- mb.gof.test(fm, nsim = 1000)
   ##estimate of c-hat:  1.89

   ##display results after overdispersion adjustment
   anovaOD(fm0, fm, c.hat = 1.89)

   detach(package:unmarked)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='beetle'>
Flour Beetle Data
</h2><span id='topic+beetle'></span>

<h3>Description</h3>

<p>This data set illustrates the acute mortality of flour beetles
(<em>Tribolium confusum</em>) following 5 hour exposure to carbon disulfide
gas. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(beetle)</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows and 4 variables.
</p>

<dl>
<dt><code>Dose</code></dt><dd><p>dose of carbon disulfide in mg/L.</p>
</dd>
<dt><code>Number_tested</code></dt><dd><p>number of beetles exposed to given dose
of carbon disulfide.</p>
</dd> 
<dt><code>Number_killed</code></dt><dd><p>number of beetles dead after 5 hour
exposure to given dose of carbon disulfide.</p>
</dd>
<dt><code>Mortality_rate</code></dt><dd><p>proportion of total beetles found dead
after 5 hour exposure.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Burnham and Anderson (2002, p. 195) use this data set originally from
Young and Young (1998) to show model selection for binomial models with
different link functions (logit, probit, cloglog). 
</p>


<h3>Source</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Young, L. J., Young, J. H. (1998) <em>Statistical Ecology</em>. Kluwer
Academic Publishers: London.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beetle)
## maybe str(beetle) ; plot(beetle) ...
</code></pre>

<hr>
<h2 id='bictab'>
Create Model Selection Tables Based on BIC
</h2><span id='topic+bictab'></span><span id='topic+bictab.default'></span><span id='topic+bictab.AICaov.lm'></span><span id='topic+bictab.AICbetareg'></span><span id='topic+bictab.AICsclm.clm'></span><span id='topic+bictab.AICclm'></span><span id='topic+bictab.AICclmm'></span><span id='topic+bictab.AICcoxme'></span><span id='topic+bictab.AICcoxph'></span><span id='topic+bictab.AICfitdist'></span><span id='topic+bictab.AICfitdistr'></span><span id='topic+bictab.AICglm.lm'></span><span id='topic+bictab.AICglmmTMB'></span><span id='topic+bictab.AICgls'></span><span id='topic+bictab.AICgnls.gls'></span><span id='topic+bictab.AIChurdle'></span><span id='topic+bictab.AIClavaan'></span><span id='topic+bictab.AIClm'></span><span id='topic+bictab.AIClme'></span><span id='topic+bictab.AIClmekin'></span><span id='topic+bictab.AICmaxlikeFit.list'></span><span id='topic+bictab.AICmer'></span><span id='topic+bictab.AIClmerMod'></span><span id='topic+bictab.AIClmerModLmerTest'></span><span id='topic+bictab.AICglmerMod'></span><span id='topic+bictab.AICnlmerMod'></span><span id='topic+bictab.AICmultinom.nnet'></span><span id='topic+bictab.AICnlme.lme'></span><span id='topic+bictab.AICnls'></span><span id='topic+bictab.AICpolr'></span><span id='topic+bictab.AICrlm.lm'></span><span id='topic+bictab.AICsurvreg'></span><span id='topic+bictab.AICunmarkedFitOccu'></span><span id='topic+bictab.AICunmarkedFitColExt'></span><span id='topic+bictab.AICunmarkedFitOccuRN'></span><span id='topic+bictab.AICunmarkedFitPCount'></span><span id='topic+bictab.AICunmarkedFitPCO'></span><span id='topic+bictab.AICunmarkedFitDS'></span><span id='topic+bictab.AICunmarkedFitGDS'></span><span id='topic+bictab.AICunmarkedFitOccuFP'></span><span id='topic+bictab.AICunmarkedFitMPois'></span><span id='topic+bictab.AICunmarkedFitGMM'></span><span id='topic+bictab.AICunmarkedFitGPC'></span><span id='topic+bictab.AICunmarkedFitOccuMulti'></span><span id='topic+bictab.AICunmarkedFitOccuMS'></span><span id='topic+bictab.AICunmarkedFitOccuTTD'></span><span id='topic+bictab.AICunmarkedFitMMO'></span><span id='topic+bictab.AICunmarkedFitDSO'></span><span id='topic+bictab.AICvglm'></span><span id='topic+bictab.AICzeroinfl'></span><span id='topic+print.bictab'></span>

<h3>Description</h3>

<p>This function creates a model selection table based on the Bayesian
information criterion (Schwarz 1978, Burnham and Anderson 2002).  The
table ranks the models based on the BIC and also provides delta BIC and
BIC model weights.  The function adjusts for overdispersion in model
selection  by using the QBIC when <code>c.hat &gt; 1</code>.  <code>bictab</code>
selects the appropriate function to create the model selection table
based on the object class.  The current version works with lists
containing objects of <code>aov</code>, <code>betareg</code>, <code>clm</code>,
<code>clmm</code>, <code>clogit</code>, <code>coxme</code>, <code>coxph</code>, <code>fitdist</code>,
<code>fitdistr</code>, <code>glm</code>, <code>glmmTMB</code>, <code>gls</code>, <code>gnls</code>,
<code>hurdle</code>, <code>lavaan</code>, <code>lm</code>, <code>lme</code>, <code>lmekin</code>,
<code>maxlikeFit</code>, <code>mer</code>, <code>merMod</code>, <code>lmerModLmerTest</code>,
<code>multinom</code>, <code>nlme</code>, <code>nls</code>, <code>polr</code>, <code>rlm</code>,
<code>survreg</code>, <code>vglm</code>, and <code>zeroinfl</code> classes as well as
various models of <code>unmarkedFit</code> classes but does not yet allow
mixing of different classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bictab(cand.set, modnames = NULL, nobs = NULL,
       sort = TRUE, ...)

## S3 method for class 'AICaov.lm'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICbetareg'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICsclm.clm'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICclmm'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICclm'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICcoxme'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICcoxph'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICfitdist'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICfitdistr'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICglm.lm'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, c.hat = 1, ...)  

## S3 method for class 'AICglmmTMB'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, c.hat = 1, ...)  

## S3 method for class 'AICgls'
bictab(cand.set, modnames = NULL,
        nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICgnls.gls'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIChurdle'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClavaan'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClm'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClme'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClmekin'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICmaxlikeFit.list'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...) 

## S3 method for class 'AICmer'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClmerMod'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AIClmerModLmerTest'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICglmerMod'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...) 

## S3 method for class 'AICnlmerMod'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICmultinom.nnet'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICnlme.lme'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...) 

## S3 method for class 'AICnls'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICpolr'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICrlm.lm'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICsurvreg'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)

## S3 method for class 'AICunmarkedFitOccu'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitColExt'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitPCount'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitPCO'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitDS'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitGDS'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitMPois'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitGMM'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitGPC'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitMMO'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICunmarkedFitDSO'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICvglm'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
bictab(cand.set, modnames = NULL,
         nobs = NULL, sort = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bictab_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="bictab_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models (i.e., a named
list).  If no names appear in the list and no character vector is
provided, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are supplied in
the table in the same order as in the list of candidate models.
</p>
</td></tr>
<tr><td><code id="bictab_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the BIC (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.
In such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="bictab_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the BIC values.
</p>
</td></tr>
<tr><td><code id="bictab_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1, <code>bictab</code>
will return the quasi-likelihood analogue of the BIC (QBIC) and multiply
the variance-covariance matrix of the estimates by this value (i.e.,
SE's are multiplied by <code>sqrt(c.hat)</code>).  This option is not
supported for generalized linear mixed models of the <code>mer</code> or
<code>merMod</code> classes.
</p>
</td></tr>
<tr><td><code id="bictab_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BIC tends to favor simpler models than AIC whenever <em>n</em> &gt; 8
(Schwarz 1978, Link and Barker 2006, Anderson 2008).  BIC assigns
uniform prior probabilities across all models (i.e., equal 1/R), whereas
in AIC and AICc, prior probabilities increase with sample size (Burnham
and Anderson 2004, Link and Barker 2010).  Some authors argue that BIC
requires the true model to be included in the model set, whereas AIC or
AICc does not (Burnham and Anderson 2002).  However, Link and Barker
(2006, 2010) consider both as assuming that a model in the model set
approximates truth. 
</p>
<p><code>bictab</code> internally creates a new class for the <code>cand.set</code>
list of candidate models, according to the contents of the list.  The
current function is implemented for <code>clogit</code>, <code>coxme</code>,
<code>coxph</code>, <code>fitdist</code>, <code>fitdistr</code>, <code>glm</code>,
<code>glmmTMB</code>, <code>gls</code>, <code>gnls</code>, <code>hurdle</code>, <code>lavaan</code>,
<code>lm</code>, <code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code>, <code>multinom</code>, <code>nlme</code>,
<code>nls</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>, <code>vglm</code>, and
<code>zeroinfl</code> classes as well as various <code>unmarkedFit</code> classes.
The function constructs a model selection table based on BIC.
</p>


<h3>Value</h3>

<p><code>bictab</code> creates an object of class <code>bictab</code> with the
following components:
</p>
<table>
<tr><td><code>Modname</code></td>
<td>
<p>the name of each model of the candidate model set.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of estimated parameters for each model.</p>
</td></tr>
<tr><td><code>(Q)BIC</code></td>
<td>
<p>the Bayesian information criterion for each model.</p>
</td></tr>
<tr><td><code>Delta_(Q)BIC</code></td>
<td>
<p>the delta BIC component.</p>
</td></tr>
<tr><td><code>ModelLik</code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td></tr> 
<tr><td><code>(Q)BICWt</code></td>
<td>
<p>the BIC model weights, also termed &quot;model probabilities&quot;
(Burnham and Anderson 2002, Link and Barker 2006, Anderson 2008).
These measures indicate the level of support (i.e., weight of
evidence) in favor of any given model being the most parsimonious
among the candidate model set.</p>
</td></tr> 
<tr><td><code>Cum.Wt</code></td>
<td>
<p>the cumulative BIC weights.  These are only meaningful
if results in table are sorted in decreasing order of BIC weights (i.e.,
<code>sort = TRUE</code>).</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>if c.hat was specified as an argument, it is included in
the table.</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>the log-likelihood of each model.</p>
</td></tr>
<tr><td><code>Res.LL</code></td>
<td>
<p>if parameters are estimated by restricted
maximum-likelihood (REML), the restricted log-likelihood of each
model.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological Methods
and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>Link, W. A., Barker, R. J. (2006) Model weights and the foundations of
multimodel inference. <em>Ecology</em> <b>87</b>, 2626&ndash;2635.
</p>
<p>Link, W. A., Barker, R. J. (2010) Bayesian Inference with Ecological
Applications. Academic Press: Boston.  
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>
<p>Schwarz, G. (1978) Estimating the dimension of a model. <em>Annals of
Statistics</em> <b>6</b>, 461&ndash;464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+bictabCustom">bictabCustom</a></code>, <code><a href="#topic+confset">confset</a></code>,
<code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+importance">importance</a></code>, <code><a href="#topic+useBIC">useBIC</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Mazerolle (2006) frog water loss example
data(dry.frog)

##setup a subset of models of Table 1
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)

##create a vector of names to trace back models in set
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = " ")

##generate BIC table
bictab(cand.set = Cand.models, modnames = Modnames, sort = TRUE)
##round to 4 digits after decimal point and give log-likelihood
print(bictab(cand.set = Cand.models, modnames = Modnames, sort = TRUE),
      digits = 4, LL = TRUE)



## Not run: 
##Burnham and Anderson (2002) flour beetle data
data(beetle)
##models as suggested by Burnham and Anderson p. 198          
Cand.set &lt;- list( )
Cand.set[[1]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "logit"), weights = Number_tested,
                     data = beetle)
Cand.set[[2]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "probit"), weights = Number_tested,
                     data = beetle)
Cand.set[[3]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link ="cloglog"), weights = Number_tested,
                     data = beetle)

##set up named list
names(Cand.set) &lt;- c("logit", "probit", "cloglog")

##compare models
##model names will be taken from the list if modnames is not specified
bictab(cand.set = Cand.set)

## End(Not run)


##two-way ANOVA with interaction
data(iron)
##full model
m1 &lt;- lm(Iron ~ Pot + Food + Pot:Food, data = iron)
##additive model
m2 &lt;- lm(Iron ~ Pot + Food, data = iron)
##null model
m3 &lt;- lm(Iron ~ 1, data = iron)

##candidate models
Cand.aov &lt;- list(m1, m2, m3)
Cand.names &lt;- c("full", "additive", "null")
bictab(Cand.aov, Cand.names)



##single-season occupancy model example modified from ?occu
## Not run: 
require(unmarked)
##single season example modified from ?occu
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
##add fake covariates
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)),
                                sitevar2 = runif(numSites(pferUMF))) 
     
##observation covariates
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) *
                                 obsNum(pferUMF))) 

##set up candidate model set
fm1 &lt;- occu(~ obsvar1 ~ sitevar1, pferUMF)
fm2 &lt;- occu(~ 1 ~ sitevar1, pferUMF)
fm3 &lt;- occu(~ obsvar1 ~ sitevar2, pferUMF)
fm4 &lt;- occu(~ 1 ~ sitevar2, pferUMF)

##assemble models in named list (alternative to using 'modnames' argument)
Cand.mods &lt;- list("fm1" = fm1, "fm2" = fm2, "fm3" = fm3, "fm4" = fm4)

##compute table based on QBIC that accounts for c.hat
bictab(cand.set = Cand.mods, c.hat = 3.9)

detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='bictabCustom'>
Create Model Selection Tables from User-supplied Input Based on (Q)BIC
</h2><span id='topic+bictabCustom'></span>

<h3>Description</h3>

<p>This function creates a model selection table from model input
(log-likelihood, number of estimated parameters) supplied by the user
instead of extracting the values automatically from a list of
candidate models.  The models are ranked based on the BIC (Schwarz
1978) or on a quasi-likelihood analogue (QBIC) corrected for
overdispersion.  The table ranks the models based on the selected
information criteria and also provides delta BIC and BIC weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bictabCustom(logL, K, modnames = NULL, nobs = NULL, sort = TRUE,
             c.hat = 1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bictabCustom_+3A_logl">logL</code></td>
<td>

<p>a vector of log-likelihood values for the models in the candidate
model set.
</p>
</td></tr>
<tr><td><code id="bictabCustom_+3A_k">K</code></td>
<td>

<p>a vector containing the number of estimated parameters for each
model in the candidate model set.
</p>
</td></tr>
<tr><td><code id="bictabCustom_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models (i.e., a named
list).  If no names appear in the list and no character vector is
provided, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are supplied in
the table in the same order as in the list of candidate models.
</p>
</td></tr>
<tr><td><code id="bictabCustom_+3A_nobs">nobs</code></td>
<td>

<p>the sample size required to compute the AICc or QAICc.
</p>
</td></tr>
<tr><td><code id="bictabCustom_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the (Q)BIC values.
</p>
</td></tr>
<tr><td><code id="bictabCustom_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>.  Note that values of
<code>c.hat</code> different from 1 are only appropriate for binomial GLM's
with trials &gt; 1 (i.e., success/trial or cbind(success, failure)
syntax), with Poisson GLM's, single-season or dynamic occupancy
models (MacKenzie et al. 2002, 2003), <em>N</em>-mixture models (Royle
2004, Dail and Madsen 2011), or capture-mark-recapture models (e.g.,
Lebreton et al. 1992).  If c.hat &gt; 1, <code>bictabCustom</code> will return
the quasi-likelihood analogue of the information criterion requested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bictabCustom</code> constructs a model selection table based on BIC or
QBIC.  This function is most useful when model input is imported into
R from other software (e.g., Program MARK, PRESENCE) or for model
classes that are not yet supported by <code>bictab</code>.
</p>


<h3>Value</h3>

<p><code>bictabCustom</code> creates an object of class <code>bictab</code> with the
following components:
</p>
<table>
<tr><td><code>Modname</code></td>
<td>
<p>the name of each model of the candidate model set.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of estimated parameters for each model.</p>
</td></tr>
<tr><td><code>(Q)BIC</code></td>
<td>
<p>the information criteria requested for each model
(BIC, QBIC).</p>
</td></tr>
<tr><td><code>Delta_(Q)BIC</code></td>
<td>
<p>the appropriate delta BIC component depending
on the information criteria selected.</p>
</td></tr>
<tr><td><code>ModelLik</code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td></tr> 
<tr><td><code>(Q)BICWt</code></td>
<td>
<p>the BIC weights, also termed &quot;model probabilities&quot;
sensu Burnham and Anderson (2002) and Anderson (2008).  These
measures indicate the level of support (i.e., weight of evidence) in
favor of any given model being the most parsimonious among the
candidate model set.</p>
</td></tr> 
<tr><td><code>Cum.Wt</code></td>
<td>
<p>the cumulative BIC weights.  These are only meaningful
if results in table are sorted in decreasing order of BIC weights
(i.e., sort = TRUE).</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>if c.hat was specified as an argument, it is included in
the table.</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>if c.hat = 1 and parameters estimated by maximum likelihood,
the log-likelihood of each model.</p>
</td></tr>
<tr><td><code>Quasi.LL</code></td>
<td>
<p>if c.hat &gt; 1, the quasi log-likelihood of each model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67&ndash;118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>
<p>Schwarz, G. (1978) Estimating the dimension of a model. <em>Annals of
Statistics</em> <b>6</b>, 461&ndash;464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICcCustom">AICcCustom</a></code>, <code><a href="#topic+aictabCustom">aictabCustom</a></code>,
<code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+ictab">ictab</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##vector with model LL's
LL &lt;- c(-38.8876, -35.1783, -64.8970)

##vector with number of parameters
Ks &lt;- c(7, 9, 4)

##create a vector of names to trace back models in set
Modnames &lt;- c("Cm1", "Cm2", "Cm3")

##generate BIC table
bictabCustom(logL = LL, K = Ks, modnames = Modnames, nobs = 121,
             sort = TRUE)
</code></pre>

<hr>
<h2 id='boot.wt'>
Compute Model Selection Relative Frequencies
</h2><span id='topic+boot.wt'></span><span id='topic+boot.wt.default'></span><span id='topic+boot.wt.AICaov.lm'></span><span id='topic+boot.wt.AICbetareg'></span><span id='topic+boot.wt.AICsclm.clm'></span><span id='topic+boot.wt.AICglm.lm'></span><span id='topic+boot.wt.AIChurdle'></span><span id='topic+boot.wt.AIClm'></span><span id='topic+boot.wt.AICmultinom.nnet'></span><span id='topic+boot.wt.AICpolr'></span><span id='topic+boot.wt.AICrlm.lm'></span><span id='topic+boot.wt.AICsurvreg'></span><span id='topic+boot.wt.AICvglm'></span><span id='topic+boot.wt.AICzeroinfl'></span><span id='topic+print.boot.wt'></span>

<h3>Description</h3>

<p>This function computes the model selection relative frequencies based on
the nonparametric bootstrap (Burnham and Anderson 2002).  Models are
ranked based on the AIC, AICc, QAIC, or QAICc.  The function currently
supports objects of <code>aov</code>, <code>betareg</code>, <code>clm</code>, <code>glm</code>,
<code>hurdle</code>, <code>lm</code>, <code>multinom</code>, <code>polr</code>, <code>rlm</code>,
<code>survreg</code>, <code>vglm</code>, and <code>zeroinfl</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
        sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICaov.lm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICsurvreg'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICsclm.clm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICglm.lm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, c.hat = 1, ...)

## S3 method for class 'AIChurdle'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)
       
## S3 method for class 'AIClm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICmultinom.nnet'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, c.hat = 1, ...)

## S3 method for class 'AICpolr'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICrlm.lm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICsurvreg'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICvglm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.wt_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="boot.wt_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="boot.wt_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="boot.wt_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for certain types of models such 
as mixed models where sample size is not straightforward.  In 
such cases, one might use total number of observations or number of 
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="boot.wt_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the (Q)AIC(c) values.
</p>
</td></tr>
<tr><td><code id="boot.wt_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax) or with Poisson
GLM's.  If c.hat &gt; 1, <code>boot.wt</code> will return the quasi-likelihood
analogue of the information criterion requested.
</p>
</td></tr>
<tr><td><code id="boot.wt_+3A_nsim">nsim</code></td>
<td>
<p>the number of bootstrap iterations. Burnham and Anderson
(2002) recommend at least 1000 and up to 10 000 iterations for certain
problems.
</p>
</td></tr>
<tr><td><code id="boot.wt_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>boot.wt</code> is implemented for <code>aov</code>, <code>betareg</code>,
<code>glm</code>, <code>hurdle</code>, <code>lm</code>, <code>multinom</code>, <code>polr</code>,
<code>rlm</code>, <code>survreg</code>, <code>vglm</code>, and <code>zeroinfl</code> classes.
During each bootstrap iteration, the data are resampled with
replacement, all the models specified in <code>cand.set</code> are updated
with the new data set, and the top-ranked model is saved. When all
iterations are completed, the relative frequency of selection is
computed for each model appearing in the candidate model set.
</p>
<p>Relative frequencies of the models are often similar to Akaike
weights, and the latter are often preferred due to their link with
a Bayesian perspective (Burnham and Anderson 2002).  <code>boot.wt</code> is
most useful for teaching purposes of sampling-theory based relative
frequencies of model selection. The current implementation is only
appropriate with completely randomized designs.  For more complex data
structures (e.g., blocks or random effects), the bootstrap should be
modified accordingly.
</p>


<h3>Value</h3>

<p><code>boot.wt</code> creates an object of class <code>boot.wt</code> with the
following components: 
</p>
<table>
<tr><td><code>Modname</code></td>
<td>
<p>the names of each model of the candidate model set.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of estimated parameters for each model.</p>
</td></tr>
<tr><td><code>(Q)AIC(c)</code></td>
<td>
<p>the information criteria requested for each model
(AICc, AICc, QAIC, QAICc).</p>
</td></tr>
<tr><td><code>Delta_(Q)AIC(c)</code></td>
<td>
<p>the appropriate delta AIC component depending on
the information criteria selected.</p>
</td></tr>
<tr><td><code>ModelLik</code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td></tr> 
<tr><td><code>(Q)AIC(c)Wt</code></td>
<td>
<p>the Akaike weights, also termed &quot;model
probabilities&quot; sensu Burnham and Anderson (2002) and Anderson (2008).
These measures indicate the level of support (i.e., weight of
evidence) in favor of any given model being the most parsimonious
among the candidate model set.</p>
</td></tr>
<tr><td><code>PiWt</code></td>
<td>
<p>the relative frequencies of model selection from the bootstrap.</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>if c.hat was specified as an argument, it is included in
the table.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological Methods
and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+importance">importance</a></code>, <code><a href="#topic+modavg">modavg</a></code>, 
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Mazerolle (2006) frog water loss example
data(dry.frog)

##setup a subset of models of Table 1
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)

##create a vector of names to trace back models in set
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = " ")

##generate AICc table with bootstrapped relative
##frequencies of model selection
boot.wt(cand.set = Cand.models, modnames = Modnames, sort = TRUE,
        nsim = 10) #number of iterations should be much higher


##Burnham and Anderson (2002) flour beetle data
## Not run: 
data(beetle)
##models as suggested by Burnham and Anderson p. 198          
Cand.set &lt;- list( )
Cand.set[[1]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "logit"), weights = Number_tested,
                     data = beetle)
Cand.set[[2]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "probit"), weights = Number_tested,
                     data = beetle)
Cand.set[[3]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link ="cloglog"), weights = Number_tested,
                     data = beetle)

##create a vector of names to trace back models in set
Modnames &lt;- paste("Mod", 1:length(Cand.set), sep = " ")

##model selection table with bootstrapped
##relative frequencies
boot.wt(cand.set = Cand.set, modnames = Modnames)

## End(Not run)
</code></pre>

<hr>
<h2 id='bullfrog'>
Bullfrog Occupancy and Common Reed Invasion
</h2><span id='topic+bullfrog'></span>

<h3>Description</h3>

<p>This is a data set from Mazerolle et al. (2014) on the occupancy of
Bullfrogs (<em>Lithobates catesbeianus</em>) in 50 wetlands sampled in
2009 in the area of Montreal, QC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bullfrog)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 23 variables.
</p>

<dl>
<dt><code>Location</code></dt><dd><p>a factor with a unique identifier for each
wetland.</p>
</dd>
<dt><code>Reed.presence</code></dt><dd><p>a binary variable, either 1 (reed
present) or 0 (reed absent).</p>
</dd>
<dt><code>V1</code></dt><dd><p>a binary variable for detection (1) or non
detection (0) of bullfrogs during the first survey.</p>
</dd> 
<dt><code>V2</code></dt><dd><p>a binary variable for detection (1) or non
detection (0) of bullfrogs during the second survey.</p>
</dd> 
<dt><code>V3</code></dt><dd><p>a binary variable for detection (1) or non
detection (0) of bullfrogs during the third survey.</p>
</dd>
<dt><code>V4</code></dt><dd><p>a binary variable for detection (1) or non
detection (0) of bullfrogs during the fourth survey.</p>
</dd>
<dt><code>V5</code></dt><dd><p>a binary variable for detection (1) or non
detection (0) of bullfrogs during the fifth survey.</p>
</dd>
<dt><code>V6</code></dt><dd><p>a binary variable for detection (1) or non
detection (0) of bullfrogs during the sixth survey.</p>
</dd>
<dt><code>V7</code></dt><dd><p>a binary variable for detection (1) or non
detection (0) of bullfrogs during the seventh survey.</p>
</dd>
<dt><code>Effort1</code></dt><dd><p>a numeric variable for the centered
number of sampling stations during the first survey.</p>
</dd>
<dt><code>Effort2</code></dt><dd><p>a numeric variable for the centered
number of sampling stations during the second survey.</p>
</dd>
<dt><code>Effort3</code></dt><dd><p>a numeric variable for the centered
number of sampling stations during the third survey.</p>
</dd>
<dt><code>Effort4</code></dt><dd><p>a numeric variable for the centered
number of sampling stations during the fourth survey.</p>
</dd>
<dt><code>Effort5</code></dt><dd><p>a numeric variable for the centered
number of sampling stations during the fifth survey.</p>
</dd>
<dt><code>Effort6</code></dt><dd><p>a numeric variable for the centered
number of sampling stations during the sixth survey.</p>
</dd>
<dt><code>Effort7</code></dt><dd><p>a numeric variable for the centered
number of sampling stations during the seventh survey.</p>
</dd>
<dt><code>Type1</code></dt><dd><p>a binary variable to identify the survey type,
either minnow trap (1) or call survey (0) during the first
sampling occasion.</p>
</dd>
<dt><code>Type2</code></dt><dd><p>a binary variable to identify the survey type,
either minnow trap (1) or call survey (0) during the second
sampling occasion.</p>
</dd>
<dt><code>Type3</code></dt><dd><p>a binary variable to identify the survey type,
either minnow trap (1) or call survey (0) during the third
sampling occasion.</p>
</dd>
<dt><code>Type4</code></dt><dd><p>a binary variable to identify the survey type,
either minnow trap (1) or call survey (0) during the fourth
sampling occasion.</p>
</dd>
<dt><code>Type5</code></dt><dd><p>a binary variable to identify the survey type,
either minnow trap (1) or call survey (0) during the fifth
sampling occasion.</p>
</dd>
<dt><code>Type6</code></dt><dd><p>a binary variable to identify the survey type,
either minnow trap (1) or call survey (0) during the sixth
sampling occasion.</p>
</dd>
<dt><code>Type7</code></dt><dd><p>a binary variable to identify the survey type,
either minnow trap (1) or call survey (0) during the seventh
sampling occasion.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set is used to illustrate single-species single-season
occupancy models (MacKenzie et al. 2002) in Mazerolle (2015). The
average number of sampling stations on each visit was 8.665714, and was
used to center <code>Effort</code> on each visit.
</p>


<h3>Source</h3>

<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002). Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255. 
</p>
<p>Mazerolle, M. J., Perez, A., Brisson, J. (2014) Common reed
(<em>Phragmites australis</em>) invasion and amphibian distribution in
freshwater wetlands. <em>Wetlands Ecology and Management</em> <b>22</b>,
325&ndash;340.
</p>
<p>Mazerolle, M. J. (2015) Estimating detectability and biological
parameters of interest with the use of the R
environment. <em>Journal of Herpetology</em> <b>49</b>, 541&ndash;559.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bullfrog)
str(bullfrog)
</code></pre>

<hr>
<h2 id='c_hat'>
Estimate Dispersion for Poisson and Binomial GLM's and GLMM's
</h2><span id='topic+c_hat'></span><span id='topic+c_hat.default'></span><span id='topic+c_hat.glm'></span><span id='topic+c_hat.glmmTMB'></span><span id='topic+c_hat.merMod'></span><span id='topic+c_hat.vglm'></span><span id='topic+print.c_hat'></span>

<h3>Description</h3>

<p>Functions to compute an estimate of c-hat for binomial or Poisson GLM's
and GLMM's using different estimators of overdispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_hat(mod, method = "pearson", ...)

## S3 method for class 'glm'
c_hat(mod, method = "pearson", ...)

## S3 method for class 'glmmTMB'
c_hat(mod, method = "pearson", ...)

## S3 method for class 'merMod'
c_hat(mod, method = "pearson", ...)

## S3 method for class 'vglm'
c_hat(mod, method = "pearson", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_hat_+3A_mod">mod</code></td>
<td>

<p>an object of class <code>glm</code>, <code>glmmTMB</code>, <code>merMod</code>, or
<code>vglm</code> for which a c-hat estimate is required.
</p>
</td></tr>
<tr><td><code id="c_hat_+3A_method">method</code></td>
<td>

<p>this argument defines the estimator used.  The default
<code>"pearson"</code> uses the Pearson chi-square divided by the residual
degrees of freedom.  Other methods include <code>"deviance"</code> consisting
of the residual deviance divided by the residual degrees of freedom,
<code>"farrington"</code> for the estimator suggested by Farrington (1996),
and <code>"fletcher"</code> for the estimator suggested by Fletcher (2012).
</p>
</td></tr>
<tr><td><code id="c_hat_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Poisson and binomial GLM's do not have a parameter for the variance and
it is usually held fixed to 1 (i.e., mean = variance).  However, one must
check whether this assumption is appropriate by estimating the
overdispersion parameter (c-hat).  Though one can obtain an estimate of
c-hat by dividing the residual deviance by the residual degrees of
freedom (i.e., <code>method = "deviance"</code>), McCullagh and Nelder (1989) and
Venables and Ripley (2002) recommend using Pearson's chi-square divided
by the residual degrees of freedom (<code>method = "pearson"</code>).  An
estimator based on Farrington (1996) is also implemented by the function
using the argument <code>method = "farrington"</code>.  Recent work by
Fletcher (2012) suggests that an alternative estimator performs better
than the above-mentioned methods in the presence of sparse data and is
now implemented with <code>method = "fletcher"</code>.  For GLMM's, only the
Pearson chi-square estimator of overdispersion is currently implemented. 
</p>
<p>Note that values of c-hat &gt; 1 indicate overdispersion (variance &gt; mean),
but that values much higher than 1 (i.e., &gt; 4) probably indicate
lack-of-fit.  In cases of moderate overdispersion, one usually
multiplies the variance-covariance matrix of the estimates by c-hat.  As
a result, the SE's of the estimates are inflated (c-hat is also known as
a variance inflation factor). 
</p>
<p>In model selection, c-hat should be estimated from the global model of
the candidate model set and the same value of c-hat applied to the
entire model set.  Specifically, a global model is the most complex model
which can be simplified to obtain all the other (nested) models of the
set.  When no single global model exists in the set of models
considered, such as when sample size does not allow a complex model, one
can estimate c-hat from 'subglobal' models.  Here, 'subglobal' models 
denote models from which only a subset of the models of the candidate
set can be derived.  In such cases, one can use the smallest value of
c-hat for model selection (Burnham and Anderson 2002).
</p>
<p>Note that c-hat counts as an additional parameter estimated and should
be added to <em>K</em>.  All functions in package <code>AICcmodavg</code>
automatically add 1 when the <code>c.hat</code> argument &gt; 1 and apply the
same value of c-hat for the entire model set.  When <code>c.hat &gt; 1</code>,
functions compute quasi-likelihood information criteria (either QAICc or
QAIC, depending on the value of the <code>second.ord</code> argument) by
scaling the log-likelihood of the model by <code>c.hat</code>.  The value of
<code>c.hat</code> can influence the ranking of the models:  as c-hat
increases, QAIC or QAICc will favor models with fewer parameters.  As an
additional check against this potential problem, one can create several
model selection tables by incrementing values of c-hat to assess the
model selection uncertainty.  If ranking changes little up to the c-hat
value observed, one can be confident in making inference. 
</p>
<p>In cases of underdispersion (c-hat &lt; 1), it is recommended to keep the
value of <code>c.hat</code> to 1.  However, note that values of c-hat &lt;&lt; 1 can
also indicate lack-of-fit and that an alternative model (and distribution)
should be investigated. 
</p>
<p>Note that <code>c_hat</code> only supports the estimation of c-hat for
binomial models with trials &gt; 1 (i.e., success/trial or cbind(success,
failure) syntax) or with Poisson GLM's or GLMM's.
</p>


<h3>Value</h3>

<p><code>c_hat</code> returns an object of class <code>c_hat</code> with the estimated
c-hat value and an attribute for the type of estimator used.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York. 
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261&ndash;304. 
</p>
<p>Farrington, C. P. (1996) On assessing goodness of fit of generalized
linear models to sparse data. <em>Journal of the Royal Statistical
Society B</em> <b>58</b>, 349&ndash;360.
</p>
<p>Fletcher, D. J. (2012) Estimating overdispersion when fitting a
generalized linear model to sparse data. <em>Biometrika</em> <b>99</b>,
230&ndash;237.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>
<p>McCullagh, P., Nelder, J. A. (1989) <em>Generalized Linear
Models</em>. Second edition. Chapman and Hall: New York.
</p>
<p>Venables, W. N., Ripley, B. D. (2002) <em>Modern Applied Statistics
with S</em>. Second edition. Springer: New York. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>, 
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>, <code><a href="#topic+mb.gof.test">mb.gof.test</a></code>,
<code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>, <code><a href="#topic+anovaOD">anovaOD</a></code>, <code><a href="#topic+summaryOD">summaryOD</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binomial glm example
set.seed(seed = 10)
resp &lt;- rbinom(n = 60, size = 1, prob = 0.5)
set.seed(seed = 10)
treat &lt;- as.factor(sample(c(rep(x = "m", times = 30), rep(x = "f",
                                           times = 30))))
age &lt;- as.factor(c(rep("young", 20), rep("med", 20), rep("old", 20)))
#each invidual has its own response (n = 1)
mod1 &lt;- glm(resp ~ treat + age, family = binomial)
## Not run: 
c_hat(mod1) #gives an error because model not appropriate for
##computation of c-hat

## End(Not run)

##computing table to summarize successes
table(resp, treat, age)
dat2 &lt;- as.data.frame(table(resp, treat, age)) #not quite what we need
data2 &lt;- data.frame(success = c(9, 4, 2, 3, 5, 2),
                    sex = c("f", "m", "f", "m", "f", "m"),
                    age = c("med", "med", "old", "old", "young",
                      "young"), total = c(13, 7, 10, 10, 7, 13))
data2$prop &lt;- data2$success/data2$total
data2$fail &lt;- data2$total - data2$success

##run model with success/total syntax using weights argument
mod2 &lt;- glm(prop ~ sex + age, family = binomial, weights = total,
            data = data2)
c_hat(mod2)

##run model with other syntax cbind(success, fail)
mod3 &lt;- glm(cbind(success, fail) ~ sex + age, family = binomial,
            data = data2) 
c_hat(mod3)
</code></pre>

<hr>
<h2 id='calcium'>
Blood Calcium Concentration in Birds
</h2><span id='topic+calcium'></span>

<h3>Description</h3>

<p>This data set features calcium concentration in the plasma of birds
of both sexes following a hormonal treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(calcium)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 3 variables.
</p>

<dl>
<dt><code>Calcium</code></dt><dd><p>calcium concentration in mg/100 ml in the
blood of birds.</p>
</dd>
<dt><code>Hormone</code></dt><dd><p>a factor with two levels indicating whether
the bird received a hormonal treatment or not.</p>
</dd>
<dt><code>Sex</code></dt><dd><p>a factor with two levels coding for the sex of
birds.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Zar (1984, p. 206) illustrates a two-way ANOVA with interaction with
this data set.
</p>


<h3>Source</h3>

<p>Zar, J. H. (1984) <em>Biostatistical analysis</em>. Second
edition. Prentice Hall: Englewood Cliffs, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(calcium)
str(calcium)
</code></pre>

<hr>
<h2 id='cement'>
Heat Expended Following Hardening of Portland Cement
</h2><span id='topic+cement'></span>

<h3>Description</h3>

<p>This data set illustrates the heat expended (calories) from mixtures of four
different ingredients of Portland cement expressed as a percentage by weight.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cement)</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 5 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>calcium aluminate.</p>
</dd>
<dt><code>x2</code></dt><dd><p>tricalcium silicate.</p>
</dd>
<dt><code>x3</code></dt><dd><p>tetracalcium alumino ferrite.</p>
</dd>
<dt><code>x4</code></dt><dd><p>dicalcium silicate.</p>
</dd>
<dt><code>y</code></dt><dd><p>calories of heat per gram of cement following 180
days of hardening.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Burnham and Anderson (2002, p. 101) use this data set originally from Woods et
al. (1932) to select among a set of multiple regression models.
</p>


<h3>Source</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York. 
</p>
<p>Woods, H., Steinour, H. H., Starke, H. R. (1932) Effect of composition
of Portland cement on heat evolved during hardening. <em>Industrial
and Engineering Chemistry</em> <b>24</b>, 1207&ndash;1214.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cement)
## maybe str(cement) ; plot(cement) ...
</code></pre>

<hr>
<h2 id='checkConv'>
Check Convergence of Fitted Model
</h2><span id='topic+checkConv'></span><span id='topic+checkConv.default'></span><span id='topic+checkConv.betareg'></span><span id='topic+checkConv.clm'></span><span id='topic+checkConv.clmm'></span><span id='topic+checkConv.glm'></span><span id='topic+checkConv.glmmTMB'></span><span id='topic+checkConv.hurdle'></span><span id='topic+checkConv.lavaan'></span><span id='topic+checkConv.maxlikeFit'></span><span id='topic+checkConv.merMod'></span><span id='topic+checkConv.lmerModLmerTest'></span><span id='topic+checkConv.multinom'></span><span id='topic+checkConv.nls'></span><span id='topic+checkConv.polr'></span><span id='topic+checkConv.unmarkedFit'></span><span id='topic+checkConv.zeroinfl'></span><span id='topic+print.checkConv'></span>

<h3>Description</h3>

<p>This function checks the convergence information contained in models of
various classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkConv(mod, ...)

## S3 method for class 'betareg'
checkConv(mod, ...)

## S3 method for class 'clm'
checkConv(mod, ...)

## S3 method for class 'clmm'
checkConv(mod, ...)

## S3 method for class 'glm'
checkConv(mod, ...)

## S3 method for class 'glmmTMB'
checkConv(mod, ...)

## S3 method for class 'hurdle'
checkConv(mod, ...)

## S3 method for class 'lavaan'
checkConv(mod, ...)

## S3 method for class 'maxlikeFit'
checkConv(mod, ...)

## S3 method for class 'merMod'
checkConv(mod, ...)

## S3 method for class 'lmerModLmerTest'
checkConv(mod, ...)

## S3 method for class 'multinom'
checkConv(mod, ...)

## S3 method for class 'nls'
checkConv(mod, ...)

## S3 method for class 'polr'
checkConv(mod, ...)

## S3 method for class 'unmarkedFit'
checkConv(mod, ...)

## S3 method for class 'zeroinfl'
checkConv(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkConv_+3A_mod">mod</code></td>
<td>

<p>an object containing the output of a model of the classes mentioned
above. 
</p>
</td></tr>
<tr><td><code id="checkConv_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the element of a model object that contains the
convergence information from the optimization function.  The function
is currently implemented for models of classes <code>betareg</code>,
<code>clm</code>, <code>clmm</code>, <code>glm</code>, <code>glmmTMB</code>, <code>hurdle</code>,
<code>lavaan</code>, <code>maxlikeFit</code>, <code>merMod</code>,
<code>lmerModLmerTest</code>, <code>multinom</code>, <code>nls</code>, <code>polr</code>,
<code>unmarkedFit</code>, and <code>zeroinfl</code>.  The function is particularly
useful for functions with several groups of parameters, such as those
of the <code>unmarked</code> package (Fiske and Chandler, 2011).
</p>


<h3>Value</h3>

<p><code>checkConv</code> returns a list with the following components:
</p>
<table>
<tr><td><code>converged</code></td>
<td>
<p>a logical value indicating whether the algorithm
converged or not.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>a string containing the message from the optimization
function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Fiske, I., Chandler, R. (2011) unmarked: An R Package for
fitting hierarchical models of wildlife occurrence and
abundance. <em>Journal of Statistical Software</em> <b>43</b>, 1&ndash;23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkParms">checkParms</a></code>, <code><a href="#topic+covDiag">covDiag</a></code>,
<code><a href="#topic+mb.gof.test">mb.gof.test</a></code>, <code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##example modified from ?pcount
## Not run: 
if(require(unmarked)){
##Simulate data
set.seed(3)
nSites &lt;- 100
nVisits &lt;- 3
##covariate
x &lt;- rnorm(nSites)               
beta0 &lt;- 0
beta1 &lt;- 1
##expected counts
lambda &lt;- exp(beta0 + beta1*x)   
N &lt;- rpois(nSites, lambda)      
y &lt;- matrix(NA, nSites, nVisits)
p &lt;- c(0.3, 0.6, 0.8)           
for(j in 1:nVisits) {
  y[,j] &lt;- rbinom(nSites, N, p[j])
}
## Organize data
visitMat &lt;- matrix(as.character(1:nVisits),
                   nSites, nVisits, byrow=TRUE)
     
umf &lt;- unmarkedFramePCount(y=y, siteCovs=data.frame(x=x),
                           obsCovs=list(visit=visitMat))
## Fit model
fm1 &lt;- pcount(~ visit ~ 1, umf, K=50)
checkConv(fm1)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='checkParms'>
Identify Parameters with Large Standard Errors
</h2><span id='topic+checkParms'></span><span id='topic+checkParms.default'></span><span id='topic+checkParms.betareg'></span><span id='topic+checkParms.clm'></span><span id='topic+checkParms.clmm'></span><span id='topic+checkParms.coxme'></span><span id='topic+checkParms.coxph'></span><span id='topic+checkParms.glm'></span><span id='topic+checkParms.glmmTMB'></span><span id='topic+checkParms.gls'></span><span id='topic+checkParms.gnls'></span><span id='topic+checkParms.hurdle'></span><span id='topic+checkParms.lm'></span><span id='topic+checkParms.lme'></span><span id='topic+checkParms.lmekin'></span><span id='topic+checkParms.maxlikeFit'></span><span id='topic+checkParms.merMod'></span><span id='topic+checkParms.lmerModLmerTest'></span><span id='topic+checkParms.multinom'></span><span id='topic+checkParms.nlme'></span><span id='topic+checkParms.nls'></span><span id='topic+checkParms.polr'></span><span id='topic+checkParms.rlm'></span><span id='topic+checkParms.survreg'></span><span id='topic+checkParms.unmarkedFit'></span><span id='topic+checkParms.vglm'></span><span id='topic+checkParms.zeroinfl'></span><span id='topic+print.checkParms'></span>

<h3>Description</h3>

<p>This function identifies parameter estimates with large standard errors
in a model.  It is particularly useful for complex models with different
parameter types such as those of <code>unmarkedFit</code> classes implemented
in package <code>unmarked</code> (Fiske and Chandler, 2011), as well as other
types of regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkParms(mod, se.max = 25, simplify = TRUE, ...)

## S3 method for class 'betareg'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'clm'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'clmm'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'coxme'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'coxph'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'glm'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'glmmTMB'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'gls'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'gnls'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'hurdle'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'lm'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'lme'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'lmekin'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'maxlikeFit'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'merMod'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'lmerModLmerTest'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'multinom'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'nlme'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'nls'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'polr'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'rlm'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'survreg'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'unmarkedFit'
checkParms(mod, se.max = 25, simplify = TRUE,
...)

## S3 method for class 'vglm'
checkParms(mod, se.max = 25, ...)

## S3 method for class 'zeroinfl'
checkParms(mod, se.max = 25, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkParms_+3A_mod">mod</code></td>
<td>

<p>a model of <code>unmarkedFit</code> classes or other regression model.
This model is checked to determine the occurrence of large standard
errors for parameter estimates.
</p>
</td></tr>
<tr><td><code id="checkParms_+3A_se.max">se.max</code></td>
<td>

<p>specifies the value beyond which standard errors are deemed high for
the model at hand.  The function will determine the number of
estimates with standard errors that exceed <code>se.max</code>.
</p>
</td></tr>
<tr><td><code id="checkParms_+3A_simplify">simplify</code></td>
<td>

<p>this argument is only valid for models of <code>unmarkedFit</code>
classes which consist of several parameter types for detection
probability and demographic parameters (e.g., abundance, occupancy,
extinction).  If <code>TRUE</code>, the function returns a matrix with a
single row identifying the parameter type and estimate with the
highest standard error.  If <code>FALSE</code>, the function returns a
matrix with as many rows as there are parameter types in the model.
In the latter case, the estimate with the highest standard error for
each parameter type is presented.
</p>
</td></tr>
<tr><td><code id="checkParms_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some complex models such as certain hierarchical models (Royle and
Dorazio 2008, Kry and Royle 2015), issues in estimating parameters and
their standard errors can occur.  Large standard errors can be
indicative of problems in estimating certain parameters due to sparse
data, parameters on the boundary, or model misspecification.  The
<code>checkParms</code> function computes the number of parameter estimates
with standard errors larger than <code>se.max</code> and identifies the
parameter estimate with the largest standard error across all parameter
types (<code>simplify = TRUE</code>) or for each parameter type
(<code>simplify = FALSE</code>).
</p>
<p>To help identify large standard errors, users can standardize numeric
explanatory variables to zero mean and unit variance.  The
<code>checkParms</code> function can also be useful to identify boundary
estimates in classic generalized models or their extensions (Venables
and Ripley 2002).
</p>


<h3>Value</h3>

<p><code>checkParms</code> returns a list of class <code>checkParms</code> with the
following components:
</p>
<table>
<tr><td><code>model.class</code></td>
<td>
<p>the class of the model for which diagnostics are
requested.</p>
</td></tr>
<tr><td><code>se.max</code></td>
<td>
<p>the value of SE used as a threshold in diagnostics.  The
function reports the number of parameter estimates with SE &gt;
<em>se.max</em>.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a matrix consisting of three columns, namely, the
identity of the parameter estimate with the highest SE
(<code>variable</code>), its standard error (<code>max.se</code>), and the
number of parameter estimates with SE larger than <code>se.max</code>
(<code>n.high.se</code>).  For classical regression models with a single
response variable, the row name is labeled <code>beta</code>.  For
<code>unmarkedFit</code> models, the matrix either consists of a single
row (<code>simplify = TRUE)</code> labeled with the name of the parameter
type (e.g., psi, gam, eps, p) where the highest SE occurs, or
consists of as many rows as there are parameter types
(<code>simplify = FALSE</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Agresti, A. (2002) <em>Categorical data analysis</em>. John Wiley and
Sons, Inc.: Hoboken.
</p>
<p>Fiske, I., Chandler, R. (2011) unmarked: An R Package for
fitting hierarchical models of wildlife occurrence and
abundance. <em>Journal of Statistical Software</em> <b>43</b>, 1&ndash;23.
</p>
<p>Kry, M., Royle, J. A. (2015) <em>Applied hierarchical modeling in
ecology: analysis of distribution, abundance and species richness in R
and BUGS</em>. Academic Press, New York, USA. 
</p>
<p>Royle, J. A., Dorazio, R. M. (2008) <em>Hierarchical modeling and
inference in ecology: the analysis of data from populations,
metapopulations and communities</em>. Academic Press: New York.
</p>
<p>Venables, W. N., Ripley, B. D. (2002) <em>Modern applied statistics
with S</em>, 2nd edition. Springer-Verlag: New York. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+detHist">detHist</a></code>, <code><a href="#topic+checkConv">checkConv</a></code>,
<code><a href="#topic+countDist">countDist</a></code>, <code><a href="#topic+countHist">countHist</a></code>,
<code><a href="#topic+extractCN">extractCN</a></code>, <code><a href="#topic+mb.gof.test">mb.gof.test</a></code>,
<code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>, <code><a href="unmarked.html#topic+parboot">parboot</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##example with multiple-season occupancy model modified from ?colext
## Not run: 
require(unmarked)
data(frogs)
umf &lt;- formatMult(masspcru)
obsCovs(umf) &lt;- scale(obsCovs(umf))
siteCovs(umf) &lt;- rnorm(numSites(umf))
yearlySiteCovs(umf) &lt;- data.frame(year = factor(rep(1:7,
                                    numSites(umf))))

##model with with year-dependent transition rates
fm.yearly &lt;- colext(psiformula = ~ 1, gammaformula = ~ year,
                    epsilonformula = ~ year,
                    pformula = ~ JulianDate + I(JulianDate^2),
                    data = umf)

##check for high SE's and report highest
##across all parameter types
checkParms(fm.yearly, simplify = TRUE)

##check for high SE's and report highest
##for each parameter type
checkParms(fm.yearly, simplify = FALSE)
detach(package:unmarked)

## End(Not run)

##example from Agresti 2002 of logistic regression
##with parameters estimated at the boundary (complete separation)
## Not run: 
x &lt;- c(10, 20, 30, 40, 60, 70, 80, 90)
y &lt;- c(0, 0, 0, 0, 1, 1, 1, 1)

m1 &lt;- glm(y ~ x, family = binomial)
checkParms(m1)

## End(Not run)
</code></pre>

<hr>
<h2 id='confset'>
Computing Confidence Set for the Kullback-Leibler Best Model
</h2><span id='topic+confset'></span><span id='topic+print.confset'></span>

<h3>Description</h3>

<p>This function computes the confidence set on the best model given
the data and model set.  <code>confset</code> implements three different
methods proposed by Burnham and Anderson (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confset(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
        method = "raw", level = 0.95, delta = 6, c.hat = 1)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confset_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="confset_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="confset_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="confset_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.
In such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="confset_+3A_method">method</code></td>
<td>

<p>a character value, either as <code>raw</code>, <code>ordinal</code>, or
<code>ratio</code>, indicating the method for determining the confidence set
for the best model (see 'Description' above for details).
</p>
</td></tr>
<tr><td><code id="confset_+3A_level">level</code></td>
<td>

<p>the level of confidence (i.e., sum of model probabilities) used to
determine the confidence set on the best model when using the <code>raw</code>
method.  Note that the argument is not used for the other methods of
determining the confidence set on the best model. 
</p>
</td></tr>
<tr><td><code id="confset_+3A_delta">delta</code></td>
<td>

<p>the delta (Q)AIC(c) value associated with the cutoff point to determine
the confidence set for the best model.  Note that the argument is only
used when <code>method = ratio</code>.
</p>
</td></tr>
<tr><td><code id="confset_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>confset</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first and simplest (<code>method = 'raw'</code>), relies on summing the
Akaike weights (i.e., model probabilities) of the ranked models until we
reach a given cutpoint (e.g., 0.95 for a 95 percent set).
</p>
<p>The second method (<code>method = 'ordinal'</code>) suggested is based on the
classification of the models on an ordinal scale based on the delta
(Q)AIC(c).  The models are grouped in different classes based on their
weight of support as determined by the delta (Q)AIC(c) values:
substantial support (delta (Q)AIC(c) &lt;= 2), some support (2 &lt; delta
(Q)AIC(c) &lt;= 7), little support (7 &lt; delta (Q)AIC(c) &lt;= 10), no support
(delta (Q)AIC(c) &gt; 10).
</p>
<p>The third method (<code>method = 'ratio'</code>) is based on identifying the
ratios of model likelihoods (i.e., exp(-delta_(Q)AIC(c)/2) ) that exceed
a cutpoint, similar to the building of profile likelihood intervals.  An
evidence ratio of each model relative to the top-ranked model is
computed and the ratios exceeding the cutpoint determine which models
are included in the confidence set.  Note here that small cutoff points 
are suggested (e.g., 0.125, 0.050).  The cutoff point is linked to delta
(Q)AIC(c) by the following relationship:  <code class="reqn">cutoff =
  exp(-1*\delta_{(Q)AIC(c)}/2)</code>.
</p>


<h3>Value</h3>

<p><code>confset</code> returns an object of class <code>confset</code> as a list with
the following components, depending on which method is used:
</p>
<p>when <code>method = 'raw'</code>:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>identifies the method of determining the confidence set on
the best model.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the confidence level used to determine the confidence set
on the best model.</p>
</td></tr> 
<tr><td><code>table</code></td>
<td>
<p>a reduced table with the models included in the confidence
set.</p>
</td></tr>
</table>
<p>when <code>method = 'ordinal'</code>:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>identifies the method of determining the confidence set on
the best model.</p>
</td></tr>
<tr><td><code>substantial</code></td>
<td>
<p>a reduced table with the models included in the
confidence set for which delta (Q)AIC(c) &lt;= 2.</p>
</td></tr>
<tr><td><code>some</code></td>
<td>
<p>a reduced table with the models included in the confidence
set for which 2 &lt; delta (Q)AIC(c) &lt;= 7.</p>
</td></tr>
<tr><td><code>little</code></td>
<td>
<p>a reduced table with the models included in the confidence
set for which 7 &lt; delta (Q)AIC(c) &lt;= 10.</p>
</td></tr>
<tr><td><code>none</code></td>
<td>
<p>a reduced table with the models included in the confidence
set for which delta (Q)AIC(c) &gt; 10.</p>
</td></tr>
</table>
<p>when <code>method = 'ratio'</code>:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>identifies the method of determining the confidence set on
the best model.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>the cutoff value for the ratios used to determine the
confidence set on the best model.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>the delta (Q)AIC(c) used to compute the cutoff value for
ratios to determine the confidence set on the best model.</p>
</td></tr>
<tr><td><code>table</code></td>
<td>
<p>a reduced table with the models included in the confidence
set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+importance">importance</a></code>, <code><a href="#topic+modavg">modavg</a></code>,
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##anuran larvae example from Mazerolle (2006)
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##set up candidate models          
Cand.mod &lt;- list()
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[2]] &lt;- glm(Num_anura ~ Type + log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[3]] &lt;- glm(Num_anura ~ Type + Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[4]] &lt;- glm(Num_anura ~ Type, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[5]] &lt;- glm(Num_anura ~ log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[6]] &lt;- glm(Num_anura ~ log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[7]] &lt;- glm(Num_anura ~ Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[8]] &lt;- glm(Num_anura ~ 1, family = poisson,
                     offset = log(Effort), data = min.trap) 
          
##check c-hat for global model
c_hat(Cand.mod[[1]]) #uses Pearson's chi-square/df
##note the very low overdispersion: in this case, the analysis could be
##conducted without correcting for c-hat as its value is reasonably close
##to 1  

##assign names to each model
Modnames &lt;- c("type + logperim + invertpred", "type + logperim",
              "type + invertpred", "type", "logperim + invertpred",
              "logperim", "invertpred", "intercept only") 

##compute confidence set based on 'raw' method
confset(cand.set = Cand.mod, modnames = Modnames, second.ord = TRUE,
        method = "raw")  


##example with linear mixed model
## Not run: 
require(nlme)

##set up candidate model list for Orthodont data set shown in Pinheiro
##and Bates (2000:  Mixed-effect models in S and S-PLUS. Springer Verlag:
##New York.)
Cand.models &lt;- list()
Cand.models[[1]] &lt;- lme(distance ~ age, random = ~age | Subject,
                        data = Orthodont, method = "ML")
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1 | Subject, method = "ML")
Cand.models[[3]] &lt;- lme(distance ~ 1, data = Orthodont,
                        random = ~ 1 | Subject, method = "ML")

##create a vector of model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

##compute confidence set based on 'raw' method
confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "raw")
##round to 4 digits after decimal point
print(confset(cand.set = Cand.models, modnames = Modnames,
              second.ord = TRUE, method = "raw"), digits = 4)

confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        level = 0.9, method = "raw")

##compute confidence set based on 'ordinal' method
confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "ordinal")

##compute confidence set based on 'ratio' method
confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "ratio", delta = 4)

confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "ratio", delta = 8)
detach(package:nlme)

## End(Not run)
</code></pre>

<hr>
<h2 id='countDist'>
Compute Summary Statistics from Distance Sampling Data
</h2><span id='topic+countDist'></span><span id='topic+countDist.default'></span><span id='topic+countDist.unmarkedFrameDS'></span><span id='topic+countDist.unmarkedFitDS'></span><span id='topic+countDist.unmarkedFrameGDS'></span><span id='topic+countDist.unmarkedFitGDS'></span><span id='topic+countDist.unmarkedFrameDSO'></span><span id='topic+countDist.unmarkedFitDSO'></span><span id='topic+print.countDist'></span>

<h3>Description</h3>

<p>This function extracts various summary statistics from distance sampling
data of various <code>unmarkedFrame</code> and <code>unmarkedFit</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countDist(object, plot.freq = TRUE, plot.distance = TRUE, cex.axis = 1,
          cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFrameDS'
countDist(object, plot.freq = TRUE,
                   plot.distance = TRUE, cex.axis = 1, cex.lab = 1,
                   cex.main = 1, ...)

## S3 method for class 'unmarkedFitDS'
countDist(object, plot.freq = TRUE,
                   plot.distance = TRUE, cex.axis = 1, cex.lab = 1,
                   cex.main = 1, ...)

## S3 method for class 'unmarkedFrameGDS'
countDist(object, plot.freq = TRUE,
                   plot.distance = TRUE, cex.axis = 1,
                   cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFitGDS'
countDist(object, plot.freq = TRUE,
                   plot.distance = TRUE, cex.axis = 1,
                   cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFrameDSO'
countDist(object, plot.freq = TRUE,
                   plot.distance = TRUE, cex.axis = 1,
                   cex.lab = 1, cex.main = 1, plot.seasons = FALSE,
                   ...)

## S3 method for class 'unmarkedFitDSO'
countDist(object, plot.freq = TRUE,
                   plot.distance = TRUE, cex.axis = 1,
                   cex.lab = 1, cex.main = 1, plot.seasons = FALSE,
                   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countDist_+3A_object">object</code></td>
<td>

<p>an object of various <code>unmarkedFrame</code> or <code>unmarkedFit</code>
classes containing distance sampling data. 
</p>
</td></tr>
<tr><td><code id="countDist_+3A_plot.freq">plot.freq</code></td>
<td>

<p>logical.  Specifies if the count data (pooled across seasons and
distance classes) should  be plotted.
</p>
</td></tr>
<tr><td><code id="countDist_+3A_plot.distance">plot.distance</code></td>
<td>

<p>logical.  Specifies if the counts in each distance class (pooled
across seasons) should be plotted.  
</p>
</td></tr>
<tr><td><code id="countDist_+3A_cex.axis">cex.axis</code></td>
<td>
<p>expansion factor influencing the size of axis
annotations on plots produced by the function.
</p>
</td></tr>
<tr><td><code id="countDist_+3A_cex.lab">cex.lab</code></td>
<td>
<p>expansion factor influencing the size of axis labels on
plots produced by the function.
</p>
</td></tr>
<tr><td><code id="countDist_+3A_cex.main">cex.main</code></td>
<td>
<p>expansion factor influencing the size of the main title
above plots produced by the function.
</p>
</td></tr> 
<tr><td><code id="countDist_+3A_plot.seasons">plot.seasons</code></td>
<td>

<p>logical.  Specifies if the count data should be plotted for each
distance class and season separately.  This argument is only relevant
for data collected across more than a single season.
</p>
</td></tr>
<tr><td><code id="countDist_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a number of summary statistics in data sets
used for the distance sampling models of Royle et al. (2004),
Chandler et al. (2011), and distance-sampling versions of models of Dail
and Madsen (2011) and Hostetler and Chandler (2015) based on Sollmann et
al. (2015).
</p>
<p><code>countDist</code> can take data frames of the
<code>unmarkedFrameDS</code>, <code>unmarkedFrameGDS</code>,
<code>unmarkedFrameDSO</code> classes as input.  For convenience, the
function can also extract the raw data from model objects of classes
<code>unmarkedFitDS</code>, <code>unmarkedFitGDS</code>, and
<code>unmarkedFitDSO</code>.  Note that different model objects using the
same data set will have identical values.
</p>


<h3>Value</h3>

<p><code>countDist</code> returns a list with the following components:
</p>
<table>
<tr><td><code>count.table.full</code></td>
<td>
<p>a table with the frequency of each observed
count pooled across distances classes.</p>
</td></tr>
<tr><td><code>count.table.seasons</code></td>
<td>
<p>a list of tables with the frequency of
each season-specific count pooled across distance classes.</p>
</td></tr>
<tr><td><code>dist.sums.full</code></td>
<td>
<p>a table with the frequency of counts in each
distance class across the entire sampling seasons.</p>
</td></tr>
<tr><td><code>dist.table.seasons</code></td>
<td>
<p>a list of tables with the frequency of
counts in each distance class for each primary period.</p>
</td></tr>
<tr><td><code>dist.names</code></td>
<td>
<p>a character string of labels for the distance
classes.</p>
</td></tr>
<tr><td><code>n.dist.classes</code></td>
<td>
<p>the number of distance classes.</p>
</td></tr>
<tr><td><code>out.freqs</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the number of sites sampled in
season <code class="reqn">t</code> (<code>sampled</code>) and the number of sites with at
least one detection in season <code class="reqn">t</code> (<code>detected</code>).  For
multiseason data, the matrix includes the number of sites sampled in
season <code class="reqn">t - 1</code> with colonizations observed in season <code class="reqn">t</code>
(<code>colonized</code>), the number of sites sampled in season <code class="reqn">t -
    1</code> with extinctions observed in season <code class="reqn">t</code> (<code>extinct</code>), the
number of sites sampled in season <code class="reqn">t - 1</code> without changes
observed in season <code class="reqn">t</code> (<code>static</code>), and the number of sites
sampled in season <code class="reqn">t</code> that were also sampled in season <code class="reqn">t -
    1</code> (<code>common</code>).
</p>
</td></tr>
<tr><td><code>out.props</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the proportion of sites in
season <em>t</em> with at least one detection (<code>naive.occ</code>).  For
multiseason data, the matrix includes the proportion of sites
sampled in season <code class="reqn">t - 1</code> with colonizations observed in season
<code class="reqn">t</code> (<code>naive.colonization</code>), the proportion of sites
sampled in season <code class="reqn">t - 1</code> with extinctions observed in season
<code class="reqn">t</code> (<code>naive.extinction</code>), and the proportion of sites
sampled in season <code class="reqn">t - 1</code> with no changes observed in season
<code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code>n.seasons</code></td>
<td>
<p>the number of seasons (primary periods) in the data
set.
</p>
</td></tr>
<tr><td><code>n.visits.season</code></td>
<td>
<p>the maximum number of visits per season in the
data set.
</p>
</td></tr>
<tr><td><code>missing.seasons</code></td>
<td>
<p>logical vector indicating whether data were
collected or not during a given season (primary period), where
<code>TRUE</code> indicates that no data were collected during the season. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Chandler, R. B., Royle, J. A., King, D. I. (2011) Inference about
density and temporary emigration in unmarked
populations. <em>Ecology</em> <b>92</b>, 1429&ndash;1435.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587.
</p>
<p>Hostetler, J. A., Chandler, R. B. (2015) Improved state-space models
for inference about spatial and temporal variation in abundance from
count data. <em>Ecology</em> <b>96</b>, 1713&ndash;1723.
</p>
<p>Royle, J. A., Dawson, D. K., Bates, S. (2004) Modeling abundance
effects in distance sampling. <em>Ecology</em> <b>85</b>, 1591&ndash;1597.
</p>
<p>Sollmann, R., Gardner, B., Chandler, R. B., Royle, J. A., Sillett,
T. S. (2015) An open-population hierarchical distance sampling
model. <b>Ecology</b> <b>96</b>, 325&ndash;331.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covDiag">covDiag</a></code>, <code><a href="#topic+detHist">detHist</a></code>, <code><a href="#topic+detTime">detTime</a></code>,
<code><a href="#topic+countHist">countHist</a></code>, <code><a href="#topic+Nmix.chisq">Nmix.chisq</a></code>,
<code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##modified example from ?distsamp
## Not run: 
if(require(unmarked)){
data(linetran)
##format data
ltUMF &lt;- with(linetran, {
              unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
              siteCovs = data.frame(Length, area, habitat),
              dist.breaks = c(0, 5, 10, 15, 20),
              tlength = linetran$Length * 1000, survey = "line",
              unitsIn = "m") 
             })

##compute descriptive stats from data object
countDist(ltUMF)
     
##Half-normal detection function
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
##compute descriptive stats from model object
countDist(fm1)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='countHist'>
Compute Summary Statistics from Count Histories
</h2><span id='topic+countHist'></span><span id='topic+countHist.default'></span><span id='topic+countHist.unmarkedFramePCount'></span><span id='topic+countHist.unmarkedFitPCount'></span><span id='topic+countHist.unmarkedFrameGPC'></span><span id='topic+countHist.unmarkedFitGPC'></span><span id='topic+countHist.unmarkedFrameMPois'></span><span id='topic+countHist.unmarkedFitMPois'></span><span id='topic+countHist.unmarkedFramePCO'></span><span id='topic+countHist.unmarkedFitPCO'></span><span id='topic+countHist.unmarkedFrameGMM'></span><span id='topic+countHist.unmarkedFitGMM'></span><span id='topic+countHist.unmarkedFrameMMO'></span><span id='topic+countHist.unmarkedFitMMO'></span><span id='topic+print.countHist'></span>

<h3>Description</h3>

<p>This function extracts various summary statistics from count data of
various <code>unmarkedFrame</code> and <code>unmarkedFit</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countHist(object, plot.freq = TRUE, cex.axis = 1, cex.lab = 1,
          cex.main = 1, ...) 

## S3 method for class 'unmarkedFramePCount'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFitPCount'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFrameGPC'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFitGPC'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFrameMPois'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFitMPois'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFramePCO'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1,
                   plot.seasons = FALSE, ...)

## S3 method for class 'unmarkedFitPCO'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1,
                   plot.seasons = FALSE, ...)

## S3 method for class 'unmarkedFrameGMM'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1,
                   plot.seasons = FALSE, ...)

## S3 method for class 'unmarkedFitGMM'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1,
                   plot.seasons = FALSE, ...)

## S3 method for class 'unmarkedFrameMMO'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1,
                   plot.seasons = FALSE, ...)

## S3 method for class 'unmarkedFitMMO'
countHist(object, plot.freq = TRUE,
                   cex.axis = 1, cex.lab = 1, cex.main = 1,
                   plot.seasons = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countHist_+3A_object">object</code></td>
<td>

<p>an object of various <code>unmarkedFrame</code> or <code>unmarkedFit</code>
classes containing count history data. 
</p>
</td></tr>
<tr><td><code id="countHist_+3A_plot.freq">plot.freq</code></td>
<td>

<p>logical.  Specifies if the count data (pooled across seasons) should
be plotted.
</p>
</td></tr>
<tr><td><code id="countHist_+3A_cex.axis">cex.axis</code></td>
<td>
<p>expansion factor influencing the size of axis
annotations on plots produced by the function.
</p>
</td></tr>
<tr><td><code id="countHist_+3A_cex.lab">cex.lab</code></td>
<td>
<p>expansion factor influencing the size of axis labels on
plots produced by the function.
</p>
</td></tr>
<tr><td><code id="countHist_+3A_cex.main">cex.main</code></td>
<td>
<p>expansion factor influencing the size of the main title
above plots produced by the function.
</p>
</td></tr> 
<tr><td><code id="countHist_+3A_plot.seasons">plot.seasons</code></td>
<td>

<p>logical.  Specifies if the count data should be plotted for each
season separately.  This argument is only relevant for data collected
across more than a single season.
</p>
</td></tr>
<tr><td><code id="countHist_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a number of summary statistics in data sets
used for various <em>N</em>-mixture models including those of Royle
(2004a, b), Dail and Madsen (2011), and Chandler et al. (2011).
</p>
<p><code>countHist</code> can take data frames of the
<code>unmarkedFramePCount</code>, <code>unmarkedFrameGPC</code>,
<code>unmarkedFrameMPois</code>, <code>unmarkedFramePCO</code>,
<code>unmarkedFrameGMM</code>, <code>unmarkedFrameMMO</code> classes as input.
For convenience, the function can also extract the raw data from model
objects of classes <code>unmarkedFitPCount</code>, <code>unmarkedFitGPC</code>,
<code>unmarkedFitMPois</code>, <code>unmarkedFitPCO</code>, <code>unmarkedFitGMM</code>,
and <code>unmarkedFitMMO</code>. Note that different model objects using the
same data set will have identical values.
</p>


<h3>Value</h3>

<p><code>countHist</code> returns a list with the following components:
</p>
<table>
<tr><td><code>count.table.full</code></td>
<td>
<p>a table with the frequency of each observed
count.</p>
</td></tr>
<tr><td><code>count.table.seasons</code></td>
<td>
<p>a list of tables with the frequency of
each season-specific count.</p>
</td></tr>
<tr><td><code>hist.table.full</code></td>
<td>
<p>a table with the frequency of each count
history across the entire sampling period.</p>
</td></tr>
<tr><td><code>hist.table.seasons</code></td>
<td>
<p>a list of tables with the frequency of
each count history for each primary period (season).</p>
</td></tr>
<tr><td><code>out.freqs</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the number of sites sampled in
season <code class="reqn">t</code> (<code>sampled</code>) and the number of sites with at
least one detection in season <code class="reqn">t</code> (<code>detected</code>).  For
multiseason data, the matrix includes the number of sites sampled in
season <code class="reqn">t - 1</code> with colonizations observed in season <code class="reqn">t</code>
(<code>colonized</code>), the number of sites sampled in season <code class="reqn">t -
    1</code> with extinctions observed in season <code class="reqn">t</code> (<code>extinct</code>), the
number of sites sampled in season <code class="reqn">t - 1</code> without changes
observed in season <code class="reqn">t</code> (<code>static</code>), and the number of sites
sampled in season <code class="reqn">t</code> that were also sampled in season <code class="reqn">t -
    1</code> (<code>common</code>).
</p>
</td></tr>
<tr><td><code>out.props</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the proportion of sites in
season <em>t</em> with at least one detection (<code>naive.occ</code>).  For
multiseason data, the matrix includes the proportion of sites
sampled in season <code class="reqn">t - 1</code> with colonizations observed in season
<code class="reqn">t</code> (<code>naive.colonization</code>), the proportion of sites
sampled in season <code class="reqn">t - 1</code> with extinctions observed in season
<code class="reqn">t</code> (<code>naive.extinction</code>), and the proportion of sites
sampled in season <code class="reqn">t - 1</code> with no changes observed in season
<code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code>n.seasons</code></td>
<td>
<p>the number of seasons (primary periods) in the data set.
</p>
</td></tr>
<tr><td><code>n.visits.season</code></td>
<td>
<p>the maximum number of visits per season in the data set.
</p>
</td></tr>
<tr><td><code>missing.seasons</code></td>
<td>
<p>logical vector indicating whether data were
collected or not during a given season (primary period), where
<code>TRUE</code> indicates that no data were collected during the season. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Chandler, R. B., Royle, J. A., King, D. I. (2011) Inference about
density and temporary emigration in unmarked
populations. <em>Ecology</em> <b>92</b>, 1429&ndash;1435. 
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587.  
</p>
<p>Royle, J. A. (2004a) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>
<p>Royle, J. A. (2004b) Generalized estimators of avian abundance from
count survey data. <em>Animal Biodiversity and Conservation</em>
<b>27</b>, 375&ndash;386. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covDiag">covDiag</a></code>, <code><a href="#topic+detHist">detHist</a></code>, <code><a href="#topic+detTime">detTime</a></code>,
<code><a href="#topic+countDist">countDist</a></code>, <code><a href="#topic+Nmix.chisq">Nmix.chisq</a></code>,
<code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##modified example from ?pcount
## Not run: 
if(require(unmarked)){
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##compute descriptive stats from data object
countHist(mallardUMF)

##run single season model
fm.mallard &lt;- pcount(~ ivel+ date + I(date^2) ~ length + elev +
                     forest, mallardUMF, K=30)
##compute descriptive stats from model object
countHist(fm.mallard)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='covDiag'>
Compute Covariance Diagnostic for Lambda in <em>N</em>-mixture Models
</h2><span id='topic+covDiag'></span><span id='topic+covDiag.default'></span><span id='topic+covDiag.unmarkedFitPCount'></span><span id='topic+covDiag.unmarkedFramePCount'></span><span id='topic+print.covDiag'></span>

<h3>Description</h3>

<p>This function extracts the covariance diagnostic of Dennis et al. (2015) 
for lambda in <em>N</em>-mixture models (Royle 2004) of the
<code>unmarkedFitPCount</code> class as well as in data frames of the
<code>unmarkedFramePcount</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covDiag(object, ...)

## S3 method for class 'unmarkedFitPCount'
covDiag(object, ...)

## S3 method for class 'unmarkedFramePCount'
covDiag(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covDiag_+3A_object">object</code></td>
<td>

<p>an object of class <code>unmarkedFitPCount</code> or <code>unmarkedFramePCount</code>.
</p>
</td></tr>
<tr><td><code id="covDiag_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the covariance diagnostic developed by Dennis 
et al. (2015) for lambda in <em>N</em>-mixture models.  Values &lt;= 0
suggest sparse data and potential problems during model fitting.
<code>covDiag</code> can take data frames of the <code>unmarkedFramePcount</code>
class as input.  For convenience, the function also takes the repeated
count model object as input, extracts the raw data, and computes the
covariance diagnostic.  Thus, different models on the same data set
will have identical values for this covariance diagnostic.   
</p>


<h3>Value</h3>

<p><code>covDiag</code> returns a list with the following components:
</p>
<table>
<tr><td><code>cov.diag</code></td>
<td>
<p>the value of the covariance diagnostic.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>a string indicating whether a warning was issued (i.e.,
<code>"Warning: lambda is infinite, data too sparse"</code>) or not (i.e.,
<code>NULL</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Dennis, E. B., Morgan, B. J. T., Ridout, M. S. (2015)
Computational aspects of <em>N</em>-mixture models. <em>Biometrics</em>
<b>71</b>, 237&ndash;246.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code>,
<code><a href="#topic+Nmix.chisq">Nmix.chisq</a></code>, <code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>,
<code><a href="#topic+predictSE">predictSE</a></code>, <code><a href="unmarked.html#topic+pcount">pcount</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##modified example from ?pcount
## Not run: 
if(require(unmarked)){
##Simulate data
set.seed(3)
nSites &lt;- 100
nVisits &lt;- 3
##covariate
x &lt;- rnorm(nSites)               
beta0 &lt;- 0
beta1 &lt;- 1
##expected counts
lambda &lt;- exp(beta0 + beta1*x)   
N &lt;- rpois(nSites, lambda)      
y &lt;- matrix(NA, nSites, nVisits)
p &lt;- c(0.3, 0.6, 0.8)           
for(j in 1:nVisits) {
  y[,j] &lt;- rbinom(nSites, N, p[j])
}
## Organize data
visitMat &lt;- matrix(as.character(1:nVisits),
                   nSites, nVisits, byrow=TRUE)
     
umf &lt;- unmarkedFramePCount(y=y, siteCovs=data.frame(x=x),
                           obsCovs=list(visit=visitMat))
## Fit model
fm1 &lt;- pcount(~ visit ~ 1, umf, K=50)
covDiag(fm1)

##sparser data
p &lt;- c(0.01, 0.001, 0.01)           
for(j in 1:nVisits) {
  y[,j] &lt;- rbinom(nSites, N, p[j])
}
## Organize data
visitMat &lt;- matrix(as.character(1:nVisits),
                   nSites, nVisits, byrow=TRUE)
     
umf &lt;- unmarkedFramePCount(y=y, siteCovs=data.frame(x=x),
                           obsCovs=list(visit=visitMat))
## Fit model
fm.sparse &lt;- pcount(~ visit ~ 1, umf, K=50)
covDiag(fm.sparse)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='detHist'>
Compute Summary Statistics from Detection Histories
</h2><span id='topic+detHist'></span><span id='topic+detHist.default'></span><span id='topic+detHist.unmarkedFitColExt'></span><span id='topic+detHist.unmarkedFitOccu'></span><span id='topic+detHist.unmarkedFitOccuFP'></span><span id='topic+detHist.unmarkedFitOccuRN'></span><span id='topic+detHist.unmarkedFitOccuMulti'></span><span id='topic+detHist.unmarkedFitOccuMS'></span><span id='topic+detHist.unmarkedFrameOccu'></span><span id='topic+detHist.unmarkedFrameOccuFP'></span><span id='topic+detHist.unmarkedFrameOccuMulti'></span><span id='topic+detHist.unmarkedMultFrame'></span><span id='topic+detHist.unmarkedFrameOccuMS'></span><span id='topic+print.detHist'></span>

<h3>Description</h3>

<p>This function extracts various summary statistics from detection history
data of various <code>unmarkedFrame</code> and <code>unmarkedFit</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detHist(object, ...)

## S3 method for class 'unmarkedFitColExt'
detHist(object, ...)

## S3 method for class 'unmarkedFitOccu'
detHist(object, ...)

## S3 method for class 'unmarkedFitOccuFP'
detHist(object, ...)

## S3 method for class 'unmarkedFitOccuRN'
detHist(object, ...)

## S3 method for class 'unmarkedFitOccuMulti'
detHist(object, ...)

## S3 method for class 'unmarkedFitOccuMS'
detHist(object, ...)

## S3 method for class 'unmarkedFrameOccu'
detHist(object, ...)

## S3 method for class 'unmarkedFrameOccuFP'
detHist(object, ...)

## S3 method for class 'unmarkedMultFrame'
detHist(object, ...)

## S3 method for class 'unmarkedFrameOccuMulti'
detHist(object, ...)

## S3 method for class 'unmarkedFrameOccuMS'
detHist(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detHist_+3A_object">object</code></td>
<td>

<p>an object of various <code>unmarkedFrame</code> or <code>unmarkedFit</code>
classes containing detection history data. 
</p>
</td></tr>
<tr><td><code id="detHist_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a number of summary statistics in data sets
used for single-season occupancy models (MacKenzie et al. 2002),
dynamic occupancy models (MacKenzie et al. 2003), Royle-Nichols models
(Royle and Nichols 2003), false-positive occupancy models (Royle
and Link 2006, Miller et al. 2011), multispecies occupancy models
(Rota et al. 2016), and multistate occupancy models (Nichols et
al. 2007, MacKenzie et al. 2009).
</p>
<p><code>detHist</code> can take data frames of the <code>unmarkedFrameOccu</code>,
<code>unmarkedFrameOccuFP</code>, <code>unmarkedMultFrame</code>,
<code>unmarkedFrameOccuMulti</code>, <code>unmarkedFrameOccuMS</code> classes as
input.  For convenience, the  function can also extract the raw data
from model objects of classes <code>unmarkedFitColExt</code>,
<code>unmarkedFitOccu</code>,  <code>unmarkedFitOccuFP</code>,
<code>unmarkedFitOccuRN</code>, <code>unmarkedFrameOccuMulti</code>, and
<code>unmarkedFrameOccuMS</code>.  Note that different model objects using
the same data set will have identical values.
</p>


<h3>Value</h3>

<p>For objects of classes <code>unmarkedFitOccu</code>, <code>unmarkedFitOccuRN</code>,
<code>unmarkedFitOccuFP</code>, <code>unmarkedFitColExt</code>,
<code>unmarkedFitOccuMS</code>, <code>unmarkedFrameOccu</code>,
<code>unmarkedFrameOccuFP</code>, <code>unmarkedMultFrame</code>, and
<code>unmarkedFrameOccuMS</code>, <code>detHist</code> returns a list with the
following components:
</p>
<table>
<tr><td><code>hist.table.full</code></td>
<td>
<p>a table with the frequency of each observed
detection history.</p>
</td></tr>
<tr><td><code>hist.table.seasons</code></td>
<td>
<p>a list of tables with the frequency of
each season-specific detection history.</p>
</td></tr>
<tr><td><code>out.freqs</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the number of sites sampled in
season <code class="reqn">t</code> (<code>sampled</code>) and the number of sites with at
least one detection in season <code class="reqn">t</code> (<code>detected</code>).  For
multiseason data, the matrix includes the number of sites sampled in
season <code class="reqn">t - 1</code> with colonizations observed in season <code class="reqn">t</code>
(<code>colonized</code>), the number of sites sampled in season <code class="reqn">t -
    1</code> with extinctions observed in season <code class="reqn">t</code> (<code>extinct</code>), the
number of sites sampled in season <code class="reqn">t - 1</code> without changes
observed in season <code class="reqn">t</code> (<code>static</code>), and the number of sites
sampled in season <code class="reqn">t</code> that were also sampled in season <code class="reqn">t -
    1</code> (<code>common</code>).  For multispecies data, <code>out.freqs</code>
presents for each species the number of sites sampled and the number
of sites with at least one detection.
</p>
</td></tr>
<tr><td><code>out.props</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the proportion of sites in
season <em>t</em> with at least one detection (<code>naive.occ</code>).  For
multiseason data, the matrix includes the proportion of sites
sampled in season <code class="reqn">t - 1</code> with colonizations observed in season
<code class="reqn">t</code> (<code>naive.colonization</code>), the proportion of sites
sampled in season <code class="reqn">t - 1</code> with extinctions observed in season
<code class="reqn">t</code> (<code>naive.extinction</code>), and the proportion of sites
sampled in season <code class="reqn">t - 1</code> with no changes observed in season
<code class="reqn">t</code>. For multispecies data, <code>out.props</code> presents the
proportion of sites with a least one detection for each species.
</p>
</td></tr>
<tr><td><code>n.seasons</code></td>
<td>
<p>the number of seasons (primary periods) in the data set.
</p>
</td></tr>
<tr><td><code>n.visits.season</code></td>
<td>
<p>the maximum number of visits per season in the data set.
</p>
</td></tr>
<tr><td><code>n.species</code></td>
<td>
<p>the number of species in the data set.
</p>
</td></tr>
<tr><td><code>missing.seasons</code></td>
<td>
<p>logical vector indicating whether data were
collected or not during a given season (primary period), where
<code>TRUE</code> indicates that no data were collected during the season. 
</p>
</td></tr>
</table>
<p>For objects of classes <code>unmarkedFitOccuMulti</code> and
<code>unmarkedFrameOccuMulti</code>, <code>detHist</code> returns a list with the
following components: 
</p>
<table>
<tr><td><code>hist.table.full</code></td>
<td>
<p>a table with the frequency of each observed
detection history.  The species are coded with letters and follow
the same order of presentation as in the other parts of the output.</p>
</td></tr>
<tr><td><code>hist.table.species</code></td>
<td>
<p>a list of tables with the frequency of
each species-specific detection history.  The last element of
<code>hist.table.species</code> features the number of sites with
co-occurrence of the different species (<code>coOcc</code>).</p>
</td></tr> 
<tr><td><code>out.freqs</code></td>
<td>
<p>a matrix where the rows correspond to each species
and where columns consist of the number of sites sampled during the
season (<code>sampled</code>) and the number of sites with at least one
detection (<code>detected</code>).</p>
</td></tr>
<tr><td><code>out.props</code></td>
<td>
<p>a matrix where the rows correspond to each species
and where columns consist of the proportion of sites with at least
one detection during the season (<code>naive.occ</code>).
</p>
</td></tr>
<tr><td><code>n.seasons</code></td>
<td>
<p>the number of seasons (primary periods) in the data set.
</p>
</td></tr>
<tr><td><code>n.visits.season</code></td>
<td>
<p>the maximum number of visits per season in the data set.
</p>
</td></tr>
<tr><td><code>n.species</code></td>
<td>
<p>the number of species in the data set.
</p>
</td></tr>
<tr><td><code>missing.seasons</code></td>
<td>
<p>logical vector indicating whether data were
collected or not during a given season (primary period), where
<code>TRUE</code> indicates that no data were collected during the season. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle, 
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when 
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.  
</p>
<p>MacKenzie, D. I., Nichols, J. D., Seamans, M. E., Gutierrez,
R. J. (2009) Modeling species occurrence dynamics with multiple states
and imperfect detection. <em>Ecology</em> <b>90</b>, 823&ndash;835.
</p>
<p>Mazerolle, M. J. (2015) Estimating detectability and biological
parameters of interest with the use of the R
environment. <em>Journal of Herpetology</em> <b>49</b>, 541&ndash;559.
</p>
<p>Miller, D. A. W., Nichols, J. D., McClintock, B. T., Campbell
Grant, E. H., Bailey, L. L. (2011) Improving occupancy estimation when
two types of observational error occur: non-detection and species
misidentification. <em>Ecology</em> <b>92</b>, 1422&ndash;1428.
</p>
<p>Nichols, J. D., Hines, J. E., Mackenzie, D. I., Seamans, M. E.,
Gutierrez, R. J. (2007) Occupancy estimation and modeling with
multiple states and state uncertainty. <em>Ecology</em> <b>88</b>,
1395&ndash;1400.
</p>
<p>Rota, C. T., Ferreira, M. A. R., Kays, R. W., Forrester, T. D.,
Kalies, E. L., McShea, W. J., Parsons, A. W., Millspaugh, J. J. (2016)
A multispecies occupancy model for two or more interacting
species. <em>Methods in Ecology and Evolution</em> <b>7</b>,
1164&ndash;1173.
</p>
<p>Royle, J. A., Link, W. A. (2006) Generalized site occupancy models
allowing for false positive and false negative errors. <em>Ecology</em>
<b>87</b>, 835&ndash;841.
</p>
<p>Royle, J. A., Nichols, J. D. (2003) Estimating abundance from
repeated presence-absence data or point counts. <em>Ecology</em>
<b>84</b>, 777&ndash;790.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covDiag">covDiag</a></code>, <code><a href="#topic+countHist">countHist</a></code>, <code><a href="#topic+countDist">countDist</a></code>,
<code><a href="#topic+detTime">detTime</a></code>, <code><a href="#topic+mb.chisq">mb.chisq</a></code>, <code><a href="#topic+mb.gof.test">mb.gof.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##data from Mazerolle (2015)
## Not run: 
data(bullfrog)

##detection data
detections &lt;- bullfrog[, 3:9]

##load unmarked package
if(require(unmarked)){

##assemble in unmarkedFrameOccu
bfrog &lt;- unmarkedFrameOccu(y = detections)

##compute descriptive stats from data object
detHist(bfrog)

##run model
fm &lt;- occu(~ 1 ~ 1, data = bfrog)
##compute descriptive stats from model object
detHist(fm)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='detTime'>
Compute Summary Statistics from Time to Detection Data
</h2><span id='topic+detTime'></span><span id='topic+detTime.default'></span><span id='topic+detTime.unmarkedFrameOccuTTD'></span><span id='topic+detTime.unmarkedFitOccuTTD'></span><span id='topic+print.detTime'></span>

<h3>Description</h3>

<p>This function extracts various summary statistics from time to detection
data of various <code>unmarkedFrame</code> and <code>unmarkedFit</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detTime(object, plot.time = TRUE, plot.seasons = FALSE,
        cex.axis = 1, cex.lab = 1, cex.main = 1, ...)

## S3 method for class 'unmarkedFrameOccuTTD'
detTime(object, plot.time = TRUE,
                 plot.seasons = FALSE, cex.axis = 1, cex.lab = 1,
                 cex.main = 1, ...)

## S3 method for class 'unmarkedFitOccuTTD'
detTime(object, plot.time = TRUE,
                   plot.seasons = FALSE, cex.axis = 1, cex.lab = 1,
                   cex.main = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detTime_+3A_object">object</code></td>
<td>

<p>an object of various <code>unmarkedFrame</code> or <code>unmarkedFit</code>
classes containing time to detection data. 
</p>
</td></tr>
<tr><td><code id="detTime_+3A_plot.time">plot.time</code></td>
<td>

<p>logical.  Specifies if the time to detection data (pooled across
seasons) should  be plotted.
</p>
</td></tr>
<tr><td><code id="detTime_+3A_plot.seasons">plot.seasons</code></td>
<td>

<p>logical.  Specifies if the time to detection data should be plotted
for each season separately.  This argument is only relevant
for data collected across more than a single season.
</p>
</td></tr>
<tr><td><code id="detTime_+3A_cex.axis">cex.axis</code></td>
<td>
<p>expansion factor influencing the size of axis
annotations on plots produced by the function.
</p>
</td></tr>
<tr><td><code id="detTime_+3A_cex.lab">cex.lab</code></td>
<td>
<p>expansion factor influencing the size of axis labels on
plots produced by the function.
</p>
</td></tr>
<tr><td><code id="detTime_+3A_cex.main">cex.main</code></td>
<td>
<p>expansion factor influencing the size of the main title
above plots produced by the function.
</p>
</td></tr>
<tr><td><code id="detTime_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a number of summary statistics in data sets
used for the time to detection models of Garrard et al. (2008,
2013).
</p>
<p><code>detTime</code> can take data frames of the <code>unmarkedFrameOccuTTD</code>
class as input, or can also extract the raw data from model objects of
the <code>unmarkedFitOccuTTD</code> class.  Note that different model
objects using the same data set will have identical values.
</p>


<h3>Value</h3>

<p><code>detTime</code> returns a list with the following components:
</p>
<table>
<tr><td><code>time.table.full</code></td>
<td>
<p>a table with the quantiles of time to
detection data pooled across seasons, but excluding censored
observations.</p>
</td></tr>
<tr><td><code>time.table.seasons</code></td>
<td>
<p>a list of tables with the quantiles of
season-specific time to detection data, but excluding censored
observations.</p>
</td></tr>
<tr><td><code>out.freqs</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the number of sites sampled in
season <code class="reqn">t</code> (<code>sampled</code>) and the number of sites with at
least one detection in season <code class="reqn">t</code> (<code>detected</code>).  For
multiseason data, the matrix includes the number of sites sampled in
season <code class="reqn">t - 1</code> with colonizations observed in season <code class="reqn">t</code>
(<code>colonized</code>), the number of sites sampled in season <code class="reqn">t -
    1</code> with extinctions observed in season <code class="reqn">t</code> (<code>extinct</code>), the
number of sites sampled in season <code class="reqn">t - 1</code> without changes
observed in season <code class="reqn">t</code> (<code>static</code>), and the number of sites
sampled in season <code class="reqn">t</code> that were also sampled in season <code class="reqn">t -
    1</code> (<code>common</code>).
</p>
</td></tr>
<tr><td><code>out.props</code></td>
<td>
<p>a matrix where the rows correspond to each sampling
season and where columns consist of the proportion of sites in
season <em>t</em> with at least one detection (<code>naive.occ</code>).  For
multiseason data, the matrix includes the proportion of sites
sampled in season <code class="reqn">t - 1</code> with colonizations observed in season
<code class="reqn">t</code> (<code>naive.colonization</code>), the proportion of sites
sampled in season <code class="reqn">t - 1</code> with extinctions observed in season
<code class="reqn">t</code> (<code>naive.extinction</code>), and the proportion of sites
sampled in season <code class="reqn">t - 1</code> with no changes observed in season
<code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code>n.seasons</code></td>
<td>
<p>the number of seasons (primary periods) in the data
set.
</p>
</td></tr>
<tr><td><code>n.visits.season</code></td>
<td>
<p>the maximum number of visits per season in the
data set.
</p>
</td></tr>
<tr><td><code>missing.seasons</code></td>
<td>
<p>logical vector indicating whether data were
collected or not during a given season (primary period), where
<code>TRUE</code> indicates that no data were collected during the season.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Garrard, G. E., Bekessy, S. A., McCarthy, M. A., Wintle, B. A. (2008)
When have we looked hard enough? A novel method for setting minimum
survey effort protocols for flora surveys. <em>Austral Ecology</em>
<b>33</b>, 986&ndash;998.
</p>
<p>Garrard, G. E., McCarthy, M. A., Williams, N. S., Bekessy, S. A.,
Wintle, B. A. (2013) A general model of detectability using species
traits. <em>Methods in Ecology and Evolution</em> <b>4</b>, 45&ndash;52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+countDist">countDist</a></code>, <code><a href="#topic+countHist">countHist</a></code>, <code><a href="#topic+detHist">detHist</a></code>,
<code><a href="#topic+Nmix.chisq">Nmix.chisq</a></code>, <code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##example from ?occuTTD
## Not run: 
if(require(unmarked)){
N &lt;- 500; J &lt;- 1
     
##Simulate occupancy
scovs &lt;- data.frame(elev=c(scale(runif(N, 0,100))),
                    forest=runif(N,0,1),
                    wind=runif(N,0,1))
     
beta_psi &lt;- c(-0.69, 0.71, -0.5)
psi &lt;- plogis(cbind(1, scovs$elev, scovs$forest) 
z &lt;- rbinom(N, 1, psi)
     
##Simulate detection
Tmax &lt;- 10 #Same survey length for all observations
beta_lam &lt;- c(-2, -0.2, 0.7)
rate &lt;- exp(cbind(1, scovs$elev, scovs$wind) 
ttd &lt;- rexp(N, rate)
ttd[z==0] &lt;- Tmax #Censor unoccupied sites
ttd[ttd&gt;Tmax] &lt;- Tmax #Censor when ttd was greater than survey length
     
##Build unmarkedFrame
umf &lt;- unmarkedFrameOccuTTD(y=ttd, surveyLength=Tmax, siteCovs=scovs)

##compute descriptive stats from data object
detTime(umf)
     
##Fit model
fit.occuTTD &lt;- occuTTD(psiformula=~elev+forest, detformula=~elev+wind, data=umf)
##extract info from model object
detTime(fit.occuTTD)     
     
}

## End(Not run)
</code></pre>

<hr>
<h2 id='DIC'>
Computing DIC
</h2><span id='topic+DIC'></span><span id='topic+DIC.default'></span><span id='topic+DIC.bugs'></span><span id='topic+DIC.rjags'></span><span id='topic+DIC.jagsUI'></span>

<h3>Description</h3>

<p>Functions to extract deviance information criterion (DIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(mod, return.pD = FALSE, ...) 

## S3 method for class 'bugs'
DIC(mod, return.pD = FALSE, ...)

## S3 method for class 'rjags'
DIC(mod, return.pD = FALSE, ...)

## S3 method for class 'jagsUI'
DIC(mod, return.pD = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_mod">mod</code></td>
<td>

<p>an object of class <code>bugs</code>, <code>rjags</code>, or <code>jagsUI</code>
containing the output of a model.
</p>
</td></tr>
<tr><td><code id="DIC_+3A_return.pd">return.pD</code></td>
<td>

<p>logical.  If <code>FALSE</code>, the function returns the DIC.  If
<code>TRUE</code>, the function returns the effective number of estimated
parameters (pD) for a given model.
</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DIC</code> is implemented for <code>bugs</code>, <code>rjags</code>, and
<code>jagsUI</code> classes.  The function extracts the deviance
information criterion (DIC, Spiegelhalter et al. 2002) or the
effective number of parameters (pD).
</p>


<h3>Value</h3>

<p><code>DIC</code> the DIC or pD depending on the values of the arguments.
</p>


<h3>Note</h3>

<p>The actual DIC values are not really interesting in themselves, as
they depend directly on the data, parameters estimated, and
likelihood function.  Furthermore, a single value does not tell much
about model fit.  Information criteria become relevant when compared to
Yone another for a given data set and set of candidate models.  Model
selection with hierarchical models is problematic as the classic DIC is
not appropriate for such types of models (Millar 2009).
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Millar, R. B. (2009) Comparison of hierarchical Bayesian models for
overdispersed count data using DIC and Bayes'
factors. <em>Biometrics</em>, <b>65</b>, 962&ndash;969.
</p>
<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P., van der Linde,
A. (2002). Bayesian measures of complexity and fit. <em>Journal of the
Royal Statistical Society, Series B</em> <b>64</b>, 583&ndash;639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICcCustom">AICcCustom</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+dictab">dictab</a></code>,
<code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##from ?jags example in R2jags package
## Not run: 
require(R2jags)
##example model file
model.file &lt;- system.file(package="R2jags", "model", "schools.txt")
file.show(model.file)     

##data
J &lt;- 8.0
y &lt;- c(28.4,7.9,-2.8,6.8,-0.6,0.6,18.0,12.2)
sd &lt;- c(14.9,10.2,16.3,11.0,9.4,11.4,10.4,17.6)
     
##arrange data in list     
jags.data &lt;- list (J = J, y = y, sd = sd)

##initial values
jags.inits &lt;- function(){
  list(theta=rnorm(J, 0, 100), mu=rnorm(1, 0, 100),
       sigma=runif(1, 0, 100))
}

##parameters to be monitored
jags.parameters &lt;- c("theta", "mu", "sigma")
     
##run model
schools.sim &lt;- jags(data = jags.data, inits = jags.inits,
                    parameters = jags.parameters,
                    model.file = model.file,
                    n.chains = 3, n.iter = 10)
##note that n.iter should be higher

##extract DIC
DIC(schools.sim)
##extract pD
DIC(schools.sim, return.pD = TRUE)
detach(package:R2jags)

## End(Not run)
</code></pre>

<hr>
<h2 id='dictab'>
Create Model Selection Tables from Bayesian Analyses
</h2><span id='topic+dictab'></span><span id='topic+dictab.default'></span><span id='topic+dictab.AICbugs'></span><span id='topic+dictab.AICrjags'></span><span id='topic+dictab.AICjagsUI'></span><span id='topic+print.dictab'></span>

<h3>Description</h3>

<p>This function creates a model selection table based on the deviance
information criterion (DIC).  The table ranks the models based on the
DIC and also provides delta DIC and DIC weights.  <code>dictab</code> selects
the appropriate function to create the model selection table based on
the object class.  The current version works with objects of <code>bugs</code>,
<code>rjags</code>, <code>jagsUI</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dictab(cand.set, modnames = NULL, sort = TRUE, ...)

## S3 method for class 'AICbugs'
dictab(cand.set, modnames = NULL, sort = TRUE, ...)

## S3 method for class 'AICrjags'
dictab(cand.set, modnames = NULL, sort = TRUE, ...)

## S3 method for class 'AICjagsUI'
dictab(cand.set, modnames = NULL, sort = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dictab_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="dictab_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="dictab_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the DIC values.
</p>
</td></tr>
<tr><td><code id="dictab_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dictab</code> internally creates a new class for the <code>cand.set</code>
list of candidate models, according to the contents of the list.  The
current function is implemented for <code>bugs</code>, <code>jags</code>,
<code>jagsUI</code> classes. The function constructs a model selection table
based on the DIC (Spiegelhalter et al. 2002).  Note that DIC might not
be appropriate to select among a set of hierarchical models and that
modifications to the information criterion have been proposed (Millar
2009).
</p>


<h3>Value</h3>

<p><code>dictab</code> creates an object of class <code>dictab</code> with the
following components:
</p>
<table>
<tr><td><code>Modname</code></td>
<td>
<p>the name of each model of the candidate model set.</p>
</td></tr>
<tr><td><code>pD</code></td>
<td>
<p>the effective number of estimated parameters for each
model.</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>the deviance information criterion for each model.</p>
</td></tr>
<tr><td><code>Delta_DIC</code></td>
<td>
<p>the delta DIC of each model, measuring the difference
in DIC between each model and the top-ranked model.</p>
</td></tr>
<tr><td><code>ModelLik</code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td></tr> 
<tr><td><code>DICWt</code></td>
<td>
<p>the DIC weights, sensu Burnham and Anderson (2002) and
Anderson (2008). These measures indicate the level of support (i.e.,
weight of evidence) in favor of any given model being the most
parsimonious among the candidate model set.</p>
</td></tr>
<tr><td><code>Cum.Wt</code></td>
<td>
<p>the cumulative DIC weights.  These are only meaningful
if results in table are sorted in decreasing order of DIC weights
(i.e., <code>sort = TRUE</code>).</p>
</td></tr>
<tr><td><code>Deviance</code></td>
<td>
<p>the deviance of each model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P., van der Linde,
A. (2002). Bayesian measures of complexity and fit. <em>Journal of the
Royal Statistical Society, Series B</em> <b>64</b>, 583&ndash;639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictabCustom">aictabCustom</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+confset">confset</a></code>,
<code><a href="#topic+DIC">DIC</a></code>, <code><a href="#topic+evidence">evidence</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##from ?jags example in R2jags package
## Not run: 
require(R2jags)
model.file &lt;- system.file(package="R2jags", "model", "schools.txt")
file.show(model.file)     

##data
J &lt;- 8.0
y &lt;- c(28.4,7.9,-2.8,6.8,-0.6,0.6,18.0,12.2)
sd &lt;- c(14.9,10.2,16.3,11.0,9.4,11.4,10.4,17.6)
     
     
jags.data &lt;- list (J = J, y = y, sd = sd)
jags.inits &lt;- function(){
  list(theta=rnorm(J, 0, 100), mu=rnorm(1, 0, 100),
       sigma=runif(1, 0, 100))
}
jags.parameters &lt;- c("theta", "mu", "sigma")
     
##run model
schools.sim &lt;- jags(data = jags.data, inits = jags.inits,
                    parameters = jags.parameters,
                    model.file = model.file,
                    n.chains = 3, n.iter = 10)
#note that n.iter should be higher

##set up in list
Cand.mods &lt;- list(schools.sim)
Model.names &lt;- "hierarchical model"
##other models can be added to Cand.mods
##to compare them to the top model

##model selection table
dictab(cand.set = Cand.mods, modnames = Model.names)
detach(package:R2jags)

## End(Not run)
</code></pre>

<hr>
<h2 id='dry.frog'>
Frog Dehydration Experiment on Three Substrate Types
</h2><span id='topic+dry.frog'></span>

<h3>Description</h3>

<p>This is a data set modified from Mazerolle and Desrochers (2005) on the
mass lost by frogs after spending two hours on one of three substrates
that are encountered in some landscape types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dry.frog)</code></pre>


<h3>Format</h3>

<p>A data frame with 121 observations on the following 16 variables.
</p>

<dl>
<dt><code>Individual</code></dt><dd><p>a numeric identifier unique to each
individual.</p>
</dd> 
<dt><code>Species</code></dt><dd><p>a factor with levels <code>Racla</code>.</p>
</dd>
<dt><code>Shade</code></dt><dd><p>a numeric vector, either 1 (shade) or 0 (no
shade).</p>
</dd> 
<dt><code>SVL</code></dt><dd><p>the snout-vent length of the individual.</p>
</dd>
<dt><code>Substrate</code></dt><dd><p>the substrate type, a factor with levels
<code>PEAT</code>, <code>SOIL</code>, and <code>SPHAGNUM</code>.</p>
</dd>
<dt><code>Initial_mass</code></dt><dd><p>the initial mass of individuals.</p>
</dd>
<dt><code>Mass_lost</code></dt><dd><p>the mass lost in g.</p>
</dd>
<dt><code>Airtemp</code></dt><dd><p>the air temperature in degrees C.</p>
</dd>
<dt><code>Wind_cat</code></dt><dd><p>the wind intensity, either 0 (no wind), 1
(low wind), 2 (moderate wind), or 3 (strong wind).</p>
</dd>
<dt><code>Cloud</code></dt><dd><p>cloud cover expressed as a percentage.</p>
</dd>
<dt><code>cent_Initial_mass</code></dt><dd><p>centered inital mass.</p>
</dd>
<dt><code>Initial_mass2</code></dt><dd><p>initial mass squared.</p>
</dd>
<dt><code>cent_Air</code></dt><dd><p>centered air temperature.</p>
</dd>
<dt><code>Perc.cloud</code></dt><dd><p>proportion of cloud cover</p>
</dd>
<dt><code>Wind</code></dt><dd><p>wind intensity, either 1 (no or low wind) or 1
(moderate to strong wind).</p>
</dd>
<dt><code>log_Mass_lost</code></dt><dd><p>log of mass lost.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Note that the original analysis in Mazerolle and Desrochers (2005)
consisted of generalized estimating equations for three mass
measurements:  mass at time 0, 1 hour, and 2 hours following exposure on
the substrate. 
</p>


<h3>Source</h3>

<p>Mazerolle, M. J., Desrochers, A. (2005) Landscape resistance to frog
movements. <em>Canadian Journal of Zoology</em> <b>83</b>, 455&ndash;464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dry.frog)
## maybe str(dry.frog) ; plot(dry.frog) ...
</code></pre>

<hr>
<h2 id='evidence'>
Compute Evidence Ratio Between Two Models
</h2><span id='topic+evidence'></span><span id='topic+print.evidence'></span>

<h3>Description</h3>

<p>This function compares two models of a candidate model set based on
their evidence ratio (i.e., ratio of model weights).  The default
computes the evidence ratio of the model weights between the top-ranked
model and the second-ranked model.  You must supply a model selection
table of class <code>aictab</code>, <code>bictab</code>, <code>boot.wt</code>,
<code>dictab</code>, <code>ictab</code> as the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evidence(aic.table, model.high = "top", model.low = "second.ranked")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evidence_+3A_aic.table">aic.table</code></td>
<td>

<p>a model selection table of class <code>aictab</code> such as that produced by 
<code>aictab</code> or of classes <code>bictab</code>, <code>boot.wt</code>,
<code>dictab</code>, or <code>ictab</code>.  The table may be sorted or not, as the
function sorts the table internally.
</p>
</td></tr>
<tr><td><code id="evidence_+3A_model.high">model.high</code></td>
<td>

<p>the top-ranked model (default), or alternatively, the name of another
model as it appears in the model selection table.
</p>
</td></tr>
<tr><td><code id="evidence_+3A_model.low">model.low</code></td>
<td>

<p>the second-ranked model (default), or alternatively, the name of a
lower-ranked model such as it appears in the model selection table.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default compares the model weights of the top-ranked model to
the second-ranked model in the candidate model set.  The evidence ratio
can be interpreted as the number of times a given model is more
parsimonious than a lower-ranked model.  If one desires an evidence
ratio that does not involve a comparison with the top-ranking model, the 
label of the required model must be specified in the <code>model.high</code>
argument as it appears in the model selection table.
</p>


<h3>Value</h3>

<p><code>evidence</code> produces an object of class <code>evidence</code> with the
following components:
</p>
<table>
<tr><td><code>Model.high</code></td>
<td>
  
<p>the model specified in <code>model.high</code>.
</p>
</td></tr>
<tr><td><code>Model.low</code></td>
<td>

<p>the model specified in <code>model.low</code>.
</p>
</td></tr>
<tr><td><code>Ev.ratio</code></td>
<td>

<p>the evidence ratio between the two models compared.    
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+bictab">bictab</a></code>,
<code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgShrink">modavgShrink</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##run example from Burnham and Anderson (2002, p. 183) with two
##non-nested models
data(pine)
Cand.set &lt;- list( )
Cand.set[[1]] &lt;- lm(y ~ x, data = pine)
Cand.set[[2]] &lt;- lm(y ~ z, data = pine)

##assign model names
Modnames &lt;- c("raw density", "density corrected for resin content")

##compute model selection table
aicctable.out &lt;- aictab(cand.set = Cand.set, modnames = Modnames)

##compute evidence ratio
evidence(aic.table = aicctable.out, model.low = "raw density")
evidence(aic.table = aicctable.out) #gives the same answer
##round to 4 digits after decimal point
print(evidence(aic.table = aicctable.out, model.low = "raw density"),
      digits = 4)


##example with bictab
## Not run: 
##compute model selection table
bictable.out &lt;- bictab(cand.set = Cand.set, modnames = Modnames)
##compute evidence ratio
evidence(bictable.out, model.low = "raw density")

## End(Not run)


##run models for the Orthodont data set in nlme package
## Not run: 
require(nlme)

##set up candidate model list
Cand.models &lt;- list()
Cand.models[[1]] &lt;- lme(distance ~ age, data = Orthodont, method = "ML")
##random is ~ age | Subject
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1, method = "ML")
Cand.models[[3]] &lt;- lme(distance ~ 1, data = Orthodont, random = ~ 1,
                        method = "ML")

##create a vector of model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = " ")

##compute AICc table
aic.table.1 &lt;- aictab(cand.set = Cand.models, modnames = Modnames,
                      second.ord = TRUE)

##compute evidence ratio between best model and second-ranked model
evidence(aic.table = aic.table.1)

##compute the same value but from an unsorted model selection table
evidence(aic.table = aictab(cand.set = Cand.models,
           modnames = Modnames, second.ord = TRUE, sort = FALSE))

##compute evidence ratio between second-best model and third-ranked
##model  
evidence(aic.table = aic.table.1, model.high = "mod1",
         model.low = "mod3")
detach(package:nlme)

## End(Not run)


</code></pre>

<hr>
<h2 id='extractCN'>
Compute Condition Number
</h2><span id='topic+extractCN'></span><span id='topic+extractCN.default'></span><span id='topic+extractCN.unmarkedFit'></span><span id='topic+print.extractCN'></span>

<h3>Description</h3>

<p>This function computes the condition number for models of
<code>unmarkedFit</code> classes as the ratio of the largest eigenvalue of the
Hessian matrix to the smallest eigenvalue of the Hessian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCN(mod, method = "svd", ...)

## S3 method for class 'unmarkedFit'
extractCN(mod, method = "svd", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractCN_+3A_mod">mod</code></td>
<td>

<p>a model of one the <code>unmarkedFit</code> classes for which a condition
number is requested.
</p>
</td></tr>
<tr><td><code id="extractCN_+3A_method">method</code></td>
<td>

<p>specifies the method used to extract the singular values or
eigenvalues from the Hessian matrix using singular value decomposition
(<code>method = "svd"</code>) or eigenvalue decomposition
(<code>method = "eigen"</code>).
</p>
</td></tr>
<tr><td><code id="extractCN_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The condition number (<code class="reqn">\kappa</code>) is a measure of the transfer of
error to the solution in response to small changes in the input (Cheney
and Kincaid 2008).  In this implementation, the condition number is
computed on the Hessian matrix of models of <code>unmarkedFit</code> classes
from the <code>optim</code> results stored in the model object.  The condition
number is defined as the ratio of the largest to the smallest
non-negative singular values of a given matrix (Cline et al. 1979, Dixon
1983).  In the special case of positive semi-definite matrices, the
singular values are equal to the eigenvalues (Ruhe 1975). 
</p>
<p>Large values of the condition number may indicate problems in estimating
parameters or their variance (ill-conditioning), possibly due to a model
having too many parameters for the given data set.  Cheney and Ward
(2008) suggest using the <code class="reqn">\log_{10}(\kappa)</code> of the condition number as
a crude estimate of the number of digits of precision lost.
</p>


<h3>Value</h3>

<p><code>extractCN</code> returns a list of class <code>extractCN</code> with the
following components:
</p>
<table>
<tr><td><code>CN</code></td>
<td>
<p>the condition number (<code class="reqn">\kappa</code>) of the model.
</p>
</td></tr>
<tr><td><code>log10</code></td>
<td>
<p>the log base 10 of the condition number.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used to extract the singular values or eigenvalues.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Cheney, W., Kincaid, D. (2008) <em>Numerical mathematics and
computing</em>. Sixth edition. Thomson Brooks/Cole: Belmont.
</p>
<p>Cline, A. K., Moler, C. B., Stewart, G. W., Wilkinson, J. H. (1979) An
estimate for the condition number of a matrix. <em>SIAM Journal on
Numerical Analysis</em> <b>16</b>, 368&ndash;375.
</p>
<p>Dixon, J. D. (1983) Estimating extremal eigenvalues and condition
numbers of matrices. <em>SIAM Journal on Numerical Analysis</em>
<b>20</b>, 812&ndash;814. 
</p>
<p>Ruhe, A. (1975) On the closeness of eigenvalues and singular values for
almost normal matrices. <em>Linear Algebra and its Applications</em>
<b>11</b>, 87&ndash;94. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+mb.gof.test">mb.gof.test</a></code>,
<code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>, <code><a href="unmarked.html#topic+parboot">parboot</a></code>,
<code><a href="base.html#topic+kappa">kappa</a></code>, <code><a href="Matrix.html#topic+rcond">rcond</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##N-mixture model example modified from ?pcount
## Not run: 
require(unmarked)
##single season
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##run model
fm.mallard &lt;- pcount(~ ivel+ date + I(date^2) ~ length + elev + forest,
                     mallardUMF, K=30)

##compute condition number
extractCN(fm.mallard)

##compare against 'kappa'
kappa(fm.mallard@opt$hessian, exact = TRUE)
detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='extractLL'>
Extract Log-Likelihood of Model
</h2><span id='topic+extractLL'></span><span id='topic+extractLL.default'></span><span id='topic+extractLL.coxph'></span><span id='topic+extractLL.coxme'></span><span id='topic+extractLL.lmekin'></span><span id='topic+extractLL.maxlikeFit'></span><span id='topic+extractLL.unmarkedFit'></span><span id='topic+extractLL.vglm'></span>

<h3>Description</h3>

<p>This function extracts the log-likelihood from an object of <code>coxme</code>,
<code>coxph</code>, <code>lmekin</code>, <code>maxlikeFit</code>, <code>vglm</code>, or various
<code>unmarkedFit</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractLL(mod, ...)

## S3 method for class 'coxme'
extractLL(mod, type = "Integrated", ...)

## S3 method for class 'coxph'
extractLL(mod, ...)

## S3 method for class 'lmekin'
extractLL(mod, ...)

## S3 method for class 'maxlikeFit'
extractLL(mod, ...)

## S3 method for class 'unmarkedFit'
extractLL(mod, ...)

## S3 method for class 'vglm'
extractLL(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractLL_+3A_mod">mod</code></td>
<td>

<p>an object of <code>coxme</code>, <code>coxph</code>, <code>lmekin</code>,
<code>maxlikeFit</code>, <code>vglm</code>, or <code>unmarkedFit</code> class resulting
from the fit of <code>distsamp</code>, <code>gdistsamp</code>, <code>gmultmix</code>,
<code>multinomPois</code>, <code>gpcount</code>, <code>occu</code>, <code>occuRN</code>,
<code>colext</code>, <code>pcount</code>, or <code>pcountOpen</code>.</p>
</td></tr> 
<tr><td><code id="extractLL_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the function.</p>
</td></tr>
<tr><td><code id="extractLL_+3A_type">type</code></td>
<td>

<p>a character string indicating whether the integrated partial
likelihood (&quot;Integrated&quot;) or penalized likelihood (&quot;Penalized&quot;) is to
be used for a <code>coxme</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility function extracts the information from a <code>coxme</code>,
<code>coxph</code>, <code>lmekin</code>, <code>maxlikeFit</code>, <code>vglm</code>, or
<code>unmarkedFit</code> object resulting from <code>distsamp</code>,
<code>gdistsamp</code>, <code>gmultmix</code>, <code>multinomPois</code>,
<code>gpcount</code>, <code>occu</code>, <code>occuRN</code>, <code>colext</code>,
<code>pcount</code>, or <code>pcountOpen</code>. 
</p>


<h3>Value</h3>

<p>These functions return the value of the log-likelihood of the model
and associated degrees of freedom.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="coxme.html#topic+coxme">coxme</a></code>,
<code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="coxme.html#topic+lmekin">lmekin</a></code>,
<code><a href="maxlike.html#topic+maxlike">maxlike</a></code>, <code><a href="unmarked.html#topic+distsamp">distsamp</a></code>,
<code><a href="unmarked.html#topic+gdistsamp">gdistsamp</a></code>, <code><a href="unmarked.html#topic+occu">occu</a></code>,
<code><a href="unmarked.html#topic+occuRN">occuRN</a></code>, <code><a href="unmarked.html#topic+colext">colext</a></code>,
<code><a href="unmarked.html#topic+pcount">pcount</a></code>, <code><a href="unmarked.html#topic+pcountOpen">pcountOpen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##single-season occupancy model example modified from ?occu
## Not run: 
require(unmarked)
##single season
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
## add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)),
                                sitevar2 = rnorm(numSites(pferUMF))) 
     
## observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) *
                                 obsNum(pferUMF))) 

##run model set
fm1 &lt;- occu(~ obsvar1 ~ sitevar1, pferUMF)

##extract log-likelihood
extractLL(fm1)
detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='extractSE'>
Extract SE of Fixed Effects
</h2><span id='topic+extractSE'></span><span id='topic+extractSE.default'></span><span id='topic+extractSE.coxme'></span><span id='topic+extractSE.lmekin'></span><span id='topic+extractSE.mer'></span><span id='topic+extractSE.merMod'></span><span id='topic+extractSE.lmerModLmerTest'></span>

<h3>Description</h3>

<p>This function extracts the standard errors (SE) of the fixed effects of
a mixed model fit with <code>coxme</code>, <code>glmer</code>, <code>lmer</code>,
<code>lmerModLmerTest</code>, and <code>lmekin</code> and adds the appropriate labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
extractSE(mod, ...)

## S3 method for class 'coxme'
extractSE(mod, ...)

## S3 method for class 'lmekin'
extractSE(mod, ...)

## S3 method for class 'mer'
extractSE(mod, ...)

## S3 method for class 'merMod'
extractSE(mod, ...)

## S3 method for class 'lmerModLmerTest'
extractSE(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractSE_+3A_mod">mod</code></td>
<td>

<p>an object of <code>coxme</code>, <code>lmekin</code>, <code>mer</code>, <code>merMod</code>,
or <code>lmerModTest</code> class.
</p>
</td></tr>
<tr><td><code id="extractSE_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These extractor functions use <code>vcov.coxme</code>, <code>vcov.lmekin</code>,
<code>vcov.mer</code>, and <code>vcov.merMod</code>. Some of these functions are
called by <code>modavg</code> and <code>modavgShrink</code>, depending on the
class of the objects. 
</p>


<h3>Value</h3>

<p>Returns the SE's of the fixed effects with the appropriate labels for each.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modavg">modavg</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code>,
<code><a href="lme4.html#topic+lmer">lmer</a></code>, <code><a href="coxme.html#topic+coxme">coxme</a></code>,
<code><a href="coxme.html#topic+lmekin">lmekin</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##modified example from ?glmer
## Not run: 
if(require(lme4)) {
##create proportion of incidence
cbpp$prop &lt;- cbpp$incidence/cbpp$size
gm1 &lt;- glmer(prop ~ period + (1 | herd), family = binomial,
             weights = size, data = cbpp)
##print summary
summary(gm1)
##extract variance-covariance matrix of fixed effects
vcov(gm1)
##extract SE's of fixed effects - no labels
sqrt(diag(vcov(gm1))) #no labels
extractSE(gm1)  #with labels
detach(package:lme4)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='extractX'>
Extract Predictors from Candidate Model List
</h2><span id='topic+extractX'></span><span id='topic+extractX.default'></span><span id='topic+extractX.AICaov.lm'></span><span id='topic+extractX.AICglm.lm'></span><span id='topic+extractX.AICglmmTMB'></span><span id='topic+extractX.AICgls'></span><span id='topic+extractX.AIClm'></span><span id='topic+extractX.AIClme'></span><span id='topic+extractX.AICglmerMod'></span><span id='topic+extractX.AIClmerMod'></span><span id='topic+extractX.AIClmerModLmerTest'></span><span id='topic+extractX.AICrlm.lm'></span><span id='topic+extractX.AICsurvreg'></span><span id='topic+extractX.AICunmarkedFitOccu'></span><span id='topic+extractX.AICunmarkedFitColExt'></span><span id='topic+extractX.AICunmarkedFitOccuRN'></span><span id='topic+extractX.AICunmarkedFitPCount'></span><span id='topic+extractX.AICunmarkedFitPCO'></span><span id='topic+extractX.AICunmarkedFitDS'></span><span id='topic+extractX.AICunmarkedFitGDS'></span><span id='topic+extractX.AICunmarkedFitOccuFP'></span><span id='topic+extractX.AICunmarkedFitMPois'></span><span id='topic+extractX.AICunmarkedFitGMM'></span><span id='topic+extractX.AICunmarkedFitGPC'></span><span id='topic+extractX.AICunmarkedFitOccuMulti'></span><span id='topic+extractX.AICunmarkedFitOccuMS'></span><span id='topic+extractX.AICunmarkedFitOccuTTD'></span><span id='topic+extractX.AICunmarkedFitMMO'></span><span id='topic+extractX.AICunmarkedFitDSO'></span><span id='topic+print.extractX'></span>

<h3>Description</h3>

<p>This function extracts the predictors used in candidate models.  The
function is currently implemented for <code>glm</code>, <code>glmmTMB</code>,
<code>gls</code>, <code>lm</code>, <code>lme</code>, <code>merMod</code>,
<code>lmerModLmerTest</code>, <code>rlm</code>, <code>survreg</code> object classes that
are stored in a list as well as various models of <code>unmarkedFit</code>
classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractX(cand.set, ...)

## S3 method for class 'AICaov.lm'
extractX(cand.set, ...) 

## S3 method for class 'AICglm.lm'
extractX(cand.set, ...)

## S3 method for class 'AICglmmTMB'
extractX(cand.set, ...)

## S3 method for class 'AIClm'
extractX(cand.set, ...) 

## S3 method for class 'AICgls'
extractX(cand.set, ...) 

## S3 method for class 'AIClme'
extractX(cand.set, ...)

## S3 method for class 'AICglmerMod'
extractX(cand.set, ...)

## S3 method for class 'AIClmerMod'
extractX(cand.set, ...)

## S3 method for class 'AIClmerModLmerTest'
extractX(cand.set, ...)

## S3 method for class 'AICrlm.lm'
extractX(cand.set, ...) 

## S3 method for class 'AICsurvreg'
extractX(cand.set, ...) 

## S3 method for class 'AICunmarkedFitOccu'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
extractX(cand.set,
        parm.type = NULL, ...)  

## S3 method for class 'AICunmarkedFitOccuRN'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
extractX(cand.set,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitPCO'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
extractX(cand.set,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitGDS'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
extractX(cand.set,
        parm.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractX_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="extractX_+3A_parm.type">parm.type</code></td>
<td>
<p>this argument specifies the parameter type on which
the predictors will be extracted and is only relevant for models of
<code>unmarkedFit</code> classes.  The character strings supported
vary with the type of model fitted.  For <code>unmarkedFitOccu</code> and
<code>unmarkedFitOccuMulti</code> objects, either <code>psi</code> or
<code>detect</code> can be supplied to indicate whether the parameter is
on occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> and <code>unmarkedFitOccuTTD</code>, possible
values  are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and detectability, respectively.  For
<code>unmarkedFitOccuFP</code> objects, one can specify <code>psi</code>,
<code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for occupancy,
detectability, probability of assigning false-positives, and
probability detections are certain, respectively.  For
<code>unmarkedFitOccuMS</code> objects, possible values are <code>psi</code>,
<code>phi</code>, or <code>detect</code>, denoting occupancy, transition, and
detection probabilities, respectively.  For <code>unmarkedFitOccuRN</code>
objects, either <code>lambda</code> or <code>detect</code> can be entered for
abundance and detectability parameters, respectively.  For
<code>unmarkedFitPCount</code> and <code>unmarkedFitMPois</code> objects,
<code>lambda</code> or <code>detect</code> denote parameters on abundance and
detectability, respectively.  For <code>unmarkedFitPCO</code>,
<code>unmarkedFitMMO</code>, and <code>unmarkedFitDSO</code> objects, one can
enter <code>lambda</code>, <code>gamma</code>, <code>omega</code>, <code>iota</code>, or
<code>detect</code>, to specify parameters on abundance, recruitment,
apparent survival, immigration, and detectability, respectively.
For <code>unmarkedFitDS</code> objects, <code>lambda</code> and <code>detect</code>
are supported.  For <code>unmarkedFitGDS</code>, <code>lambda</code>,
<code>phi</code>, and <code>detect</code> denote abundance, availability, and
detection probability, respectively.  For <code>unmarkedFitGMM</code> and
<code>unmarkedFitGPC</code> objects, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detectability,
respectively. 
</p>
</td></tr>
<tr><td><code id="extractX_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The candidate models must be stored in a list.  The results of
<code>extractX</code> are useful in preparing a <code>newdata</code>
data frame to use in computing model-averaged predictions with
<code>modavgPred</code> or differences between groups with
<code>modavgEffect</code> (Burnham and Anderson 2002, Anderson 2008, Burnham
et al. 2011).
</p>


<h3>Value</h3>

<p><code>extractX</code> returns an object of class <code>extractX</code> with the 
following components:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>

<p>a character vector of the names of the predictors included in the
model, excluding the intercept term. 
</p>
</td></tr>
<tr><td><code>data</code></td>
<td>

<p>a data frame or, in the case of <code>unmarkedFit</code> objects, a list of
data frames (e.g., obsCovs, siteCovs, yearlySiteCovs).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.  
</p>
<p>Burnham, K. P., Anderson, D. R., Huyvaert, K. P. (2011) AIC model
selection and multimodel inference in behaviorial ecology: some
background, observations and comparisons. <em>Behavioral Ecology and 
Sociobiology</em> <b>65</b>, 23&ndash;25.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180.
</p>
<p>Pinheiro, J. C., Bates, D. M. (2000). <em>Mixed-effects Models in S and
S-PLUS</em>. Springer Verlag: New York.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extractCN">extractCN</a></code>, <code><a href="#topic+extractSE">extractSE</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>,
<code><a href="#topic+modavgEffect">modavgEffect</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>,
<code><a href="#topic+predictSE">predictSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##example from subset of models in Table 1 in Mazerolle (2006)
data(dry.frog)

Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                           cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                           cent_Initial_mass + Initial_mass2 +
                           Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
##assign names
names(Cand.models) &lt;- paste(1:length(Cand.models))

##extract predictors from candidate model set
orig.data &lt;- extractX(cand.set = Cand.models)
orig.data
str(orig.data)

## Not run: 
##model-averaged prediction with original variables
modavgPred(Cand.models, newdata = orig.data$data)

## End(Not run)


##example of model-averaged predictions from N-mixture model (e.g., Royle 2004)
##modified from ?pcount
##each variable appears twice on lambda in the models
## Not run: 
require(unmarked)    
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##set up models so that each variable on abundance appears twice
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF,
                      K = 30)
fm.mall.two &lt;- pcount(~ ivel + date  ~ elev + forest, mallardUMF,
                      K = 30)
fm.mall.three &lt;- pcount(~ ivel + date  ~ length + elev, mallardUMF,
                        K = 30)
fm.mall.four &lt;- pcount(~ ivel + date  ~ 1, mallardUMF, K = 30)

##model list
Cands &lt;- list(fm.mall.one, fm.mall.two, fm.mall.three, fm.mall.four)
names(Cands) &lt;- c("length + forest", "elev + forest", "length + elev",
                  "null")

##extract predictors on lambda
lam.dat &lt;- extractX(cand.set = Cands, parm.type = "lambda")
lam.dat
str(lam.dat)

##extract predictors on detectability
extractX(cand.set = Cands, parm.type = "detect")

##model-averaged predictions on lambda
##extract data
siteCovs &lt;- lam.dat$data$siteCovs
##create vector of forest values
forest &lt;- seq(min(siteCovs$forest),
              max(siteCovs$forest),
              length.out = 40)
dframe &lt;- data.frame(forest = forest,
                     length = mean(siteCovs$length),
                     elev = mean(siteCovs$elev))
modavgPred(Cands, parm.type = "lambda",
           newdata = dframe)
detach(package:unmarked)

## End(Not run)


##example of model-averaged abundance from distance model
## Not run: 
require(unmarked)
data(linetran) #example from ?distsamp
     
ltUMF &lt;- with(linetran, {
  unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
                  siteCovs = data.frame(Length, area, habitat),
                  dist.breaks = c(0, 5, 10, 15, 20),
                  tlength = linetran$Length * 1000, survey = "line",
                  unitsIn = "m")
})
     
## Half-normal detection function. Density output (log scale). No covariates.
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
     
## Halfnormal. Covariates affecting both density and and detection.
fm2 &lt;- distsamp(~area + habitat ~ habitat, ltUMF)

## Hazard function. Covariates affecting both density and and detection.
fm3 &lt;- distsamp(~area + habitat ~ habitat, ltUMF, keyfun="hazard")

##assemble model list
Cands &lt;- list(fm1, fm2, fm3)

##model-average predictions on abundance
extractX(cand.set = Cands, parm.type = "lambda")
detach(package:unmarked)

## End(Not run)



##example using Orthodont data set from Pinheiro and Bates (2000)
## Not run: 
require(nlme)

##set up candidate models
m1 &lt;- gls(distance ~ age, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

m2 &lt;- gls(distance ~ 1, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

##assemble in list
Cand.models &lt;- list("age effect" = m1, "null model" = m2)

##model-averaged predictions
extractX(cand.set = Cand.models)
detach(package:nlme)

## End(Not run)
</code></pre>

<hr>
<h2 id='fam.link.mer'>
Extract Distribution Family and Link Function
</h2><span id='topic+fam.link.mer'></span>

<h3>Description</h3>

<p>This function extracts the distribution family and link function of a
generalized linear mixed model fit with <code>glmer</code> or <code>lmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam.link.mer(mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fam.link.mer_+3A_mod">mod</code></td>
<td>

<p>an object of <code>mer</code> or <code>merMod</code> class resulting from the
fit of <code>glmer</code> or <code>lmer</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility function extracts the information from an <code>mer</code> or
<code>merMod</code> object resulting from <code>glmer</code> or <code>lmer</code>.  The
function is called by <code>modavg</code>,  <code>modavgEffect</code>,
<code>modavgPred</code>, and <code>predictSE</code>.
</p>


<h3>Value</h3>

<p><code>fam.link.mer</code> returns a list with the following components:
</p>
<table>
<tr><td><code>family</code></td>
<td>
<p>the family of the distribution of the model.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function of the model.</p>
</td></tr>
<tr><td><code>supp.link</code></td>
<td>
<p>a character value indicating whether the link
function used is supported by <code>predictSE</code> and
<code>modavgPred</code>. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code>,
<code><a href="#topic+predictSE">predictSE</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##modified example from ?glmer
## Not run: 
if(require(lme4)){
##create proportion of incidence
cbpp$prop &lt;- cbpp$incidence/cbpp$size
gm1 &lt;- glmer(prop ~ period + (1 | herd), family = binomial,
             weights = size, data = cbpp)
fam.link.mer(gm1)
gm2 &lt;- glmer(prop ~ period + (1 | herd),
             family = binomial(link = "cloglog"), weights = size,
             data = cbpp)
fam.link.mer(gm2)
}

## End(Not run)


##example with linear mixed model with Orthodont data from
##Pinheiro and Bates (2000)
## Not run: 
data(Orthodont, package = "nlme")
m1 &lt;- lmer(distance ~ Sex + (1 | Subject), data = Orthodont,
           REML = FALSE)
fam.link.mer(m1)
m2 &lt;- glmer(distance ~ Sex + (1 | Subject),
            family = gaussian(link = "log"), data = Orthodont,
            REML = FALSE)
fam.link.mer(m2)
detach(package:lme4)

## End(Not run)
</code></pre>

<hr>
<h2 id='fat'>
Fat Data and Body Measurements
</h2><span id='topic+fat'></span>

<h3>Description</h3>

<p>This data set illustrates the relationship between body measurements and
body fat in 252 males aged between 21 and 81 years. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fat)</code></pre>


<h3>Format</h3>

<p>A data frame with 252 rows and 26 variables.
</p>

<dl>
<dt><code>Obs</code></dt><dd><p>observation number.</p>
</dd>
<dt><code>Perc.body.fat.Brozek</code></dt><dd><p>percent body fat using Brozek's
equation, i.e., <code class="reqn">457/Density - 414.2</code>.</p>
</dd>
<dt><code>Perc.body.fat.Siri</code></dt><dd><p>percent body fat using Siri's
equation, i.e., <code class="reqn">495/Density - 450</code>.</p>
</dd>
<dt><code>Density</code></dt><dd><p>density (<code class="reqn">\frac{g}{cm^3}</code>).</p>
</dd>
<dt><code>Age</code></dt><dd><p>age (years).</p>
</dd>
<dt><code>Weight</code></dt><dd><p>weight (lbs).</p>
</dd>
<dt><code>Height</code></dt><dd><p>height (inches).</p>
</dd>
<dt><code>Adiposity.index</code></dt><dd><p>adiposity index computed as <code class="reqn">Weight/Height^2</code> (<code class="reqn">\frac{kg}{m^2}</code>).</p>
</dd>
<dt><code>Fat.free.weight</code></dt><dd><p>fat free weight computed as <code class="reqn">(1 -
	Brozek's percent body fat) * Weight</code> (lbs).</p>
</dd>
<dt><code>Neck.circ</code></dt><dd><p>neck circumference (cm).</p>
</dd>
<dt><code>Chest.circ</code></dt><dd><p>chest circumference (cm).</p>
</dd>
<dt><code>Abdomen.circ</code></dt><dd><p>abdomen circumference (cm) measured at
the umbilicus and level with the iliac crest.</p>
</dd> 
<dt><code>Hip.circ</code></dt><dd><p>hip circumference (cm).</p>
</dd>
<dt><code>Thigh.circ</code></dt><dd><p>thigh circumference (cm).</p>
</dd>
<dt><code>Knee.circ</code></dt><dd><p>knee circumference (cm).</p>
</dd>
<dt><code>Ankle.circ</code></dt><dd><p>ankle circumference (cm).</p>
</dd>
<dt><code>Biceps.circ</code></dt><dd><p>extended biceps circumference (cm).</p>
</dd>
<dt><code>Forearm.circ</code></dt><dd><p>forearm circumference (cm).</p>
</dd>
<dt><code>Wrist.circ</code></dt><dd><p>wrist circumference (cm).</p>
</dd>
<dt><code>inv.Density</code></dt><dd><p>inverse of density (<code class="reqn">\frac{cm^3}{g}</code>).</p>
</dd>
<dt><code>z1</code></dt><dd><p>log of weight divided by log of height (allometric measure).</p>
</dd>
<dt><code>z2</code></dt><dd><p>abdomen circumference divided by chest
circumference (beer gut factor).</p>
</dd>
<dt><code>z3</code></dt><dd><p>index based on knee, wrist, and ankle circumference
relative to height (<code class="reqn">\frac{(Knee.circ * Wrist.circ * Ankle.circ)^(1/3)}{Height}</code>).</p>
</dd>
<dt><code>z4</code></dt><dd><p>fleshiness index based on biceps, thigh, forearm,
knee, wrist, and ankle circumference (<code class="reqn">\frac{Biceps.circ *
	Thigh.circ * Forearm.circ}{Knee.circ * Wrist.circ *
	Ankle.circ}</code>).</p>
</dd>
<dt><code>z5</code></dt><dd><p>age standardized to zero mean and unit variance.</p>
</dd>
<dt><code>z6</code></dt><dd><p>square of standardized age.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Burnham and Anderson (2002, p. 268) use this data set to show model
selection uncertainty in the context of all possible combinations of
explanatory variables.  The data are originally from Penrose et
al. (1985) who used only the first 143 cases of the 252 observations in
the data set.  Johnson (1996) later used these data as an example of
multiple regression.  Note that observation number 42 originally had an
erroneous height of 29.5 inches and that this value was changed to 69.5
inches.
</p>
<p>Burnham and Anderson (2002, p. 274) created six indices based on the
original measurements (i.e., z1 &ndash; z6).  Although Burnham and Anderson
(2002) indicate that the fleshiness index (<code>z4</code>) involved the cubic
root in the equation, the result table for the full model on p. 276
suggests that the index did not include the cubic root for <code>z4</code>.
The latter is the version of <code>z4</code> used in the data set here.
</p>


<h3>Source</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Johnson, J. W. (1996). Fitting percentage of body fat to simple body
measurements. <em>Journal of Statistics Education</em> <b>4</b> [online].
</p>
<p>Penrose, K., Nelson, A., Fisher, A. (1985) Generalized body composition
prediction equation for men using simple measurement techniques
<em>Medicine and Science in Sports and Exercise</em> <b>17</b>, 189.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fat)
str(fat)
</code></pre>

<hr>
<h2 id='gpa'>
GPA Data and Standardized Test Scores
</h2><span id='topic+gpa'></span>

<h3>Description</h3>

<p>This data set features the first-year college GPA and four standardized
tests conducted before matriculation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gpa)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 5 variables.
</p>

<dl>
<dt><code>gpa.y</code></dt><dd><p>first-year GPA.</p>
</dd>
<dt><code>sat.math.x1</code></dt><dd><p>SAT math score.</p>
</dd> 
<dt><code>sat.verb.x2</code></dt><dd><p>SAT verbal score.</p>
</dd>
<dt><code>hs.math.x3</code></dt><dd><p>high school math score.</p>
</dd>
<dt><code>hs.engl.x4</code></dt><dd><p>high school English score.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Burnham and Anderson (2002, p. 225) use this data set originally from
Graybill and Iyer (1994) to show model selection for all subsets
regression.
</p>


<h3>Source</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Graybill, F. A., Iyer, H. K. (1994) <em>Regression analysis: concepts
and applications.</em> Duxbury Press: Belmont.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gpa)
str(gpa)
</code></pre>

<hr>
<h2 id='ictab'>
Create Model Selection Tables from User-supplied Information
Criterion
</h2><span id='topic+ictab'></span><span id='topic+print.ictab'></span>

<h3>Description</h3>

<p>This function creates a model selection table from information
criterion values supplied by the user.  The table ranks the models
based on the values of the information criterion and also displays
delta values and information criterion weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ictab(ic, K, modnames = NULL, sort = TRUE, ic.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ictab_+3A_ic">ic</code></td>
<td>

<p>a vector of information criterion values for each model in the candidate
model set.
</p>
</td></tr>
<tr><td><code id="ictab_+3A_k">K</code></td>
<td>

<p>a vector containing the number of estimated parameters for each
model in the candidate model set.
</p>
</td></tr>
<tr><td><code id="ictab_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to identify each model in the
model selection table.  If <code>NULL</code>, generic names (e.g.,
<code>Mod1</code>, <code>Mod2</code>) are supplied in the table in the same
order as the information criterion values.
</p>
</td></tr>
<tr><td><code id="ictab_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the values of the information criterion.
</p>
</td></tr>
<tr><td><code id="ictab_+3A_ic.name">ic.name</code></td>
<td>

<p>a character string denoting the name of the information criterion
input by the user.  This character string will appear in certain
column labels of the model selection table.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ictab</code> constructs a model selection table based on the
information criterion values supplied by the user.  This function is
most useful for information criterion other than AIC, AICc, QAIC, and
QAICc (e.g., WAIC: Watanabe 2010) or for classes not supported by
<code>aictab</code> or <code>bictab</code>. 
</p>


<h3>Value</h3>

<p><code>ictab</code> creates an object of class <code>ictab</code> with the
following components:
</p>
<table>
<tr><td><code>Modname</code></td>
<td>
<p>the name of each model of the candidate model set.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of estimated parameters for each model.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>the values of the information criterion input by the
user.  If a value for <code>ic.name</code> is provided, the table modifies
the labels of the table.</p>
</td></tr>
<tr><td><code>Delta_IC</code></td>
<td>
<p>the delta information criterion component comparing
each model to the top-ranked model.</p>
</td></tr>
<tr><td><code>ModelLik</code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td></tr> 
<tr><td><code>ICWt</code></td>
<td>
<p>the information criterion weights, also termed &quot;model
probabilities&quot; sensu Burnham and Anderson (2002) and Anderson (2008).
These measures indicate the level of support (i.e., weight of
evidence) in favor of any given model being the most parsimonious
among the candidate model set.</p>
</td></tr>
<tr><td><code>Cum.Wt</code></td>
<td>
<p>the cumulative information criterion weights.  These
are only meaningful if results in table are sorted in decreasing
order of Akaike weights (i.e., <code>sort = TRUE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Watanabe, S. (2010) Asymptotic equivalence of Bayes cross validation and
widely applicable information criterion in singular learning
theory. <em>Journal of Machine Learning Research</em> <b>11</b>,
3571&ndash;3594. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictabCustom">aictabCustom</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+modavgCustom">modavgCustom</a></code>, <code><a href="#topic+modavgIC">modavgIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##create a vector of names to trace back models in set
Modnames &lt;- c("global model", "interactive model",
              "additive model", "invertpred model")

##WAIC values
waic &lt;- c(105.74, 107.36, 108.24, 100.57)
##number of effective parameters
effK &lt;- c(7.45, 5.61, 6.14, 6.05)

##generate WAIC table
ictab(ic = waic, K = effK, modnames = Modnames,
      sort = TRUE, ic.name = "WAIC")  
</code></pre>

<hr>
<h2 id='importance'>
Compute Importance Values of Variable
</h2><span id='topic+importance'></span><span id='topic+importance.default'></span><span id='topic+importance.AICaov.lm'></span><span id='topic+importance.AICbetareg'></span><span id='topic+importance.AICsclm.clm'></span><span id='topic+importance.AICclmm'></span><span id='topic+importance.AICclm'></span><span id='topic+importance.AICclogit.coxph'></span><span id='topic+importance.AICcoxme'></span><span id='topic+importance.AICcoxph'></span><span id='topic+importance.AICglm.lm'></span><span id='topic+importance.AICglmmTMB'></span><span id='topic+importance.AICglmerMod'></span><span id='topic+importance.AIClmerModLmerTest'></span><span id='topic+importance.AICgls'></span><span id='topic+importance.AIChurdle'></span><span id='topic+importance.AIClm'></span><span id='topic+importance.AIClme'></span><span id='topic+importance.AIClmekin'></span><span id='topic+importance.AICmaxlikeFit.list'></span><span id='topic+importance.AICmer'></span><span id='topic+importance.AICmultinom.nnet'></span><span id='topic+importance.AICnegbin.glm.lm'></span><span id='topic+importance.AICnlmerMod'></span><span id='topic+importance.AICpolr'></span><span id='topic+importance.AICrlm.lm'></span><span id='topic+importance.AICsurvreg'></span><span id='topic+importance.AICunmarkedFitColExt'></span><span id='topic+importance.AICunmarkedFitOccu'></span><span id='topic+importance.AICunmarkedFitOccuFP'></span><span id='topic+importance.AICunmarkedFitOccuRN'></span><span id='topic+importance.AICunmarkedFitPCount'></span><span id='topic+importance.AICunmarkedFitPCO'></span><span id='topic+importance.AICunmarkedFitDS'></span><span id='topic+importance.AICunmarkedFitGDS'></span><span id='topic+importance.AICunmarkedFitMPois'></span><span id='topic+importance.AICunmarkedFitGMM'></span><span id='topic+importance.AICunmarkedFitGPC'></span><span id='topic+importance.AICunmarkedFitOccuMulti'></span><span id='topic+importance.AICunmarkedFitOccuMS'></span><span id='topic+importance.AICunmarkedFitOccuTTD'></span><span id='topic+importance.AICunmarkedFitMMO'></span><span id='topic+importance.AICunmarkedFitDSO'></span><span id='topic+importance.AICvglm'></span><span id='topic+importance.AICzeroinfl'></span><span id='topic+print.importance'></span>

<h3>Description</h3>

<p>This function calculates the relative importance of variables (w+) based
on the sum of Akaike weights (model probabilities) of the models that
include the variable.  Note that this measure of evidence is only
appropriate when the variable appears in the same number of models as
those that do not include the variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importance(cand.set, parm, modnames = NULL, second.ord = TRUE,
           nobs = NULL, ...)

## S3 method for class 'AICaov.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICbetareg'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICsclm.clm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICclm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICclmm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICclogit.coxph'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICcoxme'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICcoxph'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICglm.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICglmerMod'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClmerModLmerTest'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICglmmTMB'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICgls'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClme'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClmekin'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICmaxlikeFit.list'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICmer'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICmultinom.nnet'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICnegbin.glm.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICnlmerMod'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICpolr'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICrlm.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICsurvreg'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccu'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICunmarkedFitMMO'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICunmarkedFitDSO'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICvglm'
importance(cand.set, parm, modnames = NULL, 
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
importance(cand.set, parm, modnames = NULL, 
           second.ord = TRUE, nobs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importance_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="importance_+3A_parm">parm</code></td>
<td>

<p>the parameter of interest for which a measure of relative importance is
required. 
</p>
</td></tr>
<tr><td><code id="importance_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models.  If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate models.
</p>
</td></tr>
<tr><td><code id="importance_+3A_second.ord">second.ord</code></td>
<td>

<p>logical. If <code>TRUE</code>, the function returns the second-order Akaike 
information criterion (i.e., AICc). 
</p>
</td></tr>
<tr><td><code id="importance_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.  In
such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="importance_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>importance</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td></tr>
<tr><td><code id="importance_+3A_parm.type">parm.type</code></td>
<td>
<p>this argument specifies the parameter type on which
the variable of interest will be extracted and is only relevant for
models of <code>unmarkedFit</code> classes.  The character strings supported
vary with the type of model fitted.  For <code>unmarkedFitOccu</code> and
<code>unmarkedFitOccuMulti</code> objects, either <code>psi</code> or
<code>detect</code> can be supplied to indicate whether the parameter is on
occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>, 
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuMS</code> objects, possible values are <code>psi</code>,
<code>phi</code>, or <code>detect</code>, denoting occupancy, transition, and
detection probabilities, respectively.  For <code>unmarkedFitOccuRN</code>
objects, either <code>lambda</code> or <code>detect</code> can be entered for
abundance and detectability parameters, respectively.  For
<code>unmarkedFitPCount</code> and <code>unmarkedFitMPois</code> objects,
<code>lambda</code> or <code>detect</code> denote parameters on abundance and
detectability, respectively.  For <code>unmarkedFitPCO</code>,
<code>unmarkedFitMMO</code>, and <code>unmarkedFitDSO</code> objects, one can
enter <code>lambda</code>, <code>gamma</code>, <code>omega</code>, <code>iota</code>, or
<code>detect</code>, to specify parameters on abundance, recruitment,
apparent survival, immigration, and detectability, respectively.  For
<code>unmarkedFitDS</code> objects, <code>lambda</code> and <code>detect</code> are
supported.  For <code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detection
probability, respectively.  For <code>unmarkedFitGMM</code> and
<code>unmarkedFitGPC</code> objects, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detectability,
respectively.
</p>
</td></tr>
<tr><td><code id="importance_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>importance</code> returns an object of class <code>importance</code>
consisting of the following components:
</p>
<table>
<tr><td><code>parm</code></td>
<td>
<p>the parameter for which an importance value is required.</p>
</td></tr> 
<tr><td><code>w.plus</code></td>
<td>
<p>the sum of Akaike weights for the models that include the
parameter of interest.</p>
</td></tr>
<tr><td><code>w.minus</code></td>
<td>
<p>the sum of Akaike weights for the models that exclude the
parameter of interest.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., and Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+modavg">modavg</a></code>, 
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##example on Orthodont data set in nlme
## Not run: 
require(nlme)

##set up candidate model list
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lme(distance ~ age, data = Orthodont, method = "ML")
##random is ~ age | Subject
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1, method = "ML")
Cand.models[[3]] &lt;- lme(distance ~ 1, data = Orthodont, random = ~ 1,
                        method = "ML") 
Cand.models[[4]] &lt;- lme(distance ~ Sex, data = Orthodont, random = ~ 1,
                        method = "ML") 

##create a vector of model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

importance(cand.set = Cand.models, parm = "age", modnames = Modnames,
           second.ord = TRUE, nobs = NULL)
##round to 4 digits after decimal point
print(importance(cand.set = Cand.models, parm = "age", modnames = Modnames,
                 second.ord = TRUE, nobs = NULL), digits = 4)
detach(package:nlme)

## End(Not run)


##single-season occupancy model example modified from ?occu
## Not run: 
require(unmarked)
##single season
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
## add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)),
                                sitevar2 = rnorm(numSites(pferUMF))) 
     
## observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) *
                                 obsNum(pferUMF))) 

##set up candidate model set
fm1 &lt;- occu(~ obsvar1 ~ sitevar1, pferUMF)
fm2 &lt;- occu(~ 1 ~ sitevar1, pferUMF)
fm3 &lt;- occu(~ obsvar1 ~ sitevar2, pferUMF)
fm4 &lt;- occu(~ 1 ~ sitevar2, pferUMF)
Cand.mods &lt;- list(fm1, fm2, fm3, fm4)
Modnames &lt;- c("fm1", "fm2", "fm3", "fm4")

##compute importance value for 'sitevar1' on occupancy
importance(cand.set = Cand.mods, modnames = Modnames, parm = "sitevar1",
           parm.type = "psi")
##compute importance value for 'obsvar1' on detectability
importance(cand.set = Cand.mods, modnames = Modnames, parm = "obsvar1",
           parm.type = "detect")


##example with multispecies occupancy modify from ?occuMulti
##Simulate 3 species data
N &lt;- 80
nspecies &lt;- 3
J &lt;- 4
     
occ_covs &lt;- as.data.frame(matrix(rnorm(N * 10),ncol=10))
names(occ_covs) &lt;- paste('par',1:10,sep='')

det_covs &lt;- list()
for (i in 1:nspecies){
    det_covs[[i]] &lt;- matrix(rnorm(N*J),nrow=N)
}
names(det_covs) &lt;- paste('par',1:nspecies,sep='')

##True vals
beta &lt;- c(0.5,0.2,0.4,0.5,-0.1,-0.3,0.2,0.1,-1,0.1)
f1 &lt;- beta[1] + beta[2]*occ_covs$par1
f2 &lt;- beta[3] + beta[4]*occ_covs$par2
f3 &lt;- beta[5] + beta[6]*occ_covs$par3
f4 &lt;- beta[7]
f5 &lt;- beta[8]
f6 &lt;- beta[9]
f7 &lt;- beta[10]
f &lt;- cbind(f1,f2,f3,f4,f5,f6,f7)
z &lt;- expand.grid(rep(list(1:0),nspecies))[,nspecies:1]
colnames(z) &lt;- paste('sp',1:nspecies,sep='')
dm &lt;- model.matrix(as.formula(paste0("~.^",nspecies,"-1")),z)

psi &lt;- exp(f 
psi &lt;- psi/rowSums(psi)

##True state
ztruth &lt;- matrix(NA,nrow=N,ncol=nspecies)
for (i in 1:N){
    ztruth[i,] &lt;- as.matrix(z[sample(8,1,prob=psi[i,]),])
}
     
p_true &lt;- c(0.6,0.7,0.5)

## fake y data
y &lt;- list()
     
for (i in 1:nspecies){
    y[[i]] &lt;- matrix(NA,N,J)
    for (j in 1:N){
        for (k in 1:J){
            y[[i]][j,k] &lt;- rbinom(1,1,ztruth[j,i]*p_true[i])
        }
    }
}
names(y) &lt;- c('coyote','tiger','bear')
     
##Create the unmarked data object
data &lt;- unmarkedFrameOccuMulti(y=y,siteCovs=occ_covs,obsCovs=det_covs)

## Formulas for state and detection processes
## Length should match number/order of columns in fDesign
occFormulas &lt;- c('~par1 + par2','~par2','~par3','~1','~1','~1','~1')
occFormulas2 &lt;- c('~par1 + par3','~par1 + par2','~par1 + par2 + par3',
                  "~ 1", "~1", "~ 1", "~1")

##Length should match number/order of species in data@ylist
detFormulas &lt;- c('~1','~1','~1')
     
fit &lt;- occuMulti(detFormulas,occFormulas,data)
fit2 &lt;- occuMulti(detFormulas,occFormulas2,data)

##importance
importance(cand.set = list(fit, fit2), parm = "[coyote] par2",
           parm.type = "psi")


detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='iron'>
Iron Content in Food
</h2><span id='topic+iron'></span>

<h3>Description</h3>

<p>This data set, originally from Adish et al. (1999), describes the iron
content of food cooked in different pot types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iron)</code></pre>


<h3>Format</h3>

<p>A data frame with 36 rows and 3 variables.
</p>

<dl>
<dt><code>Pot</code></dt><dd><p>pot type, one of &quot;aluminium&quot;, &quot;clay&quot;, or &quot;iron&quot;.</p>
</dd> 
<dt><code>Food</code></dt><dd><p>food type, one of &quot;legumes&quot;, &quot;meat&quot;, or
&quot;vegetables&quot;.</p>
</dd>
<dt><code>Iron</code></dt><dd><p>iron content measured in mg/100 g of food.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Heiberger and Holland (2004, p. 378) use these data as an exercise on 
two-way ANOVA with interaction.
</p>


<h3>Source</h3>

<p>Heiberger, R. M., Holland, B. (2004) <em>Statistical Analysis and Data
Display:  an intermediate course with examples in S-Plus, R, and
SAS</em>. Springer: New York.
</p>
<p>Adish, A. A., Esrey, S. A., Gyorkos, T. W., Jean-Baptiste, J., Rojhani,
A. (1999) Effect of consumption of food cooked in iron pots on iron
status and growth of young children: a randomised trial. <em>The
Lancet</em> <b>353</b>, 712&ndash;716.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iron)
str(iron)
</code></pre>

<hr>
<h2 id='lizards'>
Habitat Preference of Lizards
</h2><span id='topic+lizards'></span>

<h3>Description</h3>

<p>This data set describes the habitat preference of two species of
lizards, <em>Anolis grahami</em> and <em>A</em>. <em>opalinus</em>, on the
island of Jamaica and is originally from Schoener (1970). McCullagh and
Nelder (1989) and Burnham and Anderson (2002) reanalyzed the data. Note
that a typo occurs in table 3.11 of Burnham and Anderson (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lizards)</code></pre>


<h3>Format</h3>

<p>A data frame with 48 rows and 6 variables.
</p>

<dl>
<dt><code>Insolation</code></dt><dd><p>position of perch, either <code>shaded</code> or
<code>sunny</code>.</p>
</dd>
<dt><code>Diameter</code></dt><dd><p>diameter of the perch, either <code>&lt; 2 in</code>
or <code>&gt;= 2 in</code>.</p>
</dd>
<dt><code>Height</code></dt><dd><p>perch height, either <code>&lt; 5</code> or
<code>&gt;= 5</code>.</p>
</dd>
<dt><code>Time</code></dt><dd><p>time of day, either <code>morning</code>,
<code>midday</code>, or <code>afternoon</code>.</p>
</dd> 
<dt><code>Species</code></dt><dd><p>species observed, either <code>grahami</code> or
<code>opalinus</code>.</p>
</dd>
<dt><code>Counts</code></dt><dd><p>number of individuals observed.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Burnham and Anderson (2002, p. 137) use this data set originally from
Schoener (1970) to illustrate model selection for log-linear models. 
</p>


<h3>Source</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>McCullagh, P., Nelder, J. A. (1989) <em>Generalized Linear
Models</em>. Second edition. Chapman and Hall: New York.
</p>
<p>Schoener, T. W. (1970) Nonsynchronous spatial overlap of lizards in
patchy habitats. <em>Ecology</em> <b>51</b>, 408&ndash;418. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lizards)
## Not run: 
##log-linear model as in Burnham and Anderson 2002, p. 137
##main effects
m1 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species, 
          family = poisson, data = lizards)


##main effects and all second order interactions = base
m2 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species +
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Time +
          Diameter:Species + Height:Time + Height:Species +
          Time:Species, family = poisson, data = lizards)

##base - DT
m3 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species +
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Species +
          Height:Time + Height:Species + Time:Species, 
          family = poisson, data = lizards)

##base + HDI + HDT + HDS
m4 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species +
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Time +
          Diameter:Species + Height:Time + Height:Species +
          Time:Species + Height:Diameter:Insolation +
          Height:Diameter:Time + Height:Diameter:Species, 
          family = poisson, data = lizards)

##base + HDI + HDS + HIT + HIS + HTS + ITS
m5 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species + 
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Time +
          Diameter:Species + Height:Time + Height:Species +
          Time:Species + Height:Diameter:Insolation +
          Height:Diameter:Species + Height:Insolation:Time +
          Height:Insolation:Species + Height:Time:Species +
          Insolation:Time:Species, family = poisson, data = lizards)

##base + HIT + HIS + HTS + ITS
m6 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species + 
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Time +
          Diameter:Species + Height:Time + Height:Species +
          Time:Species + Height:Insolation:Time +
          Height:Insolation:Species +  Height:Time:Species +
          Insolation:Time:Species,  family = poisson, data = lizards)

##base + HIS + HTS + ITS
m7 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species +
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Time +
          Diameter:Species + Height:Time + Height:Species +
          Time:Species + Height:Insolation:Species +
          Height:Time:Species + Insolation:Time:Species, 
          family = poisson, data = lizards)

##base + HIT + HIS + HTS + ITS - DT
m8 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species +
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Species +
          Height:Time + Height:Species + Time:Species +
          Height:Insolation:Time + Height:Insolation:Species +
          Height:Time:Species + Insolation:Time:Species, 
          family = poisson, data = lizards)

##base + HIT + HIS + ITS - DT
m9 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species +
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Species +
          Height:Time + Height:Species + Time:Species +
          Height:Insolation:Time + Height:Insolation:Species +
          Insolation:Time:Species, 
          family = poisson, data = lizards)

##base + HIT + HIS - DT
m10 &lt;- glm(Counts ~ Insolation + Diameter + Height + Time + Species +
          Insolation:Diameter + Insolation:Height + Insolation:Time +
          Insolation:Species + Diameter:Height + Diameter:Species +
          Height:Time + Height:Species + Time:Species +
          Height:Insolation:Time + Height:Insolation:Species,
          family = poisson, data = lizards)

##set up in list
Cands &lt;- list(m1, m2, m3, m4, m5, m6, m7, m8, m9, m10)
Modnames &lt;- paste("m", 1:length(Cands), sep = "")

##model selection
library(AICcmodavg)
aictab(Cands, Modnames)

## End(Not run)
</code></pre>

<hr>
<h2 id='mb.gof.test'>
Compute MacKenzie and Bailey Goodness-of-fit Test for Single Season,
Dynamic, and Royle-Nichols Occupancy Models
</h2><span id='topic+mb.gof.test'></span><span id='topic+mb.gof.test.default'></span><span id='topic+mb.gof.test.unmarkedFitOccu'></span><span id='topic+mb.gof.test.unmarkedFitColExt'></span><span id='topic+mb.gof.test.unmarkedFitOccuRN'></span><span id='topic+mb.chisq'></span><span id='topic+mb.chisq.default'></span><span id='topic+mb.chisq.unmarkedFitOccu'></span><span id='topic+mb.chisq.unmarkedFitColExt'></span><span id='topic+mb.chisq.unmarkedFitOccuRN'></span><span id='topic+print.mb.chisq'></span>

<h3>Description</h3>

<p>These functions compute the MacKenzie and Bailey (2004) goodness-of-fit
test for single season occupancy models based on Pearson's chi-square
and extend it to dynamic (multiple season) and Royle-Nichols (2003)
occupancy models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.chisq(mod, print.table = TRUE, ...)

## S3 method for class 'unmarkedFitOccu'
mb.chisq(mod, print.table = TRUE, ...)

## S3 method for class 'unmarkedFitColExt'
mb.chisq(mod, print.table = TRUE, ...)

## S3 method for class 'unmarkedFitOccuRN'
mb.chisq(mod, print.table = TRUE,
                  maxK = NULL, ...)

mb.gof.test(mod, nsim = 5, plot.hist = TRUE, report = NULL,
            parallel = TRUE, ncores, cex.axis = 1, cex.lab = 1,
            cex.main = 1, lwd = 1, ...)

## S3 method for class 'unmarkedFitOccu'
mb.gof.test(mod, nsim = 5, plot.hist = TRUE,
                     report = NULL, parallel = TRUE, ncores,
                     cex.axis = 1, cex.lab = 1, cex.main = 1,
                     lwd = 1, ...)

## S3 method for class 'unmarkedFitColExt'
mb.gof.test(mod, nsim = 5, plot.hist = TRUE,
                     report = NULL, parallel = TRUE,
                     ncores, cex.axis = 1, cex.lab = 1, cex.main = 1,
                     lwd = 1, plot.seasons = FALSE, ...) 

## S3 method for class 'unmarkedFitOccuRN'
mb.gof.test(mod, nsim = 5, plot.hist = TRUE,
                     report = NULL, parallel = TRUE, ncores,
                     cex.axis = 1, cex.lab = 1, cex.main = 1,
                     lwd = 1, maxK = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.gof.test_+3A_mod">mod</code></td>
<td>

<p>the model for which a goodness-of-fit test is required.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_print.table">print.table</code></td>
<td>
<p>logical.  Specifies if the detailed table of observed
and expected values is to be included in the output.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_nsim">nsim</code></td>
<td>
<p>the number of bootstrapped samples.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_plot.hist">plot.hist</code></td>
<td>
<p>logical.  Specifies that a histogram of the
bootstrapped test statistic is to be included in the output.  For
dynamic occupancy models, this produces a histogram of the sum of the
season-specific chi-squares for each bootstrap sample.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_report">report</code></td>
<td>
<p>If <code>NULL</code>, the test statistic for each iteration is
not printed in the terminal.  Otherwise, an integer indicating the
number of values of the test statistic that should be printed on
the same line.  For example, if <code>report = 3</code>, the values of the
test statistic for three iterations are reported on each line.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_parallel">parallel</code></td>
<td>
<p>logical.  If <code>TRUE</code>, requests that <code>parboot</code>
use multiple cores to accelerate computations of the bootstrap.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_ncores">ncores</code></td>
<td>
<p>integer indicating the number of cores to use when
bootstrapping in parallel during the analysis of simulated data sets.
If <code>ncores</code> is not specified, one less than the number of
available cores on the computer is used.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_cex.axis">cex.axis</code></td>
<td>
<p>expansion factor influencing the size of axis
annotations on plots produced by the function.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_cex.lab">cex.lab</code></td>
<td>
<p>expansion factor influencing the size of axis labels on
plots produced by the function.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_cex.main">cex.main</code></td>
<td>
<p>expansion factor influencing the size of the main title
above plots produced by the function.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_lwd">lwd</code></td>
<td>
<p>expansion factor of line width on plots produced by the
function.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_plot.seasons">plot.seasons</code></td>
<td>
<p>logical.  For dynamic occupancy models, specifies
that a histogram of the bootstrapped test statistic for each primary
period (season) is to be included in the output. 
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_maxk">maxK</code></td>
<td>
<p>the number of support points used as the summation index in
the likelihood of the Royle-Nichols model (2003).  If <code>NULL</code>,
extracts the value of <code>K</code> used by <code>occuRN</code> to fit the model
to the original data.
</p>
</td></tr>
<tr><td><code id="mb.gof.test_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MacKenzie and Bailey (2004) and MacKenzie et al. (2006) suggest using
the Pearson chi-square to assess the fit of single season occupancy
models (MacKenzie et al. 2002).  Given low expected frequencies, the
chi-square statistic will deviate from the theoretical distribution and
it is recommended to use a parametric bootstrap approach to obtain
P-values with the <code>parboot</code> function of the <code>unmarked</code>
package.  <code>mb.chisq</code> computes the table of observed and expected
values based on the detection histories and single season occupancy
model used. <code>mb.gof.test</code> calls internally <code>mb.chisq</code> and
<code>parboot</code> to generate simulated data sets based on the model and
compute the MacKenzie and Bailey test statistic.  Missing values are
accomodated by creating cohorts for each pattern of missing values.
</p>
<p>It is also possible to obtain an estimate of the overdispersion
parameter (c-hat) for the model at hand by dividing the observed
chi-square statistic by the mean of the statistics obtained from
simulation. 
</p>
<p>This test is extended to dynamic occupancy models of MacKenzie et
al. (2003) by using the occupancy estimates for each season obtained
from the model.  These estimates are then used to compute the predicted
and observed frequencies separately within each season.  The chi-squares
are then summed to be used as the test statistic for the dynamic
occupancy model.
</p>
<p>Note that values of c-hat &gt; 1 indicate overdispersion (variance &gt; mean),
but that values much higher than 1 (i.e., &gt; 4) probably indicate
lack-of-fit.  In cases of moderate overdispersion, one usually
multiplies the variance-covariance matrix of the estimates by c-hat.  As
a result, the SE's of the estimates are inflated (c-hat is also known as
a variance inflation factor). 
</p>
<p>In model selection, c-hat should be estimated from the global model and
the same value of c-hat applied to the entire model set.  Specifically,
a global model is the most complex model from which all the other models
of the set are simpler versions (nested).  When no single global model
exists in the set of models considered, such as when sample size does
not allow a complex model, one can estimate c-hat from 'subglobal'
models.  Here, 'subglobal' models denote models from which only a subset
of the models of the candidate set can be derived.  In such cases, one
can use the smallest value of c-hat for model selection (Burnham and
Anderson 2002).
</p>
<p>Note that c-hat counts as an additional parameter estimated and should
be added to K.  All functions in package <code>AICcmodavg</code> automatically
add 1 when the <code>c.hat</code> argument &gt; 1 and apply the same value of
c-hat for the entire model set.  When c-hat &gt; 1, functions compute
quasi-likelihood information criteria (either QAICc or QAIC, depending
on the value of the <code>second.ord</code> argument) by scaling the
log-likelihood of the model by c-hat.  The value of c-hat can influence
the ranking of the models:  as c-hat increases, QAIC or QAICc will favor
models with fewer parameters.  As an additional check against this
potential problem, one can generate several model selection tables by
incrementing values of c-hat to assess the model selection uncertainty.
If ranking changes little up to the c-hat value observed, one can be
confident in making inference.
</p>
<p>In cases of underdispersion (c-hat &lt; 1), it is recommended to keep the
value of c-hat to 1.  However, note that values of c-hat &lt;&lt; 1 can also
indicate lack-of-fit and that an alternative model should be investigated. 
</p>


<h3>Value</h3>

<p><code>mb.chisq</code> returns the following components for single-season and
Royle-Nichols occupancy models:
</p>
<table>
<tr><td><code>chisq.table</code></td>
<td>
<p>the table of observed and expected values for each
detection history and its chi-square component (if <code>print.table
    = TRUE</code>).  Note that the table only shows the observed detection
histories.  Unobserved detection histories are not shown, but are
included in the computation of the test statistic.
</p>
</td></tr>
<tr><td><code>chi.square</code></td>
<td>
<p>the Pearson chi-square statistic.  This test
statistic should be compared against a bootstrap distribution
instead of the theoretical chi-square distribution because low
expected frequencies invalidate the chi-square assumption.
</p>
</td></tr>
<tr><td><code>model.type</code></td>
<td>
<p>the model type, either <code>single-season</code>,
<code>royle-nichols</code>, or <code>dynamic</code>. 
</p>
</td></tr>
</table>
<p><code>mb.chisq</code> returns the following additional components for dynamic
occupancy models:
</p>
<table>
<tr><td><code>tables</code></td>
<td>
<p>a list containing the season-specific chi-square tables
(if <code>print.table = TRUE</code>).
</p>
</td></tr>
<tr><td><code>all.chisq</code></td>
<td>
<p>an element containing the season-specific chi-squares.
</p>
</td></tr>
<tr><td><code>n.seasons</code></td>
<td>
<p>the number of primary periods (seasons).
</p>
</td></tr>
<tr><td><code>n.seasons</code></td>
<td>
<p>the number of primary periods (seasons).
</p>
</td></tr>
<tr><td><code>missing.seasons</code></td>
<td>
<p>logical vector indicating whether data were
collected or not during a given season (primary period), where
<code>TRUE</code> indicates that no data were collected during the season.
</p>
</td></tr>
</table>
<p><code>mb.gof.test</code> returns the following components for single-season
and Royle-Nichols occupancy models:
</p>
<table>
<tr><td><code>chisq.table</code></td>
<td>
<p>the table of observed and expected values for each
detection history and its chi-square component.
</p>
</td></tr>
<tr><td><code>chi.square</code></td>
<td>
<p>the Pearson chi-square statistic.
</p>
</td></tr>
<tr><td><code>t.star</code></td>
<td>
<p>the bootstrapped chi-square test statistics (i.e.,
obtained for each of the simulated data sets).
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the P-value assessed from the parametric bootstrap,
computed as the proportion of the simulated test statistics greater
than or equal to the observed test statistic.
</p>
</td></tr>
<tr><td><code>c.hat.est</code></td>
<td>
<p>the estimate of the overdispersion parameter, c-hat,
computed as the observed test statistic divided by the mean of the
simulated test statistics.
</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>the number of bootstrap samples. The recommended number of
samples varies with the data set, but should be on the order of 1000
or 5000, and in cases with a large number of visits, even 10 000
samples, namely to reduce the effect of unusually small values of the
test statistics.
</p>
</td></tr>
</table>
<p><code>mb.gof.test</code> returns the following additional components for
dynamic occupancy models:
</p>
<table>
<tr><td><code>chisq.table</code></td>
<td>
<p>a list including the table of observed and expected
values for each detection history and its chi-square component for
each primary period (season).
</p>
</td></tr>
<tr><td><code>chi.square</code></td>
<td>
<p>the chi-square test statistic, as the sum of the 
chi-squares across the primary periods.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>a list of the P-values for each of the primary periods,
computed separately as the proportion of the simulated test
statistics greater than or equal to the observed test statistic.
</p>
</td></tr>
<tr><td><code>p.global</code></td>
<td>
<p>the P-value of the chi-square test statistic for the
dynamic occupancy model.  This P-value is computed as the proportion
of the simulated sums of chi-squares greater than or equal to the
observed sum of chi-squares across the primary periods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.  
</p>
<p>MacKenzie, D. I., Bailey, L. L. (2004) Assessing the fit of
site-occupancy models. <em>Journal of Agricultural, Biological, and
Environmental Statistics</em> <b>9</b>, 300&ndash;318.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Royle, J. A., Pollock, K. H., Bailey,
L. L., Hines, J. E. (2006) <em>Occupancy estimation and
modeling: inferring patterns and dynamics of species
occurrence</em>. Academic Press: New York.
</p>
<p>Royle, J. A., Nichols, J. D. (2003) Estimating abundance from repeated
presence-absence data or point counts. <em>Ecology</em> <b>84</b>,
777&ndash;790.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="unmarked.html#topic+colext">colext</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>, <code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>,
<code><a href="unmarked.html#topic+occu">occu</a></code>, <code><a href="unmarked.html#topic+parboot">parboot</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##single-season occupancy model example modified from ?occu
## Not run: 
require(unmarked)
##single season
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
## add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)),
                                sitevar2 = rnorm(numSites(pferUMF))) 
     
## observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) *
                                 obsNum(pferUMF))) 

##run model
fm1 &lt;- occu(~ obsvar1 ~ sitevar1, pferUMF)

##compute observed chi-square
obs &lt;- mb.chisq(fm1)
obs
##round to 4 digits after decimal point
print(obs, digits.vals = 4)


##compute observed chi-square, assess significance, and estimate c-hat
obs.boot &lt;- mb.gof.test(fm1, nsim = 3)
##note that more bootstrap samples are recommended
##(e.g., 1000, 5000, or 10 000)
obs.boot
print(obs.boot, digits.vals = 4, digits.chisq = 4)


##data with missing values
mat1 &lt;- matrix(c(0, 0, 0), nrow = 120, ncol = 3, byrow = TRUE)
mat2 &lt;- matrix(c(0, 0, 1), nrow = 23, ncol = 3, byrow = TRUE)
mat3 &lt;- matrix(c(1, NA, NA), nrow = 42, ncol = 3, byrow = TRUE)
mat4 &lt;- matrix(c(0, 1, NA), nrow = 33, ncol = 3, byrow = TRUE)
y.mat &lt;- rbind(mat1, mat2, mat3, mat4)
y.sim.data &lt;- unmarkedFrameOccu(y = y.mat)
m1 &lt;- occu(~ 1 ~ 1, data = y.sim.data)

mb.gof.test(m1, nsim = 3)
##note that more bootstrap samples are recommended
##(e.g., 1000, 5000, or 10 000)

##modifying graphical parameters
mb.gof.test(m1, nsim = 3,
cex.axis = 1.2, #axis annotations are 1.2 the default size
cex.lab = 1.2,  #axis labels are 1.2 the default size
lwd = 2)        #line width is twice the default width
detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='min.trap'>
Anuran Larvae Counts in Minnow Traps Across Pond Type
</h2><span id='topic+min.trap'></span>

<h3>Description</h3>

<p>This data set consists of counts of anuran larvae as a function of pond
type, pond perimeter, and presence of water scorpions (<em>Ranatra</em> sp.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(min.trap)</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 6 variables.
</p>

<dl>
<dt><code>Type</code></dt><dd><p>pond type, denotes the location of ponds in
either bog or upland environment</p>
</dd>
<dt><code>Num_anura</code></dt><dd><p>number of anuran larvae in minnow traps</p>
</dd>
<dt><code>Effort</code></dt><dd><p>number of trap nights (i.e., number of traps x
days of trapping) in each pond</p>
</dd>
<dt><code>Perimeter</code></dt><dd><p>pond perimeter in meters</p>
</dd>
<dt><code>Num_ranatra</code></dt><dd><p>number of water scorpions trapped in
minnow traps</p>
</dd>
<dt><code>log.Perimeter</code></dt><dd><p>natural log of perimeter</p>
</dd>
</dl>



<h3>Details</h3>

<p>Mazerolle (2006) uses this data set to illustrate model selection for
Poisson regression with low overdispersion. 
</p>


<h3>Source</h3>

<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(min.trap)
## maybe str(min.trap) ; plot(min.trap) ...
</code></pre>

<hr>
<h2 id='modavg'>
Compute Model-averaged Parameter Estimate (Multimodel Inference)
</h2><span id='topic+modavg'></span><span id='topic+modavg.default'></span><span id='topic+modavg.AICaov.lm'></span><span id='topic+modavg.AICbetareg'></span><span id='topic+modavg.AICsclm.clm'></span><span id='topic+modavg.AICclm'></span><span id='topic+modavg.AICclmm'></span><span id='topic+modavg.AICcoxme'></span><span id='topic+modavg.AICcoxph'></span><span id='topic+modavg.AICglm.lm'></span><span id='topic+modavg.AICglmmTMB'></span><span id='topic+modavg.AICgls'></span><span id='topic+modavg.AIChurdle'></span><span id='topic+modavg.AIClm'></span><span id='topic+modavg.AIClme'></span><span id='topic+modavg.AIClmekin'></span><span id='topic+modavg.AICmaxlikeFit.list'></span><span id='topic+modavg.AICmer'></span><span id='topic+modavg.AIClmerMod'></span><span id='topic+modavg.AIClmerModLmerTest'></span><span id='topic+modavg.AICglmerMod'></span><span id='topic+modavg.AICmultinom.nnet'></span><span id='topic+modavg.AICnegbin.glm.lm'></span><span id='topic+modavg.AICpolr'></span><span id='topic+modavg.AICrlm.lm'></span><span id='topic+modavg.AICsurvreg'></span><span id='topic+modavg.AICvglm'></span><span id='topic+modavg.AICzeroinfl'></span><span id='topic+modavg.AICunmarkedFitOccu'></span><span id='topic+modavg.AICunmarkedFitColExt'></span><span id='topic+modavg.AICunmarkedFitOccuRN'></span><span id='topic+modavg.AICunmarkedFitPCount'></span><span id='topic+modavg.AICunmarkedFitPCO'></span><span id='topic+modavg.AICunmarkedFitDS'></span><span id='topic+modavg.AICunmarkedFitGDS'></span><span id='topic+modavg.AICunmarkedFitOccuFP'></span><span id='topic+modavg.AICunmarkedFitMPois'></span><span id='topic+modavg.AICunmarkedFitGMM'></span><span id='topic+modavg.AICunmarkedFitGPC'></span><span id='topic+modavg.AICunmarkedFitOccuMulti'></span><span id='topic+modavg.AICunmarkedFitOccuMS'></span><span id='topic+modavg.AICunmarkedFitOccuTTD'></span><span id='topic+modavg.AICunmarkedFitMMO'></span><span id='topic+modavg.AICunmarkedFitDSO'></span><span id='topic+print.modavg'></span>

<h3>Description</h3>

<p>This function model-averages the estimate of a parameter of interest
among a set of candidate models, computes the unconditional standard
error and unconditional confidence intervals as described in Buckland et
al. (1997) and Burnham and Anderson (2002).  This model-averaged estimate
is also referred to as a natural average of the estimate by Burnham and
Anderson (2002, p. 152).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modavg(cand.set, parm, modnames = NULL, second.ord = TRUE, nobs = NULL, 
       uncond.se = "revised", conf.level = 0.95, exclude = NULL, warn =
       TRUE, ...) 

## S3 method for class 'AICaov.lm'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICbetareg'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICsclm.clm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICclm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICclmm'
modavg(cand.set, parm, modnames = NULL, second.ord 
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICcoxme'
modavg(cand.set, parm, modnames = NULL, second.ord
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICcoxph'
modavg(cand.set, parm, modnames = NULL, second.ord
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICglm.lm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        gamdisp = NULL, ...)

## S3 method for class 'AICglmmTMB'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        ...)

## S3 method for class 'AICgls'
modavg(cand.set, parm, modnames = NULL, second.ord =
           TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
           exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIChurdle'
modavg(cand.set, parm, modnames = NULL,
         second.ord = TRUE, nobs = NULL, uncond.se = "revised",
         conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClm'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClme'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClmekin'
modavg(cand.set, parm, modnames = NULL,
         second.ord = TRUE, nobs = NULL, uncond.se = "revised",
         conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICmaxlikeFit.list'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        ...)

## S3 method for class 'AICmer'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClmerMod'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClmerModLmerTest'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICglmerMod'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICmultinom.nnet'
modavg(cand.set, parm, modnames = NULL, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        ...)

## S3 method for class 'AICnegbin.glm.lm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICpolr'
modavg(cand.set, parm, modnames = NULL, second.ord
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICrlm.lm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICsurvreg'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICvglm'
modavg(cand.set, parm, modnames = NULL, second.ord
         = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
         exclude = NULL, warn = TRUE, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
modavg(cand.set, parm, modnames = NULL,
         second.ord = TRUE, nobs = NULL, uncond.se = "revised",
         conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICunmarkedFitOccu'
modavg(cand.set, parm, modnames = NULL, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavg(cand.set, parm, modnames =
       NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
       conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
       parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modavg_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_parm">parm</code></td>
<td>

<p>the parameter of interest, enclosed between quotes, for which a
model-averaged estimate is required.  For a categorical variable, 
the label of the estimate must be included as it appears in the output
(see 'Details' below). 
</p>
</td></tr>
<tr><td><code id="modavg_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="modavg_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of 
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.
In such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_uncond.se">uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
  "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.  Note that versions of package AICcmodavg &lt; 1.04 used the old
method to compute unconditional standard errors.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_exclude">exclude</code></td>
<td>

<p>this argument excludes models based on the terms specified for the 
computation of a model-averaged estimate of <code>parm</code>.  The
<code>exclude</code> argument is set to <code>NULL</code> by default and does not
exclude any models other than those without the <code>parm</code>.  When
<code>parm</code> is a main effect but is also involved in
interactions/polynomial terms in some models, one should specify the
interaction/polynomial terms as a list to exclude models with these
terms from the computation of model-averaged estimate of the main effect
(e.g., <code>exclude = list("sex:mass", "mass2")</code>).  See 'Details' 
and 'Examples' below.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_warn">warn</code></td>
<td>

<p>logical.  If <code>TRUE</code>, <code>modavg</code> performs a check and isssues a
warning when the value in <code>parm</code> occurs more than once in any given
model.  This is a check for potential interaction/polynomial terms in
the model when such terms are constructed with the usual operators
(e.g., <code>I( )</code> for polynomial terms, <code>:</code> for interaction
terms).
</p>
</td></tr>
<tr><td><code id="modavg_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>modavg</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_gamdisp">gamdisp</code></td>
<td>

<p>if gamma GLM is used, the dispersion parameter should be specified here
to apply the same value to each model.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_parm.type">parm.type</code></td>
<td>
<p>this argument specifies the parameter type on which
the model-averaged estimate of a predictor will be computed and is
only relevant for models of <code>unmarkedFit</code> classes.  The character
strings supported vary with the type of model fitted.  For
<code>unmarkedFitOccu</code> and <code>unmarkedFitOccuMulti</code> objects, either
<code>psi</code> or <code>detect</code> can be supplied to indicate whether the
parameter is on occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuMS</code> objects, possible values are <code>psi</code>,
<code>phi</code>, or <code>detect</code>, denoting occupancy, transition, and
detection probabilities, respectively.  For <code>unmarkedFitOccuRN</code>
objects, either <code>lambda</code> or <code>detect</code> can be entered for
abundance and detectability parameters, respectively.  For
<code>unmarkedFitPCount</code> and <code>unmarkedFitMPois</code> objects,
<code>lambda</code> or <code>detect</code> denote parameters on abundance and
detectability, respectively.  For <code>unmarkedFitPCO</code>,
<code>unmarkedFitMMO</code>, and <code>unmarkedFitDSO</code> objects, one can
enter <code>lambda</code>, <code>gamma</code>, <code>omega</code>, <code>iota</code>, or
<code>detect</code>, to specify parameters on abundance, recruitment,
apparent survival, immigration, and detectability, respectively.  For
<code>unmarkedFitDS</code> objects, <code>lambda</code> and <code>detect</code> are
supported.  For <code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detection
probability, respectively.  For <code>unmarkedFitGMM</code> and
<code>unmarkedFitGPC</code> objects, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detectability,
respectively.
</p>
</td></tr>
<tr><td><code id="modavg_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter for which a model-averaged estimate is requested must be
specified with the <code>parm</code> argument and must be identical to its
label in the model output (e.g., from <code>summary</code>).  For factors, one
must specify the name of the variable and the level of interest.
<code>modavg</code> includes checks to find variations of interaction terms
specified in the <code>parm</code> and <code>exclude</code> arguments.  However, to
avoid problems, one should specify interaction terms consistently for
all models: e.g., either <code>a:b</code> or <code>b:a</code> for all models, but
not a mixture of both. 
</p>
<p>You must exercise caution when some models include interaction or
polynomial terms, because main effect terms do not have the same
interpretation when they also appear in an interaction/polynomial term
in the same model.  In such cases, one should exclude models containing 
interaction terms where the main effect is involved with the
<code>exclude</code> argument of <code>modavg</code>.  Note that <code>modavg</code>
checks for potential cases of multiple instances of a variable appearing
more than once in a given model (presumably in an interaction) and
issues a warning.  To correctly compute the model-averaged estimate of a
main effect involved in interaction/polynomial terms, specify the
interaction terms(s) that should not appear in the same model with the
<code>exclude</code> argument.  This will effectively exclude models from the
computation of the model-averaged estimate.  
</p>
<p>When <code>warn = TRUE</code>, <code>modavg</code> looks for matches among the
labels of the estimates with <code>identical</code>.  It then compares the
results to partial matches with <code>regexpr</code>, and issues a warning
whenever they are different.  As a result, <code>modavg</code> may issue a
warning when some variables or levels of categorical variables have
nested names (e.g., <code>treat</code>, <code>treat10</code>; <code>L</code>, <code>TL</code>).
When this warning is only due to the presence of similarly named
variables in the models (and NOT due to interaction terms), you can
suppress this warning by setting <code>warn = FALSE</code>.
</p>
<p>The model-averaging estimator implemented in <code>modavg</code> is known to
be biased away from 0 when there is substantial model selection
uncertainty (Cade 2015).  In such instances, it is recommended to use
the model-averaging shrinkage estimator (i.e., <code>modavgShrink</code>) for
inference on beta estimates or to focus on model-averaged effect sizes
(<code>modavgEffect</code>) and model-averaged predictions
(<code>modavgPred</code>).
</p>
<p><code>modavg</code> is implemented for a list containing objects of
<code>aov</code>, <code>betareg</code>, <code>clm</code>, <code>clmm</code>, <code>clogit</code>,
<code>coxme</code>, <code>coxph</code>, <code>glm</code>, <code>glmmTMB</code>, <code>gls</code>,
<code>hurdle</code>, <code>lm</code>, <code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>,
<code>mer</code>, <code>glmerMod</code>, <code>lmerMod</code>, <code>lmerModLmerTest</code>,
<code>multinom</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>, <code>vglm</code>,
<code>zeroinfl</code> classes as well as various models of <code>unmarkedFit</code>
classes.
</p>


<h3>Value</h3>

<p><code>modavg</code> creates an object of class <code>modavg</code> with the following
components: 
</p>
<table>
<tr><td><code>Parameter</code></td>
<td>
<p>the parameter for which a model-averaged estimate was
obtained.</p>
</td></tr> 
<tr><td><code>Mod.avg.table</code></td>
<td>
<p>the reduced model selection table based on models
including the parameter of interest.</p>
</td></tr>
<tr><td><code>Mod.avg.beta</code></td>
<td>
<p>the model-averaged estimate based on all models
including the parameter of interest (see 'Details' above regarding the
exclusion of models where parameter of interest is involved in an
interaction).</p>
</td></tr>
<tr><td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
estimate (as opposed to the conditional SE based on a single model).</p>
</td></tr>
<tr><td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval.</p>
</td></tr> 
<tr><td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit.</p>
</td></tr>
<tr><td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603&ndash;618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Cade, B. S. (2015) Model averaging and muddled multimodel
inferences. <em>Ecology</em> <b>96</b>, 2370&ndash;2382. 
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587.
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67&ndash;118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+modavgCustom">modavgCustom</a></code>, <code><a href="#topic+modavgEffect">modavgEffect</a></code>,
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##anuran larvae example modified from Mazerolle (2006)
##these are different models than in the paper
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##set up candidate models          
Cand.mod &lt;- list( )
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter +
                     Type:log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap)
##interactive model
Cand.mod[[2]] &lt;- glm(Num_anura ~ Type + log.Perimeter +
                     Type:log.Perimeter, family = poisson, 
                     offset = log(Effort), data = min.trap)
##additive model
Cand.mod[[3]] &lt;- glm(Num_anura ~ Type + log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap)
##Predator model
Cand.mod[[4]] &lt;- glm(Num_anura ~ Type + Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
          
##check c-hat for global model
c_hat(Cand.mod[[1]]) #uses Pearson's chi-square/df
##note the very low overdispersion: in this case, the analysis could be
##conducted without correcting for c-hat as its value is reasonably close
##to 1  

##assign names to each model
Modnames &lt;- c("global model", "interactive model",
              "additive model", "invertpred model") 

##model selection
aictab(Cand.mod, Modnames)

##compute model-averaged estimates for parameters appearing in top
##models
modavg(parm = "Num_ranatra", cand.set = Cand.mod, modnames = Modnames)
##round to 4 digits after decimal point
print(modavg(parm = "Num_ranatra", cand.set = Cand.mod,
             modnames = Modnames), digits = 4)

##model-averaging a variable involved in an interaction
##the following produces an error - because the variable is involved
##in an interaction in some candidate models
## Not run: modavg(parm = "TypeBOG", cand.set = Cand.mod,
         modnames = Modnames)
## End(Not run)


##exclude models where the variable is involved in an interaction
##to get model-averaged estimate of main effect
modavg(parm = "TypeBOG", cand.set = Cand.mod, modnames = Modnames,
       exclude = list("Type:log.Perimeter"))

##to get model-averaged estimate of interaction
modavg(parm = "TypeBOG:log.Perimeter", cand.set = Cand.mod,
       modnames = Modnames)



##beware of variables that have similar names
set.seed(seed = 4)
resp &lt;- rnorm(n = 40, mean = 3, sd = 1)
size &lt;- rep(c("small", "medsmall", "high", "medhigh"), times = 10)
set.seed(seed = 4)
mass &lt;- rnorm(n = 40, mean = 2, sd = 0.1)
mass2 &lt;- mass^2
age &lt;- rpois(n = 40, lambda = 3.2)
agecorr &lt;- rpois(n = 40, lambda = 2) 
sizecat &lt;- rep(c("a", "ab"), times = 20)
data1 &lt;- data.frame(resp = resp, size = size, sizecat = sizecat,
                    mass = mass, mass2 = mass2, age = age,
                    agecorr = agecorr)

##set up models in list
Cand &lt;- list( )
Cand[[1]] &lt;- lm(resp ~ size + agecorr, data = data1)
Cand[[2]] &lt;- lm(resp ~ size + mass + agecorr, data = data1)
Cand[[3]] &lt;- lm(resp ~ age + mass, data = data1)
Cand[[4]] &lt;- lm(resp ~ age + mass + mass2, data = data1)
Cand[[5]] &lt;- lm(resp ~ mass + mass2 + size, data = data1)
Cand[[6]] &lt;- lm(resp ~ mass + mass2 + sizecat, data = data1)
Cand[[7]] &lt;- lm(resp ~ sizecat, data = data1)
Cand[[8]] &lt;- lm(resp ~ sizecat + mass + sizecat:mass, data = data1)
Cand[[9]] &lt;- lm(resp ~ agecorr + sizecat + mass + sizecat:mass,
                 data = data1) 

##create vector of model names
Modnames &lt;- paste("mod", 1:length(Cand), sep = "")

aictab(cand.set = Cand, modnames = Modnames, sort = TRUE) #correct

##as expected, issues warning as mass occurs sometimes with "mass2" or
##"sizecatab:mass" in some of the models
## Not run: modavg(cand.set = Cand, parm = "mass", modnames = Modnames)

##no warning issued, because "age" and "agecorr" never appear in same model
modavg(cand.set = Cand, parm = "age", modnames = Modnames)

##as expected, issues warning because warn=FALSE, but it is a very bad
##idea in this example since "mass" occurs with "mass2" and "sizecat:mass"
##in some of the models - results are INCORRECT
## Not run: modavg(cand.set = Cand, parm = "mass", modnames = Modnames,
                warn = FALSE)
## End(Not run)

##correctly excludes models with quadratic term and interaction term
##results are CORRECT
modavg(cand.set = Cand, parm = "mass", modnames = Modnames,
       exclude = list("mass2", "sizecat:mass")) 

##correctly computes model-averaged estimate because no other parameter
##occurs simultaneously in any of the models
modavg(cand.set = Cand, parm = "sizesmall", modnames = Modnames) #correct

##as expected, issues a warning because "sizecatab" occurs sometimes in
##an interaction in some models
## Not run: modavg(cand.set = Cand, parm = "sizecatab",
                modnames = Modnames) 
## End(Not run)

##exclude models with "sizecat:mass" interaction - results are CORRECT
modavg(cand.set = Cand, parm = "sizecatab", modnames = Modnames,
       exclude = list("sizecat:mass"))



##example with multiple-season occupancy model modified from ?colext
##this is a bit longer
## Not run: 
require(unmarked)
data(frogs)
umf &lt;- formatMult(masspcru)
obsCovs(umf) &lt;- scale(obsCovs(umf))
siteCovs(umf) &lt;- rnorm(numSites(umf))
yearlySiteCovs(umf) &lt;- data.frame(year = factor(rep(1:7,
                                    numSites(umf))))

##set up model with constant transition rates
fm &lt;- colext(psiformula = ~ 1, gammaformula = ~ 1, epsilonformula = ~ 1,
             pformula = ~ JulianDate + I(JulianDate^2), data = umf,
             control = list(trace=1, maxit=1e4))

##model with with year-dependent transition rates
fm.yearly &lt;- colext(psiformula = ~ 1, gammaformula = ~ year,
                    epsilonformula = ~ year,
                    pformula = ~ JulianDate + I(JulianDate^2),
                    data = umf)

##store in list and assign model names
Cand.mods &lt;- list(fm, fm.yearly)
Modnames &lt;- c("psi1(.)gam(.)eps(.)p(Date + Date2)",
              "psi1(.)gam(Year)eps(Year)p(Date + Date2)")

##compute model-averaged estimate of occupancy in the first year
modavg(cand.set = Cand.mods, modnames = Modnames, parm = "(Intercept)",
       parm.type = "psi")

##compute model-averaged estimate of Julian Day squared on detectability
modavg(cand.set = Cand.mods, modnames = Modnames,
       parm = "I(JulianDate^2)", parm.type = "detect")

## End(Not run)


##example of model-averaged estimate of area from distance model
##this is a bit longer
## Not run: 
data(linetran) #example modified from ?distsamp
     
ltUMF &lt;- with(linetran, {
  unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
                  siteCovs = data.frame(Length, area, habitat),
                  dist.breaks = c(0, 5, 10, 15, 20),
                  tlength = linetran$Length * 1000, survey = "line", unitsIn = "m")
})
     
## Half-normal detection function. Density output (log scale). No covariates.
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
     
## Halfnormal. Covariates affecting both density and detection.
fm2 &lt;- distsamp(~ area + habitat ~ area + habitat, ltUMF)

## Hazard function. Covariates affecting both density and detection.
fm3 &lt;- distsamp(~ habitat ~ area + habitat, ltUMF, keyfun="hazard")

##assemble model list
Cands &lt;- list(fm1, fm2, fm3)
Modnames &lt;- paste("mod", 1:length(Cands), sep = "")

##model-average estimate of area on abundance
modavg(cand.set = Cands, modnames = Modnames, parm = "area", parm.type = "lambda")
detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='modavg.utility'>
Various Utility Functions
</h2><span id='topic+reverse.parm'></span><span id='topic+reverse.exclude'></span><span id='topic+formatCands'></span><span id='topic+formulaShort'></span>

<h3>Description</h3>

<p><code>reverse.parm</code> and <code>reverse.exclude</code> reverse the order of
variables in an interaction term.
</p>
<p><code>formatCands</code> creates new classes for lists containing candidate
models.
</p>
<p><code>formulaShort</code> prints a succinct formula from an <code>unmarkedFit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse.parm(parm)
reverse.exclude(exclude)
formatCands(cand.set)
formulaShort(mod, unmarked.type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modavg.utility_+3A_parm">parm</code></td>
<td>

<p>a parameter to be model-averaged, enclosed between quotes, as it appears
in the output of some models.
</p>
</td></tr>
<tr><td><code id="modavg.utility_+3A_exclude">exclude</code></td>
<td>

<p>a list of interaction or polynomial terms appearing in some models, as
they would appear in the call to the model function (i.e., <code>A*B</code>,
<code>A:B</code>).  Models containing elements from the list will be
excluded to obtain a model-averaged estimate.
</p>
</td></tr>
<tr><td><code id="modavg.utility_+3A_cand.set">cand.set</code></td>
<td>
<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="modavg.utility_+3A_mod">mod</code></td>
<td>
<p>an object storing the result of an <code>unmarkedFit</code>.
</p>
</td></tr>
<tr><td><code id="modavg.utility_+3A_unmarked.type">unmarked.type</code></td>
<td>
<p>a character string specifying the type of parameter in
an <code>unmarkedFit</code> for which a formula is requested.  This argument
uses the character string for each parameter group as defined by
<code>unmarked</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These utility functions are used internally by <code>aictab</code>,
<code>modavg</code>, and other related functions.
</p>
<p><code>reverse.parm</code> and <code>reverse.exclude</code> enable the user to
specify differently interaction terms (e.g., <code>A:B</code>, <code>B:A</code>)
across models for model averaging.  These functions have been added to
avoid problems when users are not consistent in the specification of
interaction terms across models.
</p>
<p><code>formatCands</code> creates new classes for the list of candidate
models based on the contents of the list.  These new classes are used
for method dispatch.
</p>
<p><code>formulaShort</code> is used by <code>anovaOD</code>.
</p>


<h3>Value</h3>

<p><code>reverse.parm</code> returns all possible combinations of an interaction
term to identify models that include the <code>parm</code> of interest and
find the corresponding estimate and standard error in the model object.
</p>
<p><code>reverse.exclude</code> returns a list of all possible combinations of
<code>exclude</code> to identify models that should be excluded when
computing a model-averaged estimate.
</p>
<p><code>formatCands</code> adds a new class to the list of candidate
models based on the classes of the models.
</p>
<p><code>formulaShort</code> creates a character string for the formula related
to a given parameter type from an <code>unmarkedFit</code> object.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+anovaOD">anovaOD</a></code>, <code><a href="#topic+modavg">modavg</a></code>,
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##a main effect
reverse.parm(parm = "Ageyoung") #does not return anything


##an interaction term as it might appear in the output
reverse.parm(parm = "Ageyoung:time") #returns the reverse


##exclude two interaction terms
reverse.exclude(exclude = list("Age*time", "A:B"))
##returns all combinations
reverse.exclude(exclude = list("Age:time", "A*B"))
##returns all combinations


##Mazerolle (2006) frog water loss example
data(dry.frog)

##setup a subset of models of Table 1
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)

formatCands(Cand.models)

## Not run: 
require(unmarked)
data(bullfrog)
bfrog &lt;- unmarkedFrameOccu(y = bullfrog[, c("V1", "V2", "V3", "V4")],
                           siteCovs = bullfrog[, 1:2])
fm1 &lt;- occu(~ 1 ~ Reed.presence, data = bfrog)
formulaShort(fm1, unmarked.type = "state")
formulaShort(fm1, unmarked.type = "det")

## End(Not run)
</code></pre>

<hr>
<h2 id='modavgCustom'>
Compute Model-averaged Parameter Estimate from User-supplied Input Based
on (Q)AIC(c)
</h2><span id='topic+modavgCustom'></span><span id='topic+print.modavgCustom'></span>

<h3>Description</h3>

<p>This function model-averages the estimate of a parameter of interest
among a set of candidate models, and computes the unconditional standard
error and unconditional confidence intervals as described in Buckland et
al. (1997) and Burnham and Anderson (2002). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modavgCustom(logL, K, modnames = NULL, estimate, se, second.ord = TRUE,
             nobs = NULL, uncond.se = "revised", conf.level = 0.95,
             c.hat = 1, useBIC = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modavgCustom_+3A_logl">logL</code></td>
<td>

<p>a vector of log-likelihood values for the models in the candidate
model set.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_k">K</code></td>
<td>

<p>a vector containing the number of estimated parameters for each
model in the candidate model set.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table.  If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_estimate">estimate</code></td>
<td>

<p>a vector of estimates for each of the models in the candidate model
set.  Estimates can be either beta estimates for a parameter of
interest or a single prediction from each model.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_se">se</code></td>
<td>

<p>a vector of standard errors for each of the estimates appearing in the
<code>estimate</code> vector.
</p>
</td></tr>  
<tr><td><code id="modavgCustom_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).  This argument is ignored if
<code>useBIC = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_nobs">nobs</code></td>
<td>

<p>the sample size required to compute the AICc, QAICc, BIC, or QBIC.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_uncond.se">uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
  "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of <code>c.hat</code>
different from 1 are only appropriate for binomial GLM's with trials &gt; 1
(i.e., success/trial or cbind(success, failure) syntax), with Poisson
GLM's, single-season and dynamic occupancy models (MacKenzie et
al. 2002, 2003), <em>N</em>-mixture models (Royle 2004, Dail and Madsen
2011), or capture-mark-recapture models (e.g., Lebreton et al. 1992).
If <code>c.hat</code> &gt; 1, <code>modavgCustom</code> will return the
quasi-likelihood analogue of the information criteria requested and
multiply the variance-covariance matrix of the estimates by this value
(i.e., SE's are multiplied by <code>sqrt(c.hat)</code>).
</p>
</td></tr>
<tr><td><code id="modavgCustom_+3A_usebic">useBIC</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the Bayesian information
criterion (BIC) when <code>c.hat = 1</code> or the quasi-likelihood BIC (QBIC)
when <code>c.hat &gt; 1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modavgCustom</code> computes a model-averaged estimate from the vector
of parameter estimates specified in <code>estimate</code>.  Estimates and
their associated standard errors must be specified in the same order as
the log-likelihood, number of estimated parameters, and model names.
Estimates provided may be for a parameter of interest (i.e., beta
estimates) or predictions from each model.  This function is most useful
when model input is imported into R from other software (e.g., Program
MARK, PRESENCE) or for model classes that are not yet supported by the
other model averaging functions such as <code>modavg</code> or
<code>modavgPred</code>.
</p>


<h3>Value</h3>

<p><code>modavgCustom</code> creates an object of class <code>modavgCustom</code> with
the following components: 
</p>
<table>
<tr><td><code>Mod.avg.table</code></td>
<td>
<p>the model selection table</p>
</td></tr>
<tr><td><code>Mod.avg.est</code></td>
<td>
<p>the model-averaged estimate</p>
</td></tr>
<tr><td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
estimate</p>
</td></tr>
<tr><td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval</p>
</td></tr> 
<tr><td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit</p>
</td></tr>
<tr><td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603&ndash;618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587.
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67&ndash;118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICcCustom">AICcCustom</a></code>, <code><a href="#topic+aictabCustom">aictabCustom</a></code>,
<code><a href="#topic+bictabCustom">bictabCustom</a></code>, <code><a href="#topic+modavg">modavg</a></code>,
<code><a href="#topic+modavgIC">modavgIC</a></code>, <code><a href="#topic+modavgShrink">modavgShrink</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##model averaging parameter estimate (natural average)
##vector with model LL's
LL &lt;- c(-38.8876, -35.1783, -64.8970)

##vector with number of parameters
Ks &lt;- c(7, 9, 4)

##create a vector of names to trace back models in set
Modnames &lt;- c("Cm1", "Cm2", "Cm3")

##vector of beta estimates for a parameter of interest
model.ests &lt;- c(0.0478, 0.0480, 0.0478)

##vector of SE's of beta estimates for a parameter of interest
model.se.ests &lt;- c(0.0028, 0.0028, 0.0034)

##compute model-averaged estimate and unconditional SE based on AICc
modavgCustom(logL = LL, K = Ks, modnames = Modnames, 
             estimate = model.ests, se = model.se.ests, nobs = 121)
##compute model-averaged estimate and unconditional SE based on BIC
modavgCustom(logL = LL, K = Ks, modnames = Modnames, 
             estimate = model.ests, se = model.se.ests, nobs = 121,
             useBIC = TRUE)


##model-averaging with shrinkage based on AICc
##set up candidate models
data(min.trap)
Cand.mod &lt;- list( )
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[2]] &lt;- glm(Num_anura ~ Type + Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[3]] &lt;- glm(Num_anura ~ log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort), data = min.trap)
Model.names &lt;- c("Type + log.Perimeter", "Type + Num_ranatra",
                 "log.Perimeter + Num_ranatra")
##model-averaged estimate with shrinkage (glm model type is already supported)
modavgShrink(cand.set = Cand.mod, modnames = Model.names,
             parm = "log.Perimeter")

##equivalent manual version of model-averaging with shrinkage
##this is especially useful when model classes are not supported
##extract vector of LL
LLs &lt;- sapply(Cand.mod, FUN = function(i) logLik(i)[1])
##extract vector of K
Ks &lt;- sapply(Cand.mod, FUN = function(i) attr(logLik(i), "df"))
##extract betas
betas &lt;- sapply(Cand.mod, FUN = function(i) coef(i)["log.Perimeter"])
##second model does not include log.Perimeter
betas[2] &lt;- 0
##extract SE's
ses &lt;- sapply(Cand.mod, FUN = function(i) sqrt(diag(vcov(i))["log.Perimeter"]))
ses[2] &lt;- 0
##model-averaging with shrinkage based on AICc
modavgCustom(logL = LLs, K = Ks, modnames = Model.names,
             nobs = nrow(min.trap), estimate = betas, se = ses)
##model-averaging with shrinkage based on BIC
modavgCustom(logL = LLs, K = Ks, modnames = Model.names,
             nobs = nrow(min.trap), estimate = betas, se = ses,
             useBIC = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='modavgEffect'>
Compute Model-averaged Effect Sizes (Multimodel Inference on Group Differences)
</h2><span id='topic+modavgEffect'></span><span id='topic+modavgEffect.default'></span><span id='topic+modavgEffect.AICaov.lm'></span><span id='topic+modavgEffect.AICglm.lm'></span><span id='topic+modavgEffect.AICgls'></span><span id='topic+modavgEffect.AIClm'></span><span id='topic+modavgEffect.AIClme'></span><span id='topic+modavgEffect.AICmer'></span><span id='topic+modavgEffect.AICglmerMod'></span><span id='topic+modavgEffect.AIClmerMod'></span><span id='topic+modavgEffect.AIClmerModLmerTest'></span><span id='topic+modavgEffect.AICnegbin.glm.lm'></span><span id='topic+modavgEffect.AICrlm.lm'></span><span id='topic+modavgEffect.AICsurvreg'></span><span id='topic+modavgEffect.AICunmarkedFitOccu'></span><span id='topic+modavgEffect.AICunmarkedFitColExt'></span><span id='topic+modavgEffect.AICunmarkedFitOccuRN'></span><span id='topic+modavgEffect.AICunmarkedFitPCount'></span><span id='topic+modavgEffect.AICunmarkedFitPCO'></span><span id='topic+modavgEffect.AICunmarkedFitDS'></span><span id='topic+modavgEffect.AICunmarkedFitGDS'></span><span id='topic+modavgEffect.AICunmarkedFitOccuFP'></span><span id='topic+modavgEffect.AICunmarkedFitMPois'></span><span id='topic+modavgEffect.AICunmarkedFitGMM'></span><span id='topic+modavgEffect.AICunmarkedFitGPC'></span><span id='topic+modavgEffect.AICunmarkedFitOccuTTD'></span><span id='topic+modavgEffect.AICunmarkedFitMMO'></span><span id='topic+modavgEffect.AICunmarkedFitDSO'></span><span id='topic+modavgEffect.AICunmarkedFitOccuMS'></span><span id='topic+modavgEffect.AICunmarkedFitOccuMulti'></span><span id='topic+print.modavgEffect'></span>

<h3>Description</h3>

<p>This function model-averages the effect size between two groups
defined by a categorical variable based on the entire model set and
computes the unconditional standard error and unconditional confidence
intervals as described in Buckland et al. (1997) and Burnham and
Anderson (2002).  This can be particularly useful when dealing with
data from an experiment (e.g., ANOVA) and when the focus is to
determine the effect of a given factor.  This is an
information-theoretic alternative to multiple comparisons (e.g.,
Burnham et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modavgEffect(cand.set, modnames = NULL, newdata, second.ord = TRUE,
             nobs = NULL, uncond.se = "revised", conf.level = 0.95,
             ...)

## S3 method for class 'AICaov.lm'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglm.lm'
modavgEffect(cand.set, modnames = NULL, newdata, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1, gamdisp = NULL,
        ...)

## S3 method for class 'AICgls'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClm'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClme'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICmer'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICglmerMod'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AIClmerMod'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerModLmerTest'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICnegbin.glm.lm'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICrlm.lm'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICsurvreg'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICunmarkedFitOccu'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavgEffect(cand.set, modnames =
       NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
       "revised", conf.level = 0.95, type = "response",
       c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modavgEffect_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_newdata">newdata</code></td>
<td>

<p>a data frame with two rows and where the columns correspond to the
explanatory variables specified in the candidate models. Note that this
data set must have the same structure as that of the original data frame
for which we want to make predictions, specifically, the same variable
type and names that appear in the original data set.  Each row of the
data set defines one of the two groups compared.  The first row in
<code>newdata</code> defines the first group, whereas the second row defines
the second group.  The effect size is computed as the prediction in the
first row minus the prediction in the second row (first row - second 
row). Only the column relating to the grouping variable can change value
and all others must be held constant for the comparison (see 'Details').
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order Akaike
information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows the specification of a numeric value other than
total sample size to compute the AICc (i.e., <code>nobs</code> defaults to
total number of observations).  This is relevant only for mixed models
or various models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the
value of <code>nobs</code>. 
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_uncond.se">uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
  "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.  Note that versions of package AICcmodavg &lt; 1.04 used the old
method to compute unconditional standard errors.
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of 
unconditional confidence intervals.  To obtain confidence intervals
corrected for multiple comparisons between pairs of treatments, it is
possible to adjust the <code class="reqn">\alpha</code> level according to various
strategies such as the Bonferroni correction (Dunn 1961).
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_type">type</code></td>
<td>

<p>the scale of prediction requested, one of <code>"response"</code> or
<code>"link"</code> (only relevant for <code>glm</code>, <code>mer</code>, and
<code>unmarkedFit</code> classes).  Note that the value <code>"terms"</code> is not
defined for <code>modavgEffect</code>).  
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such  
as that obtained from <code>c_hat</code>.  Note that values of <code>c.hat</code>
different from 1 are only appropriate for binomial GLM's with trials &gt; 1
(i.e., success/trial or cbind(success, failure) syntax), with Poisson
GLM's, single-season and dynamic occupancy models (MacKenzie et
al. 2002, 2003), or <em>N</em>-mixture models (Royle 2004, Dail and Madsen
2011).  If <code>c.hat &gt; 1</code>, <code>modavgEffect</code> will return the
quasi-likelihood analogue of the information criteria requested and
multiply the variance-covariance matrix of the estimates by this value
(i.e., SE's are multiplied by <code>sqrt(c.hat)</code>).  This option is not
supported for generalized linear mixed models of the <code>mer</code> class.
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_gamdisp">gamdisp</code></td>
<td>

<p>if gamma GLM is used, the dispersion parameter should be specified here
to apply the same value to each model.
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_parm.type">parm.type</code></td>
<td>

<p>this argument specifies the parameter type on which the effect size 
will be computed and is only relevant for models of <code>unmarkedFit</code>
classes.  The character strings supported vary with the type of model
fitted.  For <code>unmarkedFitOccu</code> objects, either <code>psi</code> or
<code>detect</code> can be supplied to indicate whether the parameter is on
occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuRN</code> objects, either <code>lambda</code> or
<code>detect</code> can be entered for abundance and detectability
parameters, respectively.  For <code>unmarkedFitPCount</code> and
<code>unmarkedFitMPois</code> objects, <code>lambda</code> or <code>detect</code> denote
parameters on abundance and detectability, respectively.  For
<code>unmarkedFitPCO</code>, <code>unmarkedFitMMO</code>, and
<code>unmarkedFitDSO</code> objects, one can enter <code>lambda</code>,
<code>gamma</code>, <code>omega</code>, <code>iota</code>, or <code>detect</code>, to specify
parameters on abundance, recruitment, apparent survival, immigration,
and detectability, respectively.  For <code>unmarkedFitDS</code> objects,
<code>lambda</code> and <code>detect</code> are supported.  For
<code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and <code>detect</code>
denote abundance, availability, and detection probability,
respectively.  For <code>unmarkedFitGMM</code> and <code>unmarkedFitGPC</code>
objects, <code>lambda</code>, <code>phi</code>, and <code>detect</code> denote
abundance, availability, and detectability, respectively.  For
<code>unmarkedFitOccuMS</code> objects, <code>psi</code>, <code>phi</code>, and
<code>detect</code> denote occupancy, transition, and detection probability,
respectively.  For <code>unmarkedFitOccuMulti</code> objects, <code>psi</code> and
<code>detect</code> denote occupancy and detection probability,
respectively.
</p>
</td></tr>
<tr><td><code id="modavgEffect_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strategy used here to compute effect sizes is to work from the
<code>newdata</code> object to create two predictions from a given model and
compute the differences and standard errors between both values.  This 
step is executed for each model in the candidate model set, to obtain a
model-averaged estimate of the effect size and unconditional standard
error.  As a result, the <code>newdata</code> argument is restricted to two
rows, each for a given prediction.  To specify each group, the values
entered in the column for each explanatory variable can be identical,
except for the grouping variable.  In such a case, the function will
identify the variable and the assign group names based on the values of 
the variable.  If more than a single variable has different values in
its respective column, the function will print generic names in the
output to identify the two groups.  A sensible choice of value for the 
explanatory variables to be held constant is the average of the
variable.
</p>
<p>Model-averaging effect sizes is most useful in true experiments (e.g.,
ANOVA-type designs), where one wants to obtain the best estimate of
effect size given the support of each candidate model. This can be
considered as a information-theoretic analog of traditional multiple
comparisons, except that the information contained in the entire model
set is used instead of being restricted to a single model.  See
'Examples' below for applications.
</p>
<p><code>modavgEffect</code> calls the appropriate method depending on the class
of objects in the list.  The current classes supported include
<code>aov</code>, <code>glm</code>, <code>gls</code>, <code>lm</code>, <code>lme</code>, <code>mer</code>,
<code>glmerMod</code>, <code>lmerMod</code>, <code>lmerModLmerTest</code>, <code>rlm</code>,
<code>survreg</code>, as well as models of <code>unmarkedFitOccu</code>,
<code>unmarkedFitColExt</code>, <code>unmarkedFitOccuFP</code>,
<code>unmarkedFitOccuRN</code>, <code>unmarkedFitOccuTTD</code>,
<code>unmarkedFitPCount</code>, <code>unmarkedFitPCO</code>, <code>unmarkedFitDS</code>,
<code>unmarkedFitDSO</code>, <code>unmarkedFitGDS</code>, <code>unmarkedFitMPois</code>,
<code>unmarkedFitGMM</code>, <code>unmarkedFitMMO</code>, <code>unmarkedFitGPC</code>,
<code>unmarkedFitOccuMS</code>, and <code>unmarkedFitOccuMulti</code>.
classes.
</p>


<h3>Value</h3>

<p>The result is an object of class <code>modavgEffect</code> with the following
components: 
</p>
<table>
<tr><td><code>Group.variable</code></td>
<td>
<p>the grouping variable defining the two groups
compared.</p>
</td></tr> 
<tr><td><code>Group1</code></td>
<td>
<p>the first group considered in the comparison.</p>
</td></tr>
<tr><td><code>Group2</code></td>
<td>
<p>the second group considered in the comparison.</p>
</td></tr>
<tr><td><code>Type</code></td>
<td>
<p>the scale on which the model-averaged effect size was
computed (e.g., response or link).</p>
</td></tr>
<tr><td><code>Mod.avg.table</code></td>
<td>
<p>the full model selection table including the
entire set of candidate models.</p>
</td></tr>
<tr><td><code>Mod.avg.eff</code></td>
<td>
<p>the model-averaged effect size based on the entire
candidate model set.</p>
</td></tr>
<tr><td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
effect size.</p>
</td></tr>
<tr><td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval.</p>
</td></tr> 
<tr><td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit.</p>
</td></tr>
<tr><td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit.</p>
</td></tr>
<tr><td><code>Matrix.output</code></td>
<td>
<p>a matrix containing the model-averaged effect size,
the unconditional standard error, and the lower and upper confidence
limits.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603&ndash;618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Burnham, K. P., Anderson, D. R., Huyvaert, K. P. (2011) AIC model
selection and multimodel inference in behaviorial ecology: some
background, observations and comparisons. <em>Behavioral Ecology and 
Sociobiology</em> <b>65</b>, 23&ndash;25. 
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587.
</p>
<p>Dunn, O. J. (1961) Multiple comparisons among means. <em>Journal of the
American Statistical Association</em> <b>56</b>, 52&ndash;64.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##heights (cm) of plants grown under two fertilizers, Ex. 9.5 from
##Zar (1984): Biostatistical Analysis. Prentice Hall: New Jersey.
heights &lt;- data.frame(Height = c(48.2, 54.6, 58.3, 47.8, 51.4, 52.0,
                        55.2, 49.1, 49.9, 52.6, 52.3, 57.4, 55.6, 53.2,
                        61.3, 58.0, 59.8, 54.8),
                      Fertilizer = c(rep("old", 10), rep("new", 8)))

##run linear model hypothesizing an effect of fertilizer
m1 &lt;- lm(Height ~ Fertilizer, data = heights)

##run null model (no effect of fertilizer)
m0 &lt;- lm(Height ~ 1, data = heights)

##assemble models in list
Cands &lt;- list(m1, m0)
Modnames &lt;- c("Fert", "null")

##compute model selection table to compare
##both hypotheses
aictab(cand.set = Cands, modnames = Modnames)
##note that model with fertilizer effect is much better supported
##than the null

##compute model-averaged effect sizes: one model hypothesizes a
##difference of 0, whereas the other assumes a difference

##prepare newdata object from which differences between groups
##will be computed
##the first row of the newdata data.frame relates to the first group,
##whereas the second row corresponds to the second group
pred.data &lt;- data.frame(Fertilizer = c("new", "old"))

##compute best estimate of effect size accounting for model selection
##uncertainty
modavgEffect(cand.set = Cands, modnames = Modnames,
              newdata = pred.data)


##classical one-way ANOVA type-design
## Not run: 
##generate data for two groups and control
set.seed(seed = 15)
y &lt;- round(c(rnorm(n = 15, mean = 10, sd = 5),
       rnorm(n = 15, mean = 15, sd = 5),
       rnorm(n = 15, mean = 12, sd = 5)), digits = 2)
##groups
group &lt;- c(rep("cont", 15), rep("trt1", 15), rep("trt2", 15))

##combine in data set
aov.data &lt;- data.frame(Y = y, Group = group)
rm(y, group)

##run model with group effect
lm.eff &lt;- lm(Y ~ Group, data = aov.data)
##null model
lm.0 &lt;- lm(Y ~ 1, data = aov.data)

##compare both models
Cands &lt;- list(lm.eff, lm.0)
Mods &lt;- c("group effect", "no group effect")
aictab(cand.set = Cands, modnames = Mods)
##model with group effect has most of the weight

##compute model-averaged effect sizes
##trt1 - control
modavgEffect(cand.set = Cands, modnames = Modnames,
              newdata = data.frame(Group = c("trt1", "cont")))
##trt1 differs from cont

##trt2 - control
modavgEffect(cand.set = Cands, modnames = Modnames,
              newdata = data.frame(Group = c("trt2", "cont")))
##trt2 does not differ from cont

## End(Not run)


##two-way ANOVA type design, Ex. 13.1 (Zar 1984) of plasma calcium
##concentration (mg/100 ml) in birds as a function of sex and hormone
##treatment
## Not run: 
birds &lt;- data.frame(Ca = c(16.87, 16.18, 17.12, 16.83, 17.19, 15.86,
                      14.92, 15.63, 15.24, 14.8, 19.07, 18.77, 17.63,
                      16.99, 18.04, 17.2, 17.64, 17.89, 16.78, 16.92,
                      32.45, 28.71, 34.65, 28.79, 24.46, 30.54, 32.41,
                      28.97, 28.46, 29.65),
                    Sex = c("M", "M", "M", "M", "M", "F", "F", "F", "F",
                      "F", "M", "M", "M", "M", "M", "F", "F", "F", "F",
                      "F", "M", "M", "M", "M", "M", "F", "F", "F", "F",
                      "F"),
                    Hormone = as.factor(c(1, 1, 1, 1, 1, 1, 1, 1, 1,
                      1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                      3, 3, 3, 3, 3)))

##candidate models
##interactive effects
m.inter &lt;- lm(Ca ~ Sex + Hormone + Sex:Hormone, data = birds)

##additive effects
m.add &lt;- lm(Ca ~ Sex + Hormone, data = birds)

##Sex only
m.sex &lt;- lm(Ca ~ Sex, data = birds)

##Hormone only
m.horm &lt;- lm(Ca ~ Hormone, data = birds)

##null
m.0 &lt;- lm(Ca ~ 1, data = birds)

##model selection
Cands &lt;- list(m.inter, m.add, m.sex, m.horm, m.0)
Mods &lt;- c("interaction", "additive", "sex only", "horm only", "null")
aictab(Cands, Mods)
##there is some support for a hormone only treatment, but also for
##additive effects

##compute model-averaged effects of sex, and set the other variable
##to a constant value
##M - F
sex.data &lt;- data.frame(Sex = c("M", "F"), Hormone = c("1", "1"))
modavgEffect(Cands, Mods, newdata = sex.data)
##no support for a sex main effect

##hormone 1 - 3, but set Sex to a constant value
horm1.data &lt;- data.frame(Sex = c("M", "M"), Hormone = c("1", "3"))
modavgEffect(Cands, Mods, newdata = horm1.data)

##hormone 2 - 3, but set Sex to a constant value
horm2.data &lt;- data.frame(Sex = c("M", "M"), Hormone = c("2", "3"))
modavgEffect(Cands, Mods, newdata = horm2.data)

## End(Not run)


##Poisson regression with anuran larvae example from Mazerolle (2006)
## Not run: 
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##set up candidate models          
Cand.mod &lt;- list( )
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[2]] &lt;- glm(Num_anura ~ log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[3]] &lt;- glm(Num_anura ~ Type, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[4]] &lt;- glm(Num_anura ~ 1, family = poisson,
                     offset = log(Effort), data = min.trap) 
          
##check c-hat for global model
vif.hat &lt;- c_hat(Cand.mod[[1]]) #uses Pearson's chi-square/df

##assign names to each model
Modnames &lt;- c("type + logperim", "type", "logperim", "intercept only") 

##compute model-averaged estimate of difference between abundance at bog
##pond and upland pond
##create newdata object to make predictions
pred.data &lt;- data.frame(Type = c("BOG", "UPLAND"),
                        log.Perimeter = mean(min.trap$log.Perimeter),
                        Effort = mean(min.trap$Effort))
modavgEffect(Cand.mod, Modnames, newdata = pred.data, c.hat = vif.hat,
             type = "response")
##little suport for a pond type effect

## End(Not run)


##mixed linear model example from ?nlme
## Not run: 
library(nlme)
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lme(distance ~ age, data = Orthodont, method="ML")
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1, method="ML")
Cand.models[[3]] &lt;-lme(distance ~ 1, data = Orthodont, random = ~ 1,
                       method="ML")
Cand.models[[4]] &lt;-lme(distance ~ Sex, data = Orthodont, random = ~ 1,
                       method="ML")

Modnames &lt;- c("age", "age + sex", "null", "sex")

data.other &lt;- data.frame(age = mean(Orthodont$age),
                         Sex = factor(c("Male", "Female"))) 
modavgEffect(cand.set = Cand.models, modnames = Modnames,
             newdata = data.other, conf.level = 0.95, second.ord = TRUE,
             nobs = NULL, uncond.se = "revised")
detach(package:nlme)

## End(Not run)


##site occupancy analysis example
## Not run: 
library(unmarked)
##single season model
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
##create a bogus site group
site.group &lt;- c(rep(1, times = nrow(pfer.bin)/2), rep(0, nrow(pfer.bin)/2))

## add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(site.group, sitevar1 =
                                rnorm(numSites(pferUMF)),
                                sitevar2 = runif(numSites(pferUMF)))
     
## observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 =
                               rnorm(numSites(pferUMF) * obsNum(pferUMF)))
     
fm1 &lt;- occu(~ obsvar1 ~ site.group, pferUMF)
fm2 &lt;- occu(~ obsvar1 ~ 1, pferUMF)

Cand.mods &lt;- list(fm1, fm2)
Modnames &lt;- c("fm1", "fm2")

##model selection table
aictab(cand.set = Cand.mods, modnames = Modnames, second.ord = TRUE)

##model-averaged effect sizes comparing site.group 1 - site.group 0
newer.dat &lt;- data.frame(site.group = c(0, 1))

modavgEffect(cand.set = Cand.mods, modnames = Modnames, type = "response",
              second.ord = TRUE, newdata = newer.dat, parm.type = "psi")
##no support for an effect of site group

## End(Not run)


##single season N-mixture models
## Not run: 
data(mallard)
##this variable was created to illustrate the use of modavgEffect
##with detection variables
mallard.site$site.group &lt;- c(rep(1, 119), rep(0, 120))
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
siteCovs(mallardUMF)
tmp.covs &lt;- obsCovs(mallardUMF)
obsCovs(mallardUMF)$date2 &lt;- tmp.covs$date^2
(fm.mall &lt;- pcount(~ site.group ~ length + elev + forest, mallardUMF, K=30))
(fm.mallb &lt;- pcount(~ 1 ~ length + elev + forest, mallardUMF, K=30))
     
Cands &lt;- list(fm.mall, fm.mallb)
Modnames &lt;- c("one", "null")

##model averaged effect size of site.group 1 - site.group 0 on response
##scale (point estimate)
modavgEffect(Cands, Modnames, newdata = data.frame(site.group = c(0, 1)),
              parm.type = "detect", type = "response")

##model averaged effect size of site.group 1 - site.group 0 on link
##scale (here, logit link)
modavgEffect(Cands, Modnames, newdata = data.frame(site.group = c(0, 1)),
              parm.type = "detect", type = "link")

detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='modavgIC'>
Compute Model-averaged Parameter Estimate from User-supplied Information
Criterion
</h2><span id='topic+modavgIC'></span><span id='topic+print.modavgIC'></span>

<h3>Description</h3>

<p>This function model-averages the estimate of a parameter of interest
among a set of candidate models, and computes the unconditional standard
error and unconditional confidence intervals as described in Buckland et
al. (1997) and Burnham and Anderson (2002).  Computations are based on
the values of the information criterion supplied manually by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modavgIC(ic, K, modnames = NULL, estimate, se, uncond.se = "revised",
         conf.level = 0.95, ic.name = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modavgIC_+3A_ic">ic</code></td>
<td>

<p>a vector of information criterion values for each model in the candidate
model set.
</p>
</td></tr>
<tr><td><code id="modavgIC_+3A_k">K</code></td>
<td>

<p>a vector containing the number of estimated parameters for each
model in the candidate model set.
</p>
</td></tr>
<tr><td><code id="modavgIC_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to identify each model in the
model selection table.  If <code>NULL</code>, generic names (e.g.,
<code>Mod1</code>, <code>Mod2</code>) are supplied in the table in the same
order as the information criterion values.
</p>
</td></tr>
<tr><td><code id="modavgIC_+3A_estimate">estimate</code></td>
<td>

<p>a vector of estimates for each of the models in the candidate model
set.  Estimates can be either beta estimates for a parameter of
interest or a single prediction from each model.
</p>
</td></tr>
<tr><td><code id="modavgIC_+3A_se">se</code></td>
<td>

<p>a vector of standard errors for each of the estimates appearing in the
<code>estimate</code> vector.
</p>
</td></tr>  
<tr><td><code id="modavgIC_+3A_uncond.se">uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
      "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.
</p>
</td></tr>
<tr><td><code id="modavgIC_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td></tr>
<tr><td><code id="modavgIC_+3A_ic.name">ic.name</code></td>
<td>

<p>a character string denoting the name of the information criterion
input by the user.  This character string will appear in certain
column labels of the model selection table.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modavgIC</code> computes a model-averaged estimate from the vector
of parameter estimates specified in <code>estimate</code>.  Estimates and
their associated standard errors must be specified in the same order
as the values of the information criterion, the number of estimated
parameters, and the model names.  Estimates provided may be for a
parameter of interest (i.e., beta estimates) or predictions from each
model.  This function is most useful for information criterion other
than AIC, AICc, QAIC, and QAICc (e.g., WAIC: Watanabe 2010) or for
classes not supported by <code>modavg</code>, <code>modavgCustom</code>, or
<code>modavgPred</code>.
</p>


<h3>Value</h3>

<p><code>modavgIC</code> creates an object of class <code>modavgIC</code> with
the following components: 
</p>
<table>
<tr><td><code>Mod.avg.table</code></td>
<td>
<p>the model selection table.</p>
</td></tr>
<tr><td><code>Mod.avg.est</code></td>
<td>
<p>the model-averaged estimate.</p>
</td></tr>
<tr><td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
estimate.</p>
</td></tr>
<tr><td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval.</p>
</td></tr> 
<tr><td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit.</p>
</td></tr>
<tr><td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603&ndash;618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Watanabe, S. (2010) Asymptotic equivalence of Bayes cross validation and
widely applicable information criterion in singular learning
theory. <em>Journal of Machine Learning Research</em> <b>11</b>,
3571&ndash;3594. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictabCustom">aictabCustom</a></code>, <code><a href="#topic+ictab">ictab</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>,
<code><a href="#topic+modavgShrink">modavgShrink</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##model averaging parameter estimate based on WAIC
##create a vector of names to trace back models in set
Modnames &lt;- c("global model", "interactive model",
              "additive model", "invertpred model")

##WAIC values
waic &lt;- c(105.74, 107.36, 108.24, 100.57)
##number of effective parameters
effK &lt;- c(7.45, 5.61, 6.14, 6.05)

##vector of predictions
Preds &lt;- c(0.106, 0.137, 0.067, 0.050)
##vector of SE's for prediction
Ses &lt;- c(0.128, 0.159, 0.054, 0.039)

##compute model-averaged estimate and unconditional SE based on WAIC
modavgIC(ic = waic, K = effK, modnames = Modnames, 
         estimate = Preds, se = Ses,
         ic.name = "WAIC")

## End(Not run)
</code></pre>

<hr>
<h2 id='modavgPred'>
Compute Model-averaged Predictions
</h2><span id='topic+modavgPred'></span><span id='topic+modavgPred.default'></span><span id='topic+modavgPred.AICaov.lm'></span><span id='topic+modavgPred.AICglm.lm'></span><span id='topic+modavgPred.AICgls'></span><span id='topic+modavgPred.AIClm'></span><span id='topic+modavgPred.AIClme'></span><span id='topic+modavgPred.AICglmerMod'></span><span id='topic+modavgPred.AIClmerMod'></span><span id='topic+modavgPred.AIClmerModLmerTest'></span><span id='topic+modavgPred.AICmer'></span><span id='topic+modavgPred.AICnegbin.glm.lm'></span><span id='topic+modavgPred.AICrlm.lm'></span><span id='topic+modavgPred.AICsurvreg'></span><span id='topic+modavgPred.AICunmarkedFitOccu'></span><span id='topic+modavgPred.AICunmarkedFitColExt'></span><span id='topic+modavgPred.AICunmarkedFitOccuRN'></span><span id='topic+modavgPred.AICunmarkedFitPCount'></span><span id='topic+modavgPred.AICunmarkedFitPCO'></span><span id='topic+modavgPred.AICunmarkedFitDS'></span><span id='topic+modavgPred.AICunmarkedFitGDS'></span><span id='topic+modavgPred.AICunmarkedFitOccuFP'></span><span id='topic+modavgPred.AICunmarkedFitMPois'></span><span id='topic+modavgPred.AICunmarkedFitGMM'></span><span id='topic+modavgPred.AICunmarkedFitGPC'></span><span id='topic+modavgPred.AICunmarkedFitOccuTTD'></span><span id='topic+modavgPred.AICunmarkedFitMMO'></span><span id='topic+modavgPred.AICunmarkedFitDSO'></span><span id='topic+modavgPred.AICunmarkedFitOccuMS'></span><span id='topic+modavgPred.AICunmarkedFitOccuMulti'></span><span id='topic+print.modavgPred'></span>

<h3>Description</h3>

<p>This function computes the model-averaged predictions, unconditional
standard errors, and confidence intervals  based on the entire candidate
model set.  The function is currently implemented for <code>glm</code>,
<code>gls</code>, <code>lm</code>, <code>lme</code>, <code>mer</code>, <code>merMod</code>,
<code>lmerModLmerTest</code>, <code>negbin</code>, <code>rlm</code>, <code>survreg</code> object
classes that are stored in a list as well as various models of
<code>unmarkedFit</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modavgPred(cand.set, modnames = NULL, newdata, second.ord = TRUE,
           nobs = NULL, uncond.se = "revised", conf.level = 0.95, ...)

## S3 method for class 'AICaov.lm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICglm.lm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        gamdisp = NULL, ...)

## S3 method for class 'AIClm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICgls'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AIClme'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICmer'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1, ...)

## S3 method for class 'AICglmerMod'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1, ...)

## S3 method for class 'AIClmerMod'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerModLmerTest'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICnegbin.glm.lm'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICrlm.lm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICsurvreg'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...) 

## S3 method for class 'AICunmarkedFitOccu'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised", 
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)  

## S3 method for class 'AICunmarkedFitOccuRN'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitPCO'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitGDS'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modavgPred_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_newdata">newdata</code></td>
<td>

<p>a data frame with the same structure as that of the original data frame
for which we want to make predictions.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total
sample size to compute the AICc (i.e., <code>nobs</code> defaults to total
number of observations).  This is relevant only for mixed models or
various models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the
value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_uncond.se">uncond.se</code></td>
<td>
<p>either, <code>old</code>, or <code>revised</code>, specifying the
equation used to compute the unconditional standard error of a
model-averaged estimate.  With <code>uncond.se = "old"</code>,
computations are based on equation 4.9 of Burnham and Anderson
(2002), which was the former way to compute unconditional standard
errors.  With <code>uncond.se = "revised"</code>, equation 6.12 of Burnham
and Anderson (2002) is used.  Anderson (2008, p. 111) recommends use
of the revised version for the computation of unconditional standard
errors and it is now the default.  Note that versions of package
AICcmodavg &lt; 1.04 used the old method to compute unconditional
standard errors.  
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_type">type</code></td>
<td>

<p>the scale of prediction requested, one of <code>response</code> or
<code>link</code>.  The latter is only relevant for <code>glm</code>, <code>mer</code>,
and <code>unmarkedFit</code> classes.  Note that the value <code>terms</code> is not
defined for <code>modavgPred</code>. 
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of <code>c.hat</code>
different from 1 are only appropriate for binomial GLM's with trials &gt; 1
(i.e., success/trial or cbind(success, failure) syntax), with Poisson
GLM's, single-season and dynamic occupancy models (MacKenzie et
al. 2002, 2003), or <em>N</em>-mixture models (Royle 2004, Dail and Madsen
2011).  If <code>c.hat &gt; 1</code>, <code>modavgPred</code> will return the
quasi-likelihood analogue of the information criteria requested and
multiply the variance-covariance matrix of the estimates by this value
(i.e., SE's are multiplied by <code>sqrt(c.hat)</code>).  This option is not
supported for generalized linear mixed models of the <code>mer</code> class.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_gamdisp">gamdisp</code></td>
<td>

<p>the value of the gamma dispersion parameter.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_parm.type">parm.type</code></td>
<td>
<p>  this argument specifies the parameter type on which
the predictions will be computed and is only relevant for models of
<code>unmarkedFit</code> classes.  The character strings supported vary with
the type of model fitted.  For <code>unmarkedFitOccu</code> objects, either
<code>psi</code> or <code>detect</code> can be supplied to indicate whether the
parameter is on occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuRN</code> objects, either <code>lambda</code> or
<code>detect</code> can be entered for abundance and detectability
parameters, respectively.  For <code>unmarkedFitPCount</code> and
<code>unmarkedFitMPois</code> objects, <code>lambda</code> or <code>detect</code> denote
parameters on abundance and detectability, respectively.  For
<code>unmarkedFitPCO</code>, <code>unmarkedFitMMO</code>, and
<code>unmarkedFitDSO</code> objects, one can enter <code>lambda</code>,
<code>gamma</code>, <code>omega</code>, <code>iota</code>, or <code>detect</code>, to specify
parameters on abundance, recruitment, apparent survival, immigration,
and detectability, respectively.  For <code>unmarkedFitDS</code> objects,
<code>lambda</code> and <code>detect</code> are supported.  For
<code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and <code>detect</code>
denote abundance, availability, and detection probability,
respectively.  For <code>unmarkedFitGMM</code> and <code>unmarkedFitGPC</code>
objects, <code>lambda</code>, <code>phi</code>, and <code>detect</code> denote
abundance, availability, and detectability, respectively.  For
<code>unmarkedFitOccuMS</code> objects, <code>psi</code>, <code>phi</code>, and
<code>detect</code> denote occupancy, transition, and detection probability,
respectively.  For <code>unmarkedFitOccuMulti</code> objects, <code>psi</code> and
<code>detect</code> denote occupancy and detection probability,
respectively.
</p>
</td></tr>
<tr><td><code id="modavgPred_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The candidate models must be stored in a list.  Note that a data frame
from which to make predictions must be supplied with the <code>newdata</code>
argument and that all variables appearing in the model set must appear
in this data frame.  Variables must be of the same type as in the
original analysis (e.g., factor, numeric).
</p>
<p>One can compute unconditional confidence intervals around the
predictions from the elements returned by <code>modavgPred</code>.  The
classic computation based on asymptotic normality of the estimator is
appropriate to estimate confidence intervals on the linear predictor
(i.e., link scale).  For predictions of some types of response
variables such as counts or binary variables, the normal approximation
may be inappropriate.  In such cases, it is often better to compute
the confidence intervals on the linear predictor scale and then
back-transform the limits to the scale of the response variable.
These are the confidence intervals returned by <code>modavgPred</code>.
Burnham et al. (1987), Burnham and Anderson (2002, p. 164), and 
Williams et al. (2002) suggest alternative methods of computing
confidence intervals for small degrees of freedom with profile
likelihood intervals or bootstrapping, but these approaches are not
yet implemented in <code>modavgPred</code>.
</p>


<h3>Value</h3>

<p><code>modavgPred</code> returns an object of class <code>modavgPred</code> with the 
following components:
</p>
<table>
<tr><td><code>type</code></td>
<td>

<p>the scale of predicted values (response or link) for <code>glm</code>, <code>mer</code>,
<code>merMod</code>, or <code>unmarkedFit</code> classes.
</p>
</td></tr>
<tr><td><code>mod.avg.pred</code></td>
<td>

<p>the model-averaged prediction over the entire candidate model set.
</p>
</td></tr>
<tr><td><code>uncond.se</code></td>
<td>

<p>the unconditional standard error of each model-averaged prediction.
</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>

<p>the confidence level used to compute the confidence
interval.
</p>
</td></tr> 
<tr><td><code>lower.CL</code></td>
<td>
<p>the lower confidence limit.
</p>
</td></tr>
<tr><td><code>upper.CL</code></td>
<td>
<p>the upper confidence limit.
</p>
</td></tr>
<tr><td><code>matrix.output</code></td>
<td>
<p>a matrix with rows consisting of the model-averaged
predictions, the unconditional standard errors, and the confidence
limits.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R., White, G. C., Brownie, C., Pollock,
K. H. (1987) Design and analysis methods for fish survival experiments
based on release-recapture. <em>American Fisheries Society Monographs</em>
<b>5</b>, 1&ndash;437.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.  
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>
<p>Williams, B. K., Nichols, J. D., Conroy, M. J. (2002) <em>Analysis and
Management of Animal Populations</em>. Academic Press: New York. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>, 
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>,
<code><a href="#topic+modavgEffect">modavgEffect</a></code>, <code><a href="#topic+modavgShrink">modavgShrink</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+predictSE">predictSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##example from subset of models in Table 1 in Mazerolle (2006)
data(dry.frog)

Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)

##setup model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

##compute model-averaged value and unconditional SE of predicted log of
##mass lost for frogs of average mass in shade for each substrate type

##first create data set to use for predictions
new.dat &lt;- data.frame(Shade = c(1, 1, 1),
                      cent_Initial_mass = c(0, 0, 0),
                      Initial_mass2 = c(0, 0, 0),
                      Substrate = c("SOIL", "SPHAGNUM", "PEAT")) 

##compare unconditional SE's using both methods
modavgPred(cand.set = Cand.models, modnames = Modnames,
           newdata = new.dat, type = "response", uncond.se = "old")
modavgPred(cand.set = Cand.models, modnames = Modnames,
           newdata = new.dat, type = "response", uncond.se = "revised")
##round to 4 digits after decimal point
print(modavgPred(cand.set = Cand.models, modnames = Modnames,
                 newdata = new.dat, type = "response",
                 uncond.se = "revised"), digits = 4)



##Gamma glm
## Not run: 
##clotting data example from 'gamma.shape' in MASS package of
##Venables and Ripley (2002, Modern applied statistics with
##S. Springer-Verlag: New York.)
clotting &lt;- data.frame(u = c(5, 10, 15, 20, 30, 40, 60, 80, 100),
                       lot1 = c(118, 58, 42, 35, 27, 25, 21, 19, 18),
                       lot2 = c(69, 35, 26, 21, 18, 16, 13, 12, 12))
clot1 &lt;- glm(lot1 ~ log(u), data = clotting, family = Gamma)

require(MASS)
gamma.dispersion(clot1) #dispersion parameter
gamma.shape(clot1) #reciprocal of dispersion parameter ==
##shape parameter 
summary(clot1, dispersion = gamma.dispersion(clot1))  #better

##create list with models
Cand &lt;- list( )
Cand[[1]] &lt;- glm(lot1 ~ log(u), data = clotting, family = Gamma)
Cand[[2]] &lt;- glm(lot1 ~ 1, data = clotting, family = Gamma)

##create vector of model names
Modnames &lt;- paste("mod", 1:length(Cand), sep = "")

##compute model-averaged predictions on scale of response variable for
##all observations
modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           gamdisp = gamma.dispersion(clot1), type = "response") 

##compute model-averaged predictions on scale of linear predictor
modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           gamdisp = gamma.dispersion(clot1), type = "link")

##compute model-averaged predictions on scale of linear predictor
modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           gamdisp = gamma.dispersion(clot1), type = "terms") #returns an error
##because type = "terms" is not defined for 'modavgPred'

modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           type = "terms") #returns an error because
##no gamma dispersion parameter was specified (i.e., 'gamdisp' missing) 

## End(Not run)


##example of model-averaged predictions from N-mixture model
##each variable appears twice in the models - this is a bit longer
## Not run: 
require(unmarked)
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##set up models so that each variable on abundance appears twice
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF,
                      K = 30)
fm.mall.two &lt;- pcount(~ ivel + date  ~ elev + forest, mallardUMF,
                      K = 30)
fm.mall.three &lt;- pcount(~ ivel + date  ~ length + elev, mallardUMF,
                        K = 30)
fm.mall.four &lt;- pcount(~ ivel + date  ~ 1, mallardUMF, K = 30)

##model list
Cands &lt;- list(fm.mall.one, fm.mall.two, fm.mall.three, fm.mall.four)
Modnames &lt;- c("length + forest", "elev + forest", "length + elev",
              "null")

##compute model-averaged predictions of abundance for values of elev
modavgPred(cand.set = Cands, modnames = Modnames, newdata =
           data.frame(elev = seq(from = -1.4, to = 2.4, by = 0.1),
                      length = 0, forest = 0), parm.type = "lambda",
           type = "response")

##compute model-averaged predictions of detection for values of ivel
modavgPred(cand.set = Cands, modnames = Modnames, newdata =
           data.frame(ivel = seq(from = -1.75, to = 5.9, by = 0.5),
                      date = 0), parm.type = "detect",
           type = "response")
detach(package:unmarked)

## End(Not run)


##example of model-averaged abundance from distance model
## Not run: 
##this is a bit longer
data(linetran) #example from ?distsamp
     
ltUMF &lt;- with(linetran, {
  unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
                  siteCovs = data.frame(Length, area, habitat),
                  dist.breaks = c(0, 5, 10, 15, 20),
                  tlength = linetran$Length * 1000, survey = "line",
                  unitsIn = "m")
})
     
## Half-normal detection function. Density output (log scale). No covariates.
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
     
## Halfnormal. Covariates affecting both density and and detection.
fm2 &lt;- distsamp(~area + habitat ~ habitat, ltUMF)

## Hazard function. Covariates affecting both density and and detection.
fm3 &lt;- distsamp(~area + habitat ~ habitat, ltUMF, keyfun="hazard")

##assemble model list
Cands &lt;- list(fm1, fm2, fm3)
Modnames &lt;- paste("mod", 1:length(Cands), sep = "")

##model-average predictions on abundance
modavgPred(cand.set = Cands, modnames = Modnames, parm.type = "lambda", type = "link",
           newdata = data.frame(area = mean(linetran$area), habitat = c("A", "B")))
detach(package:unmarked)

## End(Not run)



##example using Orthodont data set from Pinheiro and Bates (2000)
## Not run: 
require(nlme)

##set up candidate models
m1 &lt;- gls(distance ~ age, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

m2 &lt;- gls(distance ~ 1, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

##assemble in list
Cand.models &lt;- list(m1, m2)
##model names
Modnames &lt;- c("age effect", "null model")

##model selection table
aictab(cand.set = Cand.models, modnames = Modnames)

##model-averaged predictions
modavgPred(cand.set = Cand.models, modnames = Modnames, newdata =
data.frame(age = c(8, 10, 12, 14)))
detach(package:nlme)

## End(Not run)
</code></pre>

<hr>
<h2 id='modavgShrink'>
Compute Model-averaged Parameter Estimate with Shrinkage (Multimodel Inference)
</h2><span id='topic+modavgShrink'></span><span id='topic+modavgShrink.default'></span><span id='topic+modavgShrink.AICaov.lm'></span><span id='topic+modavgShrink.AICbetareg'></span><span id='topic+modavgShrink.AICsclm.clm'></span><span id='topic+modavgShrink.AICclm'></span><span id='topic+modavgShrink.AICclmm'></span><span id='topic+modavgShrink.AICcoxme'></span><span id='topic+modavgShrink.AICcoxph'></span><span id='topic+modavgShrink.AICglm.lm'></span><span id='topic+modavgShrink.AICglmmTMB'></span><span id='topic+modavgShrink.AICgls'></span><span id='topic+modavgShrink.AIChurdle'></span><span id='topic+modavgShrink.AIClm'></span><span id='topic+modavgShrink.AIClme'></span><span id='topic+modavgShrink.AIClmekin'></span><span id='topic+modavgShrink.AICmaxlikeFit.list'></span><span id='topic+modavgShrink.AICmer'></span><span id='topic+modavgShrink.AICglmerMod'></span><span id='topic+modavgShrink.AIClmerMod'></span><span id='topic+modavgShrink.AIClmerModLmerTest'></span><span id='topic+modavgShrink.AICmultinom.nnet'></span><span id='topic+modavgShrink.AICnegbin.glm.lm'></span><span id='topic+modavgShrink.AICpolr'></span><span id='topic+modavgShrink.AICrlm.lm'></span><span id='topic+modavgShrink.AICsurvreg'></span><span id='topic+modavgShrink.AICvglm'></span><span id='topic+modavgShrink.AICzeroinfl'></span><span id='topic+modavgShrink.AICunmarkedFitOccu'></span><span id='topic+modavgShrink.AICunmarkedFitColExt'></span><span id='topic+modavgShrink.AICunmarkedFitOccuRN'></span><span id='topic+modavgShrink.AICunmarkedFitPCount'></span><span id='topic+modavgShrink.AICunmarkedFitPCO'></span><span id='topic+modavgShrink.AICunmarkedFitDS'></span><span id='topic+modavgShrink.AICunmarkedFitGDS'></span><span id='topic+modavgShrink.AICunmarkedFitOccuFP'></span><span id='topic+modavgShrink.AICunmarkedFitMPois'></span><span id='topic+modavgShrink.AICunmarkedFitGMM'></span><span id='topic+modavgShrink.AICunmarkedFitGPC'></span><span id='topic+modavgShrink.AICunmarkedFitOccuMulti'></span><span id='topic+modavgShrink.AICunmarkedFitOccuMS'></span><span id='topic+modavgShrink.AICunmarkedFitOccuTTD'></span><span id='topic+modavgShrink.AICunmarkedFitMMO'></span><span id='topic+modavgShrink.AICunmarkedFitDSO'></span><span id='topic+print.modavgShrink'></span>

<h3>Description</h3>

<p>This function computes an alternative version of model-averaging
parameter estimates that consists in shrinking estimates toward 0 to
reduce model selection bias as in Burnham and Anderson (2002, p. 152),
Anderson (2008, pp. 130-132) and Lukacs et al. (2010).  Specifically,
models without the parameter of interest have an estimate and variance
of 0.  <code>modavgShrink</code> also returns unconditional standard errors
and unconditional confidence intervals as described in Buckland et
al. (1997) and Burnham and Anderson (2002). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modavgShrink(cand.set, parm, modnames = NULL, second.ord = TRUE,
              nobs = NULL, uncond.se = "revised", conf.level = 0.95,
              ...)
## S3 method for class 'AICaov.lm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICbetareg'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICsclm.clm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICclm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICclmm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICcoxme'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICcoxph'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglm.lm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, gamdisp = NULL, ...)

## S3 method for class 'AICgls'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglmmTMB'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AIChurdle'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClme'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmekin'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICmer'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglmerMod'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerMod'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerModLmerTest'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICmaxlikeFit.list'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AICmultinom.nnet'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AICnegbin.glm.lm'
modavgShrink(cand.set, parm, modnames = NULL, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICpolr'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICrlm.lm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICsurvreg'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICvglm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICunmarkedFitOccu'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavgShrink(cand.set, parm, modnames
           = NULL, second.ord = TRUE, nobs = NULL, uncond.se =
           "revised", conf.level = 0.95, c.hat = 1, parm.type = NULL,
           ...)

## S3 method for class 'AICunmarkedFitOccuRN'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modavgShrink_+3A_cand.set">cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_parm">parm</code></td>
<td>

<p>the parameter of interest, enclosed between quotes, for which a
model-averaged estimate is required.  For a categorical variable, 
the label of the estimate must be included as it appears in the output
(see 'Details' below). 
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_modnames">modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order Akaike
information criterion (i.e., AICc).
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total
sample size to compute the AICc (i.e., <code>nobs</code> defaults to total
number of observations).  This is relevant only for mixed models or
various models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the
value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_uncond.se">uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
    "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.  Note that versions of package AICcmodavg &lt; 1.04 used the old
method to compute unconditional standard errors.  
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>modavgShrink</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_gamdisp">gamdisp</code></td>
<td>

<p>if gamma GLM is used, the dispersion parameter should be specified here
to apply the same value to each model.
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_parm.type">parm.type</code></td>
<td>

<p>this argument specifies the parameter type on which the
model-averaged estimate of a predictor will be computed and is only
relevant for models of <code>unmarkedFit</code> classes.  The character
strings supported vary with the type of model fitted.  For
<code>unmarkedFitOccu</code> objects, either <code>psi</code> or <code>detect</code>
can be supplied to indicate whether the parameter is on occupancy or
detectability, respectively.  For <code>unmarkedFitColExt</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and detectability, respectively.  For
<code>unmarkedFitOccuTTD</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
time-to-dection (lambda rate parameter), respectively.  For
<code>unmarkedFitOccuFP</code> objects, one can specify <code>psi</code>,
<code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for occupancy,
detectability, probability of assigning false-positives, and
probability detections are certain, respectively.  For
<code>unmarkedFitOccuRN</code> objects, either <code>lambda</code> or
<code>detect</code> can be entered for abundance and detectability
parameters, respectively.  For <code>unmarkedFitPCount</code> and
<code>unmarkedFitMPois</code> objects, <code>lambda</code> or <code>detect</code>
denote parameters on abundance and detectability, respectively.  For
<code>unmarkedFitPCO</code>, <code>unmarkedFitMMO</code>, and
<code>unmarkedFitDSO</code> objects, one can enter <code>lambda</code>,
<code>gamma</code>, <code>omega</code>, <code>iota</code>, or <code>detect</code>, to specify
parameters on abundance, recruitment, apparent survival, immigration,
and detectability, respectively.  For <code>unmarkedFitDS</code> objects,
<code>lambda</code> and <code>detect</code> are supported.  For
<code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and <code>detect</code>
denote abundance, availability, and detection probability,
respectively.  For <code>unmarkedFitGMM</code> and <code>unmarkedFitGPC</code>
objects, <code>lambda</code>, <code>phi</code>, and <code>detect</code> denote
abundance, availability, and detectability, respectively.
</p>
</td></tr>
<tr><td><code id="modavgShrink_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter for which a model-averaged estimate is requested must be
specified with the <code>parm</code> argument and must be identical to its
label in the model output (e.g., from <code>summary</code>).  For factors, one
must specify the name of the variable and the level of interest.  The
shrinkage version of model averaging is only appropriate for cases where
each parameter is given an equal weighting in the model (i.e., each
parameter must appear the same number of times in the models) and has
the same interpretation across all models.  As a result, models with
interaction terms or polynomial terms are not supported by
<code>modavgShrink</code>. 
</p>
<p><code>modavgShrink</code> is implemented for a list containing objects of
<code>aov</code>, <code>betareg</code>, <code>clm</code>, <code>clmm</code>, <code>clogit</code>,
<code>coxme</code>, <code>coxph</code>, <code>glm</code>, <code>glmmTMB</code>, <code>gls</code>,
<code>hurdle</code>, <code>lm</code>, <code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>,
<code>mer</code>, <code>glmerMod</code>, <code>lmerMod</code>, <code>lmerModLmerTest</code>,
<code>multinom</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>, <code>vglm</code>,
<code>zeroinfl</code> classes as well as various models of <code>unmarkedFit</code>
classes.
</p>


<h3>Value</h3>

<p><code>modavgShrink</code> creates an object of class <code>modavgShrink</code>
with the following components:
</p>
<table>
<tr><td><code>Parameter</code></td>
<td>
<p>the parameter for which a model-averaged estimate with
shrinkage was obtained.</p>
</td></tr> 
<tr><td><code>Mod.avg.table</code></td>
<td>
<p>the model selection table based on models including
the parameter of interest.</p>
</td></tr> 
<tr><td><code>Mod.avg.beta</code></td>
<td>
<p>the model-averaged estimate based on all models.</p>
</td></tr>
<tr><td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
estimate (as opposed to the conditional SE based on a single model).</p>
</td></tr>
<tr><td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval.</p>
</td></tr> 
<tr><td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit.</p>
</td></tr>
<tr><td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603&ndash;618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>Lukacs, P. M., Burnham, K. P., Anderson, D. R. (2010) Model selection
bias and Freedman's paradox. <em>Annals of the Institute of
Statistical Mathematics</em> <b>62</b>, 117&ndash;125. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+importance">importance</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##cement example in Burnham and Anderson 2002
data(cement)
##setup same model set as in Table 3.2, p. 102         
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(y ~ x1 + x2, data = cement)
Cand.models[[2]] &lt;- lm(y ~ x1 + x2 + x4, data = cement)          
Cand.models[[3]] &lt;- lm(y ~ x1 + x2 + x3, data = cement)
Cand.models[[4]] &lt;- lm(y ~ x1 + x4, data = cement)
Cand.models[[5]] &lt;- lm(y ~ x1 + x3 + x4, data = cement)
Cand.models[[6]] &lt;- lm(y ~ x2 + x3 + x4, data = cement)
Cand.models[[7]] &lt;- lm(y ~ x1 + x2 + x3 + x4, data = cement)
Cand.models[[8]] &lt;- lm(y ~ x3 + x4, data = cement)
Cand.models[[9]] &lt;- lm(y ~ x2 + x3, data = cement)
Cand.models[[10]] &lt;- lm(y ~ x4, data = cement)
Cand.models[[11]] &lt;- lm(y ~ x2, data = cement)
Cand.models[[12]] &lt;- lm(y ~ x2 + x4, data = cement)
Cand.models[[13]] &lt;- lm(y ~ x1, data = cement)
Cand.models[[14]] &lt;- lm(y ~ x1 + x3, data = cement)
Cand.models[[15]] &lt;- lm(y ~ x3, data = cement)

##vector of model names
Modnames &lt;- paste("mod", 1:15, sep="")

##AICc          
aictab(cand.set = Cand.models, modnames = Modnames)

##compute model-averaged estimate with shrinkage - each parameter
##appears 8 times in the models 
modavgShrink(cand.set = Cand.models, modnames = Modnames, parm = "x1")

##compare against classic model-averaging
modavg(cand.set = Cand.models, modnames = Modnames, parm = "x1")
##note that model-averaged estimate with shrinkage is closer to 0 than
##with the classic version

##remove a few models from the set and run again
Cand.unbalanced &lt;- Cand.models[-c(3, 14, 15)]

##set up model names
Modnames &lt;- paste("mod", 1:length(Cand.unbalanced), sep="")

##issues an error because some parameters appear more often than others
## Not run: modavgShrink(cand.set = Cand.unbalanced,
                       modnames = Modnames, parm = "x1")
## End(Not run)



##example on Orthodont data set in nlme
## Not run: 
require(nlme)

##set up candidate model list
##age and sex parameters appear in the same number of models
##same number of models with and without these parameters
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lme(distance ~ age, data = Orthodont, method = "ML") 
##random is ~ age | Subject as it is a grouped data frame
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1, method = "ML")
Cand.models[[3]] &lt;- lme(distance ~ 1, data = Orthodont, random = ~ 1, 
                        method = "ML") 
Cand.models[[4]] &lt;- lme(distance ~ Sex, data = Orthodont, random = ~ 1,
                        method = "ML")  

##create a vector of model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

##compute importance values for age
imp.age &lt;- importance(cand.set = Cand.models, parm = "age",
                      modnames = Modnames, second.ord = TRUE,
                      nobs = NULL)

##compute shrinkage version of model averaging on age
mod.avg.age.shrink &lt;- modavgShrink(cand.set = Cand.models,
                                    parm = "age", modnames = Modnames,
                                    second.ord = TRUE, nobs = NULL)

##compute classic version of model averaging on age
mod.avg.age.classic &lt;- modavg(cand.set = Cand.models, parm = "age",
                              modnames = Modnames, second.ord = TRUE,
                              nobs = NULL)

##correspondence between shrinkage version and classic version of
##model averaging 
mod.avg.age.shrink$Mod.avg.beta/imp.age$w.plus
mod.avg.age.classic$Mod.avg.beta
detach(package:nlme)

## End(Not run)


##example of N-mixture model modified from ?pcount
## Not run: 
require(unmarked)
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##set up models so that each variable on abundance appears twice
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF,
                      K = 30)
fm.mall.two &lt;- pcount(~ ivel + date  ~ elev + forest, mallardUMF,
                      K = 30)
fm.mall.three &lt;- pcount(~ ivel + date  ~ length + elev, mallardUMF,
                        K = 30)

##model list and names
Cands &lt;- list(fm.mall.one, fm.mall.two, fm.mall.three)
Modnames &lt;- c("length + forest", "elev + forest", "length + elev")

##compute model-averaged estimate with shrinkage for elev on abundance
modavgShrink(cand.set = Cands, modnames = Modnames, parm = "elev",
              parm.type = "lambda")
detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='multComp'>
Create Model Selection Tables based on Multiple Comparisons
</h2><span id='topic+multComp'></span><span id='topic+multComp.default'></span><span id='topic+multComp.aov'></span><span id='topic+multComp.gls'></span><span id='topic+multComp.glm'></span><span id='topic+multComp.lm'></span><span id='topic+multComp.lme'></span><span id='topic+multComp.mer'></span><span id='topic+multComp.negbin'></span><span id='topic+multComp.merMod'></span><span id='topic+multComp.lmerModLmerTest'></span><span id='topic+multComp.rlm'></span><span id='topic+multComp.survreg'></span><span id='topic+print.multComp'></span>

<h3>Description</h3>

<p>This function is an alternative to traditional multiple comparison
tests in designed experiments.  It creates a model selection table based
on different grouping patterns of a factor and computes model-averaged
predictions for each of the factor levels.  The current version works
with objects of <code>aov</code>, <code>glm</code>, <code>gls</code>, <code>lm</code>,
<code>lme</code>, <code>mer</code>, <code>merMod</code>, <code>lmerModLmerTest</code>,
<code>negbin</code>, and <code>rlm</code>, <code>survreg</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multComp(mod, factor.id, letter.labels = TRUE, second.ord = TRUE,
         nobs = NULL, sort = TRUE, newdata = NULL, uncond.se = "revised", 
         conf.level = 0.95, correction = "none", ...)

## S3 method for class 'aov'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        ...) 

## S3 method for class 'lm'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        ...)

## S3 method for class 'gls'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        ...) 

## S3 method for class 'glm'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        type = "response", c.hat = 1, gamdisp = NULL, ...)

## S3 method for class 'lme'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        ...)

## S3 method for class 'negbin'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        type = "response", ...)

## S3 method for class 'rlm'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        ...)

## S3 method for class 'survreg'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        type = "response", ...)

## S3 method for class 'mer'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95, correction = "none",
        type = "response", ...)

## S3 method for class 'merMod'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95,
        correction = "none", type = "response", ...)

## S3 method for class 'lmerModLmerTest'
multComp(mod, factor.id, letter.labels = TRUE,
        second.ord = TRUE, nobs = NULL, sort = TRUE, newdata = NULL,
        uncond.se = "revised", conf.level = 0.95,
        correction = "none", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multComp_+3A_mod">mod</code></td>
<td>

<p>a model of one of the above-mentioned classes that includes at least one
factor as an explanatory variable.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_factor.id">factor.id</code></td>
<td>

<p>the factor of interest, on which the groupings (multiple comparisons)
are based. The user must supply the name of the categorical variable
between quotes as it appears in the model formula.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_letter.labels">letter.labels</code></td>
<td>

<p>logical. If <code>TRUE</code>, letters are used as labels to denote the
grouping structure.  If <code>FALSE</code>, numbers are used as group labels.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_second.ord">second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc), otherwise returns
Akaike's Information Criterion (AIC).
</p>
</td></tr>
<tr><td><code id="multComp_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for certain types of models such
as mixed models where sample size is not straightforward.  In
such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_sort">sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the (Q)AIC(c) values.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_newdata">newdata</code></td>
<td>

<p>a data frame with the same structure as that of the original data
frame for which we want to make predictions.  This data frame should 
hold all variables constant other than the <code>factor.id</code> variable.
All levels of the <code>factor.id</code> variables should be included in the
<code>newdata</code> data frame to get model-averaged predictions for each
level.  If <code>NULL</code>, model-averaged predictions are computed for
each level of the <code>factor.id</code> variable while the values of the
other explanatory variables are taken from the first row of the
original data set.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_uncond.se">uncond.se</code></td>
<td>
<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying
the equation used to compute the unconditional standard error of a
model-averaged estimate.  With <code>uncond.se = "old"</code>, computations
are based on equation 4.9 of Burnham and Anderson (2002), which was
the former way to compute unconditional standard errors.  With
<code>uncond.se = "revised"</code>, equation 6.12 of Burnham and Anderson
(2002) is used.  Anderson (2008, p. 111) recommends use of the revised
version for the computation of unconditional standard errors and it is
now the default.  Note that versions of package <code>AICcmodavg</code> &lt;
1.04 used the old method to compute unconditional standard errors.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for
the computation of unconditional confidence intervals around
predicted values for each level of <code>factor.id</code>.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_correction">correction</code></td>
<td>
<p>the type of correction applied to obtain confidence
intervals for simultaneous inference (i.e., corrected for multiple
comparisons).  Current corrections include <code>"none"</code> for
uncorrected unconditional confidence intervals, <code>"bonferroni"</code>
for Bonferroni-adjusted confidence intervals (Dunn 1961), and
<code>"sidak"</code> for Sidak-adjusted confidence intervals (Sidak 1967).
</p>
</td></tr>  
<tr><td><code id="multComp_+3A_type">type</code></td>
<td>
<p>the scale of prediction requested, one of <code>"response"</code>
or <code>"link"</code>.  The latter is only relevant for <code>glm</code> and
<code>mer</code> classes.  Note that the value <code>"terms"</code> is not defined
for <code>multComp</code>. 
</p>
</td></tr>
<tr><td><code id="multComp_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>.  Note that values of 
<code>c.hat</code> different from 1 are only appropriate for binomial
GLM's with trials &gt; 1 (i.e., success/trial or cbind(success,
failure) syntax) or with Poisson GLM's.  If <code>c.hat &gt; 1</code>,
<code>multComp</code> will return the quasi-likelihood analogue of the
information criterion requested.  This  option is not supported for
generalized linear mixed models of the <code>mer</code> class. 
</p>
</td></tr>
<tr><td><code id="multComp_+3A_gamdisp">gamdisp</code></td>
<td>

<p>the value of the gamma dispersion parameter in a gamma GLM.
</p>
</td></tr>
<tr><td><code id="multComp_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A number of pairwise comparison tests are available for traditional
experimental designs, some controlling for the experiment-wise error and
others for comparison-wise errors (Day and Quinn 1991).  With the advent
of information-theoretic approaches, there has been a need for methods
analogous to multiple comparison tests in a model selection
framework.  Dayton (1998) and Burnham et al. (2011) suggested using
different parameterizations or grouping patterns of a factor to perform
multiple comparisons with model selection.  As such, it is possible to
assess the support in favor of certain grouping patterns based on a
factor.
</p>
<p>For example, a factor with three levels has four possible grouping
patterns: {abc} (all groups are different), {abb} (the first group
differs from the other two), {aab} (the first two groups differ from the
third), and {aaa} (all groups are equal).  <code>multComp</code> implements
such an approach by pooling groups of the factor variable in a model and
updating the model, for each grouping pattern possible.  The models are
ranked according to one of four information criteria (AIC, AICc, QAIC,
and QAICc), and the labels in the table correspond to the grouping
pattern.  Note that the factor levels are sorted according to their means
for the response variable before being assigned to a group.  The
function also returns model-averaged predictions and unconditional
standard errors for each level of the <code>factor.id</code> variable based on
the support in favor of each model (i.e., grouping pattern).
</p>
<p>The number of grouping patterns increases substantially with the number
of factor levels, as <code class="reqn">2^{k - 1}</code>, where <code class="reqn">k</code> is the number of
factor levels.  <code>multComp</code> supports factors with a maximum of 6
levels.  Also note that <code>multComp</code> does not handle models where
the <code>factor.id</code> variable is involved in an interaction.  In such
cases, one should create the interaction variable manually before
fitting the model (see Examples).
</p>
<p><code>multComp</code> currently implements three methods of computing
confidence intervals.  The default unconditional confidence intervals
do not account for multiple comparisons (<code>correction = "none"</code>).
With a large number <code class="reqn">m</code> of potential pairwise comparisons among
levels of <code>factor.id</code>, there is an increased risk of type I
error.  For <code class="reqn">m</code> pairwise comparisons and a given <code class="reqn">\alpha</code>
level, <code>correction = "bonferroni"</code> computes the unconditional
confidence intervals based on <code class="reqn">\alpha_{corr} = \frac{\alpha}{m}</code>
(Dunn 1961).  When <code>correction = "sidak"</code>, <code>multComp</code>
reports Sidak-adjusted confidence intervals, i.e., <code class="reqn">\alpha_{corr}
  = 1 - (1 - \alpha)^{\frac{1}{m}}</code>. 
</p>


<h3>Value</h3>

<p><code>multComp</code> creates a list of class <code>multComp</code> with the
following components: 
</p>
<table>
<tr><td><code>factor.id</code></td>
<td>
<p>the factor for which grouping patterns are investigated.</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>a list with the output of each model representing a
different grouping pattern for the factor of interest.</p>
</td></tr>
<tr><td><code>model.names</code></td>
<td>
<p>a vector of model names denoting the grouping pattern
for each level of the factor.</p>
</td></tr>
<tr><td><code>model.table</code></td>
<td>
<p>the model selection table for the models
corresponding to each grouping pattern for the factor of interest.</p>
</td></tr>
<tr><td><code>ordered.levels</code></td>
<td>
<p>the levels of the factor ordered according to the
mean of the response variable. The grouping patterns (and model names)
in the model selection table are based on the same order.</p>
</td></tr>
<tr><td><code>model.avg.est</code></td>
<td>
<p>a matrix with the model-averaged prediction,
unconditional standard error, and confidence intervals for each
level of the factor.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>the confidence level used for the confidence
intervals.</p>
</td></tr>
<tr><td><code>correction</code></td>
<td>
<p>the type of correction applied to the confidence
intervals to account for potential pairwise comparisons.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R., Huyvaert, K. P. (2011) AIC model
selection and multimodel inference in behaviorial ecology: some
background, observations and comparisons. <em>Behavioral Ecology and
Sociobiology</em> <b>65</b>, 23&ndash;25. 
</p>
<p>Day, R. W., Quinn, G. P. (1989) Comparisons of treatments after an
analysis of variance in ecology. <em>Ecological Monographs</em>
<b>59</b>, 433&ndash;463. 
</p>
<p>Dayton, C. M. (1998) Information criteria for the paired-comparisons
problem. <em>American Statistician</em>, <b>52</b> 144&ndash;151.
</p>
<p>Dunn, O. J. (1961) Multiple comparisons among means. <em>Journal of the
American Statistical Association</em> <b>56</b>, 52&ndash;64.
</p>

<p>Sidak, Z. (1967) Rectangular confidence regions for the means of
multivariate normal distributions. <em>Journal of the American
Statistical Association</em> <b>62</b>, 626&ndash;633.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+confset">confset</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>,
<code><a href="#topic+evidence">evidence</a></code>, <code><a href="multcomp.html#topic+glht">glht</a></code>, <code><a href="gmodels.html#topic+fit.contrast">fit.contrast</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##one-way ANOVA example
data(turkey)

##convert diet to factor
turkey$Diet &lt;- as.factor(turkey$Diet)
##run one-way ANOVA
m.aov &lt;- lm(Weight.gain ~ Diet, data = turkey)

##compute models with different grouping patterns
##and also compute model-averaged group means
out &lt;- multComp(m.aov, factor.id = "Diet", correction = "none")
##look at results
out

##look at grouping structure of a given model
##and compare with original variable
cbind(model.frame(out$models[[2]]), turkey$Diet)

##evidence ratio
evidence(out$model.table)

##compute Bonferroni-adjusted confidence intervals
multComp(m.aov, factor.id = "Diet", correction = "bonferroni")


##two-way ANOVA with interaction
## Not run: 
data(calcium)

m.aov2 &lt;- lm(Calcium ~ Hormone + Sex + Hormone:Sex, data = calcium)

##multiple comparisons
multComp(m.aov2, factor.id = "Hormone")
##returns an error because 'Hormone' factor is
##involved in an interaction

##create interaction variable
calcium$inter &lt;- interaction(calcium$Hormone, calcium$Sex)

##run model with interaction
m.aov.inter &lt;- lm(Calcium ~ inter, data = calcium)

##compare both
logLik(m.aov2)
logLik(m.aov.inter)
##both are identical

##multiple comparisons
multComp(m.aov.inter, factor.id = "inter")

## End(Not run)


##Poisson regression
## Not run: 
##example from ?glm
##Dobson (1990) Page 93: Randomized Controlled Trial :
counts &lt;- c(18,17,15,20,10,20,25,13,12)
outcome &lt;- gl(3,1,9)
treatment &lt;- gl(3,3)
print(d.AD &lt;- data.frame(treatment, outcome, counts))
glm.D93 &lt;- glm(counts ~ outcome + treatment, data = d.AD, family = poisson)

multComp(mod = glm.D93, factor.id = "outcome")

## End(Not run)


##example specifying 'newdata'
## Not run: 
data(dry.frog)
m1 &lt;- lm(log_Mass_lost ~ Shade + Substrate +
      cent_Initial_mass + Initial_mass2,
      data = dry.frog)

multComp(m1, factor.id = "Substrate",
          newdata = data.frame(
            Substrate = c("PEAT", "SOIL", "SPHAGNUM"),
            Shade = 0, cent_Initial_mass = 0,
            Initial_mass2 = 0))

## End(Not run)
</code></pre>

<hr>
<h2 id='newt'>
Newt Capture-mark-recapture Data
</h2><span id='topic+newt'></span>

<h3>Description</h3>

<p>This is a capture-mark-recapture data set on adult male and female
Red-spotted Newts (<em>Notophthalmus viridescens</em>) recorded by Gill
(1985).  A total of 1079 unique individuals were captured in pitfall
traps at a breeding site (White Oak Flat pond, Virginia) between 1975
and 1983.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(newt)</code></pre>


<h3>Format</h3>

<p>A data frame with 78 observations on the following 11 variables.
</p>

<dl>
<dt><code>T1975</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1975 breeding season.</p>
</dd>
<dt><code>T1976</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1976 breeding season.</p>
</dd>
<dt><code>T1977</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1977 breeding season.</p>
</dd>
<dt><code>T1978</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1978 breeding season.</p>
</dd>
<dt><code>T1979</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1979 breeding season.</p>
</dd>
<dt><code>T1980</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1980 breeding season.</p>
</dd>
<dt><code>T1981</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1981 breeding season.</p>
</dd>
<dt><code>T1982</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1982 breeding season.</p>
</dd>
<dt><code>T1983</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1983 breeding season.</p>
</dd>
<dt><code>Males</code></dt><dd><p>a numeric variable indicating the total number
of males with a given capture history.</p>
</dd> 
<dt><code>Females</code></dt><dd><p>a numeric variable indicating the total number
of females with a given capture history.</p>
</dd>
</dl>



<h3>Details</h3>

<p>A single cohort of individuals was followed throughout the study, as all
individuals were marked in 1975 and no new individuals were added during
the subsequent years.  This data set is used to illustrate classic
Cormack-Jolly-Seber and related models (Cormack 1964, Jolly 1965, Seber
1965, Lebreton et al. 1992, Mazerolle 2015).
</p>


<h3>Source</h3>

<p>Cormack, R. M. (1964) Estimates of survival from the sighting of
marked animals. <em>Biometrika</em> <b>51</b>, 429&ndash;438.
</p>
<p>Gill, D. E. (1985) Interpreting breeding patterns from census data: a
solution to the Husting dilemma. <em>Ecology</em> <b>66</b>, 344&ndash;354. 
</p>
<p>Jolly, G. M. (1965) Explicit estimates from capture-recapture data
with both death and immigration: stochastic model. <em>Biometrika</em> 
<b>52</b>, 225&ndash;247.
</p>
<p>Laake, J. L. (2013) <em>RMark: an R interface for analysis of
capture-recapture data with MARK.</em> Alaska Fisheries Science Center
(AFSC), National Oceanic and Atmospheric Administration, National
Marine Fisheries Service, AFSC Report 2013-01.
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67-118.
</p>
<p>Mazerolle, M. J. (2015) Estimating detectability and biological
parameters of interest with the use of the R
environment. <em>Journal of Herpetology</em> <b>49</b>, 541&ndash;559. 
</p>
<p>Seber, G. A. F. (1965) A note on the multiple-recapture
census. <em>Biometrika</em> <b>52</b>, 249&ndash;259.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(newt)
str(newt)

##convert raw capture data to capture histories
captures &lt;- newt[, c("T1975", "T1976", "T1977", "T1978", "T1979",
                      "T1980", "T1981", "T1982", "T1983")]
newt.ch &lt;- apply(captures, MARGIN = 1, FUN = function(i)
                  paste(i, collapse = ""))

##organize as a data frame readable by RMark package (Laake 2013)
##RMark requires at least one column called "ch" 
##and another "freq" if summarized captures are provided
newt.full &lt;- data.frame(ch = rep(newt.ch, 2),
                        freq = c(newt$Males, newt$Females),
                        Sex = c(rep("male", length(newt.ch)),
                        rep("female", length(newt.ch))))
str(newt.full)
newt.full$ch &lt;- as.character(newt.full$ch)

##delete rows with 0 freqs
newt.full.orig &lt;- newt.full[which(newt.full$freq != 0), ]
</code></pre>

<hr>
<h2 id='Nmix.gof.test'>
Compute Chi-square Goodness-of-fit Test for N-mixture Models
</h2><span id='topic+Nmix.chisq'></span><span id='topic+Nmix.chisq.default'></span><span id='topic+Nmix.chisq.unmarkedFitPCount'></span><span id='topic+Nmix.chisq.unmarkedFitPCO'></span><span id='topic+Nmix.chisq.unmarkedFitMPois'></span><span id='topic+Nmix.chisq.unmarkedFitDS'></span><span id='topic+Nmix.chisq.unmarkedFitGDS'></span><span id='topic+Nmix.chisq.unmarkedFitGPC'></span><span id='topic+Nmix.chisq.unmarkedFitGMM'></span><span id='topic+Nmix.chisq.unmarkedFitMMO'></span><span id='topic+Nmix.chisq.unmarkedFitDSO'></span><span id='topic+Nmix.gof.test'></span><span id='topic+Nmix.gof.test.default'></span><span id='topic+Nmix.gof.test.unmarkedFitPCount'></span><span id='topic+Nmix.gof.test.unmarkedFitPCO'></span><span id='topic+Nmix.gof.test.unmarkedFitDS'></span><span id='topic+Nmix.gof.test.unmarkedFitGDS'></span><span id='topic+Nmix.gof.test.unmarkedFitGMM'></span><span id='topic+Nmix.gof.test.unmarkedFitGPC'></span><span id='topic+Nmix.gof.test.unmarkedFitMPois'></span><span id='topic+Nmix.gof.test.unmarkedFitMMO'></span><span id='topic+Nmix.gof.test.unmarkedFitDSO'></span><span id='topic+print.Nmix.chisq'></span>

<h3>Description</h3>

<p>These functions compute a goodness-of-fit test for N-mixture models
based on Pearson's chi-square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##methods for 'unmarkedFitPCount', 'unmarkedFitPCO', 
##'unmarkedFitDS', 'unmarkedFitGDS', 'unmarkedFitGMM',
##'unmarkedFitGPC', and 'unmarkedFitMPois' classes
Nmix.chisq(mod, ...)

Nmix.gof.test(mod, nsim = 5, plot.hist = TRUE, report = NULL,
parallel = TRUE, ncores, cex.axis = 1, cex.lab = 1, cex.main = 1,
lwd = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nmix.gof.test_+3A_mod">mod</code></td>
<td>

<p>the <em>N</em>-mixture model of <code>unmarkedFitPCount</code>,
<code>unmarkedFitPCO</code>, <code>unmarkedFitDS</code>, <code>unmarkedFitGDS</code>,
<code>unmarkedFitGMM</code>, <code>unmarkedFitGPC</code>,
<code>unmarkedFitMPois</code>, <code>unmarkedFitMMO</code>, or
<code>unmarkedFitDSO</code> classes for which a goodness-of-fit test is
required. 
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_nsim">nsim</code></td>
<td>
<p>the number of bootstrapped samples.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_plot.hist">plot.hist</code></td>
<td>
<p>logical.  Specifies that a histogram of the
bootstrapped test statistic is to be included in the output.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_report">report</code></td>
<td>
<p>If <code>NULL</code>, the test statistic for each iteration is
not printed in the terminal.  Otherwise, an integer indicating the
number of values of the test statistic that should be printed on
the same line.  For example, if <code>report = 3</code>, the values of the
test statistic for three iterations are reported on each line.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_parallel">parallel</code></td>
<td>
<p>logical.  If <code>TRUE</code>, requests that <code>parboot</code>
use multiple cores to accelerate computations of the bootstrap.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_ncores">ncores</code></td>
<td>
<p>integer indicating the number of cores to use when
bootstrapping in parallel during the analysis of simulated data sets.
If <code>ncores</code> is not specified, one less than the number of
available cores on the computer is used.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_cex.axis">cex.axis</code></td>
<td>
<p>expansion factor influencing the size of axis
annotations on plots produced by the function.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_cex.lab">cex.lab</code></td>
<td>
<p>expansion factor influencing the size of axis labels on
plots produced by the function.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_cex.main">cex.main</code></td>
<td>
<p>expansion factor influencing the size of the main title
above plots produced by the function.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_lwd">lwd</code></td>
<td>
<p>expansion factor of line width on plots produced by the
function.
</p>
</td></tr>
<tr><td><code id="Nmix.gof.test_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pearson chi-square can be used to assess the fit of N-mixture
models.  Instead of relying on the theoretical distribution of the
chi-square, a parametric bootstrap approach is implemented to obtain
<em>P</em>-values with the <code>parboot</code> function of the <code>unmarked</code>
package.  <code>Nmix.chisq</code> computes the observed chi-square statistic
based on the observed and expected counts from the model.
<code>Nmix.gof.test</code> calls internally <code>Nmix.chisq</code> and
<code>parboot</code> to generate simulated data sets based on the model and
compute the chi-square test statistic.
</p>
<p>It is also possible to obtain an estimate of the overdispersion
parameter (c-hat) for the model at hand by dividing the observed
chi-square statistic by the mean of the statistics obtained from
simulation (MacKenzie and Bailey 2004, McKenny et al. 2006).  This
method of estimating c-hat is similar to the one implemented for
capture-mark-recapture models in program MARK (White and Burnham 1999).
</p>
<p>Note that values of c-hat &gt; 1 indicate overdispersion (variance &gt;
mean).  Values much higher than 1 (i.e., &gt; 4) probably indicate
lack-of-fit.  In cases of moderate overdispersion, one can multiply the
variance-covariance matrix of the estimates by c-hat.  As a result, the
SE's of the estimates are inflated (c-hat is also known as a variance
inflation factor).
</p>
<p>In model selection, c-hat should be estimated from the global model and
the same value of c-hat applied to the entire model set.  Specifically,
a global model is the most complex model which can be simplified to
yield all the other (nested) models of the set.  When no single global
model exists in the set of models considered, such as when sample size
does not allow a complex model, one can estimate c-hat from 'subglobal'
models.  Here, 'subglobal' models denote models from which only a subset
of the models of the candidate set can be derived.  In such cases, one
can use the smallest value of c-hat for model selection (Burnham and
Anderson 2002).
</p>
<p>Note that c-hat counts as an additional parameter estimated and should 
be added to <em>K</em>.  All functions in package <code>AICcmodavg</code>
automatically add 1 when the <code>c.hat</code> argument &gt; 1 and apply the
same value of c-hat for the entire model set.  When c-hat &gt; 1, functions
compute quasi-likelihood information criteria (either QAICc or QAIC,
depending on the value of the <code>second.ord</code> argument) by scaling the
log-likelihood of the model by c-hat.  The value of c-hat can influence
the ranking of the models:  as c-hat increases, QAIC or QAICc will favor
models with fewer parameters.  As an additional check against this
potential problem, one can generate several model selection tables by
incrementing values of c-hat to assess the model selection uncertainty.
If ranking changes only slightly up to the c-hat value observed, one can
be confident in making inference.
</p>
<p>In cases of underdispersion (c-hat &lt; 1), it is recommended to keep the
value of c-hat to 1.  However, note that values of c-hat &lt;&lt; 1 can also
indicate lack-of-fit and that an alternative model should be investigated. 
</p>


<h3>Value</h3>

<p><code>Nmix.chisq</code> returns two value:
</p>
<table>
<tr><td><code>chi.square</code></td>
<td>
<p>the Pearson chi-square statistic.
</p>
</td></tr>
<tr><td><code>model.type</code></td>
<td>
<p>the class of the fitted model.
</p>
</td></tr>
</table>
<p><code>Nmix.gof.test</code> returns the following components:
</p>
<table>
<tr><td><code>model.type</code></td>
<td>
<p>the class of the fitted model.
</p>
</td></tr>
<tr><td><code>chi.square</code></td>
<td>
<p>the Pearson chi-square statistic.
</p>
</td></tr>
<tr><td><code>t.star</code></td>
<td>
<p>the bootstrapped chi-square test statistics (i.e.,
obtained for each of the simulated data sets).
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the <em>P</em>-value assessed from the parametric bootstrap,
computed as the proportion of the simulated test statistics greater
than or equal to the observed test statistic.
</p>
</td></tr>
<tr><td><code>c.hat.est</code></td>
<td>
<p>the estimate of the overdispersion parameter, c-hat,
computed as the observed test statistic divided by the mean of the
simulated test statistics.
</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>the number of bootstrap samples. The recommended number of
samples varies with the data set, but should be on the order of 1000
or 5000, and in cases with a large number of visits, even 10 000
samples, namely to reduce the effect of unusually small values of the
test statistics.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>MacKenzie, D. I., Bailey, L. L. (2004) Assessing the fit of
site-occupancy models. <em>Journal of Agricultural, Biological, and
Environmental Statistics</em> <b>9</b>, 300&ndash;318.
</p>
<p>McKenny, H. C., Keeton, W. S., Donovan, T. M. (2006). Effects of
structural complexity enhancement on eastern red-backed salamander
(<em>Plethodon cinereus</em>) populations in northern hardwood
forests. <em>Forest Ecology and Management</em> <b>230</b>, 186&ndash;196.
</p>
<p>White, G. C., Burnham, K. P. (1999). Program MARK: Survival estimation
from populations of marked animals. <em>Bird Study</em> <b>46
(Supplement)</b>, 120&ndash;138. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+evidence">evidence</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+mb.gof.test">mb.gof.test</a></code>, <code><a href="#topic+modavgPred">modavgPred</a></code>,
<code><a href="unmarked.html#topic+pcount">pcount</a></code>, <code><a href="unmarked.html#topic+pcountOpen">pcountOpen</a></code>,
<code><a href="unmarked.html#topic+parboot">parboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##N-mixture model example modified from ?pcount
## Not run: 
require(unmarked)
##single season
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##run model
fm.mallard &lt;- pcount(~ ivel+ date + I(date^2) ~ length + elev + forest,
                     mallardUMF, K=30)

##compute observed chi-square
obs &lt;- Nmix.chisq(fm.mallard)
obs

##round to 4 digits after decimal point
print(obs, digits.vals = 4)

##compute observed chi-square, assess significance, and estimate c-hat
obs.boot &lt;- Nmix.gof.test(fm.mallard, nsim = 10)
##note that more bootstrap samples are recommended
##(e.g., 1000, 5000, or 10 000)
obs.boot
print(obs.boot, digits.vals = 4, digits.chisq = 4)
detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='pine'>
Strength of Pine Wood Based on the Density Adjusted for Resin Content
</h2><span id='topic+pine'></span>

<h3>Description</h3>

<p>This data set consists of the strength of pine wood as a function of
density or density adjusted for resin content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pine)</code></pre>


<h3>Format</h3>

<p>A data frame with 42 observations on the following 3 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>pine wood strength.</p>
</dd>
<dt><code>x</code></dt><dd><p>pine wood density.</p>
</dd>
<dt><code>z</code></dt><dd><p>pine wood density adjusted for resin content.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Burnham and Anderson (2002, p. 183) use this data set originally from
Carlin and Chib (1995) to illustrate model selection for two competing
and non-nested models. 
</p>


<h3>Source</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York. 
</p>
<p>Carlin, B. P., Chib, S. (1995) Bayesian model choice via Markov chain
Monte Carlo methods. <em>Journal of the Royal Statistical Society, 
Series B</em> <b>57</b>, 473&ndash;484. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pine)
## maybe str(pine) ; plot(pine) ...
</code></pre>

<hr>
<h2 id='predictSE'>
Computing Predicted Values and Standard Errors
</h2><span id='topic+predictSE'></span><span id='topic+predictSE.default'></span><span id='topic+predictSE.gls'></span><span id='topic+predictSE.lme'></span><span id='topic+predictSE.mer'></span><span id='topic+predictSE.merMod'></span><span id='topic+predictSE.lmerModLmerTest'></span><span id='topic+predictSE.unmarkedFitPCount'></span><span id='topic+predictSE.unmarkedFitPCO'></span>

<h3>Description</h3>

<p>Function to compute predicted values based on linear predictor and
associated standard errors from various fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictSE(mod, newdata, se.fit = TRUE, print.matrix = FALSE, ...)

## S3 method for class 'gls'
predictSE(mod, newdata, se.fit = TRUE, print.matrix = 
        FALSE, ...) 

## S3 method for class 'lme'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, ...)

## S3 method for class 'mer'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, type = "response", ...)

## S3 method for class 'merMod'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, type = "response", ...)

## S3 method for class 'lmerModLmerTest'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, ...)

## S3 method for class 'unmarkedFitPCount'
predictSE(mod, newdata, se.fit = TRUE,
        print.matrix = FALSE, type = "response", c.hat = 1, parm.type =
        "lambda", ...)

## S3 method for class 'unmarkedFitPCO'
predictSE(mod, newdata, se.fit = TRUE, 
        print.matrix = FALSE, type = "response", c.hat = 1,
        parm.type = "lambda", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictSE_+3A_mod">mod</code></td>
<td>

<p>an object of class <code>gls</code>, <code>lme</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code>, <code>unmarkedFitPCount</code>,
or <code>unmarkedFitPCO</code> containing the output of a model.
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_newdata">newdata</code></td>
<td>

<p>a data frame with the same structure as that of the original data
frame for which we want to make predictions.
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_se.fit">se.fit</code></td>
<td>

<p>logical.  If <code>TRUE</code>, compute standard errors on predictions.
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_print.matrix">print.matrix</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the output is returned as a matrix, with
predicted values and standard errors in columns.  If <code>FALSE</code>,
the output is returned as a list.
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_level">level</code></td>
<td>
 
<p>the level for which predicted values and standard errors are to be
computed.  The current version of the function only supports
predictions for the populations excluding random effects (i.e.,
<code>level = 0</code>).
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_type">type</code></td>
<td>

<p>specifies the type of prediction requested.  This argument can take
the value <code>response</code> or <code>link</code>, for predictions on the
scale of the response variable or on the scale of the linear
predictor, respectively.
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>Nmix.gof.test</code>.  If <code>c.hat &gt;
    1</code>, <code>predictSE</code> will multiply the variance-covariance matrix of
the predictions by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  High values of <code>c.hat</code> (e.g., <code>c.hat
    &gt; 4</code>) may indicate that model structure is inappropriate.
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_parm.type">parm.type</code></td>
<td>
 
<p>the parameter for which predictions are made based on the
<em>N</em>-mixture model of class <code>unmarkedFitPCount</code> or
<code>unmarkedFitPCO</code> classes.
</p>
</td></tr>
<tr><td><code id="predictSE_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predictSE</code> computes predicted values and associated standard
errors.  Standard errors are approximated using the delta method
(Oehlert 1992).  Predictions and standard errors for objects of
<code>gls</code> class and mixed models of <code>lme</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code> classes exclude the
correlation or variance structure of the model.
</p>
<p><code>predictSE</code> computes predicted values on abundance and standard
errors based on the estimates from an <code>unmarkedFitPCount</code> or
<code>unmarkedFitPCO</code> object.  Currently, only predictions on
abundance (i.e., <code>parm.type = "lambda"</code>) with the zero-inflated
Poisson distribution is supported.  For other parameters or
distributions for models of <code>unmarkedFit</code> classes, use
<code>predict</code> from the <code>unmarked</code> package. 
</p>


<h3>Value</h3>

<p><code>predictSE</code> returns requested values either as a matrix
(<code>print.matrix = TRUE</code>) or list (<code>print.matrix = FALSE</code>)
with components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>

<p>the predicted values.
</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>

<p>the standard errors of the predicted values (if <code>se.fit = TRUE</code>). 
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For standard errors with better properties, especially for small
samples, one can opt for simulations (see Gelman and Hill 2007), or
nonparametric bootstrap (Efron and Tibshirani 1998).
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Efron, B., Tibshirani, R. J. (1998) <em>An Introduction to the
Bootstrap</em>. Chapman &amp; Hall/CRC: New York. 
</p>
<p>Gelman, A., Hill, J. (2007) <em>Data Analysis Using Regression and
Multilevel/Hierarchical Models</em>. Cambridge University Press: New York. 
</p>
<p>Oehlert, G. W. (1992) A note on the delta method. <em>American
Statistician</em> <b>46</b>, 27&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+gls">gls</a></code>, <code><a href="nlme.html#topic+lme">lme</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code>,
<code><a href="lme4.html#topic+simulate.merMod">simulate.merMod</a></code>, <code><a href="boot.html#topic+boot">boot</a></code>,
<code><a href="unmarked.html#topic+parboot">parboot</a></code>, <code><a href="unmarked.html#topic+nonparboot-methods">nonparboot</a></code>,
<code><a href="unmarked.html#topic+pcount">pcount</a></code>, <code><a href="unmarked.html#topic+pcountOpen">pcountOpen</a></code>,
<code><a href="unmarked.html#topic+unmarkedFit-class">unmarkedFit-class</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Orthodont data from Pinheiro and Bates (2000) revisited
## Not run: 
require(nlme)
m1 &lt;- gls(distance ~ age, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method= "ML")

##compare against lme fit
logLik(m1)
logLik(lme(distance ~ age, random = ~1 | Subject, data = Orthodont,
          method= "ML"))
##both are identical


##compute predictions and SE's for different ages
predictSE(m1, newdata = data.frame(age = c(8, 10, 12, 14)))
detach(package:nlme)

## End(Not run)


##example with mallard data set from unmarked package
## Not run: 
require(unmarked)
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##run model with zero-inflated Poisson abundance
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF, K=30,
                      mixture = "ZIP")
##make prediction
predictSE(fm.mall.one, type = "response", parm.type = "lambda",
          newdata = data.frame(length = 0, forest = 0, elev = 0))
##compare against predict
predict(fm.mall.one, type = "state", backTransform = TRUE,
        newdata = data.frame(length = 0, forest = 0, elev = 0))

##add offset in model to scale abundance per transect length
fm.mall.off &lt;- pcount(~ ivel + date  ~ forest + offset(length), mallardUMF, K=30,
                      mixture = "ZIP")
##make prediction
predictSE(fm.mall.off, type = "response", parm.type = "lambda",
          newdata = data.frame(length = 10, forest = 0, elev = 0))
##compare against predict
predict(fm.mall.off, type = "state", backTransform = TRUE,
        newdata = data.frame(length = 10, forest = 0, elev = 0))
detach(package:unmarked)

## End(Not run)
</code></pre>

<hr>
<h2 id='salamander'>
Salamander Capture-mark-recapture Data
</h2><span id='topic+salamander'></span>

<h3>Description</h3>

<p>This is a capture-mark-recapture data set on male and female Spotted
Salamanders (<em>Ambystoma maculatum</em>) recorded by Husting (1965).  A
total of 1244 unique individuals were captured in pitfall traps at a
breeding site between 1959 and 1963.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salamander)</code></pre>


<h3>Format</h3>

<p>A data frame with 36 observations on the following 7 variables.
</p>

<dl>
<dt><code>T1959</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1959 breeding season.</p>
</dd>
<dt><code>T1960</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1960 breeding season.</p>
</dd>
<dt><code>T1961</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1961 breeding season.</p>
</dd>
<dt><code>T1962</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1962 breeding season.</p>
</dd>
<dt><code>T1963</code></dt><dd><p>a binary variable, either 1 (captured) or 0 (not
captured) during the 1963 breeding season.</p>
</dd>
<dt><code>Males</code></dt><dd><p>a numeric variable indicating the total number
of males with a given capture history.  Negative values indicate
losses on capture (animals not released on last capture). </p>
</dd> 
<dt><code>Females</code></dt><dd><p>a numeric variable indicating the total number
of females with a given capture history.  Negative values indicate
losses on capture (animals not released on last capture). </p>
</dd> 
</dl>



<h3>Details</h3>

<p>This data set is used to illustrate classic Cormack-Jolly-Seber and
related models (Cormack 1964, Jolly 1965, Seber 1965, Lebreton et
al. 1992). 
</p>


<h3>Source</h3>

<p>Cormack, R. M. (1964) Estimates of survival from the sighting of
marked animals. <em>Biometrika</em> <b>51</b>, 429&ndash;438.
</p>
<p>Husting, E. L. (1965) Survival and breeding structure in a population
of <em>Ambystoma maculatum</em>. <em>Copeia</em> <b>1965</b>, 352&ndash;362. 
</p>
<p>Jolly, G. M. (1965) Explicit estimates from capture-recapture data
with both death and immigration: stochastic model. <em>Biometrika</em> 
<b>52</b>, 225&ndash;247.
</p>
<p>Laake, J. L. (2013) <em>RMark: an R interface for analysis of
capture-recapture data with MARK.</em> Alaska Fisheries Science Center
(AFSC), National Oceanic and Atmospheric Administration, National
Marine Fisheries Service, AFSC Report 2013-01.
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67-118.
</p>
<p>Seber, G. A. F. (1965) A note on the multiple-recapture
census. <em>Biometrika</em> <b>52</b>, 249&ndash;259.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(salamander)
str(salamander)

##convert raw capture data to capture histories
captures &lt;- salamander[, c("T1959", "T1960", "T1961", "T1962", "T1963")]
salam.ch &lt;- apply(captures, MARGIN = 1, FUN = function(i)
                  paste(i, collapse = ""))

##organize as a data frame readable by RMark package (Laake 2013)
##RMark requires at least one column called "ch" 
##and another "freq" if summarized captures are provided
salam.full &lt;- data.frame(ch = rep(salam.ch, 2),
                         freq = c(salamander$Males, salamander$Females),
                         Sex = c(rep("male", length(salam.ch)),
                           rep("female", length(salam.ch))))
str(salam.full)
salam.full$ch &lt;- as.character(salam.full$ch)

##delete rows with 0 freqs
salam.full.orig &lt;- salam.full[which(salam.full$freq != 0), ]
</code></pre>

<hr>
<h2 id='summaryOD'>
Display Model Summary Corrected for Overdispersion
</h2><span id='topic+summaryOD'></span><span id='topic+summaryOD.glm'></span><span id='topic+summaryOD.unmarkedFitOccu'></span><span id='topic+summaryOD.unmarkedFitColExt'></span><span id='topic+summaryOD.unmarkedFitOccuRN'></span><span id='topic+summaryOD.unmarkedFitPCount'></span><span id='topic+summaryOD.unmarkedFitPCO'></span><span id='topic+summaryOD.unmarkedFitDS'></span><span id='topic+summaryOD.unmarkedFitGDS'></span><span id='topic+summaryOD.unmarkedFitOccuFP'></span><span id='topic+summaryOD.unmarkedFitMPois'></span><span id='topic+summaryOD.unmarkedFitGMM'></span><span id='topic+summaryOD.unmarkedFitGPC'></span><span id='topic+summaryOD.unmarkedFitOccuMulti'></span><span id='topic+summaryOD.unmarkedFitOccuMS'></span><span id='topic+summaryOD.unmarkedFitOccuTTD'></span><span id='topic+summaryOD.unmarkedFitMMO'></span><span id='topic+summaryOD.unmarkedFitDSO'></span><span id='topic+summaryOD.glmerMod'></span><span id='topic+summaryOD.maxlikeFit'></span><span id='topic+summaryOD.multinom'></span><span id='topic+summaryOD.vglm'></span><span id='topic+print.summaryOD'></span>

<h3>Description</h3>

<p>This function displays the estimates of a model with standard errors
corrected for overdispersion for a variety of model classes.  The output
includes either confidence intervals based on the normal approximation
or Wald hypothesis tests corrected for overdispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryOD(mod, c.hat = 1, conf.level = 0.95, 
          out.type = "confint", ...)

## S3 method for class 'glm'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitOccu'
summaryOD(mod, c.hat = 1, conf.level = 0.95,
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitColExt'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitOccuRN'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitPCount'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitPCO'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitDS'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitGDS'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitOccuFP'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitMPois'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitGMM'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitGPC'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitOccuMulti'
summaryOD(mod, c.hat = 1, conf.level = 0.95,
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitOccuMS'
summaryOD(mod, c.hat = 1, conf.level = 0.95,
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitOccuTTD'
summaryOD(mod, c.hat = 1, conf.level = 0.95,
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitMMO'
summaryOD(mod, c.hat = 1, conf.level = 0.95,
     out.type = "confint", ...)

## S3 method for class 'unmarkedFitDSO'
summaryOD(mod, c.hat = 1, conf.level = 0.95,
     out.type = "confint", ...)

## S3 method for class 'glmerMod'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'maxlikeFit'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'multinom'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)

## S3 method for class 'vglm'
summaryOD(mod, c.hat = 1, conf.level = 0.95, 
     out.type = "confint", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryOD_+3A_mod">mod</code></td>
<td>

<p>an object of class <code>glm</code>, <code>glmmTMB</code>,
<code>maxlikeFit</code>, <code>mer</code>, <code>merMod</code>, <code>multinom</code>,  
<code>vglm</code>, and various <code>unmarkedFit</code> classes containing 
the output of a model.
</p>
</td></tr>
<tr><td><code id="summaryOD_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>, <code>mb.gof.test</code>, or
<code>Nmix.gof.test</code>.
</p>
</td></tr>
<tr><td><code id="summaryOD_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
confidence intervals.
</p>
</td></tr>
<tr><td><code id="summaryOD_+3A_out.type">out.type</code></td>
<td>

<p>the type of summary requested for each parameter estimate. If
<code>out.type = "confint"</code>, computes confidence intervals corrected
for overdispersion, whereas <code>out.type = "nhst"</code> conducts
null-hypothesis statistical testing corrected for overdispersion.
</p>
</td></tr>
<tr><td><code id="summaryOD_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overdispersion occurs when the variance in the data exceeds that
expected from a theoretical distribution such as the Poisson or
binomial (McCullagh and Nelder 1989, Burnham and Anderson 2002).
When the model is correct, small values of c-hat (1 &lt; c-hat &lt; 4) can
reflect minor deviations from model assumptions (Burnham and Anderson
2002).  In such cases, it is possible to adjust standard errors of
parameter estimates by multiplying with <code>sqrt(c.hat)</code> (McCullagh
and Nelder 1989).  This is the correction applied by
<code>summaryOD</code>.
</p>
<p>Depending on the type of summary requested, i.e.,
<code>out.type = "confint"</code> or <code>out.type = "nhst"</code>,
<code>summaryOD</code> will return either confidence intervals based on the
normal approximation or Wald tests for each parameter estimate
(Agresti 1990).
</p>
<p>For binomial distributions, note that values of <code>c.hat</code> &gt; 1 are
only appropriate with trials &gt; 1 (i.e., <code>success/trial</code> or
<code>cbind(success, failure)</code> syntax).  The function supports
different model types such as Poisson GLM's and GLMM's, single-season
occupancy models (MacKenzie et al. 2002), dynamic occupancy models
(MacKenzie et al. 2003), or <em>N</em>-mixture models (Royle 2004, Dail
and Madsen 2011).
</p>


<h3>Value</h3>

<p><code>summaryOD</code> returns an object of class <code>summaryOD</code> as a list with
the following components:
</p>
<table>
<tr><td><code>out.type</code></td>
<td>
<p>the type of output requested by the user.</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>the <code>c.hat</code> estimate used to adjust standard errors.</p>
</td></tr> 
<tr><td><code>conf.level</code></td>
<td>
<p>the confidence level used to compute confidence
intervals around the estimates.</p>
</td></tr>
<tr><td><code>outMat</code></td>
<td>
<p>the output of the model corrected for overdispersion
organized in a matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Agresti, A. (2002) <em>Categorical Data Analysis</em>. Second
edition. John Wiley and Sons: New Jersey.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169&ndash;180. 
</p>
<p>McCullagh, P., Nelder, J. A. (1989) <em>Generalized Linear
Models</em>. Second edition. Chapman and Hall: New York.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c_hat">c_hat</a></code>, <code><a href="#topic+mb.gof.test">mb.gof.test</a></code>,
<code><a href="#topic+Nmix.gof.test">Nmix.gof.test</a></code>, <code><a href="#topic+anovaOD">anovaOD</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##anuran larvae example from Mazerolle (2006)
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##run model
m1 &lt;- glm(Num_anura ~ Type + log.Perimeter + Num_ranatra,
          family = poisson, offset = log(Effort),
          data = min.trap) 

##check c-hat for global model
c_hat(m1) #uses Pearson's chi-square/df

##display results corrected for overdispersion
summaryOD(m1, c_hat(m1))
summaryOD(m1, c_hat(m1), out.type = "nhst")

##example with occupancy model
## Not run: 
##load unmarked package
if(require(unmarked)){
   
   data(bullfrog)
     
   ##detection data
   detections &lt;- bullfrog[, 3:9]

   ##assemble in unmarkedFrameOccu
   bfrog &lt;- unmarkedFrameOccu(y = detections)
     
   ##run model
   fm &lt;- occu(~ 1 ~ 1, data = bfrog)

   ##check GOF
   ##GOF &lt;- mb.gof.test(fm, nsim = 1000)
   ##estimate of c-hat:  1.89

   ##display results after overdispersion adjustment
   summaryOD(fm, c.hat = 1.89)
   summaryOD(fm, c.hat = 1.89, out.type = "nhst")

   detach(package:unmarked)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='tortoise'>
Gopher Tortoise Distance Sampling Data
</h2><span id='topic+tortoise'></span>

<h3>Description</h3>

<p>This simulated data set by Mazerolle (2015) is based on the biological
parameters for the Gopher Tortoise (<em>Gopherus polyphemus</em>) reported
by Smith et al. (2009).  A half-normal distribution with a scale of 10
and without an  adjustment factor was used to simulate the distance data
for a study area of 120 <code class="reqn">km^2</code>. An effort of 500 m in 300 line
transects was deployed. A density of 72 individuals per <code class="reqn">km^2</code> was
used in the simulation using the approach outlined in Buckland et
al. (2001). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tortoise)</code></pre>


<h3>Format</h3>

<p>A data frame with 410 observations on the following 5 variables.
</p>

<dl>
<dt><code>Region.Label</code></dt><dd><p>a numeric identifier for the study area.</p>
</dd> 
<dt><code>Area</code></dt><dd><p>a numeric variable for the surface area of the
study area in square meters.</p>
</dd>
<dt><code>Sample.Label</code></dt><dd><p>a numeric identifier for each line
transect relating each observation to its corresponding transect.</p>
</dd>
<dt><code>Effort</code></dt><dd><p>Effort in meters expended in each line transect.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numeric variable for the perpendicular
distances in meters relative to the transect line for each of the
individuals detected during the survey. Note that transects
without detections have a value of NA for this variable.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set is used to illustrate classic distance sampling (Buckland
et al. 2001, Mazerolle 2015). 
</p>


<h3>Source</h3>

<p>Buckland, S. T., Anderson, D. R., Burnham, K. P., Laake, J. L.,
Borchers, D. L., Thomas, L. (2001) <em>Introduction to distance
sampling: estimating abundance of biological populations.</em> Oxford
University Press: Oxford.
</p>
<p>Mazerolle, M. J. (2015) Estimating detectability and biological
parameters of interest with the use of the R
environment. <em>Journal of Herpetology</em> <b>49</b>, 541&ndash;559.
</p>
<p>Smith, L. L., Linehan, J. M., Stober, J. M., Elliott, M. J., Jensen,
J. B. (2009) An evaluation of distance sampling for large-scale gopher
tortoise surveys in Georgia, USA. <em>Applied Herpetology</em> <b>6</b>,
355&ndash;368.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tortoise)
str(tortoise)

##plot distance data to determine if truncation is required
##(Buckland et al. 2001, pp. 15--17)
hist(tortoise$distance)
</code></pre>

<hr>
<h2 id='turkey'>
Turkey Weight Gain
</h2><span id='topic+turkey'></span>

<h3>Description</h3>

<p>This one-way ANOVA data set presents turkey weight gain in pounds across
five diets. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(turkey)</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 2 variables.
</p>

<dl>
<dt><code>Diet</code></dt><dd><p>diet factor with 5 levels.</p>
</dd>
<dt><code>Weight.gain</code></dt><dd><p>weight gain in pounds.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Heiberger and Holland (2004) and Ott (1993) analyze
this data set to illustrate one-way ANOVA.
</p>


<h3>Source</h3>

<p>Heiberger, R. M., Holland, B. (2004) <em>Statistical Analysis and Data
Display:  an intermediate course with examples in S-Plus, R, and
SAS</em>. Springer: New York.
</p>
<p>Ott, R. L. (1993) <em>An Introduction to Statistical Methods and Data
Analysis</em>. Fourth edition. Duxbury: Pacific Grove, CA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turkey)
str(turkey)
</code></pre>

<hr>
<h2 id='useBIC'>
Computing BIC or QBIC
</h2><span id='topic+useBIC'></span><span id='topic+useBIC.default'></span><span id='topic+useBIC.aov'></span><span id='topic+useBIC.betareg'></span><span id='topic+useBIC.clm'></span><span id='topic+useBIC.clmm'></span><span id='topic+useBIC.coxme'></span><span id='topic+useBIC.coxph'></span><span id='topic+useBIC.fitdist'></span><span id='topic+useBIC.fitdistr'></span><span id='topic+useBIC.glm'></span><span id='topic+useBIC.glmmTMB'></span><span id='topic+useBIC.gls'></span><span id='topic+useBIC.gnls'></span><span id='topic+useBIC.hurdle'></span><span id='topic+useBIC.lavaan'></span><span id='topic+useBIC.lm'></span><span id='topic+useBIC.lme'></span><span id='topic+useBIC.lmekin'></span><span id='topic+useBIC.maxlikeFit'></span><span id='topic+useBIC.mer'></span><span id='topic+useBIC.merMod'></span><span id='topic+useBIC.lmerModLmerTest'></span><span id='topic+useBIC.multinom'></span><span id='topic+useBIC.nlme'></span><span id='topic+useBIC.nls'></span><span id='topic+useBIC.polr'></span><span id='topic+useBIC.rlm'></span><span id='topic+useBIC.survreg'></span><span id='topic+useBIC.unmarkedFit'></span><span id='topic+useBIC.vglm'></span><span id='topic+useBIC.zeroinfl'></span>

<h3>Description</h3>

<p>Functions to compute the Bayesian information criterion (BIC) or a
quasi-likelihood analogue (QBIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>useBIC(mod, return.K = FALSE, nobs = NULL, ...) 

## S3 method for class 'aov'
useBIC(mod, return.K = FALSE, nobs = NULL, ...) 

## S3 method for class 'betareg'
useBIC(mod, return.K = FALSE, nobs = NULL, ...) 

## S3 method for class 'clm'
useBIC(mod, return.K = FALSE, nobs = NULL, ...) 

## S3 method for class 'clmm'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)  

## S3 method for class 'coxme'
useBIC(mod, return.K = FALSE, nobs = NULL, ...) 

## S3 method for class 'coxph'
useBIC(mod, return.K = FALSE, nobs = NULL, ...) 

## S3 method for class 'fitdist'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'fitdistr'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'glm'
useBIC(mod, return.K = FALSE, nobs = NULL, c.hat = 1,
...)

## S3 method for class 'glmmTMB'
useBIC(mod, return.K = FALSE, nobs = NULL, c.hat = 1,
...)

## S3 method for class 'gls'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'gnls'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'hurdle'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'lavaan'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'lm'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'lme'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'lmekin'
useBIC(mod, return.K = FALSE, nobs = NULL, ...) 

## S3 method for class 'maxlikeFit'
useBIC(mod, return.K = FALSE, nobs = NULL, c.hat =
1, ...)

## S3 method for class 'mer'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'merMod'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)  

## S3 method for class 'lmerModLmerTest'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)  

## S3 method for class 'multinom'
useBIC(mod, return.K = FALSE, nobs = NULL, c.hat = 1,
...)

## S3 method for class 'nlme'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'nls'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'polr'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'rlm'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'survreg'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)

## S3 method for class 'unmarkedFit'
useBIC(mod, return.K = FALSE, nobs = NULL, c.hat =
1, ...)

## S3 method for class 'vglm'
useBIC(mod, return.K = FALSE, nobs = NULL, c.hat = 1,
...)

## S3 method for class 'zeroinfl'
useBIC(mod, return.K = FALSE, nobs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="useBIC_+3A_mod">mod</code></td>
<td>

<p>an object of class <code>aov</code>, <code>betareg</code>, <code>clm</code>,
<code>clmm</code>, <code>clogit</code>, <code>coxme</code>, <code>coxph</code>,
<code>fitdist</code>, <code>fitdistr</code>, <code>glm</code>, <code>glmmTMB</code>,
<code>gls</code>, <code>gnls</code>, <code>hurdle</code>, <code>lavaan</code>, <code>lm</code>,
<code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code>, <code>multinom</code>, <code>nlme</code>,
<code>nls</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>, <code>vglm</code>,
<code>zeroinfl</code>, and various <code>unmarkedFit</code> classes containing
the output of a model. 
</p>
</td></tr>
<tr><td><code id="useBIC_+3A_return.k">return.K</code></td>
<td>

<p>logical.  If <code>FALSE</code>, the function returns the information
criterion specified.  If <code>TRUE</code>, the function returns K (number
of estimated parameters) for a given model.
</p>
</td></tr>
<tr><td><code id="useBIC_+3A_nobs">nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total
sample size to compute the BIC (i.e., <code>nobs</code> defaults to total
number of observations).  This is relevant only for mixed models or
various models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the 
value of <code>nobs</code>.
</p>
</td></tr>
<tr><td><code id="useBIC_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>.  Note that values of c.hat
different from 1 are only appropriate for binomial GLM's with trials
&gt; 1 (i.e., success/trial or cbind(success, failure) syntax), with
Poisson GLM's, single-season occupancy models (MacKenzie et al. 2002),
dynamic occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture
models (Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>useBIC</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td></tr>
<tr><td><code id="useBIC_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>useBIC</code> computes the Bayesian information criterion (BIC,
Schwarz 1978): </p>
<p style="text-align: center;"><code class="reqn">BIC = -2 * log-likelihood + K * log(n),</code>
</p>
<p> where
the log-likelihood is the maximum log-likelihood of the model, <em>K</em>
corresponds to the number of estimated parameters, and <em>n</em>
corresponds to the sample size of the data set.
</p>
<p>In the presence of overdispersion, a quasi-likelihood analogue of
the BIC (QBIC) will be computed, as </p>
<p style="text-align: center;"><code class="reqn">QBIC = \frac{-2 *
    log-likelihood}{c-hat} + K * log(n),</code>
</p>
<p> where <em>c-hat</em> is the
overdispersion parameter specified by the user with the argument
<code>c.hat</code>.  Note that BIC or QBIC values are meaningful to select
among <code>gls</code> or <code>lme</code> models fit by maximum likelihood.
BIC or QBIC based on REML are valid to select among different models
that only differ in their random effects (Pinheiro and Bates 2000). 
</p>


<h3>Value</h3>

<p><code>useBIC</code> returns the BIC or the number of estimated parameters,
depending on the values of the arguments.
</p>


<h3>Note</h3>

<p>The actual (Q)BIC values are not really interesting in themselves, as
they depend directly on the data, parameters estimated, and likelihood
function.  Furthermore, a single value does not tell much about model
fit.  Information criteria become relevant when compared to one
another for a given data set and set of candidate models. 
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Pinheiro, J. C., Bates, D. M. (2000) <em>Mixed-effect models in S and
S-PLUS</em>. Springer Verlag: New York.  
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>
<p>Schwarz, G. (1978) Estimating the dimension of a model. <em>Annals of
Statistics</em> <b>6</b>, 461&ndash;464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+bictab">bictab</a></code>,
<code><a href="#topic+bictabCustom">bictabCustom</a></code>, <code><a href="#topic+useBICCustom">useBICCustom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##cement data from Burnham and Anderson (2002, p. 101)
data(cement)
##run multiple regression - the global model in Table 3.2
glob.mod &lt;- lm(y ~ x1 + x2 + x3 + x4, data = cement)

##compute BIC with full likelihood
useBIC(glob.mod, return.K = FALSE)

##compute BIC for mixed model on Orthodont data set in Pinheiro and
##Bates (2000)
## Not run: 
require(nlme)
m1 &lt;- lme(distance ~ age, random = ~1 | Subject, data = Orthodont,
          method= "ML")
useBIC(m1, return.K = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='useBICCustom'>
Custom Computation of BIC and QBIC from User-supplied Input
</h2><span id='topic+useBICCustom'></span>

<h3>Description</h3>

<p>This function computes the Bayesian information criterion (BIC) or a
quasi-likelihood counterpart (QBIC) from user-supplied input instead
of extracting the values automatically from a model object.  This
function is particularly useful for output imported from other
software or for model classes that are not currently supported by
<code>useBIC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>useBICCustom(logL, K, return.K = FALSE, nobs = NULL, c.hat = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="useBICCustom_+3A_logl">logL</code></td>
<td>

<p>the value of the model log-likelihood.
</p>
</td></tr>
<tr><td><code id="useBICCustom_+3A_k">K</code></td>
<td>

<p>the number of estimated parameters in the model.
</p>
</td></tr>
<tr><td><code id="useBICCustom_+3A_return.k">return.K</code></td>
<td>

<p>logical.  If <code>FALSE</code>, the function returns the information
criterion specified.  If <code>TRUE</code>, the function returns K (number
of estimated parameters) for a given model.  
</p>
</td></tr>
<tr><td><code id="useBICCustom_+3A_nobs">nobs</code></td>
<td>

<p>the sample size required to compute the BIC or QBIC.
</p>
</td></tr>
<tr><td><code id="useBICCustom_+3A_c.hat">c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>c_hat</code>.  Note that values of
<code>c.hat</code> different from 1 are only appropriate for binomial GLM's
with trials &gt; 1 (i.e., success/trial or cbind(success, failure)
syntax), with Poisson GLM's, single-season or dynamic occupancy
models (MacKenzie et al. 2002, 2003), <em>N</em>-mixture models (Royle
2004, Dail and Madsen 2011), or capture-mark-recapture models (e.g.,
Lebreton et al. 1992).  If c.hat &gt; 1, <code>useBICCustom</code> will return
the quasi-likelihood analogue of the information criterion requested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>useBICCustom</code> computes one of the following two information
criteria:
</p>
<p>the Bayesian information criterion (BIC, Schwarz 1978) or the
quasi-likelihood BIC (QBIC).
</p>


<h3>Value</h3>

<p><code>useBICCustom</code> returns the BIC or QBIC depending on the values of
the <code>c.hat</code> argument.
</p>


<h3>Note</h3>

<p>The actual (Q)BIC values are not really interesting in themselves,
as they depend directly on the data, parameters estimated, and
likelihood function.  Furthermore, a single value does not tell much
about model fit.  Information criteria become relevant when compared
to one another for a given data set and set of candidate models.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577&ndash;587. 
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67&ndash;118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200&ndash;2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108&ndash;115.
</p>
<p>Schwarz, G. (1978) Estimating the dimension of a model. <em>Annals of
Statistics</em> <b>6</b>, 461&ndash;464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="#topic+aictabCustom">aictabCustom</a></code>, <code><a href="#topic+useBIC">useBIC</a></code>, 
<code><a href="#topic+bictab">bictab</a></code>, <code><a href="#topic+evidence">evidence</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##cement data from Burnham and Anderson (2002, p. 101)
data(cement)
##run multiple regression - the global model in Table 3.2
glob.mod &lt;- lm(y ~ x1 + x2 + x3 + x4, data = cement)

##extract log-likelihood
LL &lt;- logLik(glob.mod)[1]

##extract number of parameters
##including residual variance
K.mod &lt;- length(coef(glob.mod)) + 1

##compute BIC with full likelihood
useBICCustom(LL, K.mod, nobs = nrow(cement))
##compare against useBIC
useBIC(glob.mod)
</code></pre>

<hr>
<h2 id='xtable'>
Format Objects to LaTeX or HTML
</h2><span id='topic+xtable.aictab'></span><span id='topic+xtable.anovaOD'></span><span id='topic+xtable.bictab'></span><span id='topic+xtable.boot.wt'></span><span id='topic+xtable.checkParms'></span><span id='topic+xtable.countDist'></span><span id='topic+xtable.countHist'></span><span id='topic+xtable.detHist'></span><span id='topic+xtable.detTime'></span><span id='topic+xtable.dictab'></span><span id='topic+xtable.ictab'></span><span id='topic+xtable.mb.chisq'></span><span id='topic+xtable.modavg'></span><span id='topic+xtable.modavgCustom'></span><span id='topic+xtable.modavgEffect'></span><span id='topic+xtable.modavgIC'></span><span id='topic+xtable.modavgPred'></span><span id='topic+xtable.modavgShrink'></span><span id='topic+xtable.multComp'></span><span id='topic+xtable.summaryOD'></span>

<h3>Description</h3>

<p>Functions to format various objects following model selection and
multimodel inference to LaTeX or HTML tables.  These functions extend the
methods from the <code>xtable</code> package (Dahl 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aictab'
xtable(x, caption = NULL, label = NULL, align = NULL, 
        digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, include.AICc = TRUE,
        include.LL = TRUE, include.Cum.Wt = FALSE, ...)

## S3 method for class 'anovaOD'
xtable(x, caption = NULL, label = NULL, align = NULL,
       digits = NULL, display = NULL, auto = FALSE, 
       nice.names = TRUE, ...)

## S3 method for class 'bictab'
xtable(x, caption = NULL, label = NULL, align = NULL, 
        digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, include.BIC = TRUE, include.LL = TRUE,
        include.Cum.Wt = FALSE, ...)

## S3 method for class 'boot.wt'
xtable(x, caption = NULL, label = NULL, align = NULL,
        digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, include.AICc = TRUE, include.AICcWt = FALSE, ...)

## S3 method for class 'countDist'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, table.countDist = "distance", ...)

## S3 method for class 'checkParms'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, include.variable = TRUE, include.max.se =
        TRUE, include.n.high.se = TRUE, ...)

## S3 method for class 'countHist'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, table.countHist = "count", ...)

## S3 method for class 'detHist'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, table.detHist = "freq", ...)

## S3 method for class 'detTime'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, table.detTime = "freq", ...)

## S3 method for class 'dictab'
xtable(x, caption = NULL, label = NULL, align = NULL, 
        digits = NULL, display = NULL, auto = FALSE, 
        nice.names = TRUE, include.DIC = TRUE, include.Cum.Wt = FALSE, ...)

## S3 method for class 'ictab'
xtable(x, caption = NULL, label = NULL, align = NULL,
        digits = NULL, display = NULL, auto = FALSE, nice.names = TRUE,
        include.IC = TRUE, include.Cum.Wt = FALSE, ...)

## S3 method for class 'mb.chisq'
xtable(x, caption = NULL, label = NULL, align = NULL,
        digits = NULL, display = NULL, auto = FALSE, nice.names = TRUE,
        include.detection.histories = TRUE, ...)

## S3 method for class 'modavg'
xtable(x, caption = NULL, label = NULL, align = NULL,
        digits = NULL, display = NULL, auto = FALSE, nice.names = TRUE,
        print.table = FALSE, ...)

## S3 method for class 'modavgCustom'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, print.table = FALSE, ...)

## S3 method for class 'modavgEffect'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, print.table = FALSE, ...)

## S3 method for class 'modavgIC'
xtable(x, caption = NULL, label = NULL, align = NULL,
        digits = NULL, display = NULL, auto = FALSE, nice.names = TRUE,
        print.table = FALSE, ...)

## S3 method for class 'modavgPred'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, ...)

## S3 method for class 'modavgShrink'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, print.table = FALSE, ...)

## S3 method for class 'multComp'
xtable(x, caption = NULL, label = NULL,
        align = NULL, digits = NULL, display = NULL, auto = FALSE,
        nice.names = TRUE, print.table = FALSE, ...)

## S3 method for class 'summaryOD'
xtable(x, caption = NULL, label = NULL, align = NULL,
                           digits = NULL, display = NULL, auto = FALSE, 
                           nice.names = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtable_+3A_x">x</code></td>
<td>

<p>an object of class <code>aictab</code>, <code>anovaOD</code>, <code>bictab</code>,
<code>boot.wt</code>, <code>checkParms</code>, <code>countDist</code>,
<code>countHist</code>, <code>detHist</code>, <code>detTime</code>, <code>dictab</code>,
<code>ictab</code>, <code>mb.chisq</code>, <code>modavg</code>, <code>modavgEffect</code>,
<code>modavgCustom</code>, <code>modavgIC</code>, <code>modavgPred</code>,
<code>modavgShrink</code>, <code>multComp</code>, or <code>summaryOD</code>.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_caption">caption</code></td>
<td>

<p>a character vector of length 1 or 2 storing the caption or title of
the table.  If the vector is of length 2, the second item is the
short caption used when LaTeX generates a list of tables.  The
default value is <code>NULL</code> and suppresses the caption.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_label">label</code></td>
<td>
 
<p>a character vector storing the LaTeX label or HTML anchor.  The default
value is <code>NULL</code> and suppresses the label. 
</p>
</td></tr>
<tr><td><code id="xtable_+3A_align">align</code></td>
<td>

<p>a character vector of length equal to the number of columns of the
table specifying the alignment of the elements.  Note that the rownames
are considered as an additional column and require an alignment value.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_digits">digits</code></td>
<td>

<p>a numeric vector of length one or equal to the number of columns in
the table (including the rownames) specifying the number of digits to
display in each column. 
</p>
</td></tr>
<tr><td><code id="xtable_+3A_display">display</code></td>
<td>

<p>a character vector of length equal to the number of columns
(including the rownames) specifying the format of each column.  For
example, use <code>s</code> for strings, <code>f</code> for numbers in the
regular format, or <code>d</code> for integers.  See <code>formatC</code> for
additional possible values.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_auto">auto</code></td>
<td>

<p>Logical, indicating whether to apply automatic format when no value
is passed to <code>align</code>, <code>digits</code>, or <code>display</code>. This
<code>autoformat</code> (based on <code>xalign</code>, <code>xdigits</code>, and <code>xdisplay</code>)
can be useful to quickly format a typical <code>matrix</code> or
<code>data.frame</code>. Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_nice.names">nice.names</code></td>
<td>

<p>logical.  If <code>TRUE</code>, column labels are modified to improve their
appearance in the table.  If <code>FALSE</code>, simpler labels are used,
or the ones supplied directly by the user in the object storing the
output.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.aicc">include.AICc</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the column containing
the information criterion (AIC, AICc, QAIC, or QAICc) of each model
is printed in the table.  If <code>FALSE</code>, the column is
suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.bic">include.BIC</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the column containing
the information criterion (BIC or QBIC) of each model is printed in
the table.  If <code>FALSE</code>, the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.dic">include.DIC</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the column containing
the deviance information criterion (DIC) of each model is printed in
the table.  If <code>FALSE</code>, the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.ic">include.IC</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the column containing
the information criterion of each model is printed in the table.  If
<code>FALSE</code>, the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.ll">include.LL</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the column containing the
log-likelihood of each model is printed in the table.  If
<code>FALSE</code>, the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.cum.wt">include.Cum.Wt</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the column containing
the cumulative Akaike weights is printed in the table.  If
<code>FALSE</code>, the column is suppressed. 
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.aiccwt">include.AICcWt</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the column containing
the Akaike weight of each model is printed in the table.  If
<code>FALSE</code>, the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.detection.histories">include.detection.histories</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the
column containing detection histories is printed in the table.  If
<code>FALSE</code>, the column is suppressed. 
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.variable">include.variable</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the
column containing the variable name is printed in the table.  If
<code>FALSE</code>, the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.max.se">include.max.se</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the
column containing the maximum SE in the model is printed in the
table.  If <code>FALSE</code>, the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_include.n.high.se">include.n.high.se</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the
column containing the number of SE's greater than the threshold 
specified by the user is printed in the table.  If <code>FALSE</code>,
the column is suppressed.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_print.table">print.table</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the model selection table
is printed and other sections of the output are suppressed (e.g.,
model-averaged estimates).  If <code>FALSE</code>, the model selection
table is suppressed and only the other portion of the output is
printed in the table.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_table.dethist">table.detHist</code></td>
<td>
<p>character string specifying, either <code>"freq"</code>,
<code>"prop"</code>, or <code>"hist"</code>.  If <code>table.type = "freq"</code>, the
function returns a table of frequencies of sites sampled, of sites with
at least one detection, and for data with multiple primary periods,
the frequencies of sites with observed extinctions and colonizations.
If <code>table.type = "prop"</code>, the table returns the proportion of
sites with at least one detection, and for data with multiple periods,
the proportion of sites with observed extinctions and colonizations.
If <code>table.type = "hist"</code>, the function returns the frequencies of
each observed detection history.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_table.dettime">table.detTime</code></td>
<td>
<p>character string specifying, either <code>"freq"</code>,
<code>"prop"</code>, or <code>"dist"</code>.  If <code>table.type = "freq"</code>, the
function returns a table of frequencies of sites sampled, of sites with
at least one detection, and for data with multiple primary periods,
the frequencies of sites with observed extinctions and colonizations.
If <code>table.type = "prop"</code>, the table returns the proportion of
sites with at least one detection, and for data with multiple periods,
the proportion of sites with observed extinctions and colonizations.
If <code>table.type = "dist"</code>, the function returns the quantiles of
detection times.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_table.countdist">table.countDist</code></td>
<td>
<p>character string specifying, either
<code>"distance"</code>, <code>"count"</code>, <code>"freq"</code>, or <code>"prop"</code>.  If
<code>table.type = "distance"</code>, the function returns a table of counts
summarized for each distance class.  If <code>table.type = "count"</code>,
the function returns the table of frequencies of counts observed
across sites.  If <code>table.type = "freq"</code>, the function returns a
table of frequencies of sites sampled, of sites with at least one
detection, and for data with multiple primary periods, the frequencies
of sites with observed extinctions and colonizations.  If
<code>table.type = "prop"</code>, the table returns the proportion of sites
with at least one detection, and for data with multiple periods, the
proportion of sites with observed extinctions and colonizations.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_table.counthist">table.countHist</code></td>
<td>
<p>character string specifying, either
<code>"count"</code>, <code>"freq"</code>, <code>"prop"</code>, or <code>"hist"</code>.  If
<code>table.type = "count"</code>, the function returns the table of
frequencies of counts observed across sites.  If <code>table.type =
  "freq"</code>, the function returns a table of frequencies of sites sampled,
of sites with at least one detection, and for data with multiple
primary periods, the frequencies of sites with observed extinctions
and colonizations.  If <code>table.type = "prop"</code>, the table returns
the proportion of sites with at least one detection, and for data with
multiple periods, the proportion of sites with observed extinctions
and colonizations.  If <code>table.type = "hist"</code>, the function
returns the frequencies of each observed count history.
</p>
</td></tr>
<tr><td><code id="xtable_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xtable</code> creates an object of the <code>xtable</code> class inheriting
from the <code>data.frame</code> class.  This object can then be used with
<code>print.xtable</code> for added flexibility such as suppressing row names,
modifying caption placement, and format tables in LaTeX or HTML
format.
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Dahl, D. B. (2014) xtable: Export tables to LaTeX or HTML. R package
version 1.7-3. <a href="https://cran.r-project.org/package=xtable">https://cran.r-project.org/package=xtable</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aictab">aictab</a></code>, <code><a href="#topic+boot.wt">boot.wt</a></code>, <code><a href="#topic+dictab">dictab</a></code>,
<code><a href="base.html#topic+formatC">formatC</a></code>, <code><a href="#topic+ictab">ictab</a></code>, <code><a href="#topic+mb.chisq">mb.chisq</a></code>,
<code><a href="#topic+modavg">modavg</a></code>, <code><a href="#topic+modavgCustom">modavgCustom</a></code>,
<code><a href="#topic+modavgIC">modavgIC</a></code>, <code><a href="#topic+modavgEffect">modavgEffect</a></code>,
<code><a href="#topic+modavgPred">modavgPred</a></code>, <code><a href="#topic+modavgShrink">modavgShrink</a></code>,
<code><a href="#topic+multComp">multComp</a></code>, <code><a href="#topic+summaryOD">summaryOD</a></code>, <code><a href="#topic+anovaOD">anovaOD</a></code>,
<code><a href="xtable.html#topic+xtable">xtable</a></code>, <code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(xtable)) {
##model selection example
data(dry.frog)
##setup candidate models
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Model.names &lt;- c("additive", "interaction", "no shade")

##model selection table - AICc
out &lt;- aictab(cand.set = Cand.models, modnames = Model.names)

xtable(out)
##exclude AICc and LL
xtable(out, include.AICc = FALSE, include.LL = FALSE)
##remove row names and add caption
print(xtable(out, caption = "Model selection based on AICc"),
      include.rownames = FALSE, caption.placement = "top")


##model selection table - BIC
out2 &lt;- bictab(cand.set = Cand.models, modnames = Model.names)

xtable(out2)
##exclude AICc and LL
xtable(out2, include.BIC = FALSE, include.LL = FALSE)
##remove row names and add caption
print(xtable(out2, caption = "Model selection based on BIC"),
      include.rownames = FALSE, caption.placement = "top")


##model-averaged estimate of Initial_mass2
mavg.mass &lt;- modavg(cand.set = Cand.models, parm = "Initial_mass2",
                    modnames = Model.names)
#model-averaged estimate
xtable(mavg.mass, print.table = FALSE)
#table with contribution of each model
xtable(mavg.mass, print.table = TRUE)  


##model-averaged predictions for first 10 observations
preds &lt;- modavgPred(cand.set = Cand.models, modnames = Model.names,
                    newdata = dry.frog[1:10, ])
xtable(preds)
}


##example of diagnostics
## Not run: 
if(require(unmarked)){
##distance sampling example from ?distsamp
data(linetran)
ltUMF &lt;- with(linetran, {
              unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
              siteCovs = data.frame(Length, area, habitat),
              dist.breaks = c(0, 5, 10, 15, 20),
              tlength = linetran$Length * 1000, survey = "line",
              unitsIn = "m")
              })

##summarize counts across distance classes
xtable(countDist(ltUMF), table.countDist = "distance")
##summarize counts across all sites
xtable(countDist(ltUMF), table.countDist = "count")

##Half-normal detection function
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
##determine parameters with highest SE's
xtable(checkParms(fm1))
}

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
