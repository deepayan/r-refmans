<!DOCTYPE html><html><head><title>Help for package edmcr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {edmcr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A'><p>Molecule Metadata</p></a></li>
<li><a href='#colamdR'><p>Column Approximate Minimum Degree Permutation</p></a></li>
<li><a href='#dpf'><p>Dissimilarity Parameterization Formulation</p></a></li>
<li><a href='#edm2gram'><p>Linear Matrix Operator</p></a></li>
<li><a href='#edm2psd'><p>Linear Matrix Operator</p></a></li>
<li><a href='#edmc'><p>Euclidean Distance Matrix Completion</p></a></li>
<li><a href='#getConfig'><p>Create a Point Configuration from a Distance Matrix</p></a></li>
<li><a href='#gram2edm'><p>Linear Matrix Operator</p></a></li>
<li><a href='#grs'><p>Guided Random Search</p></a></li>
<li><a href='#mst'><p>Compute Minimum Spanning Tree</p></a></li>
<li><a href='#mstLB'><p>Minimum Spanning Tree Preserving Lower Bound</p></a></li>
<li><a href='#mstUB'><p>Shortest Path Upper Bound</p></a></li>
<li><a href='#npf'><p>Nonparametric Position Formulation</p></a></li>
<li><a href='#primPath'><p>Minimum Spanning Tree Path</p></a></li>
<li><a href='#psd2edm'><p>Linear Matrix Operator</p></a></li>
<li><a href='#rgrs'><p>Relaxed Guided Random Search</p></a></li>
<li><a href='#sdp'><p>Semi-Definite Programming Algorithm</p></a></li>
<li><a href='#snl'><p>Sensor Network Localization</p></a></li>
<li><a href='#sprosr'><p>Semidefinite Programming-based Protein Structure Determination</p></a></li>
<li><a href='#sprosr_aco'><p>Demo Data - ACO</p></a></li>
<li><a href='#sprosr_seq'><p>Demo Data - SEQ</p></a></li>
<li><a href='#sprosr_upl'><p>Demo Data - UPL</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Euclidean Distance Matrix Completion Tools</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various general algorithms to estimate missing elements
   of a Euclidean (squared) distance matrix.  
   Includes optimization methods based on semi-definite programming found in
   Alfakih, Khadani, and Wolkowicz (1999)&lt;<a href="https://doi.org/10.1023%2FA%3A1008655427845">doi:10.1023/A:1008655427845</a>&gt;, 
   a non-convex position formulation by Fang and O'Leary (2012)&lt;<a href="https://doi.org/10.1080%2F10556788.2011.643888">doi:10.1080/10556788.2011.643888</a>&gt;, and 
   a dissimilarity parameterization formulation by Trosset (2000)&lt;<a href="https://doi.org/10.1023%2FA%3A1008722907820">doi:10.1023/A:1008722907820</a>&gt;.
   When the only non-missing
   distances are those on the minimal spanning tree, the guided random search
   algorithm will complete the matrix while preserving the minimal spanning tree following
   Rahman and Oldford (2018)&lt;<a href="https://doi.org/10.1137%2F16M1092350">doi:10.1137/16M1092350</a>&gt;.
   Point configurations in specified dimensions can be determined from the completions. 
   Special problems such as the sensor localization problem, 
   as for example in Krislock and Wolkowicz (2010)&lt;<a href="https://doi.org/10.1137%2F090759392">doi:10.1137/090759392</a>&gt;,
   as well as reconstructing
   the geometry of a molecular structure, as for example in 
   Hendrickson (1995)&lt;<a href="https://doi.org/10.1137%2F0805040">doi:10.1137/0805040</a>&gt;, can also be solved.
   These and other methods are described in the thesis of Adam Rahman(2018)<a href="https://hdl.handle.net/10012/13365">https://hdl.handle.net/10012/13365</a>.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>R. Wayne Oldford &lt;rwoldford@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/great-northern-diver/edmcr">https://github.com/great-northern-diver/edmcr</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, igraph, lbfgs, truncnorm, MASS, nloptr, vegan, sdpt3r,
utils, methods, stats</td>
</tr>
<tr>
<td>KeepSource:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-08 17:59:30 UTC; rwoldford</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Rahman [aut],
  R. Wayne Oldford [aut, cre, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-10 10:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='A'>Molecule Metadata</h2><span id='topic+A'></span>

<h3>Description</h3>

<p>Molecule Metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(A)
</code></pre>


<h3>Format</h3>

<p>list
</p>

<hr>
<h2 id='colamdR'>Column Approximate Minimum Degree Permutation</h2><span id='topic+colamdR'></span>

<h3>Description</h3>

<p><code>colamdR</code> returns the column approximate minimum degree permutation of a 
sparse matrix S. The permutation of S, S[,p], will result in LU factors sparser
than S.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colamdR(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colamdR_+3A_m">M</code></td>
<td>
<p>A matrix to be permuted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the colamd function available in SuiteSparse, and also implemented in Matlab.
</p>


<h3>Value</h3>

<p>A vector containing the column minimum degree permutation of the matrix M.
</p>


<h3>References</h3>

<p>The authors of the code for &quot;colamd&quot; are Stefan I. Larimore and Timothy A. Davis (davis@cise.ufl.edu), University of Florida.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(1,1,0,0,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0), ncol=4)
p &lt;- colamdR(M)
M[,p]

</code></pre>

<hr>
<h2 id='dpf'>Dissimilarity Parameterization Formulation</h2><span id='topic+dpf'></span>

<h3>Description</h3>

<p><code>dpf</code> returns a completed Euclidean Distance Matrix D, with dimension d,
from a partial Euclidean Distance Matrix using the methods of Trosset (2000)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpf(D, d, toler = 1e-08, lower = NULL, upper = NULL, retainMST = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpf_+3A_d">D</code></td>
<td>
<p>An nxn partial-distance matrix to be completed. D must satisfy a list of conditions (see details), with unkown entries set to NA</p>
</td></tr>
<tr><td><code id="dpf_+3A_d">d</code></td>
<td>
<p>The dimension for the resulting completion.</p>
</td></tr>
<tr><td><code id="dpf_+3A_toler">toler</code></td>
<td>
<p>The convergence tolerance of the algorithm. Set to a default value of 1e-8</p>
</td></tr>
<tr><td><code id="dpf_+3A_lower">lower</code></td>
<td>
<p>An nxn matrix containing the lower bounds for the unknown entries in D. 
If NULL, lower is set to be a matrix of 0s.</p>
</td></tr>
<tr><td><code id="dpf_+3A_upper">upper</code></td>
<td>
<p>An nxn matrix containing the upper bounds of the unknown entries in D. 
If NULL, upper[i,j] is set to be the shortest path between node i and node j.</p>
</td></tr>
<tr><td><code id="dpf_+3A_retainmst">retainMST</code></td>
<td>
<p>D logical input indicating if the current minimum spanning tree structure in D should be retained.
If TRUE, a judicious choice of Lower is calculated internally such that the MST is retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the Dissimilarity Parameterization Formulation (DPF)
for Euclidean Distance Matrix Completion, as proposed in 'Distance Matrix Completion by Numerical
Optimization' (Trosset, 2000).
</p>
<p>The method seeks to minimize the following:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^{d}(\lambda_{i} - \lambda_{max}) + \sum_{i=d+1}^{n}\lambda_{i}^{2}</code>
</p>

<p>where <code class="reqn">\lambda_{i}</code> are the ordered eigenvalues of <code class="reqn">\tau(\Delta)</code>. For details, see Trosset(2000)
</p>
<p>The matrix D is a partial-distance matrix, meaning some of its entries are unknown. 
It must satisfy the following conditions in order to be completed:
</p>

<ul>
<li><p>diag(D) = 0
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is known, <code class="reqn">a_{ji} = a_{ij}</code>
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is unknown, so is <code class="reqn">a_{ji}</code>
</p>
</li>
<li><p>The graph of D must be connected. If D can be decomposed into two (or more) subgraphs, 
then the completion of D can be decomposed into two (or more) independent completion problems.
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>The completed distance matrix with dimensionality d</p>
</td></tr>
<tr><td><code>optval</code></td>
<td>
<p>The minimum function value achieved during minimization (see details)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Trosset, M.W. (2000). Distance Matrix Completion by Numerical Optimization.Computational Optimization and Applications, 17, 11â€“22, 2000.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1337)
D &lt;- matrix(c(0,3,4,3,4,3,
             3,0,1,NA,5,NA,
             4,1,0,5,NA,5,
             3,NA,5,0,1,NA,
             4,5,NA,1,0,5,
             3,NA,5,NA,5,0),byrow=TRUE, nrow=6)

edmc(D, method="dpf", d=3, toler=1e-8)

</code></pre>

<hr>
<h2 id='edm2gram'>Linear Matrix Operator</h2><span id='topic+edm2gram'></span>

<h3>Description</h3>

<p><code>edm2gram</code> Linear transformation of a Euclidean Distance Matrix to a Gram Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edm2gram(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edm2gram_+3A_d">D</code></td>
<td>
<p>A Euclidean Distance Matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While we specify that the input should be a Euclidean Distance Matrix (as this results in a Gram Matrix)
the domain of edm2gram is the set of all real symmetric matrices. This function is particularly useful
as it has the following property:
</p>
<p style="text-align: center;"><code class="reqn">edm2gram(D_{n}^{-}) = B_{n}^{+}</code>
</p>
 
<p>where <code class="reqn">D_{n}^{-}</code> is the space of symmetric, hollow matrices, negative definite on the space spanned by <code class="reqn">x'e = 0</code>
and <code class="reqn">B_{n}^{+}</code> is the space of centered positive definite matrices. 
</p>
<p>We can combine these two properties with a well known result: If D is a real symmetric matrix with 0 diagonal (call this matrix pre-EDM),
then D is a Euclidean Distance Matrix iff D is negative semi-definite on <code class="reqn">D_{n}^{-}</code>.
</p>
<p>Using this result, combined with the properties of edm2gram we therefore have that 
D is an EDM iff D is pre-EDM and <code class="reqn">edm2gram{D}</code> is positive semi-definite.
</p>


<h3>Value</h3>

<p>G A Gram Matrix, where G = XX', and X is an nxp matrix containing the point configuration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
XY &lt;- cbind(runif(100,0,1),runif(100,0,1))
D &lt;- dist(XY)
edm2gram(as.matrix(D))

</code></pre>

<hr>
<h2 id='edm2psd'>Linear Matrix Operator</h2><span id='topic+edm2psd'></span>

<h3>Description</h3>

<p><code>edm2psd</code> Convert an Euclidean Distance Matrix to a Positive Semi-definite Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edm2psd(D, V = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edm2psd_+3A_d">D</code></td>
<td>
<p>A matrix in the set D_n^-.</p>
</td></tr>
<tr><td><code id="edm2psd_+3A_v">V</code></td>
<td>
<p>A projection matrix satisfying V'1 = 0 and VV' = I</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a matrix D in <code class="reqn">D_{n}^{-}</code>, edm2psd will be in the space of positive
semi-definite matrices. Therefore, if D also has zero diagonal, we have the following property:
</p>
<p>D is a Euclidean Distance Matrix if and only if edm2psd is positive semi-definite.
</p>
<p>This operator gives us another method to characterize the existence of a Euclidean distance matrix.
</p>


<h3>Value</h3>

<p>S A symmetric, positive semi-definite matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psd2edm">psd2edm</a></code> <code><a href="#topic+edm2gram">edm2gram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
XY &lt;- cbind(runif(100,0,1),runif(100,0,1))
D &lt;- dist(XY)
edm2psd(as.matrix(D))

</code></pre>

<hr>
<h2 id='edmc'>Euclidean Distance Matrix Completion</h2><span id='topic+edmc'></span>

<h3>Description</h3>

<p><code>edmc</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edmc(D, method = "dpf", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edmc_+3A_d">D</code></td>
<td>
<p>An nxn partial-distance matrix to be completed, with unkown entries set to NA.</p>
</td></tr>
<tr><td><code id="edmc_+3A_method">method</code></td>
<td>
<p>The algorithm to be used to complete the distance matrix D. One of sdp, npf, dpf, snl, or grs</p>
</td></tr>
<tr><td><code id="edmc_+3A_...">...</code></td>
<td>
<p>The remaining input values required for the completion method specified in <code>method</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the method called, a number of input values are possible.
</p>


<h3>Value</h3>

<p>The return from <code>edmc</code> depends on the method used. The help pages for each individual method 
can be consulted for specific output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdp">sdp</a></code> <code><a href="#topic+npf">npf</a></code> <code><a href="#topic+dpf">dpf</a></code> <code><a href="#topic+snl">snl</a></code> <code><a href="#topic+grs">grs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1337)
D &lt;- matrix(c(0,3,4,3,4,3,
             3,0,1,NA,5,NA,
             4,1,0,5,NA,5,
             3,NA,5,0,1,NA,
             4,5,NA,1,0,5,
             3,NA,5,NA,5,0),byrow=TRUE, nrow=6)
             
edmc(D,method = "dpf", d=3, toler=1e-8)

</code></pre>

<hr>
<h2 id='getConfig'>Create a Point Configuration from a Distance Matrix</h2><span id='topic+getConfig'></span>

<h3>Description</h3>

<p><code>getConfig</code> - given an nxn Euclidean distance matrix, produces a d-dimensional
point configuration of size n via eigendecomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfig(D, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConfig_+3A_d">D</code></td>
<td>
<p>an nxn Euclidean distance matrix</p>
</td></tr>
<tr><td><code id="getConfig_+3A_d">d</code></td>
<td>
<p>the dimension for the configuration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a distance matrix D, transform to a semi-definite matrix S using the linear transformation <code class="reqn">\tau(D)</code>.
Using S, compute the eigen-decomposition <code class="reqn">S = ULV'</code>, where L is a diagonal matrix containing the singular-values of S,
and the columns of U contain the eigen-vectors. A point configuration X is then computed as:
</p>
<p style="text-align: center;"><code class="reqn">X = US^{.5}</code>
</p>

<p>To compute a configuration in d dimensions, the first d eigenvalues of S are used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>
<p>an nxd matrix containing the d-dimensional point configuration</p>
</td></tr>
<tr><td><code>Accuracy</code></td>
<td>
<p>the ratio of the sum of retained eigenvalues to the sum of all n eigenvalues obtained during decomposition</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1337)
D &lt;- matrix(c(0,3,4,3,4,3,
             3,0,1,NA,5,NA,
             4,1,0,5,NA,5,
             3,NA,5,0,1,NA,
             4,5,NA,1,0,5,
             3,NA,5,NA,5,0),byrow=TRUE, nrow=6)
d &lt;- 3
DStar &lt;- dpf(D,d)$D

getConfig(DStar,3)

</code></pre>

<hr>
<h2 id='gram2edm'>Linear Matrix Operator</h2><span id='topic+gram2edm'></span>

<h3>Description</h3>

<p><code>gram2edm</code> Inverse Operator of edm2gram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gram2edm(B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gram2edm_+3A_b">B</code></td>
<td>
<p>A centered, positive semi-definite matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edm2gram function performs the following transformation:
</p>
<p style="text-align: center;"><code class="reqn">edm2gram(D_{n}^{-}) = B_{n}^{+}</code>
</p>
 
<p>where <code class="reqn">D_{n}^{-}</code> is the space of symmetric, hollow matrices, negative definite on the space spanned by <code class="reqn">x'e = 0</code>
and <code class="reqn">B_{n}^{+}</code> is the space of centered positive definite matrices. 
</p>
<p>The gram2edm function performs the inverse operation, taking a matrix in <code class="reqn">B_{n}^{+}</code> and transforming it to a matrix in <code class="reqn">D_{n}^{-}</code>.
</p>
<p style="text-align: center;"><code class="reqn">gram2edm(B_{n}^{+}) = D_{n}^{-}</code>
</p>

<p>Therfore, gram2edm on <code class="reqn">B_{n}^{+}</code> is the inverse operator of edm2gram on <code class="reqn">D_{n}^{-}</code>.
</p>


<h3>Value</h3>

<p>D A matrix in <code class="reqn">D_{n}^{-}</code>. If the input matrix B is a gram matrix, D is a Euclidean Distance Matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edm2gram">edm2gram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
X &lt;- cbind(runif(100,0,1),runif(100,0,1))
G &lt;- X %*% t(X)
gram2edm(G)

</code></pre>

<hr>
<h2 id='grs'>Guided Random Search</h2><span id='topic+grs'></span>

<h3>Description</h3>

<p><code>grs</code> performs Euclidean Distance Matrix Completion using the guided random search algorithm
of Rahman &amp; Oldford. Using this method will preserve the minimum spanning tree in the partial distance 
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grs(D, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grs_+3A_d">D</code></td>
<td>
<p>An nxn partial-distance matrix to be completed. D must satisfy a list of conditions (see details), with unkown entries set to NA</p>
</td></tr>
<tr><td><code id="grs_+3A_d">d</code></td>
<td>
<p>The dimension for the resulting completion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix D is a partial-distance matrix, meaning some of its entries are unknown. 
It must satisfy the following conditions in order to be completed:
</p>

<ul>
<li><p>diag(D) = 0
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is known, <code class="reqn">a_{ji} = a_{ij}</code>
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is unknown, so is <code class="reqn">a_{ji}</code>
</p>
</li>
<li><p>The graph of D must contain ONLY the minimum spanning tree distances
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>P</code></td>
<td>
<p>The completed point configuration in dimension d</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The completed Euclidean distance matrix</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, D., &amp; Oldford, R.W. (2016). Euclidean Distance Matrix Completion and Point Configurations from the Minimal Spanning Tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#D matrix containing only the minimum spanning tree
D &lt;- matrix(c(0,3,NA,3,NA,NA,
              3,0,1,NA,NA,NA,
              NA,1,0,NA,NA,NA,
              3,NA,NA,0,1,NA,
              NA,NA,NA,1,0,1,
              NA,NA,NA,NA,1,0),byrow=TRUE, nrow=6)
              
edmc(D, method="grs", d=3)

</code></pre>

<hr>
<h2 id='mst'>Compute Minimum Spanning Tree</h2><span id='topic+mst'></span>

<h3>Description</h3>

<p><code>mst</code> Compute a minimum spanning tree using Prim's algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mst_+3A_d">D</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MST a data frame object of 3 columns containing the parent nodes, child nodes, and corresponding weight of the MST edge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- runif(10,0,1)
Y &lt;- runif(10,0,1)
D &lt;- dist(cbind(X,Y))

mst(as.matrix(D))

</code></pre>

<hr>
<h2 id='mstLB'>Minimum Spanning Tree Preserving Lower Bound</h2><span id='topic+mstLB'></span>

<h3>Description</h3>

<p><code>mstLB</code> Returns an nxn matrix containing the lower bounds for all unknown entries
in the partial distance matrix D such that the minimum spanning tree of the partial matrix D
is preserved upon completion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstLB(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstLB_+3A_d">D</code></td>
<td>
<p>An nxn partial distance matrix to be completed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The insight in constructing the lower bound is drawn from single-linkage clustering. 
Every edge in a spanning tree separates the vertices into two different groups, 
depending on which points remain connected to either one vertex or the other of that edge.
Because the tree is a minimum spanning tree, if we select the largest edge, then the distance
between any vertex of one group and any vertex of the other group must be at least as large as
that of the the largest edge.  This gives a lower bound for these distances that will preserve 
that edge in the minimum spanning tree.  The same reasoning is applied recursively to each separate
group, thus producing a lower bound on all edges.
</p>
<p>The details of the algorithm can be found in Rahman &amp; Oldford (2016).
</p>


<h3>Value</h3>

<p>Returns an nxn matrix containing the lower bound for the unknown entries in D
</p>


<h3>References</h3>

<p>Rahman, D., &amp; Oldford R.W. (2016). Euclidean Distance Matrix Completion and Point Configurations from the Minimal Spanning Tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D &lt;- matrix(c(0,3,4,3,4,3,
             3,0,1,NA,5,NA,
             4,1,0,5,NA,5,
             3,NA,5,0,1,NA,
             4,5,NA,1,0,5,
             3,NA,5,NA,5,0),byrow=TRUE, nrow=6)
mstLB(D)

</code></pre>

<hr>
<h2 id='mstUB'>Shortest Path Upper Bound</h2><span id='topic+mstUB'></span>

<h3>Description</h3>

<p><code>mstUB</code> Compute the shortest path upper bound for all unknown entries in a partial distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstUB(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstUB_+3A_a">A</code></td>
<td>
<p>A (connected) partial distance matrix, with unknown entries set to Inf</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the shortest.paths() function, available in the igraph package.
</p>


<h3>Value</h3>

<p>UB A matrix containing the upper bounds for only the unknown entries. All other entries will be set to Inf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- dist(cbind(rnorm(10,0,1),rnorm(10,0,1)))
mstUB(as.matrix(A))

</code></pre>

<hr>
<h2 id='npf'>Nonparametric Position Formulation</h2><span id='topic+npf'></span>

<h3>Description</h3>

<p><code>npf</code> returns a completed Euclidean Distance Matrix D, with dimension d,
from a partial Euclidean Distance Matrix using the methods of Fang &amp; O'Leary (2012)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npf(
  D,
  A = NA,
  d,
  dmax = (nrow(D) - 1),
  decreaseDim = 1,
  stretch = NULL,
  method = "Linear",
  toler = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npf_+3A_d">D</code></td>
<td>
<p>An nxn partial-distance matrix to be completed. D must satisfy a list of conditions (see details), with unkown entries set to NA.</p>
</td></tr>
<tr><td><code id="npf_+3A_a">A</code></td>
<td>
<p>a weight matrix, with <code class="reqn">h_{ij} = 0</code> implying <code class="reqn">a_{ij}</code> is unknown. Generally, if <code class="reqn">a_{ij}</code> is known, <code class="reqn">h_{ij} = 1</code>, although any non-negative weight is allowed.</p>
</td></tr>
<tr><td><code id="npf_+3A_d">d</code></td>
<td>
<p>the dimension of the resulting completion</p>
</td></tr>
<tr><td><code id="npf_+3A_dmax">dmax</code></td>
<td>
<p>the maximum dimension to consider during dimension relaxation</p>
</td></tr>
<tr><td><code id="npf_+3A_decreasedim">decreaseDim</code></td>
<td>
<p>during dimension reduction, the number of dimensions to decrease each step</p>
</td></tr>
<tr><td><code id="npf_+3A_stretch">stretch</code></td>
<td>
<p>should the distance matrix be multiplied by a scalar constant? If no, stretch = NULL, otherwise stretch is a positive scalar</p>
</td></tr>
<tr><td><code id="npf_+3A_method">method</code></td>
<td>
<p>The method used for dimension reduction, one of &quot;Linear&quot; or &quot;NLP&quot;.</p>
</td></tr>
<tr><td><code id="npf_+3A_toler">toler</code></td>
<td>
<p>convergence tolerance for the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the Nonconvex Position Formulation (npf)
for Euclidean Distance Matrix Completion, as proposed in 'Euclidean 
Distance Matrix Completion Problems' (Fang &amp; O'Leary, 2012).
</p>
<p>The method seeks to minimize the following:
</p>
<p style="text-align: center;"><code class="reqn">||A \cdot (D - K(XX'))||_{F}^{2}</code>
</p>

<p>where the function K() is that described in gram2edm, and the norm is Frobenius. Minimization is over X, the nxp matrix of node locations.
</p>
<p>The matrix D is a partial-distance matrix, meaning some of its entries are unknown. 
It must satisfy the following conditions in order to be completed:
</p>

<ul>
<li><p>diag(D) = 0
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is known, <code class="reqn">a_{ji} = a_{ij}</code>
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is unknown, so is <code class="reqn">a_{ji}</code>
</p>
</li>
<li><p>The graph of D must be connected. If D can be decomposed into two (or more) subgraphs, 
then the completion of D can be decomposed into two (or more) independent completion problems.
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>an nxn matrix of the completed Euclidean distances</p>
</td></tr>
<tr><td><code>optval</code></td>
<td>
<p>the minimum value achieved of the target function during minimization</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gram2edm">gram2edm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D &lt;- matrix(c(0,3,4,3,4,3,
             3,0,1,NA,5,NA,
             4,1,0,5,NA,5,
             3,NA,5,0,1,NA,
             4,5,NA,1,0,5,
             3,NA,5,NA,5,0),byrow=TRUE, nrow=6)
             
A &lt;- matrix(c(1,1,1,1,1,1,
             1,1,1,0,1,0,
             1,1,1,1,0,1,
             1,0,1,1,1,0,
             1,1,0,1,1,1,
             1,0,1,0,1,1),byrow=TRUE, nrow=6)

edmc(D, method="npf", d=3, dmax=5)

</code></pre>

<hr>
<h2 id='primPath'>Minimum Spanning Tree Path</h2><span id='topic+primPath'></span>

<h3>Description</h3>

<p><code>primPath</code> Given a starting node, creates the minimum spanning tree path through a point configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primPath(A, start)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primPath_+3A_a">A</code></td>
<td>
<p>the distance matrix for which the minimum spanning tree path will be created</p>
</td></tr>
<tr><td><code id="primPath_+3A_start">start</code></td>
<td>
<p>the starting node for the path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a starting node, compute Prim's algorithm, resulting in the path taken to construct the minimum spanning tree.
</p>


<h3>Value</h3>

<p>return a 2x(n-1) matrix, where row 1 contains the parent nodes of the MST path, and row 2 contains the corresponding child nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- dist(cbind(rnorm(100,0,1),rnorm(100,0,1)))
primPath(as.matrix(A),1)
primPath(as.matrix(A),2)

</code></pre>

<hr>
<h2 id='psd2edm'>Linear Matrix Operator</h2><span id='topic+psd2edm'></span>

<h3>Description</h3>

<p><code>psd2edm</code> Transform a positive semi-definite matrix to a Euclidean Distance Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psd2edm(S, V = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psd2edm_+3A_s">S</code></td>
<td>
<p>A symmetric, positive semi-definite matrix</p>
</td></tr>
<tr><td><code id="psd2edm_+3A_v">V</code></td>
<td>
<p>A projection matrix satisfying V'1 = 0 and VV' = I</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The psd2edm function performs the inverse operation of the edm2psd function, 
taking a matrix in <code class="reqn">S_{n-1}^{+}</code> and transforming it to a matrix in <code class="reqn">D_{n}^{-}</code>.
</p>
<p style="text-align: center;"><code class="reqn">psd2edm(S_{n-1}^{+}) = D_{n}^{-}</code>
</p>

<p>Therefore, psd2edm on <code class="reqn">S_{n-1}^{+}</code> is the inverse operator of  edm2psd on <code class="reqn">D_{n}^{-}</code>. 
</p>
<p>For a symmetric positive semi-definite matrix S, psd2edm(S) will be in <code class="reqn">D_{n}^{-}</code>.
</p>


<h3>Value</h3>

<p>D A Euclidean Distance Matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gram2edm">gram2edm</a></code> <code><a href="#topic+edm2psd">edm2psd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
XY &lt;- cbind(runif(100,0,1),runif(100,0,1))
S &lt;- edm2psd(as.matrix(dist(XY)))
D &lt;- psd2edm(S)

</code></pre>

<hr>
<h2 id='rgrs'>Relaxed Guided Random Search</h2><span id='topic+rgrs'></span>

<h3>Description</h3>

<p><code>rgrs</code> Produce a point configuration given the edge lengths of the desired minimum spanning tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgrs(
  edges = NULL,
  d,
  n = NULL,
  theta = NULL,
  outlying = "N",
  skew = "N",
  stringy = "N"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgrs_+3A_edges">edges</code></td>
<td>
<p>A numeric vector containing the desired edge lengths of the minimum spanning tree. If n is specified, must be NULL.</p>
</td></tr>
<tr><td><code id="rgrs_+3A_d">d</code></td>
<td>
<p>the dimension of the resulting configuration.</p>
</td></tr>
<tr><td><code id="rgrs_+3A_n">n</code></td>
<td>
<p>the desired number of edge lengths to simulate. If edges is specified, must be set to NULL.</p>
</td></tr>
<tr><td><code id="rgrs_+3A_theta">theta</code></td>
<td>
<p>Angle restriction during point proposal of the form (theta1,theta2,p), where p represents the probability of confining the proposal to [theta1,theta2]. Only used for d=2, otherwise NULL. See details for more in depth explanation.</p>
</td></tr>
<tr><td><code id="rgrs_+3A_outlying">outlying</code></td>
<td>
<p>One of &quot;L&quot;, &quot;M&quot;, or &quot;H&quot;, specifying if the simulated edge lengths should have a Low, Medium, or High outlying scagnostic value.</p>
</td></tr>
<tr><td><code id="rgrs_+3A_skew">skew</code></td>
<td>
<p>One of &quot;L&quot;, &quot;M&quot;, or &quot;H&quot;, specifying if the simulated edge lengths should have a Low, Medium, or High skew scagnostic value.</p>
</td></tr>
<tr><td><code id="rgrs_+3A_stringy">stringy</code></td>
<td>
<p>One of &quot;L&quot;, &quot;M&quot;, or &quot;H&quot;, specifying if the simulated edge lengths should have a Low, Medium, or High stringy scagnostic value. A numeric scalar specifying a value of stringy is also accepted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 2-dimensions, when a new point is proposed, the position for the new point is determined by:
</p>
<p>x &lt;- x0 + r*sin(theta)
y &lt;- y0 + r*cos(theta)
</p>
<p>where (x0,y0) is the base point, and r is the minimum spanning tree distance. 
theta is generated from a uniform distribution on (-pi,pi). By specifying the theta argument, the
proposed theta is restricted, and is then generated from Uniform(theta1,theta2) or Uniform(-theta2,-theta1) with equal probability.
This restriction allows the user to introduce striation into their point configuration.
</p>


<h3>Value</h3>

<p>An nxd matrix containing the d-dimensional locations of the points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# An example where edge lengths are supplied
EL &lt;- runif(100,0,1)
rgrs(edges = EL, d = 2)
rgrs(edges = EL, d = 3) 
 
# An Example where edge lengths are simulated internally
rgrs(d=2, n=100)
rgrs(d=3, n=100)
rgrs(d=2, n=100, outlying="H")
rgrs(d=2, n=100, skew = "M")
rgrs(d=2, n=100, stringy = "H")
 
# An Example making use of theta
rgrs(d=2, n=100, theta=c(pi/4,pi/3,.5))


</code></pre>

<hr>
<h2 id='sdp'>Semi-Definite Programming Algorithm</h2><span id='topic+sdp'></span>

<h3>Description</h3>

<p><code>sdp</code> returns a completed Euclidean Distance Matrix D, with dimension d,
from a partial Euclidean Distance Matrix using the methods of Alfakih et. al. (1999)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdp(D, A, toler = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdp_+3A_d">D</code></td>
<td>
<p>An nxn partial-distance matrix to be completed. D must satisfy a list of conditions (see details), with unkown entries set to NA.</p>
</td></tr>
<tr><td><code id="sdp_+3A_a">A</code></td>
<td>
<p>a weight matrix, with <code class="reqn">h_{ij} = 0</code> implying <code class="reqn">a_{ij}</code> is unknown. Generally, if <code class="reqn">a_{ij}</code> is known, <code class="reqn">h_{ij} = 1</code>, although any non-negative weight is allowed.</p>
</td></tr>
<tr><td><code id="sdp_+3A_toler">toler</code></td>
<td>
<p>convergence tolerance for the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the Semi-Definite Programming Algorithm (sdp)
for Euclidean Distance Matrix Completion, as proposed in 'Solving Euclidean 
Distance Matrix Completion Problems via Semidefinite Programming' (Alfakih et. al., 1999).
</p>
<p>The method seeks to minimize the following:
</p>
<p style="text-align: center;"><code class="reqn">||A \cdot (D - psd2edm(S))||_{F}^{2}</code>
</p>

<p>where the function psd2edm() is that described in psd2edm(), and the norm is Frobenius. Minimization is over S, a positive semidefinite matrix.
</p>
<p>The matrix D is a partial-distance matrix, meaning some of its entries are unknown. 
It must satisfy the following conditions in order to be completed:
</p>

<ul>
<li><p>diag(D) = 0
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is known, <code class="reqn">a_{ji} = a_{ij}</code>
</p>
</li>
<li><p>If <code class="reqn">a_{ij}</code> is unknown, so is <code class="reqn">a_{ji}</code>
</p>
</li>
<li><p>The graph of D must be connected. If D can be decomposed into two (or more) subgraphs, 
then the completion of D can be decomposed into two (or more) independent completion problems.
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>an nxn matrix of the completed Euclidean distances</p>
</td></tr>
<tr><td><code>optval</code></td>
<td>
<p>the minimum value achieved of the target function during minimization</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+psd2edm">psd2edm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

D &lt;- matrix(c(0,3,4,3,4,3,
             3,0,1,NA,5,NA,
             4,1,0,5,NA,5,
             3,NA,5,0,1,NA,
             4,5,NA,1,0,5,
             3,NA,5,NA,5,0), byrow=TRUE, nrow=6)
A &lt;- matrix(c(1,1,1,1,1,1,
             1,1,1,0,1,0,
             1,1,1,1,0,1,
             1,0,1,1,1,0,
             1,1,0,1,1,1,
             1,0,1,0,1,1), byrow=TRUE, nrow=6)
             
edmc(D, method="sdp", A=A, toler=1e-2)


</code></pre>

<hr>
<h2 id='snl'>Sensor Network Localization</h2><span id='topic+snl'></span>

<h3>Description</h3>

<p><code>snl</code> solves the sensor network problem with
partial distance (squared) matrix D, and anchor positions anchors, in
dimension d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snl(D, d, anchors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snl_+3A_d">D</code></td>
<td>
<p>The partial distance matrix specifying the known distances between nodes. 
If anchors is specified (and is a pxr matrix), the p final columns and p final rows specify the 
distances between the anchors specified in anchors.</p>
</td></tr>
<tr><td><code id="snl_+3A_d">d</code></td>
<td>
<p>the dimension for the resulting completion</p>
</td></tr>
<tr><td><code id="snl_+3A_anchors">anchors</code></td>
<td>
<p>a pxr matrix specifying the d dimensional locations of the p anchors. If the anchorless problem
is to be solved, anchors = NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Set anchors=NULL to solve the anchorless (Euclidean distance matrix completion) 
problem in dimension d.
</p>
<p>NOTE:  When anchors is specified, the distances between the anchors must be in the
bottom right corner of the matrix D, and anchors must have d columns.
</p>


<h3>Value</h3>

<p>X the d-dimensional positions of the localized sensors. Note that it may be the case
that not all  sensors could be localized, in which case X contains the positions of only the localized sensors.
</p>


<h3>References</h3>

<p>Nathan Krislock and Henry Wolkowicz. Explicit sensor network localization
using semidefinite representations and facial reductions. SIAM Journal on
Optimization, 20(5):2679-2708, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- matrix(c(0,NA,.1987,NA,.0595,NA,.0159,.2251,.0036,.0875,
              NA,0,.0481,NA,NA,.0515,NA,.2079,.2230,NA,
              .1987,.0481,0,NA,NA,.1158,NA,NA,.1553,NA,
              NA,NA,NA,0,NA,NA,NA,.2319,NA,NA,
              .0595,NA,NA,NA,0,NA,.1087,.0894,.0589,.0159,
              NA,.0515,.1158,NA,NA,0,NA,NA,NA,NA,
              .0159,NA,NA,NA,.1087,NA,0,.3497,.0311,.1139,
              .2251,.2079,NA,.2319,.0894,NA,.3497,0,.1918,.1607,
              .0036,.2230,.1553,NA,.0589,NA,.0311,.1918,0,.1012,
              .0875,NA,NA,NA,.0159,NA,.1139,.1607,.1012,0),nrow=10, byrow=TRUE)
              
anchors &lt;- matrix(c(.5131,.9326,
                    .3183,.3742,
                    .5392,.7524,
                    .2213,.7631), nrow=4,byrow=TRUE)
d &lt;- 2

#Anchorless Problem
edmc(D, method="snl", d=2, anchors=NULL)

#Anchored Problem
edmc(D, method="snl", d=2, anchors=anchors)

</code></pre>

<hr>
<h2 id='sprosr'>Semidefinite Programming-based Protein Structure Determination</h2><span id='topic+sprosr'></span>

<h3>Description</h3>

<p><code>sprosr</code> compute the three dimensional strucutre of a protein 
molecule using its amino acid sequences using the semidefinite programming-based
protein structure determination (SPROS) method of Ramandi (2011)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprosr(
  seq,
  aco,
  upl,
  hydrogen_omission = 1,
  f = c(10, 10, 10, 10, 10),
  in_max_res = NULL,
  in_min_res = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprosr_+3A_seq">seq</code></td>
<td>
<p>A table containing the amino acid sequence of the protein in CYANA .seq format</p>
</td></tr>
<tr><td><code id="sprosr_+3A_aco">aco</code></td>
<td>
<p>A table containing the angle constraint information in CYANA .aco format</p>
</td></tr>
<tr><td><code id="sprosr_+3A_upl">upl</code></td>
<td>
<p>A table containing the distance constraint information in CYANA .upl format</p>
</td></tr>
<tr><td><code id="sprosr_+3A_hydrogen_omission">hydrogen_omission</code></td>
<td>
<p>Should side-chain hydrogen atoms be omitted? TRUE/FALSE. Default is FALSE</p>
</td></tr>
<tr><td><code id="sprosr_+3A_f">f</code></td>
<td>
<p>Vector of length five detailing the multiplicative factors to be used. See details for more.</p>
</td></tr>
<tr><td><code id="sprosr_+3A_in_max_res">in_max_res</code></td>
<td>
<p>User overwrite of the maximum residue number.</p>
</td></tr>
<tr><td><code id="sprosr_+3A_in_min_res">in_min_res</code></td>
<td>
<p>User overwrite of the minimum residue number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input files requires by sprosr follow the typical CYANA format. Each is a table with the following columns (no headers required).
</p>
<p>Sequence File (seq) <br />
column 1: amino acid residue name  <br />
column 2: residue number <br />
</p>
<p>Torsion Angle Restraint File (aco)  <br />
column 1: residue number (corresponding to seq file)  <br />
column 2: amino acid residue name  <br />
column 3: angle identifier, one of PHI or PSI  <br />
column 4: the lower limit of the angle specified in column 3  <br />
column 5: the upper limit of the angle specified in column 3  <br />
</p>
<p>Distance Restraint File (upl) <br />
column 1: residue number of the first atom (corresponding to seq file) <br />
column 2: amino acid residue name of the first atom <br />
column 3: atom name of the first atom <br />
column 4: residue number of the second atom (corresponding to seq file) <br />
column 5: amino acid residue name of the second atom <br />
column 6: atom name of the second atom <br />
column 7: upper distance limit (in Angstroms) <br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>Matrix containing the three dimensional point configuration of the protein structure.</p>
</td></tr>
<tr><td><code>report</code></td>
<td>
<p>A list containing the final violations of the protein</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramandi, Babak A., (2011). New Approaches to Protein NMR Automation. PhD Thesis.
https://uwspace.uwaterloo.ca/bitstream/handle/10012/6389/Alipanahi_Ramandi_Babak.pdf;sequence=1
</p>

<hr>
<h2 id='sprosr_aco'>Demo Data - ACO</h2><span id='topic+sprosr_aco'></span>

<h3>Description</h3>

<p>Demo Data - ACO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sprosr_aco)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>

<hr>
<h2 id='sprosr_seq'>Demo Data - SEQ</h2><span id='topic+sprosr_seq'></span>

<h3>Description</h3>

<p>Demo Data - SEQ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sprosr_seq)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>

<hr>
<h2 id='sprosr_upl'>Demo Data - UPL</h2><span id='topic+sprosr_upl'></span>

<h3>Description</h3>

<p>Demo Data - UPL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sprosr_upl)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
