<!DOCTYPE html><html><head><title>Help for package fMRItools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fMRItools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_binary'><p>All binary?</p></a></li>
<li><a href='#all_integers'><p>All integers?</p></a></li>
<li><a href='#as.matrix_ifti'><p>Convert CIFTI, NIFTI, or GIFTI input to <code class="reqn">T \times V</code> matrix</p></a></li>
<li><a href='#bandstop_filter'><p>Bandstop filter</p></a></li>
<li><a href='#carpetplot'><p>Carpetplot</p></a></li>
<li><a href='#carpetplot_stack'><p>Stacked carpetplot</p></a></li>
<li><a href='#check_req_ifti_pkg'><p>Check required packages for the data format</p></a></li>
<li><a href='#colCenter'><p>Center matrix columns</p></a></li>
<li><a href='#CompCor'><p>Anatomical CompCor</p></a></li>
<li><a href='#CompCor_HCP'><p>Anatomical CompCor for HCP NIFTI and CIFTI data</p></a></li>
<li><a href='#CompCor.noise_comps'><p>CompCor: get noise components</p></a></li>
<li><a href='#coordlist_to_vol'><p>Convert coordinate list to 3D array</p></a></li>
<li><a href='#crop_vol'><p>Crop a 3D array</p></a></li>
<li><a href='#data_CompCor_Params'><p>fMRI data for <code>scrub</code> and <code>CompCor</code></p></a></li>
<li><a href='#dct_bases'><p>Generate cosine bases for the DCT</p></a></li>
<li><a href='#dct_convert'><p>DCT and frequency conversion</p></a></li>
<li><a href='#despike_3D'><p>3dDespike from AFNI</p></a></li>
<li><a href='#despike_3D.interpolate'><p>3dDespike from AFNI, step 2</p></a></li>
<li><a href='#despike_3D.qreg'><p>3dDespike from AFNI, step 1</p></a></li>
<li><a href='#detrend'><p>Detrending with DCT or FFT</p></a></li>
<li><a href='#dim_reduce'><p>PCA-based Dimension Reduction and Prewhitening</p></a></li>
<li><a href='#dual_reg'><p>Dual Regression</p></a></li>
<li><a href='#erode_mask_vol'><p>Erode 3D mask</p></a></li>
<li><a href='#fft_detrend'><p>FFT detrending</p></a></li>
<li><a href='#fMRItools'><p>fMRItools: Routines for Common fMRI Processing Tasks</p></a></li>
<li><a href='#format_data'><p>Format data for pscrub and CompCor</p></a></li>
<li><a href='#format_path'><p>Format a path</p></a></li>
<li><a href='#fsl_bptf'><p><code>bptf</code> function from FSL</p></a></li>
<li><a href='#get_FORMAT'><p>Get FORMAT from format</p></a></li>
<li><a href='#get_kwargs'><p>Get kwargs</p></a></li>
<li><a href='#get_NIFTI_ROI_masks'><p>Get NIFTI ROI masks</p></a></li>
<li><a href='#hat_matrix'><p>Hat matrix</p></a></li>
<li><a href='#infer_format_ifti'><p>Infer fMRI data format</p></a></li>
<li><a href='#infer_format_ifti_vec'><p>Infer fMRI data format for several inputs</p></a></li>
<li><a href='#is_1'><p>Is this object the expected data type, and length one?</p></a></li>
<li><a href='#is_constant'><p>Is this numeric vector constant?</p></a></li>
<li><a href='#is_integer'><p>Is this an integer?</p></a></li>
<li><a href='#is_posNum'><p>Is this object a positive number? (Or non-negative)</p></a></li>
<li><a href='#is.fname'><p>Is this an existing file path?</p></a></li>
<li><a href='#make_mask'><p>Create a mask based on vertices that are invalid</p></a></li>
<li><a href='#match_exactly'><p>Do these character vectors match exactly?</p></a></li>
<li><a href='#match_input'><p>Match user inputs to expected values</p></a></li>
<li><a href='#mean_squares'><p>Compute mean squares from variance decomposition</p></a></li>
<li><a href='#merge_kwargs'><p>Merges two kwargs</p></a></li>
<li><a href='#Mode'><p>Mode of data vector</p></a></li>
<li><a href='#noise_Params'><p>noise parameters for CompCor</p></a></li>
<li><a href='#norm_BOLD'><p>Normalize BOLD data</p></a></li>
<li><a href='#nuisance_regression'><p>Nuisance regression</p></a></li>
<li><a href='#pad_vol'><p>Pad 3D Array</p></a></li>
<li><a href='#PCA'><p>PCA for tall matrix</p></a></li>
<li><a href='#pct_sig'><p>Convert data values to percent signal.</p></a></li>
<li><a href='#read_nifti'><p>Wrapper to functions for reading NIFTIs</p></a></li>
<li><a href='#rowMedians2'><p>Row medians</p></a></li>
<li><a href='#scale_design_mat'><p>Scale a design matrix</p></a></li>
<li><a href='#scale_med'><p>Robust scaling</p></a></li>
<li><a href='#scale_timeseries'><p>Scale the BOLD timeseries</p></a></li>
<li><a href='#sign_flip'><p>Sign match ICA results</p></a></li>
<li><a href='#skew_pos'><p>Positive skew?</p></a></li>
<li><a href='#sum_neighbors_vol'><p>Sum of each voxel's neighbors</p></a></li>
<li><a href='#sys_path'><p>Format a path for <code>system</code></p></a></li>
<li><a href='#unmask_mat'><p>Unmask matrix data</p></a></li>
<li><a href='#unvec_mat'><p>Transform vector data to image</p></a></li>
<li><a href='#unvec_vol'><p>Convert vectorized data back to volume</p></a></li>
<li><a href='#validate_design_mat'><p>Validate design matrix</p></a></li>
<li><a href='#var_decomp'><p>Compute variance decomposition</p></a></li>
<li><a href='#vox_locations'><p>Get coordinates of each voxel in a mask</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Routines for Common fMRI Processing Tasks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amanda Mejia &lt;mandy.mejia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Supports fMRI (functional magnetic resonance imaging) 
    analysis tasks including reading in 'CIFTI', 'GIFTI' and 
    'NIFTI' data, temporal filtering, nuisance regression, and 
    aCompCor (anatomical Components Correction) (Muschelli et al.
    (2014) &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2014.03.028">doi:10.1016/j.neuroimage.2014.03.028</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ciftiTools, corpcor, expm, gifti, knitr, rmarkdown,
robustbase, pesel, RNifti, oro.nifti, templateICAr (&ge; 0.8.0),
gsignal, testthat (&ge; 3.0.0), covr, fda, quantreg, graphics,
grDevices</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mandymejia/fMRItools">https://github.com/mandymejia/fMRItools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mandymejia/fMRItools/issues">https://github.com/mandymejia/fMRItools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 14:42:08 UTC; ddpham</td>
</tr>
<tr>
<td>Author:</td>
<td>Amanda Mejia [aut, cre],
  Damon Pham <a href="https://orcid.org/0000-0001-7563-4727"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mark Fiecas [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-21 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_binary'>All binary?</h2><span id='topic+all_binary'></span>

<h3>Description</h3>

<p>Check if a data vector or matrix is all zeroes and ones. Option to also
accept logical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_binary(x, logical_ok = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_binary_+3A_x">x</code></td>
<td>
<p>The data vector or matrix</p>
</td></tr>
<tr><td><code id="all_binary_+3A_logical_ok">logical_ok</code></td>
<td>
<p>Is a logical vector or matrix also acceptable? Default:
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Is <code>x</code> binary data?
</p>

<hr>
<h2 id='all_integers'>All integers?</h2><span id='topic+all_integers'></span>

<h3>Description</h3>

<p>Check if a data vector or matrix is all integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_integers(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_integers_+3A_x">x</code></td>
<td>
<p>The data vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Is <code>x</code> all integers?
</p>

<hr>
<h2 id='as.matrix_ifti'>Convert CIFTI, NIFTI, or GIFTI input to <code class="reqn">T \times V</code> matrix</h2><span id='topic+as.matrix_ifti'></span>

<h3>Description</h3>

<p>Convert CIFTI, NIFTI, or GIFTI input to a <code class="reqn">T \times V</code> matrix by
reading it in with the corresponding package and then separating the data
from the metadata. Also works with the intermediate R objects created from
reading these files: <code>"xifti"</code> objects from <code>ciftiTools</code>,
<code>"gifti"</code> objects from <code>gifti</code>,
<code>"nifti"</code> or <code>"niftiExtension"</code> objects from <code>oro.nifti</code>, and
<code>"niftiImage"</code> objects from <code>RNifti</code>.
</p>
<p>For CIFTI files, only intents supported by <code>ciftiTools</code> are supported:
<code>dscalar</code>, <code>dtseries</code>, and <code>dlabel</code>. For NIFTI file or
NIFTI-intermediate R objects, the data will be vectorized/masked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.matrix_ifti(
  x,
  meta = FALSE,
  sortSub = FALSE,
  TbyV = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix_ifti_+3A_x">x</code></td>
<td>
<p>The object to coerce to a matrix</p>
</td></tr>
<tr><td><code id="as.matrix_ifti_+3A_meta">meta</code></td>
<td>
<p>Return metadata too? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.matrix_ifti_+3A_sortsub">sortSub</code></td>
<td>
<p>For CIFTI format input only. Sort subcortex by labels?
Default: <code>FALSE</code> (sort by array index).</p>
</td></tr>
<tr><td><code id="as.matrix_ifti_+3A_tbyv">TbyV</code></td>
<td>
<p>Return the data matrix in <code class="reqn">T \times V</code> form? Default:
<code>TRUE</code>. If <code>FALSE</code>, return in <code class="reqn">V \times T</code> form instead.
Using this argument may be faster than transposing after the function call.</p>
</td></tr>
<tr><td><code id="as.matrix_ifti_+3A_verbose">verbose</code></td>
<td>
<p>Print updates? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.matrix_ifti_+3A_...">...</code></td>
<td>
<p>If <code>x</code> is a file path, additional arguments to the function
used to read in <code>x</code> can be specified here. For example, if <code>x</code>
is a path to a CIFTI file, <code>...</code> might specify which <code>idx</code> and
<code>brainstructures</code> to read in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>!meta</code>, <code>x</code> as a matrix. If <code>meta</code>, a list of
length two: the first entry is <code>x</code> as a matrix, and the second entry is
the metadata of <code>x</code>.
</p>

<hr>
<h2 id='bandstop_filter'>Bandstop filter</h2><span id='topic+bandstop_filter'></span>

<h3>Description</h3>

<p>Filter out frequencies within a given range using a Chebyshev Type II
stopband. Essentially a convenience wrapper for the
<code><a href="gsignal.html#topic+cheby2">cheby2</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandstop_filter(X, TR, f1, f2, Rs = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandstop_filter_+3A_x">X</code></td>
<td>
<p>A numeric matrix, with each column being a timeseries to apply
the stopband filter. For fMRI data, <code>X</code> should be <code>T</code> timepoints
by <code>V</code> brain locations.</p>
</td></tr>
<tr><td><code id="bandstop_filter_+3A_tr">TR</code></td>
<td>
<p>The time step between adjacent rows of <code>x</code>, in seconds</p>
</td></tr>
<tr><td><code id="bandstop_filter_+3A_f1">f1</code>, <code id="bandstop_filter_+3A_f2">f2</code></td>
<td>
<p>The frequency limits for the filter, in Hz. <code>f1 &lt; f2</code></p>
</td></tr>
<tr><td><code id="bandstop_filter_+3A_rs">Rs</code></td>
<td>
<p>The amount of attenuation of the stopband ripple, in dB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("gsignal", quietly=TRUE)) {
 n_voxels = 1e4
 n_timepoints = 100
 X = cbind(arima.sim(n=100, list(ar=.6)), arima.sim(n=100, list(ar=.6)))
 Y = bandstop_filter(X, .72, .31, .43)
}
</code></pre>

<hr>
<h2 id='carpetplot'>Carpetplot</h2><span id='topic+carpetplot'></span>

<h3>Description</h3>

<p>Plot a matrix with <code>graphics::image</code>. For fMRI data, this is the
&quot;carpetplot&quot; or grayplot coined by (Power, 2017). The <code>graphics</code> and
<code>grDevices</code> packages are required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carpetplot(
  x,
  qcut = 0.1,
  fname = NULL,
  center = TRUE,
  scale = FALSE,
  colors = "gray255",
  sortSub = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carpetplot_+3A_x">x</code></td>
<td>
<p>The <code class="reqn">T \times V</code> numeric data matrix, or a <code>"xifti"</code> object.
In the plot, the <code class="reqn">T</code> index will increase from left to right, and the
<code class="reqn">V</code> will increase from top to bottom.</p>
</td></tr>
<tr><td><code id="carpetplot_+3A_qcut">qcut</code></td>
<td>
<p>Sets blackpoint at the <code>qcut</code> quantile, and the
whitepoint at the <code>1-qcut</code> quantile. Default: <code>.1</code>. This is
equivalent to setting the color range between the 10% and 90% quantiles.
The quantiles are computed across the entire data matrix after any
centering or scaling.
</p>
<p>Must be between 0 and .49. If <code>0</code> or <code>NULL</code> (default), do not
clamp the data values.</p>
</td></tr>
<tr><td><code id="carpetplot_+3A_fname">fname</code></td>
<td>
<p>A <code>.pdf</code> (highly recommended) or <code>.png</code> file path
to write the carpetplot to. If <code>NULL</code> (default), return the plot directly
instead of writing a file.</p>
</td></tr>
<tr><td><code id="carpetplot_+3A_center">center</code>, <code id="carpetplot_+3A_scale">scale</code></td>
<td>
<p>Center and scale the data? If <code>x</code> is fMRI data
which has not otherwise been centered or scaled, it is recommended to center
but not scale it (default).</p>
</td></tr>
<tr><td><code id="carpetplot_+3A_colors">colors</code></td>
<td>
<p><code>"gray255"</code> (default) will use a grayscale color ramp
from black to white. Otherwise, this should be a character vector of
color names to use.
</p>
<p>Colors will be assigned from the lowest to the highest data value, after
any clamping of the data values by <code>qcut</code>.</p>
</td></tr>
<tr><td><code id="carpetplot_+3A_sortsub">sortSub</code></td>
<td>
<p>If <code>x</code> is a <code>"xifti"</code> object with subcortical data,
should the voxels be sorted by structure alphabetically? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="carpetplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>pdf</code> or <code>png</code>, such as width
and height.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The image or <code>NULL, invisibly</code> if a file was written.
</p>


<h3>References</h3>


<ul>
<li><p>Power, J. D. A simple but useful way to assess fMRI scan qualities. NeuroImage 154, 150-158 (2017).
</p>
</li></ul>


<hr>
<h2 id='carpetplot_stack'>Stacked carpetplot</h2><span id='topic+carpetplot_stack'></span>

<h3>Description</h3>

<p>Stacks carpetplots on top of one another by rbinding the matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carpetplot_stack(
  x_list,
  center = TRUE,
  scale = FALSE,
  qcut = 0.1,
  match_scale = TRUE,
  nsep = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carpetplot_stack_+3A_x_list">x_list</code></td>
<td>
<p>List of data matrices</p>
</td></tr>
<tr><td><code id="carpetplot_stack_+3A_center">center</code>, <code id="carpetplot_stack_+3A_scale">scale</code></td>
<td>
<p>Center and scale the data? If <code>x</code> is fMRI data
which has not otherwise been centered or scaled, it is recommended to center
but not scale it (default).</p>
</td></tr>
<tr><td><code id="carpetplot_stack_+3A_qcut">qcut</code></td>
<td>
<p>Sets blackpoint at the <code>qcut</code> quantile, and the
whitepoint at the <code>1-qcut</code> quantile. Default: <code>.1</code>. This is
equivalent to setting the color range between the 10% and 90% quantiles.
The quantiles are computed across the entire data matrix after any
centering or scaling.
</p>
<p>Must be between 0 and .49. If <code>0</code> or <code>NULL</code> (default), do not
clamp the data values.</p>
</td></tr>
<tr><td><code id="carpetplot_stack_+3A_match_scale">match_scale</code></td>
<td>
<p>Match the scales of the carpetplots? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="carpetplot_stack_+3A_nsep">nsep</code></td>
<td>
<p>Equivalent number of data locations for size of gap between
carpetplots. Default: zero (no gap).</p>
</td></tr>
<tr><td><code id="carpetplot_stack_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>carpetplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='check_req_ifti_pkg'>Check required packages for the data format</h2><span id='topic+check_req_ifti_pkg'></span>

<h3>Description</h3>

<p>Check required packages for the data format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_req_ifti_pkg(FORMAT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_req_ifti_pkg_+3A_format">FORMAT</code></td>
<td>
<p>The data FORMAT</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='colCenter'>Center matrix columns</h2><span id='topic+colCenter'></span>

<h3>Description</h3>

<p>Efficiently center columns of a matrix. (Faster than <code>base::scale</code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colCenter(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colCenter_+3A_x">X</code></td>
<td>
<p>The data matrix. Its columns will be centered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The centered data
</p>

<hr>
<h2 id='CompCor'>Anatomical CompCor</h2><span id='topic+CompCor'></span>

<h3>Description</h3>

<p>The aCompCor algorithm for denoising fMRI data using noise ROIs data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompCor(
  X,
  ROI_data = "infer",
  ROI_noise = NULL,
  noise_nPC = 5,
  noise_erosion = NULL,
  center = TRUE,
  scale = TRUE,
  nuisance = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompCor_+3A_x">X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T observations</code> by <code class="reqn">V variables</code>, <code class="reqn">T &lt;&lt; V</code>).
For example, if <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the number
of timepoints and <code class="reqn">V</code> should be the number of brainordinate vertices/voxels.
</p>
<p>Or, a 4D array or NIFTI or file path to a NIFTI (<code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code> by <code class="reqn">T</code>
observations), in which case <code>ROI_data</code> must be provided.
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{in-mask} voxels</code>)
</p>
<p>Or, a <code>ciftiTools</code> <code>"xifti"</code> object or a file path to a CIFTI
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{left+right+sub} grayordinates</code>).</p>
</td></tr>
<tr><td><code id="CompCor_+3A_roi_data">ROI_data</code></td>
<td>
<p>Indicates the data ROI. Allowed arguments depend on <code>X</code>:
</p>
<p>If <code>X</code> is a matrix, this must be a length <code class="reqn">V</code> logical vector, where
the data ROI is indicated by <code>TRUE</code> values. If <code>"infer"</code> (default), all
columns of <code>X</code> will be included in the data ROI (<code>rep(TRUE, V)</code>).
</p>
<p>If <code>X</code> is an array or NIFTI, this must be either a vector of values
to expect for out-of-mask voxels in <code>X</code>, or a (file path to a) 3D NIFTI.
In the latter case, each of the volume dimensions should match the first
three dimensions of <code>X</code>. Voxels in the data ROI should be indicated by
<code>TRUE</code> and all other voxels by <code>FALSE</code>. If <code>"infer"</code> (default),
will be set to <code>c(0, NA, NaN)</code> (include all voxels which are not constant
<code>0</code>, <code>NA</code>, or <code>NaN</code>).
</p>
<p>If <code>X</code> is a <code>"xifti"</code> this must be the <code>brainstructures</code>
argument to <code>ciftiTools::read_cifti</code>. If <code>"infer"</code> (default),
<code>brainstructures</code> will be set to <code>"all"</code> (use both left and right
cortex vertices, and subcortical voxels).
</p>
<p>If <code>NULL</code>, the data ROI will be empty. This is useful for obtaining just
the noise ROI, if the data and noise are located in separate files.</p>
</td></tr>
<tr><td><code id="CompCor_+3A_roi_noise">ROI_noise</code></td>
<td>
<p>Indicates the noise ROIs for aCompCor. Should be a list where
each entry corresponds to a distinct noise ROI. The names of the list should
be the ROI names, e.g. <code>"white_matter"</code> and <code>"csf"</code>. The expected
formats of the list entries depends on <code>X</code>:
</p>
<p>For all types of <code>X</code>, <code>ROI_noise</code> entries can be a matrix of noise
ROI data. The matrix should have <code class="reqn">T</code> rows, with each column being a
data location's timeseries.
</p>
<p>If <code>X</code> is a matrix, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a length <code class="reqn">V</code> logical vector with <code>TRUE</code> values
indicating locations in <code>X</code> within that noise ROI. Since the ROIs must
not overlap, the masks must be mutually exclusive with each other, and with
<code>ROI_data</code>.
</p>
<p>If <code>X</code> is an array or NIFTI, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a logical array or (file path to) a 3D NIFTI with the
same spatial dimensions as <code>X</code>, and with <code>TRUE</code> values indicating
voxels inside the noise ROI. Since the ROIs must not overlap, the masks must
be mutually exclusive with each other, and with <code>ROI_data</code>.
</p>
<p>(If <code>X</code> is a <code>"xifti"</code>, entries must be data matrices, since no
grayordinate locations in <code>X</code> are appropriate noise ROIs).</p>
</td></tr>
<tr><td><code id="CompCor_+3A_noise_npc">noise_nPC</code></td>
<td>
<p>The number of principal components to compute for each noise
ROI. Alternatively, values between 0 and 1, in which case they will
represent the minimum proportion of variance explained by the PCs used for
each noise ROI. The smallest number of PCs will be used to achieve this
proportion of variance explained.
</p>
<p>Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>5</code> (compute the top 5 PCs for
each noise ROI).</p>
</td></tr>
<tr><td><code id="CompCor_+3A_noise_erosion">noise_erosion</code></td>
<td>
<p>The number of voxel layers to erode the noise ROIs by.
Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>NULL</code>, which will use a value of
0 (do not erode the noise ROIs). Note that noise erosion can only be
performed if the noise ROIs are volumetric.</p>
</td></tr>
<tr><td><code id="CompCor_+3A_center">center</code>, <code id="CompCor_+3A_scale">scale</code></td>
<td>
<p>Center the columns of the noise ROI data by their medians,
and scale by their MADs? Default: <code>TRUE</code> for both. Note that this argument
affects the noise ROI data and not the data that is being cleaned with aCompCor.
Centering and scaling of the data being cleaned can be done after this function call.</p>
</td></tr>
<tr><td><code id="CompCor_+3A_nuisance">nuisance</code></td>
<td>
<p>Nuisance signals to regress from each data column in addition
to the noise ROI PCs. Should be a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix where
<code class="reqn">N</code> represents the number of nuisance signals. To not perform any nuisance
regression set this argument to <code>NULL</code>, <code>0</code>, or <code>FALSE</code>.
Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the principal components (PCs) of each noise region of interest (ROI)
are calculated. For each ROI, voxels are centered and scaled
(can be disabled with the arguments <code>center</code> and <code>scale</code>),
and then the PCs are calculated via the singular value decomposition.
</p>
<p>Next, aCompCor is performed to remove the shared variation between the noise ROI
PCs and each location in the data. This is accomplished by a nuisance regression
using a design matrix with the noise ROI PCs, any additional regressors specified
by <code>nuisance</code>, and an intercept term. (To detrend the data and perform aCompCor
in the same regression, <code>nuisance</code> can be set to DCT bases obtained with
the function <code><a href="#topic+dct_bases">dct_bases</a></code>.)
</p>


<h3>Value</h3>

<p>A list with entries <code>"data"</code>, <code>"noise"</code>, and potentially
<code>"ROI_data"</code>.
</p>
<p>The entry <code>"data"</code> will be a <code>V x T</code> matrix where each row corresponds to a
data location (if it was originally an array, the locations will be voxels in spatial
order). Each row will be a time series with each noise PC regressed from it. This entry
will be <code>NULL</code> if there was no data.
</p>
<p>The entry <code>"noise"</code> is a list of noise PC scores, their corresponding variance,
and their ROI mask, for each noise ROI.
</p>
<p>If the data ROI is not all <code>TRUE</code>, the entry <code>"ROI_data"</code> will have
the ROI mask for the data.
</p>


<h3>References</h3>


<ul>
<li><p>Behzadi, Y., Restom, K., Liau, J. &amp; Liu, T. T. A component based noise correction method (CompCor) for BOLD and perfusion based fMRI. NeuroImage 37, 90-101 (2007).
</p>
</li>
<li><p>Muschelli, J. et al. Reduction of motion-related artifacts in resting state fMRI using aCompCor. NeuroImage 96, 22-35 (2014).
</p>
</li></ul>



<h3>See Also</h3>

<p>CompCor_HCP
</p>

<hr>
<h2 id='CompCor_HCP'>Anatomical CompCor for HCP NIFTI and CIFTI data</h2><span id='topic+CompCor_HCP'></span>

<h3>Description</h3>

<p>Wrapper to <code><a href="#topic+CompCor">CompCor</a></code> for HCP-format data. Can be used to clean
the surface-based CIFTI data with aCompCor using the noise PCs and ROIs
calculated from the NIFTI fMRI data and NIFTI mask. Can also be used to just
obtain the noise PCs and ROIs without performing aCompCor, if the CIFTI
data is not provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompCor_HCP(
  nii,
  nii_labels,
  ROI_noise = c("wm_cort", "csf"),
  noise_nPC = 5,
  noise_erosion = NULL,
  idx = NULL,
  cii = NULL,
  brainstructures = c("left", "right"),
  center = TRUE,
  scale = TRUE,
  DCT = 0,
  nuisance_too = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompCor_HCP_+3A_nii">nii</code></td>
<td>
<p><code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code> by <code class="reqn">T</code>
NIFTI object or array (or file path to the NIFTI) which contains
whole-brain data, including the noise ROIs. In the HCP, the corresponding
file is e.g. &quot;../Results/rfMRI_REST1_LR/rfMRI_REST1_LR.nii.gz&quot;</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_nii_labels">nii_labels</code></td>
<td>
<p><code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code>
NIFTI object or array (or file path to the NIFTI) which
contains the corresponding labels to each voxel in <code>nii</code>. Values should
be according to this table:
https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLUT .
In the HCP, the corresponding file is &quot;ROIs/Atlas_wmparc.2.nii.gz&quot;.</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_roi_noise">ROI_noise</code></td>
<td>
<p>A list of numeric vectors. Each entry should represent labels
in <code>nii_labels</code> belonging to a single noise ROI, named by that entry's
name. Or, this can be a character vector of at least one of the following:
<code>"wm_cort"</code> (cortical white matter), <code>"wm_cblm"</code> (cerebellar white
matter), <code>"csf"</code> (cerebrospinal fluid). In the latter case, these labels
will be used:
</p>

<dl>
<dt><code>"wm_cort"</code></dt><dd><p><code>c(3000:4035, 5001, 5002)</code></p>
</dd>
<dt><code>"wm_cblm"</code></dt><dd><p><code>c(7, 46)</code></p>
</dd>
<dt><code>"csf"</code></dt><dd><p><code>c(4, 5, 14, 15, 24, 31, 43, 44, 63, 250, 251, 252, 253, 254, 255))</code></p>
</dd>
</dl>

<p>These default ROIs are based on this forum post:
https://www.mail-archive.com/hcp-users@humanconnectome.org/msg00931.html
</p>
<p>Default: <code>c("wm_cort", "csf")</code></p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_noise_npc">noise_nPC</code></td>
<td>
<p>The number of principal components to compute for each noise
ROI. Alternatively, values between 0 and 1, in which case they will
represent the minimum proportion of variance explained by the PCs used for
each noise ROI. The smallest number of PCs will be used to achieve this
proportion of variance explained.
</p>
<p>Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>5</code> (compute the top 5 PCs for
each noise ROI).</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_noise_erosion">noise_erosion</code></td>
<td>
<p>The number of voxel layers to erode the noise ROIs by.
Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>NULL</code>, which will use a value of
0 (do not erode the noise ROIs).</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_idx">idx</code></td>
<td>
<p>A numeric vector indicating the timepoints to use, or
<code>NULL</code> (default) to use all idx. (Indexing begins with 1, so the
first timepoint has index 1 and the last has the same index as the length of
the scan.)</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_cii">cii</code></td>
<td>
<p><code>"xifti"</code> (or file path to the CIFTI) from which the noise
ROI components will be regressed. In the HCP, the corresponding file is e.g.
&quot;../Results/rfMRI_REST1_LR/rfMRI_REST1_LR_Atlas_MSMAll.dtseries.nii&quot;. If not
provided, only the noise components will be returned (no data will be cleaned).</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Choose among &quot;left&quot;, &quot;right&quot;, and &quot;subcortical&quot;.
Default: <code>c("left", "right")</code> (cortical data only)</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_center">center</code>, <code id="CompCor_HCP_+3A_scale">scale</code></td>
<td>
<p>Center the columns of the data by median, and scale the
columns of the data by MAD? Default: <code>TRUE</code> for both. Affects both
<code>X</code> and the noise data. <code>center</code> also applies to <code>nuisance_too</code>
so if it is <code>FALSE</code>, <code>nuisance_too</code> must already be centered.</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_dct">DCT</code></td>
<td>
<p>Add DCT bases to the nuisance regression? Use an integer to
indicate the number of cosine bases. Use <code>0</code> (default) to forgo detrending.
</p>
<p>The data must be centered, either before input or with <code>center</code>.</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_nuisance_too">nuisance_too</code></td>
<td>
<p>A matrix of nuisance signals to add to the nuisance
regression. Should have <code class="reqn">T</code> rows. <code>NULL</code> to not add additional
nuisance regressors (default).</p>
</td></tr>
<tr><td><code id="CompCor_HCP_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The noise components, and if <code>cii</code> is provided, the cleaned
surface-based data as a <code>"xifti"</code> object.
</p>


<h3>References</h3>


<ul>
<li><p>Behzadi, Y., Restom, K., Liau, J. &amp; Liu, T. T. A component based noise correction method (CompCor) for BOLD and perfusion based fMRI. NeuroImage 37, 90-101 (2007).
</p>
</li>
<li><p>Muschelli, J. et al. Reduction of motion-related artifacts in resting state fMRI using aCompCor. NeuroImage 96, 22-35 (2014).
</p>
</li></ul>



<h3>See Also</h3>

<p>CompCor
</p>

<hr>
<h2 id='CompCor.noise_comps'>CompCor: get noise components</h2><span id='topic+CompCor.noise_comps'></span>

<h3>Description</h3>

<p>Get noise components for aCompCor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompCor.noise_comps(X_noise, center, scale, noise_nPC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompCor.noise_comps_+3A_x_noise">X_noise</code></td>
<td>
<p>The noise ROIs data</p>
</td></tr>
<tr><td><code id="CompCor.noise_comps_+3A_center">center</code>, <code id="CompCor.noise_comps_+3A_scale">scale</code></td>
<td>
<p>Center &amp; scale robustly</p>
</td></tr>
<tr><td><code id="CompCor.noise_comps_+3A_noise_npc">noise_nPC</code></td>
<td>
<p>Number of PCs to obtain for each noise ROI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components X, X_noise, ROI_data, ROI_noise, noise_nPC,
noise_erosion, noise_comps, and noise_var.
</p>

<hr>
<h2 id='coordlist_to_vol'>Convert coordinate list to 3D array</h2><span id='topic+coordlist_to_vol'></span>

<h3>Description</h3>

<p>Converts a sparse coordinate list to its non-sparse volumetric representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordlist_to_vol(coords, fill = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordlist_to_vol_+3A_coords">coords</code></td>
<td>
<p>The sparse coordinate list. Should be a <code>"data.frame"</code> or
matrix with voxels along the rows and three or four columns. The first three
columns should be integers indicating the spatial coordinates of the voxel.
If the fourth column is present, it will be the value used for that voxel.
If it is absent, the value will be <code>TRUE</code> or <code>1</code> if <code>fill</code>
is not one of those values, and <code>FALSE</code> or <code>0</code> if <code>fill</code> is.
The data type will be the same as that of <code>fill</code>. The fourth column
must be logical or numeric.</p>
</td></tr>
<tr><td><code id="coordlist_to_vol_+3A_fill">fill</code></td>
<td>
<p>Logical or numeric fill value for the volume. Default:
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The volumetric data
</p>

<hr>
<h2 id='crop_vol'>Crop a 3D array</h2><span id='topic+crop_vol'></span>

<h3>Description</h3>

<p>Remove empty (zero-valued) edge slices from a 3D array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_vol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_vol_+3A_x">x</code></td>
<td>
<p>The numeric 3D array to crop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length two: <code>"data"</code>, the cropped array, and
<code>"padding"</code>, the number of slices removed from each edge of each
dimension.
</p>

<hr>
<h2 id='data_CompCor_Params'>fMRI data for <code>scrub</code> and <code>CompCor</code></h2><span id='topic+data_CompCor_Params'></span>

<h3>Description</h3>

<p>fMRI data for <code>scrub</code> and <code>CompCor</code>
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_CompCor_Params_+3A_x">X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T observations</code> by <code class="reqn">V variables</code>, <code class="reqn">T &lt;&lt; V</code>).
For example, if <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the number
of timepoints and <code class="reqn">V</code> should be the number of brainordinate vertices/voxels.
</p>
<p>Or, a 4D array or NIFTI or file path to a NIFTI (<code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code> by <code class="reqn">T</code>
observations), in which case <code>ROI_data</code> must be provided.
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{in-mask} voxels</code>)
</p>
<p>Or, a <code>ciftiTools</code> <code>"xifti"</code> object or a file path to a CIFTI
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{left+right+sub} grayordinates</code>).</p>
</td></tr>
<tr><td><code id="data_CompCor_Params_+3A_roi_data">ROI_data</code></td>
<td>
<p>Indicates the data ROI. Allowed arguments depend on <code>X</code>:
</p>
<p>If <code>X</code> is a matrix, this must be a length <code class="reqn">V</code> logical vector, where
the data ROI is indicated by <code>TRUE</code> values. If <code>"infer"</code> (default), all
columns of <code>X</code> will be included in the data ROI (<code>rep(TRUE, V)</code>).
</p>
<p>If <code>X</code> is an array or NIFTI, this must be either a vector of values
to expect for out-of-mask voxels in <code>X</code>, or a (file path to a) 3D NIFTI.
In the latter case, each of the volume dimensions should match the first
three dimensions of <code>X</code>. Voxels in the data ROI should be indicated by
<code>TRUE</code> and all other voxels by <code>FALSE</code>. If <code>"infer"</code> (default),
will be set to <code>c(0, NA, NaN)</code> (include all voxels which are not constant
<code>0</code>, <code>NA</code>, or <code>NaN</code>).
</p>
<p>If <code>X</code> is a <code>"xifti"</code> this must be the <code>brainstructures</code>
argument to <code>ciftiTools::read_cifti</code>. If <code>"infer"</code> (default),
<code>brainstructures</code> will be set to <code>"all"</code> (use both left and right
cortex vertices, and subcortical voxels).
</p>
<p>If <code>NULL</code>, the data ROI will be empty. This is useful for obtaining just
the noise ROI, if the data and noise are located in separate files.</p>
</td></tr>
<tr><td><code id="data_CompCor_Params_+3A_roi_noise">ROI_noise</code></td>
<td>
<p>Indicates the noise ROIs for aCompCor. Should be a list where
each entry corresponds to a distinct noise ROI. The names of the list should
be the ROI names, e.g. <code>"white_matter"</code> and <code>"csf"</code>. The expected
formats of the list entries depends on <code>X</code>:
</p>
<p>For all types of <code>X</code>, <code>ROI_noise</code> entries can be a matrix of noise
ROI data. The matrix should have <code class="reqn">T</code> rows, with each column being a
data location's timeseries.
</p>
<p>If <code>X</code> is a matrix, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a length <code class="reqn">V</code> logical vector with <code>TRUE</code> values
indicating locations in <code>X</code> within that noise ROI. Since the ROIs must
not overlap, the masks must be mutually exclusive with each other, and with
<code>ROI_data</code>.
</p>
<p>If <code>X</code> is an array or NIFTI, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a logical array or (file path to) a 3D NIFTI with the
same spatial dimensions as <code>X</code>, and with <code>TRUE</code> values indicating
voxels inside the noise ROI. Since the ROIs must not overlap, the masks must
be mutually exclusive with each other, and with <code>ROI_data</code>.
</p>
<p>(If <code>X</code> is a <code>"xifti"</code>, entries must be data matrices, since no
grayordinate locations in <code>X</code> are appropriate noise ROIs).</p>
</td></tr>
</table>

<hr>
<h2 id='dct_bases'>Generate cosine bases for the DCT</h2><span id='topic+dct_bases'></span>

<h3>Description</h3>

<p>Generate cosine bases for the DCT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct_bases(T_, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dct_bases_+3A_t_">T_</code></td>
<td>
<p>Length of timeseries</p>
</td></tr>
<tr><td><code id="dct_bases_+3A_n">n</code></td>
<td>
<p>Number of cosine bases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with cosine bases along columns
</p>

<hr>
<h2 id='dct_convert'>DCT and frequency conversion</h2><span id='topic+dct_convert'></span><span id='topic+dct2Hz'></span><span id='topic+Hz2dct'></span>

<h3>Description</h3>

<p>Convert between number of DCT bases and Hz of highpass filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct_convert(T_, TR, n = NULL, f = NULL)

dct2Hz(T_, TR, n)

Hz2dct(T_, TR, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dct_convert_+3A_t_">T_</code></td>
<td>
<p>Length of timeseries (number of timepoints)</p>
</td></tr>
<tr><td><code id="dct_convert_+3A_tr">TR</code></td>
<td>
<p>TR of the fMRI scan, in seconds (the time between timepoints)</p>
</td></tr>
<tr><td><code id="dct_convert_+3A_n">n</code></td>
<td>
<p>Number of cosine bases</p>
</td></tr>
<tr><td><code id="dct_convert_+3A_f">f</code></td>
<td>
<p>Hz of highpass filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide either <code>n</code> or <code>f</code> to calculate the other.
</p>
<p>If only the total length of the scan is known, you can set that to <code>TR</code>
and use <code>T_=1</code>.
</p>
<p><code class="reqn">f = n / (2 * T_ * TR)</code>
</p>


<h3>Value</h3>

<p>If <code>n</code> was provided, the highpass filter cutoff (Hz) is returned.
Otherwise, if <code>f</code> was provided, the number of cosine bases is returned.
The result should be rounded before passing to <code><a href="#topic+dct_bases">dct_bases</a></code>
</p>

<hr>
<h2 id='despike_3D'>3dDespike from AFNI</h2><span id='topic+despike_3D'></span>

<h3>Description</h3>

<p>Identify and interpolate outliers. See
<a href="https://afni.nimh.nih.gov/pub/dist/doc/program_help/3dDespike.html">the
AFNI documentation for 3dDespike</a> for additional information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>despike_3D(Yt, c1 = 2.5, c2 = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="despike_3D_+3A_yt">Yt</code></td>
<td>
<p>The data vector.</p>
</td></tr>
<tr><td><code id="despike_3D_+3A_c1">c1</code></td>
<td>
<p>spike threshold. Default: <code>2.5</code>.</p>
</td></tr>
<tr><td><code id="despike_3D_+3A_c2">c2</code></td>
<td>
<p>upper range of the acceptable deviation from the fit. Default:
<code>4</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("fda", quietly=TRUE) &amp;&amp; requireNamespace("quantreg", quietly=TRUE)) {
 y &lt;- rnorm(99) + cos(seq(99)/15)*3
 y[20] &lt;- 20
 despike_3D(y)
}

</code></pre>

<hr>
<h2 id='despike_3D.interpolate'>3dDespike from AFNI, step 2</h2><span id='topic+despike_3D.interpolate'></span>

<h3>Description</h3>

<p>Identify and interpolate the outliers for <code><a href="#topic+despike_3D">despike_3D</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>despike_3D.interpolate(qreg, c1 = 2.5, c2 = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="despike_3D.interpolate_+3A_qreg">qreg</code></td>
<td>
<p>the quantile regression from <code><a href="#topic+despike_3D.qreg">despike_3D.qreg</a></code></p>
</td></tr>
<tr><td><code id="despike_3D.interpolate_+3A_c1">c1</code></td>
<td>
<p>spike threshold. Default: <code>2.5</code>.</p>
</td></tr>
<tr><td><code id="despike_3D.interpolate_+3A_c2">c2</code></td>
<td>
<p>upper range of the acceptable deviation from the fit. Default:
<code>4</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='despike_3D.qreg'>3dDespike from AFNI, step 1</h2><span id='topic+despike_3D.qreg'></span>

<h3>Description</h3>

<p>Compute the quantile regression that <code><a href="#topic+despike_3D">despike_3D</a></code> is based on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>despike_3D.qreg(Yt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="despike_3D.qreg_+3A_yt">Yt</code></td>
<td>
<p>The data vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the quantile regression
</p>

<hr>
<h2 id='detrend'>Detrending with DCT or FFT</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p>Detrending with DCT or FFT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(X, TR, f = 0.008, method = c("DCT", "FFT"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_x">X</code></td>
<td>
<p>A numeric matrix, with each column being a timeseries to detrend.
For fMRI data, <code>X</code> should be <code>T</code> timepoints by <code>V</code> brain
locations.</p>
</td></tr>
<tr><td><code id="detrend_+3A_tr">TR</code></td>
<td>
<p>The time step between adjacent rows of <code>X</code>, in seconds</p>
</td></tr>
<tr><td><code id="detrend_+3A_f">f</code></td>
<td>
<p>The frequency of the highpass filter, in Hertz. Default: <code>.008</code></p>
</td></tr>
<tr><td><code id="detrend_+3A_method">method</code></td>
<td>
<p><code>"DCT"</code> (default) or <code>"FFT"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Detrended <code>X</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>detrend(matrix(rnorm(700), nrow=100), TR=.72)
</code></pre>

<hr>
<h2 id='dim_reduce'>PCA-based Dimension Reduction and Prewhitening</h2><span id='topic+dim_reduce'></span>

<h3>Description</h3>

<p>Performs dimension reduction and prewhitening based on probabilistic PCA using
SVD. If dimensionality is not specified, it is estimated using the method
described in Minka (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_reduce(X, Q = NULL, Q_max = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_reduce_+3A_x">X</code></td>
<td>
<p>A numeric matrix, with each column being a centered timeseries.
For fMRI data, <code>X</code> should be <code>T</code> timepoints by <code>V</code> brain
locations.</p>
</td></tr>
<tr><td><code id="dim_reduce_+3A_q">Q</code></td>
<td>
<p>Number of latent dimensions to estimate. If <code>NULL</code> (default),
estimated using PESEL (Sobczyka et al. 2020).</p>
</td></tr>
<tr><td><code id="dim_reduce_+3A_q_max">Q_max</code></td>
<td>
<p>Maximal number of principal components for automatic
dimensionality selection with PESEL. Default: <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the dimension-reduced data (<code>data_reduced</code>, a
<code class="reqn">V \times Q</code> matrix), prewhitening/dimension reduction matrix (<code>H</code>,
a <code class="reqn">QxT</code> matrix) and its (pseudo-)inverse (<code>Hinv</code>, a <code class="reqn">TxQ</code>
matrix), the noise variance (<code>sigma_sq</code>), the correlation matrix of the
dimension-reduced data (<code>C_diag</code>, a <code class="reqn">QxQ</code> matrix), and the
dimensionality (<code>Q</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nT &lt;- 30
nV &lt;- 400
nQ &lt;- 7
X &lt;- matrix(rnorm(nV*nQ), nrow=nV) %*% diag(seq(nQ, 1)) %*% matrix(rnorm(nQ*nT), nrow=nQ) 
dim_reduce(X, Q=nQ)

</code></pre>

<hr>
<h2 id='dual_reg'>Dual Regression</h2><span id='topic+dual_reg'></span>

<h3>Description</h3>

<p>Dual Regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_reg(
  BOLD,
  GICA,
  scale = c("local", "global", "none"),
  scale_sm_xifti = NULL,
  scale_sm_FWHM = 2,
  TR = NULL,
  hpf = 0.01,
  GSR = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_reg_+3A_bold">BOLD</code></td>
<td>
<p>Subject-level fMRI data matrix (<code class="reqn">V \times T</code>). Rows will be
centered.</p>
</td></tr>
<tr><td><code id="dual_reg_+3A_gica">GICA</code></td>
<td>
<p>Group-level independent components (<code class="reqn">V \times Q</code>)</p>
</td></tr>
<tr><td><code id="dual_reg_+3A_scale">scale</code></td>
<td>
<p><code>"local"</code> (default), <code>"global"</code>, or <code>"none"</code>.
Local scaling will divide each data location's time series by its estimated
standard deviation. Global scaling will divide the entire data matrix by the
mean image standard deviation (<code>mean(sqrt(rowVars(BOLD)))</code>).</p>
</td></tr>
<tr><td><code id="dual_reg_+3A_scale_sm_xifti">scale_sm_xifti</code>, <code id="dual_reg_+3A_scale_sm_fwhm">scale_sm_FWHM</code></td>
<td>
<p>Only applies if <code>scale=="local"</code> and
<code>BOLD</code> represents CIFTI-format data. To smooth the standard deviation
estimates used for local scaling, provide a <code>"xifti"</code> object with data
locations in alignment with <code>BOLD</code>, as well as the smoothing FWHM
(default: <code>2</code>). If no <code>"xifti"</code> object is provided (default), do
not smooth.</p>
</td></tr>
<tr><td><code id="dual_reg_+3A_tr">TR</code></td>
<td>
<p>The temporal resolution of the data, i.e. the time between volumes,
in seconds. <code>TR</code> is required for detrending with <code>hpf</code>.</p>
</td></tr>
<tr><td><code id="dual_reg_+3A_hpf">hpf</code></td>
<td>
<p>The frequency at which to apply a highpass filter to the data
during pre-processing, in Hertz. Default: <code>0.01</code> Hertz. Set to <code>0</code>
to disable the highpass filter.
</p>
<p>The highpass filter serves to detrend the data, since low-frequency
variance is associated with noise. Highpass filtering is accomplished by
nuisance regression of discrete cosine transform (DCT) bases.
</p>
<p>Note the <code>TR</code> argument is required for highpass filtering. If
<code>TR</code> is not provided, <code>hpf</code> will be ignored.</p>
</td></tr>
<tr><td><code id="dual_reg_+3A_gsr">GSR</code></td>
<td>
<p>Center BOLD across columns (each image)? This
is equivalent to performing global signal regression. Default:
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
the subject-level independent components <strong>S</strong> (<code class="reqn">V \times Q</code>),
and subject-level mixing matrix <strong>A</strong> (<code class="reqn">TxQ</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nT &lt;- 30
nV &lt;- 400
nQ &lt;- 7
mU &lt;- matrix(rnorm(nV*nQ), nrow=nV)
mS &lt;- mU %*% diag(seq(nQ, 1)) %*% matrix(rnorm(nQ*nT), nrow=nQ)
BOLD &lt;- mS + rnorm(nV*nT, sd=.05)
GICA &lt;- mU
dual_reg(BOLD=BOLD, GICA=mU, scale="local")

</code></pre>

<hr>
<h2 id='erode_mask_vol'>Erode 3D mask</h2><span id='topic+erode_mask_vol'></span>

<h3>Description</h3>

<p>Erode a volumetric mask by a certain number of voxel layers. For each layer,
any in-mask voxel adjacent to at least one out-of-mask voxel is removed
from the mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erode_mask_vol(vol, n_erosion = 1, out_of_mask_val = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erode_mask_vol_+3A_vol">vol</code></td>
<td>
<p>The 3D array to erode. The mask to erode is defined by all values
not in <code>out_of_mask_val</code>.</p>
</td></tr>
<tr><td><code id="erode_mask_vol_+3A_n_erosion">n_erosion</code></td>
<td>
<p>The number of layers to erode the mask by. Default:
<code>1</code>.</p>
</td></tr>
<tr><td><code id="erode_mask_vol_+3A_out_of_mask_val">out_of_mask_val</code></td>
<td>
<p>A voxel is not included in the mask if and only if its
value is in this vector. The first value of this vector will be used to
replace eroded voxels. Default: <code>NA</code>. If <code>vol</code> is simply a logical
array with <code>TRUE</code> values for in-mask voxels, use
<code>out_of_mask_val=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diagonal voxels are not considered adjacent, i.e. the voxel at (0,0,0) is not
adjacent to the voxels at (1,1,0) or (1,1,1), although it is adjacent to
(1,0,0).
</p>


<h3>Value</h3>

<p>The eroded <code>vol</code>. It is the same as <code>vol</code>, but eroded
voxels are replaced with <code>out_of_mask_val[1]</code>.
</p>

<hr>
<h2 id='fft_detrend'>FFT detrending</h2><span id='topic+fft_detrend'></span>

<h3>Description</h3>

<p>FFT detrending
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fft_detrend(X, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fft_detrend_+3A_x">X</code></td>
<td>
<p><code class="reqn">T \times V</code> numeric matrix. Each column is a voxel or vertex
time series.</p>
</td></tr>
<tr><td><code id="fft_detrend_+3A_n">N</code></td>
<td>
<p>Number of FFT entries to remove from each end of the vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Detrended <code>X</code>
</p>

<hr>
<h2 id='fMRItools'>fMRItools: Routines for Common fMRI Processing Tasks</h2><span id='topic+fMRItools'></span><span id='topic+fMRItools-package'></span>

<h3>Description</h3>

<p>See <code>help(package="fMRItools")</code> for a list of functions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Amanda Mejia <a href="mailto:mandy.mejia@gmail.com">mandy.mejia@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Damon Pham <a href="mailto:damondpham@gmail.com">damondpham@gmail.com</a> (<a href="https://orcid.org/0000-0001-7563-4727">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Mark Fiecas <a href="mailto:mfiecas@umn.edu">mfiecas@umn.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mandymejia/fMRItools">https://github.com/mandymejia/fMRItools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mandymejia/fMRItools/issues">https://github.com/mandymejia/fMRItools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='format_data'>Format data for pscrub and CompCor</h2><span id='topic+format_data'></span>

<h3>Description</h3>

<p>Format data for pscrub and CompCor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_data(
  X,
  ROI_data = "infer",
  ROI_noise = NULL,
  noise_nPC = 5,
  noise_erosion = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_data_+3A_x">X</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="format_data_+3A_roi_data">ROI_data</code>, <code id="format_data_+3A_roi_noise">ROI_noise</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="format_data_+3A_noise_npc">noise_nPC</code></td>
<td>
<p>The number of principal components to compute for each noise
ROI. Alternatively, values between 0 and 1, in which case they will
represent the minimum proportion of variance explained by the PCs used for
each noise ROI. The smallest number of PCs will be used to achieve this
proportion of variance explained.
</p>
<p>Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>5</code> (compute the top 5 PCs for
each noise ROI).</p>
</td></tr>
<tr><td><code id="format_data_+3A_noise_erosion">noise_erosion</code></td>
<td>
<p>The number of voxel layers to erode the noise ROIs by.
Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>NULL</code>, which will use a value of
0 (do not erode the noise ROIs).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components &quot;X&quot;, &quot;X_noise&quot;, &quot;ROI_data&quot;, and &quot;ROI_noise&quot;
</p>

<hr>
<h2 id='format_path'>Format a path</h2><span id='topic+format_path'></span>

<h3>Description</h3>

<p>Normalize and validate a path (optionally, within a certain directory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_path(path, dir = NULL, mode = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_path_+3A_path">path</code></td>
<td>
<p>The path to normalize.</p>
</td></tr>
<tr><td><code id="format_path_+3A_dir">dir</code></td>
<td>
<p>(Optional) the directory to append to the beginning of the path.
<code>NULL</code> (default) to not append any directory, leaving <code>path</code>
unchanged.</p>
</td></tr>
<tr><td><code id="format_path_+3A_mode">mode</code></td>
<td>
<p>The mode for <code><a href="base.html#topic+file.access">file.access</a></code> to verify existence,
writing permission, or reading permission. Use NA (default) to not perform
any is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized path, or <code>NULL</code> if the path was <code>NULL</code>.
</p>

<hr>
<h2 id='fsl_bptf'><code>bptf</code> function from FSL</h2><span id='topic+fsl_bptf'></span>

<h3>Description</h3>

<p>Copy of <code>bptf</code> highpass filter from FSL. The results are very similar
but not identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsl_bptf(orig_data, HP_sigma = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsl_bptf_+3A_orig_data">orig_data</code></td>
<td>
<p><code class="reqn">T \times V</code> data matrix whose columns will be detrended</p>
</td></tr>
<tr><td><code id="fsl_bptf_+3A_hp_sigma">HP_sigma</code></td>
<td>
<p>The frequency parameter for the highpass filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sources:
https://cpb-us-w2.wpmucdn.com/sites.udel.edu/dist/7/4542/files/2016/09/fsl_temporal_filt-15sywxn.m
https://github.com/rordenlab/niimath/blob/master/src/core32.c
</p>


<h3>Value</h3>

<p>The data with detrended columns
</p>


<h3>References</h3>


<ul>
<li><p>Jenkinson, M., Beckmann, C. F., Behrens, T. E. J., Woolrich, M. W. &amp; Smith, S. M. FSL. NeuroImage 62, 782-790 (2012).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fsl_bptf(matrix(rnorm(700), nrow=100))
</code></pre>

<hr>
<h2 id='get_FORMAT'>Get FORMAT from format</h2><span id='topic+get_FORMAT'></span>

<h3>Description</h3>

<p>Get FORMAT from format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_FORMAT(format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_FORMAT_+3A_format">format</code></td>
<td>
<p>the file format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file FORMAT
</p>

<hr>
<h2 id='get_kwargs'>Get kwargs</h2><span id='topic+get_kwargs'></span>

<h3>Description</h3>

<p>Get the names of the arguments of a function as a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_kwargs(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_kwargs_+3A_fun">fun</code></td>
<td>
<p>The function to get the argument names for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names of the arguments of <code>fun</code> as a character vector
</p>

<hr>
<h2 id='get_NIFTI_ROI_masks'>Get NIFTI ROI masks</h2><span id='topic+get_NIFTI_ROI_masks'></span>

<h3>Description</h3>

<p>Get NIFTI ROI masks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_NIFTI_ROI_masks(nii_labels, ROI_noise = c("wm_cort", "csf"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_NIFTI_ROI_masks_+3A_nii_labels">nii_labels</code></td>
<td>
<p><code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code>
NIFTI object or array (or file path to the NIFTI) which
contains the corresponding labels to each voxel in <code>nii</code>. Values should
be according to this table:
https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLUT .
In the HCP, the corresponding file is &quot;ROIs/Atlas_wmparc.2.nii.gz&quot;.</p>
</td></tr>
<tr><td><code id="get_NIFTI_ROI_masks_+3A_roi_noise">ROI_noise</code></td>
<td>
<p>A list of numeric vectors. Each entry should represent labels
in <code>nii_labels</code> belonging to a single noise ROI, named by that entry's
name. Or, this can be a character vector of at least one of the following:
<code>"wm_cort"</code> (cortical white matter), <code>"wm_cblm"</code> (cerebellar white
matter), <code>"csf"</code> (cerebrospinal fluid). In the latter case, these labels
will be used:
</p>

<dl>
<dt><code>"wm_cort"</code></dt><dd><p><code>c(3000:4035, 5001, 5002)</code></p>
</dd>
<dt><code>"wm_cblm"</code></dt><dd><p><code>c(7, 46)</code></p>
</dd>
<dt><code>"csf"</code></dt><dd><p><code>c(4, 5, 14, 15, 24, 31, 43, 44, 63, 250, 251, 252, 253, 254, 255))</code></p>
</dd>
</dl>

<p>These default ROIs are based on this forum post:
https://www.mail-archive.com/hcp-users@humanconnectome.org/msg00931.html
</p>
<p>Default: <code>c("wm_cort", "csf")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ROIs
</p>

<hr>
<h2 id='hat_matrix'>Hat matrix</h2><span id='topic+hat_matrix'></span>

<h3>Description</h3>

<p>Get the hat matrix from a design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hat_matrix(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hat_matrix_+3A_design">design</code></td>
<td>
<p>The <code class="reqn">T</code> by <code class="reqn">Q</code> design matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the QR decomposition.
</p>


<h3>Value</h3>

<p>The <code class="reqn">T</code> by <code class="reqn">T</code> hat matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hat_matrix(cbind(seq(100), 1))
</code></pre>

<hr>
<h2 id='infer_format_ifti'>Infer fMRI data format</h2><span id='topic+infer_format_ifti'></span>

<h3>Description</h3>

<p>Infer fMRI data format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_format_ifti(BOLD, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_format_ifti_+3A_bold">BOLD</code></td>
<td>
<p>The fMRI data</p>
</td></tr>
<tr><td><code id="infer_format_ifti_+3A_verbose">verbose</code></td>
<td>
<p>Print the format? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-two vector. The first element indicates the format:
<code>"CIFTI"</code> file path, <code>"xifti"</code> object,
<code>"GIFTI"</code> file path, <code>"gifti"</code> object,
<code>"NIFTI"</code> file path, <code>"nifti"</code> object,
<code>"RDS"</code> file path, or <code>"data"</code>.
The second element indicates
the sub-format if relevant; i.e. the type of CIFTI or GIFTI file/object.
</p>

<hr>
<h2 id='infer_format_ifti_vec'>Infer fMRI data format for several inputs</h2><span id='topic+infer_format_ifti_vec'></span>

<h3>Description</h3>

<p>Vectorized version of <code><a href="#topic+infer_format_ifti">infer_format_ifti</a></code>. Expects all inputs
to have the same format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_format_ifti_vec(BOLD, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_format_ifti_vec_+3A_bold">BOLD</code></td>
<td>
<p>The vector of fMRI data, expected to be of one format</p>
</td></tr>
<tr><td><code id="infer_format_ifti_vec_+3A_verbose">verbose</code></td>
<td>
<p>Print the format? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Raises an error if the elements of <code>BOLD</code> do not share the same format.
</p>


<h3>Value</h3>

<p>A length-two vector. The first element indicates the format:
<code>"CIFTI"</code> file path, <code>"xifti"</code> object,
<code>"GIFTI"</code> file path, <code>"gifti"</code> object,
<code>"NIFTI"</code> file path, <code>"nifti"</code> object,
<code>"RDS"</code> file path, or <code>"data"</code>. The second element indicates
the sub-format if relevant; i.e. the type of CIFTI or GIFTI file/object.
</p>

<hr>
<h2 id='is_1'>Is this object the expected data type, and length one?</h2><span id='topic+is_1'></span>

<h3>Description</h3>

<p>Is this object the expected data type, and length one?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_1(x, dtype = c("numeric", "logical", "character"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_1_+3A_x">x</code></td>
<td>
<p>The value to check</p>
</td></tr>
<tr><td><code id="is_1_+3A_dtype">dtype</code></td>
<td>
<p>The data type. Default: <code>"numeric"</code>. Also can be
<code>"logical"</code> or <code>"character"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is <code>dtype</code> and length one.
</p>

<hr>
<h2 id='is_constant'>Is this numeric vector constant?</h2><span id='topic+is_constant'></span>

<h3>Description</h3>

<p>Is this numeric vector constant?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_constant(x, TOL = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_constant_+3A_x">x</code></td>
<td>
<p>The numeric vector</p>
</td></tr>
<tr><td><code id="is_constant_+3A_tol">TOL</code></td>
<td>
<p>minimum range of <code>x</code> to be considered non-constant.
Default: <code>1e-8</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Is <code>x</code> constant?
</p>

<hr>
<h2 id='is_integer'>Is this an integer?</h2><span id='topic+is_integer'></span>

<h3>Description</h3>

<p>Is this an integer?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_integer(x, nneg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_integer_+3A_x">x</code></td>
<td>
<p>The putative integer</p>
</td></tr>
<tr><td><code id="is_integer_+3A_nneg">nneg</code></td>
<td>
<p>Require <code>x&gt;=0</code> (non-negative) too?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating whether <code>x</code> is an integer
</p>

<hr>
<h2 id='is_posNum'>Is this object a positive number? (Or non-negative)</h2><span id='topic+is_posNum'></span>

<h3>Description</h3>

<p>Is this object a positive number? (Or non-negative)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_posNum(x, zero_ok = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_posNum_+3A_x">x</code></td>
<td>
<p>The value to check</p>
</td></tr>
<tr><td><code id="is_posNum_+3A_zero_ok">zero_ok</code></td>
<td>
<p>Is a value of zero ok?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating if <code>x</code> is a single positive or non-negative
number
</p>

<hr>
<h2 id='is.fname'>Is this an existing file path?</h2><span id='topic+is.fname'></span>

<h3>Description</h3>

<p>Simple check if something is an existing file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fname(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fname_+3A_x">x</code></td>
<td>
<p>The potential file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Is <code>x</code> an existing file?
</p>

<hr>
<h2 id='make_mask'>Create a mask based on vertices that are invalid</h2><span id='topic+make_mask'></span>

<h3>Description</h3>

<p>Create a mask based on vertices that are invalid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mask(BOLD, meanTol = -Inf, varTol = 1e-06, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mask_+3A_bold">BOLD</code></td>
<td>
<p>A <code class="reqn">V \times T</code> numeric matrix. Each row is a location.</p>
</td></tr>
<tr><td><code id="make_mask_+3A_meantol">meanTol</code>, <code id="make_mask_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Defaults: <code>-Inf</code> for <code>meanTol</code> (ignore), and <code>1e-6</code> for
<code>varTol</code>.</p>
</td></tr>
<tr><td><code id="make_mask_+3A_verbose">verbose</code></td>
<td>
<p>Print messages counting how many locations are removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating valid vertices
</p>

<hr>
<h2 id='match_exactly'>Do these character vectors match exactly?</h2><span id='topic+match_exactly'></span>

<h3>Description</h3>

<p>Checks if a user-defined character vector matches an expected character
vector. That is, they share the same lengths and entries in the same order.
For vectors of the same lengths, the result is <code>all(a == b)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_exactly(
  user,
  expected,
  fail_action = c("message", "warning", "stop", "nothing")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_exactly_+3A_user">user</code></td>
<td>
<p>Character vector of user input.</p>
</td></tr>
<tr><td><code id="match_exactly_+3A_expected">expected</code></td>
<td>
<p>Character vector of expected/allowed values.</p>
</td></tr>
<tr><td><code id="match_exactly_+3A_fail_action">fail_action</code></td>
<td>
<p>If any value in <code>user</code> could not be
matched, or repeated matches occurred, what should happen? Possible values
are <code>"message"</code> (default), <code>"warning"</code>, <code>"stop"</code>, and
<code>"nothing"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attributes are ignored.
</p>


<h3>Value</h3>

<p>Logical. Do <code>user</code> and <code>expected</code> match?
</p>

<hr>
<h2 id='match_input'>Match user inputs to expected values</h2><span id='topic+match_input'></span>

<h3>Description</h3>

<p>Match each user input to an expected/allowed value. Raise a warning if either
several user inputs match the same expected value, or at least one could not
be matched to any expected value. <code>ciftiTools</code> uses this function to
match keyword arguments for a function call. Another use is to match
brainstructure labels (&quot;left&quot;, &quot;right&quot;, or &quot;subcortical&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_input(
  user,
  expected,
  fail_action = c("stop", "warning", "message", "nothing"),
  user_value_label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_input_+3A_user">user</code></td>
<td>
<p>Character vector of user input. These will be matched to
<code>expected</code> using <code><a href="base.html#topic+match.arg">match.arg</a></code>.</p>
</td></tr>
<tr><td><code id="match_input_+3A_expected">expected</code></td>
<td>
<p>Character vector of expected/allowed values.</p>
</td></tr>
<tr><td><code id="match_input_+3A_fail_action">fail_action</code></td>
<td>
<p>If any value in <code>user</code> could not be
matched, or repeated matches occurred, what should happen? Possible values
are <code>"stop"</code> (default; raises an error), <code>"warning"</code>, and
<code>"nothing"</code>.</p>
</td></tr>
<tr><td><code id="match_input_+3A_user_value_label">user_value_label</code></td>
<td>
<p>How to refer to the user input in a stop or warning
message. If <code>NULL</code>, no label is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched user inputs.
</p>

<hr>
<h2 id='mean_squares'>Compute mean squares from variance decomposition</h2><span id='topic+mean_squares'></span>

<h3>Description</h3>

<p>Compute mean squares from variance decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_squares(vd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_squares_+3A_vd">vd</code></td>
<td>
<p>The variance decomposition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean squares
</p>

<hr>
<h2 id='merge_kwargs'>Merges two kwargs</h2><span id='topic+merge_kwargs'></span>

<h3>Description</h3>

<p>Merge two kwarg lists. If a kwarg is present in both lists but with different
values, an error is raised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_kwargs(
  kwargsA,
  kwargsB,
  labelA = "first kwarg(s)",
  labelB = "second kwarg(s)",
  extraMsg = "[DEFAULT]"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_kwargs_+3A_kwargsa">kwargsA</code></td>
<td>
<p>The first list of kwargs.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_kwargsb">kwargsB</code></td>
<td>
<p>The second list of kwargs. If duplicates are present, the default
message recommends the user to remove the kwarg here in favor of placing the
correct one in <code>kwargsA</code>.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_labela">labelA</code></td>
<td>
<p>(Optional) Descriptor of <code>kwargsA</code> for error statement. Default &quot;first kwarg(s)&quot;.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_labelb">labelB</code></td>
<td>
<p>(Optional) Descriptor of <code>kwargsB</code> for error statement. Default &quot;second kwarg(s)&quot;.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_extramsg">extraMsg</code></td>
<td>
<p>(Optional) Extra text for error statement. &quot;[DEFAULT]&quot; (default) will use this message:
&quot;Note that a kwarg only has to be provided to one of these. Place the correct value in the first
location and remove the kwarg from the second location&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the union of <code>kwargsA</code> and <code>kwargsB</code>
</p>

<hr>
<h2 id='Mode'>Mode of data vector</h2><span id='topic+Mode'></span>

<h3>Description</h3>

<p>Get mode of a data vector. But use the median instead of the mode if all
data values are unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mode_+3A_x">x</code></td>
<td>
<p>The data vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mode
</p>

<hr>
<h2 id='noise_Params'>noise parameters for CompCor</h2><span id='topic+noise_Params'></span>

<h3>Description</h3>

<p>noise parameters for CompCor
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="noise_Params_+3A_noise_npc">noise_nPC</code></td>
<td>
<p>The number of principal components to compute for each noise
ROI. Alternatively, values between 0 and 1, in which case they will
represent the minimum proportion of variance explained by the PCs used for
each noise ROI. The smallest number of PCs will be used to achieve this
proportion of variance explained.
</p>
<p>Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>5</code> (compute the top 5 PCs for
each noise ROI).</p>
</td></tr>
<tr><td><code id="noise_Params_+3A_noise_erosion">noise_erosion</code></td>
<td>
<p>The number of voxel layers to erode the noise ROIs by.
Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>NULL</code>, which will use a value of
0 (do not erode the noise ROIs). Note that noise erosion can only be
performed if the noise ROIs are volumetric.</p>
</td></tr>
</table>

<hr>
<h2 id='norm_BOLD'>Normalize BOLD data</h2><span id='topic+norm_BOLD'></span>

<h3>Description</h3>

<p>Center the data across space and/or time, detrend, and scale, in that order.
For dual regression, row centering is required and column centering is not
recommended. Scaling and detrending depend on the user preference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_BOLD(
  BOLD,
  center_rows = TRUE,
  center_cols = FALSE,
  scale = c("local", "global", "none"),
  scale_sm_xifti = NULL,
  scale_sm_FWHM = 2,
  TR = NULL,
  hpf = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_BOLD_+3A_bold">BOLD</code></td>
<td>
<p>fMRI numeric data matrix (<code class="reqn">V \times T</code>)</p>
</td></tr>
<tr><td><code id="norm_BOLD_+3A_center_rows">center_rows</code>, <code id="norm_BOLD_+3A_center_cols">center_cols</code></td>
<td>
<p>Center BOLD data across rows (each data
location's time series) or columns (each time point's image)? Default:
<code>TRUE</code> for row centering, and <code>FALSE</code> for column centering.</p>
</td></tr>
<tr><td><code id="norm_BOLD_+3A_scale">scale</code></td>
<td>
<p><code>"global"</code> (default), <code>"local"</code>, or <code>"none"</code>.
Global scaling will divide the entire data matrix by the mean image standard
deviation (<code>mean(sqrt(rowVars(BOLD)))</code>). Local scaling will divide each
data location's time series by its estimated standard deviation.</p>
</td></tr>
<tr><td><code id="norm_BOLD_+3A_scale_sm_xifti">scale_sm_xifti</code>, <code id="norm_BOLD_+3A_scale_sm_fwhm">scale_sm_FWHM</code></td>
<td>
<p>Only applies if <code>scale=="local"</code> and
<code>BOLD</code> represents CIFTI-format data. To smooth the standard deviation
estimates used for local scaling, provide a <code>"xifti"</code> object with data
locations in alignment with <code>BOLD</code>, as well as the smoothing FWHM
(default: <code>2</code>). If no <code>"xifti"</code> object is provided (default), do
not smooth.</p>
</td></tr>
<tr><td><code id="norm_BOLD_+3A_tr">TR</code></td>
<td>
<p>The temporal resolution of the data, i.e. the time between volumes,
in seconds. <code>TR</code> is required for detrending with <code>hpf</code>.</p>
</td></tr>
<tr><td><code id="norm_BOLD_+3A_hpf">hpf</code></td>
<td>
<p>The frequency at which to apply a highpass filter to the data
during pre-processing, in Hertz. Default: <code>0.01</code> Hertz. Set to <code>0</code>
to disable the highpass filter.
</p>
<p>The highpass filter serves to detrend the data, since low-frequency
variance is associated with noise. Highpass filtering is accomplished by
nuisance regression of discrete cosine transform (DCT) bases.
</p>
<p>Note the <code>TR</code> argument is required for highpass filtering. If
<code>TR</code> is not provided, <code>hpf</code> will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized BOLD data matrix (<code class="reqn">V \times T</code>)
</p>

<hr>
<h2 id='nuisance_regression'>Nuisance regression</h2><span id='topic+nuisance_regression'></span>

<h3>Description</h3>

<p>Performs nuisance regression. Important note: the data and design matrix must
both be centered, or an intercept must be included in the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuisance_regression(Y, design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nuisance_regression_+3A_y">Y</code></td>
<td>
<p>The <code class="reqn">T \times V</code> or <code class="reqn">V \times T</code> data.</p>
</td></tr>
<tr><td><code id="nuisance_regression_+3A_design">design</code></td>
<td>
<p>The <code class="reqn">T \times Q</code> matrix of nuisance regressors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data after nuisance regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- matrix(rnorm(700), nrow=100)
design &lt;- cbind(seq(100), 1)
nuisance_regression(Y, design)
</code></pre>

<hr>
<h2 id='pad_vol'>Pad 3D Array</h2><span id='topic+pad_vol'></span><span id='topic+uncrop_vol'></span>

<h3>Description</h3>

<p>Pad a 3D array by a certain amount in each direction, along each dimension.
This operation is like the opposite of cropping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_vol(x, padding, fill = NA)

uncrop_vol(x, padding, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_vol_+3A_x">x</code></td>
<td>
<p>A 3D array, e.g.
<code>unvec_vol(xifti$data$subcort, xifti$meta$subcort$mask)</code>.</p>
</td></tr>
<tr><td><code id="pad_vol_+3A_padding">padding</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix indicating the number of
slices to add at the beginning (first column) and end (second column) of
each of dimension, e.g. <code>xifti$meta$subcort$mask_padding</code>.</p>
</td></tr>
<tr><td><code id="pad_vol_+3A_fill">fill</code></td>
<td>
<p>Value to pad with. Default: <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The padded array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(seq(24), dim=c(2,3,4))
y &lt;- pad_vol(x, array(1, dim=c(3,2)), 0)
stopifnot(all(dim(y) == dim(x)+2))
stopifnot(sum(y) == sum(x))
z &lt;- crop_vol(y)$data
stopifnot(identical(dim(x), dim(z)))
stopifnot(max(abs(z - x))==0)
</code></pre>

<hr>
<h2 id='PCA'>PCA for tall matrix</h2><span id='topic+PCA'></span>

<h3>Description</h3>

<p>Efficient PCA for a tall matrix (many more rows than columns). Uses the SVD
of the covariance matrix. The dimensionality of the result can be preset
with <code>Q</code> or estimated with PESEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA(X, center = TRUE, Q = NULL, Q_max = 100, Vdim = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA_+3A_x">X</code></td>
<td>
<p>The tall numeric matrix for which to compute the PCA. For fMRI data,
<code>X</code> should be <code>V</code> brain locations by <code>T</code> timepoints.</p>
</td></tr>
<tr><td><code id="PCA_+3A_center">center</code></td>
<td>
<p>Center the columns of <code>X</code>? Default: <code>TRUE</code>. Set to
<code>FALSE</code> if already centered. Centered data is required to compute PCA.</p>
</td></tr>
<tr><td><code id="PCA_+3A_q">Q</code></td>
<td>
<p>Number of latent dimensions to estimate. If <code>NULL</code> (default),
estimated using PESEL (Sobczyka et al. 2020).</p>
</td></tr>
<tr><td><code id="PCA_+3A_q_max">Q_max</code></td>
<td>
<p>Maximal number of principal components for automatic
dimensionality selection with PESEL. Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="PCA_+3A_vdim">Vdim</code></td>
<td>
<p>Number of principal directions to obtain. Default: <code>0</code>. Can
also be <code>"Q"</code> to set equal to the value of <code>Q</code>. Note that setting
this value less than <code>Q</code> does not speed up computation time, but does
save on memory. Note that the directions will be with respect to <code>X</code>,
not its covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SVD decomposition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- matrix(rnorm(900), nrow=300, ncol=3)
V &lt;- matrix(rnorm(15), nrow=3, ncol=5)
PCA(U %*% V)
</code></pre>

<hr>
<h2 id='pct_sig'>Convert data values to percent signal.</h2><span id='topic+pct_sig'></span>

<h3>Description</h3>

<p>Convert data values to percent signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pct_sig(X, center = median, by = c("column", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pct_sig_+3A_x">X</code></td>
<td>
<p>a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix. The columns will be normalized to
percent signal.</p>
</td></tr>
<tr><td><code id="pct_sig_+3A_center">center</code></td>
<td>
<p>A function that computes the center of a numeric vector.
Default: <code>median</code>. Other common options include <code>mean</code> and
<code>mode</code>.</p>
</td></tr>
<tr><td><code id="pct_sig_+3A_by">by</code></td>
<td>
<p>Should the center be measured individually for each <code>"column"</code>
(default), or should the center be the same across <code>"all"</code> columns?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>X</code> with its columns normalized to percent signal. (A value of
85 will represent a -15% signal change.)
</p>

<hr>
<h2 id='read_nifti'>Wrapper to functions for reading NIFTIs</h2><span id='topic+read_nifti'></span>

<h3>Description</h3>

<p>Tries <code>RNifti::readNifti</code>, then <code>oro.nifti::readNIfTI</code>. If
neither package is available an error is raised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nifti(nifti_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_nifti_+3A_nifti_fname">nifti_fname</code></td>
<td>
<p>The file name of the NIFTI.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>oro.nifti::readNIFTI</code> the argument
<code>reorient=FALSE</code> will be used.
</p>


<h3>Value</h3>

<p>The NIFTI
</p>

<hr>
<h2 id='rowMedians2'>Row medians</h2><span id='topic+rowMedians2'></span>

<h3>Description</h3>

<p>Use <code>robustbase::rowMedians</code> package if available, <code>apply</code> if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMedians2(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMedians2_+3A_x">x</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="rowMedians2_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignore NA values? Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The row medians of <code>x</code>.
</p>

<hr>
<h2 id='scale_design_mat'>Scale a design matrix</h2><span id='topic+scale_design_mat'></span>

<h3>Description</h3>

<p>Scale the columns of a matrix by dividing each column by its
highest-magnitude value, and then subtracting its mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_design_mat(x, doRows = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_design_mat_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">T \times K</code> numeric matrix. In the context of a
design matrix for a GLM analysis of task fMRI, <code class="reqn">T</code> is the number of time
points and <code class="reqn">K</code> is the number of task covariates.</p>
</td></tr>
<tr><td><code id="scale_design_mat_+3A_dorows">doRows</code></td>
<td>
<p>Scale the rows instead? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scaled design matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_design_mat(cbind(seq(7), 1, rnorm(7)))
</code></pre>

<hr>
<h2 id='scale_med'>Robust scaling</h2><span id='topic+scale_med'></span>

<h3>Description</h3>

<p>Centers and scales the columns of a matrix robustly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_med(mat, TOL = 1e-08, drop_const = TRUE, doRows = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_med_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix. Its columns will be centered and scaled.</p>
</td></tr>
<tr><td><code id="scale_med_+3A_tol">TOL</code></td>
<td>
<p>Columns with MAD below this value will be considered constant.
Default: <code>1e-8</code></p>
</td></tr>
<tr><td><code id="scale_med_+3A_drop_const">drop_const</code></td>
<td>
<p>Drop constant columns? Default: <code>TRUE</code>. If
<code>FALSE</code>, set to <code>NA</code> instead.</p>
</td></tr>
<tr><td><code id="scale_med_+3A_dorows">doRows</code></td>
<td>
<p>Center and scale the rows instead? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centers each column on its median, and scales each column by its median
absolute deviation (MAD). If there are constant-valued columns, they are
removed if <code>drop_const</code> or set to <code>NA</code> if <code>!drop_const</code>, and
a warning is raised. If all columns are constant, an error is raised.
</p>


<h3>Value</h3>

<p>The input matrix with its columns centered and scaled.
</p>

<hr>
<h2 id='scale_timeseries'>Scale the BOLD timeseries</h2><span id='topic+scale_timeseries'></span>

<h3>Description</h3>

<p>Scale the BOLD timeseries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_timeseries(
  BOLD,
  scale = c("auto", "mean", "sd", "none"),
  transpose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_timeseries_+3A_bold">BOLD</code></td>
<td>
<p>fMRI data as a locations by time (<code class="reqn">V \times T</code>) numeric
matrix.</p>
</td></tr>
<tr><td><code id="scale_timeseries_+3A_scale">scale</code></td>
<td>
<p>Option for scaling the BOLD response.
</p>
<div class="sourceCode"><pre>\code{"auto"} (default) will use \code{"mean"} scaling except if demeaned 
</pre></div>
<p>data is detected (if any mean is less than one), in which case <code>"sd"</code>
scaling will be used instead.
</p>
<div class="sourceCode"><pre>\code{"mean"} scaling will scale the data to percent local signal change.

\code{"sd"} scaling will scale the data by local standard deviation.

\code{"none"} will only center the data, not scale it.
</pre></div></td></tr>
<tr><td><code id="scale_timeseries_+3A_transpose">transpose</code></td>
<td>
<p>Transpose <code>BOLD</code> if there are more columns than rows?
(Because we usually expect the number of voxels to exceed the number of time
points.) Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scale to units of percent local signal change and centers
</p>

<hr>
<h2 id='sign_flip'>Sign match ICA results</h2><span id='topic+sign_flip'></span>

<h3>Description</h3>

<p>Flips all source signal estimates (S) to positive skew
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign_flip(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign_flip_+3A_x">x</code></td>
<td>
<p>The ICA results: a list with entries <code>"S"</code> and <code>"M"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> but with positive skew source signals
</p>

<hr>
<h2 id='skew_pos'>Positive skew?</h2><span id='topic+skew_pos'></span>

<h3>Description</h3>

<p>Does the vector have a positive skew?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skew_pos(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skew_pos_+3A_x">x</code></td>
<td>
<p>The numeric vector for which to calculate the skew. Can also be a
matrix, in which case the skew of each column will be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the skew is positive or zero. <code>FALSE</code> if the
skew is negative.
</p>

<hr>
<h2 id='sum_neighbors_vol'>Sum of each voxel's neighbors</h2><span id='topic+sum_neighbors_vol'></span>

<h3>Description</h3>

<p>For each voxel in a 3D logical or numeric array, sum the values of the six
neighboring voxels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_neighbors_vol(arr, pad = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_neighbors_vol_+3A_arr">arr</code></td>
<td>
<p>The 3D array.</p>
</td></tr>
<tr><td><code id="sum_neighbors_vol_+3A_pad">pad</code></td>
<td>
<p>In order to compute the sum, the array is temporarily padded along
each edge with the value of <code>pad</code>. <code>0</code> (default) will mean that
edge voxels reflect the sum of 3-5 neighbors whereas non-edge voxels reflect
the sum of 6 neighbors. An alternative is to use a value of <code>NA</code> so
that edge voxels are <code>NA</code>-valued because they did not have a complete
set of six neighbors. Perhaps another option is to use <code>mean(arr)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diagonal voxels are not considered adjacent, i.e. the voxel at (0,0,0) is not
adjacent to the voxels at (1,1,0) or (1,1,1), although it is adjacent to
(1,0,0).
</p>


<h3>Value</h3>

<p>An array with the same dimensions as <code>arr</code>. Each voxel value
will be the sum across the immediate neighbors. If <code>arr</code> was a logical
array, this value will be between 0 and 6.
</p>

<hr>
<h2 id='sys_path'>Format a path for <code><a href="base.html#topic+system">system</a></code></h2><span id='topic+sys_path'></span>

<h3>Description</h3>

<p>Right now, it uses <code>shQuote</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sys_path(R_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sys_path_+3A_r_path">R_path</code></td>
<td>
<p>The name of the file. It should be properly formatted: if it
exists, <code>file.exists(R_path)</code> should be <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the file
</p>

<hr>
<h2 id='unmask_mat'>Unmask matrix data</h2><span id='topic+unmask_mat'></span>

<h3>Description</h3>

<p>Insert empty rows or columns to a matrix. For example, medial wall vertices
can be added back to the cortex data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmask_mat(x, mask, mask_dim = 1, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmask_mat_+3A_x">x</code></td>
<td>
<p>The data matrix to unmask.</p>
</td></tr>
<tr><td><code id="unmask_mat_+3A_mask">mask</code></td>
<td>
<p>The logical mask: the number of <code>TRUE</code> values should match
the size of the (<code>mask_dim</code>)th dimension in <code>dat</code>.</p>
</td></tr>
<tr><td><code id="unmask_mat_+3A_mask_dim">mask_dim</code></td>
<td>
<p>Rows, <code>1</code> (default), or columns, <code>2</code>.</p>
</td></tr>
<tr><td><code id="unmask_mat_+3A_fill">fill</code></td>
<td>
<p>The fill value for the inserted rows/columns. Default: <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unmasked matrix.
</p>

<hr>
<h2 id='unvec_mat'>Transform vector data to image</h2><span id='topic+unvec_mat'></span>

<h3>Description</h3>

<p>From a <code class="reqn">v \times p</code> matrix of vectorized data and an <code class="reqn">m \times n</code>
image mask with <code class="reqn">v</code> in-mask locations, create a list of <code class="reqn">p</code>
<code class="reqn">m \times n</code> data arrays in which the mask locations are filled
in with the vectorized data values.
</p>
<p>Consider using <code>abind::abind</code> to merge the result into a single
array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvec_mat(x, mask, fill_value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unvec_mat_+3A_x">x</code></td>
<td>
<p><code class="reqn">v \times p</code> matrix, where <code class="reqn">v</code> is the number of
voxels within a mask and <code class="reqn">p</code> is the number of vectors to transform into
matrix images.</p>
</td></tr>
<tr><td><code id="unvec_mat_+3A_mask">mask</code></td>
<td>
<p><code class="reqn">m \times n</code> logical matrix in which <code>v</code>
entries are <code>TRUE</code> and the rest are <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unvec_mat_+3A_fill_value">fill_value</code></td>
<td>
<p>Out-of-mask value in the output image. Default:
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of masked values from <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- unvec_mat(
 cbind(seq(3), seq(2,4), seq(3,5)), 
 matrix(c(rep(TRUE, 3), FALSE), ncol=2),
 0
)
y &lt;- array(c(1,2,3,0,2,3,4,0,3,4,5,0), dim=c(2,2,3))
stopifnot(identical(x[[1]], y[,,1]))
stopifnot(identical(x[[2]], y[,,2]))
stopifnot(identical(x[[3]], y[,,3]))

</code></pre>

<hr>
<h2 id='unvec_vol'>Convert vectorized data back to volume</h2><span id='topic+unvec_vol'></span>

<h3>Description</h3>

<p>Un-applies a mask to vectorized data to yield its volumetric representation.
The mask and data should have compatible dimensions: the number of rows in
<code>dat</code> should equal the number of locations within the <code>mask</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvec_vol(dat, mask, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unvec_vol_+3A_dat">dat</code></td>
<td>
<p>Data matrix with locations along the rows and measurements along
the columns. If only one set of measurements were made, this may be a
vector.</p>
</td></tr>
<tr><td><code id="unvec_vol_+3A_mask">mask</code></td>
<td>
<p>Volumetric binary mask. <code>TRUE</code> indicates voxels inside the
mask.</p>
</td></tr>
<tr><td><code id="unvec_vol_+3A_fill">fill</code></td>
<td>
<p>The value for locations outside the mask. Default: <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 3D or 4D unflattened volume array
</p>

<hr>
<h2 id='validate_design_mat'>Validate design matrix</h2><span id='topic+validate_design_mat'></span>

<h3>Description</h3>

<p>Coerces <code>design</code> to a numeric matrix, and optionally checks that the
number of rows is as expected. Sets constant-valued columns to 1, and scales
all other columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_design_mat(design, T_ = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_design_mat_+3A_design">design</code></td>
<td>
<p>The design matrix</p>
</td></tr>
<tr><td><code id="validate_design_mat_+3A_t_">T_</code></td>
<td>
<p>the expected number of rows in <code>design</code>. Default:
<code>NULL</code> (no expected value to validate).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (modified) design matrix
</p>

<hr>
<h2 id='var_decomp'>Compute variance decomposition</h2><span id='topic+var_decomp'></span>

<h3>Description</h3>

<p>Calculate the various ANOVA sums of squares for repeated measures data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_decomp(x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_decomp_+3A_x">x</code></td>
<td>
<p>The data as a 3D array: measurements by subjects by variables.
(Alternatively, a matrix that is measurements by subjects, if only one
variable exists.)</p>
</td></tr>
<tr><td><code id="var_decomp_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, display progress of algorithm. Default:
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance decomposition
</p>

<hr>
<h2 id='vox_locations'>Get coordinates of each voxel in a mask</h2><span id='topic+vox_locations'></span>

<h3>Description</h3>

<p>Made for obtaining voxel locations in 3D space from the subcortical metadata
of CIFTI data: the volumetric mask, the transformation matrix and the
spatial units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vox_locations(mask, trans_mat, trans_units = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vox_locations_+3A_mask">mask</code></td>
<td>
<p>3D logical mask</p>
</td></tr>
<tr><td><code id="vox_locations_+3A_trans_mat">trans_mat</code></td>
<td>
<p>Transformation matrix from array indices to spatial
coordinates.</p>
</td></tr>
<tr><td><code id="vox_locations_+3A_trans_units">trans_units</code></td>
<td>
<p>Units for the spatial coordinates (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>coords</code> and <code>trans_units</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
