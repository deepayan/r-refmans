<!DOCTYPE html><html lang="en"><head><title>Help for package callsync</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {callsync}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#callsync'><p>callsync: sychronous analysis of multiple microphones</p></a></li>
<li><a href='#align'><p>align</p></a></li>
<li><a href='#better.spectro'><p>better.spectro</p></a></li>
<li><a href='#calc.am'><p>calc.am</p></a></li>
<li><a href='#calc.fm'><p>calc.fm</p></a></li>
<li><a href='#calc.perf'><p>calc.perf</p></a></li>
<li><a href='#call.assign'><p>call.assign</p></a></li>
<li><a href='#call.detect'><p>call.detect</p></a></li>
<li><a href='#call.detect.multiple'><p>call.detect.multiple</p></a></li>
<li><a href='#create.spec.object'><p>create.spec.object</p></a></li>
<li><a href='#detect.and.assign'><p>detect.and.assign</p></a></li>
<li><a href='#export.detections'><p>export.detections</p></a></li>
<li><a href='#load.selection.table'><p>load.selection.table</p></a></li>
<li><a href='#load.selection.tables'><p>load.selection.tables</p></a></li>
<li><a href='#load.selection.tables.audacity'><p>load.selection.tables.audacity</p></a></li>
<li><a href='#load.wave'><p>load.wave</p></a></li>
<li><a href='#measure.trace'><p>measure.trace</p></a></li>
<li><a href='#measure.trace.multiple'><p>measure.trace.multiple</p></a></li>
<li><a href='#o.to.m'><p>o.to.m</p></a></li>
<li><a href='#run.spcc'><p>run.spcc</p></a></li>
<li><a href='#simple.cc'><p>simple.cc</p></a></li>
<li><a href='#sliding.pixel.comparison'><p>sliding.pixel.comparison</p></a></li>
<li><a href='#trace.fund'><p>trace.fund</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Recording Synchronisation, Call Detection and Assignment, Audio
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Intended to analyse recordings from multiple microphones (e.g., backpack
  microphones in captive setting). It allows users to align recordings even if there is non-linear 
  drift of several minutes between them. A call detection and assignment pipeline can be used 
  to find vocalisations and assign them to the vocalising individuals (even if the vocalisation
  is picked up on multiple microphones). The tracing and measurement functions allow for detailed
  analysis of the vocalisations and filtering of noise. Finally, the package includes a function
  to run spectrographic cross correlation, which can be used to compare vocalisations. It also 
  includes multiple other functions related to analysis of vocal behaviour.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/simeonqs/callsync">https://github.com/simeonqs/callsync</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/simeonqs/callsync/issues">https://github.com/simeonqs/callsync/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.10), oce (&ge; 1.7), seewave (&ge; 2.2.0), signal
(&ge; 0.7), stringr (&ge; 1.4.1), tuneR (&ge; 1.4.0), scales (&ge;
1.2.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-24 10:03:16 UTC; au472091</td>
</tr>
<tr>
<td>Author:</td>
<td>Simeon Q. Smeele [cre, aut],
  Stephen A. Tyndel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simeon Q. Smeele &lt;simeonqs@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-24 10:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='callsync'>callsync: sychronous analysis of multiple microphones</h2><span id='topic+callsync'></span><span id='topic+callsync-package'></span>

<h3>Description</h3>

<p>Intended to analyse recordings from multiple microphones (e.g., backpack
microphones in captive setting). It allows users to align recordings even if there is non-linear
drift of several minutes between them. A call detection and assignment pipeline can be used
to find vocalisations and assign them to the vocalising individuals (even if the vocalisation
is picked up on multiple microphones). The tracing and measurement functions allow for detailed
analysis of the vocalisations and filtering of noise. Finally, the package includes a function
to run spectrographic cross correlation, which can be used to compare vocalisations. It also
includes multiple other functions related to analysis of vocal behaviour.
</p>


<h3>Details</h3>

<p>The main features of the package are:
</p>

<ul>
<li><p> alignment and partitioning of drifting microphones using signal compression and cross correlation
</p>
</li>
<li><p> call detection using an amplitude envelope
</p>
</li>
<li><p> fine-scale alignment and call assignment across recordings using cross correlation and energy content
</p>
</li>
<li><p> fundamental frequency tracing
</p>
</li>
<li><p> analysis of the resulting traces and wav clips
</p>
</li></ul>

<p>The package offers functions to:
</p>

<ul>
<li><p> create flexible spectrograms
</p>
</li>
<li><p> run spectrographic cross correlation
</p>
</li>
<li><p> analyse amplitude and frequency modulation
</p>
</li>
<li><p> load selection tables from Raven and Audacity
</p>
</li>
<li><p> calculate performance of the detection and assignment functions
</p>
</li></ul>

<p>License: GNU (&gt;= 2)
</p>
<p>Authors: Simeon Q. Smeele and Stephen A. Tyndel
</p>
<p>Maintainer: Simeon Q. Smeele, &lt;simeonqs@hotmail.com&gt;
</p>

<hr>
<h2 id='align'>align</h2><span id='topic+align'></span>

<h3>Description</h3>

<p>Aligns multiple recordings (.wav files). It assumes all microphones are within recording range
of each other most of the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align(
  chunk_size = 15,
  step_size = 0.5,
  all_files = NULL,
  path_recordings = NULL,
  path_chunks = NULL,
  chunk_seq = NULL,
  keys_id = NULL,
  keys_rec = NULL,
  blank = 15,
  wing = 10,
  ffilter_from = NULL,
  down_sample = NULL,
  save_pdf = FALSE,
  save_log = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_+3A_chunk_size">chunk_size</code></td>
<td>
<p>numeric, duration in minutes of the chunks to output. Default is '15'.</p>
</td></tr>
<tr><td><code id="align_+3A_step_size">step_size</code></td>
<td>
<p>numeric, duration in seconds of the bins for signal compression before cross correlation.
Default is '0.5'.</p>
</td></tr>
<tr><td><code id="align_+3A_all_files">all_files</code></td>
<td>
<p>character vector, paths to all raw recordings to consider. If 'NULL' files are listed
based on the argument 'path_recordings'.</p>
</td></tr>
<tr><td><code id="align_+3A_path_recordings">path_recordings</code></td>
<td>
<p>character, the path where the raw recordings are stored. Can be nested in folders,
in this case provide the top-level folder.</p>
</td></tr>
<tr><td><code id="align_+3A_path_chunks">path_chunks</code></td>
<td>
<p>character, the path where aligned chunks should be stored.</p>
</td></tr>
<tr><td><code id="align_+3A_chunk_seq">chunk_seq</code></td>
<td>
<p>numeric vector or 'NULL'. If supplied only these chunks are rerun.</p>
</td></tr>
<tr><td><code id="align_+3A_keys_id">keys_id</code></td>
<td>
<p>character vector of length 2. The characters before and after the unique ID of the
individual or microphone. This can be in the file name or in the folder structure. E.g., if the path to the
recording is &lsquo;../data/week_1/recording_mic1.wav' the keys would be 'c(&rsquo;recording_', '.wav')' and the
function would retrieve 'mic1' as individual id.</p>
</td></tr>
<tr><td><code id="align_+3A_keys_rec">keys_rec</code></td>
<td>
<p>character vector of length 2. The characters before and after the unique ID of the
recording. This can be in the file name or in the folder structure. E.g., if the path to the recording
is &lsquo;../data/week_1/recording_mic1.wav' the keys would be 'c(&rsquo;data/', '/recording')' and the function would
retrieve 'week_1' as recording id.</p>
</td></tr>
<tr><td><code id="align_+3A_blank">blank</code></td>
<td>
<p>numeric, the duration in minutes to be discarded at the beginning and end of the recording.</p>
</td></tr>
<tr><td><code id="align_+3A_wing">wing</code></td>
<td>
<p>numeric, the duration in minutes to load before and after each chunk to improve alignment. This
is not saved with the aligned chunk.</p>
</td></tr>
<tr><td><code id="align_+3A_ffilter_from">ffilter_from</code></td>
<td>
<p>numeric, frequency in Hz for the high-pass filter.</p>
</td></tr>
<tr><td><code id="align_+3A_down_sample">down_sample</code></td>
<td>
<p>numeric, the sample rate for down-sampling. If 'NULL' no down-sampling is done.</p>
</td></tr>
<tr><td><code id="align_+3A_save_pdf">save_pdf</code></td>
<td>
<p>logical, if 'TRUE' a pdf is saved with a page per chunk that shows all the aligned
recordings.</p>
</td></tr>
<tr><td><code id="align_+3A_save_log">save_log</code></td>
<td>
<p>logical, if 'TRUE' a csv file with all alignment times is saved in path_chunks.</p>
</td></tr>
<tr><td><code id="align_+3A_quiet">quiet</code></td>
<td>
<p>logical, if 'TRUE' no messages are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to tell the function where the files are. You can either compile a character
vector of pathnames yourself and enter this under 'all_files' or you can give a single character path to
'path_recordings'. You need to make sure that there is an identifier by which to group the recordings and
an identifier for each individual or microphone in the path. This can either be a in the folder structure
or in the file names themselves. The align function will align all individuals per recording id (e.g.,
date). These identifiers are found using regexp, so mostly you can use the first few characters before
and after them (see examples in the argument descriptions). The function loads chunks of the recordings,
sums the absolute amplitude per bin and runs cross correlation to find alignment relative to the first
recording. The aligned chunks are then saved.
</p>


<h3>Value</h3>

<p>saves all the aligned chunks in the location specific by 'path_chunks'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/chunk@1@1@1@1.wav'
file_2 = '/chunk@2@1@1@1.wav'
url_1 = paste0(path_git, path_repo, file_1)
url_2 = paste0(path_git, path_repo, file_2)
local_file_1 = paste(tempdir(), file_1, sep = '/')
local_file_2 = paste(tempdir(), file_2, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
if(!file.exists(local_file_2))
  download.file(url_2, destfile = local_file_2, mode = 'wb')
all_files = c(local_file_1, local_file_2)
a = align(chunk_size = 2,
          step_size = 0.1,
          all_files = all_files,
          keys_id = c('c', '@'),
          keys_rec = c('c', '@'),
          blank = 0,
          wing = 0,
          quiet = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='better.spectro'>better.spectro</h2><span id='topic+better.spectro'></span>

<h3>Description</h3>

<p>Creates a spectrogram and plots it to the current window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>better.spectro(
  wave,
  main = "",
  wl = 512,
  ovl = wl/2,
  xlim = NULL,
  ylim = NULL,
  mar = rep(3, 4),
  cex.main = 1,
  cex.axis = 0.75,
  cex.lab = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="better.spectro_+3A_wave">wave</code></td>
<td>
<p>wave object, e.g., from 'load.wave' or 'readWave'.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_main">main</code></td>
<td>
<p>character, title for the spectrogram. Default is no title.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_wl">wl</code></td>
<td>
<p>numeric, window length in samples. Default is '512'.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_ovl">ovl</code></td>
<td>
<p>numeric, overlap in samples. Default is 'wl/2'.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_xlim">xlim</code></td>
<td>
<p>numeric vector of length 2, limits for the x-axis. Default is no limits.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of length 2, limits for the y-axis. Default is no limits.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_mar">mar</code></td>
<td>
<p>numeric vector of length 4, the margins of the plot for the 'impagep' function. Default is 'rep(3, 4)'.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_cex.main">cex.main</code></td>
<td>
<p>numeric the relative size of the title</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_cex.axis">cex.axis</code></td>
<td>
<p>numeric the relative size of the axis labels.</p>
</td></tr>
<tr><td><code id="better.spectro_+3A_cex.lab">cex.lab</code></td>
<td>
<p>numeric the relative size of the axis titles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots the spectrogram to current window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
better.spectro(wave)

</code></pre>

<hr>
<h2 id='calc.am'>calc.am</h2><span id='topic+calc.am'></span>

<h3>Description</h3>

<p>Calculates the amplitude modulation for a wave object and returns several measurements in
a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.am(wave, msmooth = c(1000, 90))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.am_+3A_wave">wave</code></td>
<td>
<p>wave object, e.g., from 'load.wave' or 'readWave'.</p>
</td></tr>
<tr><td><code id="calc.am_+3A_msmooth">msmooth</code></td>
<td>
<p>used as argument for the 'seewave::env' function. *A vector of length 2 to smooth the
amplitude envelope with a mean sliding window. The first component is the window length (in number of
points). The second component is the overlap between successive windows (in %).* Default is 'c(500, 95)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with nr_notes = total number of amplitude modulations in the signal,
amp_mod_med = median difference between highest and lowest amplitude from the normalised envelope,
internote_med = median internote distance in seconds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
result = calc.am(wave)

</code></pre>

<hr>
<h2 id='calc.fm'>calc.fm</h2><span id='topic+calc.fm'></span>

<h3>Description</h3>

<p>Calculates the frequency modulation for a wave object and returns several measurements in
a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.fm(trace, min_height = 8, plot_it = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.fm_+3A_trace">trace</code></td>
<td>
<p>numeric vector, e.g., the fundamental frequency from
'trace.fund', NOTE this would be 'trace$fund' and not the whole 'trace'
object.</p>
</td></tr>
<tr><td><code id="calc.fm_+3A_min_height">min_height</code></td>
<td>
<p>the minimum difference between a bottom and a peak for an infliction point to be
accepted.</p>
</td></tr>
<tr><td><code id="calc.fm_+3A_plot_it">plot_it</code></td>
<td>
<p>logical, if 'TRUE' plot the trace and peaks to current window. Default is 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with fm = median difference between peaks and bottoms and ipi = inter peak,
np = number of peaks.
interval (s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
trace = trace.fund(wave)
result = calc.fm(trace$fund)

</code></pre>

<hr>
<h2 id='calc.perf'>calc.perf</h2><span id='topic+calc.perf'></span>

<h3>Description</h3>

<p>Calculates the performance of the detections. Detections are
true positive if they overlap to any extend with a ground truth selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.perf(d, gt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.perf_+3A_d">d</code></td>
<td>
<p>data frame, detection selection table with start = start time in
seconds, end = end time in  seconds and file = file name</p>
</td></tr>
<tr><td><code id="calc.perf_+3A_gt">gt</code></td>
<td>
<p>data frame, ground truth selection table with start = start time
in seconds, end = end time in seconds and file = file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list with tp = the row numbers (in d) for the true
positives, fp = the row numbers (in d) for the false positives, fn = the row
numbers (in gt) for the false negatives, fp_rate = 'length(fp)/nrow(d)',
tp_rate = 'length(tp)/nrow(gt)', fn_rate = 'length(fn)/nrow(gt)'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/audacity/chunk_15_ground_truth.txt'
url_1 = paste0(path_git, path_repo, file_1)
local_dir = paste(tempdir(), 'audacity', sep = '/')
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!dir.exists(local_dir)) dir.create(local_dir)
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
d = load.selection.tables.audacity(path_selection_tables = local_dir)
result = calc.perf(d, d)

</code></pre>

<hr>
<h2 id='call.assign'>call.assign</h2><span id='topic+call.assign'></span>

<h3>Description</h3>

<p>Assigns calls from a detection table. Or rather removes calls that are not the loudest and
returns the cleaned detection table. Uses fine alignment and energy content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call.assign(
  all_files = NULL,
  detections = NULL,
  save_files = TRUE,
  path_calls = NULL,
  ffilter_from = 1100,
  wing = 5,
  step_size = 0.01,
  assign_fraq = 0.05,
  save_wing = 0.1,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call.assign_+3A_all_files">all_files</code></td>
<td>
<p>character vector, should contain all the paths to the raw recordings that should be
considered. If 'NULL' files are loaded from 'path_chunks'.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_detections">detections</code></td>
<td>
<p>data frame with start = start time in samples and end = end time in samples for each
detection.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_save_files">save_files</code></td>
<td>
<p>logical, if 'TRUE' the files are stored in the 'path_chunks' location. Results are also
returned.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_path_calls">path_calls</code></td>
<td>
<p>character, path to where to store the results.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_ffilter_from">ffilter_from</code></td>
<td>
<p>numeric, frequency in Hz for the high-pass filter.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_wing">wing</code></td>
<td>
<p>numeric, the duration in seconds to load before and after each detection to improve alignment.
This is not saved with the aligned call.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_step_size">step_size</code></td>
<td>
<p>numeric, duration in seconds of the bins for signal compression before cross correlation.
Default is '0.01'.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_assign_fraq">assign_fraq</code></td>
<td>
<p>numeric between 0 and 1, how much louder does the focal needs to be than the second
loudest track to be accepted. Default is '0.05' and accepts if the focal is just 0.05 louder.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_save_wing">save_wing</code></td>
<td>
<p>numeric, how much extra to export before and after a detection to make sure the whole call
is included in seconds. Default is '0.1'.</p>
</td></tr>
<tr><td><code id="call.assign_+3A_quiet">quiet</code></td>
<td>
<p>logical, if 'TRUE' no messages are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with file = file name, start = start time in samples and end = end time in
samples for each detection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/chunk@1@1@1@1.wav'
file_2 = '/chunk@2@1@1@1.wav'
url_1 = paste0(path_git, path_repo, file_1)
url_2 = paste0(path_git, path_repo, file_2)
local_file_1 = paste(tempdir(), file_1, sep = '/')
local_file_2 = paste(tempdir(), file_2, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
if(!file.exists(local_file_2))
  download.file(url_2, destfile = local_file_2, mode = 'wb')
all_files = c(local_file_1, local_file_2)
detections = lapply(all_files, function(file){
  wave = load.wave(file, ffilter_from = 1100)
  detections = call.detect.multiple(wave, plot_it = FALSE)
  return(detections)
})
names(detections) = basename(all_files)
ca = call.assign(all_files = all_files,
                 detections = detections,
                 quiet = TRUE,
                 save_files = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='call.detect'>call.detect</h2><span id='topic+call.detect'></span>

<h3>Description</h3>

<p>Detects single call in a wave object using an amplitude
envelope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call.detect(wave, threshold = 0.3, msmooth = c(500, 95), plot_it = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call.detect_+3A_wave">wave</code></td>
<td>
<p>wave object, e.g., from 'load.wave' or 'readWave'.</p>
</td></tr>
<tr><td><code id="call.detect_+3A_threshold">threshold</code></td>
<td>
<p>rector of length 1 or 2. The fraction of the maximum of the
normalised envelope to use as threshold to detect start and end. If a vector
of length 2 is supplied, the first is used to detect the start and the
second to detect the end (in case of echo).</p>
</td></tr>
<tr><td><code id="call.detect_+3A_msmooth">msmooth</code></td>
<td>
<p>used as argument for the 'seewave::env' function. *A vector
of length 2 to smooth the amplitude envelope with a mean sliding window. The
first component is the window length (in number of points). The second
component is the overlap between successive windows (in %).* Default is
'c(500, 95)'.</p>
</td></tr>
<tr><td><code id="call.detect_+3A_plot_it">plot_it</code></td>
<td>
<p>if 'TRUE', returns three-panel plot of wave form, envelope
and spectrogram to current plotting window. Default is 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with start = start time in samples and end = end
time in samples for each detection. Optionally also plots the wave form and
detections to current window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
cd = call.detect(wave)

</code></pre>

<hr>
<h2 id='call.detect.multiple'>call.detect.multiple</h2><span id='topic+call.detect.multiple'></span>

<h3>Description</h3>

<p>Detects multiple calls in a wave object using an amplitude
envelope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call.detect.multiple(
  wave,
  threshold = 0.3,
  msmooth = c(500, 95),
  plot_it = FALSE,
  min_dur = 0.1,
  max_dur = 0.3,
  save_extra = 0,
  env_type = "Hilbert",
  bin_depth = 512,
  merge_overlap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call.detect.multiple_+3A_wave">wave</code></td>
<td>
<p>wave object, e.g., from 'load.wave' or 'readWave'.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_threshold">threshold</code></td>
<td>
<p>rector of length 1 or 2. The fraction of the maximum of the
normalised envelope to use as threshold to detect start and end. If a vector
of length 2 is supplied, the first is used to detect the start and the
second to detect the end (in case of echo).</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_msmooth">msmooth</code></td>
<td>
<p>used as argument for the 'seewave::env' function. *A vector
of length 2 to smooth the amplitude envelope with a mean sliding window. The
first component is the window length (in number of points). The second
component is the overlap between successive windows (in %).* Default is
'c(500, 95)'.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_plot_it">plot_it</code></td>
<td>
<p>logical, if 'TRUE', returns three-panel plot of wave form,
envelope and spectrogram to current plotting window. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_min_dur">min_dur</code></td>
<td>
<p>numeric, the minimal duration in seconds for a detection to
be saved. Default is '0.1'.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_max_dur">max_dur</code></td>
<td>
<p>numeric, the maximal duration in seconds for a detection to
be saved. Default is '0.3'.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_save_extra">save_extra</code></td>
<td>
<p>numeric, how much to add to start and end time in seconds.
Can be used to make sure the whole vocalisation is included.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_env_type">env_type</code></td>
<td>
<p>character, what type of envelope to calculate. If 'Hilbert'
returns the modulus (Mod)
of the analytical signal of wave obtained through the Hilbert transform
(hilbert) using seewave::env. If 'summed' returns the summed absolute
amplitude. Default is 'Hilbert'.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_bin_depth">bin_depth</code></td>
<td>
<p>numeric, how many samples to sum if env_type is 'summed'.
Default is '512'.</p>
</td></tr>
<tr><td><code id="call.detect.multiple_+3A_merge_overlap">merge_overlap</code></td>
<td>
<p>logical, if 'TRUE' overlapping detections (due to
'save_extra') are merged. Default is 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with start = start time in samples and end =
end time in samples for each detection. Optionally also plots the wave form
and detections to current window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
cd = call.detect.multiple(wave)

</code></pre>

<hr>
<h2 id='create.spec.object'>create.spec.object</h2><span id='topic+create.spec.object'></span>

<h3>Description</h3>

<p>Creates a tailored spectrogram (matrix) for spectrographic
cross correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.spec.object(
  wave,
  wl = 512,
  ovl = 450,
  freq_range = c(0, 20000),
  plot_it = TRUE,
  thr_low = 1.5,
  thr_high = 3,
  sum_one = FALSE,
  method = "sd"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.spec.object_+3A_wave">wave</code></td>
<td>
<p>wave object, e.g., from 'load.wave' or 'readWave'.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_wl">wl</code></td>
<td>
<p>numeric, window length in samples. Default is '512'.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_ovl">ovl</code></td>
<td>
<p>numeric, overlap in samples. Default is '450'.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_freq_range">freq_range</code></td>
<td>
<p>numeric vector of length 2, the frequency range in Hz to
return.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_plot_it">plot_it</code></td>
<td>
<p>logical, if 'TRUE', returns three-panel plot of wave form,
envelope and spectrogram to current plotting window. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_thr_low">thr_low</code></td>
<td>
<p>numeric, the lower range (see 'method'). Pixels with lower
values are set to 0 for noise reduction.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_thr_high">thr_high</code></td>
<td>
<p>numeric, the upper range (see 'method'). Pixels with higher
values are set to 'thr_high'.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_sum_one">sum_one</code></td>
<td>
<p>logical, if 'TRUE' pixels are divided by the sum of all
pixels, such that they sum to one.</p>
</td></tr>
<tr><td><code id="create.spec.object_+3A_method">method</code></td>
<td>
<p>character, either 'sd' or 'max'. If 'sd', pixels are
standardised. If 'max', pixels are normalised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix with the spectrogram values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
result = create.spec.object(wave, plot_it = FALSE)

</code></pre>

<hr>
<h2 id='detect.and.assign'>detect.and.assign</h2><span id='topic+detect.and.assign'></span>

<h3>Description</h3>

<p>Traces the fundamental frequency from a wave object. Also
applies smoothening to trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.and.assign(
  all_files = NULL,
  path_chunks = NULL,
  path_calls = NULL,
  ffilter_from = 1100,
  threshold = 0.4,
  msmooth = c(1000, 95),
  min_dur = 0.1,
  max_dur = 0.3,
  step_size = 0.01,
  wing = 6,
  save_files = TRUE,
  quiet = FALSE,
  save_extra = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect.and.assign_+3A_all_files">all_files</code></td>
<td>
<p>character vector or 'NULL'. Character vector should contain
all the paths to the raw recordings that should be considered. If 'NULL'
files are loaded from 'path_chunks'.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_path_chunks">path_chunks</code></td>
<td>
<p>character, path to where the chunks are stored.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_path_calls">path_calls</code></td>
<td>
<p>character, path to where to store the results.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_ffilter_from">ffilter_from</code></td>
<td>
<p>numeric, frequency in Hz for the high-pass filter.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_threshold">threshold</code></td>
<td>
<p>numeric, threshold (fraction of the maximum) for amplitude
envelope when detecting call.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_msmooth">msmooth</code></td>
<td>
<p>used as argument for the 'seewave::env' function. *A vector
of length 2 to smooth the amplitude envelope with a mean sliding window. The
first component is the window length (in number of points). The second
component is the overlap between successive windows (in %).* Default is
'c(500, 95)'.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_min_dur">min_dur</code></td>
<td>
<p>numeric, the minimal duration in seconds for a detection to
be saved. Default is '0.1'.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_max_dur">max_dur</code></td>
<td>
<p>numeric, the maximal duration in seconds for a detection to
be saved. Default is '0.3'.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_step_size">step_size</code></td>
<td>
<p>numeric, duration in seconds of the bins for signal
compression before cross correlation. Default is '0.01'.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_wing">wing</code></td>
<td>
<p>numeric, the duration in seconds to load before and after each
detection to improve alignment. This is not saved with the aligned call.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_save_files">save_files</code></td>
<td>
<p>logical, if 'TRUE' the files are stored in the
'path_chunks' location. Results are also returned.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_quiet">quiet</code></td>
<td>
<p>logical, if 'TRUE' no messages are printed.</p>
</td></tr>
<tr><td><code id="detect.and.assign_+3A_save_extra">save_extra</code></td>
<td>
<p>numeric, how much to add to start and end time in
seconds. Can be used to make sure the whole vocalisation is included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with start = start time in samples and end =
end time in samples for each detection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/chunk@1@1@1@1.wav'
file_2 = '/chunk@2@1@1@1.wav'
url_1 = paste0(path_git, path_repo, file_1)
url_2 = paste0(path_git, path_repo, file_2)
local_file_1 = paste(tempdir(), file_1, sep = '/')
local_file_2 = paste(tempdir(), file_2, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
if(!file.exists(local_file_2))
  download.file(url_2, destfile = local_file_2, mode = 'wb')
all_files = c(local_file_1, local_file_2)
## Not run: 
result = detect.and.assign(all_files = all_files,
                           quiet = TRUE,
                           save_files = FALSE)
                           
## End(Not run)

</code></pre>

<hr>
<h2 id='export.detections'>export.detections</h2><span id='topic+export.detections'></span>

<h3>Description</h3>

<p>Exports detection table from 'call.detect' into a txt file
that can be read by Raven Lite. All columns other than those containing
start and end times are filled with 0 or &rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.detections(detections, sr = 1, path_out = "out.txt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export.detections_+3A_detections">detections</code></td>
<td>
<p>data.frame, the object generated by 'call.detect'.</p>
</td></tr>
<tr><td><code id="export.detections_+3A_sr">sr</code></td>
<td>
<p>numeric, the sampling rate of the wave on which detections were
run. Default to '1', which allows users to transform the start and end times
before feeding the data.frame to this function.</p>
</td></tr>
<tr><td><code id="export.detections_+3A_path_out">path_out</code></td>
<td>
<p>character, the path including file name where to store the
txt file. Default is ''out.txt''.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stores a Raven Lite readable selection table.
</p>

<hr>
<h2 id='load.selection.table'>load.selection.table</h2><span id='topic+load.selection.table'></span>

<h3>Description</h3>

<p>Loads single Raven selection table into a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.selection.table(path_selection_table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.selection.table_+3A_path_selection_table">path_selection_table</code></td>
<td>
<p>the path to the file containing the selection
table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data frame with all selections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/2020_10_27_091634.Table.1.selections.txt'
file_2 = '/2020_10_27_132148.Table.1.selections.txt'
url_1 = paste0(path_git, path_repo, file_1)
url_2 = paste0(path_git, path_repo, file_2)
local_file_1 = paste(tempdir(), file_1, sep = '/')
local_file_2 = paste(tempdir(), file_2, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
if(!file.exists(local_file_2))
  download.file(url_2, destfile = local_file_2, mode = 'wb')
st = load.selection.tables(path_selection_tables = tempdir())

</code></pre>

<hr>
<h2 id='load.selection.tables'>load.selection.tables</h2><span id='topic+load.selection.tables'></span>

<h3>Description</h3>

<p>Loads multiple Raven selection tables into one dataframe.
Also adds a column with file-selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.selection.tables(path_selection_tables, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.selection.tables_+3A_path_selection_tables">path_selection_tables</code></td>
<td>
<p>the path to the folder containing selection
tables. Folder should not contain any other files.</p>
</td></tr>
<tr><td><code id="load.selection.tables_+3A_recursive">recursive</code></td>
<td>
<p>if 'TRUE' lists files recursively before loading, default
is 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data frame with all selection tables.
</p>

<hr>
<h2 id='load.selection.tables.audacity'>load.selection.tables.audacity</h2><span id='topic+load.selection.tables.audacity'></span>

<h3>Description</h3>

<p>Loads multiple Audacity selection tables into one data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.selection.tables.audacity(path_selection_tables)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.selection.tables.audacity_+3A_path_selection_tables">path_selection_tables</code></td>
<td>
<p>character, the path to the folder containing selection tables. Folder should
not contain any other txt files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data frame with all selection tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/audacity/chunk_15_ground_truth.txt'
url_1 = paste0(path_git, path_repo, file_1)
local_dir = paste(tempdir(), 'audacity', sep = '/')
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!dir.exists(local_dir)) dir.create(local_dir)
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
st = load.selection.tables.audacity(path_selection_tables = local_dir)

</code></pre>

<hr>
<h2 id='load.wave'>load.wave</h2><span id='topic+load.wave'></span>

<h3>Description</h3>

<p>Wrapper function for 'readWave' from *tuneR*.
Also optionally applies 'ffilter' from *seewave*.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.wave(path_audio_file, from = 0, to = Inf, ffilter_from = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.wave_+3A_path_audio_file">path_audio_file</code></td>
<td>
<p>the path to the .wav file</p>
</td></tr>
<tr><td><code id="load.wave_+3A_from">from</code></td>
<td>
<p>time in seconds from where to start the loading of the audio file.
Default is '0' which loads the whole file.</p>
</td></tr>
<tr><td><code id="load.wave_+3A_to">to</code></td>
<td>
<p>time in seconds until where to load the audio file. Default is 'Inf' which loads the whole file.</p>
</td></tr>
<tr><td><code id="load.wave_+3A_ffilter_from">ffilter_from</code></td>
<td>
<p>numeric, frequency in Hz for the high-pass filter.
Default is 'NULL', which does not apply a filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an R wave object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = load.wave(local_file_1)

</code></pre>

<hr>
<h2 id='measure.trace'>measure.trace</h2><span id='topic+measure.trace'></span>

<h3>Description</h3>

<p>Takes several measurements on a fundamental frequency trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure.trace(trace, sr = 44100, hop = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure.trace_+3A_trace">trace</code></td>
<td>
<p>data frame, e.g., the output of the 'trace.fund' function.
Should contain columns with time = time in seconds, fund = fundamental
frequency in Hz and missing = logical indicating if the fundamental was
detected ('TRUE') or interpolated ('FALSE').</p>
</td></tr>
<tr><td><code id="measure.trace_+3A_sr">sr</code></td>
<td>
<p>sample rate of the wave object used for 'trace.fund'.</p>
</td></tr>
<tr><td><code id="measure.trace_+3A_hop">hop</code></td>
<td>
<p>the 'hop' parameter used to generate the trace.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with all measurements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
trace = trace.fund(wave)
result = measure.trace(trace)

</code></pre>

<hr>
<h2 id='measure.trace.multiple'>measure.trace.multiple</h2><span id='topic+measure.trace.multiple'></span>

<h3>Description</h3>

<p>Takes several measurements on multiple fundamental frequency
traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure.trace.multiple(
  traces,
  new_waves = NULL,
  waves = NULL,
  detections = NULL,
  sr = NULL,
  path_pdf = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure.trace.multiple_+3A_traces">traces</code></td>
<td>
<p>a list of data frames, e.g., the output of the 'trace.fund'
function. Should contain columns with time = time in seconds, fund =
fundamental frequency in Hz and missing = logical indicating if the
fundamental was detected ('TRUE') or interpolated ('FALSE'). If the list is
named the names will be used as file names in the output.</p>
</td></tr>
<tr><td><code id="measure.trace.multiple_+3A_new_waves">new_waves</code></td>
<td>
<p>a list of wave objects, should only contain the call.</p>
</td></tr>
<tr><td><code id="measure.trace.multiple_+3A_waves">waves</code></td>
<td>
<p>a list of wave objects, should not be resized.</p>
</td></tr>
<tr><td><code id="measure.trace.multiple_+3A_detections">detections</code></td>
<td>
<p>the detections.</p>
</td></tr>
<tr><td><code id="measure.trace.multiple_+3A_sr">sr</code></td>
<td>
<p>numeric, sample rate of the waves objects used for the traces.
Only needed if 'waves' is 'NULL'.</p>
</td></tr>
<tr><td><code id="measure.trace.multiple_+3A_path_pdf">path_pdf</code></td>
<td>
<p>numeric or 'NULL', where to store the pdf. If 'NULL' no pdf
is stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with all measurements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
file_2 = '/wave_2.wav'
url_1 = paste0(path_git, path_repo, file_1)
url_2 = paste0(path_git, path_repo, file_2)
local_file_1 = paste(tempdir(), file_1, sep = '/')
local_file_2 = paste(tempdir(), file_2, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
if(!file.exists(local_file_2))
  download.file(url_2, destfile = local_file_2, mode = 'wb')
all_files = c(local_file_1, local_file_2)
waves = lapply(all_files, load.wave)
new_waves = waves
detections = lapply(waves, call.detect)
traces = lapply(waves, trace.fund)
mt = measure.trace.multiple(traces = traces, waves = waves,
                            new_waves = new_waves, detections = detections)

## End(Not run)

</code></pre>

<hr>
<h2 id='o.to.m'>o.to.m</h2><span id='topic+o.to.m'></span>

<h3>Description</h3>

<p>Transforms a vector into a matrix where it assumes that the vector values are the lower
triangular of the matrix: 'm[lower.tri(m)] = o'. It includes 0 on the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>o.to.m(o, n = seq(sqrt(length(o) + 1) + 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="o.to.m_+3A_o">o</code></td>
<td>
<p>the vector containing the values for the lower triangular (required)</p>
</td></tr>
<tr><td><code id="o.to.m_+3A_n">n</code></td>
<td>
<p>the names for the rows and columns of the matrix (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix where it assumes that 'm[lower.tri(m)] = o'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = matrix(1:9, nrow = 3, ncol = 3)
o = m[lower.tri(m)]
m_new = o.to.m(o)

</code></pre>

<hr>
<h2 id='run.spcc'>run.spcc</h2><span id='topic+run.spcc'></span>

<h3>Description</h3>

<p>Runs spectrographic cross correlation on multiple wave objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.spcc(
  waves,
  freq_range = c(700, 3500),
  thr_low = 0.45,
  thr_high = 0.6,
  wl = 256,
  ovl = 250,
  method = "sd",
  sum_one = TRUE,
  mc.cores = 1,
  step_size = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.spcc_+3A_waves">waves</code></td>
<td>
<p>a list of wave objects, e.g., from 'lapply' in combination with
'load.wave' or 'readWave'.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_freq_range">freq_range</code></td>
<td>
<p>numeric vector of length 2, the frequency range in Hz to
return.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_thr_low">thr_low</code></td>
<td>
<p>numeric, the lower range (see 'method'). Pixels with lower
values are set to 0 for noise
reduction.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_thr_high">thr_high</code></td>
<td>
<p>numeric, the upper range (see 'method'). Pixels with higher
values are set to 'thr_high'.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_wl">wl</code></td>
<td>
<p>numeric, window length in samples. Default is '512'.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_ovl">ovl</code></td>
<td>
<p>numeric, overlap in samples. Default is '450'.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_method">method</code></td>
<td>
<p>character, either 'sd' or 'max'. If 'sd', pixels are
standardised. If 'max', pixels are
normalised.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_sum_one">sum_one</code></td>
<td>
<p>logical, if 'TRUE' pixels are divided by the sum of all
pixels, such that they sum to one.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_mc.cores">mc.cores</code></td>
<td>
<p>numeric, how many threads to run in parallel. For Windows
only one can be used.</p>
</td></tr>
<tr><td><code id="run.spcc_+3A_step_size">step_size</code></td>
<td>
<p>numeric, argument for 'sliding.pixel.comparison' how many
pixels should be moved for each
step. Default is '10'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with row and columns names equal to the names of the wave
list. Diagonal is zeroes. Other values are the normalised pairwise
distances from 'sliding.pixel.comparison'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
file_2 = '/wave_2.wav'
url_1 = paste0(path_git, path_repo, file_1)
url_2 = paste0(path_git, path_repo, file_2)
local_file_1 = paste(tempdir(), file_1, sep = '/')
local_file_2 = paste(tempdir(), file_2, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
if(!file.exists(local_file_2))
  download.file(url_2, destfile = local_file_2, mode = 'wb')
all_files = c(local_file_1, local_file_2)
waves = lapply(all_files, load.wave)
spcc_out = run.spcc(waves)

</code></pre>

<hr>
<h2 id='simple.cc'>simple.cc</h2><span id='topic+simple.cc'></span>

<h3>Description</h3>

<p>Simple cross correlation of two vectors. Uses zero embedding
to find optimal overlap. Also has an option to normalise by the longest
vector (divides final difference by length). This version returns the time
difference for best overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple.cc(s1, s2, norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simple.cc_+3A_s1">s1</code></td>
<td>
<p>the first numeric vector (required)</p>
</td></tr>
<tr><td><code id="simple.cc_+3A_s2">s2</code></td>
<td>
<p>the second numeric vector (required)</p>
</td></tr>
<tr><td><code id="simple.cc_+3A_norm">norm</code></td>
<td>
<p>if 'TRUE' the final difference is divided by the length of the
longest vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an integer, which is the start of s1 relative to s2.
E.g., -1 means that s1 has to be moved one step back to be aligned with s2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 = c(0, 0, 0, 1, 1, 2, 0)
s2 = c(0, 0, 2, 2, 3, 0, 0, 0, 0)
offset = simple.cc(s1, s2) # -1
index_s1 = seq(1, length(s1)) + offset # align
plot(s2, type = 'b')
points(index_s1, s1, col = 2, type = 'b')

</code></pre>

<hr>
<h2 id='sliding.pixel.comparison'>sliding.pixel.comparison</h2><span id='topic+sliding.pixel.comparison'></span>

<h3>Description</h3>

<p>Can be used to run spectrographic cross correlation. Both
spectrograms are zero-padded and slid over each other. For each step the
difference is computed. The function returns the absolute difference at the
point at the minimum (maximal signal overlap).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliding.pixel.comparison(s1, s2, step_size = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sliding.pixel.comparison_+3A_s1">s1</code></td>
<td>
<p>numeric matrix, the first spectrogram.</p>
</td></tr>
<tr><td><code id="sliding.pixel.comparison_+3A_s2">s2</code></td>
<td>
<p>numeric matrix, the second spectrogram.</p>
</td></tr>
<tr><td><code id="sliding.pixel.comparison_+3A_step_size">step_size</code></td>
<td>
<p>numeric, how many pixels should be moved for each step.
Default is '1'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the distance at the point of maximal signal overlap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
file_2 = '/wave_2.wav'
url_1 = paste0(path_git, path_repo, file_1)
url_2 = paste0(path_git, path_repo, file_2)
local_file_1 = paste(tempdir(), file_1, sep = '/')
local_file_2 = paste(tempdir(), file_2, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
if(!file.exists(local_file_2))
  download.file(url_2, destfile = local_file_2, mode = 'wb')
wave_1 = readWave(local_file_1)
wave_2 = readWave(local_file_2)
so_1 = create.spec.object(wave = wave_1, plot_it = FALSE)
so_2 = create.spec.object(wave = wave_2, plot_it = FALSE)
out = sliding.pixel.comparison(so_1, so_2)

</code></pre>

<hr>
<h2 id='trace.fund'>trace.fund</h2><span id='topic+trace.fund'></span>

<h3>Description</h3>

<p>Traces the fundamental frequency from a wave object. Also
applies smoothening to trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace.fund(
  wave,
  hop = 5,
  wl = 200,
  freq_lim = c(1.1, 4),
  spar = 0.4,
  noise_factor = 3.5,
  thr = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace.fund_+3A_wave">wave</code></td>
<td>
<p>wave object, e.g., from 'load.wave' or 'readWave'.</p>
</td></tr>
<tr><td><code id="trace.fund_+3A_hop">hop</code></td>
<td>
<p>integer, how many samples to skip for each trace point.</p>
</td></tr>
<tr><td><code id="trace.fund_+3A_wl">wl</code></td>
<td>
<p>integer, window length for the spectrum</p>
</td></tr>
<tr><td><code id="trace.fund_+3A_freq_lim">freq_lim</code></td>
<td>
<p>numeric vector of length 2, frequency in kHz between which
to find the fundamental</p>
</td></tr>
<tr><td><code id="trace.fund_+3A_spar">spar</code></td>
<td>
<p>numeric between 0-1, for the 'smooth.spline' function</p>
</td></tr>
<tr><td><code id="trace.fund_+3A_noise_factor">noise_factor</code></td>
<td>
<p>numeric, how much louder the fundamental has to be
than the noise to be accepted</p>
</td></tr>
<tr><td><code id="trace.fund_+3A_thr">thr</code></td>
<td>
<p>numeric between 0-1, the fraction of the maximum of the spectrum
used to detect the fundamental</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tracing step is based on a sliding window for which the spectrum
is calculated. A threshold is based on the maximum y value and the first
frequency to cross the threshold is considered the fundamental frequency.
If the average hight before the fundamental is higher than 'noise_factor',
the detection is discarded and NA is returned for that window.
Smoothing step is based on 'smooth.spline'. Finally, all points outside
'freq_lim' are reset to these limits.
</p>


<h3>Value</h3>

<p>Data frame with time = time in seconds, fund = fundamental
frequency in Hz and missing = logical indicating if the fundamental was
detected ('TRUE') or interpolated ('FALSE').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(callsync)
require(seewave)
require(tuneR)
path_git = 'https://raw.githubusercontent.com'
path_repo = '/simeonqs/callsync/master/tests/testthat/files'
file_1 = '/wave_1.wav'
url_1 = paste0(path_git, path_repo, file_1)
local_file_1 = paste(tempdir(), file_1, sep = '/')
if(!file.exists(local_file_1))
  download.file(url_1, destfile = local_file_1, mode = 'wb',)
wave = readWave(local_file_1)
trace = trace.fund(wave)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
