<!DOCTYPE html><html><head><title>Help for package JointAI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JointAI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_linebreaks'><p>Add line breaks to a linear predictor string</p></a></li>
<li><a href='#add_samples'><p>Continue sampling from an object of class JointAI</p></a></li>
<li><a href='#all_vars'><p>Extract names of variables from a (list of) formula(s)</p></a></li>
<li><a href='#bs'><p>B-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#check_formula_list'><p>Check/convert formula to list</p></a></li>
<li><a href='#check_full_blockdiag'><p>Replace a full with a block-diagonal variance covariance matrix</p>
Check if a full random effects variance covariance matrix is specified
for a single variable. In that case, it is identical to a block-diagonal
matrix. Change the <code>rd_vcov</code> specification to <code>blockdiag</code> for clarity
(because then the variable name is used in the name of <code>b</code>, <code>D</code>, <code>invD</code>, ...)</a></li>
<li><a href='#check_rd_vcov'><p>Check / create the random effects variance-covariance matrix specification</p></a></li>
<li><a href='#check_rd_vcov_list'><p>First validation for rd_vcov</p></a></li>
<li><a href='#clean_survname'><p>Convert a survival outcome to a model name</p></a></li>
<li><a href='#combine_formula_lists'><p>Combine fixed and random effects formulas</p></a></li>
<li><a href='#combine_formulas'><p>Combine a fixed and random effects formula</p></a></li>
<li><a href='#default_hyperpars'><p>Get the default values for hyper-parameters</p></a></li>
<li><a href='#densplot'><p>Plot the posterior density from object of class JointAI</p></a></li>
<li><a href='#difftime_df'><p>Converts a <code>difftime</code> object to a <code>data.frame</code></p></a></li>
<li><a href='#duration_obj'><p>Create a duration object</p></a></li>
<li><a href='#expand_rd_vcov_full'><p>Expand rd_vcov using variable names in case &quot;full&quot; is used</p></a></li>
<li><a href='#extract_id'><p>Extract all id variables from a list of random effects formulas</p></a></li>
<li><a href='#extract_lhs'><p>Extract the left hand side of a formula</p></a></li>
<li><a href='#extract_state'><p>Return the current state of a 'JointAI' model</p></a></li>
<li><a href='#get_family'><p>Identify the family from the covariate model type</p></a></li>
<li><a href='#get_MIdat'><p>Extract multiple imputed datasets from an object of class JointAI</p></a></li>
<li><a href='#get_missinfo'><p>Obtain a summary of the missing values involved in an object of class JointAI</p></a></li>
<li><a href='#get_Mlist'><p>Re-create the full <code>Mlist</code> from a &quot;JointAI&quot; object</p></a></li>
<li><a href='#get_modeltype'><p>Identify the general model type from the covariate model type</p></a></li>
<li><a href='#get_nranef'><p>Extract the number of random effects</p></a></li>
<li><a href='#get_resp_mat'><p>Identify the data matrix containing a given response variable</p></a></li>
<li><a href='#GR_crit'><p>Gelman-Rubin criterion for convergence</p></a></li>
<li><a href='#hc_rdslope_info'><p>Get info on the main effects in a random slope structure</p>
for a given level and sub-model</a></li>
<li><a href='#hc_rdslope_interact'><p>Get info on the interactions with random slopes for a given level and sub-model</p></a></li>
<li><a href='#JointAI'><p>JointAI: Joint Analysis and Imputation of Incomplete Data</p></a></li>
<li><a href='#JointAIObject'><p>Fitted object of class 'JointAI'</p></a></li>
<li><a href='#list_models'><p>List model details</p></a></li>
<li><a href='#longDF'><p>Longitudinal example dataset</p></a></li>
<li><a href='#MC_error'><p>Calculate and plot the Monte Carlo error</p></a></li>
<li><a href='#md_pattern'><p>Missing data pattern</p></a></li>
<li><a href='#model_imp'><p>Joint Analysis and Imputation of incomplete data</p></a></li>
<li><a href='#NHANES'><p>National Health and Nutrition Examination Survey (NHANES) Data</p></a></li>
<li><a href='#ns'><p>Generate a Basis Matrix for Natural Cubic Splines</p></a></li>
<li><a href='#parameters'><p>Parameter names of an JointAI object</p></a></li>
<li><a href='#paste_coef'><p>Write the coefficient part of a linear predictor</p></a></li>
<li><a href='#paste_data'><p>Write the data element of a linear predictor</p></a></li>
<li><a href='#paste_linpred'><p>Write a linear predictor</p></a></li>
<li><a href='#paste_scale'><p>Create the scaling in a data element of a linear predictor</p></a></li>
<li><a href='#paste_scaling'><p>Wrap a data element of a linear predictor in scaling syntax</p></a></li>
<li><a href='#PBC'><p>PBC data</p></a></li>
<li><a href='#plot_all'><p>Visualize the distribution of all variables in the dataset</p></a></li>
<li><a href='#plot_imp_distr'><p>Plot the distribution of observed and imputed values</p></a></li>
<li><a href='#plot.JointAI'><p>Plot an object object inheriting from class 'JointAI'</p></a></li>
<li><a href='#predDF'><p>Create a new data frame for prediction</p></a></li>
<li><a href='#predict.JointAI'><p>Predict values from an object of class JointAI</p></a></li>
<li><a href='#print.Dmat'><p>Summarize the results from an object of class JointAI</p></a></li>
<li><a href='#rd_vcov'><p>Extract the random effects variance covariance matrix</p>
Returns the posterior mean of the variance-covariance matrix/matrices of
the random effects in a fitted JointAI object.</a></li>
<li><a href='#reformat_difftime'><p>Set all elements of a <code>difftime</code> object to the same, largest meaningful unit</p></a></li>
<li><a href='#remove_lhs'><p>Remove the left hand side of a (list of) formula(s)</p></a></li>
<li><a href='#residuals.JointAI'><p>Extract residuals from an object of class JointAI</p></a></li>
<li><a href='#set_refcat'><p>Specify reference categories for all categorical covariates in the model</p></a></li>
<li><a href='#sharedParams'><p>Parameters used by several functions in JointAI</p></a></li>
<li><a href='#simLong'><p>Simulated Longitudinal Data in Long and Wide Format</p></a></li>
<li><a href='#split_formula'><p>Split a formula into fixed and random effects parts</p></a></li>
<li><a href='#split_formula_list'><p>Split a list of formulas into fixed and random effects parts.</p></a></li>
<li><a href='#sum_duration'><p>Calculate the sum of the computational duration of a JointAI object</p></a></li>
<li><a href='#Surv'><p>Create a Survival Object</p></a></li>
<li><a href='#traceplot'><p>Create traceplots for a MCMC sample</p></a></li>
<li><a href='#wideDF'><p>Cross-sectional example dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Joint Analysis and Imputation of Incomplete Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Joint analysis and imputation of incomplete data in the Bayesian
    framework, using (generalized) linear (mixed) models and extensions there of,
    survival models, or joint models for longitudinal and survival data, as
    described in Erler, Rizopoulos and Lesaffre (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i20">doi:10.18637/jss.v100.i20</a>&gt;.
    Incomplete covariates, if present, are automatically imputed.
    The package performs some preprocessing of the data and creates a 'JAGS'
    model, which will then automatically be passed to 'JAGS' 
    <a href="https://mcmc-jags.sourceforge.io/">https://mcmc-jags.sourceforge.io/</a> with the help of 
    the package 'rjags'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nerler.github.io/JointAI/">https://nerler.github.io/JointAI/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nerler/JointAI/issues/">https://github.com/nerler/JointAI/issues/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>rjags, mcmcse, coda, rlang, future, mathjaxr, survival, MASS</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (https://mcmc-jags.sourceforge.io/)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown, foreign, ggplot2, ggpubr,
testthat, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-27 08:19:18 UTC; erler</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicole S. Erler <a href="https://orcid.org/0000-0002-9370-6832"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicole S. Erler &lt;n.erler@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-27 09:22:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_linebreaks'>Add line breaks to a linear predictor string</h2><span id='topic+add_linebreaks'></span>

<h3>Description</h3>

<p>Adds line breaks to a string, breaking it after a &quot;+&quot; sign to not exceed a
given width of characters and taking into account indentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_linebreaks(string, indent, width = 90L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_linebreaks_+3A_string">string</code></td>
<td>
<p>a character string (linear predictor)</p>
</td></tr>
<tr><td><code id="add_linebreaks_+3A_indent">indent</code></td>
<td>
<p>integer; number of characters the new line should be indented</p>
</td></tr>
<tr><td><code id="add_linebreaks_+3A_width">width</code></td>
<td>
<p>integer; the maximum number of characters per line</p>
</td></tr>
</table>

<hr>
<h2 id='add_samples'>Continue sampling from an object of class JointAI</h2><span id='topic+add_samples'></span>

<h3>Description</h3>

<p>This function continues the sampling from the MCMC chains of an existing
object of class 'JointAI'.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_samples(object, n.iter, add = TRUE, thin = NULL,
  monitor_params = NULL, progress.bar = "text", mess = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_samples_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="add_samples_+3A_n.iter">n.iter</code></td>
<td>
<p>the number of additional iterations of the MCMC chain</p>
</td></tr>
<tr><td><code id="add_samples_+3A_add">add</code></td>
<td>
<p>logical; should the new MCMC samples be added to the existing
samples (<code>TRUE</code>; default) or replace them?
If samples are added the arguments <code>monitor_params</code> and
<code>thin</code> are ignored.</p>
</td></tr>
<tr><td><code id="add_samples_+3A_thin">thin</code></td>
<td>
<p>thinning interval (see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>);
ignored when <code>add = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_samples_+3A_monitor_params">monitor_params</code></td>
<td>
<p>named list or vector specifying which parameters should
be monitored. For details, see
<code><a href="#topic+model_imp">*_imp</a></code> and the vignette
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>.
Ignored when <code>add = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_samples_+3A_progress.bar">progress.bar</code></td>
<td>
<p>character string specifying the type of
progress bar. Possible values are &quot;text&quot; (default), &quot;gui&quot;,
and &quot;none&quot; (see <code><a href="rjags.html#topic+update">update</a></code>). Note: when
sampling is performed in parallel it is not possible to
display a progress bar.</p>
</td></tr>
<tr><td><code id="add_samples_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+model_imp">*_imp</a></code>
</p>
<p>The vignette
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>
contains some examples on how to specify the argument <code>monitor_params</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1:
# Run an initial JointAI model:
mod &lt;- lm_imp(y ~ C1 + C2, data = wideDF, n.iter = 100)

# Continue sampling:
mod_add &lt;- add_samples(mod, n.iter = 200, add = TRUE)


# Example 2:
# Continue sampling, but additionally sample imputed values.
# Note: Setting different parameters to monitor than in the original model
# requires add = FALSE.
imps &lt;- add_samples(mod, n.iter = 200, monitor_params = c("imps" = TRUE),
                    add = FALSE)

</code></pre>

<hr>
<h2 id='all_vars'>Extract names of variables from a (list of) formula(s)</h2><span id='topic+all_vars'></span>

<h3>Description</h3>

<p>Version of <code>all.vars()</code> that can handle lists of formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_vars(fmla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_vars_+3A_fmla">fmla</code></td>
<td>
<p>a formula or list of formulas</p>
</td></tr>
</table>

<hr>
<h2 id='bs'>B-Spline Basis for Polynomial Splines</h2><span id='topic+bs'></span>

<h3>Description</h3>

<p>This function just calls <code>bs()</code> from the
<a href="https://CRAN.R-project.org/package=splines"><strong>splines</strong></a>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bs(x, df = NULL, knots = NULL, degree = 3, intercept = FALSE,
  Boundary.knots = range(x), warn.outside = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bs_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="bs_+3A_df">df</code></td>
<td>
<p>degrees of freedom; one can specify <code>df</code> rather than
<code>knots</code>; <code>bs()</code> then chooses <code>df-degree</code> (minus one
if there is an intercept) knots at suitable quantiles of <code>x</code>
(which will ignore missing values).  The default, <code>NULL</code>,
takes the number of inner knots as <code>length(knots)</code>.  If that is
zero as per default, that corresponds to <code>df = degree - intercept</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_knots">knots</code></td>
<td>
<p>the <em>internal</em> breakpoints that define the
spline.  The default is <code>NULL</code>, which results in a basis for
ordinary polynomial regression.  Typical values are the mean or
median for one knot, quantiles for more knots.  See also
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial&mdash;default is <code>3</code> for
cubic splines.</p>
</td></tr>
<tr><td><code id="bs_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the
basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to anchor the B-spline
basis (default the range of the non-<code><a href="base.html#topic+NA">NA</a></code> data).  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>.  Data can extend beyond
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_warn.outside">warn.outside</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if a
<code><a href="base.html#topic+warning">warning</a></code> should be signalled in case some <code>x</code> values
are outside the boundary knots.</p>
</td></tr>
</table>

<hr>
<h2 id='check_formula_list'>Check/convert formula to list</h2><span id='topic+check_formula_list'></span>

<h3>Description</h3>

<p>Check if an object is a list of formulas and/or NULL elements and convert
it to a list if it is a formula object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_formula_list(formula, convert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_formula_list_+3A_formula">formula</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="check_formula_list_+3A_convert">convert</code></td>
<td>
<p>logical; should the input be converted to a list?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function; used in many help functions, get_refs, *_imp, predict
(2022-02-05)
</p>

<hr>
<h2 id='check_full_blockdiag'>Replace a full with a block-diagonal variance covariance matrix
Check if a full random effects variance covariance matrix is specified
for a single variable. In that case, it is identical to a block-diagonal
matrix. Change the <code>rd_vcov</code> specification to <code>blockdiag</code> for clarity
(because then the variable name is used in the name of <code>b</code>, <code>D</code>, <code>invD</code>, ...)</h2><span id='topic+check_full_blockdiag'></span>

<h3>Description</h3>

<p>Replace a full with a block-diagonal variance covariance matrix
Check if a full random effects variance covariance matrix is specified
for a single variable. In that case, it is identical to a block-diagonal
matrix. Change the <code>rd_vcov</code> specification to <code>blockdiag</code> for clarity
(because then the variable name is used in the name of <code>b</code>, <code>D</code>, <code>invD</code>, ...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_full_blockdiag(rd_vcov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_full_blockdiag_+3A_rd_vcov">rd_vcov</code></td>
<td>
<p>a valid random effects variance-covariance structure
specification (i.e., checked using <code>expand_rd_vcov_full()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a valid random effects variance-covariance structure specification
</p>

<hr>
<h2 id='check_rd_vcov'>Check / create the random effects variance-covariance matrix specification</h2><span id='topic+check_rd_vcov'></span>

<h3>Description</h3>

<p>Check / create the random effects variance-covariance matrix specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_rd_vcov(rd_vcov, nranef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_rd_vcov_+3A_rd_vcov">rd_vcov</code></td>
<td>
<p>variance covariance specification provided by the user</p>
</td></tr>
<tr><td><code id="check_rd_vcov_+3A_nranef">nranef</code></td>
<td>
<p>list by level with named vectors of number of random effects
per variable (obtained by <code>get_nranef()</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='check_rd_vcov_list'>First validation for rd_vcov</h2><span id='topic+check_rd_vcov_list'></span>

<h3>Description</h3>

<p>Checks if <code>rd_vcov</code> is a <code>list</code> with elements for all grouping levels or does
not specify a grouping level.
If valid, this function also make sure that <code>rd_vcov</code> is a list per grouping
level by duplicating the contents if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_rd_vcov_list(rd_vcov, idvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_rd_vcov_list_+3A_rd_vcov">rd_vcov</code></td>
<td>
<p>a character string or a list describing the the random effects
variance covariance structure (provided by the user)</p>
</td></tr>
<tr><td><code id="check_rd_vcov_list_+3A_idvar">idvar</code></td>
<td>
<p>vector with the names of all grouping variables
(except &quot;lvlone&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list per grouping level where each elements contains
information on how the random effects variance-covariance matrices on
that level are structured.
Per level it can be either a character string (e.g. <code>"full"</code>) or a
list specifying structures per (groups) of
variable(s) (e.g. <code>list(full = c("a", "b"), indep = "c")</code>)
</p>

<hr>
<h2 id='clean_survname'>Convert a survival outcome to a model name</h2><span id='topic+clean_survname'></span>

<h3>Description</h3>

<p>A helper function that converts the &quot;name of a survival model&quot;
(the <code>"Surv(time, status)"</code> specification) into a valid variable name
so that it can be used in the JAGS model syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_survname(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_survname_+3A_x">x</code></td>
<td>
<p>a character string or vector of character strings</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>clean_survname("Surv(eventtime, event != 'censored')")

</code></pre>

<hr>
<h2 id='combine_formula_lists'>Combine fixed and random effects formulas</h2><span id='topic+combine_formula_lists'></span>

<h3>Description</h3>

<p>A function to combine nlme-style fixed and random effects formulas into
lme4 style formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_formula_lists(fixed, random, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_formula_lists_+3A_fixed">fixed</code></td>
<td>
<p>a fixed effects formula or list of such formulas</p>
</td></tr>
<tr><td><code id="combine_formula_lists_+3A_random">random</code></td>
<td>
<p>a random effects formula (only RHS) or list of such formulas</p>
</td></tr>
<tr><td><code id="combine_formula_lists_+3A_warn">warn</code></td>
<td>
<p>logical; should the warning(s) be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function.
Lists of formulas can be named or unnamed.
Uses <code>combine_formulas()</code>.
</p>

<hr>
<h2 id='combine_formulas'>Combine a fixed and random effects formula</h2><span id='topic+combine_formulas'></span>

<h3>Description</h3>

<p>Combine a single fixed and random effects formula by pasting them together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_formulas(fixed, random)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_formulas_+3A_fixed">fixed</code></td>
<td>
<p>fixed effects formula (two-sided <code>formula</code> object)</p>
</td></tr>
<tr><td><code id="combine_formulas_+3A_random">random</code></td>
<td>
<p>random effects formula (one-sided <code>formula</code> object)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function, used in <code>combine_formula_lists()</code>.
</p>

<hr>
<h2 id='default_hyperpars'>Get the default values for hyper-parameters</h2><span id='topic+default_hyperpars'></span>

<h3>Description</h3>

<p>This function returns a list of default values for the hyper-parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_hyperpars()
</code></pre>


<h3>Details</h3>

<p><strong>norm:</strong> hyper-parameters for normal and log-normal models
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_norm</code> </td><td style="text-align: left;"> mean in the priors for regression coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_norm</code> </td><td style="text-align: left;"> precision in the priors for regression
coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>shape_tau_norm</code> </td><td style="text-align: left;"> shape parameter in Gamma prior for the precision
of the (log-)normal distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rate_tau_norm</code> </td><td style="text-align: left;"> rate parameter in Gamma prior for the precision
of the (log-)normal distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><strong>gamma:</strong> hyper-parameters for Gamma models
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_gamma</code> </td><td style="text-align: left;"> mean in the priors for regression coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_gamma</code> </td><td style="text-align: left;"> precision in the priors for regression
coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>shape_tau_gamma</code> </td><td style="text-align: left;"> shape parameter in Gamma prior for the precision
of the Gamma distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rate_tau_gamma</code> </td><td style="text-align: left;"> rate parameter in Gamma prior for the precision
of the Gamma distribution
</td>
</tr>

</table>

<p><strong>beta:</strong> hyper-parameters for beta models
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_beta</code> </td><td style="text-align: left;"> mean in the priors for regression coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_beta</code> </td><td style="text-align: left;"> precision in the priors for regression
coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>shape_tau_beta</code> </td><td style="text-align: left;"> shape parameter in Gamma prior for the precision
of the beta distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rate_tau_beta</code> </td><td style="text-align: left;"> rate parameter in Gamma prior for precision of the
of the beta distribution
</td>
</tr>

</table>

<p><strong>binom:</strong> hyper-parameters for binomial models
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_binom</code> </td><td style="text-align: left;"> mean in the priors for regression coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_binom</code> </td><td style="text-align: left;"> precision in the priors for regression coefficients
</td>
</tr>

</table>

<p><strong>poisson:</strong> hyper-parameters for poisson models
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_poisson</code> </td><td style="text-align: left;"> mean in the priors for regression coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_poisson</code> </td><td style="text-align: left;"> precision in the priors for regression
coefficients
</td>
</tr>

</table>

<p><strong>multinomial:</strong> hyper-parameters for multinomial models
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_multinomial</code> </td><td style="text-align: left;"> mean in the priors for regression
coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_multinomial</code> </td><td style="text-align: left;"> precision in the priors for regression
coefficients
</td>
</tr>

</table>

<p><strong>ordinal:</strong> hyper-parameters for ordinal models
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_ordinal</code> </td><td style="text-align: left;"> mean in the priors for regression coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_ordinal</code> </td><td style="text-align: left;"> precision in the priors for regression
coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mu_delta_ordinal</code> </td><td style="text-align: left;"> mean in the prior for the intercepts</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_delta_ordinal</code> </td><td style="text-align: left;"> precision in the priors for the intercepts
</td>
</tr>

</table>

<p><strong>ranef:</strong> hyper-parameters for the random effects variance-covariance
matrices (when there is only one random effect a Gamma distribution is used
instead of the Wishart distribution)
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>shape_diag_RinvD</code> </td><td style="text-align: left;"> shape parameter in Gamma prior for the diagonal
elements of <code>RinvD</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rate_diag_RinvD</code> </td><td style="text-align: left;"> rate parameter in Gamma prior for the diagonal
elements of <code>RinvD</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>KinvD_expr</code> </td><td style="text-align: left;"> a character string that can be evaluated to calculate
the number of degrees of freedom in the Wishart
distribution used for the inverse of the
variance-covariance matrix for random effects,
depending on the number of random effects
<code>nranef</code>
</td>
</tr>

</table>

<p><strong>surv:</strong> parameters for survival models (<code>survreg</code>, <code>coxph</code>
and <code>JM</code>)
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mu_reg_surv</code> </td><td style="text-align: left;"> mean in the priors for regression coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_reg_surv</code> </td><td style="text-align: left;"> precision in the priors for regression coefficients
</td>
</tr>

</table>



<h3>Note</h3>

<p><strong>From the
<a href="https://sourceforge.net/projects/mcmc-jags/files/Manuals/">JAGS user
manual</a>
on the specification of the Wishart distribution:</strong><br />
For <code>KinvD</code> larger than the dimension of the variance-covariance matrix
the prior on the correlation between the random effects is concentrated
around 0, so that larger values of <code>KinvD</code> indicate stronger prior
belief that the elements of the multivariate normal distribution are
independent.
For <code>KinvD</code> equal to the number of random effects the Wishart prior
puts most weight on the extreme values (correlation 1 or -1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default_hyperpars()

# To change the hyper-parameters:
hyp &lt;- default_hyperpars()
hyp$norm['rate_tau_norm'] &lt;- 1e-3
mod &lt;- lm_imp(y ~ C1 + C2 + B1, data = wideDF, hyperpars = hyp, mess = FALSE)


</code></pre>

<hr>
<h2 id='densplot'>Plot the posterior density from object of class JointAI</h2><span id='topic+densplot'></span><span id='topic+densplot.JointAI'></span>

<h3>Description</h3>

<p>The function plots a set of densities (per chain and coefficient) from
the MCMC sample of an object of class &quot;JointAI&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densplot(object, ...)

## S3 method for class 'JointAI'
densplot(object, start = NULL, end = NULL, thin = NULL,
  subset = c(analysis_main = TRUE), outcome = NULL,
  exclude_chains = NULL, vlines = NULL, nrow = NULL, ncol = NULL,
  joined = FALSE, use_ggplot = FALSE, warn = TRUE, mess = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densplot_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="densplot_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>plot()</code></p>
</td></tr>
<tr><td><code id="densplot_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="densplot_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="densplot_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="densplot_+3A_subset">subset</code></td>
<td>
<p>subset of parameters/variables/nodes (columns in the MCMC
sample). Follows the same principle as the argument
<code>monitor_params</code> in
<code><a href="#topic+model_imp">*_imp</a></code>.</p>
</td></tr>
<tr><td><code id="densplot_+3A_outcome">outcome</code></td>
<td>
<p>optional; vector identifying a subset of sub-models included
in the output, either by specifying their indices (using the
order used in the list of model formulas), or their
names (LHS of the respective model formula as character
string)</p>
</td></tr>
<tr><td><code id="densplot_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="densplot_+3A_vlines">vlines</code></td>
<td>
<p>list, where each element is a named list of parameters that
can be passed to <code>graphics::abline()</code> to create
vertical lines.
Each of the list elements needs to contain at least
<code>v = &lt;x location&gt;</code> where <code>&lt;x location&gt;</code> is a vector of the
same length as the number of plots (see examples).</p>
</td></tr>
<tr><td><code id="densplot_+3A_nrow">nrow</code></td>
<td>
<p>optional; number of rows in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="densplot_+3A_ncol">ncol</code></td>
<td>
<p>optional; number of columns in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="densplot_+3A_joined">joined</code></td>
<td>
<p>logical; should the chains be combined before plotting?</p>
</td></tr>
<tr><td><code id="densplot_+3A_use_ggplot">use_ggplot</code></td>
<td>
<p>logical; Should ggplot be used instead of the base
graphics?</p>
</td></tr>
<tr><td><code id="densplot_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="densplot_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The vignette
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>
contains some examples how to specify the argument <code>subset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# fit a JointAI object:
mod &lt;- lm_imp(y ~ C1 + C2 + M1, data = wideDF, n.iter = 100)

# Example 1: basic densityplot
densplot(mod)
densplot(mod, exclude_chains = 2)


# Example 2: use vlines to mark zero
densplot(mod, col = c("darkred", "darkblue", "darkgreen"),
         vlines = list(list(v = rep(0, nrow(summary(mod)$res$y$regcoef)),
                            col = grey(0.8))))


# Example 3: use vlines to visualize posterior mean and 2.5%/97.5% quantiles
res &lt;- rbind(summary(mod)$res$y$regcoef[, c('Mean', '2.5%', '97.5%')],
             summary(mod)$res$y$sigma[, c('Mean', '2.5%', '97.5%'),
             drop = FALSE]
             )
densplot(mod, vlines = list(list(v = res[, "Mean"], lty = 1, lwd = 2),
                            list(v = res[, "2.5%"], lty = 2),
                            list(v = res[, "97.5%"], lty = 2)))


# Example 4: ggplot version
densplot(mod, use_ggplot = TRUE)


# Example 5: change how the ggplot version looks
library(ggplot2)

densplot(mod, use_ggplot = TRUE) +
  xlab("value") +
  theme(legend.position = 'bottom') +
  scale_color_brewer(palette = 'Dark2', name = 'chain')

## End(Not run)

</code></pre>

<hr>
<h2 id='difftime_df'>Converts a <code>difftime</code> object to a <code>data.frame</code></h2><span id='topic+difftime_df'></span>

<h3>Description</h3>

<p>Converts a <code>difftime</code> object to a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difftime_df(dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difftime_df_+3A_dt">dt</code></td>
<td>
<p><code>difftime</code> object (vector of <code>difftime</code> objects)</p>
</td></tr>
</table>

<hr>
<h2 id='duration_obj'>Create a duration object</h2><span id='topic+duration_obj'></span>

<h3>Description</h3>

<p>Add row names to the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duration_obj(dur)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_obj_+3A_dur">dur</code></td>
<td>
<p>list of <code>difftime</code> objects</p>
</td></tr>
</table>

<hr>
<h2 id='expand_rd_vcov_full'>Expand rd_vcov using variable names in case &quot;full&quot; is used</h2><span id='topic+expand_rd_vcov_full'></span>

<h3>Description</h3>

<p>Expand rd_vcov using variable names in case &quot;full&quot; is used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_rd_vcov_full(rd_vcov, rd_outnam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_rd_vcov_full_+3A_rd_vcov">rd_vcov</code></td>
<td>
<p>the random effects variance covariance structure provided by
the user (<code>check_rd_vcov_list()</code> is called internally)</p>
</td></tr>
<tr><td><code id="expand_rd_vcov_full_+3A_rd_outnam">rd_outnam</code></td>
<td>
<p>list by grouping level of the names of the outcome variables
that have random effects on this level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list per grouping level where each elements contains
information on how the random effects variance-covariance matrices on
that level are structured. Per level there is a list of grouping
structures containing the names of variables in each structure
(e.g. <code>list(full = c("a", "b"), indep = "c")</code>)
</p>

<hr>
<h2 id='extract_id'>Extract all id variables from a list of random effects formulas</h2><span id='topic+extract_id'></span>

<h3>Description</h3>

<p>Internal function, used in <code>divide_matrices()</code>, <code>get_models()</code>,
various help functions, <code>predict()</code> (2022-02-06)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_id(random, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_id_+3A_random">random</code></td>
<td>
<p>a one-sided random effects formula or a list of such formulas</p>
</td></tr>
<tr><td><code id="extract_id_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be printed?</p>
</td></tr>
</table>

<hr>
<h2 id='extract_lhs'>Extract the left hand side of a formula</h2><span id='topic+extract_lhs'></span>

<h3>Description</h3>

<p>Extracts the left hand side from a <code>formula</code> object and returns it as
character string.
Relevant, for example, for survival formulas, where <code>Surv(...)</code> is a
<code>call</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_lhs(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_lhs_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> object (NOT a <code>list</code> of formulas)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal; used in various help functions (2022-02-05)
</p>


<h3>Value</h3>

<p>A character string.
</p>

<hr>
<h2 id='extract_state'>Return the current state of a 'JointAI' model</h2><span id='topic+extract_state'></span>

<h3>Description</h3>

<p>Return the current state of a 'JointAI' model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_state(object, pattern = paste0("^", c("RinvD", "invD", "tau", "b"),
  "_"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_state_+3A_object">object</code></td>
<td>
<p>an object of class 'JointAI'</p>
</td></tr>
<tr><td><code id="extract_state_+3A_pattern">pattern</code></td>
<td>
<p>vector of patterns to be matched with the names of the nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one element per chain of the MCMC sampler, containing the
Returns the current state of the MCMC sampler (values of the last
iteration) for the subset of nodes identified based on the pattern
the user has specified.
</p>

<hr>
<h2 id='get_family'>Identify the family from the covariate model type</h2><span id='topic+get_family'></span>

<h3>Description</h3>

<p>Identify the family from the covariate model type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_family(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_family_+3A_model">model</code></td>
<td>
<p>character string; the covariate model type</p>
</td></tr>
</table>

<hr>
<h2 id='get_MIdat'>Extract multiple imputed datasets from an object of class JointAI</h2><span id='topic+get_MIdat'></span>

<h3>Description</h3>

<p>This function returns a dataset containing multiple imputed datasets stacked
onto each other (i.e., long format; optionally including the original,
incomplete data).<br />
These data can be automatically exported to SPSS (as a .txt file containing
the data and a .sps file containing syntax to generate a .sav file).
For the export function the
<a href="https://CRAN.R-project.org/package=foreign"><strong>foreign</strong></a> package
needs to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_MIdat(object, m = 10, include = TRUE, start = NULL, minspace = 50,
  seed = NULL, export_to_SPSS = FALSE, resdir = NULL, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_MIdat_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_m">m</code></td>
<td>
<p>number of imputed datasets</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_include">include</code></td>
<td>
<p>should the original, incomplete data be included? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_minspace">minspace</code></td>
<td>
<p>minimum number of iterations between iterations to be chosen
as imputed values (to prevent strong correlation between
imputed datasets in the case of high autocorrelation of the
MCMC chains).</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_seed">seed</code></td>
<td>
<p>optional seed value</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_export_to_spss">export_to_SPSS</code></td>
<td>
<p>logical; should the completed data be exported to SPSS?</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_resdir">resdir</code></td>
<td>
<p>optional; directory for results. If unspecified and
<code>export_to_SPSS = TRUE</code> the current working directory is
used.</p>
</td></tr>
<tr><td><code id="get_MIdat_+3A_filename">filename</code></td>
<td>
<p>optional; file name (without ending). If unspecified and
<code>export_to_SPSS = TRUE</code> a name is generated
automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> in which the original data (if
<code>include = TRUE</code>) and the imputed datasets are stacked onto
each other.<br />
The variable <code>Imputation_</code> indexes the imputation, while
<code>.rownr</code> links the rows to the rows of the original data.
In cross-sectional datasets the
variable <code>.id</code> is added as subject identifier.
</p>


<h3>Note</h3>

<p>In order to be able to extract (multiple) imputed datasets the imputed values
must have been monitored, i.e., <code>imps = TRUE</code> had to be specified in the
argument <code>monitor_params</code> in <code><a href="#topic+model_imp">*_imp</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_imp_distr">plot_imp_distr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# fit a model and monitor the imputed values with
# monitor_params = c(imps = TRUE)

mod &lt;- lm_imp(y ~ C1 + C2 + M2, data = wideDF,
              monitor_params = c(imps = TRUE), n.iter = 100)

# Example 1: without export to SPSS
MIs &lt;- get_MIdat(mod, m = 3, seed = 123)



# Example 2: with export for SPSS
# (here: to the temporary directory "temp_dir")

temp_dir &lt;- tempdir()
MIs &lt;- get_MIdat(mod, m = 3, seed = 123, resdir = temp_dir,
                 filename = "example_imputation",
                 export_to_SPSS = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='get_missinfo'>Obtain a summary of the missing values involved in an object of class JointAI</h2><span id='topic+get_missinfo'></span>

<h3>Description</h3>

<p>This function returns a <code>data.frame</code> or a <code>list</code> of
<code>data.frame</code>s per grouping level. Each of the <code>data.frames</code>
has columns <code>variable</code>, <code>#NA</code> (number of missing values) and
<code>%NA</code> (proportion of missing values in percent).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_missinfo(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_missinfo_+3A_object">object</code></td>
<td>
<p>object inheriting from class JointAI</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;-  lm_imp(y ~ C1 + B2 + C2, data = wideDF, n.iter = 100)
get_missinfo(mod)


</code></pre>

<hr>
<h2 id='get_Mlist'>Re-create the full <code>Mlist</code> from a &quot;JointAI&quot; object</h2><span id='topic+get_Mlist'></span>

<h3>Description</h3>

<p>Re-create the full <code>Mlist</code> from a &quot;JointAI&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Mlist(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Mlist_+3A_object">object</code></td>
<td>
<p>object of class &quot;JointAI&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='get_modeltype'>Identify the general model type from the covariate model type</h2><span id='topic+get_modeltype'></span>

<h3>Description</h3>

<p>Identify the general model type from the covariate model type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_modeltype(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_modeltype_+3A_model">model</code></td>
<td>
<p>character string; the covariate model type</p>
</td></tr>
</table>

<hr>
<h2 id='get_nranef'>Extract the number of random effects</h2><span id='topic+get_nranef'></span>

<h3>Description</h3>

<p>Extract the number of random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nranef(idvar, random, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nranef_+3A_idvar">idvar</code></td>
<td>
<p>vector of the names of all id variables</p>
</td></tr>
<tr><td><code id="get_nranef_+3A_random">random</code></td>
<td>
<p>a random effect formula or list of random effects formulas</p>
</td></tr>
<tr><td><code id="get_nranef_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list by grouping level (<code>idvar</code>) with a named vector of the number
of random effects per variable (=names).
</p>

<hr>
<h2 id='get_resp_mat'>Identify the data matrix containing a given response variable</h2><span id='topic+get_resp_mat'></span>

<h3>Description</h3>

<p>Identify the data matrix containing a given response variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_resp_mat(resp, Mlvls, outnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_resp_mat_+3A_resp">resp</code></td>
<td>
<p>character string; name of the response variable</p>
</td></tr>
<tr><td><code id="get_resp_mat_+3A_mlvls">Mlvls</code></td>
<td>
<p>named vector where the names are all column names of all data
matrices, and the values are the names of the corresponding
data matrices</p>
</td></tr>
<tr><td><code id="get_resp_mat_+3A_outnames">outnames</code></td>
<td>
<p>character vector; names of the columns in the data matrices
that contain the response variable (or multiple columns in
case of a survival outcome)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string; the name(s) of the data matrix/matrices of the
response variable(s)
</p>

<hr>
<h2 id='GR_crit'>Gelman-Rubin criterion for convergence</h2><span id='topic+GR_crit'></span>

<h3>Description</h3>

<p>Calculates the Gelman-Rubin criterion for convergence
(uses <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code> from package <strong>coda</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GR_crit(object, confidence = 0.95, transform = FALSE, autoburnin = TRUE,
  multivariate = TRUE, subset = NULL, exclude_chains = NULL,
  start = NULL, end = NULL, thin = NULL, warn = TRUE, mess = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GR_crit_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_confidence">confidence</code></td>
<td>
<p>the coverage probability of the confidence interval for the
potential scale reduction factor</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_transform">transform</code></td>
<td>
<p>a logical flag indicating whether variables in
<code>x</code> should be transformed to improve the normality of the
distribution. If set to TRUE, a log transform or logit transform, as
appropriate, will be applied.</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_autoburnin">autoburnin</code></td>
<td>
<p>a logical flag indicating whether only the second half
of the series should be used in the computation.  If set to TRUE
(default) and <code>start(x)</code> is less than <code>end(x)/2</code> then start
of series will be adjusted so that only second half of series is used.</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_multivariate">multivariate</code></td>
<td>
<p>a logical flag indicating whether the multivariate
potential scale reduction factor should be calculated for multivariate
chains</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_subset">subset</code></td>
<td>
<p>subset of parameters/variables/nodes (columns in the MCMC
sample). Follows the same principle as the argument
<code>monitor_params</code> in
<code><a href="#topic+model_imp">*_imp</a></code>.</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GR_crit_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using
multiple sequences, <em>Statistical Science</em>, <strong>7</strong>, 457-511.
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence
of iterative simulations.
<em>Journal of Computational and Graphical Statistics</em>, <strong>7</strong>, 434-455.
</p>


<h3>See Also</h3>

<p>The vignette
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>
contains some examples how to specify the argument <code>subset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;- lm_imp(y ~ C1 + C2 + M2, data = wideDF, n.iter = 100)
GR_crit(mod1)



</code></pre>

<hr>
<h2 id='hc_rdslope_info'>Get info on the main effects in a random slope structure
for a given level and sub-model</h2><span id='topic+hc_rdslope_info'></span>

<h3>Description</h3>

<p>Get info on the main effects in a random slope structure
for a given level and sub-model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hc_rdslope_info(hc_cols, parelmts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hc_rdslope_info_+3A_hc_cols">hc_cols</code></td>
<td>
<p>list of lists (one per random effect), each containing a list
with elements &quot;main&quot; and &quot;interact&quot; that contain information
on the column number and name of the design matrix for the
random effects variables or variables interacting with them</p>
</td></tr>
<tr><td><code id="hc_rdslope_info_+3A_parelmts">parelmts</code></td>
<td>
<p>list (per design matrix) of indices of the regression
coefficients used for that sub-model (named with the
corresponding column name of the design matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>hc_cols</code> should have the structure:
</p>
<div class="sourceCode r"><pre>list(
  "(Intercept)" = list(main = c(M_id = 1),
                       interact = NULL),
  time = list(main = c(M_lvlone = 4),
              interact = list("C1:time" = list(interterm = c(M_lvlone = 6),
                                               elmts = c(M_id = 2,
                                                         M_lvlone = 4)),
                              "b21:time" = list(interterm = c(M_lvlone = 7),
                                                elmts = c(M_lvlone = 3,
                                                          M_lvlone = 4))
              )
  ),
  "I(time^2)" = list(main = c(M_lvlone = 5),
                     interact = NULL)
)
</pre></div>
<p>Argument <code>parelmts</code> is a list of lists instead of a list of vectors in
case of a multinomial model or cumulative logit model with non-proportional
effects.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns
</p>

<ul>
<li> <p><code>rd_effect</code>: name of the main random effect,
</p>
</li>
<li> <p><code>term</code>: the name of the random effect,
</p>
</li>
<li> <p><code>matrix</code>: the name of the design matrix,
</p>
</li>
<li> <p><code>cols</code>: the column index of the design matrix,
</p>
</li>
<li> <p><code>parelmts</code> (the index of the corresponding regression coefficient
and one row per (main) random effect
</p>
</li></ul>


<hr>
<h2 id='hc_rdslope_interact'>Get info on the interactions with random slopes for a given level and sub-model</h2><span id='topic+hc_rdslope_interact'></span>

<h3>Description</h3>

<p>Get info on the interactions with random slopes for a given level and sub-model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hc_rdslope_interact(hc_cols, parelmts, lvls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hc_rdslope_interact_+3A_hc_cols">hc_cols</code></td>
<td>
<p>list of lists (one per random effect), each containing a list
with elements &quot;main&quot; and &quot;interact&quot; that contain information
on the column number and name of the design matrix for the
random effects variables or variables interacting with them</p>
</td></tr>
<tr><td><code id="hc_rdslope_interact_+3A_parelmts">parelmts</code></td>
<td>
<p>list (per design matrix) of indices of the regression
coefficients used for that sub-model (named with the
corresponding column name of the design matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>hc_cols</code> should have the structure:
</p>
<div class="sourceCode r"><pre>list(
  "(Intercept)" = list(main = c(M_id = 1),
                       interact = NULL),
  time = list(main = c(M_lvlone = 4),
              interact = list("C1:time" = list(interterm = c(M_lvlone = 6),
                                               elmts = c(M_id = 2,
                                                         M_lvlone = 4)),
                              "b21:time" = list(interterm = c(M_lvlone = 7),
                                                elmts = c(M_lvlone = 3,
                                                          M_lvlone = 4))
              )
  ),
  "I(time^2)" = list(main = c(M_lvlone = 5),
                     interact = NULL)
)
</pre></div>
<p>Argument <code>parelmts</code> is a list of lists instead of a list of vectors in
case of a multinomial model or cumulative logit model with non-proportional
effects.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns
</p>

<ul>
<li> <p><code>rd_effect</code>: name of the main random effect,
</p>
</li>
<li> <p><code>term</code>: the name of the random effect,
</p>
</li>
<li> <p><code>matrix</code>: the name of the design matrix,
</p>
</li>
<li> <p><code>cols</code>: the column index of the design matrix,
</p>
</li>
<li> <p><code>parelmts</code> (the index of the corresponding regression coefficient
and one row per (main) random effect
</p>
</li></ul>


<hr>
<h2 id='JointAI'>JointAI: Joint Analysis and Imputation of Incomplete Data</h2><span id='topic+JointAI'></span>

<h3>Description</h3>

<p>The <strong>JointAI</strong> package performs simultaneous imputation and inference
for incomplete or complete data under the Bayesian framework.
Models for incomplete covariates, conditional on other covariates,
are specified automatically and modelled jointly with the analysis model.
MCMC sampling is performed in <a href="https://mcmc-jags.sourceforge.io/">'JAGS'</a>
via the R package
<a href="https://CRAN.R-project.org/package=rjags"><strong>rjags</strong></a>.
</p>


<h3>Main functions</h3>

<p><strong>JointAI</strong> provides the following main functions that facilitate
analysis with different models:
</p>

<ul>
<li> <p><code><a href="#topic+lm_imp">lm_imp</a></code> for linear regression
</p>
</li>
<li> <p><code><a href="#topic+glm_imp">glm_imp</a></code> for generalized linear regression
</p>
</li>
<li> <p><code><a href="#topic+betareg_imp">betareg_imp</a></code> for regression using a beta distribution
</p>
</li>
<li> <p><code><a href="#topic+lognorm_imp">lognorm_imp</a></code> for regression using a log-normal
distribution
</p>
</li>
<li> <p><code><a href="#topic+clm_imp">clm_imp</a></code> for (ordinal) cumulative logit models
</p>
</li>
<li> <p><code><a href="#topic+mlogit_imp">mlogit_imp</a></code> for multinomial models
</p>
</li>
<li> <p><code><a href="#topic+lme_imp">lme_imp</a></code> or <code><a href="#topic+lmer_imp">lmer_imp</a></code> for linear mixed models
</p>
</li>
<li> <p><code><a href="#topic+glme_imp">glme_imp</a></code> or <code><a href="#topic+glmer_imp">glmer_imp</a></code> for generalized
linear mixed models
</p>
</li>
<li> <p><code><a href="#topic+betamm_imp">betamm_imp</a></code> for mixed models using a beta distribution
</p>
</li>
<li> <p><code><a href="#topic+lognormmm_imp">lognormmm_imp</a></code> for mixed models using a log-normal
distribution
</p>
</li>
<li> <p><code><a href="#topic+clmm_imp">clmm_imp</a></code> for (ordinal) cumulative logit mixed models
</p>
</li>
<li> <p><code><a href="#topic+survreg_imp">survreg_imp</a></code> for parametric (Weibull) survival models
</p>
</li>
<li> <p><code><a href="#topic+coxph_imp">coxph_imp</a></code> for (Cox) proportional hazard models
</p>
</li>
<li> <p><code><a href="#topic+JM_imp">JM_imp</a></code> for joint models of longitudinal and survival data
</p>
</li></ul>

<p>As far as possible, the specification of these functions is analogous to the
specification of widely used functions for the analysis of complete data,
such as
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="nlme.html#topic+lme">lme</a></code> (from the package
<a href="https://CRAN.R-project.org/package=nlme"><strong>nlme</strong></a>),
<code><a href="survival.html#topic+survreg">survreg</a></code> (from the package
<a href="https://CRAN.R-project.org/package=survival"><strong>survival</strong></a>) and
<code><a href="survival.html#topic+coxph">coxph</a></code> (from the package
<a href="https://CRAN.R-project.org/package=survival"><strong>survival</strong></a>).
</p>
<p>Computations can be performed in parallel to reduce computational time,
using the package <span class="pkg">future</span>,
the argument <code>shrinkage</code> allows the user to impose a penalty on the
regression coefficients of some or all models involved,
and hyper-parameters can be changed via the argument <code>hyperpars</code>.
</p>
<p>To obtain summaries of the results, the functions
<code><a href="#topic+summary.JointAI">summary()</a></code>,
<code><a href="#topic+summary.JointAI">coef()</a></code> and
<code><a href="#topic+summary.JointAI">confint()</a></code> are available, and
results can be visualized with the help of
<code><a href="#topic+traceplot">traceplot()</a></code> or
<code><a href="#topic+densplot">densplot()</a></code>.
</p>
<p>The function <code><a href="#topic+predict.JointAI">predict()</a></code> allows
prediction (including credible intervals) from <code>JointAI</code> models.
</p>


<h3>Evaluation and export</h3>

<p>Two criteria for evaluation of convergence and precision of the posterior
estimate are available:
</p>

<ul>
<li> <p><code><a href="#topic+GR_crit">GR_crit</a></code> implements the Gelman-Rubin criterion
('potential scale reduction factor') for convergence
</p>
</li>
<li> <p><code><a href="#topic+MC_error">MC_error</a></code> calculates the Monte Carlo error to evaluate
the precision of the MCMC sample
</p>
</li></ul>

<p>Imputed data can be extracted (and exported to SPSS) using
<code><a href="#topic+get_MIdat">get_MIdat()</a></code>.
The function <code><a href="#topic+plot_imp_distr">plot_imp_distr()</a></code> allows
visual comparison of the distribution of observed and imputed values.
</p>


<h3>Other useful functions</h3>


<ul>
<li> <p><code><a href="#topic+parameters">parameters</a></code> and <code><a href="#topic+list_models">list_models</a></code> to gain
insight in the specified model
</p>
</li>
<li> <p><code><a href="#topic+plot_all">plot_all</a></code> and <code><a href="#topic+md_pattern">md_pattern</a></code> to visualize the
distribution of the data and the missing data pattern
</p>
</li></ul>



<h3>Vignettes</h3>

<p>The following vignettes are available
</p>

<ul>
<li> <p><a href="https://nerler.github.io/JointAI/articles/MinimalExample.html"><em>Minimal Example</em></a>:<br />
A minimal example demonstrating the use of
<code><a href="#topic+lm_imp">lm_imp</a></code>,
<code><a href="#topic+summary.JointAI">summary.JointAI</a></code>,
<code><a href="#topic+traceplot">traceplot</a></code>
and <code><a href="#topic+densplot">densplot</a></code>.
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/VisualizingIncompleteData.html"><em>Visualizing Incomplete Data</em></a>:<br />
Demonstrations of the options in <code><a href="#topic+plot_all">plot_all</a></code> (plotting histograms
and bar plots for all variables in the data)  and <code><a href="#topic+md_pattern">md_pattern</a></code>
(plotting or printing the missing data pattern).
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/ModelSpecification.html"><em>Model Specification</em></a>:<br />
Explanation and demonstration of all parameters that are required or optional
to specify the model structure in <code><a href="#topic+lm_imp">lm_imp</a></code>,
<code><a href="#topic+glm_imp">glm_imp</a></code> and <code><a href="#topic+lme_imp">lme_imp</a></code>.
Among others, the functions <code><a href="#topic+parameters">parameters</a></code>,
<code><a href="#topic+list_models">list_models</a></code> and <code><a href="#topic+set_refcat">set_refcat</a></code> are used.
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html"><em>Parameter Selection</em></a>:<br />
Examples on how to select the parameters/variables/nodes
to follow using the argument <code>monitor_params</code> and the
parameters/variables/nodes displayed in the <code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+traceplot">traceplot</a></code>, <code><a href="#topic+densplot">densplot</a></code> or when using
<code><a href="#topic+GR_crit">GR_crit</a></code> or <code><a href="#topic+MC_error">MC_error</a></code>.
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/MCMCsettings.html"><em>MCMC Settings</em></a>:<br />
Examples demonstrating how to set the arguments controlling settings
of the MCMC sampling,
i.e., <code>n.adapt</code>, <code>n.iter</code>, <code>n.chains</code>, <code>thin</code>,
<code>inits</code>.
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/AfterFitting.html"><em>After Fitting</em></a>:<br />
Examples on the use of functions to be applied after the model has
been fitted, including <code><a href="#topic+traceplot">traceplot</a></code>, <code><a href="#topic+densplot">densplot</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+GR_crit">GR_crit</a></code>, <code><a href="#topic+MC_error">MC_error</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+predDF">predDF</a></code> and
<code><a href="#topic+get_MIdat">get_MIdat</a></code>.
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/TheoreticalBackground.html"><em>Theoretical Background</em></a>:<br />
Explanation of the statistical method implemented in <strong>JointAI</strong>.
</p>
</li></ul>



<h3>References</h3>

<p>Erler NS, Rizopoulos D, Lesaffre EMEH (2021).
&quot;JointAI: Joint Analysis and Imputation of Incomplete Data in R.&quot;
<em>Journal of Statistical Software</em>, <em>100</em>(20), 1-56.
<a href="https://doi.org/10.18637/jss.v100.i20">doi:10.18637/jss.v100.i20</a>.
</p>
<p>Erler, N.S., Rizopoulos, D., Rosmalen, J., Jaddoe, V.W.V.,
Franco, O. H., &amp; Lesaffre, E.M.E.H. (2016).
Dealing with missing covariates in epidemiologic studies: A comparison
between multiple imputation and a full Bayesian approach.
<em>Statistics in Medicine</em>, 35(17), 2955-2974.
<a href="https://doi.org/10.1002/sim.6944">doi:10.1002/sim.6944</a>
</p>
<p>Erler, N.S., Rizopoulos D., Jaddoe, V.W.V., Franco, O.H. &amp; Lesaffre, E.M.E.H. (2019).
Bayesian imputation of time-varying covariates in linear mixed models.
<em>Statistical Methods in Medical Research</em>, 28(2), 555–568.
<a href="https://doi.org/10.1177/0962280217730851">doi:10.1177/0962280217730851</a>
</p>

<hr>
<h2 id='JointAIObject'>Fitted object of class 'JointAI'</h2><span id='topic+JointAIObject'></span>

<h3>Description</h3>

<p>An object returned by one of the main functions
<code><a href="#topic+model_imp">*_imp</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>analysis_type</code></td>
<td>
<p><code>lm</code>, <code>glm</code>, <code>clm</code>, <code>lme</code>,
<code>glme</code>, <code>clmm</code>, <code>survreg</code> or
<code>coxph</code> (with attributes
<code>family</code> and <code>link</code> for GLM-type
models</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula used in the (analysis) model.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original (incomplete, but pre-processed) data</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>named vector specifying the the types of all sub-models</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>a list of the fixed effects formulas of the sub-model(s)
for which the use had specified a formula</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>a list of the random effects formulas of the
sub-model(s) for which the use had specified a formula</p>
</td></tr>
<tr><td><code>Mlist</code></td>
<td>
<p>a list (for internal use) containing the data and
information extracted from the data and model formulas,
split up into
</p>

<ul>
<li><p> a named vector identifying the levels (in the hierarchy)
of all variables (<code>Mlvls</code>)
</p>
</li>
<li><p> a vector of the id variables that were extracted from the
random effects formulas (<code>idvar</code>)
</p>
</li>
<li><p> a list of grouping information for each grouping level of the
data (<code>groups</code>)
</p>
</li>
<li><p> a named vector identifying the hierarchy of the grouping levels
(<code>group_lvls</code>)
</p>
</li>
<li><p> a named vector giving the number of observations on each
level of the hierarchy (<code>N</code>)
</p>
</li>
<li><p> the name of the time variable (only for survival models with
time-varying covariates) (<code>timevar</code>)
</p>
</li>
<li><p> a formula of auxiliary variables (<code>auxvars</code>)
</p>
</li>
<li><p> a list specifying the reference categories and dummy variables
for all factors involved in the models (<code>refs</code>)
</p>
</li>
<li><p> a list of linear predictor information (column numbers per
design matrix) for all sub-models (<code>lp_cols</code>)
</p>
</li>
<li><p> a list identifying information for interaction terms found in
the model formulas (<code>interactions</code>)
</p>
</li>
<li><p> a <code>data.frame</code> containing information on transformations
of incomplete variables (<code>trafos</code>)
</p>
</li>
<li><p> a <code>data.frame</code> containing information on transformations
of all variables (<code>fcts_all</code>)
</p>
</li>
<li><p> a logical indicator if parameter for posterior predictive
checks should be monitored (<code>ppc</code>; not yet used)
</p>
</li>
<li><p> a vector specifying if shrinkage of regression coefficients
should be performed, and if so for which models and what type
of shrinkage (<code>shrinkage</code>)
</p>
</li>
<li><p> the number of degrees of freedom to be used in the spline
specification of the baseline hazard in proportional hazards
survival models (<code>df_basehaz</code>)
</p>
</li>
<li><p> a list of matrices, one per level of the data, specifying
centring and scaling parameters for the data
(<code>scale_pars</code>)
</p>
</li>
<li><p> a list containing information on the outcomes (mostly relevant
for survival outcomes; <code>outcomes</code>)
</p>
</li>
<li><p> a list of terms objects, needed to be able to build correct
design matrices for the Gauss-Kronrod quadrature when, for
example, splines are used to model time in a joint model
(<code>terms_list</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code>par_index_main</code></td>
<td>
<p>a list of matrices specifying the indices of the
regression coefficients for each of the main models per design matrix</p>
</td></tr>
<tr><td><code>par_index_other</code></td>
<td>
<p>a list of matrices specifying the indices of
regression coefficients for each covariate model per design matrix</p>
</td></tr>
<tr><td><code>jagsmodel</code></td>
<td>
<p>The JAGS model as character string.</p>
</td></tr>
<tr><td><code>mcmc_settings</code></td>
<td>
<p>a list containing MCMC sampling related
information with elements
</p>

<ul>
<li><p><code>modelfile</code>: path and name of the JAGS model file
</p>
</li>
<li><p><code>n.chains</code>: number of MCMC chains
</p>
</li>
<li><p><code>n.adapt</code>: number of iterations in the adaptive phase
</p>
</li>
<li><p><code>n.iter</code>: number of iterations in the MCMC sample
</p>
</li>
<li><p><code>variable.names</code>: monitored nodes
</p>
</li>
<li><p><code>thin</code>: thinning interval of the MCMC sample
</p>
</li>
<li><p><code>inits</code>: a list containing the initial values that were
passed to <strong>rjags</strong>
</p>
</li></ul>
</td></tr>
<tr><td><code>monitor_params</code></td>
<td>
<p>the named list of parameter groups to be
monitored</p>
</td></tr>
<tr><td><code>data_list</code></td>
<td>
<p>list with data that was passed to <strong>rjags</strong></p>
</td></tr>
<tr><td><code>hyperpars</code></td>
<td>
<p>a list containing the values of the hyper-parameters
used</p>
</td></tr>
<tr><td><code>info_list</code></td>
<td>
<p>a list with information used to write the imputation
model syntax</p>
</td></tr>
<tr><td><code>coef_list</code></td>
<td>
<p>a list relating the regression coefficient vectors
used in the JAGS model to the names of the
corresponding covariates</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the JAGS model (an object of class 'jags', created by
<b>rjags</b>)</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>MCMC sample on the sampling scale (included only if
<code>keep_scaled_sample = TRUE</code>)</p>
</td></tr>
<tr><td><code>MCMC</code></td>
<td>
<p>MCMC sample, scaled back to the scale of the data</p>
</td></tr>
<tr><td><code>comp_info</code></td>
<td>
<p>a list with information on the computational setting
(<code>start_time</code>: date and time the calculation was
started, <code>duration</code>: computational time of the
model adaptive and sampling phase,
<code>JointAI_version</code>: package version,
<code>R_version</code>: the <code>R.version.string</code>,
<code>parallel</code>: whether parallel computation was used,
<code>workers</code>: if parallel computation was used, the
number of workers)</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted/predicted values (if available)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals (if available)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call</p>
</td></tr>
</table>

<hr>
<h2 id='list_models'>List model details</h2><span id='topic+list_models'></span>

<h3>Description</h3>

<p>This function prints information on all models, those explicitly specified
by the user and those specified automatically by JointAI for (incomplete)
covariates in a JointAI object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_models(object, predvars = TRUE, regcoef = TRUE, otherpars = TRUE,
  priors = TRUE, refcat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_models_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="list_models_+3A_predvars">predvars</code></td>
<td>
<p>logical; should information on the predictor variables be
printed? (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="list_models_+3A_regcoef">regcoef</code></td>
<td>
<p>logical; should information on the regression coefficients
be printed? (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="list_models_+3A_otherpars">otherpars</code></td>
<td>
<p>logical; should information on other parameters be printed?
(default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="list_models_+3A_priors">priors</code></td>
<td>
<p>logical; should information on the priors
(and hyper-parameters) be printed? (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="list_models_+3A_refcat">refcat</code></td>
<td>
<p>logical; should information on the reference category be
printed? (default is <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The models listed by this function are not the actual imputation models,
but the conditional models that are part of the specification of the joint
distribution.
Briefly, the joint distribution is specified as a sequence of conditional
models
</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[p(y | x_1, x_2, x_3, ..., \theta) p(x_1|x_2, x_3, ..., \theta)
p(x_2|x_3, ..., \theta) ...\]
<p>The actual imputation models are the full conditional distributions
\(p(x_1 | \cdot)\) derived from this joint distribution.
Even though the conditional distributions do not contain the outcome and all
other covariates in their linear predictor, outcome and other covariates are
taken into account implicitly, since imputations are sampled
from the full conditional distributions.
For more details, see Erler et al. (2016) and Erler et al. (2019).
</p>
<p>The function <code>list_models</code> prints information on the conditional
distributions of the covariates (since they are what is specified;
the full-conditionals are automatically derived within JAGS). The outcome
is, thus, not part of the printed linear predictor, but is still included
during imputation.
</p>


<h3>References</h3>

<p>Erler, N.S., Rizopoulos, D., Rosmalen, J.V., Jaddoe,
V.W., Franco, O.H., &amp; Lesaffre, E.M.E.H. (2016).
Dealing with missing covariates in epidemiologic studies: A comparison
between multiple imputation and a full Bayesian approach.
<em>Statistics in Medicine</em>, 35(17), 2955-2974.
</p>
<p>Erler NS, Rizopoulos D, Lesaffre EMEH (2021).
&quot;JointAI: Joint Analysis and Imputation of Incomplete Data in R.&quot;
<em>Journal of Statistical Software</em>, <em>100</em>(20), 1-56.
<a href="https://doi.org/10.18637/jss.v100.i20">doi:10.18637/jss.v100.i20</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (set n.adapt = 0 and n.iter = 0 to prevent MCMC sampling to save time)
mod1 &lt;- lm_imp(y ~ C1 + C2 + M2 + O2 + B2, data = wideDF, n.adapt = 0,
               n.iter = 0, mess = FALSE)

list_models(mod1)

</code></pre>

<hr>
<h2 id='longDF'>Longitudinal example dataset</h2><span id='topic+longDF'></span>

<h3>Description</h3>

<p>A simulated longitudinal dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(longDF)
</code></pre>


<h3>Format</h3>

<p>A simulated data frame with 329 rows and 21 variables with data from
100 subjects:
</p>

<dl>
<dt>C1</dt><dd><p>continuous, complete baseline variable</p>
</dd>
<dt>C2</dt><dd><p>continuous, incomplete baseline variable</p>
</dd>
<dt>B1</dt><dd><p>binary, complete baseline variable</p>
</dd>
<dt>B2</dt><dd><p>binary, incomplete baseline variable</p>
</dd>
<dt>M1</dt><dd><p>unordered factor; complete baseline variable</p>
</dd>
<dt>M2</dt><dd><p>unordered factor; incomplete baseline variable</p>
</dd>
<dt>O1</dt><dd><p>ordered factor; complete baseline variable</p>
</dd>
<dt>O2</dt><dd><p>ordered factor; incomplete baseline variable</p>
</dd>
<dt>P1</dt><dd><p>count variable; complete baseline variable</p>
</dd>
<dt>P2</dt><dd><p>count variable; incomplete baseline variable</p>
</dd>
<dt>c1</dt><dd><p>continuous, complete longitudinal variable</p>
</dd>
<dt>c2</dt><dd><p>continuous incomplete longitudinal variable</p>
</dd>
<dt>b1</dt><dd><p>binary, complete longitudinal variable</p>
</dd>
<dt>b2</dt><dd><p>binary incomplete longitudinal variable</p>
</dd>
<dt>o1</dt><dd><p>ordered factor; complete longitudinal variable</p>
</dd>
<dt>o2</dt><dd><p>ordered factor; incomplete longitudinal variable</p>
</dd>
<dt>p1</dt><dd><p>count variable; complete longitudinal variable</p>
</dd>
<dt>p2</dt><dd><p>count variable; incomplete longitudinal variable</p>
</dd>
<dt>id</dt><dd><p>id (grouping) variable</p>
</dd>
<dt>time</dt><dd><p>continuous complete longitudinal variable</p>
</dd>
<dt>y</dt><dd><p>continuous, longitudinal (outcome) variable</p>
</dd>
</dl>


<hr>
<h2 id='MC_error'>Calculate and plot the Monte Carlo error</h2><span id='topic+MC_error'></span><span id='topic+plot.MCElist'></span>

<h3>Description</h3>

<p>Calculate, print and plot the Monte Carlo error of the samples from a
'JointAI' model, combining the samples from all MCMC chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC_error(x, subset = NULL, exclude_chains = NULL, start = NULL,
  end = NULL, thin = NULL, digits = 2, warn = TRUE, mess = TRUE, ...)

## S3 method for class 'MCElist'
plot(x, data_scale = TRUE, plotpars = NULL,
  ablinepars = list(v = 0.05), minlength = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_error_+3A_x">x</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="MC_error_+3A_subset">subset</code></td>
<td>
<p>subset of parameters/variables/nodes (columns in the MCMC
sample). Follows the same principle as the argument
<code>monitor_params</code> in
<code><a href="#topic+model_imp">*_imp</a></code>.</p>
</td></tr>
<tr><td><code id="MC_error_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="MC_error_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="MC_error_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="MC_error_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="MC_error_+3A_digits">digits</code></td>
<td>
<p>number of digits for the printed output</p>
</td></tr>
<tr><td><code id="MC_error_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MC_error_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MC_error_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="mcmcse.html#topic+mcse.mat">mcmcse::mcse.mat</a></code>
</p>

<dl>
<dt><code>size</code></dt><dd><p>represents the batch size in &ldquo;<code>bm</code>&rdquo; and the truncation point in &ldquo;<code>bartlett</code>&rdquo; and 
&ldquo;<code>tukey</code>&rdquo;. Default is <code>NULL</code> which implies that an optimal batch size is calculated using the 
<code>batchSize</code> function. Can take character values of &ldquo;<code>sqroot</code>&rdquo; and &ldquo;<code>cuberoot</code>&rdquo; or any numeric
value between 1 and n/2. &ldquo;<code>sqroot</code>&rdquo; means size is <code class="reqn">\lfloor n^{1/2} \rfloor</code> and &ldquo;<code>cuberoot</code>&rdquo; means size is
<code class="reqn">\lfloor n^{1/3} \rfloor</code>.</p>
</dd>
<dt><code>g</code></dt><dd><p>a function such that <code class="reqn">E(g(x))</code> is the quantity of interest. The default is
<code>NULL</code>, which causes the identity function to be used.</p>
</dd>
<dt><code>method</code></dt><dd><p>any of &ldquo;<code>bm</code>&rdquo;,&ldquo;<code>obm</code>&rdquo;,&ldquo;<code>bartlett</code>&rdquo;, &ldquo;<code>tukey</code>&rdquo;. &ldquo;<code>bm</code>&rdquo;
represents batch means estimator, &ldquo;<code>obm</code>&rdquo; represents overlapping batch means estimator with, &ldquo;<code>bartlett</code>&rdquo;
and &ldquo;<code>tukey</code>&rdquo; represents the modified-Bartlett window and the Tukey-Hanning windows for spectral variance estimators.</p>
</dd>
<dt><code>r</code></dt><dd><p>The lugsail parameters (<code>r</code>) that converts a lag window into its lugsail
equivalent. Larger values of <code>r</code> will typically imply less underestimation of &ldquo;<code>cov</code>&rdquo;,
but higher variability of the estimator. Default is <code>r = 3</code> and <code>r = 1,2</code> are
also good choices although may lead to underestimates of the variance. <code>r &gt; 5</code> is not recommended.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="MC_error_+3A_data_scale">data_scale</code></td>
<td>
<p>logical; show the Monte Carlo error of the sample
transformed back to the scale of the data (<code>TRUE</code>) or
on the sampling scale (this requires the argument
<code>keep_scaled_mcmc = TRUE</code> to be set when fitting the
model)</p>
</td></tr>
<tr><td><code id="MC_error_+3A_plotpars">plotpars</code></td>
<td>
<p>optional; list of parameters passed to
<code>plot()</code></p>
</td></tr>
<tr><td><code id="MC_error_+3A_ablinepars">ablinepars</code></td>
<td>
<p>optional; list of parameters passed to
<code><a href="graphics.html#topic+abline">abline</a>()</code></p>
</td></tr>
<tr><td><code id="MC_error_+3A_minlength">minlength</code></td>
<td>
<p>number of characters the variable names are abbreviated to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>MCElist</code> with elements <code>unscaled</code>,
<code>scaled</code> and <code>digits</code>. The first two are matrices with
columns <code>est</code> (posterior mean), <code>MCSE</code> (Monte Carlo error),
<code>SD</code> (posterior standard deviation) and <code>MCSE/SD</code>
(Monte Carlo error divided by post. standard deviation.)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(MCElist)</code>: plot Monte Carlo error
</p>
</li></ul>


<h3>Note</h3>

<p>Lesaffre &amp; Lawson (2012; p. 195) suggest the Monte Carlo error of a
parameter should not be more than 5% of the posterior standard
deviation of this parameter (i.e., <code class="reqn">MCSE/SD \le 0.05</code>).
</p>
<p><strong>Long variable names:</strong><br />
The default plot margins may not be wide enough when variable names are
longer than a few characters. The plot margin can be adjusted (globally)
using the argument <code>"mar"</code> in <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>References</h3>

<p>Lesaffre, E., &amp; Lawson, A. B. (2012).
<em>Bayesian Biostatistics</em>.
John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p>The vignette
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>
provides some examples how to specify the argument <code>subset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

mod &lt;- lm_imp(y ~ C1 + C2 + M2, data = wideDF, n.iter = 100)

MC_error(mod)

plot(MC_error(mod), ablinepars = list(lty = 2),
     plotpars = list(pch = 19, col = 'blue'))

## End(Not run)

</code></pre>

<hr>
<h2 id='md_pattern'>Missing data pattern</h2><span id='topic+md_pattern'></span>

<h3>Description</h3>

<p>Obtain a plot of the pattern of missing data and/or return the pattern as a
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_pattern(data, color = c(grDevices::grey(0.1), grDevices::grey(0.7)),
  border = grDevices::grey(0.5), plot = TRUE, pattern = FALSE,
  print_xaxis = TRUE, ylab = "Number of observations per pattern",
  print_yaxis = TRUE, legend.position = "bottom", sort_columns = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md_pattern_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_color">color</code></td>
<td>
<p>vector of length two, that specifies the colour used to indicate
observed and missing values (in that order)</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_border">border</code></td>
<td>
<p>colour of the grid</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_plot">plot</code></td>
<td>
<p>logical; should the missing data pattern be plotted?
(default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_pattern">pattern</code></td>
<td>
<p>logical; should the missing data pattern be returned as
matrix? (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_print_xaxis">print_xaxis</code>, <code id="md_pattern_+3A_print_yaxis">print_yaxis</code></td>
<td>
<p>logical; should the x-axis (below the plot)
and y-axis (on the right) be printed?</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_legend.position">legend.position</code></td>
<td>
<p>the position of legends (&quot;none&quot;, &quot;left&quot;, &quot;right&quot;,
&quot;bottom&quot;, &quot;top&quot;, or two-element numeric vector)</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_sort_columns">sort_columns</code></td>
<td>
<p>logical; should the columns be sorted by number of missing
values? (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="md_pattern_+3A_...">...</code></td>
<td>
<p>optional additional parameters, currently not used</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the
<a href="https://CRAN.R-project.org/package=ggplot2"><strong>ggplot2</strong></a> package
to be installed.
</p>


<h3>See Also</h3>

<p>See the vignette
<a href="https://nerler.github.io/JointAI/articles/VisualizingIncompleteData.html">Visualizing Incomplete Data</a>
for more examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(mar = c(3, 1, 1.5, 1.5), mgp = c(2, 0.6, 0))
md_pattern(wideDF)
par(op)

</code></pre>

<hr>
<h2 id='model_imp'>Joint Analysis and Imputation of incomplete data</h2><span id='topic+model_imp'></span><span id='topic+lm_imp'></span><span id='topic+glm_imp'></span><span id='topic+clm_imp'></span><span id='topic+lognorm_imp'></span><span id='topic+betareg_imp'></span><span id='topic+mlogit_imp'></span><span id='topic+lme_imp'></span><span id='topic+lmer_imp'></span><span id='topic+glme_imp'></span><span id='topic+glmer_imp'></span><span id='topic+betamm_imp'></span><span id='topic+lognormmm_imp'></span><span id='topic+clmm_imp'></span><span id='topic+mlogitmm_imp'></span><span id='topic+survreg_imp'></span><span id='topic+coxph_imp'></span><span id='topic+JM_imp'></span>

<h3>Description</h3>

<p>Main analysis functions to estimate different types of models using MCMC
sampling, while imputing missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_imp(formula, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, models = NULL, no_model = NULL, shrinkage = FALSE,
  ppc = TRUE, seed = NULL, inits = NULL, warn = TRUE, mess = TRUE,
  ...)

glm_imp(formula, family, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, models = NULL, no_model = NULL, shrinkage = FALSE,
  ppc = TRUE, seed = NULL, inits = NULL, warn = TRUE, mess = TRUE,
  ...)

clm_imp(formula, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, nonprop = NULL, rev = NULL, models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

lognorm_imp(formula, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, models = NULL, no_model = NULL, shrinkage = FALSE,
  ppc = TRUE, seed = NULL, inits = NULL, warn = TRUE, mess = TRUE,
  ...)

betareg_imp(formula, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, models = NULL, no_model = NULL, shrinkage = FALSE,
  ppc = TRUE, seed = NULL, inits = NULL, warn = TRUE, mess = TRUE,
  ...)

mlogit_imp(formula, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, models = NULL, no_model = NULL, shrinkage = FALSE,
  ppc = TRUE, seed = NULL, inits = NULL, warn = TRUE, mess = TRUE,
  ...)

lme_imp(fixed, data, random, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, rd_vcov = "blockdiag", models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

lmer_imp(fixed, data, random, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, rd_vcov = "blockdiag", models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

glme_imp(fixed, data, random, family, n.chains = 3, n.adapt = 100,
  n.iter = 0, thin = 1, monitor_params = c(analysis_main = TRUE),
  auxvars = NULL, refcats = NULL, rd_vcov = "blockdiag", models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

glmer_imp(fixed, data, random, family, n.chains = 3, n.adapt = 100,
  n.iter = 0, thin = 1, monitor_params = c(analysis_main = TRUE),
  auxvars = NULL, refcats = NULL, rd_vcov = "blockdiag", models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

betamm_imp(fixed, random, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, rd_vcov = "blockdiag", models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

lognormmm_imp(fixed, random, data, n.chains = 3, n.adapt = 100,
  n.iter = 0, thin = 1, monitor_params = c(analysis_main = TRUE),
  auxvars = NULL, refcats = NULL, rd_vcov = "blockdiag", models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

clmm_imp(fixed, data, random, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, nonprop = NULL, rev = NULL, rd_vcov = "blockdiag",
  models = NULL, no_model = NULL, shrinkage = FALSE, ppc = TRUE,
  seed = NULL, inits = NULL, warn = TRUE, mess = TRUE, ...)

mlogitmm_imp(fixed, data, random, n.chains = 3, n.adapt = 100,
  n.iter = 0, thin = 1, monitor_params = c(analysis_main = TRUE),
  auxvars = NULL, refcats = NULL, rd_vcov = "blockdiag", models = NULL,
  no_model = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)

survreg_imp(formula, data, n.chains = 3, n.adapt = 100, n.iter = 0,
  thin = 1, monitor_params = c(analysis_main = TRUE), auxvars = NULL,
  refcats = NULL, models = NULL, no_model = NULL, shrinkage = FALSE,
  ppc = TRUE, seed = NULL, inits = NULL, warn = TRUE, mess = TRUE,
  ...)

coxph_imp(formula, data, df_basehaz = 6, n.chains = 3, n.adapt = 100,
  n.iter = 0, thin = 1, monitor_params = c(analysis_main = TRUE),
  auxvars = NULL, refcats = NULL, models = NULL, no_model = NULL,
  shrinkage = FALSE, ppc = TRUE, seed = NULL, inits = NULL,
  warn = TRUE, mess = TRUE, ...)

JM_imp(formula, data, df_basehaz = 6, n.chains = 3, n.adapt = 100,
  n.iter = 0, thin = 1, monitor_params = c(analysis_main = TRUE),
  auxvars = NULL, timevar = NULL, refcats = NULL,
  rd_vcov = "blockdiag", models = NULL, no_model = NULL,
  assoc_type = NULL, shrinkage = FALSE, ppc = TRUE, seed = NULL,
  inits = NULL, warn = TRUE, mess = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_imp_+3A_formula">formula</code></td>
<td>
<p>a two sided model formula (see <code><a href="stats.html#topic+formula">formula</a></code>)
or a list of such formulas; (more details below).</p>
</td></tr>
<tr><td><code id="model_imp_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing the original data
(more details below)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_n.chains">n.chains</code></td>
<td>
<p>number of MCMC chains</p>
</td></tr>
<tr><td><code id="model_imp_+3A_n.adapt">n.adapt</code></td>
<td>
<p>number of iterations for adaptation of the MCMC samplers
(see <code><a href="rjags.html#topic+adapt">adapt</a></code>)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations of the MCMC chain (after adaptation;
see <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_monitor_params">monitor_params</code></td>
<td>
<p>named list or vector specifying which parameters
should be monitored (more details below)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_auxvars">auxvars</code></td>
<td>
<p>optional; one-sided formula of variables that should be used
as predictors in the imputation procedure (and will be imputed
if necessary) but are not part of the analysis model(s).
For more details with regards to the behaviour with
non-linear effects see the vignette on
<a href="https://nerler.github.io/JointAI/articles/ModelSpecification.html#auxvars">Model Specification</a></p>
</td></tr>
<tr><td><code id="model_imp_+3A_refcats">refcats</code></td>
<td>
<p>optional; either one of <code>"first"</code>, <code>"last"</code>,
<code>"largest"</code> (which sets the category for all categorical
variables) or a named list specifying which category should
be used as reference category per categorical variable.
Options are the category label, the category number,
or one of &quot;first&quot; (the first category),
&quot;last&quot; (the last category) or &quot;largest&quot; (chooses the category
with the most observations).
Default is &quot;first&quot;. If reference categories are specified for
a subset of the categorical variables the default will be
used for the remaining variables.
(See also <code><a href="#topic+set_refcat">set_refcat</a></code>)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_models">models</code></td>
<td>
<p>optional; named vector specifying the types of models for
(incomplete) covariates.
This arguments replaces the argument <code>meth</code> used in
earlier versions.
If <code>NULL</code> (default) models will be determined
automatically based on the class of the respective columns of
<code>data</code>.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_no_model">no_model</code></td>
<td>
<p>optional; vector of names of variables for which no model
should be specified.
Note that this is only possible for completely observed
variables and implies the assumptions of independence between
the excluded variable and the incomplete variables.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_shrinkage">shrinkage</code></td>
<td>
<p>optional; either a character string naming the shrinkage
method to be used for regression coefficients in all models
or a named vector specifying the type of shrinkage to be
used in the models given as names.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_ppc">ppc</code></td>
<td>
<p>logical: should monitors for posterior predictive checks be
set? (not yet used)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_seed">seed</code></td>
<td>
<p>optional; seed value (for reproducibility)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_inits">inits</code></td>
<td>
<p>optional; specification of initial values in the form of a list
or a function (see <code><a href="rjags.html#topic+jags.model">jags.model</a></code>).
If omitted, starting values for the random number generator are
created by <strong>JointAI</strong>, initial values are then generated
by JAGS.
It is an error to supply an initial value for an observed node.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_...">...</code></td>
<td>
<p>additional, optional arguments
</p>

<dl>
<dt><code>trunc</code></dt><dd><p>named list specifying limits of truncation for the
distribution of the named incomplete variables (see the
vignette
<a href="https://nerler.github.io/JointAI/articles/ModelSpecification.html#functions-with-restricted-support">ModelSpecification</a>)</p>
</dd>
<dt><code>hyperpars</code></dt><dd><p>list of hyper-parameters, as obtained by
<code><a href="#topic+default_hyperpars">default_hyperpars</a>()</code></p>
</dd>
<dt><code>scale_vars</code></dt><dd><p>named vector of (continuous) variables that
will be centred and scaled (such that mean = 0 and sd = 1)
when they enter a linear predictor to improve
convergence of the MCMC sampling. Default is that all
numeric variables and integer variables with &gt;20 different
values will be scaled.
If set to <code>FALSE</code> no scaling will be done.</p>
</dd>
<dt><code>custom</code></dt><dd><p>named list of JAGS model chunks (character strings)
that replace the model for the given variable.</p>
</dd>
<dt><code>append_data_list</code></dt><dd><p>list that will be appended to the list
containing the data that is passed to <strong>rjags</strong>
(<code>data_list</code>). This may be necessary if additional data /
variables are needed for custom (covariate) models.</p>
</dd>
<dt><code>progress.bar</code></dt><dd><p>character string specifying the type of
progress bar. Possible values are &quot;text&quot; (default), &quot;gui&quot;,
and &quot;none&quot; (see <code><a href="rjags.html#topic+update">update</a></code>). Note: when
sampling is performed in parallel it is not possible to
display a progress bar.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>logical; if <code>TRUE</code> then messages generated by
<strong>rjags</strong> during compilation as well as the progress bar
for the adaptive phase will be suppressed,
(see <code><a href="rjags.html#topic+jags.model">jags.model</a></code>)</p>
</dd>
<dt><code>keep_scaled_mcmc</code></dt><dd><p>should the &quot;original&quot; MCMC sample (i.e.,
the scaled version returned by <code>coda.samples()</code>) be
kept? (The MCMC sample that is re-scaled to the scale of the
data is always kept.)</p>
</dd>
<dt><code>modelname</code></dt><dd><p>character string specifying the name of the
model file (including the ending, either .R or .txt). If
unspecified a random name will be generated.</p>
</dd>
<dt><code>modeldir</code></dt><dd><p>directory containing the model file or directory
in which the model file should be written. If unspecified a
temporary directory will be created.</p>
</dd>
<dt><code>overwrite</code></dt><dd><p>logical; whether an existing model file with
the specified <code>&lt;modeldir&gt;/&lt;modelname&gt;</code> should be
overwritten. If set to <code>FALSE</code> and a model already
exists, that model will be used. If unspecified (<code>NULL</code>)
and a file exists, the user is asked for input on how to
proceed.</p>
</dd>
<dt><code>keep_model</code></dt><dd><p>logical; whether the created JAGS model file
should be saved or removed from (<code>FALSE</code>; default) when
the sampling has finished.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="model_imp_+3A_family">family</code></td>
<td>
<p>only for <code>glm_imp</code> and <code>glmm_imp</code>/<code>glmer_imp</code>:
a description of the distribution and link function to
be used in the model. This can be a character string naming a
family function, a family function or the result of a call to
a family function. (For more details see below and
<code><a href="stats.html#topic+family">family</a></code>.)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_nonprop">nonprop</code></td>
<td>
<p>optional named list of one-sided formulas specifying
covariates that have non-proportional effects in cumulative
logit models. These covariates should also be part of the
regular model formula, and the names of the list should be
the names of the ordinal response variables.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_rev">rev</code></td>
<td>
<p>optional character vector; vector of ordinal outcome variable
names for which the odds should be reversed, i.e.,
<code class="reqn">logit(y\le k)</code> instead of <code class="reqn">logit(y &gt; k)</code>.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_fixed">fixed</code></td>
<td>
<p>a two sided formula describing the fixed-effects part of the
model (see <code><a href="stats.html#topic+formula">formula</a></code>)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_random">random</code></td>
<td>
<p>only for multi-level models:
a one-sided formula of the form <code>~x1 + ... + xn | g</code>,
where <code>x1 + ... + xn</code> specifies the model for the random
effects and <code>g</code> the grouping variable</p>
</td></tr>
<tr><td><code id="model_imp_+3A_rd_vcov">rd_vcov</code></td>
<td>
<p>character string or list specifying the structure of the
random effects variance covariance matrix, see details below.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_df_basehaz">df_basehaz</code></td>
<td>
<p>degrees of freedom for the B-spline used to model the
baseline hazard in proportional hazards models
(<code>coxph_imp</code> and <code>JM_imp</code>)</p>
</td></tr>
<tr><td><code id="model_imp_+3A_timevar">timevar</code></td>
<td>
<p>name of the variable indicating the time of the measurement of
a time-varying covariate in a proportional hazards survival
model (also in a joint model).
The variable specified in
&quot;timevar&quot; will automatically be added to &quot;no_model&quot;.</p>
</td></tr>
<tr><td><code id="model_imp_+3A_assoc_type">assoc_type</code></td>
<td>
<p>named vector specifying the type of the association used
for a time-varying covariate in the linear predictor of the
survival model when using a &quot;JM&quot; model.
Implemented options are &quot;underl.value&quot;
(linear predictor; default for covariates modelled using a
Gaussian, Gamma, beta or log-normal distribution)
covariates) and &quot;obs.value&quot; (the observed/imputed value;
default for covariates modelled using other distributions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+JointAIObject">JointAI</a>.
</p>


<h3>Model formulas</h3>



<h4>Random effects</h4>

<p>It is possible to specify multi-level models as it is done in the package
<a href="https://CRAN.R-project.org/package=nlme"><span class="pkg">nlme</span></a>,
using <code>fixed</code> and <code>random</code>, or as it is done in the package
<a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a>,
using <code>formula</code> and specifying the random effects in brackets:
</p>
<div class="sourceCode r"><pre>formula = y ~ x1 + x2 + x3 + (1 | id)
</pre></div>
<p>is equivalent to
</p>
<div class="sourceCode r"><pre>fixed = y ~ x1 + x2 + x3, random = ~ 1|id
</pre></div>



<h4>Multiple levels of grouping</h4>

<p>For multiple levels of grouping the specification using <code>formula</code>
should be used. There is no distinction between nested and crossed random
effects, i.e., <code>... + (1 | id) + (1 | center)</code> is treated the same as
<code>... + (1 | center/id)</code>.
</p>



<h4>Nested vs crossed random effects</h4>

<p>The distinction between nested and crossed random effects should come from
the levels of the grouping variables, i.e., if <code>id</code> is nested in
<code>center</code>, then there cannot be observations with the same <code>id</code>
but different values for <code>center</code>.
</p>



<h4>Modelling multiple models simultaneously &amp; joint models</h4>

<p>To fit multiple main models at the same time, a <code>list</code> of <code>formula</code>
objects can be passed to the argument <code>formula</code>.
Outcomes of one model may be contained as covariates in another model and
it is possible to combine models for variables on different levels,
for example:
</p>
<div class="sourceCode r"><pre>formula = list(y ~ x1 + x2 + x3 + x4 + time + (time | id),
                     x2 ~ x3 + x4 + x5)
</pre></div>
<p>This principle is also used for the specification of a joint model for
longitudinal and survival data.
</p>
<p>Note that it is not possible to specify multiple models for the same outcome
variable.
</p>


<h5>Random effects variance-covariance structure</h5>

<p>(Note: This feature is new and has not been fully tested yet.)
</p>
<p>By default, a block-diagonal structure is assumed for the variance-covariance
matrices of the random effects in models with random effects. This means that
per outcome and level random effects are assumed to be correlated, but
random effects of different outcomes are modelled as independent.
The argument <code>rd_vcov</code> allows the user specify different assumptions about
these variance-covariance matrices. Implemented structures are <code>full</code>,
<code>blockdiag</code> and <code>indep</code> (all off-diagonal elements are zero).
</p>
<p>If <code>rd_vcov</code> is set to one of these options, the structure is assumed for
all random effects variance-covariance matrices.
Alternatively, it is possible to specify a named list of vectors, where
the names are the structures and the vectors contain the names of the
response variables which are included in this structure.
</p>
<p>For example, for a multivariate mixed model with five outcomes
<code>y1</code>, ..., <code>y5</code>, the specification could be:
</p>
<div class="sourceCode r"><pre>rd_vcov = list(blockdiag = c("y1", "y2"),
               full = c("y3", "y4"),
               indep = "y5")
</pre></div>
<p>This would entail that the random effects for <code>y3</code> and <code>y4</code> are assumed to
be correlated (within and across outcomes),
random effects for <code>y1</code> and <code>y2</code> are assumed to be correlated within each
outcome, and the random effects for <code>y5</code> are assumed to be independent.
</p>
<p>It is possible to have multiple sets of response variables for which separate
full variance-covariance matrices are used, for example:
</p>
<div class="sourceCode r"><pre>rd_vcov = list(full = c("y1", "y2", "y5"),
               full = c("y3", "y4"))
</pre></div>
<p>In models with multiple levels of nesting, separate structures can be
specified per level:
</p>
<div class="sourceCode r"><pre>rd_vcov = list(id = list(blockdiag = c("y1", "y2"),
                         full = c("y3", "y4"),
                         indep = "y5"),
              center = "indep")
</pre></div>




<h4>Survival models with frailties or time-varying covariates</h4>

<p>Random effects specified in brackets can also be used to indicate a
multi-level structure in survival models, as would, for instance be needed
in a multi-centre setting, where patients are from multiple hospitals.
</p>
<p>It also allows to model time-dependent covariates in a proportional
hazards survival model (using <code>coxph_imp</code>), also in combination with
additional grouping levels.
</p>
<p>In time-dependent proportional hazards models,
last-observation-carried-forward is used to fill in missing values in the
time-varying covariates, and to determine the value of the covariate at the
event time. Preferably, all time-varying covariates should be measured at
baseline (<code>timevar = 0</code>). If a value for a time-varying covariate needs to be
filled in and there is no previous observation, the next observation will be
carried backward.
</p>



<h4>Differences to basic regression models</h4>

<p>It is not possible to specify transformations of outcome variables, i.e.,
it is not possible to use a model formula like
</p>
<div class="sourceCode r"><pre>log(y) ~ x1 + x2 + ...
</pre></div>
<p>In the specific case of a transformation with the natural logarithm,
a log-normal model can be used instead of a normal model.
</p>
<p>Moreover, it is not possible to use <code>.</code> to indicate that all variables in a
<code>data.frame</code> other than the outcome variable should be used as covariates.
I.e., a formula <code>y ~ .</code> is not valid in <strong>JointAI</strong>.
</p>



<h3>Data structure</h3>

<p>For multi-level settings, the data must be in long format, so that repeated
measurements are recorded in separate rows.
</p>
<p>For survival data with time-varying covariates (<code>coxph_imp</code> and
<code>JM_imp</code>) the data should also be in long format. The
survival/censoring times and event indicator variables must be stored in
separate variables in the same data and should be constant across all rows
referring to the same subject.
</p>
<p>During the pre-processing of the data the survival/censoring times will
automatically be merged with the observation times of the  time-varying
covariates (which must be supplied via the argument <code>timevar</code>).
</p>
<p>It is possible to have multiple time-varying covariates, which do not
have to be measured at the same time points, but there can only be one
<code>timevar</code>.
</p>


<h3>Distribution families and link functions</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>gaussian</code> </td><td style="text-align: left;"> with links: <code>identity</code>, <code>log</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>binomial</code> </td><td style="text-align: left;"> with links: <code>logit</code>, <code>probit</code>, <code>log</code>,
<code>cloglog</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Gamma</code>    </td><td style="text-align: left;"> with links: <code>inverse</code>, <code>identity</code>,
<code>log</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>poisson</code>  </td><td style="text-align: left;"> with links: <code>log</code>, <code>identity</code>
</td>
</tr>

</table>



<h3>Imputation methods / model types</h3>

<p>Implemented model types that can be chosen in the argument <code>models</code>
for baseline covariates (not repeatedly measured) are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>lm</code> </td><td style="text-align: left;"> linear (normal) model with identity link
(alternatively: <code>glm_gaussian_identity</code>); default for
continuous variables</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_gaussian_log</code> </td><td style="text-align: left;"> linear (normal) model with log link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_gaussian_inverse</code> </td><td style="text-align: left;"> linear (normal) model with inverse link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_logit</code> </td><td style="text-align: left;"> logistic model for binary data
(alternatively: <code>glm_binomial_logit</code>);
default for binary variables</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_probit</code> </td><td style="text-align: left;"> probit model for binary data
(alternatively: <code>glm_binomial_probit</code>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_binomial_log</code> </td><td style="text-align: left;"> binomial model with log link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_binomial_cloglog</code> </td><td style="text-align: left;"> binomial model with complementary
log-log link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_gamma_inverse</code> </td><td style="text-align: left;"> gamma model with inverse link for skewed
continuous data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_gamma_identity</code> </td><td style="text-align: left;"> gamma model with identity link for skewed
continuous data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_gamma_log</code> </td><td style="text-align: left;"> gamma model with log link for skewed continuous
data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_poisson_log</code> </td><td style="text-align: left;"> Poisson model with log link for count data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glm_poisson_identity</code> </td><td style="text-align: left;"> Poisson model with identity link for count
data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lognorm</code> </td><td style="text-align: left;"> log-normal model for skewed continuous data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>beta</code> </td><td style="text-align: left;"> beta model (with logit link) for skewed continuous
data in (0, 1)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mlogit</code> </td><td style="text-align: left;"> multinomial logit model for unordered categorical
variables;
default for unordered factors with &gt;2 levels</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>clm</code> </td><td style="text-align: left;"> cumulative logit model for ordered categorical variables;
default for ordered factors</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For repeatedly measured variables the following model types are available:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>lmm</code> </td><td style="text-align: left;"> linear (normal) mixed model with identity link
(alternatively: <code>glmm_gaussian_identity</code>);
default for continuous variables</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_gaussian_log</code> </td><td style="text-align: left;"> linear (normal) mixed model with log link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_gaussian_inverse</code> </td><td style="text-align: left;"> linear (normal) mixed model with
inverse link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_logit</code> </td><td style="text-align: left;"> logistic mixed model for binary data
(alternatively: <code>glmm_binomial_logit</code>);
default for binary variables</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_probit</code> </td><td style="text-align: left;"> probit model for binary data
(alternatively: <code>glmm_binomial_probit</code>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_binomial_log</code> </td><td style="text-align: left;"> binomial mixed model with log link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_binomial_cloglog</code> </td><td style="text-align: left;"> binomial mixed model with complementary
log-log link</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_gamma_inverse</code> </td><td style="text-align: left;"> gamma mixed model with inverse link for
skewed continuous data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_gamma_identity</code> </td><td style="text-align: left;"> gamma mixed model with identity link for
skewed continuous data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_gamma_log</code> </td><td style="text-align: left;"> gamma mixed model with log link for skewed
continuous data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_poisson_log</code> </td><td style="text-align: left;"> Poisson mixed model with log link for
count data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_poisson_identity</code> </td><td style="text-align: left;"> Poisson mixed model with identity link for
count data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_lognorm</code> </td><td style="text-align: left;"> log-normal mixed model for skewed covariates</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>glmm_beta</code> </td><td style="text-align: left;"> beta mixed model for continuous data in (0, 1)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mlogitmm</code> </td><td style="text-align: left;"> multinomial logit mixed model for unordered categorical
variables;
default for unordered factors with &gt;2 levels</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>clmm</code> </td><td style="text-align: left;"> cumulative logit mixed model for ordered factors;
default for ordered factors
</td>
</tr>

</table>

<p>When models are specified for only a subset of the variables for which a
model is needed, the default model choices (as indicated in the tables)
are used for the unspecified variables.
</p>


<h3>Parameters to follow (<code>monitor_params</code>)</h3>

<p>See also the vignette:
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a><br />
</p>
<p>Named vector specifying which parameters should be monitored. This can be
done either directly by specifying the name of the parameter or indirectly
by one of the key words selecting a set of parameters.
Except for <code>other</code>, in which parameter names are specified directly,
parameter (groups) are just set as <code>TRUE</code> or <code>FALSE</code>.
</p>
<p>Models are divided into two groups, the main models, which are the models
for which the user has explicitly specified a formula (via <code>formula</code>
or <code>fixed</code>), and all other models, for which models were specified
automatically.
</p>
<p>If left unspecified, <code>monitor_params = c("analysis_main" = TRUE)</code>
will be used.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>name/key word</strong> </td><td style="text-align: left;"> <strong>what is monitored</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>analysis_main</code> </td><td style="text-align: left;"> <code>betas</code> and <code>sigma_main</code>, <code>tau_main</code>
(for beta regression) or <code>shape_main</code>
(for parametric survival models), <code>gamma_main</code>
(for cumulative logit models),
codeD_main (for multi-level models) and
<code>basehaz</code> in proportional hazards models)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>analysis_random</code> </td><td style="text-align: left;"> <code>ranef_main</code>, <code>D_main</code>,
<code>invD_main</code>, <code>RinvD_main</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>other_models</code> </td><td style="text-align: left;"> <code>alphas</code>, <code>tau_other</code>, <code>gamma_other</code>,
<code>delta_other</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>imps</code> </td><td style="text-align: left;"> imputed values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>betas</code> </td><td style="text-align: left;"> regression coefficients of the main analysis model</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_main</code> </td><td style="text-align: left;"> precision of the residuals from the main analysis
model(s)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sigma_main</code> </td><td style="text-align: left;"> standard deviation of the residuals from the main
analysis model(s)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>gamma_main</code> </td><td style="text-align: left;"> intercepts in ordinal main model(s)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>delta_main</code> </td><td style="text-align: left;"> increments of ordinal main model(s)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ranef_main</code> </td><td style="text-align: left;"> random effects from the main analysis model(s)
<code>b</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>D_main</code> </td><td style="text-align: left;"> covariance matrix of the random effects from the
main model(s)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>invD_main</code> </td><td style="text-align: left;"> inverse(s) of <code>D_main</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>RinvD_main</code> </td><td style="text-align: left;"> matrices in the priors for <code>invD_main</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>alphas</code> </td><td style="text-align: left;"> regression coefficients in the covariate models</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tau_other</code> </td><td style="text-align: left;"> precision parameters of the residuals from
covariate models</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>gamma_other</code> </td><td style="text-align: left;"> intercepts in ordinal covariate models</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>delta_other</code> </td><td style="text-align: left;"> increments of ordinal intercepts</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ranef_other</code> </td><td style="text-align: left;"> random effects from the other  models <code>b</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>D_other</code> </td><td style="text-align: left;"> covariance matrix of the random effects from the
other models</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>invD_other</code> </td><td style="text-align: left;"> inverses of <code>D_other</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>RinvD_other</code> </td><td style="text-align: left;"> matrices in the priors for <code>invD_other</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>other</code> </td><td style="text-align: left;"> additional parameters
</td>
</tr>

</table>

<p><strong>For example:</strong><br />
<code>monitor_params = c(analysis_main = TRUE, tau_main = TRUE,
sigma_main = FALSE)</code>
would monitor the regression parameters <code>betas</code> and the
residual precision <code>tau_main</code> instead of the residual standard
deviation <code>sigma_main</code>.
</p>
<p>For a linear model, <code>monitor_params = c(imps = TRUE)</code> would monitor
<code>betas</code>, and <code>sigma_main</code> (because <code>analysis_main = TRUE</code> by
default) as well as the imputed values.
</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>


<h3>Cumulative logit (mixed) models</h3>

<p>In the default setting for cumulative logit models, i.e, <code>rev = NULL</code>, the
odds for a variable \(y\) with \(K\) ordered categories
are defined as \[\log\left(\frac{P(y_i > k)}{P(y_i \leq k)}\right) =
\gamma_k + \eta_i, \quad k = 1, \ldots, K-1,\] where
\(\gamma_k\) is a category specific intercept and
\(\eta_i\) the subject specific linear predictor.
</p>
<p>To reverse the odds to \[\log\left(\frac{P(y_i \leq k)}{P(y_i >
k)}\right) = \gamma_k + \eta_i, \quad k = 1, \ldots, K-1,\] the name of
the response variable has to be specified in the argument <code>rev</code>, e.g., <code>rev = c("y")</code>.
</p>
<p>By default, proportional odds are assumed and only the intercepts differ
per category of the ordinal response. To allow for non-proportional odds,
i.e.,
\[\log\left(\frac{P(y_i > k)}{P(y_i \leq k)}\right) =
\gamma_k + \eta_i + \eta_{ki}, \quad k = 1, \ldots, K-1,\]
the argument <code>nonprop</code> can be specified. It takes a one-sided formula or
a list of one-sided formulas. When a single formula is supplied, or a
unnamed list with just one element, it is assumed that the formula
corresponds to the main model.
To specify non-proportional effects for linear predictors in models for
ordinal covariates, the list has to be named with the names of the
ordinal response variables.
</p>
<p>For example, the following three specifications are equivalent and assume a
non-proportional effect of <code>C1</code> on <code>O1</code>, but <code>C1</code> is assumed to have a
proportional effect on the incomplete ordinal covariate <code>O2</code>:
</p>
<div class="sourceCode r"><pre>clm_imp(O1 ~ C1 + C2 + B2 + O2, data = wideDF, nonprop = ~ C1)
clm_imp(O1 ~ C1 + C2 + B2 + O2, data = wideDF, nonprop = list(~ C1))
clm_imp(O1 ~ C1 + C2 + B2 + O2, data = wideDF, nonprop = list(O1 = ~ C1))
</pre></div>
<p>To specify non-proportional effects on <code>O2</code>, a named list has to be provided:
</p>
<div class="sourceCode r"><pre>clm_imp(O1 ~ C1 + C2 + B2 + O2 + B1, data = wideDF,
        nonprop = list(O1 = ~ C1,
                       O2 = ~ C1 + B1))
</pre></div>
<p>The variables for which a non-proportional effect is assumed also have to be
part of the regular model formula.
</p>


<h3>Custom model parts</h3>

<p>(Note: This feature is experimental and has not been fully tested yet.)
</p>
<p>Via the argument <code>custom</code> it is possible to provide custom sub-models that
replace the sub-models that are automatically generated by <strong>JointAI</strong>.
</p>
<p>Using this feature it is, for instance, possible to use the value of
a repeatedly measured variable at a specific time point as covariate in
another model. An example would be the use of &quot;baseline&quot; cholesterol
(<code>chol</code> at <code>day = 0</code>) as covariate in a survival model.
</p>
<p>First, the variable <code>chol0</code> is added to the <code>PBC</code> data.
For most patients the value of cholesterol at baseline is observed, but not
for all. It is important that the data has a row with <code>day = 0</code> for each
patient.
</p>
<div class="sourceCode r"><pre>PBC &lt;- merge(PBC,
             subset(PBC, day == 0, select = c("id", "chol")),
             by = "id", suffixes = c("", "0"))
</pre></div>
<p>Next, the custom piece of JAGS model syntax needs to be specified.
We loop here only over the patients for which the baseline cholesterol
is missing.
</p>
<div class="sourceCode r"><pre>calc_chol0 &lt;- "
for (ii in 1:28) {
  M_id[row_chol0_id[ii], 3] &lt;- M_lvlone[row_chol0_lvlone[ii], 1]
  }"
</pre></div>
<p>To be able to run the model with the custom imputation &quot;model&quot; for baseline
cholesterol we need to provide the numbers of the rows in the data matrices
that contain the missing values of baseline cholesterol and the rows that
contain the imputed cholesterol at <code>day = 0</code>:
</p>
<div class="sourceCode r"><pre>row_chol0_lvlone &lt;- which(PBC$day == 0 &amp; is.na(PBC$chol0))
row_chol0_id &lt;- match(PBC$id, unique(PBC$id))[row_chol0_lvlone]
</pre></div>
<p>Then we pass both the custom sub-model and the additional data to the
analysis function <code>coxph_imp()</code>. Note that we explicitly need to specify
the model for <code>chol</code>.
</p>
<div class="sourceCode r"><pre>coxph_imp(list(Surv(futime, status != "censored") ~ age + sex + chol0,
               chol ~ age + sex + day + (day | id)),
          no_model = "day", data = PBC,
          append_data_list = list(row_chol0_lvlone = row_chol0_lvlone,
                                  row_chol0_id = row_chol0_id),
          custom = list(chol0 = calc_chol0))
</pre></div>


<h3>Note</h3>



<h4>Coding of variables:</h4>

<p>The default covariate (imputation) models are chosen based on the
<code>class</code> of each of the variables, distinguishing between <code>numeric</code>,
<code>factor</code> with two levels, unordered <code>factor</code> with &gt;2 levels and
ordered <code>factor</code> with &gt;2 levels.<br />
</p>
<p>When a continuous variable has only two different values it is
assumed to be binary and its coding and default (imputation) model will be
changed accordingly. This behaviour can be overwritten specifying a model
type via the argument <code>models</code>.<br />
</p>
<p>Variables of type <code>logical</code> are automatically converted to unordered
factors.<br />
</p>


<h5>Contrasts</h5>

<p><strong>JointAI</strong> version \(\geq\) 1.0.0 uses the globally (via
<code>options("contrasts")</code>) specified contrasts. However, for incomplete
categorical variables, for which the contrasts need to be re-calculated
within the JAGS model, currently only <code>contr.treatment</code> and <code>contr.sum</code> are
possible. Therefore, when an in complete ordinal covariate is used and the
default contrasts (<code>contr.poly()</code>) are set to be used for ordered factors, a
warning message is printed and dummy coding (<code>contr.treatment()</code>) is used for
that variable instead.
</p>




<h4>Non-linear effects and transformation of variables:</h4>

<p><strong>JointAI</strong> handles non-linear effects, transformation of covariates
and interactions the following way:<br />
When, for instance, a model formula contains the function <code>log(x)</code> and
<code>x</code> has missing values, <code>x</code> will be imputed and used in the linear
predictor of models for which no formula was specified,
i.e., it is assumed that the other variables have a linear association with
<code>x</code>. The <code>log()</code> of the observed and imputed values of
<code>x</code> is calculated and used in the linear predictor of the main
analysis model.<br />
</p>
<p>If, instead of using <code>log(x)</code> in the model formula, a pre-calculated
variable <code>logx</code> is used, this variable is imputed directly
and used in the linear predictors of all models, implying that
variables that have <code>logx</code> in their linear predictors have a linear
association with <code>logx</code> but not with <code>x</code>.<br />
</p>
<p>When different transformations of the same incomplete variable are used in
one model it is strongly discouraged to calculate these transformations
beforehand and supply them as different variables.
If, for example, a model formula contains both <code>x</code> and <code>x2</code> (where
<code>x2</code> = <code>x^2</code>), they are treated as separate variables and imputed
with separate models. Imputed values of <code>x2</code> are thus not equal to the
square of imputed values of <code>x</code>.
Instead, <code>x</code> and <code>I(x^2)</code> should be used in the model formula.
Then only <code>x</code> is imputed and <code>x^2</code> is calculated from the imputed
values of <code>x</code> internally.
</p>
<p>The same applies to interactions involving incomplete variables.
</p>



<h4>Sequence of models:</h4>

<p>Models generated automatically (i.e., not mentioned in <code>formula</code> or <code>fixed</code>
are specified in a sequence based on the level of the outcome of the
respective model in the multi-level hierarchy and within each level
according to the number of missing values.
This means that level-1 variables have all level-2, level-3, ... variables
in their linear predictor, and variables on the highest level only have
variables from the same level in their linear predictor.
Within each level, the variable with the most missing values has the most
variables in its linear predictor.
</p>



<h4>Not (yet) possible:</h4>


<ul>
<li><p> prediction (using <code>predict</code>) conditional on random effects
</p>
</li>
<li><p> the use of splines for incomplete variables
</p>
</li>
<li><p> the use of (or equivalents for) <code><a href="survival.html#topic+pspline">pspline</a></code>,
or <code><a href="survival.html#topic+strata">strata</a></code> in survival models
</p>
</li>
<li><p> left censored or interval censored data
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+set_refcat">set_refcat</a></code>,
<code><a href="#topic+traceplot">traceplot</a></code>, <code><a href="#topic+densplot">densplot</a></code>,
<code><a href="#topic+summary.JointAI">summary.JointAI</a></code>, <code><a href="#topic+MC_error">MC_error</a></code>,
<code><a href="#topic+GR_crit">GR_crit</a></code>,
<code><a href="#topic+predict.JointAI">predict.JointAI</a></code>, <code><a href="#topic+add_samples">add_samples</a></code>,
<code><a href="#topic+JointAIObject">JointAIObject</a></code>, <code><a href="#topic+add_samples">add_samples</a></code>,
<code><a href="#topic+parameters">parameters</a></code>, <code><a href="#topic+list_models">list_models</a></code>
</p>
<p>Vignettes
</p>

<ul>
<li> <p><a href="https://nerler.github.io/JointAI/articles/MinimalExample.html">Minimal Example</a>
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/ModelSpecification.html">Model Specification</a>
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/MCMCsettings.html">MCMC Settings</a>
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/AfterFitting.html">After Fitting</a>
</p>
</li>
<li> <p><a href="https://nerler.github.io/JointAI/articles/TheoreticalBackground.html">Theoretical Background</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Linear regression with incomplete covariates
mod1 &lt;- lm_imp(y ~ C1 + C2 + M1 + B1, data = wideDF, n.iter = 100)


# Example 2: Logistic regression with incomplete covariates
mod2 &lt;- glm_imp(B1 ~ C1 + C2 + M1, data = wideDF,
                family = binomial(link = "logit"), n.iter = 100)

## Not run: 

# Example 3: Linear mixed model with incomplete covariates
mod3 &lt;- lme_imp(y ~ C1 + B2 + c1 + time, random = ~ time|id,
                data = longDF, n.iter = 300)


# Example 4: Parametric Weibull survival model
mod4 &lt;- survreg_imp(Surv(time, status) ~ age + sex + meal.cal + wt.loss,
                    data = survival::lung, n.iter = 100)


# Example 5: Proportional hazards survival model
mod5 &lt;- coxph_imp(Surv(time, status) ~ age + sex + meal.cal + wt.loss,
                    data = survival::lung, n.iter = 200)

# Example 6: Joint model for longitudinal and survival data
mod6 &lt;- JM_imp(list(Surv(futime, status != 'censored') ~ age + sex +
                    albumin + copper + trig + (1 | id),
                    albumin ~ day + age + sex + (day | id)),
                    timevar = 'day', data = PBC, n.iter = 100)

# Example 7: Proportional hazards  model with a time-dependent covariate
mod7 &lt;- coxph_imp(Surv(futime, status != 'censored') ~ age + sex + copper +
                  trig + stage + (1 | id),
                  timevar = 'day', data = PBC, n.iter = 100)



# Example 8: Parallel computation
# If no strategy how the "future" should be handled is specified, the
# MCMC chains are run sequentially.
# To run MCMC chains in parallel, a strategy can be specified using the
# package \pkg{future} (see ?future::plan), for example:
future::plan(future::multisession, workers = 4)
mod8 &lt;- lm_imp(y ~ C1 + C2 + B2, data = wideDF, n.iter = 500, n.chains = 8)
mod8$comp_info$future
# To re-set the strategy to sequential computation, the sequential strategy
# can be specified:
future::plan(future::sequential)


## End(Not run)

</code></pre>

<hr>
<h2 id='NHANES'>National Health and Nutrition Examination Survey (NHANES) Data</h2><span id='topic+NHANES'></span>

<h3>Description</h3>

<p>This data is a small subset of the data collected within the 2011-2012 wave
of the NHANES study, a study designed to assess the health and nutritional
status of adults and children in the United States, conduced by the
<a href="https://www.cdc.gov/nchs/">National Center for Health Statistics</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NHANES)
</code></pre>


<h3>Format</h3>

<p>A data frame with 186 rows and 13 variables:
</p>

<dl>
<dt>SBP</dt><dd><p>systolic blood pressure</p>
</dd>
<dt>gender</dt><dd><p>male or female</p>
</dd>
<dt>age</dt><dd><p>in years</p>
</dd>
<dt>race</dt><dd><p>race / Hispanic origin (5 categories)</p>
</dd>
<dt>WC</dt><dd><p>waist circumference in cm</p>
</dd>
<dt>alc</dt><dd><p>alcohol consumption (binary: &lt;1 drink per week vs. &gt;= 1 drink
per week)</p>
</dd>
<dt>educ</dt><dd><p>educational level (binary: low vs. high)</p>
</dd>
<dt>creat</dt><dd><p>creatinine concentration in mg/dL</p>
</dd>
<dt>albu</dt><dd><p>albumin concentration in g/dL</p>
</dd>
<dt>uricacid</dt><dd><p>uric acid concentration in mg/dL</p>
</dd>
<dt>bili</dt><dd><p>bilirubin concentration in mg/dL</p>
</dd>
<dt>occup</dt><dd><p>occupational status (3 categories)</p>
</dd>
<dt>smoke</dt><dd><p>smoking status (3 ordered categories)</p>
</dd>
</dl>



<h3>Note</h3>

<p>The subset provided here was selected and re-coded to facilitate
demonstration of the functionality of the JointAI package,
and no clinical conclusions should be derived from it.
</p>


<h3>Source</h3>

<p>National Center for Health Statistics (NCHS) (2011 - 2012).
National Health and Nutrition Examination Survey Data.
URL <a href="https://www.cdc.gov/nchs/nhanes/">https://www.cdc.gov/nchs/nhanes/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(NHANES)
</code></pre>

<hr>
<h2 id='ns'>Generate a Basis Matrix for Natural Cubic Splines</h2><span id='topic+ns'></span>

<h3>Description</h3>

<p>This function just calls <code>ns()</code> from the
<a href="https://CRAN.R-project.org/package=splines"><strong>splines</strong></a>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ns(x, df = NULL, knots = NULL, intercept = FALSE,
  Boundary.knots = range(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ns_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="ns_+3A_df">df</code></td>
<td>
<p>degrees of freedom.  One can supply <code>df</code> rather than
knots; <code>ns()</code> then chooses <code>df - 1 - intercept</code> knots at
suitably chosen quantiles of <code>x</code> (which will ignore missing
values).  The default, <code>df = NULL</code>, sets the number of
inner knots as <code>length(knots)</code>.</p>
</td></tr>
<tr><td><code id="ns_+3A_knots">knots</code></td>
<td>
<p>breakpoints that define the spline.  The default is no
knots; together with the natural boundary conditions this results in
a basis for linear regression on <code>x</code>.  Typical values are the
mean or median for one knot, quantiles for more knots.  See also
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="ns_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the
basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ns_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to impose the natural
boundary conditions and anchor the B-spline basis (default the range
of the data).  If both <code>knots</code> and <code>Boundary.knots</code> are
supplied, the basis parameters do not depend on <code>x</code>. Data can
extend beyond <code>Boundary.knots</code></p>
</td></tr>
</table>

<hr>
<h2 id='parameters'>Parameter names of an JointAI object</h2><span id='topic+parameters'></span>

<h3>Description</h3>

<p>Returns the names of the parameters/nodes of an object of class 'JointAI' for
which a monitor is set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(object, expand_ranef = FALSE, mess = TRUE, warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="parameters_+3A_expand_ranef">expand_ranef</code></td>
<td>
<p>logical; should all elements of the random effects
vectors/matrices be shown separately?</p>
</td></tr>
<tr><td><code id="parameters_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="parameters_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="parameters_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># (This function does not need MCMC samples to work, so we will set
# n.adapt = 0 and n.iter = 0 to reduce computational time)
mod1 &lt;- lm_imp(y ~ C1 + C2 + M2 + O2 + B2, data = wideDF, n.adapt = 0,
               n.iter = 0, mess = FALSE)

parameters(mod1)

</code></pre>

<hr>
<h2 id='paste_coef'>Write the coefficient part of a linear predictor</h2><span id='topic+paste_coef'></span>

<h3>Description</h3>

<p>Write the coefficient part of a linear predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_coef(parname, parelmts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_coef_+3A_parname">parname</code></td>
<td>
<p>character string; name of the coefficient (e.g., &quot;beta&quot;)</p>
</td></tr>
<tr><td><code id="paste_coef_+3A_parlemts">parlemts</code></td>
<td>
<p>vector of integers; the index of the parameter vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character strings of the form <code>beta[3]</code>.
</p>

<hr>
<h2 id='paste_data'>Write the data element of a linear predictor</h2><span id='topic+paste_data'></span>

<h3>Description</h3>

<p>Write the data element of a linear predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_data(matnam, index, col, isgk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_data_+3A_matnam">matnam</code></td>
<td>
<p>characters string; name of the data matrix</p>
</td></tr>
<tr><td><code id="paste_data_+3A_index">index</code></td>
<td>
<p>character string; the index (e.g., &quot;i&quot;, or &quot;ii&quot;)</p>
</td></tr>
<tr><td><code id="paste_data_+3A_col">col</code></td>
<td>
<p>integer vector; the indices of the columns in <code>matnam</code></p>
</td></tr>
<tr><td><code id="paste_data_+3A_isgk">isgk</code></td>
<td>
<p>logical; is this for within the Gauss-Kronrod quadrature?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character strings of the form
<code>M_id[i, 3]</code> or <code>M_id[i, 3, k]</code>.
</p>

<hr>
<h2 id='paste_linpred'>Write a linear predictor</h2><span id='topic+paste_linpred'></span>

<h3>Description</h3>

<p>Construct a linear predictor from parameter names and indices, the name of
the data matrix and corresponding columns, and apply scaling to the data
if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_linpred(parname, parelmts, matnam, index, cols, scale_pars,
  isgk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_linpred_+3A_parname">parname</code></td>
<td>
<p>character string; name fo the parameter (e.g., &quot;beta&quot;)</p>
</td></tr>
<tr><td><code id="paste_linpred_+3A_index">index</code></td>
<td>
<p>character string; name of the index (e.g., &quot;i&quot; or &quot;ii&quot;)</p>
</td></tr>
<tr><td><code id="paste_linpred_+3A_cols">cols</code></td>
<td>
<p>integer vector; indices of the columns of <code>matname</code>, should have
the same length as <code>parlemts</code></p>
</td></tr>
<tr><td><code id="paste_linpred_+3A_scale_pars">scale_pars</code></td>
<td>
<p>matrix with row names according to the column names of
<code>matname</code> and columns &quot;center&quot; and &quot;scale&quot;; or NULL</p>
</td></tr>
<tr><td><code id="paste_linpred_+3A_isgk">isgk</code></td>
<td>
<p>logical; is this linear predictor within the Gauss-Kronrod
quadrature?</p>
</td></tr>
<tr><td><code id="paste_linpred_+3A_parlemts">parlemts</code></td>
<td>
<p>integer vector; indices of the parameter vector to be used;
should have the same length as <code>cols</code></p>
</td></tr>
<tr><td><code id="paste_linpred_+3A_matname">matname</code></td>
<td>
<p>character string; name of the data matrix</p>
</td></tr>
</table>

<hr>
<h2 id='paste_scale'>Create the scaling in a data element of a linear predictor</h2><span id='topic+paste_scale'></span>

<h3>Description</h3>

<p>Create the scaling in a data element of a linear predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_scale(x, row, scalemat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_scale_+3A_x">x</code></td>
<td>
<p>a character string</p>
</td></tr>
<tr><td><code id="paste_scale_+3A_row">row</code></td>
<td>
<p>integer; indicating the row of <code>scalemat</code> to be used</p>
</td></tr>
<tr><td><code id="paste_scale_+3A_scalemat">scalemat</code></td>
<td>
<p>character string; name of the matrix containing the scaling
information (e.g., &quot;spM_lvlone&quot;). This matrix is assumed to
have columns &quot;center&quot; and &quot;scale&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string of the form <code>(x - center)/scale</code>.
</p>

<hr>
<h2 id='paste_scaling'>Wrap a data element of a linear predictor in scaling syntax</h2><span id='topic+paste_scaling'></span>

<h3>Description</h3>

<p>Identifies if a data element of a linear predictor should be scaled (based
on whether scaling parameters are given) and then calls <code>paste_scale()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_scaling(x, rows, scale_pars, scalemat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_scaling_+3A_x">x</code></td>
<td>
<p>vector of character strings; to be scaled, typically matrix columns</p>
</td></tr>
<tr><td><code id="paste_scaling_+3A_rows">rows</code></td>
<td>
<p>integer vector; row numbers of the matrix containing the scaling
information</p>
</td></tr>
<tr><td><code id="paste_scaling_+3A_scale_pars">scale_pars</code></td>
<td>
<p>matrix containing the scaling information, with columns
&quot;center&quot; and &quot;scale&quot;</p>
</td></tr>
<tr><td><code id="paste_scaling_+3A_scalemat">scalemat</code></td>
<td>
<p>the name of the scaling matrix in the JAGS model
(e.g. &quot;spM_id&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code>paste_scale()</code> on each element of <code>x</code>.
</p>

<hr>
<h2 id='PBC'>PBC data</h2><span id='topic+PBC'></span>

<h3>Description</h3>

<p>Data from the Mayo Clinic trial in primary biliary cirrhosis (PBC) of the
liver. This dataset was obtained from the <strong>survival</strong> package:
the variables <code>copper</code> and <code>trig</code> from <code>survival::pbc</code> were
merged into <code>survival::pbcseq</code> and several categorical variables were
re-coded.
</p>


<h3>Format</h3>

<p><code>PBC</code>: A data frame of 312 individuals in long format with 1945 rows
and 21 variables.
</p>


<h3>Survival outcome and id</h3>


<dl>
<dt>id</dt><dd><p>case number</p>
</dd>
<dt>futime</dt><dd><p>number of days between registration and the earlier of death,
transplantation, or end of follow-up</p>
</dd>
<dt>status</dt><dd><p>status at endpoint (&quot;censored&quot;, &quot;transplant&quot; or &quot;dead&quot;)</p>
</dd>
</dl>



<h3>Baseline covariates</h3>


<dl>
<dt>trt</dt><dd><p>D-pen (D-penicillamine) vs  placebo</p>
</dd>
<dt>age</dt><dd><p>in years</p>
</dd>
<dt>sex</dt><dd><p>male or female</p>
</dd>
<dt>copper</dt><dd><p>urine copper (<code class="reqn">\mu</code>g/day)</p>
</dd>
<dt>trig</dt><dd><p>triglycerides (mg/dl)</p>
</dd>
</dl>



<h3>Time-varying covariates</h3>


<dl>
<dt>day</dt><dd><p>number of days between enrolment and this visit date; all
measurements below refer to this date</p>
</dd>
<dt>albumin</dt><dd><p>serum albumin (mg/dl)</p>
</dd>
<dt>alk.phos</dt><dd><p>alkaline phosphatase (U/liter)</p>
</dd>
<dt>ascites</dt><dd><p>presence of ascites</p>
</dd>
<dt>ast</dt><dd><p>aspartate aminotransferase (U/ml)</p>
</dd>
<dt>bili</dt><dd><p>serum bilirubin (mg/dl)</p>
</dd>
<dt>chol</dt><dd><p>serum cholesterol (mg/dl)</p>
</dd>
<dt>edema</dt><dd><p>&quot;no&quot;: no oedema,
&quot;(un)treated&quot;: untreated or successfully treated 1 oedema,
&quot;edema&quot;: oedema despite diuretic therapy</p>
</dd>
<dt>hepato</dt><dd><p>presence of hepatomegaly (enlarged liver)</p>
</dd>
<dt>platelet</dt><dd><p>platelet count</p>
</dd>
<dt>protime</dt><dd><p>standardised blood clotting time</p>
</dd>
<dt>spiders</dt><dd><p>blood vessel malformations in the skin</p>
</dd>
<dt>stage</dt><dd><p>histologic stage of disease (4 levels)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> summary(PBC)

</code></pre>

<hr>
<h2 id='plot_all'>Visualize the distribution of all variables in the dataset</h2><span id='topic+plot_all'></span>

<h3>Description</h3>

<p>This function plots a grid of histograms (for continuous variables) and
bar plots (for categorical variables) and labels it with the proportion of
missing values in each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all(data, nrow = NULL, ncol = NULL, fill = grDevices::grey(0.8),
  border = "black", allNA = FALSE, idvars = NULL, xlab = "",
  ylab = "frequency", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_all_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> (or a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="plot_all_+3A_nrow">nrow</code></td>
<td>
<p>optional; number of rows in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="plot_all_+3A_ncol">ncol</code></td>
<td>
<p>optional; number of columns in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="plot_all_+3A_fill">fill</code></td>
<td>
<p>colour the histograms and bars are filled with</p>
</td></tr>
<tr><td><code id="plot_all_+3A_border">border</code></td>
<td>
<p>colour of the borders of the histograms and bars</p>
</td></tr>
<tr><td><code id="plot_all_+3A_allna">allNA</code></td>
<td>
<p>logical; if <code>FALSE</code> (default) the proportion of missing
values is only given for variables that have missing values,
if <code>TRUE</code> it is given for all variables</p>
</td></tr>
<tr><td><code id="plot_all_+3A_idvars">idvars</code></td>
<td>
<p>name of the column that specifies the multi-level grouping
structure</p>
</td></tr>
<tr><td><code id="plot_all_+3A_xlab">xlab</code>, <code id="plot_all_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x- and y-axis</p>
</td></tr>
<tr><td><code id="plot_all_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>
and <code><a href="graphics.html#topic+hist">hist</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Vignette: <a href="https://nerler.github.io/JointAI/articles/VisualizingIncompleteData.html">Visualizing Incomplete Data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(mar = c(2,2,3,1), mgp = c(2, 0.6, 0))
plot_all(wideDF)
par(op)

</code></pre>

<hr>
<h2 id='plot_imp_distr'>Plot the distribution of observed and imputed values</h2><span id='topic+plot_imp_distr'></span>

<h3>Description</h3>

<p>Plots densities and bar plots of the observed and imputed values in a
long-format dataset (multiple imputed datasets stacked onto each other).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_imp_distr(data, imp = "Imputation_", id = ".id", rownr = ".rownr",
  ncol = NULL, nrow = NULL, labeller = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_imp_distr_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing multiple imputations
and the original incomplete data stacked onto each other</p>
</td></tr>
<tr><td><code id="plot_imp_distr_+3A_imp">imp</code></td>
<td>
<p>the name of the variable specifying the imputation indicator</p>
</td></tr>
<tr><td><code id="plot_imp_distr_+3A_id">id</code></td>
<td>
<p>the name of the variable specifying the subject indicator</p>
</td></tr>
<tr><td><code id="plot_imp_distr_+3A_rownr">rownr</code></td>
<td>
<p>the name of a variable identifying which rows correspond to the
same observation in the original (un-imputed) data</p>
</td></tr>
<tr><td><code id="plot_imp_distr_+3A_ncol">ncol</code></td>
<td>
<p>optional; number of columns in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="plot_imp_distr_+3A_nrow">nrow</code></td>
<td>
<p>optional; number of rows in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="plot_imp_distr_+3A_labeller">labeller</code></td>
<td>
<p>optional labeller to be passed to
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>
to change the facet labels</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
mod &lt;- lme_imp(y ~ C1 + c2 + B2 + C2, random = ~ 1 | id, data = longDF,
               n.iter = 200, monitor_params = c(imps = TRUE), mess = FALSE)
impDF &lt;- get_MIdat(mod, m = 5)
plot_imp_distr(impDF, id = "id", ncol = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.JointAI'>Plot an object object inheriting from class 'JointAI'</h2><span id='topic+plot.JointAI'></span>

<h3>Description</h3>

<p>Plot an object object inheriting from class 'JointAI'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JointAI'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.JointAI_+3A_x">x</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="plot.JointAI_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, <code>plot()</code> can only be used with (generalized) linear (mixed)
models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm_imp(y ~ C1 + C2 + B1, data = wideDF, n.iter = 100)
plot(mod)

</code></pre>

<hr>
<h2 id='predDF'>Create a new data frame for prediction</h2><span id='topic+predDF'></span><span id='topic+predDF.JointAI'></span><span id='topic+predDF.formula'></span><span id='topic+predDF.list'></span>

<h3>Description</h3>

<p>Build a <code>data.frame</code> for prediction, where one variable varies and all
other variables are set to the reference value (median for continuous
variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predDF(object, ...)

## S3 method for class 'JointAI'
predDF(object, vars, length = 100L, ...)

## S3 method for class 'formula'
predDF(object, data, vars, length = 100L, ...)

## S3 method for class 'list'
predDF(object, data, vars, length = 100L, idvar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predDF_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="predDF_+3A_...">...</code></td>
<td>
<p>optional specification of the values used for some (or all) of the
variables given in <code>vars</code></p>
</td></tr>
<tr><td><code id="predDF_+3A_vars">vars</code></td>
<td>
<p>name of variable that should be varying</p>
</td></tr>
<tr><td><code id="predDF_+3A_length">length</code></td>
<td>
<p>number of values used in the sequence when <code>vars</code> is
continuous</p>
</td></tr>
<tr><td><code id="predDF_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing the original data
(more details below)</p>
</td></tr>
<tr><td><code id="predDF_+3A_idvar">idvar</code></td>
<td>
<p>optional name of an ID variable</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict.JointAI">predict.JointAI</a></code>, <code><a href="#topic+lme_imp">lme_imp</a></code>,
<code><a href="#topic+glm_imp">glm_imp</a></code>, <code><a href="#topic+lm_imp">lm_imp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a JointAI model
mod &lt;- lm_imp(y ~ C1 + C2 + M2, data = wideDF, n.iter = 100)

# generate a data frame with varying "C2" and reference values for all other
# variables in the model
newDF &lt;- predDF(mod, vars = ~ C2)

head(newDF)


newDF2 &lt;- predDF(mod, vars = ~ C2 + M2,
                 C2 = seq(-0.5, 0.5, 0.25),
                 M2 = levels(wideDF$M2)[2:3])
newDF2

</code></pre>

<hr>
<h2 id='predict.JointAI'>Predict values from an object of class JointAI</h2><span id='topic+predict.JointAI'></span>

<h3>Description</h3>

<p>Obtains predictions and corresponding credible intervals from an object of
class 'JointAI'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JointAI'
predict(object, outcome = 1L, newdata,
  quantiles = c(0.025, 0.975), type = "lp", start = NULL, end = NULL,
  thin = NULL, exclude_chains = NULL, mess = TRUE, warn = TRUE,
  return_sample = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.JointAI_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_outcome">outcome</code></td>
<td>
<p>vector of variable names or integers identifying for which
outcome(s) the prediction should be performed.</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_newdata">newdata</code></td>
<td>
<p>optional new dataset for prediction. If left empty, the
original data is used.</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_quantiles">quantiles</code></td>
<td>
<p>quantiles of the predicted distribution of the outcome</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_type">type</code></td>
<td>
<p>the type of prediction. The default is on the scale of the linear
predictor (<code>"link"</code> or <code>"lp"</code>). Additionally, for generalized
linear (mixed) models (incl. beta and log-normal) <code>type = "response"</code>
transforms the predicted values to the scale of the response, and for
ordinal and multinomial (mixed) models <code>type</code> may be <code>"prob"</code> (to
obtain probabilities per class), <code>"class"</code> to obtain the class with
the highest posterior probability, or <code>"lp"</code>. For parametric survival
models <code>type</code> can be <code>"lp" </code> or &quot;response&quot;, and for proportional
hazards survival models the options are <code>"lp"</code>, <code>"risk"</code> (=
<code>exp(lp)</code>), <code>"survival"</code> or <code>"expected"</code> (=
<code>-log(survival)</code>).</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_return_sample">return_sample</code></td>
<td>
<p>logical; should the full sample on which the summary
(mean and quantiles) is calculated be returned?#'</p>
</td></tr>
<tr><td><code id="predict.JointAI_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>model.matrix</code> <code class="reqn">X</code> is created from the model formula
(currently fixed effects only) and <code>newdata</code>. <code class="reqn">X\beta</code> is then
calculated for each iteration of the MCMC sample in <code>object</code>, i.e.,
<code class="reqn">X\beta</code> has <code>n.iter</code> rows and <code>nrow(newdata)</code> columns. A
subset of the MCMC sample can be selected using <code>start</code>, <code>end</code>
and  <code>thin</code>.
</p>


<h3>Value</h3>

<p>A list with entries <code>dat</code>, <code>fit</code> and <code>quantiles</code>,
where <code>fit</code> contains the predicted values (mean over the values
calculated from the iterations of the MCMC sample), <code>quantiles</code>
contain the specified quantiles (by default 2.5% and 97.5%), and <code>dat</code>
is <code>newdata</code>, extended with <code>fit</code> and <code>quantiles</code> (unless
prediction for an ordinal outcome is done with <code>type = "prob"</code>, in
which case the quantiles are an array with three dimensions and are
therefore not included in <code>dat</code>).
</p>


<h3>Note</h3>

 <ul>
<li><p> So far, <code>predict</code> cannot calculate
predicted values for cases with missing values in covariates. Predicted
values for such cases are <code>NA</code>. </p>
</li>
<li><p> For repeated measures models
prediction currently only uses fixed effects. </p>
</li></ul>
<p> Functionality will be
extended in the future.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predDF.JointAI">predDF.JointAI</a></code>, <code><a href="#topic+model_imp">*_imp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit model
mod &lt;- lm_imp(y ~ C1 + C2 + I(C2^2), data = wideDF, n.iter = 100)

# calculate the fitted values
fit &lt;- predict(mod)

# create dataset for prediction
newDF &lt;- predDF(mod, vars = ~ C2)

# obtain predicted values
pred &lt;- predict(mod, newdata = newDF)

# plot predicted values and 95% confidence band
matplot(newDF$C2, pred$fitted, lty = c(1, 2, 2), type = "l", col = 1,
xlab = 'C2', ylab = 'predicted values')

</code></pre>

<hr>
<h2 id='print.Dmat'>Summarize the results from an object of class JointAI</h2><span id='topic+print.Dmat'></span><span id='topic+summary.JointAI'></span><span id='topic+print.summary.JointAI'></span><span id='topic+coef.JointAI'></span><span id='topic+confint.JointAI'></span><span id='topic+print.JointAI'></span>

<h3>Description</h3>

<p>Obtain and print the <code>summary</code>, (fixed effects) coefficients
(<code>coef</code>) and credible interval (<code>confint</code>) for an object of
class 'JointAI'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Dmat'
print(x, digits = getOption("digits"),
  scientific = getOption("scipen"), ...)

## S3 method for class 'JointAI'
summary(object, start = NULL, end = NULL, thin = NULL,
  quantiles = c(0.025, 0.975), subset = NULL, exclude_chains = NULL,
  outcome = NULL, missinfo = FALSE, warn = TRUE, mess = TRUE, ...)

## S3 method for class 'summary.JointAI'
print(x, digits = max(3, .Options$digits - 4), ...)

## S3 method for class 'JointAI'
coef(object, start = NULL, end = NULL, thin = NULL,
  subset = NULL, exclude_chains = NULL, warn = TRUE, mess = TRUE, ...)

## S3 method for class 'JointAI'
confint(object, parm = NULL, level = 0.95,
  quantiles = NULL, start = NULL, end = NULL, thin = NULL,
  subset = NULL, exclude_chains = NULL, warn = TRUE, mess = TRUE, ...)

## S3 method for class 'JointAI'
print(x, digits = max(4, getOption("digits") - 4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Dmat_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.JointAI</code> or <code>JointAI</code></p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_digits">digits</code></td>
<td>
<p>the minimum number of significant digits to be printed in
values.</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_scientific">scientific</code></td>
<td>
<p>A penalty to be applied when deciding to print numeric
values in fixed or exponential notation, by default the
value obtained from <code>getOption("scipen")</code></p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_quantiles">quantiles</code></td>
<td>
<p>posterior quantiles</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_subset">subset</code></td>
<td>
<p>subset of parameters/variables/nodes (columns in the MCMC
sample). Follows the same principle as the argument
<code>monitor_params</code> in
<code><a href="#topic+model_imp">*_imp</a></code>.</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_outcome">outcome</code></td>
<td>
<p>optional; vector identifying for which outcomes the summary
should be given, either by specifying their indices, or their
names (LHS of the respective model formulas as character
string).</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_missinfo">missinfo</code></td>
<td>
<p>logical; should information on the number and proportion of
missing values be included in the summary?</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_parm">parm</code></td>
<td>
<p>same as <code>subset</code> (for consistency with <code>confint</code>
method for other types of objects)</p>
</td></tr>
<tr><td><code id="print.Dmat_+3A_level">level</code></td>
<td>
<p>confidence level (default is 0.95)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting functions <code><a href="#topic+lm_imp">lm_imp</a></code>,
<code><a href="#topic+glm_imp">glm_imp</a></code>, <code><a href="#topic+clm_imp">clm_imp</a></code>, <code><a href="#topic+lme_imp">lme_imp</a></code>,
<code><a href="#topic+glme_imp">glme_imp</a></code>, <code><a href="#topic+survreg_imp">survreg_imp</a></code> and
<code><a href="#topic+coxph_imp">coxph_imp</a></code>,
and the vignette
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>
for examples how to specify the parameter <code>subset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
mod1 &lt;- lm_imp(y ~ C1 + C2 + M2, data = wideDF, n.iter = 100)

summary(mod1, missinfo = TRUE)
coef(mod1)
confint(mod1)

## End(Not run)

</code></pre>

<hr>
<h2 id='rd_vcov'>Extract the random effects variance covariance matrix
Returns the posterior mean of the variance-covariance matrix/matrices of
the random effects in a fitted JointAI object.</h2><span id='topic+rd_vcov'></span>

<h3>Description</h3>

<p>Extract the random effects variance covariance matrix
Returns the posterior mean of the variance-covariance matrix/matrices of
the random effects in a fitted JointAI object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rd_vcov(object, outcome = NULL, start = NULL, end = NULL, thin = NULL,
  exclude_chains = NULL, mess = TRUE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rd_vcov_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="rd_vcov_+3A_outcome">outcome</code></td>
<td>
<p>optional; vector of integers giving the indices of the
outcomes for which the random effects variance-covariance
matrix/matrices should be returned.</p>
</td></tr>
<tr><td><code id="rd_vcov_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="rd_vcov_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="rd_vcov_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="rd_vcov_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="rd_vcov_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rd_vcov_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='reformat_difftime'>Set all elements of a <code>difftime</code> object to the same, largest meaningful unit</h2><span id='topic+reformat_difftime'></span>

<h3>Description</h3>

<p>Set all elements of a <code>difftime</code> object to the same, largest meaningful unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformat_difftime(dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reformat_difftime_+3A_dt">dt</code></td>
<td>
<p>a <code>difftime</code> object (potentially a vector of <code>difftime</code>s)</p>
</td></tr>
</table>

<hr>
<h2 id='remove_lhs'>Remove the left hand side of a (list of) formula(s)</h2><span id='topic+remove_lhs'></span>

<h3>Description</h3>

<p>Internal function; used in divide_matrices, get_models and help functions
(2022-02-05)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_lhs(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_lhs_+3A_formula">formula</code></td>
<td>
<p>a formula object or a list of formula objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>formula</code> object or a <code>list</code> of <code>formula</code> objects.
</p>

<hr>
<h2 id='residuals.JointAI'>Extract residuals from an object of class JointAI</h2><span id='topic+residuals.JointAI'></span>

<h3>Description</h3>

<p>Extract residuals from an object of class JointAI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JointAI'
residuals(object, type = c("working", "pearson",
  "response"), warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.JointAI_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="residuals.JointAI_+3A_type">type</code></td>
<td>
<p>type of residuals: <code>"deviance"</code>, <code>"response"</code>,
<code>"working"</code></p>
</td></tr>
<tr><td><code id="residuals.JointAI_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.JointAI_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Note</h3>


<ul>
<li><p> For mixed models residuals are currently calculated using the fixed
effects only.
</p>
</li>
<li><p> For ordinal (mixed) models and parametric survival models only
<code>type = "response"</code> is available.
</p>
</li>
<li><p> For Cox proportional hazards models residuals are not yet implemented.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- glm_imp(B1 ~ C1 + C2 + O1, data = wideDF, n.iter = 100,
               family = binomial(), mess = FALSE)
summary(residuals(mod, type = 'response')[[1]])
summary(residuals(mod, type = 'working')[[1]])


</code></pre>

<hr>
<h2 id='set_refcat'>Specify reference categories for all categorical covariates in the model</h2><span id='topic+set_refcat'></span>

<h3>Description</h3>

<p>The function is a helper function that asks questions and, depending on the
answers given by the user,
returns the input for the argument <code>refcats</code> in the main analysis
functions
<code><a href="#topic+model_imp">*_imp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_refcat(data, formula, covars, auxvars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_refcat_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="set_refcat_+3A_formula">formula</code></td>
<td>
<p>optional; model formula or a list of formulas
(used to select subset of relevant columns of <code>data</code>)</p>
</td></tr>
<tr><td><code id="set_refcat_+3A_covars">covars</code></td>
<td>
<p>optional; vector containing the names of relevant columns of
<code>data</code></p>
</td></tr>
<tr><td><code id="set_refcat_+3A_auxvars">auxvars</code></td>
<td>
<p>optional; formula containing the names of relevant columns of
<code>data</code> that should be considered additionally to the
columns occurring in the <code>formula</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>formula</code>, <code>covars</code> and <code>auxvars</code> can be used
to specify a subset of the <code>data</code> to be considered. If non of these
arguments is specified, all variables in <code>data</code> will be considered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1: set reference categories for the whole dataset and choose
# answer option 3:
set_refcat(data = NHANES)
3

# insert the returned string as argument refcats
mod1 &lt;- lm_imp(SBP ~ age + race + creat + educ, data = NHANES,
               refcats = 'largest')

# Example 2:
# specify a model formula
fmla &lt;- SBP ~ age + gender + race + bili + smoke + alc

# write the output of set_refcat to an object
ref_mod2 &lt;- set_refcat(data = NHANES, formula = fmla)
4
2
5
1
1

# enter the output in the model specification
mod2 &lt;- lm_imp(formula = fmla, data = NHANES, refcats = ref_mod2,
               n.adapt = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='sharedParams'>Parameters used by several functions in JointAI</h2><span id='topic+sharedParams'></span>

<h3>Description</h3>

<p>Parameters used by several functions in JointAI
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="sharedParams_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_no_model">no_model</code></td>
<td>
<p>optional; vector of names of variables for which no model
should be specified.
Note that this is only possible for completely observed
variables and implies the assumptions of independence between
the excluded variable and the incomplete variables.</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_timevar">timevar</code></td>
<td>
<p>name of the variable indicating the time of the measurement of
a time-varying covariate in a proportional hazards survival
model (also in a joint model).
The variable specified in
&quot;timevar&quot; will automatically be added to &quot;no_model&quot;.</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_assoc_type">assoc_type</code></td>
<td>
<p>named vector specifying the type of the association used
for a time-varying covariate in the linear predictor of the
survival model when using a &quot;JM&quot; model.
Implemented options are &quot;underl.value&quot;
(linear predictor; default for covariates modelled using a
Gaussian, Gamma, beta or log-normal distribution)
covariates) and &quot;obs.value&quot; (the observed/imputed value;
default for covariates modelled using other distributions).</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_subset">subset</code></td>
<td>
<p>subset of parameters/variables/nodes (columns in the MCMC
sample). Follows the same principle as the argument
<code>monitor_params</code> in
<code><a href="#topic+model_imp">*_imp</a></code>.</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_n.adapt">n.adapt</code></td>
<td>
<p>number of iterations for adaptation of the MCMC samplers
(see <code><a href="rjags.html#topic+adapt">adapt</a></code>)</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations of the MCMC chain (after adaptation;
see <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>)</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_n.chains">n.chains</code></td>
<td>
<p>number of MCMC chains</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_quiet">quiet</code></td>
<td>
<p>logical; if <code>TRUE</code> then messages generated by
<strong>rjags</strong> during compilation as well as the progress bar
for the adaptive phase will be suppressed,
(see <code><a href="rjags.html#topic+jags.model">jags.model</a></code>)</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_progress.bar">progress.bar</code></td>
<td>
<p>character string specifying the type of
progress bar. Possible values are &quot;text&quot; (default), &quot;gui&quot;,
and &quot;none&quot; (see <code><a href="rjags.html#topic+update">update</a></code>). Note: when
sampling is performed in parallel it is not possible to
display a progress bar.</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_nrow">nrow</code></td>
<td>
<p>optional; number of rows in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_ncol">ncol</code></td>
<td>
<p>optional; number of columns in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_use_ggplot">use_ggplot</code></td>
<td>
<p>logical; Should ggplot be used instead of the base
graphics?</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_xlab">xlab</code>, <code id="sharedParams_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x- and y-axis</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_idvars">idvars</code></td>
<td>
<p>name of the column that specifies the multi-level grouping
structure</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_seed">seed</code></td>
<td>
<p>optional; seed value (for reproducibility)</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_ppc">ppc</code></td>
<td>
<p>logical: should monitors for posterior predictive checks be
set? (not yet used)</p>
</td></tr>
<tr><td><code id="sharedParams_+3A_rd_vcov">rd_vcov</code></td>
<td>
<p>optional character string or list (of lists or character
strings) specifying the structure of the variance covariance
matrix/matrices of the random effects for multivariate
mixed models. Options are  <code style="white-space: pre;">&#8288;"full&#8288;</code>, <code>"blockdiag"</code> (default)
and <code>"indep"</code>. Different structures can be specified per
grouping level (in multi-level models with more than two
levels) by specifying a list with elements per grouping
level. To specify different structures for different
outcomes, a list (maybe nested in the list per grouping
level) can be specified. This list should have the type
of structure as names and contain vectors of variable
names that belong to the respective structure.</p>
</td></tr>
</table>

<hr>
<h2 id='simLong'>Simulated Longitudinal Data in Long and Wide Format</h2><span id='topic+simLong'></span><span id='topic+simWide'></span>

<h3>Description</h3>

<p>This data was simulated to mimic data from a longitudinal cohort study
following mothers and their child from birth until approximately 4 years of
age.
It contains 2400 observations of 200 mother-child pairs. Children's BMI and
head circumference was measured repeatedly and their age in months was
recorded at each measurement. Furthermore, the data contain several baseline
variables with information on the mothers' demographics and socio-economic
status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simLong

simWide
</code></pre>


<h3>Format</h3>

<p><code>simLong</code>: A data frame in long format with 2400 rows and 16 variables
</p>
<p><code>simWide</code>: A data frame in wide format with 200 rows and 81 variables
</p>
<p>An object of class <code>data.frame</code> with 2400 rows and 16 columns.
</p>
<p>An object of class <code>data.frame</code> with 200 rows and 81 columns.
</p>


<h3>Baseline covariates</h3>

<p>(in <code>simLong</code> and <code>simWide</code>)
</p>

<dl>
<dt>GESTBIR</dt><dd><p>gestational age at birth (in weeks)</p>
</dd>
<dt>ETHN</dt><dd><p>ethnicity (binary: European vs. other)</p>
</dd>
<dt>AGE_M</dt><dd><p>age of the mother at intake</p>
</dd>
<dt>HEIGHT_M</dt><dd><p>height of the mother (in cm)</p>
</dd>
<dt>PARITY</dt><dd><p>number of times the mother has given birth
(binary: 0 vs. &gt;=1)</p>
</dd>
<dt>SMOKE</dt><dd><p>smoking status of the mother during pregnancy
(3 ordered categories: never smoked during pregnancy,
smoked until pregnancy was known, continued smoking in
pregnancy)</p>
</dd>
<dt>EDUC</dt><dd><p>educational level of the mother (3 ordered categories: low,
mid, high)</p>
</dd>
<dt>MARITAL</dt><dd><p>marital status (3 categories)</p>
</dd>
<dt>ID</dt><dd><p>subject identifier</p>
</dd>
</dl>



<h3>Long-format variables</h3>

<p>(only in <code>simLong</code>)
</p>

<dl>
<dt>time</dt><dd><p>measurement occasion/visit
(by design, children should be measured at/around
1, 2, 3, 4, 7, 11, 15, 20, 26, 32, 40 and 50 months of age)</p>
</dd>
<dt>age</dt><dd><p>child age at measurement time in months</p>
</dd>
<dt>bmi</dt><dd><p>child BMI</p>
</dd>
<dt>hc</dt><dd><p>child head circumference in cm</p>
</dd>
<dt>hgt</dt><dd><p>child height in cm</p>
</dd>
<dt>wgt</dt><dd><p>child weight in gram</p>
</dd>
<dt>sleep</dt><dd><p>sleeping behaviour of the child (3 ordered categories)</p>
</dd>
</dl>



<h3>Wide-format variables</h3>

<p>(only in <code>simWide</code>)
</p>

<dl>
<dt>age1, age2, age3, age4, age7, age11, age15, age20, age26, age32,
age40, age50</dt><dd><p>child age at the repeated measurements in months</p>
</dd>
<dt>bmi1, bmi2, bmi3, bmi4, bmi7, bmi11, bmi15, bmi20, bmi26, bmi32,
bmi40, bmi50</dt><dd><p>repeated measurements of child BMI</p>
</dd>
<dt>hc1, hc2, hc3, hc4, hc7, hc11, hc15, hc20, hc26, hc32,
hc40, hc50</dt><dd><p>repeated measurements of child head circumference in cm</p>
</dd>
<dt>hgt1, hgt2, hgt3, hgt4, hgt7, hgt11, hgt15, hgt20, hgt26, hgt32,
hgt40, hgt50</dt><dd><p>repeated measurements of child height in cm</p>
</dd>
<dt>wgt1, wgt2, wgt3, wgt4, wgt7, wgt11, wgt15, wgt20, wgt26, wgt32,
wgt40, wgt50</dt><dd><p>repeated measurements of child weight in gram</p>
</dd>
<dt>sleep1, sleep2, sleep3, sleep4, sleep7, sleep11, sleep15, sleep20,
sleep26, sleep32, sleep40, sleep50</dt><dd><p>repeated measurements of child sleep
behaviour (3 ordered categories)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> summary(simLong)
 summary(simWide)

</code></pre>

<hr>
<h2 id='split_formula'>Split a formula into fixed and random effects parts</h2><span id='topic+split_formula'></span>

<h3>Description</h3>

<p>Split a lme4 style formula into nlme style formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_formula(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_formula_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function, used in *_imp and help functions (2022-02-06)
</p>

<hr>
<h2 id='split_formula_list'>Split a list of formulas into fixed and random effects parts.</h2><span id='topic+split_formula_list'></span>

<h3>Description</h3>

<p>Calls <code>split_formula()</code> on each formula in a list to create one list of the
fixed effects formulas and one list containing the random effects formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_formula_list(formulas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_formula_list_+3A_formulas">formulas</code></td>
<td>
<p>a <code>list</code> of <code>formula</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function, used in *_imp() (2022-02-06)
</p>

<hr>
<h2 id='sum_duration'>Calculate the sum of the computational duration of a JointAI object</h2><span id='topic+sum_duration'></span>

<h3>Description</h3>

<p>Calculate the sum of the computational duration of a JointAI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_duration(object, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_duration_+3A_object">object</code></td>
<td>
<p>object of class <code>JointAI</code></p>
</td></tr>
<tr><td><code id="sum_duration_+3A_by">by</code></td>
<td>
<p>optional grouping information; options are <code>NULL</code> (default) to
calculate the sum over all chains and runs and both the adaptive
and sampling phase, <code>"run"</code> to get the duration per run,
<code>"phase"</code> to get the sum over all chains and runs per phase,
<code>"chain"</code> to get the sum per chain over both phases and all runs,
<code>"phase and run"</code> to get the sum over all chains, separately per
phase and run.</p>
</td></tr>
</table>

<hr>
<h2 id='Surv'>Create a Survival Object</h2><span id='topic+Surv'></span>

<h3>Description</h3>

<p>This function just calls <code>Surv()</code> from the
<a href="https://CRAN.R-project.org/package=survival"><strong>survival</strong></a>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Surv(time, time2, event, type = c("right", "left", "interval", "counting",
  "interval2", "mstate"), origin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Surv_+3A_time">time</code></td>
<td>

<p>for right censored data, this is the follow up time.  For interval
data, the first argument is the starting time for the interval. 
</p>
</td></tr>
<tr><td><code id="Surv_+3A_time2">time2</code></td>
<td>

<p>ending time of the interval for interval censored  or counting
process data only.  Intervals are assumed to be open on the left and
closed on the right, <code>(start, end]</code>.  For counting process
data, <code>event</code> indicates whether an event occurred at the end of
the interval.
</p>
</td></tr>
<tr><td><code id="Surv_+3A_event">event</code></td>
<td>

<p>The status indicator, normally 0=alive, 1=dead.  Other choices are
<code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For
interval censored data, the status indicator is 0=right censored,
1=event at <code>time</code>, 2=left censored, 3=interval censored.
For multiple endpoint data the event variable will be a factor,
whose first level is treated as censoring.
Although unusual, the event indicator can be omitted, in which case
all subjects are assumed to have an event.
</p>
</td></tr>
<tr><td><code id="Surv_+3A_type">type</code></td>
<td>

<p>character string specifying the type of censoring. Possible values
are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, <code>"interval2"</code> or <code>"mstate"</code>.  
</p>
</td></tr>
<tr><td><code id="Surv_+3A_origin">origin</code></td>
<td>

<p>for counting process data, the hazard function origin.  This option
was intended to be used in conjunction with a model containing
time dependent
strata in order to align the subjects properly when they cross over
from one strata to another, but it has rarely proven useful.</p>
</td></tr>
</table>

<hr>
<h2 id='traceplot'>Create traceplots for a MCMC sample</h2><span id='topic+traceplot'></span><span id='topic+traceplot.JointAI'></span>

<h3>Description</h3>

<p>Creates a set of traceplots from the MCMC sample of an object of class
'JointAI'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(object, ...)

## S3 method for class 'JointAI'
traceplot(object, start = NULL, end = NULL,
  thin = NULL, subset = c(analysis_main = TRUE), outcome = NULL,
  exclude_chains = NULL, nrow = NULL, ncol = NULL, use_ggplot = FALSE,
  warn = TRUE, mess = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_object">object</code></td>
<td>
<p>object inheriting from class 'JointAI'</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="graphics.html#topic+matplot">graphics::matplot</a></code>
</p>

<dl>
<dt><code>lty,lwd,lend</code></dt><dd><p>vector of line types, widths, and end styles.
The first element is for the first column, the second element for
the second column, etc., even if lines are not plotted for all
columns. Line types will be used cyclically until all plots are
drawn.</p>
</dd>
<dt><code>col</code></dt><dd><p>vector of colors.  Colors are used cyclically.</p>
</dd>
<dt><code>cex</code></dt><dd><p>vector of character expansion sizes, used cyclically.
This works as a multiple of <code><a href="graphics.html#topic+par">par</a>("cex")</code>.  <code>NULL</code> is
equivalent to <code>1.0</code>. </p>
</dd>
<dt><code>bg</code></dt><dd><p>vector of background (fill) colors for the open plot
symbols given by <code>pch = 21:25</code> as in <code><a href="graphics.html#topic+points">points</a></code>.  The
default <code>NA</code> corresponds to the one of the underlying function
<code><a href="graphics.html#topic+plot.xy">plot.xy</a></code>.</p>
</dd>
<dt><code>add</code></dt><dd><p>logical.  If <code>TRUE</code>, plots are added to current one,
using <code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>logical.  If <code>TRUE</code>, write one line of what is
done.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="traceplot_+3A_start">start</code></td>
<td>
<p>the first iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_end">end</code></td>
<td>
<p>the last iteration of interest
(see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_thin">thin</code></td>
<td>
<p>thinning interval (integer; see <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code>).
For example, <code>thin = 1</code> (default) will keep the MCMC samples
from all iterations; <code>thin = 5</code> would only keep every 5th
iteration.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_subset">subset</code></td>
<td>
<p>subset of parameters/variables/nodes (columns in the MCMC
sample). Follows the same principle as the argument
<code>monitor_params</code> in
<code><a href="#topic+model_imp">*_imp</a></code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_outcome">outcome</code></td>
<td>
<p>optional; vector identifying a subset of sub-models included
in the output, either by specifying their indices (using the
order used in the list of model formulas), or their
names (LHS of the respective model formula as character
string)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_exclude_chains">exclude_chains</code></td>
<td>
<p>optional vector of the index numbers of chains that
should be excluded</p>
</td></tr>
<tr><td><code id="traceplot_+3A_nrow">nrow</code></td>
<td>
<p>optional; number of rows in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="traceplot_+3A_ncol">ncol</code></td>
<td>
<p>optional; number of columns in the plot layout;
automatically chosen if unspecified</p>
</td></tr>
<tr><td><code id="traceplot_+3A_use_ggplot">use_ggplot</code></td>
<td>
<p>logical; Should ggplot be used instead of the base
graphics?</p>
</td></tr>
<tr><td><code id="traceplot_+3A_warn">warn</code></td>
<td>
<p>logical; should warnings be given? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_mess">mess</code></td>
<td>
<p>logical; should messages be given? Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.JointAI">summary.JointAI</a></code>,
<code><a href="#topic+model_imp">*_imp</a></code>,
<code><a href="#topic+densplot">densplot</a></code><br />
The vignette
<a href="https://nerler.github.io/JointAI/articles/SelectingParameters.html">Parameter Selection</a>
contains some examples how to specify the parameter <code>subset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a JointAI model
mod &lt;- lm_imp(y ~ C1 + C2 + M1, data = wideDF, n.iter = 100)


# Example 1: simple traceplot
traceplot(mod)


# Example 2: ggplot version of traceplot
traceplot(mod, use_ggplot = TRUE)


# Example 5: changing how the ggplot version looks (using ggplot syntax)
library(ggplot2)

traceplot(mod, use_ggplot = TRUE) +
  theme(legend.position = 'bottom') +
  xlab('iteration') +
  ylab('value') +
  scale_color_discrete(name = 'chain')


</code></pre>

<hr>
<h2 id='wideDF'>Cross-sectional example dataset</h2><span id='topic+wideDF'></span>

<h3>Description</h3>

<p>A simulated cross-sectional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wideDF)
</code></pre>


<h3>Format</h3>

<p>A simulated data frame with 100 rows and 13 variables:
</p>

<dl>
<dt>C1</dt><dd><p>continuous, complete variable</p>
</dd>
<dt>C2</dt><dd><p>continuous, incomplete variable</p>
</dd>
<dt>B1</dt><dd><p>binary, complete variable</p>
</dd>
<dt>B2</dt><dd><p>binary, incomplete variable</p>
</dd>
<dt>M1</dt><dd><p>unordered factor; complete variable</p>
</dd>
<dt>M2</dt><dd><p>unordered factor; incomplete variable</p>
</dd>
<dt>O1</dt><dd><p>ordered factor; complete variable</p>
</dd>
<dt>O2</dt><dd><p>ordered factor; incomplete variable</p>
</dd>
<dt>L1</dt><dd><p>continuous, complete variable</p>
</dd>
<dt>L2</dt><dd><p>continuous incomplete variable</p>
</dd>
<dt>id</dt><dd><p>id (grouping) variable</p>
</dd>
<dt>time</dt><dd><p>continuous complete variable</p>
</dd>
<dt>y</dt><dd><p>continuous, complete variable</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
