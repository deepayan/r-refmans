<!DOCTYPE html><html><head><title>Help for package bvartools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bvartools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_priors'><p>Add Priors to Bayesian Models</p>
</p>
<p>A generic function used to generate prior specifications for a list of models. The</p>
function invokes particular methods which depend on the class of the first argument.</a></li>
<li><a href='#add_priors.bvarmodel'><p>Add Priors for a Vector Autoregressive Models</p></a></li>
<li><a href='#add_priors.bvecmodel'><p>Add Priors for Vector Error Correction Models</p></a></li>
<li><a href='#add_priors.dfmodel'><p>Add Priors to Dynamic Factor Model</p></a></li>
<li><a href='#bem_dfmdata'><p>FRED-QD data</p></a></li>
<li><a href='#bvar'><p>Bayesian Vector Autoregression Objects</p></a></li>
<li><a href='#bvarpost'><p>Posterior Simulation for BVAR Models</p></a></li>
<li><a href='#bvartools-package'><p>bvartools: Bayesian Inference of Vector Autoregressive and Error Correction Models</p></a></li>
<li><a href='#bvec'><p>Bayesian Vector Error Correction Objects</p></a></li>
<li><a href='#bvec_to_bvar'><p>Transform a VEC Model to a VAR in Levels</p></a></li>
<li><a href='#bvecpost'><p>Posterior Simulation for BVEC Models</p></a></li>
<li><a href='#bvs'><p>Bayesian Variable Selection</p></a></li>
<li><a href='#dfm'><p>Bayesian Dynamic Factor Model Objects</p></a></li>
<li><a href='#dfmpost'><p>Posterior Simulation for Dynamic Factor Models</p></a></li>
<li><a href='#draw_posterior'><p>Posterior Simulation</p></a></li>
<li><a href='#draw_posterior.bvarmodel'><p>Posterior Simulation</p></a></li>
<li><a href='#draw_posterior.bvecmodel'><p>Posterior Simulation for Vector Error Correction Models</p></a></li>
<li><a href='#draw_posterior.dfmodel'><p>Posterior Simulation</p></a></li>
<li><a href='#e1'><p>West German economic time series data</p></a></li>
<li><a href='#e6'><p>German interest and inflation rate data</p></a></li>
<li><a href='#fevd'><p>Forecast Error Variance Decomposition</p>
</p>
<p>A generic function used to calculate forecast error varianc decompositions.</p></a></li>
<li><a href='#fevd.bvar'><p>Forecast Error Variance Decomposition</p></a></li>
<li><a href='#gen_dfm'><p>Dynamic Factor Model Input</p></a></li>
<li><a href='#gen_var'><p>Vector Autoregressive Model Input</p></a></li>
<li><a href='#gen_vec'><p>Vector Error Correction Model Input</p></a></li>
<li><a href='#inclusion_prior'><p>Prior Inclusion Probabilities</p></a></li>
<li><a href='#irf'><p>Impulse Response Function</p>
</p>
<p>A generic function used to calculate impulse response functions.</p></a></li>
<li><a href='#irf.bvar'><p>Impulse Response Function</p></a></li>
<li><a href='#kalman_dk'><p>Durbin and Koopman Simulation Smoother</p></a></li>
<li><a href='#loglik_normal'><p>Calculates the log-likelihood of a multivariate normal distribution.</p></a></li>
<li><a href='#minnesota_prior'><p>Minnesota Prior</p></a></li>
<li><a href='#plot.bvarlist'><p>Plotting Posterior Draws of Bayesian VAR or VEC Models</p></a></li>
<li><a href='#plot.bvarprd'><p>Plotting Forecasts of BVAR Models</p></a></li>
<li><a href='#post_coint_kls'><p>Posterior Draw for Cointegration Models</p></a></li>
<li><a href='#post_coint_kls_sur'><p>Posterior Draw for Cointegration Models</p></a></li>
<li><a href='#post_normal'><p>Posterior Draw from a Normal Distribution</p></a></li>
<li><a href='#post_normal_covar_const'><p>Posterior Simulation of Error Covariance Coefficients</p></a></li>
<li><a href='#post_normal_covar_tvp'><p>Posterior Simulation of Error Covariance Coefficients</p></a></li>
<li><a href='#post_normal_sur'><p>Posterior Draw from a Normal Distribution</p></a></li>
<li><a href='#ssvs'><p>Stochastic Search Variable Selection</p></a></li>
<li><a href='#ssvs_prior'><p>Stochastic Search Variable Selection Prior</p></a></li>
<li><a href='#stoch_vol'><p>Stochastic Volatility</p></a></li>
<li><a href='#stochvol_ksc1998'><p>Stochastic Volatility</p></a></li>
<li><a href='#stochvol_ocsn2007'><p>Stochastic Volatility</p></a></li>
<li><a href='#summary.bvar'><p>Summarising Bayesian VAR Coefficients</p></a></li>
<li><a href='#summary.bvarlist'><p>Summarising Bayesian VAR or VEC Models</p></a></li>
<li><a href='#summary.bvec'><p>Summarising Bayesian VEC Coefficients</p></a></li>
<li><a href='#summary.dfm'><p>Summarising Bayesian Dynamic Factor Models</p></a></li>
<li><a href='#thin.bvar'><p>Thinning Posterior Draws</p></a></li>
<li><a href='#thin.bvarlist'><p>Thinning Posterior Draws</p></a></li>
<li><a href='#thin.bvec'><p>Thinning Posterior Draws</p></a></li>
<li><a href='#thin.dfm'><p>Thinning Posterior Draws</p></a></li>
<li><a href='#us_macrodata'><p>US macroeconomic data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Inference of Vector Autoregressive and Error Correction
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Assists in the set-up of algorithms for Bayesian inference of vector autoregressive (VAR) and error correction (VEC) models. Functions for posterior simulation, forecasting, impulse response analysis and forecast error variance decomposition are largely based on the introductory texts of Chan, Koop, Poirier and Tobias (2019, ISBN: 9781108437493), Koop and Korobilis (2010) &lt;<a href="https://doi.org/10.1561%2F0800000013">doi:10.1561/0800000013</a>&gt; and Luetkepohl (2006, ISBN: 9783540262398).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), coda, Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, methods, parallel, Rcpp (&ge; 0.12.14),
stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/franzmohr/bvartools">https://github.com/franzmohr/bvartools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/franzmohr/bvartools/issues">https://github.com/franzmohr/bvartools/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'add_priors.R' 'add_priors.bvarmodel.R'
'add_priors.bvecmodel.R' 'add_priors.dfmodel.R' 'bvar.R'
'bvar_fill_helper.R' 'bvarpost.R' 'bvartools-package.R'
'bvec.R' 'bvec_to_bvar.R' 'bvecpost.R' 'data.R' 'dfm.R'
'dfmpost.R' 'draw_posterior.R' 'draw_posterior.bvarmodel.R'
'draw_posterior.bvecmodel.R' 'draw_posterior.dfmodel.R'
'fevd.R' 'fevd.bvar.R' 'gen_dfm.R' 'gen_var.R' 'gen_vec.R'
'get_regressor_names.R' 'inclusion_prior.R' 'irf.R'
'irf.bvar.R' 'minnesota_prior.R' 'plot.bvar.R'
'plot.bvarfevd.R' 'plot.bvarirf.R' 'plot.bvarlist.R'
'plot.bvarprd.R' 'plot.bvec.R' 'plot.dfm.R'
'post_normal_covar_const.R' 'post_normal_covar_tvp.R'
'predict.bvar.R' 'summary.bvar.R' 'print.summary.bvar.R'
'summary.bvec.R' 'print.summary.bvec.R' 'ssvs_prior.R'
'summary.bvarlist.R' 'summary.dfm.R' 'thin.bvar.R'
'thin.bvarlist.R' 'thin.bvec.R' 'thin.dfm.R' 'tvpribbon.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 08:34:17 UTC; franz</td>
</tr>
<tr>
<td>Author:</td>
<td>Franz X. Mohr [aut, cre] (0009-0003-8890-7781)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Franz X. Mohr &lt;franz.x.mohr@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_priors'>Add Priors to Bayesian Models
A generic function used to generate prior specifications for a list of models. The
function invokes particular methods which depend on the class of the first argument.</h2><span id='topic+add_priors'></span>

<h3>Description</h3>

<p>Add Priors to Bayesian Models
</p>
<p>A generic function used to generate prior specifications for a list of models. The
function invokes particular methods which depend on the class of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_priors(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_priors_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvarmodel"</code> or <code>"bvecmodel"</code>.</p>
</td></tr>
<tr><td><code id="add_priors_+3A_...">...</code></td>
<td>
<p>arguments passed forward to method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Obtain data matrices
model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burn-in draws should be much higher.

# Add prior specifications
model &lt;- add_priors(model)

</code></pre>

<hr>
<h2 id='add_priors.bvarmodel'>Add Priors for a Vector Autoregressive Models</h2><span id='topic+add_priors.bvarmodel'></span>

<h3>Description</h3>

<p>Adds prior specifications to a list of models, which was produced by
function <code><a href="#topic+gen_var">gen_var</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvarmodel'
add_priors(
  object,
  coef = list(v_i = 1, v_i_det = 0.1, shape = 3, rate = 1e-04, rate_det = 0.01),
  sigma = list(df = "k", scale = 1, mu = 0, v_i = 0.01, sigma_h = 0.05, constant = 1e-04),
  ssvs = NULL,
  bvs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_priors.bvarmodel_+3A_object">object</code></td>
<td>
<p>a list, usually, the output of a call to <code><a href="#topic+gen_var">gen_var</a></code>.</p>
</td></tr>
<tr><td><code id="add_priors.bvarmodel_+3A_coef">coef</code></td>
<td>
<p>a named list of prior specifications for the coefficients of the
models. For the default specification all prior means are set to zero and the diagonal elements of
the inverse prior variance-covariance matrix are set to 1 for coefficients corresponding to non-deterministic
and structural terms. For deterministic coefficients the prior variances are set to 10 via <code>v_i_det = 0.1</code>.
The variances need to be specified as precisions, i.e. as inverses of the variances.
For further specifications such as the Minnesota prior see 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvarmodel_+3A_sigma">sigma</code></td>
<td>
<p>a named list of prior specifications for the error variance-covariance matrix
of the models. For the default specification of an inverse Wishart distribution
the prior degrees of freedom are set to the number of endogenous variables and
the prior variances to 1. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvarmodel_+3A_ssvs">ssvs</code></td>
<td>
<p>optional; a named list of prior specifications for the SSVS algorithm. Not allowed for TVP models. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvarmodel_+3A_bvs">bvs</code></td>
<td>
<p>optional; a named list of prior specifications for the BVS algorithm. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvarmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments of the function require named lists. Possible
specifications are described in the following. Note that it is important to specify the
priors in the correct list. Otherwise, the provided specification will be disregarded
and default values will be used.
</p>
<p>Argument <code>coef</code> can contain the following elements
</p>

<dl>
<dt><code>v_i</code></dt><dd><p>a numeric specifying the prior precision of the coefficients. Default is 1.</p>
</dd>
<dt><code>v_i_det</code></dt><dd><p>a numeric specifying the prior precision of coefficients corresponding to deterministic terms. Default is 0.1.</p>
</dd>
<dt><code>coint_var</code></dt><dd><p>a logical specifying whether the prior mean of the first own lag of an
endogenous variable should be set to 1. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>const</code></dt><dd><p>a numeric or character specifying the prior mean of coefficients, which correspond
to the intercept. If a numeric is provided, all prior means are set to this value.
If <code>const = "mean"</code>, the mean of the respective endogenous variable is used as prior mean.
If <code>const = "first"</code>, the first values of the respective endogenous variable is used as prior mean.</p>
</dd>
<dt><code>minnesota</code></dt><dd><p>a list of length 4 containing parameters for the calculation of
the Minnesota prior, where the element names must be <code>kappa0</code>, <code>kappa1</code>, <code>kappa2</code> and <code>kappa3</code>.
For the endogenous variable <code class="reqn">i</code> the prior variance of the <code class="reqn">l</code>th lag of regressor <code class="reqn">j</code> is obtained as
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0}}{l^2} \textrm{ for own lags of endogenous variables,}</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0} \kappa_{1}}{l^2} \frac{\sigma_{i}^2}{\sigma_{j}^2} \textrm{ for endogenous variables other than own lags,}</code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0} \kappa_{2}}{(l+1)^2} \frac{\sigma_{i}^2}{\sigma_{j}^2} \textrm{ for exogenous variables,}</code>
</p>

<p style="text-align: center;"><code class="reqn"> \kappa_{0} \kappa_{3} \sigma_{i}^2 \textrm{ for deterministic terms,}</code>
</p>

<p>where <code class="reqn">\sigma_{i}</code> is the residual standard deviation of variable <code class="reqn">i</code> of an unrestricted
LS estimate. For exogenous variables <code class="reqn">\sigma_{i}</code> is the sample standard deviation.</p>
</dd>
<dt><code>max_var</code></dt><dd><p>a numeric specifying the maximum prior variance that is allowed for
non-deterministic coefficients.</p>
</dd>
<dt><code>shape</code></dt><dd><p>a numeric specifying the prior shape parameter of the error term of the
state equation. Only used for models with time varying parameters. Default is 3.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric specifying the prior rate parameter of the error term of the
state equation. Only used for models with time varying parameters. Default is 0.0001.</p>
</dd>
<dt><code>rate_det</code></dt><dd><p>a numeric specifying the prior rate parameter of the error term of the
state equation for coefficients, which correspond to deterministic terms.
Only used for models with time varying parameters. Default is 0.01.</p>
</dd>
</dl>

<p>If <code>minnesota</code> is specified, <code>v_i</code> and <code>v_i_det</code> are ignored.
</p>
<p>Argument <code>sigma</code> can contain the following elements:
</p>

<dl>
<dt><code>df</code></dt><dd><p>an integer or character specifying the prior degrees of freedom of the error term. Only
used, if the prior is inverse Wishart.
Default is <code>"k"</code>, which indicates the amount of endogenous variables in the respective model.
<code>"k + 3"</code> can be used to set the prior to the amount of endogenous variables plus 3. If an integer
is provided, the degrees of freedom are set to this value in all models.</p>
</dd>
<dt><code>scale</code></dt><dd><p>a numeric specifying the prior error variance of endogenous variables.
Default is 1.</p>
</dd>
<dt><code>shape</code></dt><dd><p>a numeric or character specifying the prior shape parameter of the error term. Only
used, if the prior is inverse gamma or if time varying volatilities are estimated.
For models with constant volatility the default is <code>"k"</code>, which indicates the amount of endogenous
variables in the respective country model. <code>"k + 3"</code> can be used to set the prior to the amount of
endogenous variables plus 3. If a numeric is provided, the shape parameters are set to this value in all
models. For models with stochastic volatility this prior refers to the error variance of the state
equation.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric specifying the prior rate parameter of the error term. Only used, if the
prior is inverse gamma or if time varying volatilities are estimated. For models with stochastic
volatility this prior refers to the error variance of the state equation.</p>
</dd>
<dt><code>mu</code></dt><dd><p>numeric of the prior mean of the initial state of the log-volatilities.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>v_i</code></dt><dd><p>numeric of the prior precision of the initial state of the log-volatilities.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>sigma_h</code></dt><dd><p>numeric of the initial draw for the variance of the log-volatilities.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>constant</code></dt><dd><p>numeric of the constant, which is added before taking the log of the squared errors.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>covar</code></dt><dd><p>logical indicating whether error covariances should be estimated. Only used
in combination with an inverse gamma prior or stochastic volatility, for which <code>shape</code> and
<code>rate</code> must be specified.</p>
</dd>
</dl>

<p><code>df</code> and <code>scale</code> must be specified for an inverse Wishart prior. <code>shape</code> and <code>rate</code>
are required for an inverse gamma prior. For structural models or models with stochastic volatility
only a gamma prior specification is allowed.
</p>
<p>Argument <code>ssvs</code> can contain the following elements:
</p>

<dl>
<dt><code>inprior</code></dt><dd><p>a numeric between 0 and 1 specifying the prior probability
of a variable to be included in the model.</p>
</dd>
<dt><code>tau</code></dt><dd><p>a numeric vector of two elements containing the prior standard errors
of restricted variables (<code class="reqn">\tau_0</code>) as its first element and unrestricted variables (<code class="reqn">\tau_1</code>)
as its second.</p>
</dd>
<dt><code>semiautomatic</code></dt><dd><p>an numeric vector of two elements containing the
factors by which the standard errors associated with an unconstrained least squares
estimate of the model are multiplied to obtain the prior standard errors
of restricted (<code class="reqn">\tau_0</code>) and unrestricted (<code class="reqn">\tau_1</code>) variables, respectively.
This is the semiautomatic approach described in George et al. (2008).</p>
</dd>
<dt><code>covar</code></dt><dd><p>logical indicating if SSVS should also be applied to the error covariance matrix
as in George et al. (2008).</p>
</dd>
<dt><code>exclude_det</code></dt><dd><p>logical indicating if deterministic terms should be excluded from the SSVS algorithm.</p>
</dd>
<dt><code>minnesota</code></dt><dd><p>a numeric vector of length 4 containing parameters for the calculation of
the Minnesota-like inclusion priors. See below.</p>
</dd>
</dl>

<p>Either <code>tau</code> or <code>semiautomatic</code> must be specified.
</p>
<p>The argument <code>bvs</code> can contain the following elements
</p>

<dl>
<dt><code>inprior</code></dt><dd><p>a numeric between 0 and 1 specifying the prior probability
of a variable to be included in the model.</p>
</dd>
<dt><code>covar</code></dt><dd><p>logical indicating if BVS should also be applied to the error covariance matrix.</p>
</dd>
<dt><code>exclude_det</code></dt><dd><p>logical indicating if deterministic terms should be excluded from the BVS algorithm.</p>
</dd>
<dt><code>minnesota</code></dt><dd><p>a numeric vector of length 4 containing parameters for the calculation of
the Minnesota-like inclusion priors. See below.</p>
</dd>
</dl>

<p>If either <code>ssvs$minnesota</code> or <code>bvs$minnesota</code> is specified, prior inclusion probabilities
are calculated in a Minnesota-like fashion as
</p>

<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_1}{l}</code> </td><td style="text-align: left;"> for own lags of endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_2}{l}</code> </td><td style="text-align: left;"> for other endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_3}{1 + l}</code> </td><td style="text-align: left;"> for exogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa_{4}</code> </td><td style="text-align: left;"> for deterministic variables, 
</td>
</tr>

</table>

<p>for lag <code class="reqn">l</code> with <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, <code class="reqn">\kappa_3</code>, <code class="reqn">\kappa_4</code> as the first, second,
third and forth element in <code>ssvs$minnesota</code> or <code>bvs$minnesota</code>, respectively.
</p>


<h3>Value</h3>

<p>A list of country models.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>George, E. I., Sun, D., &amp; Ni, S. (2008). Bayesian stochastic search for VAR model
restrictions. <em>Journal of Econometrics, 142</em>(1), 553&ndash;580.
<a href="https://doi.org/10.1016/j.jeconom.2007.08.017">doi:10.1016/j.jeconom.2007.08.017</a>
</p>
<p>Korobilis, D. (2013). VAR forecasting using Bayesian variable selection.
<em>Journal of Applied Econometrics, 28</em>(2), 204&ndash;230. <a href="https://doi.org/10.1002/jae.1271">doi:10.1002/jae.1271</a>
</p>
<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("e1")
e1 &lt;- diff(log(e1)) * 100

model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)

model &lt;- add_priors(model)

</code></pre>

<hr>
<h2 id='add_priors.bvecmodel'>Add Priors for Vector Error Correction Models</h2><span id='topic+add_priors.bvecmodel'></span>

<h3>Description</h3>

<p>Adds prior specifications to a list of models, which was produced by
function <code><a href="#topic+gen_vec">gen_vec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvecmodel'
add_priors(
  object,
  coef = list(v_i = 1, v_i_det = 0.1, shape = 3, rate = 1e-04, rate_det = 0.01),
  coint = list(v_i = 0, p_tau_i = 1, shape = 3, rate = 1e-04, rho = 0.999),
  sigma = list(df = "k", scale = 1, mu = 0, v_i = 0.01, sigma_h = 0.05, constant = 1e-04),
  ssvs = NULL,
  bvs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_priors.bvecmodel_+3A_object">object</code></td>
<td>
<p>a list, usually, the output of a call to <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="add_priors.bvecmodel_+3A_coef">coef</code></td>
<td>
<p>a named list of prior specifications for coefficients that do not 
determine the cointegration space. For the default specification all prior means are set to zero
and the diagonal elements of the inverse prior variance-covariance matrix are set to 1
for coefficients corresponding to non-deterministic terms. For deterministic coefficients the prior
variances are set to 10 by <code>v_i_det = 0.1</code>. The variances need to be specified as precisions,
i.e. as inverses of the variances. For further specifications such as the Minnesota prior see 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvecmodel_+3A_coint">coint</code></td>
<td>
<p>a named list of prior specifications for coefficients determining the
cointegration space of VEC models. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvecmodel_+3A_sigma">sigma</code></td>
<td>
<p>a named list of prior specifications for the error variance-covariance matrix
of the models. For the default specification of an inverse Wishart distribution
the prior degrees of freedom are set to the number of endogenous variables plus the rank of
the cointegration matrix. The prior variance is to 1. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvecmodel_+3A_ssvs">ssvs</code></td>
<td>
<p>optional; a named list of prior specifications for the SSVS algorithm.
Not allowed for TVP models. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvecmodel_+3A_bvs">bvs</code></td>
<td>
<p>optional; a named list of prior specifications for the BVS algorithm. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.bvecmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments of the function require named lists. Possible
specifications are described in the following. Note that it is important to specify the
priors in the correct list. Otherwise, the provided specification will be disregarded
and default values will be used.
</p>
<p>Argument <code>coef</code> contains the following elements
</p>

<dl>
<dt><code>v_i</code></dt><dd><p>a numeric specifying the prior precision of the coefficients. Default is 1.</p>
</dd>
<dt><code>v_i_det</code></dt><dd><p>a numeric specifying the prior precision of coefficients that correspond
to deterministic terms. Default is 0.1.</p>
</dd>
<dt><code>const</code></dt><dd><p>a character specifying the prior mean of coefficients, which correspond
to the intercept. If <code>const = "mean"</code>, the means of the series of endogenous variables
are used as prior means. If <code>const = "first"</code>, the first values of the series of endogenous
variables are used as prior means.</p>
</dd>
<dt><code>minnesota</code></dt><dd><p>a list of length 4 containing parameters for the calculation of
the Minnesota prior, where the element names must be <code>kappa0</code>, <code>kappa1</code>, <code>kappa2</code> and <code>kappa3</code>.
For the endogenous variable <code class="reqn">i</code> the prior variance of the <code class="reqn">l</code>th lag of regressor <code class="reqn">j</code> is obtained as
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0}}{l^2} \textrm{ for own lags of endogenous variables,}</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0} \kappa_{1}}{l^2} \frac{\sigma_{i}^2}{\sigma_{j}^2} \textrm{ for endogenous variables other than own lags,}</code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0} \kappa_{2}}{(l+1)^2} \frac{\sigma_{i}^2}{\sigma_{j}^2} \textrm{ for exogenous variables,}</code>
</p>

<p style="text-align: center;"><code class="reqn"> \kappa_{0} \kappa_{3} \sigma_{i}^2 \textrm{ for deterministic terms,}</code>
</p>

<p>where <code class="reqn">\sigma_{i}</code> is the residual standard deviation of variable <code class="reqn">i</code> of an unrestricted
LS estimate. For exogenous variables <code class="reqn">\sigma_{i}</code> is the sample standard deviation.
</p>
<p>The function only provides priors for the non-cointegration part of the model. However,
the residual standard errors <code class="reqn">\sigma_i</code> are based on an unrestricted LS regression of the
endogenous variables on the error correction term and the non-cointegration regressors.</p>
</dd>
<dt><code>max_var</code></dt><dd><p>a numeric specifying the maximum prior variance that is allowed for
non-deterministic coefficients.</p>
</dd>
<dt><code>shape</code></dt><dd><p>a numeric specifying the prior shape parameter of the error term of the
state equation. Only used for models with time varying parameters. Default is 3.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric specifying the prior rate parameter of the error term of the
state equation. Only used for models with time varying parameters. Default is 0.0001.</p>
</dd>
<dt><code>rate_det</code></dt><dd><p>a numeric specifying the prior rate parameter of the error term of the
state equation for coefficients, which correspond to deterministic terms.
Only used for models with time varying parameters. Default is 0.01.</p>
</dd>
</dl>

<p>If <code>minnesota</code> is specified, elements <code>v_i</code> and <code>v_i_det</code> are ignored.
</p>
<p>Argument <code>coint</code> can contain the following elements:
</p>

<dl>
<dt><code>v_i</code></dt><dd><p>numeric between 0 and 1 specifying the shrinkage of the cointegration space prior. Default is 0.</p>
</dd>
<dt><code>p_tau_i</code></dt><dd><p>numeric of the diagonal elements of the inverse prior matrix of
the central location of the cointegration space <code class="reqn">sp(\beta)</code>. Default is 1.</p>
</dd>
<dt><code>shape</code></dt><dd><p>an integer specifying the prior degrees of freedom of the error term of the state equation
of the loading matrix <code class="reqn">\alpha</code>. Default is 3.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric specifying the prior variance of error term of the state equation
of the loading matrix <code class="reqn">\alpha</code>. Default is 0.0001.</p>
</dd>
<dt><code>rho</code></dt><dd><p>a numeric specifying the autocorrelation coefficient
of the state equation of <code class="reqn">\beta</code>. It must be smaller than 1. Default is 0.999.
Note that in contrast to Koop et al. (2011) <code class="reqn">\rho</code> is not drawn in the Gibbs sampler of
this package yet.</p>
</dd>
</dl>

<p>Argument <code>sigma</code> can contain the following elements:
</p>

<dl>
<dt><code>df</code></dt><dd><p>an integer or character specifying the prior degrees of freedom of the error term. Only
used, if the prior is inverse Wishart.
Default is <code>"k"</code>, which indicates the amount of endogenous variables in the respective model.
<code>"k + 3"</code> can be used to set the prior to the amount of endogenous variables plus 3. If an integer
is provided, the degrees of freedom are set to this value in all models.
In all cases the rank <code class="reqn">r</code> of the cointegration matrix is automatically added.</p>
</dd>
<dt><code>scale</code></dt><dd><p>a numeric specifying the prior error variance of endogenous variables.
Default is 1.</p>
</dd>
<dt><code>shape</code></dt><dd><p>a numeric or character specifying the prior shape parameter of the error term. Only
used, if the prior is inverse gamma or if time varying volatilities are estimated.
For models with constant volatility the default is <code>"k"</code>, which indicates the amount of endogenous
variables in the respective country model. <code>"k + 3"</code> can be used to set the prior to the amount of
endogenous variables plus 3. If a numeric is provided, the shape parameters are set to this value in all
models. For models with stochastic volatility this prior refers to the error variance of the state
equation.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric specifying the prior rate parameter of the error term. Only used, if the
prior is inverse gamma or if time varying volatilities are estimated. For models with stochastic
volatility this prior refers to the error variance of the state equation.</p>
</dd>
<dt><code>mu</code></dt><dd><p>numeric of the prior mean of the initial state of the log-volatilities.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>v_i</code></dt><dd><p>numeric of the prior precision of the initial state of the log-volatilities.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>sigma_h</code></dt><dd><p>numeric of the initial draw for the variance of the log-volatilities.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>constant</code></dt><dd><p>numeric of the constant, which is added before taking the log of the squared errors.
Only used for models with time varying volatility.</p>
</dd>
<dt><code>covar</code></dt><dd><p>logical indicating whether error covariances should be estimated. Only used
in combination with an inverse gamma prior or stochastic volatility, for which <code>shape</code> and
<code>rate</code> must be specified.</p>
</dd>
</dl>

<p><code>df</code> and <code>scale</code> must be specified for an inverse Wishart prior. <code>shape</code> and <code>rate</code>
are required for an inverse gamma prior. For structural models or models with stochastic volatility
only a gamma prior specification is allowed.
</p>
<p>Argument <code>ssvs</code> can contain the following elements:
</p>

<dl>
<dt><code>inprior</code></dt><dd><p>a numeric between 0 and 1 specifying the prior probability
of a variable to be included in the model.</p>
</dd>
<dt><code>tau</code></dt><dd><p>a numeric vector of two elements containing the prior standard errors
of restricted variables (<code class="reqn">\tau_0</code>) as its first element and unrestricted variables (<code class="reqn">\tau_1</code>)
as its second.</p>
</dd>
<dt><code>semiautomatic</code></dt><dd><p>an numeric vector of two elements containing the
factors by which the standard errors associated with an unconstrained least squares
estimate of the model are multiplied to obtain the prior standard errors
of restricted (<code class="reqn">\tau_0</code>) and unrestricted (<code class="reqn">\tau_1</code>) variables, respectively.
This is the semiautomatic approach described in George et al. (2008).</p>
</dd>
<dt><code>covar</code></dt><dd><p>logical indicating if SSVS should also be applied to the error covariance matrix
as in George et al. (2008).</p>
</dd>
<dt><code>exclude_det</code></dt><dd><p>logical indicating if deterministic terms should be excluded from the SSVS algorithm.</p>
</dd>
<dt><code>minnesota</code></dt><dd><p>a numeric vector of length 4 containing parameters for the calculation of
the Minnesota-like inclusion priors. See below.</p>
</dd>
</dl>

<p>Either <code>tau</code> or <code>semiautomatic</code> must be specified.
</p>
<p>The argument <code>bvs</code> can contain the following elements
</p>

<dl>
<dt><code>inprior</code></dt><dd><p>a numeric between 0 and 1 specifying the prior probability
of a variable to be included in the model.</p>
</dd>
<dt><code>covar</code></dt><dd><p>logical indicating if BVS should also be applied to the error covariance matrix.</p>
</dd>
<dt><code>exclude_det</code></dt><dd><p>logical indicating if deterministic terms should be excluded from the BVS algorithm.</p>
</dd>
<dt><code>minnesota</code></dt><dd><p>a numeric vector of length 4 containing parameters for the calculation of
the Minnesota-like inclusion priors. See below.</p>
</dd>
</dl>

<p>If either <code>ssvs$minnesota</code> or <code>bvs$minnesota</code> is specified, prior inclusion probabilities
are calculated in a Minnesota-like fashion as
</p>

<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_1}{l}</code> </td><td style="text-align: left;"> for own lags of endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_2}{l}</code> </td><td style="text-align: left;"> for other endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_3}{1 + l}</code> </td><td style="text-align: left;"> for exogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa_{4}</code> </td><td style="text-align: left;"> for deterministic variables, 
</td>
</tr>

</table>

<p>for lag <code class="reqn">l</code> with <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, <code class="reqn">\kappa_3</code>, <code class="reqn">\kappa_4</code> as the first, second,
third and forth element in <code>ssvs$minnesota</code> or <code>bvs$minnesota</code>, respectively.
</p>


<h3>Value</h3>

<p>A list of models.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>George, E. I., Sun, D., &amp; Ni, S. (2008). Bayesian stochastic search for VAR model
restrictions. <em>Journal of Econometrics, 142</em>(1), 553&ndash;580.
<a href="https://doi.org/10.1016/j.jeconom.2007.08.017">doi:10.1016/j.jeconom.2007.08.017</a>
</p>
<p>Koop, G., León-González, R., &amp; Strachan R. W. (2010). Efficient posterior
simulation for cointegrated models with priors on the cointegration space.
<em>Econometric Reviews, 29</em>(2), 224&ndash;242.
<a href="https://doi.org/10.1080/07474930903382208">doi:10.1080/07474930903382208</a>
</p>
<p>Koop, G., León-González, R., &amp; Strachan R. W. (2011). Bayesian inference in
a time varying cointegration model. <em>Journal of Econometrics, 165</em>(2), 210&ndash;220.
<a href="https://doi.org/10.1016/j.jeconom.2011.07.007">doi:10.1016/j.jeconom.2011.07.007</a>
</p>
<p>Korobilis, D. (2013). VAR forecasting using Bayesian variable selection.
<em>Journal of Applied Econometrics, 28</em>(2), 204&ndash;230. <a href="https://doi.org/10.1002/jae.1271">doi:10.1002/jae.1271</a>
</p>
<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get data
data("e6")

# Create model
model &lt;- gen_vec(e6, p = 4, r = 1,
                 const = "unrestricted", seasonal = "unrestricted",
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burnin should be much higher.

# Add priors
model &lt;- add_priors(model)

</code></pre>

<hr>
<h2 id='add_priors.dfmodel'>Add Priors to Dynamic Factor Model</h2><span id='topic+add_priors.dfmodel'></span>

<h3>Description</h3>

<p>Adds prior specifications to a list of models, which was produced by
function <code><a href="#topic+gen_dfm">gen_dfm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfmodel'
add_priors(
  object,
  lambda = list(v_i = 0.01),
  sigma_u = list(shape = 5, rate = 4),
  a = list(v_i = 0.01),
  sigma_v = list(shape = 5, rate = 4),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_priors.dfmodel_+3A_object">object</code></td>
<td>
<p>a list, usually, the output of a call to <code><a href="#topic+gen_dfm">gen_dfm</a></code>.</p>
</td></tr>
<tr><td><code id="add_priors.dfmodel_+3A_lambda">lambda</code></td>
<td>
<p>a named list of prior specifications for the factor loadings in the measurement equation.
For the default specification the diagonal elements of the inverse prior variance-covariance matrix are set to 0.01.
The variances need to be specified as precisions, i.e. as inverses of the variances.</p>
</td></tr>
<tr><td><code id="add_priors.dfmodel_+3A_sigma_u">sigma_u</code></td>
<td>
<p>a named list of prior specifications for the error variance-covariance matrix. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.dfmodel_+3A_a">a</code></td>
<td>
<p>a named list of prior specifications for the coefficients of the transition equation.
For the default specification the diagonal elements of the inverse prior variance-covariance matrix are set to 0.01.
The variances need to be specified as precisions, i.e. as inverses of the variances.</p>
</td></tr>
<tr><td><code id="add_priors.dfmodel_+3A_sigma_v">sigma_v</code></td>
<td>
<p>a named list of prior specifications for the error variance-covariance matrix. See 'Details'.</p>
</td></tr>
<tr><td><code id="add_priors.dfmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>lambda</code> can only contain the element <code>v_i</code>, which is a numeric specifying the prior
precision of the loading factors of the measurement equation. Default is 0.01.
</p>
<p>The function assumes an inverse gamma prior for the errors of the measurement equation.
Argument <code>sigma_u</code> can contain the following elements:
</p>

<dl>
<dt><code>shape</code></dt><dd><p>a numeric or character specifying the prior shape parameter of the error terms
of the measurement equation. Default is 5.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric specifying the prior rate parameter of the error terms of the measurement
equation. Default is 4.</p>
</dd>
</dl>

<p>Argument <code>a</code> can only contain the element <code>v_i</code>, which is a numeric specifying the prior
precision of the coefficients of the transition equation. Default is 0.01.
</p>
<p>The function assumes an inverse gamma prior for the errors of the transition equation.
Argument <code>sigma_v</code> can contain the following elements:
</p>

<dl>
<dt><code>shape</code></dt><dd><p>a numeric or character specifying the prior shape parameter of the error terms
of the transition equation. Default is 5.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric specifying the prior rate parameter of the error terms of the transition
equation. Default is 4.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of models.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>Lütkepohl, H. (2007). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("bem_dfmdata")

# Generate model data
model &lt;- gen_dfm(x = bem_dfmdata, p = 1, n = 1,
                 iterations = 5000, burnin = 1000)
# Number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model,
                    lambda = list(v_i = .01),
                    sigma_u = list(shape = 5, rate = 4),
                    a = list(v_i = .01),
                    sigma_v = list(shape = 5, rate = 4))

</code></pre>

<hr>
<h2 id='bem_dfmdata'>FRED-QD data</h2><span id='topic+bem_dfmdata'></span>

<h3>Description</h3>

<p>The data set contains quarterly time series for 196 US macroeconomic variables from 1959Q3 to 2015Q3.
It was produced from file &quot;freddata_Q.csv&quot; of the data sets associated
with Chan, Koop, Poirier and Tobias (2019). Raw data are available at
<a href="https://web.ics.purdue.edu/~jltobias/second_edition/Chapter18/code_for_exercise_4/freddata_Q.csv">https://web.ics.purdue.edu/~jltobias/second_edition/Chapter18/code_for_exercise_4/freddata_Q.csv</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bem_dfmdata")
</code></pre>


<h3>Format</h3>

<p>A named time-series object with 225 rows and 196 variables. A detailed explanation of the
variables can be found in McCracken and Ng (2016).
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>McCracken, M. W., &amp; Ng, S. (2016). FRED-MD: A monthly database for macroeconomic research.
<em>Journal of Business &amp; Economic Statistics 34</em>(4), 574-589. <a href="https://doi.org/10.1080/07350015.2015.1086655">doi:10.1080/07350015.2015.1086655</a>
</p>

<hr>
<h2 id='bvar'>Bayesian Vector Autoregression Objects</h2><span id='topic+bvar'></span><span id='topic+plot.bvar'></span><span id='topic+predict.bvar'></span>

<h3>Description</h3>

<p><code>bvar</code> is used to create objects of class <code>"bvar"</code>.
</p>
<p>A plot function for objects of class <code>"bvar"</code>.
</p>
<p>Forecasting a Bayesian VAR object of class <code>"bvar"</code> with credible bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvar(
  data = NULL,
  exogen = NULL,
  y,
  x = NULL,
  A0 = NULL,
  A = NULL,
  B = NULL,
  C = NULL,
  Sigma = NULL
)

## S3 method for class 'bvar'
plot(x, ci = 0.95, type = "hist", ...)

## S3 method for class 'bvar'
predict(object, ..., n.ahead = 10, new_x = NULL, new_d = NULL, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvar_+3A_data">data</code></td>
<td>
<p>the original time-series object of endogenous variables.</p>
</td></tr>
<tr><td><code id="bvar_+3A_exogen">exogen</code></td>
<td>
<p>the original time-series object of unmodelled variables.</p>
</td></tr>
<tr><td><code id="bvar_+3A_y">y</code></td>
<td>
<p>a time-series object of endogenous variables with <code class="reqn">T</code> observations,
usually, a result of a call to <code><a href="#topic+gen_var">gen_var</a></code>.</p>
</td></tr>
<tr><td><code id="bvar_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bvar"</code>, usually, a result of a call to <code><a href="#topic+draw_posterior">draw_posterior</a></code>.</p>
</td></tr>
<tr><td><code id="bvar_+3A_a0">A0</code></td>
<td>
<p>either a <code class="reqn">K^2 \times S</code> matrix of MCMC coefficient draws of structural parameters or
a named list, where element <code>coeffs</code> contains a <code class="reqn">K^2 \times S</code> matrix of MCMC coefficient
draws of structural parameters and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed. For time varying parameter models
the coefficient matrix must be <code class="reqn">TK^2 \times S</code>. Draws of the error covariance matrix of the state
equation can be provided as a <code class="reqn">K^2 \times S</code> matrix in an additional list element.</p>
</td></tr>
<tr><td><code id="bvar_+3A_a">A</code></td>
<td>
<p>either a <code class="reqn">pK^2 \times S</code> matrix of MCMC coefficient draws of lagged endogenous variables or
a named list, where element <code>coeffs</code> contains a <code class="reqn">pK^2 \times S</code> matrix of MCMC coefficient draws
of lagged endogenous variables and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed. For time varying parameter models
the coefficient matrix must be <code class="reqn">pTK^2 \times S</code>. Draws of the error covariance matrix of the state
equation can be provided as a <code class="reqn">pK^2 \times S</code> matrix in an additional list element.</p>
</td></tr>
<tr><td><code id="bvar_+3A_b">B</code></td>
<td>
<p>either a <code class="reqn">((1 + s)MK) \times S</code> matrix of MCMC coefficient draws of unmodelled, non-deterministic variables
or a named list, where element <code>coeffs</code> contains a <code class="reqn">((1 + s)MK) \times S</code> matrix of MCMC coefficient draws of
unmodelled, non-deterministic variables and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed. For time varying parameter models
the coefficient matrix must be <code class="reqn">(1 + s)TMK \times S</code>. Draws of the error covariance matrix of the state
equation can be provided as a <code class="reqn">(1 + s)MK \times S</code> matrix in an additional list element.</p>
</td></tr>
<tr><td><code id="bvar_+3A_c">C</code></td>
<td>
<p>either a <code class="reqn">KN \times S</code> matrix of MCMC coefficient draws of deterministic terms or
a named list, where element <code>coeffs</code> contains a <code class="reqn">KN \times S</code> matrix of MCMC coefficient draws of
deterministic terms and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed. For time varying parameter models
the coefficient matrix must be <code class="reqn">TKN \times S</code>. Draws of the error covariance matrix of the state
equation can be provided as a <code class="reqn">KN \times S</code> matrix in an additional list element.</p>
</td></tr>
<tr><td><code id="bvar_+3A_sigma">Sigma</code></td>
<td>
<p>a <code class="reqn">K^2 \times S</code> matrix of MCMC draws for the error variance-covariance matrix or
a named list, where element <code>coeffs</code> contains a <code class="reqn">K^2 \times S</code> matrix of MCMC draws for the
error variance-covariance matrix and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed to the covariances. For time varying parameter models
the coefficient matrix must be <code class="reqn">TK^2 \times S</code>. Draws of the error covariance matrix of the state
equation can be provided as a <code class="reqn">K^2 \times S</code> matrix in an additional list element.</p>
</td></tr>
<tr><td><code id="bvar_+3A_ci">ci</code></td>
<td>
<p>a numeric between 0 and 1 specifying the probability mass covered by the
credible intervals. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="bvar_+3A_type">type</code></td>
<td>
<p>either <code>"hist"</code> (default) for histograms, <code>"trace"</code> for a trace plot
or <code>"boxplot"</code> for a boxplot. Only used for parameter draws of constant coefficients.</p>
</td></tr>
<tr><td><code id="bvar_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="bvar_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvar"</code>, usually, a result of a call to
<code><a href="#topic+bvar">bvar</a></code> or <code><a href="#topic+bvec_to_bvar">bvec_to_bvar</a></code>.</p>
</td></tr>
<tr><td><code id="bvar_+3A_n.ahead">n.ahead</code></td>
<td>
<p>number of steps ahead at which to predict.</p>
</td></tr>
<tr><td><code id="bvar_+3A_new_x">new_x</code></td>
<td>
<p>an object of class <code>ts</code> of new non-deterministic, exogenous variables.
The object must have the same frequency as the time series in <code>object[["x"]]</code> and must contain
at least all necessary observations for the predicted period.</p>
</td></tr>
<tr><td><code id="bvar_+3A_new_d">new_d</code></td>
<td>
<p>a matrix of new deterministic variables. Must have <code>n.ahead</code> rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the VARX model
</p>
<p style="text-align: center;"><code class="reqn">A_0 y_t = \sum_{i = 1}^{p} A_i y_{t-i} + \sum_{i = 0}^{s} B_i x_{t - i} + C d_t + u_t</code>
</p>

<p>the function collects the S draws of a Gibbs sampler (after the burn-in phase) in a standardised object,
where <code class="reqn">y_t</code> is a K-dimensional vector of endogenous variables,
<code class="reqn">A_0</code> is a <code class="reqn">K \times K</code> matrix of structural coefficients.
<code class="reqn">A_i</code> is a <code class="reqn">K \times K</code> coefficient matrix of lagged endogenous variabels.
<code class="reqn">x_t</code> is an M-dimensional vector of unmodelled, non-deterministic variables
and <code class="reqn">B_i</code> its corresponding coefficient matrix.
<code class="reqn">d_t</code> is an N-dimensional vector of deterministic terms
and <code class="reqn">C</code> its corresponding coefficient matrix.
<code class="reqn">u_t</code> is an error term with <code class="reqn">u_t \sim N(0, \Sigma_u)</code>.
</p>
<p>For time varying parameter and stochastic volatility models the respective coefficients and
error covariance matrix of the above model are assumed to be time varying, respectively.
</p>
<p>The draws of the different coefficient matrices provided in <code>A0</code>, <code>A</code>,
<code>B</code>, <code>C</code> and <code>Sigma</code> have to correspond to the same MCMC iterations.
</p>
<p>For the VAR model
</p>
<p style="text-align: center;"><code class="reqn">A_0 y_t = \sum_{i = 1}^{p} A_{i} y_{t-i} + \sum_{i = 0}^{s} B_{i} x_{t-i} + C D_t + u_t,</code>
</p>

<p>with <code class="reqn">u_t \sim N(0, \Sigma)</code> the function produces <code>n.ahead</code> forecasts.
</p>


<h3>Value</h3>

<p>An object of class <code>"bvar"</code> containing the following components, if specified:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>the original time-series object of endogenous variables.</p>
</td></tr>
<tr><td><code>exogen</code></td>
<td>
<p>the original time-series object of unmodelled variables.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of endogenous variables.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a <code class="reqn">(pK + (1+s)M + N) \times T</code> matrix of regressor variables.</p>
</td></tr>
<tr><td><code>A0</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of coefficient draws of structural parameters. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>A0_lambda</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of inclusion parameters for structural parameters.</p>
</td></tr>
<tr><td><code>A0_sigma</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of the error covariance matrices of the structural parameters in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>an <code class="reqn">S \times pK^2</code> &quot;mcmc&quot; object of coefficient draws of lagged endogenous variables. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>A_lambda</code></td>
<td>
<p>an <code class="reqn">S \times pK^2</code> &quot;mcmc&quot; object of inclusion parameters for lagged endogenous variables.</p>
</td></tr>
<tr><td><code>A_sigma</code></td>
<td>
<p>an <code class="reqn">S \times pK^2</code> &quot;mcmc&quot; object of the error covariance matrices of coefficients of lagged endogenous variables in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>an <code class="reqn">S \times ((1 + s)MK)</code> &quot;mcmc&quot; object of coefficient draws of unmodelled, non-deterministic variables. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>B_lambda</code></td>
<td>
<p>an <code class="reqn">S \times ((1 + s)MK)</code> &quot;mcmc&quot; object of inclusion parameters for unmodelled, non-deterministic variables.</p>
</td></tr>
<tr><td><code>B_sigma</code></td>
<td>
<p>an <code class="reqn">S \times ((1 + s)MK)</code> &quot;mcmc&quot; object of the error covariance matrices of coefficients of unmodelled, non-deterministic variables in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>an <code class="reqn">S \times NK</code> &quot;mcmc&quot; object of coefficient draws of deterministic terms. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>C_lambda</code></td>
<td>
<p>an <code class="reqn">S \times NK</code> &quot;mcmc&quot; object of inclusion parameters for deterministic terms.</p>
</td></tr>
<tr><td><code>C_sigma</code></td>
<td>
<p>an <code class="reqn">S \times NK</code> &quot;mcmc&quot; object of the error covariance matrices of coefficients of deterministic terms in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of variance-covariance draws. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Sigma_lambda</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of inclusion parameters for error covariances.</p>
</td></tr>
<tr><td><code>Sigma_sigma</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of the error covariance matrices of the coefficients of the error covariance matrix of the measurement equation of a model with time varying parameters.</p>
</td></tr>
<tr><td><code>specifications</code></td>
<td>
<p>a list containing information on the model specification.</p>
</td></tr>
</table>
<p>A time-series object of class <code>"bvarprd"</code>.
</p>


<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get data
data("e1")
e1 &lt;- diff(log(e1))
e1 &lt;- window(e1, end = c(1978, 4))

# Generate model data
data &lt;- gen_var(e1, p = 2, deterministic = "const")

# Add priors
model &lt;- add_priors(data,
                    coef = list(v_i = 0, v_i_det = 0),
                    sigma = list(df = 0, scale = .00001))

# Set RNG seed for reproducibility 
set.seed(1234567)

iterations &lt;- 400 # Number of iterations of the Gibbs sampler
# Chosen number of iterations and burnin should be much higher.
burnin &lt;- 100 # Number of burn-in draws
draws &lt;- iterations + burnin # Total number of MCMC draws

y &lt;- t(model$data$Y)
x &lt;- t(model$data$Z)
tt &lt;- ncol(y) # Number of observations
k &lt;- nrow(y) # Number of endogenous variables
m &lt;- k * nrow(x) # Number of estimated coefficients

# Priors
a_mu_prior &lt;- model$priors$coefficients$mu # Vector of prior parameter means
a_v_i_prior &lt;- model$priors$coefficients$v_i # Inverse of the prior covariance matrix

u_sigma_df_prior &lt;- model$priors$sigma$df # Prior degrees of freedom
u_sigma_scale_prior &lt;- model$priors$sigma$scale # Prior covariance matrix
u_sigma_df_post &lt;- tt + u_sigma_df_prior # Posterior degrees of freedom

# Initial values
u_sigma_i &lt;- diag(1 / .00001, k)

# Data containers for posterior draws
draws_a &lt;- matrix(NA, m, iterations)
draws_sigma &lt;- matrix(NA, k^2, iterations)

# Start Gibbs sampler
for (draw in 1:draws) {
 # Draw conditional mean parameters
 a &lt;- post_normal(y, x, u_sigma_i, a_mu_prior, a_v_i_prior)

 # Draw variance-covariance matrix
 u &lt;- y - matrix(a, k) %*% x # Obtain residuals
 u_sigma_scale_post &lt;- solve(u_sigma_scale_prior + tcrossprod(u))
 u_sigma_i &lt;- matrix(rWishart(1, u_sigma_df_post, u_sigma_scale_post)[,, 1], k)

 # Store draws
 if (draw &gt; burnin) {
  draws_a[, draw - burnin] &lt;- a
  draws_sigma[, draw - burnin] &lt;- solve(u_sigma_i)
 }
}

# Generate bvar object
bvar_est &lt;- bvar(y = model$data$Y, x = model$data$Z,
                 A = draws_a[1:18,], C = draws_a[19:21, ],
                 Sigma = draws_sigma)
                 

# Load data 
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate model
model &lt;- gen_var(e1, p = 1, deterministic = 2,
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burn-in should be much higher.

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Plot draws
plot(object)


# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100
e1 &lt;- window(e1, end = c(1978, 4))

# Generate model data
model &lt;- gen_var(e1, p = 0, deterministic = "const",
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Generate forecasts
bvar_pred &lt;- predict(object, n.ahead = 10, new_d = rep(1, 10))

# Plot forecasts
plot(bvar_pred)

</code></pre>

<hr>
<h2 id='bvarpost'>Posterior Simulation for BVAR Models</h2><span id='topic+bvarpost'></span>

<h3>Description</h3>

<p>Produces draws from the posterior distributions of Bayesian VAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvarpost(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvarpost_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvarmodel"</code>, usually, a result of a call to <code><a href="#topic+gen_var">gen_var</a></code>
in combination with <code><a href="#topic+add_priors">add_priors</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements commonly used posterior simulation algorithms for Bayesian VAR models with
both constant and time varying parameters (TVP) as well as stochastic volatility. It can produce posterior
draws for standard BVAR models with independent normal-Wishart priors, which can be augmented by stochastic
search variable selection (SSVS) as proposed by Geroge et al. (2008) or Bayesian variable selection (BVS)
as proposed in Korobilis (2013). Both SSVS or BVS can also be applied to the covariances of the error term.
</p>
<p>The implementation follows the descriptions in Chan et al. (2019), George et al. (2008) and Korobilis (2013).
For all approaches the SUR form of a VAR model is used to obtain posterior draws. The algorithm is implemented
in C++ to reduce calculation time.
</p>
<p>The function also supports structural BVAR models, where the structural coefficients are estimated from
contemporary endogenous variables, which corresponds to the so-called (A-model). Currently, only
specifications are supported, where the structural matrix contains ones on its diagonal and all lower
triangular elements are freely estimated. Since posterior draws are obtained based on the SUR form of
the VAR model, the structural coefficients are drawn jointly with the other coefficients.
</p>


<h3>Value</h3>

<p>An object of class <code>"bvar"</code>.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>George, E. I., Sun, D., &amp; Ni, S. (2008). Bayesian stochastic search for VAR model
restrictions. <em>Journal of Econometrics, 142</em>(1), 553&ndash;580.
<a href="https://doi.org/10.1016/j.jeconom.2007.08.017">doi:10.1016/j.jeconom.2007.08.017</a>
</p>
<p>Korobilis, D. (2013). VAR forecasting using Bayesian variable selection.
<em>Journal of Applied Econometrics, 28</em>(2), 204&ndash;230. <a href="https://doi.org/10.1002/jae.1271">doi:10.1002/jae.1271</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Create model
model &lt;- gen_var(e1, p = 2, deterministic = "const",
                 iterations = 50, burnin = 10)
# Number of iterations and burnin should be much higher.

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws 
object &lt;- bvarpost(model)

</code></pre>

<hr>
<h2 id='bvartools-package'>bvartools: Bayesian Inference of Vector Autoregressive and Error Correction Models</h2><span id='topic+bvartools'></span><span id='topic+bvartools-package'></span>

<h3>Description</h3>

<p>Assists in the set-up of algorithms for Bayesian inference of vector autoregressive (VAR) and error correction (VEC) models. Functions for posterior simulation, forecasting, impulse response analysis and forecast error variance decomposition are largely based on the introductory texts of Chan, Koop, Poirier and Tobias (2019, ISBN: 9781108437493), Koop and Korobilis (2010) <a href="https://doi.org/10.1561/0800000013">doi:10.1561/0800000013</a> and Luetkepohl (2006, ISBN: 9783540262398).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Franz X. Mohr <a href="mailto:franz.x.mohr@outlook.com">franz.x.mohr@outlook.com</a> (0009-0003-8890-7781)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/franzmohr/bvartools">https://github.com/franzmohr/bvartools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/franzmohr/bvartools/issues">https://github.com/franzmohr/bvartools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bvec'>Bayesian Vector Error Correction Objects</h2><span id='topic+bvec'></span><span id='topic+plot.bvec'></span>

<h3>Description</h3>

<p>'bvec' is used to create objects of class <code>"bvec"</code>.
</p>
<p>A plot function for objects of class <code>"bvec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvec(
  y,
  alpha = NULL,
  beta = NULL,
  beta_x = NULL,
  beta_d = NULL,
  r = NULL,
  Pi = NULL,
  Pi_x = NULL,
  Pi_d = NULL,
  w = NULL,
  w_x = NULL,
  w_d = NULL,
  Gamma = NULL,
  Upsilon = NULL,
  C = NULL,
  x = NULL,
  x_x = NULL,
  x_d = NULL,
  A0 = NULL,
  Sigma = NULL,
  data = NULL,
  exogen = NULL
)

## S3 method for class 'bvec'
plot(x, ci = 0.95, type = "hist", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvec_+3A_y">y</code></td>
<td>
<p>a time-series object of differenced endogenous variables,
usually, a result of a call to <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="bvec_+3A_alpha">alpha</code></td>
<td>
<p>a <code class="reqn">Kr \times S</code> matrix of MCMC coefficient draws of the loading matrix <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="bvec_+3A_beta">beta</code></td>
<td>
<p>a <code class="reqn">Kr \times S</code> matrix of MCMC coefficient draws of cointegration matrix <code class="reqn">\beta</code>
corresponding to the endogenous variables of the model.</p>
</td></tr>
<tr><td><code id="bvec_+3A_beta_x">beta_x</code></td>
<td>
<p>a <code class="reqn">Mr \times S</code> matrix of MCMC coefficient draws of cointegration matrix <code class="reqn">\beta</code>
corresponding to unmodelled, non-deterministic variables.</p>
</td></tr>
<tr><td><code id="bvec_+3A_beta_d">beta_d</code></td>
<td>
<p>a <code class="reqn">N^{R}r \times S</code> matrix of MCMC coefficient draws of cointegration matrix <code class="reqn">\beta</code>
corresponding to restricted deterministic terms.</p>
</td></tr>
<tr><td><code id="bvec_+3A_r">r</code></td>
<td>
<p>an integer of the rank of the cointegration matrix.</p>
</td></tr>
<tr><td><code id="bvec_+3A_pi">Pi</code></td>
<td>
<p>a <code class="reqn">K^2 \times S</code> matrix of MCMC coefficient draws of endogenous varaibles in the cointegration matrix.</p>
</td></tr>
<tr><td><code id="bvec_+3A_pi_x">Pi_x</code></td>
<td>
<p>a <code class="reqn">KM \times S</code> matrix of MCMC coefficient draws of unmodelled, non-deterministic variables in the cointegration matrix.</p>
</td></tr>
<tr><td><code id="bvec_+3A_pi_d">Pi_d</code></td>
<td>
<p>a <code class="reqn">KN^{R} \times S</code> matrix of MCMC coefficient draws of restricted deterministic terms.</p>
</td></tr>
<tr><td><code id="bvec_+3A_w">w</code></td>
<td>
<p>a time-series object of lagged endogenous variables in levels, which enter the
cointegration term, usually, a result of a call to <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="bvec_+3A_w_x">w_x</code></td>
<td>
<p>a time-series object of lagged unmodelled, non-deterministic variables in levels, which enter the
cointegration term, usually, a result of a call to <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="bvec_+3A_w_d">w_d</code></td>
<td>
<p>a time-series object of deterministic terms, which enter the
cointegration term, usually, a result of a call to <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="bvec_+3A_gamma">Gamma</code></td>
<td>
<p>a <code class="reqn">(p-1)K^2 \times S</code> matrix of MCMC coefficient draws of differenced lagged endogenous variables or
a named list, where element <code>coeffs</code> contains a <code class="reqn">(p - 1)K^2 \times S</code> matrix of MCMC coefficient draws
of lagged differenced endogenous variables and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed.</p>
</td></tr>
<tr><td><code id="bvec_+3A_upsilon">Upsilon</code></td>
<td>
<p>an <code class="reqn">sMK \times S</code> matrix of MCMC coefficient draws of differenced unmodelled, non-deterministic variables or
a named list, where element <code>coeffs</code> contains a <code class="reqn">sMK \times S</code> matrix of MCMC coefficient draws of
unmodelled, non-deterministic variables and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed.</p>
</td></tr>
<tr><td><code id="bvec_+3A_c">C</code></td>
<td>
<p>an <code class="reqn">KN^{UR} \times S</code> matrix of MCMC coefficient draws of unrestricted deterministic terms or
a named list, where element <code>coeffs</code> contains a <code class="reqn">KN^{UR} \times S</code> matrix of MCMC coefficient draws of
deterministic terms and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed.</p>
</td></tr>
<tr><td><code id="bvec_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bvec"</code>, usually, a result of a call to <code><a href="#topic+draw_posterior">draw_posterior</a></code>.</p>
</td></tr>
<tr><td><code id="bvec_+3A_x_x">x_x</code></td>
<td>
<p>a time-series object of <code class="reqn">Ms</code> differenced unmodelled regressors.</p>
</td></tr>
<tr><td><code id="bvec_+3A_x_d">x_d</code></td>
<td>
<p>a time-series object of <code class="reqn">N^{UR}</code> deterministic terms that do not enter the
cointegration term.</p>
</td></tr>
<tr><td><code id="bvec_+3A_a0">A0</code></td>
<td>
<p>either a <code class="reqn">K^2 \times S</code> matrix of MCMC coefficient draws of structural parameters or
a named list, where element <code>coeffs</code> contains a <code class="reqn">K^2 \times S</code> matrix of MCMC coefficient
draws of structural parameters and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed.</p>
</td></tr>
<tr><td><code id="bvec_+3A_sigma">Sigma</code></td>
<td>
<p>a <code class="reqn">K^2 \times S</code> matrix of MCMC draws for the error variance-covariance matrix or
a named list, where element <code>coeffs</code> contains a <code class="reqn">K^2 \times S</code> matrix of MCMC draws for the
error variance-covariance matrix and element <code>lambda</code> contains the corresponding draws of inclusion
parameters in case variable selection algorithms were employed to the covariances.</p>
</td></tr>
<tr><td><code id="bvec_+3A_data">data</code></td>
<td>
<p>the original time-series object of endogenous variables.</p>
</td></tr>
<tr><td><code id="bvec_+3A_exogen">exogen</code></td>
<td>
<p>the original time-series object of unmodelled variables.</p>
</td></tr>
<tr><td><code id="bvec_+3A_ci">ci</code></td>
<td>
<p>interval used to calculate credible bands for time-varying parameters.</p>
</td></tr>
<tr><td><code id="bvec_+3A_type">type</code></td>
<td>
<p>either <code>"hist"</code> (default) for histograms, <code>"trace"</code> for a trace plot
or <code>"boxplot"</code> for a boxplot. Only used for parameter draws of constant coefficients.</p>
</td></tr>
<tr><td><code id="bvec_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the vector error correction model with unmodelled exogenous variables (VECX) 
</p>
<p style="text-align: center;"><code class="reqn">A_0 \Delta y_t = \Pi^{+} \begin{pmatrix} y_{t-1} \\ x_{t-1} \\ d^{R}_{t-1} \end{pmatrix} +
\sum_{i = 1}^{p-1} \Gamma_i \Delta y_{t-i} +
\sum_{i = 0}^{s-1} \Upsilon_i \Delta x_{t-i} +
C^{UR} d^{UR}_t + u_t</code>
</p>

<p>the function collects the <code class="reqn">S</code> draws of a Gibbs sampler in a standardised object,
where <code class="reqn">\Delta y_t</code> is a K-dimensional vector of differenced endogenous variables
and <code class="reqn">A_0</code> is a <code class="reqn">K \times K</code> matrix of structural coefficients.
<code class="reqn">\Pi^{+} = \left[ \Pi, \Pi^{x}, \Pi^{d} \right]</code> is
the coefficient matrix of the error correction term, where
<code class="reqn">y_{t-1}</code>, <code class="reqn">x_{t-1}</code> and <code class="reqn">d^{R}_{t-1}</code> are the first lags of endogenous,
exogenous variables in levels and restricted deterministic terms, respectively.
<code class="reqn">\Pi</code>, <code class="reqn">\Pi^{x}</code>, and <code class="reqn">\Pi^{d}</code> are the corresponding coefficient matrices, respectively.
<code class="reqn">\Gamma_i</code> is a coefficient matrix of lagged differenced endogenous variabels.
<code class="reqn">\Delta x_t</code> is an M-dimensional vector of unmodelled, non-deterministic variables
and <code class="reqn">\Upsilon_i</code> its corresponding coefficient matrix. <code class="reqn">d_t</code> is an
<code class="reqn">N^{UR}</code>-dimensional vector of unrestricted deterministics and <code class="reqn">C^{UR}</code>
the corresponding coefficient matrix.
<code class="reqn">u_t</code> is an error term with <code class="reqn">u_t \sim N(0, \Sigma_u)</code>.
</p>
<p>For time varying parameter and stochastic volatility models the respective coefficients and
error covariance matrix of the above model are assumed to be time varying, respectively.
</p>
<p>The draws of the different coefficient matrices provided in <code>alpha</code>, <code>beta</code>,
<code>Pi</code>, <code>Pi_x</code>, <code>Pi_d</code>, <code>A0</code>, <code>Gamma</code>, <code>Ypsilon</code>,
<code>C</code> and <code>Sigma</code> have to correspond to the same MCMC iteration.
</p>


<h3>Value</h3>

<p>An object of class <code>"gvec"</code> containing the following components, if specified:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>the original time-series object of endogenous variables.</p>
</td></tr>
<tr><td><code>exogen</code></td>
<td>
<p>the original time-series object of unmodelled variables.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a time-series object of differenced endogenous variables.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a time-series object of lagged endogenous variables in levels, which enter the
cointegration term.</p>
</td></tr>
<tr><td><code>w_x</code></td>
<td>
<p>a time-series object of lagged unmodelled, non-deterministic variables in levels, which enter the
cointegration term.</p>
</td></tr>
<tr><td><code>w_d</code></td>
<td>
<p>a time-series object of deterministic terms, which enter the
cointegration term.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a time-series object of <code class="reqn">K(p - 1)</code> differenced endogenous variables</p>
</td></tr>
<tr><td><code>x_x</code></td>
<td>
<p>a time-series object of <code class="reqn">Ms</code> differenced unmodelled regressors.</p>
</td></tr>
<tr><td><code>x_d</code></td>
<td>
<p>a time-series object of <code class="reqn">N^{UR}</code> deterministic terms that do not enter the
cointegration term.</p>
</td></tr>
<tr><td><code>A0</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of coefficient draws of structural parameters. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>A0_lambda</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of inclusion parameters for coefficients
corresponding to structural parameters.</p>
</td></tr>
<tr><td><code>A0_sigma</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of the error covariance matrices of the structural parameters in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>an <code class="reqn">S \times Kr</code> &quot;mcmc&quot; object of coefficient draws of loading parameters. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>an <code class="reqn">S \times ((K + M + N^{R})r)</code> &quot;mcmc&quot; object of coefficient draws of cointegration parameters
corresponding to the endogenous variables of the model. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>beta_x</code></td>
<td>
<p>an <code class="reqn">S \times KM</code> &quot;mcmc&quot; object of coefficient draws of cointegration parameters
corresponding to unmodelled, non-deterministic variables. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>beta_d</code></td>
<td>
<p>an <code class="reqn">S \times KN^{R}</code> &quot;mcmc&quot; object of coefficient draws of cointegration parameters
corresponding to restricted deterministic variables. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Pi</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of coefficient draws of endogenous variables in the cointegration matrix. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Pi_x</code></td>
<td>
<p>an <code class="reqn">S \times KM</code> &quot;mcmc&quot; object of coefficient draws of unmodelled, non-deterministic variables in the cointegration matrix. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Pi_d</code></td>
<td>
<p>an <code class="reqn">S \times KN^{R}</code> &quot;mcmc&quot; object of coefficient draws of restricted deterministic variables in the cointegration matrix. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>an <code class="reqn">S \times (p-1)K^2</code> &quot;mcmc&quot; object of coefficient draws of differenced lagged endogenous variables. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Gamma_lamba</code></td>
<td>
<p>an <code class="reqn">S \times (p-1)K^2</code> &quot;mcmc&quot; object of inclusion parameters for coefficients
corresponding to differenced lagged endogenous variables.</p>
</td></tr>
<tr><td><code>Gamma_sigma</code></td>
<td>
<p>an <code class="reqn">S \times (p - 1)K^2</code> &quot;mcmc&quot; object of the error covariance matrices of the coefficients of lagged endogenous variables in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>Upsilon</code></td>
<td>
<p>an <code class="reqn">S \times sMK</code> &quot;mcmc&quot; object of coefficient draws of differenced unmodelled, non-deterministic variables. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Upsilon_lambda</code></td>
<td>
<p>an <code class="reqn">S \times sMK</code> &quot;mcmc&quot; object of inclusion parameters for coefficients
corresponding to differenced unmodelled, non-deterministic variables.</p>
</td></tr>
<tr><td><code>Upsilon_sigma</code></td>
<td>
<p>an <code class="reqn">S \times sMK</code> &quot;mcmc&quot; object of the error covariance matrices of the coefficients of unmodelled, non-deterministic variables in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>an <code class="reqn">S \times KN^{UR}</code> &quot;mcmc&quot; object of coefficient draws of deterministic terms that
do not enter the cointegration term. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>C_lambda</code></td>
<td>
<p>an <code class="reqn">S \times KN^{UR}</code> &quot;mcmc&quot; object of inclusion parameters for coefficients
corresponding to deterministic terms, that do not enter the conintegration term.</p>
</td></tr>
<tr><td><code>C_sigma</code></td>
<td>
<p>an <code class="reqn">S \times KN^{UR}</code> &quot;mcmc&quot; object of the error covariance matrices of the coefficients of deterministic terms, which do not enter the cointegration term, in a model with time varying parameters.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of variance-covariance draws. In case of time varying parameters a list of such objects.</p>
</td></tr>
<tr><td><code>Sigma_lambda</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object inclusion parameters for the variance-covariance matrix.</p>
</td></tr>
<tr><td><code>Sigma_sigma</code></td>
<td>
<p>an <code class="reqn">S \times K^2</code> &quot;mcmc&quot; object of the error covariance matrices of the coefficients of the error covariance matrix of the measurement equation of a model with time varying parameters.</p>
</td></tr>
<tr><td><code>specifications</code></td>
<td>
<p>a list containing information on the model specification.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e6")
# Generate model
data &lt;- gen_vec(e6, p = 4, r = 1, const = "unrestricted", season = "unrestricted")
# Obtain data matrices
y &lt;- t(data$data$Y)
w &lt;- t(data$data$W)
x &lt;- t(data$data$X)

# Reset random number generator for reproducibility
set.seed(1234567)

iterations &lt;- 400 # Number of iterations of the Gibbs sampler
# Chosen number of iterations should be much higher, e.g. 30000.

burnin &lt;- 100 # Number of burn-in draws
draws &lt;- iterations + burnin

r &lt;- 1 # Set rank

tt &lt;- ncol(y) # Number of observations
k &lt;- nrow(y) # Number of endogenous variables
k_w &lt;- nrow(w) # Number of regressors in error correction term
k_x &lt;- nrow(x) # Number of differenced regressors and unrestrictec deterministic terms

k_alpha &lt;- k * r # Number of elements in alpha
k_beta &lt;- k_w * r # Number of elements in beta
k_gamma &lt;- k * k_x

# Set uninformative priors
a_mu_prior &lt;- matrix(0, k_x * k) # Vector of prior parameter means
a_v_i_prior &lt;- diag(0, k_x * k) # Inverse of the prior covariance matrix

v_i &lt;- 0
p_tau_i &lt;- diag(1, k_w)

u_sigma_df_prior &lt;- r # Prior degrees of freedom
u_sigma_scale_prior &lt;- diag(0, k) # Prior covariance matrix
u_sigma_df_post &lt;- tt + u_sigma_df_prior # Posterior degrees of freedom

# Initial values
beta &lt;- matrix(c(1, -4), k_w, r)
u_sigma_i &lt;- diag(1 / .0001, k)
g_i &lt;- u_sigma_i

# Data containers
draws_alpha &lt;- matrix(NA, k_alpha, iterations)
draws_beta &lt;- matrix(NA, k_beta, iterations)
draws_pi &lt;- matrix(NA, k * k_w, iterations)
draws_gamma &lt;- matrix(NA, k_gamma, iterations)
draws_sigma &lt;- matrix(NA, k^2, iterations)

# Start Gibbs sampler
for (draw in 1:draws) {
  # Draw conditional mean parameters
  temp &lt;- post_coint_kls(y = y, beta = beta, w = w, x = x, sigma_i = u_sigma_i,
                         v_i = v_i, p_tau_i = p_tau_i, g_i = g_i,
                         gamma_mu_prior = a_mu_prior,
                         gamma_v_i_prior = a_v_i_prior)
  alpha &lt;- temp$alpha
  beta &lt;- temp$beta
  Pi &lt;- temp$Pi
  gamma &lt;- temp$Gamma
  
  # Draw variance-covariance matrix
  u &lt;- y - Pi %*% w - matrix(gamma, k) %*% x
  u_sigma_scale_post &lt;- solve(tcrossprod(u) +
     v_i * alpha %*% tcrossprod(crossprod(beta, p_tau_i) %*% beta, alpha))
  u_sigma_i &lt;- matrix(rWishart(1, u_sigma_df_post, u_sigma_scale_post)[,, 1], k)
  u_sigma &lt;- solve(u_sigma_i)
  
  # Update g_i
  g_i &lt;- u_sigma_i
  
  # Store draws
  if (draw &gt; burnin) {
    draws_alpha[, draw - burnin] &lt;- alpha
    draws_beta[, draw - burnin] &lt;- beta
    draws_pi[, draw - burnin] &lt;- Pi
    draws_gamma[, draw - burnin] &lt;- gamma
    draws_sigma[, draw - burnin] &lt;- u_sigma
  }
}

# Number of non-deterministic coefficients
k_nondet &lt;- (k_x - 4) * k

# Generate bvec object
bvec_est &lt;- bvec(y = data$data$Y, w = data$data$W,
                 x = data$data$X[, 1:6],
                 x_d = data$data$X[, 7:10],
                 Pi = draws_pi,
                 Gamma = draws_gamma[1:k_nondet,],
                 C = draws_gamma[(k_nondet + 1):nrow(draws_gamma),],
                 Sigma = draws_sigma)


# Load data 
data("e6")

# Generate model
model &lt;- gen_vec(data = e6, p = 2, r = 1, const = "unrestricted",
                 iterations = 20, burnin = 10)
# Chosen number of iterations and burn-in should be much higher.

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Plot draws
plot(object)

</code></pre>

<hr>
<h2 id='bvec_to_bvar'>Transform a VEC Model to a VAR in Levels</h2><span id='topic+bvec_to_bvar'></span>

<h3>Description</h3>

<p>An object of class <code>"bvec"</code> is transformed to a VAR in level representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvec_to_bvar(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvec_to_bvar_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvec"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"bvar"</code>.
</p>


<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e6")

# Generate model
data &lt;- gen_vec(e6, p = 4, r = 1, const = "unrestricted", season = "unrestricted")

# Obtain data matrices
y &lt;- t(data$data$Y)
w &lt;- t(data$data$W)
x &lt;- t(data$data$X)

# Reset random number generator for reproducibility
set.seed(1234567)

iterations &lt;- 100 # Number of iterations of the Gibbs sampler
# Chosen number of iterations should be much higher, e.g. 30000.

burnin &lt;- 100 # Number of burn-in draws
draws &lt;- iterations + burnin

r &lt;- 1 # Set rank

tt &lt;- ncol(y) # Number of observations
k &lt;- nrow(y) # Number of endogenous variables
k_w &lt;- nrow(w) # Number of regressors in error correction term
k_x &lt;- nrow(x) # Number of differenced regressors and unrestrictec deterministic terms

k_alpha &lt;- k * r # Number of elements in alpha
k_beta &lt;- k_w * r # Number of elements in beta
k_gamma &lt;- k * k_x

# Set uninformative priors
a_mu_prior &lt;- matrix(0, k_x * k) # Vector of prior parameter means
a_v_i_prior &lt;- diag(0, k_x * k) # Inverse of the prior covariance matrix

v_i &lt;- 0
p_tau_i &lt;- diag(1, k_w)

u_sigma_df_prior &lt;- r # Prior degrees of freedom
u_sigma_scale_prior &lt;- diag(0, k) # Prior covariance matrix
u_sigma_df_post &lt;- tt + u_sigma_df_prior # Posterior degrees of freedom

# Initial values
beta &lt;- matrix(c(1, -4), k_w, r)
u_sigma_i &lt;- diag(1 / .0001, k)
g_i &lt;- u_sigma_i

# Data containers
draws_alpha &lt;- matrix(NA, k_alpha, iterations)
draws_beta &lt;- matrix(NA, k_beta, iterations)
draws_pi &lt;- matrix(NA, k * k_w, iterations)
draws_gamma &lt;- matrix(NA, k_gamma, iterations)
draws_sigma &lt;- matrix(NA, k^2, iterations)

# Start Gibbs sampler
for (draw in 1:draws) {
  # Draw conditional mean parameters
  temp &lt;- post_coint_kls(y = y, beta = beta, w = w, x = x, sigma_i = u_sigma_i,
                         v_i = v_i, p_tau_i = p_tau_i, g_i = g_i,
                         gamma_mu_prior = a_mu_prior,
                         gamma_v_i_prior = a_v_i_prior)
  alpha &lt;- temp$alpha
  beta &lt;- temp$beta
  Pi &lt;- temp$Pi
  gamma &lt;- temp$Gamma
  
  # Draw variance-covariance matrix
  u &lt;- y - Pi %*% w - matrix(gamma, k) %*% x
  u_sigma_scale_post &lt;- solve(tcrossprod(u) +
     v_i * alpha %*% tcrossprod(crossprod(beta, p_tau_i) %*% beta, alpha))
  u_sigma_i &lt;- matrix(rWishart(1, u_sigma_df_post, u_sigma_scale_post)[,, 1], k)
  u_sigma &lt;- solve(u_sigma_i)
  
  # Update g_i
  g_i &lt;- u_sigma_i
  
  # Store draws
  if (draw &gt; burnin) {
    draws_alpha[, draw - burnin] &lt;- alpha
    draws_beta[, draw - burnin] &lt;- beta
    draws_pi[, draw - burnin] &lt;- Pi
    draws_gamma[, draw - burnin] &lt;- gamma
    draws_sigma[, draw - burnin] &lt;- u_sigma
  }
}

# Number of non-deterministic coefficients
k_nondet &lt;- (k_x - 4) * k

# Generate bvec object
bvec_est &lt;- bvec(y = data$data$Y, w = data$data$W,
                 x = data$data$X[, 1:6],
                 x_d = data$data$X[, 7:10],
                 Pi = draws_pi,
                 Gamma = draws_gamma[1:k_nondet,],
                 C = draws_gamma[(k_nondet + 1):nrow(draws_gamma),],
                 Sigma = draws_sigma)

# Thin posterior draws
bvec_est &lt;- thin(bvec_est, thin = 5)

# Transfrom VEC output to VAR output
bvar_form &lt;- bvec_to_bvar(bvec_est)

</code></pre>

<hr>
<h2 id='bvecpost'>Posterior Simulation for BVEC Models</h2><span id='topic+bvecpost'></span>

<h3>Description</h3>

<p>Produces draws from the posterior distributions of Bayesian VEC models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvecpost(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvecpost_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvecmodel"</code>, usually, a result of a call to <code><a href="#topic+gen_vec">gen_vec</a></code>
in combination with <code><a href="#topic+add_priors">add_priors</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements posterior simulation algorithms proposed in Koop et al. (2010)
and Koop et al. (2011), which place identifying restrictions on the cointegration space.
Both algorithms are able to employ Bayesian variable selection (BVS) as proposed in Korobilis (2013).
The algorithm of Koop et al. (2010) is also able to employ stochastic search variable selection (SSVS)
as proposed by Geroge et al. (2008).
Both SSVS and BVS can also be applied to the covariances of the error term. However, the algorithms
cannot be applied to cointegration related coefficients, i.e. to the loading matrix <code class="reqn">\alpha</code> or
the cointegration matrix <code class="reqn">beta</code>.
</p>
<p>The implementation primarily follows the description in Koop et al. (2010). Chan et al. (2019),
George et al. (2008) and Korobilis (2013) were used to implement the variable selection algorithms.
For all approaches the SUR form of a VEC model is used to obtain posterior draws. The algorithm is implemented
in C++ to reduce calculation time.
</p>
<p>The function also supports structural BVEC models, where the structural coefficients are estimated from
contemporary endogenous variables, which corresponds to the so-called (A-model). Currently, only
specifications are supported, where the structural matrix contains ones on its diagonal and all lower
triangular elements are freely estimated. Since posterior draws are obtained based on the SUR form of
the VEC model, the structural coefficients are drawn jointly with the other coefficients. No identifying
restrictions are made regarding the cointegration matrix.
</p>


<h3>Value</h3>

<p>An object of class <code>"bvec"</code>.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>George, E. I., Sun, D., &amp; Ni, S. (2008). Bayesian stochastic search for VAR model
restrictions. <em>Journal of Econometrics, 142</em>(1), 553&ndash;580.
<a href="https://doi.org/10.1016/j.jeconom.2007.08.017">doi:10.1016/j.jeconom.2007.08.017</a>
</p>
<p>Koop, G., León-González, R., &amp; Strachan R. W. (2010). Efficient posterior
simulation for cointegrated models with priors on the cointegration space.
<em>Econometric Reviews, 29</em>(2), 224&ndash;242.
<a href="https://doi.org/10.1080/07474930903382208">doi:10.1080/07474930903382208</a>
</p>
<p>Koop, G., León-González, R., &amp; Strachan R. W. (2011). Bayesian inference in
a time varying cointegration model. <em>Journal of Econometrics, 165</em>(2), 210&ndash;220.
<a href="https://doi.org/10.1016/j.jeconom.2011.07.007">doi:10.1016/j.jeconom.2011.07.007</a>
</p>
<p>Korobilis, D. (2013). VAR forecasting using Bayesian variable selection.
<em>Journal of Applied Econometrics, 28</em>(2), 204&ndash;230. <a href="https://doi.org/10.1002/jae.1271">doi:10.1002/jae.1271</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get data
data("e6")

# Create model
model &lt;- gen_vec(e6, p = 4, r = 1,
                 const = "unrestricted", seasonal = "unrestricted",
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burnin should be much higher.

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws 
object &lt;- bvecpost(model)

</code></pre>

<hr>
<h2 id='bvs'>Bayesian Variable Selection</h2><span id='topic+bvs'></span>

<h3>Description</h3>

<p><code>bvs</code> employs Bayesian variable selection as proposed by Korobilis (2013)
to produce a vector of inclusion parameters for the coefficient matrix
of a VAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvs(y, z, a, lambda, sigma_i, prob_prior, include = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvs_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of the endogenous variables.</p>
</td></tr>
<tr><td><code id="bvs_+3A_z">z</code></td>
<td>
<p>a <code class="reqn">KT \times M</code> matrix of explanatory variables.</p>
</td></tr>
<tr><td><code id="bvs_+3A_a">a</code></td>
<td>
<p>an M-dimensional vector of parameter draws. If time varying parameters are used,
an <code class="reqn">M \times T</code> coefficient matrix can be provided.</p>
</td></tr>
<tr><td><code id="bvs_+3A_lambda">lambda</code></td>
<td>
<p>an <code class="reqn">M \times M</code> inclusion matrix that should be updated.</p>
</td></tr>
<tr><td><code id="bvs_+3A_sigma_i">sigma_i</code></td>
<td>
<p>the inverse variance-covariance matrix. If the variance-covariance matrix
is time varying, a <code class="reqn">KT \times K</code> matrix can be provided.</p>
</td></tr>
<tr><td><code id="bvs_+3A_prob_prior">prob_prior</code></td>
<td>
<p>an M-dimensional vector of prior inclusion probabilities.</p>
</td></tr>
<tr><td><code id="bvs_+3A_include">include</code></td>
<td>
<p>an integer vector specifying the positions of variables, which should be
included in the BVS algorithm. If <code>NULL</code> (default), BVS will be applied to all variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function employs Bayesian variable selection as proposed
by Korobilis (2013) to produce a vector of inclusion parameters, which are
the diagonal elements of the inclusion matrix <code class="reqn">\Lambda</code> for the VAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t = Z_t \Lambda a_t + u_t,</code>
</p>

<p>where <code class="reqn">u_t \sim N(0, \Sigma_{t})</code>.
<code class="reqn">y_t</code> is a K-dimensional vector of endogenous variables and
<code class="reqn">Z_t = x_t^{\prime} \otimes I_K</code> is a <code class="reqn">K \times M</code> matrix of regressors with
<code class="reqn">x_t</code> as a vector of regressors.
</p>


<h3>Value</h3>

<p>A matrix of inclusion parameters on its diagonal.
</p>


<h3>References</h3>

<p>Korobilis, D. (2013). VAR forecasting using Bayesian variable selection. <em>Journal of Applied Econometrics, 28</em>(2), 204&ndash;230. <a href="https://doi.org/10.1002/jae.1271">doi:10.1002/jae.1271</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
data &lt;- diff(log(e1)) * 100

# Generate model data
temp &lt;- gen_var(data, p = 2, deterministic = "const")

y &lt;- t(temp$data$Y)
z &lt;- temp$data$SUR

tt &lt;- ncol(y)
m &lt;- ncol(z)

# Priors
a_mu_prior &lt;- matrix(0, m)
a_v_i_prior &lt;- diag(0.1, m)

# Prior for inclusion parameter
prob_prior &lt;- matrix(0.5, m)

# Initial value of Sigma
sigma &lt;- tcrossprod(y) / tt
sigma_i &lt;- solve(sigma)

lambda &lt;- diag(1, m)

z_bvs &lt;- z %*% lambda

a &lt;- post_normal_sur(y = y, z = z_bvs, sigma_i = sigma_i,
                     a_prior = a_mu_prior, v_i_prior = a_v_i_prior)

lambda &lt;- bvs(y = y, z = z, a = a, lambda = lambda,
              sigma_i = sigma_i, prob_prior = prob_prior)

</code></pre>

<hr>
<h2 id='dfm'>Bayesian Dynamic Factor Model Objects</h2><span id='topic+dfm'></span><span id='topic+plot.dfm'></span>

<h3>Description</h3>

<p><code>dfm</code> is used to create objects of class <code>"dfm"</code>.
</p>
<p>A plot function for objects of class <code>"dfm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfm(x, lambda = NULL, fac, sigma_u = NULL, a = NULL, sigma_v = NULL)

## S3 method for class 'dfm'
plot(x, ci = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"dfm"</code>, usually, a result of a call to <code><a href="#topic+dfm">dfm</a></code>.</p>
</td></tr>
<tr><td><code id="dfm_+3A_lambda">lambda</code></td>
<td>
<p>an <code class="reqn">MN \times S</code> matrix of MCMC coefficient draws of factor loadings of the measurement equation.</p>
</td></tr>
<tr><td><code id="dfm_+3A_fac">fac</code></td>
<td>
<p>an <code class="reqn">NT \times S</code> matrix of MCMC draws of the factors in the transition equation, where the first N
rows correspond to the N factors in period 1 and the next N rows to the factors in period 2 etc.</p>
</td></tr>
<tr><td><code id="dfm_+3A_sigma_u">sigma_u</code></td>
<td>
<p>an <code class="reqn">M \times S</code> matrix of MCMC draws for the error variances of the measurement equation.</p>
</td></tr>
<tr><td><code id="dfm_+3A_a">a</code></td>
<td>
<p>a <code class="reqn">pN^2 \times S</code> matrix of MCMC coefficient draws of the transition equation.</p>
</td></tr>
<tr><td><code id="dfm_+3A_sigma_v">sigma_v</code></td>
<td>
<p>an <code class="reqn">N \times S</code> matrix of MCMC draws for the error variances of the transition equation.</p>
</td></tr>
<tr><td><code id="dfm_+3A_ci">ci</code></td>
<td>
<p>interval used to calculate credible bands.</p>
</td></tr>
<tr><td><code id="dfm_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a standardised object from S draws of a Gibbs sampler (after the burn-in phase)
for the dynamic factor model (DFM) with measurement equation
</p>
<p style="text-align: center;"><code class="reqn">x_t = \lambda f_t + u_t,</code>
</p>

<p>where
<code class="reqn">x_t</code> is an <code class="reqn">M \times 1</code> vector of observed variables,
<code class="reqn">f_t</code> is an <code class="reqn">N \times 1</code> vector of unobserved factors and
<code class="reqn">\lambda</code> is the corresponding <code class="reqn">M \times N</code> matrix of factor loadings.
<code class="reqn">u_t</code> is an <code class="reqn">M \times 1</code> error term.
</p>
<p>The transition equation is
</p>
<p style="text-align: center;"><code class="reqn">f_t = \sum_{i=1}^{p} A_i f_{t - i} + v_t,</code>
</p>

<p>where
<code class="reqn">A_i</code> is an <code class="reqn">N \times N</code> coefficient matrix and
<code class="reqn">v_t</code> is an <code class="reqn">N \times 1</code> error term.
</p>


<h3>Value</h3>

<p>An object of class <code>"dfm"</code> containing the following components, if specified:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the standardised time-series object of observable variables.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>an <code class="reqn">S \times MN</code> &quot;mcmc&quot; object of draws of factor loadings of the measurement equation.</p>
</td></tr>
<tr><td><code>factor</code></td>
<td>
<p>an <code class="reqn">S \times NT</code> &quot;mcmc&quot; object of draws of factors.</p>
</td></tr>
<tr><td><code>sigma_u</code></td>
<td>
<p>an <code class="reqn">S \times M</code> &quot;mcmc&quot; object of variance draws of the measurement equation.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>an <code class="reqn">S \times pN^2</code> &quot;mcmc&quot; object of coefficient draws of the transition equation.</p>
</td></tr>
<tr><td><code>sigma_v</code></td>
<td>
<p>an <code class="reqn">S \times N</code> &quot;mcmc&quot; object of variance draws of the transition equation.</p>
</td></tr>
<tr><td><code>specifications</code></td>
<td>
<p>a list containing information on the model specification.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("bem_dfmdata")

# Generate model data
model &lt;- gen_dfm(x = bem_dfmdata, p = 1, n = 1,
                 iterations = 20, burnin = 10)
# Number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model,
                    lambda = list(v_i = .01),
                    sigma_u = list(shape = 5, rate = 4),
                    a = list(v_i = .01),
                    sigma_v = list(shape = 5, rate = 4))

# Obtain posterior draws
object &lt;- dfmpost(model)


# Load data
data("bem_dfmdata")

# Generate model data
model &lt;- gen_dfm(x = bem_dfmdata, p = 1, n = 1,
                 iterations = 20, burnin = 10)
# Number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model,
                    lambda = list(v_i = .01),
                    sigma_u = list(shape = 5, rate = 4),
                    a = list(v_i = .01),
                    sigma_v = list(shape = 5, rate = 4))

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Plot factors
plot(object)

</code></pre>

<hr>
<h2 id='dfmpost'>Posterior Simulation for Dynamic Factor Models</h2><span id='topic+dfmpost'></span>

<h3>Description</h3>

<p>Produces draws from the posterior distributions of Bayesian dynamic factor models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfmpost(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfmpost_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dfmodel"</code>, usually, a result of a call to <code><a href="#topic+gen_dfm">gen_dfm</a></code>
in combination with <code><a href="#topic+add_priors">add_priors</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the posterior simulation algorithm for Bayesian dynamic factor models.
</p>
<p>The implementation follows the description in Chan et al. (2019) and C++ is used to reduce calculation time.
</p>


<h3>Value</h3>

<p>An object of class <code>"dfm"</code>.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("bem_dfmdata")

# Generate model data
model &lt;- gen_dfm(x = bem_dfmdata, p = 1, n = 1,
                 iterations = 20, burnin = 10)
# Number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model,
                    lambda = list(v_i = .01),
                    sigma_u = list(shape = 5, rate = 4),
                    a = list(v_i = .01),
                    sigma_v = list(shape = 5, rate = 4))

# Obtain posterior draws
object &lt;- dfmpost(model)

</code></pre>

<hr>
<h2 id='draw_posterior'>Posterior Simulation</h2><span id='topic+draw_posterior'></span>

<h3>Description</h3>

<p>Forwards model input to posterior simulation functions. This is a generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_posterior(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_posterior_+3A_object">object</code></td>
<td>
<p>a list of model specifications. Usually, the output of a call to 
<code><a href="#topic+gen_var">gen_var</a></code>, <code><a href="#topic+gen_vec">gen_vec</a></code> or <code><a href="#topic+gen_dfm">gen_dfm</a></code> in combination with <code><a href="#topic+add_priors">add_priors</a></code>.</p>
</td></tr>
<tr><td><code id="draw_posterior_+3A_...">...</code></td>
<td>
<p>arguments passed forward to method.</p>
</td></tr>
</table>

<hr>
<h2 id='draw_posterior.bvarmodel'>Posterior Simulation</h2><span id='topic+draw_posterior.bvarmodel'></span>

<h3>Description</h3>

<p>Forwards model input to posterior simulation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvarmodel'
draw_posterior(object, FUN = NULL, mc.cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_posterior.bvarmodel_+3A_object">object</code></td>
<td>
<p>a list of model specifications, which should be passed on
to function <code>FUN</code>. Usually, the output of a call to <code><a href="#topic+gen_var">gen_var</a></code> in
combination with <code><a href="#topic+add_priors">add_priors</a></code>.</p>
</td></tr>
<tr><td><code id="draw_posterior.bvarmodel_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each model in argument <code>object</code>.
If <code>NULL</code> (default), the internal functions <code><a href="#topic+bvarpost">bvarpost</a></code> is used.</p>
</td></tr>
<tr><td><code id="draw_posterior.bvarmodel_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores to use, i.e. at most how many child
processes will be run simultaneously. The option is initialized from
environment variable MC_CORES if set. Must be at least one, and
parallelization requires at least two cores.</p>
</td></tr>
<tr><td><code id="draw_posterior.bvarmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For multiple models a list of objects of class <code>bvarlist</code>.
For a single model the object has the class of the output of the applied posterior
simulation function. In case the package's own functions are used, this will
result in an object of class <code>"bvar"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data 
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate model
model &lt;- gen_var(e1, p = 1:2, deterministic = 2,
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burn-in should be much higher.

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

</code></pre>

<hr>
<h2 id='draw_posterior.bvecmodel'>Posterior Simulation for Vector Error Correction Models</h2><span id='topic+draw_posterior.bvecmodel'></span>

<h3>Description</h3>

<p>Forwards model input to posterior simulation functions for vector error correction models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvecmodel'
draw_posterior(object, FUN = NULL, mc.cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_posterior.bvecmodel_+3A_object">object</code></td>
<td>
<p>a list of model specifications, which should be passed on
to function <code>FUN</code>. Usually, the output of a call to <code><a href="#topic+gen_vec">gen_vec</a></code>
in combination with <code><a href="#topic+add_priors">add_priors</a></code>.</p>
</td></tr>
<tr><td><code id="draw_posterior.bvecmodel_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each list element in argument <code>object</code>.
If <code>NULL</code> (default), the internal function <code><a href="#topic+bvecpost">bvecpost</a></code> is used.</p>
</td></tr>
<tr><td><code id="draw_posterior.bvecmodel_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores to use, i.e. at most how many child
processes will be run simultaneously. The option is initialized from
environment variable MC_CORES if set. Must be at least one, and
parallelization requires at least two cores.</p>
</td></tr>
<tr><td><code id="draw_posterior.bvecmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For multiple models a list of objects of class <code>bvarlist</code>.
For a single model the object has the class of the output of the applied posterior
simulation function. In case the package's own functions are used, this will
be <code>"bvec"</code>.
</p>


<h3>References</h3>

<p>Koop, G., León-González, R., &amp; Strachan R. W. (2010). Efficient posterior
simulation for cointegrated models with priors on the cointegration space.
<em>Econometric Reviews, 29</em>(2), 224&ndash;242.
<a href="https://doi.org/10.1080/07474930903382208">doi:10.1080/07474930903382208</a>
</p>
<p>Koop, G., León-González, R., &amp; Strachan R. W. (2011). Bayesian inference in
a time varying cointegration model. <em>Journal of Econometrics, 165</em>(2), 210&ndash;220.
<a href="https://doi.org/10.1016/j.jeconom.2011.07.007">doi:10.1016/j.jeconom.2011.07.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data 
data("e6")
e6 &lt;- e6 * 100

# Generate model
model &lt;- gen_vec(e6, p = 1, r = 1, const = "restricted",
                 iterations = 10, burnin = 10)
# Chosen number of iterations and burn-in should be much higher.

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

</code></pre>

<hr>
<h2 id='draw_posterior.dfmodel'>Posterior Simulation</h2><span id='topic+draw_posterior.dfmodel'></span>

<h3>Description</h3>

<p>Forwards model input to posterior simulation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfmodel'
draw_posterior(object, FUN = NULL, mc.cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_posterior.dfmodel_+3A_object">object</code></td>
<td>
<p>a list of model specifications, which should be passed on
to function <code>FUN</code>. Usually, the output of a call to <code><a href="#topic+gen_var">gen_var</a></code>,
<code><a href="#topic+gen_vec">gen_vec</a></code> or <code><a href="#topic+gen_dfm">gen_dfm</a></code> in combination with <code><a href="#topic+add_priors">add_priors</a></code>.</p>
</td></tr>
<tr><td><code id="draw_posterior.dfmodel_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each list element in argument <code>object</code>.
If <code>NULL</code> (default), the internal functions <code><a href="#topic+bvarpost">bvarpost</a></code> is used for
VAR model, <code><a href="#topic+bvecpost">bvecpost</a></code> for VEC models and <code><a href="#topic+dfmpost">dfmpost</a></code> for dynamic
factor models.</p>
</td></tr>
<tr><td><code id="draw_posterior.dfmodel_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores to use, i.e. at most how many child
processes will be run simultaneously. The option is initialized from
environment variable MC_CORES if set. Must be at least one, and
parallelization requires at least two cores.</p>
</td></tr>
<tr><td><code id="draw_posterior.dfmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For multiple models a list of objects of class <code>bvarlist</code>.
For a single model the object has the class of the output of the applied posterior
simulation function. In case the package's own functions are used, this will
be <code>"bvar"</code>, <code>"bvec"</code> or <code>"dfm"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data 
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate model
model &lt;- gen_var(e1, p = 1:2, deterministic = 2,
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burn-in should be much higher.

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

</code></pre>

<hr>
<h2 id='e1'>West German economic time series data</h2><span id='topic+e1'></span>

<h3>Description</h3>

<p>The data set contains quarterly, seasonally adjusted time series for West German fixed investment, disposable
income, and consumption expenditures in billions of DM from 1960Q1 to 1982Q4. It was produced
from file E1 of the data sets associated with Lütkepohl (2007). Raw data are available at
<a href="http://www.jmulti.de/download/datasets/e1.dat">http://www.jmulti.de/download/datasets/e1.dat</a> and were originally obtained from
Deutsche Bundesbank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("e1")
</code></pre>


<h3>Format</h3>

<p>A named time-series object with 92 rows and 3 variables:
</p>

<dl>
<dt>invest</dt><dd><p>fixed investment.</p>
</dd>
<dt>income</dt><dd><p>disposable income.</p>
</dd>
<dt>cons</dt><dd><p>consumption expenditures.</p>
</dd>
</dl>



<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>

<hr>
<h2 id='e6'>German interest and inflation rate data</h2><span id='topic+e6'></span>

<h3>Description</h3>

<p>The data set contains quarterly, seasonally unadjusted time series for German long-term interest
and inflation rates from 1972Q2 to 1998Q4. It was produced from file E6 of the data sets associated
with Lütkepohl (2007). Raw data are available at <a href="http://www.jmulti.de/download/datasets/e6.dat">http://www.jmulti.de/download/datasets/e6.dat</a>
and were originally obtained from Deutsche Bundesbank and Deutsches Institut für Wirtschaftsforschung.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("e6")
</code></pre>


<h3>Format</h3>

<p>A named time-series object with 107 rows and 2 variables:
</p>

<dl>
<dt>R</dt><dd><p>nominal long-term interest rate (Umlaufsrendite).</p>
</dd>
<dt>Dp</dt><dd><p><code class="reqn">\Delta</code> log of GDP deflator.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data cover West Germany until 1990Q2 and all of Germany aferwards. The values refer to 
the last month of a quarter.
</p>


<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>

<hr>
<h2 id='fevd'>Forecast Error Variance Decomposition
A generic function used to calculate forecast error varianc decompositions.</h2><span id='topic+fevd'></span><span id='topic+plot.bvarfevd'></span>

<h3>Description</h3>

<p>A plot function for objects of class &quot;bvarfevd&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fevd(object, ...)

## S3 method for class 'bvarfevd'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fevd_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvar"</code>.</p>
</td></tr>
<tr><td><code id="fevd_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
<tr><td><code id="fevd_+3A_x">x</code></td>
<td>
<p>an object of class &quot;bvarfevd&quot;, usually, a result of a call to <code><a href="#topic+fevd">fevd</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate model data
model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Obtain FEVD
vd &lt;- fevd(object, response = "cons")

# Plot
plot(vd)

</code></pre>

<hr>
<h2 id='fevd.bvar'>Forecast Error Variance Decomposition</h2><span id='topic+fevd.bvar'></span>

<h3>Description</h3>

<p>Produces the forecast error variance decomposition of a Bayesian VAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
fevd(
  object,
  response = NULL,
  n.ahead = 5,
  type = "oir",
  normalise_gir = FALSE,
  period = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fevd.bvar_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvar"</code>, usually, a result of a call to <code><a href="#topic+bvar">bvar</a></code>
or <code><a href="#topic+bvec_to_bvar">bvec_to_bvar</a></code>.</p>
</td></tr>
<tr><td><code id="fevd.bvar_+3A_response">response</code></td>
<td>
<p>name of the response variable.</p>
</td></tr>
<tr><td><code id="fevd.bvar_+3A_n.ahead">n.ahead</code></td>
<td>
<p>number of steps ahead.</p>
</td></tr>
<tr><td><code id="fevd.bvar_+3A_type">type</code></td>
<td>
<p>type of the impulse responses used to calculate forecast error variable decompositions.
Possible choices are orthogonalised <code>oir</code> (default) and generalised <code>gir</code> impulse responses.</p>
</td></tr>
<tr><td><code id="fevd.bvar_+3A_normalise_gir">normalise_gir</code></td>
<td>
<p>logical. Should the GIR-based FEVD be normalised?</p>
</td></tr>
<tr><td><code id="fevd.bvar_+3A_period">period</code></td>
<td>
<p>integer. Index of the period, for which the variance decomposition should be generated.
Only used for TVP or SV models. Default is <code>NULL</code>, so that the posterior draws of the last time period
are used.</p>
</td></tr>
<tr><td><code id="fevd.bvar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces forecast error variance decompositions (FEVD) for the VAR model
</p>
<p style="text-align: center;"><code class="reqn">A_0 y_t = \sum_{i = 1}^{p} A_{i} y_{t-i} + u_t,</code>
</p>

<p>with <code class="reqn">u_t \sim N(0, \Sigma)</code>. For non-structural models matrix <code class="reqn">A_0</code> is set to the identiy matrix
and can therefore be omitted, where not relevant.
</p>
<p>If the FEVD is based on the orthogonalised impulse resonse (OIR), the FEVD will be calculated as
</p>
<p style="text-align: center;"><code class="reqn">\omega^{OIR}_{jk, h} = \frac{\sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i P e_k )^2}{\sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i \Sigma \Phi_i^{\prime} e_j )},</code>
</p>

<p>where <code class="reqn">\Phi_i</code> is the forecast error impulse response for the <code class="reqn">i</code>th period,
<code class="reqn">P</code> is the lower triangular Choleski decomposition of the variance-covariance
matrix <code class="reqn">\Sigma</code>, <code class="reqn">e_j</code> is a selection vector for the response variable and
<code class="reqn">e_k</code> a selection vector for the impulse variable.
</p>
<p>If <code>type = "sir"</code>, the structural FEVD will be
calculated as </p>
<p style="text-align: center;"><code class="reqn">\omega^{SIR}_{jk, h} = \frac{\sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i A_0^{-1} e_k )^2}{\sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i A_0^{-1} A_0^{-1\prime} \Phi_i^{\prime} e_j )},</code>
</p>

<p>where <code class="reqn">\sigma_{jj}</code> is the diagonal element of the <code class="reqn">j</code>th variable of the variance covariance matrix.
</p>
<p>If <code>type = "gir"</code>, the generalised FEVD will be
calculated as </p>
<p style="text-align: center;"><code class="reqn">\omega^{GIR}_{jk, h} = \frac{\sigma^{-1}_{jj} \sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i \Sigma e_k )^2}{\sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i \Sigma \Phi_i^{\prime} e_j )},</code>
</p>

<p>where <code class="reqn">\sigma_{jj}</code> is the diagonal element of the <code class="reqn">j</code>th variable of the variance covariance matrix.
</p>
<p>If <code>type = "sgir"</code>, the structural generalised FEVD will be
calculated as </p>
<p style="text-align: center;"><code class="reqn">\omega^{SGIR}_{jk, h} = \frac{\sigma^{-1}_{jj} \sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i A_0^{-1} \Sigma e_k )^2}{\sum_{i = 0}^{h-1} (e_j^{\prime} \Phi_i A_0^{-1} \Sigma A_0^{-1\prime} \Phi_i^{\prime} e_j )}</code>
</p>
<p>.
</p>
<p>Since GIR-based FEVDs do not add up to unity, they can be normalised by setting <code>normalise_gir = TRUE</code>.
</p>


<h3>Value</h3>

<p>A time-series object of class <code>"bvarfevd"</code>.
</p>


<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>
<p>Pesaran, H. H., &amp; Shin, Y. (1998). Generalized impulse response analysis in linear multivariate models. <em>Economics Letters, 58</em>, 17-29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate models
model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)

# Add priors
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Obtain FEVD
vd &lt;- fevd(object, response = "cons")

# Plot FEVD
plot(vd)

</code></pre>

<hr>
<h2 id='gen_dfm'>Dynamic Factor Model Input</h2><span id='topic+gen_dfm'></span>

<h3>Description</h3>

<p><code>gen_dfm</code> produces the input for the estimation of a dynamic factor model (DFM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_dfm(x, p = 2, n = 1, iterations = 50000, burnin = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_dfm_+3A_x">x</code></td>
<td>
<p>a time-series object of stationary endogenous variables.</p>
</td></tr>
<tr><td><code id="gen_dfm_+3A_p">p</code></td>
<td>
<p>an integer vector of the lag order of the measurement equation. See 'Details'.</p>
</td></tr>
<tr><td><code id="gen_dfm_+3A_n">n</code></td>
<td>
<p>an integer vector of the number of factors. See 'Details'.</p>
</td></tr>
<tr><td><code id="gen_dfm_+3A_iterations">iterations</code></td>
<td>
<p>an integer of MCMC draws excluding burn-in draws (defaults
to 50000).</p>
</td></tr>
<tr><td><code id="gen_dfm_+3A_burnin">burnin</code></td>
<td>
<p>an integer of MCMC draws used to initialize the sampler
(defaults to 5000). These draws do not enter the computation of posterior
moments, forecasts etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces the variable matrices of dynamic factor
models (DFM) with measurement equation
</p>
<p style="text-align: center;"><code class="reqn">x_t = \lambda f_t + u_t,</code>
</p>

<p>where
<code class="reqn">x_t</code> is an <code class="reqn">M \times 1</code> vector of observed variables,
<code class="reqn">f_t</code> is an <code class="reqn">N \times 1</code> vector of unobserved factors and
<code class="reqn">\lambda</code> is the corresponding <code class="reqn">M \times N</code> matrix of factor loadings.
<code class="reqn">u_t</code> is an <code class="reqn">M \times 1</code> error term.
</p>
<p>The transition equation is
</p>
<p style="text-align: center;"><code class="reqn">f_t = \sum_{i=1}^{p} A_i f_{t - i} + v_t,</code>
</p>

<p>where
<code class="reqn">A_i</code> is an <code class="reqn">N \times N</code> coefficient matrix and
<code class="reqn">v_t</code> is an <code class="reqn">N \times 1</code> error term.
</p>
<p>If integer vectors are provided as arguments <code>p</code> or <code>n</code>, the function will
produce a distinct model for all possible combinations of those specifications.
</p>


<h3>Value</h3>

<p>An object of class <code>'dfmodel'</code>, which contains the following elements:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>A list of data objects, which can be used for posterior simulation. Element
<code>X</code> is a time-series object of normalised observable variables, i.e. each column has
zero mean and unity variance.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list of model specifications.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias, J. L. (2019). <em>Bayesian Econometric Methods</em>
(2nd ed.). Cambridge: University Press.
</p>
<p>Lütkepohl, H. (2007). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("bem_dfmdata")

# Generate model data
model &lt;- gen_dfm(x = bem_dfmdata, p = 1, n = 1,
                 iterations = 5000, burnin = 1000)

</code></pre>

<hr>
<h2 id='gen_var'>Vector Autoregressive Model Input</h2><span id='topic+gen_var'></span>

<h3>Description</h3>

<p><code>gen_var</code> produces the input for the estimation of a vector autoregressive (VAR) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_var(
  data,
  p = 2,
  exogen = NULL,
  s = NULL,
  deterministic = "const",
  seasonal = FALSE,
  structural = FALSE,
  tvp = FALSE,
  sv = FALSE,
  fcst = NULL,
  iterations = 50000,
  burnin = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_var_+3A_data">data</code></td>
<td>
<p>a time-series object of endogenous variables.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_p">p</code></td>
<td>
<p>an integer vector of the lag order (default is <code>p = 2</code>).</p>
</td></tr>
<tr><td><code id="gen_var_+3A_exogen">exogen</code></td>
<td>
<p>an optional time-series object of external regressors.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_s">s</code></td>
<td>
<p>an optional integer vector of the lag order of the external regressors (default is <code>s = 2</code>).</p>
</td></tr>
<tr><td><code id="gen_var_+3A_deterministic">deterministic</code></td>
<td>
<p>a character specifying which deterministic terms should
be included. Available values are <code>"none"</code>, <code>"const"</code> (default) for an intercept,
<code>"trend"</code> for a linear trend, and <code>"both"</code> for an intercept with a linear trend.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_seasonal">seasonal</code></td>
<td>
<p>logical. If <code>TRUE</code>, seasonal dummy variables are
generated as additional deterministic terms. The amount of dummies depends on the frequency of the
time-series object provided in <code>data</code>.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_structural">structural</code></td>
<td>
<p>logical indicating whether data should be prepared for the estimation of a
structural VAR model.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_tvp">tvp</code></td>
<td>
<p>logical indicating whether the model parameters are time varying.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_sv">sv</code></td>
<td>
<p>logical indicating whether time varying error variances should be estimated by
employing a stochastic volatility algorithm.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_fcst">fcst</code></td>
<td>
<p>integer. Number of observations saved for forecasting evaluation.</p>
</td></tr>
<tr><td><code id="gen_var_+3A_iterations">iterations</code></td>
<td>
<p>an integer of MCMC draws excluding burn-in draws (defaults
to 50000).</p>
</td></tr>
<tr><td><code id="gen_var_+3A_burnin">burnin</code></td>
<td>
<p>an integer of MCMC draws used to initialize the sampler
(defaults to 5000). These draws do not enter the computation of posterior
moments, forecasts etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces the data matrices for vector autoregressive (VAR)
models, which can also include unmodelled, non-deterministic variables:
</p>
<p style="text-align: center;"><code class="reqn">A_0 y_t = \sum_{i=1}^{p} A_i y_{t - i} +
\sum_{i=0}^{s} B_i x_{t - i} +
C D_t + u_t,</code>
</p>

<p>where
<code class="reqn">y_t</code> is a K-dimensional vector of endogenous variables,
<code class="reqn">A_0</code> is a <code class="reqn">K \times K</code> coefficient matrix of contemporaneous endogenous variables,
<code class="reqn">A_i</code> is a <code class="reqn">K \times K</code> coefficient matrix of endogenous variables,
<code class="reqn">x_t</code> is an M-dimensional vector of exogenous regressors and
<code class="reqn">B_i</code> its corresponding <code class="reqn">K \times M</code> coefficient matrix.
<code class="reqn">D_t</code> is an N-dimensional vector of deterministic terms and
<code class="reqn">C</code> its corresponding <code class="reqn">K \times N</code> coefficient matrix.
<code class="reqn">p</code> is the lag order of endogenous variables, <code class="reqn">s</code> is the lag
order of exogenous variables, and <code class="reqn">u_t</code> is an error term.
</p>
<p>If an integer vector is provided as argument <code>p</code> or <code>s</code>, the function will
produce a distinct model for all possible combinations of those specifications.
</p>
<p>If <code>tvp</code> is <code>TRUE</code>, the respective coefficients
of the above model are assumed to be time varying. If <code>sv</code> is <code>TRUE</code>,
the error covariance matrix is assumed to be time varying.
</p>


<h3>Value</h3>

<p>An object of class <code>'bvarmodel'</code>, which contains the following elements:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>A list of data objects, which can be used for posterior simulation. Element
<code>Y</code> is a time-series object of dependent variables. Element <code>Z</code> is a time-series
object of the regressors and element <code>SUR</code> is the corresponding matrix of regressors
in SUR form.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list of model specifications.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias, J. L. (2019). <em>Bayesian Econometric Methods</em>
(2nd ed.). Cambridge: University Press.
</p>
<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1") 
e1 &lt;- diff(log(e1))

# Generate model data
data &lt;- gen_var(e1, p = 0:2, deterministic = "const")

</code></pre>

<hr>
<h2 id='gen_vec'>Vector Error Correction Model Input</h2><span id='topic+gen_vec'></span>

<h3>Description</h3>

<p><code>gen_vec</code> produces the input for the estimation of a vector error correction (VEC) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_vec(
  data,
  p = 2,
  exogen = NULL,
  s = 2,
  r = NULL,
  const = NULL,
  trend = NULL,
  seasonal = NULL,
  structural = FALSE,
  tvp = FALSE,
  sv = FALSE,
  fcst = NULL,
  iterations = 50000,
  burnin = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_vec_+3A_data">data</code></td>
<td>
<p>a time-series object of endogenous variables.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_p">p</code></td>
<td>
<p>an integer vector of the lag order of the series in the (levels) VAR. Thus, the
resulting model's lag will be <code class="reqn">p - 1</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_exogen">exogen</code></td>
<td>
<p>an optional time-series object of external regressors.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_s">s</code></td>
<td>
<p>an optional integer vector of the lag order of the exogenous variables of the series
in the (levels) VAR. Thus, the resulting model's lag will be <code class="reqn">s - 1</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_r">r</code></td>
<td>
<p>an integer vector of the cointegration rank. See 'Details'.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_const">const</code></td>
<td>
<p>a character specifying whether a constant term enters the error correction
term (<code>"restricted"</code>) or the non-cointegration term as an <code>"unrestricted"</code> variable.
If <code>NULL</code> (default) no constant term will be added.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_trend">trend</code></td>
<td>
<p>a character specifying whether a trend term enters the error correction
term (<code>"restricted"</code>) or the non-cointegration term as an <code>"unrestricted"</code> variable.
If <code>NULL</code> (default) no constant term will be added.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_seasonal">seasonal</code></td>
<td>
<p>a character specifying whether seasonal dummies should be included in the error
correction term (<code>"restricted"</code>) or in the non-cointegreation term as <code>"unrestricted"</code>
variables. If <code>NULL</code> (default) no seasonal terms will be added. The amount of dummy variables
will be automatically detected and depends on the frequency of the time-series object provided
in <code>data</code>.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_structural">structural</code></td>
<td>
<p>logical indicating whether data should be prepared for the estimation of a
structural VAR model.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_tvp">tvp</code></td>
<td>
<p>logical indicating whether the model parameters are time varying.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_sv">sv</code></td>
<td>
<p>logical indicating whether time varying error variances should be estimated by
employing a stochastic volatility algorithm.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_fcst">fcst</code></td>
<td>
<p>integer. Number of observations saved for forecasting evaluation.</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_iterations">iterations</code></td>
<td>
<p>an integer of MCMC draws excluding burn-in draws (defaults
to 50000).</p>
</td></tr>
<tr><td><code id="gen_vec_+3A_burnin">burnin</code></td>
<td>
<p>an integer of MCMC draws used to initialize the sampler
(defaults to 5000). These draws do not enter the computation of posterior
moments, forecasts etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces the variable matrices of vector error correction (VEC)
models, which can also include exogenous variables:
</p>
<p style="text-align: center;"><code class="reqn">\Delta y_t = \Pi w_t + \sum_{i=1}^{p-1} \Gamma_{i} \Delta y_{t - i} + 
\sum_{i=0}^{s-1} \Upsilon_{i} \Delta x_{t - i} +
C^{UR} d^{UR}_t + u_t,</code>
</p>

<p>where
<code class="reqn">\Delta y_t</code> is a <code class="reqn">K \times 1</code> vector of differenced endogenous variables,
<code class="reqn">w_t</code> is a <code class="reqn">(K + M + N^{R}) \times 1</code> vector of cointegration variables,
<code class="reqn">\Pi</code> is a <code class="reqn">K \times (K + M + N^{R})</code> matrix of cointegration parameters,
<code class="reqn">\Gamma_i</code> is a <code class="reqn">K \times K</code> coefficient matrix of endogenous variables,
<code class="reqn">\Delta x_t</code> is a <code class="reqn">M \times 1</code> vector of differenced exogenous regressors,
<code class="reqn">\Upsilon_i</code> is a <code class="reqn">K \times M</code> coefficient matrix of exogenous regressors,
<code class="reqn">d^{UR}_t</code> is a <code class="reqn">N \times 1</code> vector of deterministic terms, and
<code class="reqn">C^{UR}</code> is a <code class="reqn">K \times N^{UR}</code> coefficient matrix of deterministic terms
that do not enter the cointegration term.
<code class="reqn">p</code> is the lag order of endogenous variables and <code class="reqn">s</code> is the lag
order of exogenous variables of the corresponding VAR model.
<code class="reqn">u_t</code> is a <code class="reqn">K \times 1</code> error term.
</p>
<p>If an integer vector is provided as argument <code>p</code>, <code>s</code> or <code>r</code>, the function will
produce a distinct model for all possible combinations of those specifications.
</p>
<p>If <code>tvp</code> is <code>TRUE</code>, the respective coefficients
of the above model are assumed to be time varying. If <code>sv</code> is <code>TRUE</code>,
the error covariance matrix is assumed to be time varying.
</p>


<h3>Value</h3>

<p>An object of class <code>'bvecmodel'</code>, which contains the following elements:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>A list of data objects, which can be used for posterior simulation. Element
<code>Y</code> is a time-series object of dependent variables. Element <code>W</code> is a timer-series
object of variables in the cointegration term and element <code>X</code> is a time-series
object of variables that do not enter the cointegration term. Element <code>SUR</code> contains a
matrix of element <code>X</code> in its SUR form.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list of model specifications.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e6")

# Generate model data
data &lt;- gen_vec(e6, p = 4, const = "unrestricted", season = "unrestricted")

</code></pre>

<hr>
<h2 id='inclusion_prior'>Prior Inclusion Probabilities</h2><span id='topic+inclusion_prior'></span>

<h3>Description</h3>

<p>Prior inclusion probabilities as required for stochastic search variable selection (SSVS) à la
George et al. (2008) and Bayesian variable selection (BVS) à la Korobilis (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusion_prior(
  object,
  prob = 0.5,
  exclude_deterministics = TRUE,
  minnesota_like = FALSE,
  kappa = c(0.8, 0.5, 0.5, 0.8)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inclusion_prior_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvarmodel"</code>, usually, a result of a call to <code><a href="#topic+gen_var">gen_var</a></code>
or <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="inclusion_prior_+3A_prob">prob</code></td>
<td>
<p>a numeric specifying the prior inclusion probability of all model parameters.</p>
</td></tr>
<tr><td><code id="inclusion_prior_+3A_exclude_deterministics">exclude_deterministics</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the vector of the positions of
included variables does not include the positions of deterministic terms.</p>
</td></tr>
<tr><td><code id="inclusion_prior_+3A_minnesota_like">minnesota_like</code></td>
<td>
<p>logical. If <code>TRUE</code>, the prior inclusion probabilities of the
parameters are calculated in a similar way as the Minnesota prior. See 'Details'.</p>
</td></tr>
<tr><td><code id="inclusion_prior_+3A_kappa">kappa</code></td>
<td>
<p>a numeric vector of four elements containing the prior inclusion probabilities
of coefficients that correspond to own lags of endogenous variables, to endogenous variables,
which do not correspond to own lags, to exogenous variables and deterministic terms, respectively.
Only used if <code>minnesota_like = TRUE</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>minnesota_like = TRUE</code>, prior inclusion probabilities <code class="reqn">\underline{\pi}_1</code>
are calculated as
</p>

<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_1}{r}</code> </td><td style="text-align: left;"> for own lags of endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_2}{r}</code> </td><td style="text-align: left;"> for other endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\frac{\kappa_3}{1 + r}</code> </td><td style="text-align: left;"> for exogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa_{4}</code> </td><td style="text-align: left;"> for deterministic variables, 
</td>
</tr>

</table>

<p>for lag <code class="reqn">r</code> with <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, <code class="reqn">\kappa_3</code>, <code class="reqn">\kappa_4</code> as the first, second,
third and forth element in <code>kappa</code>, respectively.
</p>
<p>For vector error correction models the function generates prior inclusion probabilities for differenced
variables and unrestricted deterministc terms as described above. For variables in the error
correction term prior inclusion probabilites are calculated as
</p>

<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa_1</code> </td><td style="text-align: left;"> fow own levels of endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa_2</code> </td><td style="text-align: left;"> for levels of other endogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa_3</code> </td><td style="text-align: left;"> for levels of exogenous variables, </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa_4</code> </td><td style="text-align: left;"> for deterministic variables.
</td>
</tr>

</table>



<h3>Value</h3>

<p>A list containing a matrix of prior inclusion probabilities and an integer vector
specifying the positions of variables, which should be included in the variable selction algorithm.
</p>


<h3>References</h3>

<p>George, E. I., Sun, D., &amp; Ni, S. (2008). Bayesian stochastic search for VAR model
restrictions. <em>Journal of Econometrics, 142</em>(1), 553&ndash;580.
<a href="https://doi.org/10.1016/j.jeconom.2007.08.017">doi:10.1016/j.jeconom.2007.08.017</a>
</p>
<p>Korobilis, D. (2013). VAR forecasting using Bayesian variable selection.
<em>Journal of Applied Econometrics, 28</em>(2), 204&ndash;230. <a href="https://doi.org/10.1002/jae.1271">doi:10.1002/jae.1271</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Prepare data
data("e1")

# Generate model input
object &lt;- gen_var(e1)

# Obtain inclusion prior
pi_prior &lt;- inclusion_prior(object)

</code></pre>

<hr>
<h2 id='irf'>Impulse Response Function
A generic function used to calculate impulse response functions.</h2><span id='topic+irf'></span><span id='topic+plot.bvarirf'></span>

<h3>Description</h3>

<p>A plot function for objects of class &quot;bvarirf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irf(x, ...)

## S3 method for class 'bvarirf'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irf_+3A_x">x</code></td>
<td>
<p>an object of class &quot;bvarirf&quot;, usually, a result of a call to <code><a href="#topic+irf">irf</a></code>.</p>
</td></tr>
<tr><td><code id="irf_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate model data
model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)
# Number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model)

# Optain posterior draws
object &lt;- draw_posterior(model)

# Calculate IR
ir &lt;- irf(object, impulse = "invest", response = "cons")

# Plot IR
plot(ir)

</code></pre>

<hr>
<h2 id='irf.bvar'>Impulse Response Function</h2><span id='topic+irf.bvar'></span>

<h3>Description</h3>

<p>Computes the impulse response coefficients of an object of class <code>"bvar"</code> for
<code>n.ahead</code> steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 5,
  ci = 0.95,
  shock = 1,
  type = "feir",
  cumulative = FALSE,
  keep_draws = FALSE,
  period = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irf.bvar_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bvar"</code>, usually, a result of a call to
<code><a href="#topic+bvar">bvar</a></code> or <code><a href="#topic+bvec_to_bvar">bvec_to_bvar</a></code>.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_impulse">impulse</code></td>
<td>
<p>name of the impulse variable.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_response">response</code></td>
<td>
<p>name of the response variable.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_n.ahead">n.ahead</code></td>
<td>
<p>number of steps ahead.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_ci">ci</code></td>
<td>
<p>a numeric between 0 and 1 specifying the probability mass covered by the
credible intervals. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_shock">shock</code></td>
<td>
<p>size of the shock.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_type">type</code></td>
<td>
<p>type of the impulse response. Possible choices are forecast error <code>"feir"</code>
(default), orthogonalised <code>"oir"</code>, structural <code>"sir"</code>, generalised <code>"gir"</code>,
and structural generalised <code>"sgir"</code> impulse responses.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_cumulative">cumulative</code></td>
<td>
<p>logical specifying whether a cumulative IRF should be calculated.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_keep_draws">keep_draws</code></td>
<td>
<p>logical specifying whether the function should return all draws of
the posterior impulse response function. Defaults to <code>FALSE</code> so that
the median and the credible intervals of the posterior draws are returned.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_period">period</code></td>
<td>
<p>integer. Index of the period, for which the IR should be generated.
Only used for TVP or SV models. Default is <code>NULL</code>, so that the posterior draws of the last time period
are used.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces different types of impulse responses for the VAR model
</p>
<p style="text-align: center;"><code class="reqn">A_0 y_t = \sum_{i = 1}^{p} A_{i} y_{t-i} + u_t,</code>
</p>

<p>with <code class="reqn">u_t \sim N(0, \Sigma)</code>.
</p>
<p>Forecast error impulse responses <code class="reqn">\Phi_i</code> are obtained by recursions
</p>
<p style="text-align: center;"><code class="reqn">\Phi_i = \sum_{j = 1}^{i} \Phi_{i-j} A_j,   i = 1, 2,...,h</code>
</p>

<p>with <code class="reqn">\Phi_0 = I_K</code>.
</p>
<p>Orthogonalised impulse responses <code class="reqn">\Theta^o_i</code> are calculated as <code class="reqn">\Theta^o_i = \Phi_i P</code>,
where P is the lower triangular Choleski decomposition of <code class="reqn">\Sigma</code>.
</p>
<p>Structural impulse responses <code class="reqn">\Theta^s_i</code> are calculated as <code class="reqn">\Theta^s_i = \Phi_i A_0^{-1}</code>.
</p>
<p>(Structural) Generalised impulse responses for variable <code class="reqn">j</code>, i.e. <code class="reqn">\Theta^g_ji</code> are calculated as
<code class="reqn">\Theta^g_{ji} = \sigma_{jj}^{-1/2} \Phi_i A_0^{-1} \Sigma e_j</code>, where <code class="reqn">\sigma_{jj}</code> is the variance
of the <code class="reqn">j^{th}</code> diagonal element of <code class="reqn">\Sigma</code> and <code class="reqn">e_i</code> is a selection vector containing
one in its <code class="reqn">j^{th}</code> element and zero otherwise. If the <code>"bvar"</code> object does not contain draws
of <code class="reqn">A_0</code>, it is assumed to be an identity matrix.
</p>


<h3>Value</h3>

<p>A time-series object of class <code>"bvarirf"</code> and if <code>keep_draws = TRUE</code> a simple matrix.
</p>


<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>
<p>Pesaran, H. H., Shin, Y. (1998). Generalized impulse response analysis in linear multivariate models. <em>Economics Letters, 58</em>, 17-29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate model data
model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Obtain IR
ir &lt;- irf(object, impulse = "invest", response = "cons")

# Plot IR
plot(ir)


</code></pre>

<hr>
<h2 id='kalman_dk'>Durbin and Koopman Simulation Smoother</h2><span id='topic+kalman_dk'></span>

<h3>Description</h3>

<p>An implementation of the Kalman filter and backward smoothing
algorithm proposed by Durbin and Koopman (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalman_dk(y, z, sigma_u, sigma_v, B, a_init, P_init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalman_dk_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of endogenous variables.</p>
</td></tr>
<tr><td><code id="kalman_dk_+3A_z">z</code></td>
<td>
<p>a <code class="reqn">KT \times M</code> matrix of explanatory variables.</p>
</td></tr>
<tr><td><code id="kalman_dk_+3A_sigma_u">sigma_u</code></td>
<td>
<p>the constant <code class="reqn">K \times K</code> error variance-covariance matrix.
For time varying variance-covariance matrices a <code class="reqn">KT \times K</code> can be specified.</p>
</td></tr>
<tr><td><code id="kalman_dk_+3A_sigma_v">sigma_v</code></td>
<td>
<p>the constant <code class="reqn">M \times M</code> coefficient variance-covariance matrix.
For time varying variance-covariance matrices a <code class="reqn">MT \times M</code> can be specified.</p>
</td></tr>
<tr><td><code id="kalman_dk_+3A_b">B</code></td>
<td>
<p>an <code class="reqn">M \times M</code> autocorrelation matrix of the transition equation.</p>
</td></tr>
<tr><td><code id="kalman_dk_+3A_a_init">a_init</code></td>
<td>
<p>an M-dimensional vector of initial states.</p>
</td></tr>
<tr><td><code id="kalman_dk_+3A_p_init">P_init</code></td>
<td>
<p>an <code class="reqn">M \times M</code> variance-covariance matrix of the initial states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses algorithm 2 from Durbin and Koopman (2002) to produce
a draw of the state vector <code class="reqn">a_t</code> for <code class="reqn">t = 1,...,T</code> for a state space model
with measurement equation
</p>
<p style="text-align: center;"><code class="reqn">y_t = Z_t a_t + u_t</code>
</p>

<p>and transition equation 
</p>
<p style="text-align: center;"><code class="reqn">a_{t + 1} = B_t a_{t} + v_t,</code>
</p>

<p>where <code class="reqn">u_t \sim N(0, \Sigma_{u,t})</code> and <code class="reqn">v_t \sim N(0, \Sigma_{v,t})</code>.
<code class="reqn">y_t</code> is a K-dimensional vector of endogenous variables and
<code class="reqn">Z_t = z_t^{\prime} \otimes I_K</code> is a <code class="reqn">K \times M</code> matrix of regressors with
<code class="reqn">z_t</code> as a vector of regressors.
</p>
<p>The algorithm takes into account Jarociński (2015), where a possible missunderstanding
in the implementation of the algorithm of Durbin and Koopman (2002) is pointed out. Following
that note the function sets the mean of the initial state to zero in the first step of the algorithm.
</p>


<h3>Value</h3>

<p>A <code class="reqn">M \times T+1</code> matrix of state vector draws.
</p>


<h3>References</h3>

<p>Durbin, J., &amp; Koopman, S. J. (2002). A simple and efficient simulation smoother for
state space time series analysis. <em>Biometrika, 89</em>(3), 603&ndash;615.
</p>
<p>Jarociński, M. (2015). A note on implementing the Durbin and Koopman simulation
smoother. <em>Computational Statistics and Data Analysis, 91</em>, 1&ndash;3.
<a href="https://doi.org/10.1016/j.csda.2015.05.001">doi:10.1016/j.csda.2015.05.001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
data &lt;- diff(log(e1))

# Generate model data
temp &lt;- gen_var(data, p = 2, deterministic = "const")
y &lt;- t(temp$data$Y)
z &lt;- temp$data$SUR
k &lt;- nrow(y)
tt &lt;- ncol(y)
m &lt;- ncol(z)

# Priors
a_mu_prior &lt;- matrix(0, m)
a_v_i_prior &lt;- diag(0.1, m)

a_Q &lt;- diag(.0001, m)

# Initial value of Sigma
sigma &lt;- tcrossprod(y) / tt
sigma_i &lt;- solve(sigma)

# Initial values for Kalman filter
y_init &lt;- y * 0
a_filter &lt;- matrix(0, m, tt + 1)

# Initialise the Kalman filter
for (i in 1:tt) {
  y_init[, i] &lt;- y[, i] - z[(i - 1) * k + 1:k,] %*% a_filter[, i]
}
a_init &lt;- post_normal_sur(y = y_init, z = z, sigma_i = sigma_i,
                          a_prior = a_mu_prior, v_i_prior = a_v_i_prior)
y_filter &lt;- matrix(y) - z %*% a_init
y_filter &lt;- matrix(y_filter, k) # Reshape

# Kalman filter and backward smoother
a_filter &lt;- kalman_dk(y = y_filter, z = z, sigma_u = sigma,
                      sigma_v = a_Q, B = diag(1, m),
                      a_init = matrix(0, m), P_init = a_Q)
                      
a &lt;- a_filter + matrix(a_init, m, tt + 1)

</code></pre>

<hr>
<h2 id='loglik_normal'>Calculates the log-likelihood of a multivariate normal distribution.</h2><span id='topic+loglik_normal'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_normal(u, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_normal_+3A_u">u</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of residuals.</p>
</td></tr>
<tr><td><code id="loglik_normal_+3A_sigma">sigma</code></td>
<td>
<p>a <code class="reqn">K \times K</code> or <code class="reqn">KT \times K</code> variance-covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood is calculated for each vector in period <code class="reqn">t</code> as
</p>
<p style="text-align: center;"><code class="reqn">-\frac{K}{2} \ln 2\pi - \frac{1}{2} \ln |\Sigma_t| -\frac{1}{2} u_t^\prime \Sigma_t^{-1} u_t</code>
</p>
<p>,
where <code class="reqn">u_t = y_t - \mu_t</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1))

# Generate VAR model
data &lt;- gen_var(e1, p = 2, deterministic = "const")
y &lt;- t(data$data$Y)
x &lt;- t(data$data$Z)

# LS estimate
ols &lt;- tcrossprod(y, x) %*% solve(tcrossprod(x))

# Residuals
u &lt;- y - ols %*% x # Residuals

# Covariance matrix
sigma &lt;- tcrossprod(u) / ncol(u)

# Log-likelihood
loglik_normal(u = u, sigma = sigma)

</code></pre>

<hr>
<h2 id='minnesota_prior'>Minnesota Prior</h2><span id='topic+minnesota_prior'></span>

<h3>Description</h3>

<p>Calculates the Minnesota prior for a VAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minnesota_prior(
  object,
  kappa0 = 2,
  kappa1 = 0.5,
  kappa2 = NULL,
  kappa3 = 5,
  max_var = NULL,
  coint_var = FALSE,
  sigma = "AR"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minnesota_prior_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvarmodel"</code>, usually, a result of a call to <code><a href="#topic+gen_var">gen_var</a></code>
or <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="minnesota_prior_+3A_kappa0">kappa0</code></td>
<td>
<p>a numeric specifying the prior variance of coefficients that correspond to
own lags of endogenous variables.</p>
</td></tr>
<tr><td><code id="minnesota_prior_+3A_kappa1">kappa1</code></td>
<td>
<p>a numeric specifying the size of the prior variance of endogenous
variables, which do not correspond to own lags, relative to argument <code>kappa0</code>.</p>
</td></tr>
<tr><td><code id="minnesota_prior_+3A_kappa2">kappa2</code></td>
<td>
<p>a numeric specifying the size of the prior variance of non-deterministic exogenous
variables relative to argument <code>kappa0</code>. Default is <code>NULL</code>, which indicates that the formula
for the calculation of the prior variance of deterministic terms is used for all exogenous variables.</p>
</td></tr>
<tr><td><code id="minnesota_prior_+3A_kappa3">kappa3</code></td>
<td>
<p>a numeric specifying the size of the prior variance of deterministic
terms relative to argument <code>kappa0</code>.</p>
</td></tr>
<tr><td><code id="minnesota_prior_+3A_max_var">max_var</code></td>
<td>
<p>a positive numeric specifying the maximum prior variance that is allowed for
coefficients of non-deterministic variables. If <code>NULL</code> (default), the prior variances are not limited.</p>
</td></tr>
<tr><td><code id="minnesota_prior_+3A_coint_var">coint_var</code></td>
<td>
<p>a logical specifying whether the model is a cointegrated VAR model,
for which the prior means of first own lags should be set to one.</p>
</td></tr>
<tr><td><code id="minnesota_prior_+3A_sigma">sigma</code></td>
<td>
<p>either <code>"AR"</code> (default) or <code>"VAR"</code> indicating that the variances of the endogenous
variables <code class="reqn">\sigma^2</code> are calculated based on a univariate AR regression or a least squares estimate of
the VAR form, respectively. In both cases all deterministic variables are used in the regressions,
if they appear in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the Minnesota prior of a VAR model. For the endogenous variable
<code class="reqn">i</code> the prior variance of the <code class="reqn">l</code>th lag of regressor <code class="reqn">j</code> is obtained as
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0}}{l^2} \textrm{ for own lags of endogenous variables,}</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0} \kappa_{1}}{l^2} \frac{\sigma_{i}^2}{\sigma_{j}^2} \textrm{ for endogenous variables other than own lags,}</code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{\kappa_{0} \kappa_{2}}{(l + 1)^2} \frac{\sigma_{i}^2}{\sigma_{j}^2} \textrm{ for exogenous variables,}</code>
</p>

<p style="text-align: center;"><code class="reqn"> \kappa_{0} \kappa_{3} \sigma_{i}^2 \textrm{ for deterministic terms,}</code>
</p>

<p>where <code class="reqn">\sigma_{i}</code> is the residual standard deviation of variable <code class="reqn">i</code> of an unrestricted
LS estimate. For exogenous variables <code class="reqn">\sigma_{i}</code> is the sample standard deviation.
</p>
<p>For VEC models the function only provides priors for the non-cointegration part of the model. The
residual standard errors <code class="reqn">\sigma_i</code> are based on an unrestricted LS regression of the
endogenous variables on the error correction term and the non-cointegration regressors.
</p>


<h3>Value</h3>

<p>A list containing a matrix of prior means and the precision matrix of the cofficients and the
inverse variance-covariance matrix of the error term, which was obtained by an LS estimation.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias, J. L. (2020). <em>Bayesian Econometric Methods</em>
(2nd ed.). Cambridge: University Press.
</p>
<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
data &lt;- diff(log(e1))

# Generate model input
object &lt;- gen_var(data)

# Obtain Minnesota prior
prior &lt;- minnesota_prior(object)

</code></pre>

<hr>
<h2 id='plot.bvarlist'>Plotting Posterior Draws of Bayesian VAR or VEC Models</h2><span id='topic+plot.bvarlist'></span>

<h3>Description</h3>

<p>A plot function for objects of class <code>"bvarlist"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvarlist'
plot(x, ci = 0.95, type = "hist", model = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bvarlist_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bvarlist"</code>, usually, a result of a call to <code><a href="#topic+draw_posterior">draw_posterior</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvarlist_+3A_ci">ci</code></td>
<td>
<p>interval used to calculate credible bands for time-varying parameters.</p>
</td></tr>
<tr><td><code id="plot.bvarlist_+3A_type">type</code></td>
<td>
<p>either <code>"hist"</code> (default) for histograms, <code>"trace"</code> for a trace plot,
or <code>"boxplot"</code> for a boxplot. Only used for parameter draws of constant coefficients.</p>
</td></tr>
<tr><td><code id="plot.bvarlist_+3A_model">model</code></td>
<td>
<p>numeric or integer indicating for which models in argument <code>"x"</code> plots should be produced.</p>
</td></tr>
<tr><td><code id="plot.bvarlist_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.bvarprd'>Plotting Forecasts of BVAR Models</h2><span id='topic+plot.bvarprd'></span>

<h3>Description</h3>

<p>A plot function for objects of class <code>"bvarprd"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvarprd'
plot(x, n.pre = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bvarprd_+3A_x">x</code></td>
<td>
<p>an object of class &quot;bvarprd&quot;, usually, a result of a call to <code><a href="#topic+predict.bvar">predict.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvarprd_+3A_n.pre">n.pre</code></td>
<td>
<p>number of plotted observations that precede the forecasts. If <code>NULL</code> (default),
all available obervations will be plotted.</p>
</td></tr>
<tr><td><code id="plot.bvarprd_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate model data
model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)

# Add prior specifications
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Calculate forecasts
pred &lt;- predict(object, new_d = rep(1, 10))

# Plot forecasts
plot(pred)

</code></pre>

<hr>
<h2 id='post_coint_kls'>Posterior Draw for Cointegration Models</h2><span id='topic+post_coint_kls'></span>

<h3>Description</h3>

<p>Produces a draw of coefficients for cointegration models with a prior on
the cointegration space as proposed in Koop et al. (2010) and a draw of
non-cointegration coefficients from a normal density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_coint_kls(
  y,
  beta,
  w,
  sigma_i,
  v_i,
  p_tau_i,
  g_i,
  x = NULL,
  gamma_mu_prior = NULL,
  gamma_v_i_prior = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_coint_kls_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of differenced endogenous variables.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_beta">beta</code></td>
<td>
<p>a <code class="reqn">M \times r</code> cointegration matrix <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_w">w</code></td>
<td>
<p>a <code class="reqn">M \times T</code> matrix of variables in the cointegration term.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_sigma_i">sigma_i</code></td>
<td>
<p>an inverse of the <code class="reqn">K \times K</code> variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_v_i">v_i</code></td>
<td>
<p>a numeric between 0 and 1 specifying the shrinkage of the cointegration space prior.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_p_tau_i">p_tau_i</code></td>
<td>
<p>an inverted <code class="reqn">M \times M</code> matrix specifying the central location
of the cointegration space prior of <code class="reqn">sp(\beta)</code>.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_g_i">g_i</code></td>
<td>
<p>a <code class="reqn">K \times K</code> matrix.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_x">x</code></td>
<td>
<p>a <code class="reqn">N \times T</code> matrix of differenced regressors and unrestricted deterministic terms.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_gamma_mu_prior">gamma_mu_prior</code></td>
<td>
<p>a <code class="reqn">KN \times 1</code> prior mean vector of non-cointegration coefficients.</p>
</td></tr>
<tr><td><code id="post_coint_kls_+3A_gamma_v_i_prior">gamma_v_i_prior</code></td>
<td>
<p>an inverted <code class="reqn">KN \times KN</code> prior covariance matrix of non-cointegration coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces posterior draws of the coefficient
matrices <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\Gamma</code> for the model
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = \alpha \beta^{\prime} w_{t-1} + \Gamma z_{t} + u_{t},</code>
</p>

<p>where <code class="reqn">y_{t}</code> is a K-dimensional vector of differenced endogenous variables.
<code class="reqn">w_{t}</code> is an <code class="reqn">M \times 1</code> vector of variables in the cointegration term,
which include lagged values of endogenous and exogenous variables in levels and
restricted deterministic terms. <code class="reqn">z_{t}</code> is an N-dimensional vector of
differenced endogenous and exogenous explanatory variabes as well as unrestricted
deterministic terms. The error term is <code class="reqn">u_t \sim \Sigma</code>.
</p>
<p>Draws of the loading matrix <code class="reqn">\alpha</code> are obtained using the prior on the cointegration space
as proposed in Koop et al. (2010). The posterior covariance matrix is
</p>
<p style="text-align: center;"><code class="reqn">\overline{V}_{\alpha} = \left[\left(v^{-1} (\beta^{\prime} P_{\tau}^{-1} \beta) \otimes G_{-1}\right) + \left(ZZ^{\prime} \otimes \Sigma^{-1} \right) \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{\alpha} = \overline{V}_{\alpha} + vec(\Sigma^{-1} Y Z^{\prime}),</code>
</p>

<p>where <code class="reqn">Y</code> is a <code class="reqn">K \times T</code> matrix of differenced endogenous variables and
<code class="reqn">Z = \beta^{\prime} W</code> with <code class="reqn">W</code> as an <code class="reqn">M \times T</code> matrix of
variables in the cointegration term.
</p>
<p>For a given prior mean vector <code class="reqn">\underline{\Gamma}</code> and prior covariance matrix <code class="reqn">\underline{V_{\Gamma}}</code>
the posterior covariance matrix of non-cointegration coefficients in <code class="reqn">\Gamma</code> is obtained by
</p>
<p style="text-align: center;"><code class="reqn">\overline{V}_{\Gamma} = \left[ \underline{V}_{\Gamma}^{-1} + \left(X X^{\prime} \otimes \Sigma^{-1} \right) \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{\Gamma} = \overline{V}_{\Gamma} \left[ \underline{V}_{\Gamma}^{-1} \underline{\Gamma} + vec(\Sigma^{-1} Y X^{\prime}) \right],</code>
</p>

<p>where <code class="reqn">X</code> is an <code class="reqn">M \times T</code> matrix of
explanatory variables, which do not enter the cointegration term.
</p>
<p>Draws of the cointegration matrix <code class="reqn">\beta</code> are obtained using the prior on the cointegration space
as proposed in Koop et al. (2010). The posterior covariance matrix of the unrestricted cointegration
matrix <code class="reqn">B</code> is
</p>
<p style="text-align: center;"><code class="reqn">\overline{V}_{B} = \left[\left(A^{\prime} G^{-1} A \otimes v^{-1} P_{\tau}^{-1} \right) + \left(A^{\prime} \Sigma^{-1} A \otimes WW^{\prime} \right) \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{B} = \overline{V}_{B} + vec(W Y_{B}^{-1} \Sigma^{-1} A),</code>
</p>

<p>where <code class="reqn">Y_{B} = Y - \Gamma X</code> and <code class="reqn">A = \alpha (\alpha^{\prime} \alpha)^{-\frac{1}{2}}</code>.
</p>
<p>The final draws of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are calculated using
<code class="reqn">\beta = B (B^{\prime} B)^{-\frac{1}{2}}</code> and
<code class="reqn">\alpha = A (B^{\prime} B)^{\frac{1}{2}}</code>.
</p>


<h3>Value</h3>

<p>A named list containing the following elements:
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>a draw of the <code class="reqn">K \times r</code> loading matrix.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a draw of the <code class="reqn">M \times r</code> cointegration matrix.</p>
</td></tr>
<tr><td><code>Pi</code></td>
<td>
<p>a draw of the <code class="reqn">K \times M</code> cointegration matrix <code class="reqn">\Pi = \alpha \beta^{\prime}</code>.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>a draw of the <code class="reqn">K \times N</code> coefficient matrix for non-cointegration parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Koop, G., León-González, R., &amp; Strachan R. W. (2010). Efficient posterior
simulation for cointegrated models with priors on the cointegration space.
<em>Econometric Reviews, 29</em>(2), 224-242. <a href="https://doi.org/10.1080/07474930903382208">doi:10.1080/07474930903382208</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e6")

# Generate model data
temp &lt;- gen_vec(e6, p = 1, r = 1)
y &lt;- t(temp$data$Y)
ect &lt;- t(temp$data$W)

k &lt;- nrow(y) # Endogenous variables
tt &lt;- ncol(y) # Number of observations

# Initial value of Sigma
sigma &lt;- tcrossprod(y) / tt
sigma_i &lt;- solve(sigma)

# Initial values of beta
beta &lt;- matrix(c(1, -4), k)

# Draw parameters
coint &lt;- post_coint_kls(y = y, beta = beta, w = ect, sigma_i = sigma_i,
                        v_i = 0, p_tau_i = diag(1, k), g_i = sigma_i)

</code></pre>

<hr>
<h2 id='post_coint_kls_sur'>Posterior Draw for Cointegration Models</h2><span id='topic+post_coint_kls_sur'></span>

<h3>Description</h3>

<p>Produces a draw of coefficients for cointegration models in SUR form with a prior on
the cointegration space as proposed in Koop et al. (2010) and a draw of
non-cointegration coefficients from a normal density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_coint_kls_sur(
  y,
  beta,
  w,
  sigma_i,
  v_i,
  p_tau_i,
  g_i,
  x = NULL,
  gamma_mu_prior = NULL,
  gamma_v_i_prior = NULL,
  svd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_coint_kls_sur_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of differenced endogenous variables.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_beta">beta</code></td>
<td>
<p>a <code class="reqn">M \times r</code> cointegration matrix <code class="reqn">\beta</code>, where <code class="reqn">\beta^{\prime} \beta = I</code>.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_w">w</code></td>
<td>
<p>a <code class="reqn">M \times T</code> matrix of variables in the cointegration term.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_sigma_i">sigma_i</code></td>
<td>
<p>the inverse of the constant <code class="reqn">K \times K</code> error variance-covariance matrix.
For time varying variance-covariance matrics a <code class="reqn">KT \times K</code> can be provided.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_v_i">v_i</code></td>
<td>
<p>a numeric between 0 and 1 specifying the shrinkage of the cointegration space prior.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_p_tau_i">p_tau_i</code></td>
<td>
<p>an inverted <code class="reqn">M \times M</code> matrix specifying the central location
of the cointegration space prior of <code class="reqn">sp(\beta)</code>.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_g_i">g_i</code></td>
<td>
<p>a <code class="reqn">K \times K</code> or <code class="reqn">KT \times K</code> matrix. If the matrix is <code class="reqn">KT \times K</code>,
the function will automatically produce a <code class="reqn">K \times K</code> matrix containing the means of the
time varying <code class="reqn">K \times K</code> covariance matrix.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_x">x</code></td>
<td>
<p>a <code class="reqn">KT \times NK</code> matrix of differenced regressors and unrestricted deterministic terms.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_gamma_mu_prior">gamma_mu_prior</code></td>
<td>
<p>a <code class="reqn">KN \times 1</code> prior mean vector of non-cointegration coefficients.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_gamma_v_i_prior">gamma_v_i_prior</code></td>
<td>
<p>an inverted <code class="reqn">KN \times KN</code> prior covariance matrix of
non-cointegration coefficients.</p>
</td></tr>
<tr><td><code id="post_coint_kls_sur_+3A_svd">svd</code></td>
<td>
<p>logical. If <code>TRUE</code> the singular value decomposition is used to determine
the root of the posterior covariance matrix. Default is <code>FALSE</code> which means
that the eigenvalue decomposition is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces posterior draws of the coefficient
matrices <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\Gamma</code> for the model
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = \alpha \beta^{\prime} w_{t-1} + \Gamma z_{t} + u_{t},</code>
</p>

<p>where <code class="reqn">y_{t}</code> is a K-dimensional vector of differenced endogenous variables.
<code class="reqn">w_{t}</code> is an <code class="reqn">M \times 1</code> vector of variables in the cointegration term,
which include lagged values of endogenous and exogenous variables in levels and
restricted deterministic terms. <code class="reqn">z_{t}</code> is an N-dimensional vector of
differenced endogenous and exogenous explanatory variabes as well as unrestricted
deterministic terms. The error term is <code class="reqn">u_t \sim \Sigma</code>.
</p>
<p>Draws of the loading matrix <code class="reqn">\alpha</code> are obtained using the prior on the cointegration space
as proposed in Koop et al. (2010). The posterior covariance matrix is
</p>
<p style="text-align: center;"><code class="reqn">\overline{V}_{\alpha} = \left[\left(v^{-1} (\beta^{\prime} P_{\tau}^{-1} \beta) \otimes G_{-1}\right) + \left(ZZ^{\prime} \otimes \Sigma^{-1} \right) \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{\alpha} = \overline{V}_{\alpha} + vec(\Sigma^{-1} Y Z^{\prime}),</code>
</p>

<p>where <code class="reqn">Y</code> is a <code class="reqn">K \times T</code> matrix of differenced endogenous variables and
<code class="reqn">Z = \beta^{\prime} W</code> with <code class="reqn">W</code> as an <code class="reqn">M \times T</code> matrix of
variables in the cointegration term.
</p>
<p>For a given prior mean vector <code class="reqn">\underline{\Gamma}</code> and prior covariance matrix <code class="reqn">\underline{V_{\Gamma}}</code>
the posterior covariance matrix of non-cointegration coefficients in <code class="reqn">\Gamma</code> is obtained by
</p>
<p style="text-align: center;"><code class="reqn">\overline{V}_{\Gamma} = \left[ \underline{V}_{\Gamma}^{-1} + \left(X X^{\prime} \otimes \Sigma^{-1} \right) \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{\Gamma} = \overline{V}_{\Gamma} \left[ \underline{V}_{\Gamma}^{-1} \underline{\Gamma} + vec(\Sigma^{-1} Y X^{\prime}) \right],</code>
</p>

<p>where <code class="reqn">X</code> is an <code class="reqn">M \times T</code> matrix of
explanatory variables, which do not enter the cointegration term.
</p>
<p>Draws of the cointegration matrix <code class="reqn">\beta</code> are obtained using the prior on the cointegration space
as proposed in Koop et al. (2010). The posterior covariance matrix of the unrestricted cointegration
matrix <code class="reqn">B</code> is
</p>
<p style="text-align: center;"><code class="reqn">\overline{V}_{B} = \left[\left(A^{\prime} G^{-1} A \otimes v^{-1} P_{\tau}^{-1} \right) + \left(A^{\prime} \Sigma^{-1} A \otimes WW^{\prime} \right) \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{B} = \overline{V}_{B} + vec(W Y_{B}^{-1} \Sigma^{-1} A),</code>
</p>

<p>where <code class="reqn">Y_{B} = Y - \Gamma X</code> and <code class="reqn">A = \alpha (\alpha^{\prime} \alpha)^{-\frac{1}{2}}</code>.
</p>
<p>The final draws of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are calculated using
<code class="reqn">\beta = B (B^{\prime} B)^{-\frac{1}{2}}</code> and
<code class="reqn">\alpha = A (B^{\prime} B)^{\frac{1}{2}}</code>.
</p>


<h3>Value</h3>

<p>A named list containing the following elements:
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>a draw of the <code class="reqn">K \times r</code> loading matrix.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a draw of the <code class="reqn">M \times r</code> cointegration matrix.</p>
</td></tr>
<tr><td><code>Pi</code></td>
<td>
<p>a draw of the <code class="reqn">K \times M</code> cointegration matrix <code class="reqn">\Pi = \alpha \beta^{\prime}</code>.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>a draw of the <code class="reqn">K \times N</code> coefficient matrix for non-cointegration parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Koop, G., León-González, R., &amp; Strachan R. W. (2010). Efficient posterior
simulation for cointegrated models with priors on the cointegration space.
<em>Econometric Reviews, 29</em>(2), 224-242. <a href="https://doi.org/10.1080/07474930903382208">doi:10.1080/07474930903382208</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e6")

# Generate model data
temp &lt;- gen_vec(e6, p = 1, r = 1)
y &lt;- t(temp$data$Y)
ect &lt;- t(temp$data$W)

k &lt;- nrow(y) # Endogenous variables
tt &lt;- ncol(y) # Number of observations

# Initial value of Sigma
sigma &lt;- tcrossprod(y) / tt
sigma_i &lt;- solve(sigma)

# Initial values of beta
beta &lt;- matrix(c(1, -4), k)

# Draw parameters
coint &lt;- post_coint_kls_sur(y = y, beta = beta, w = ect,
                            sigma_i = sigma_i, v_i = 0, p_tau_i = diag(1, nrow(ect)),
                            g_i = sigma_i)

</code></pre>

<hr>
<h2 id='post_normal'>Posterior Draw from a Normal Distribution</h2><span id='topic+post_normal'></span>

<h3>Description</h3>

<p>Produces a draw of coefficients from a normal posterior density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_normal(y, x, sigma_i, a_prior, v_i_prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_normal_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of endogenous variables.</p>
</td></tr>
<tr><td><code id="post_normal_+3A_x">x</code></td>
<td>
<p>an <code class="reqn">M \times T</code> matrix of explanatory variables.</p>
</td></tr>
<tr><td><code id="post_normal_+3A_sigma_i">sigma_i</code></td>
<td>
<p>the inverse of the <code class="reqn">K \times K</code> variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="post_normal_+3A_a_prior">a_prior</code></td>
<td>
<p>a <code class="reqn">KM \times 1</code> numeric vector of prior means.</p>
</td></tr>
<tr><td><code id="post_normal_+3A_v_i_prior">v_i_prior</code></td>
<td>
<p>the inverse of the <code class="reqn">KM \times KM</code> prior covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a vectorised posterior draw <code class="reqn">a</code> of the
<code class="reqn">K \times M</code> coefficient matrix <code class="reqn">A</code> for the model
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = A x_{t} + u_{t},</code>
</p>

<p>where <code class="reqn">y_{t}</code> is a K-dimensional vector of endogenous variables,
<code class="reqn">x_{t}</code> is an M-dimensional vector of explanatory variabes
and the error term is <code class="reqn">u_t \sim \Sigma</code>.
</p>
<p>For a given prior mean vector <code class="reqn">\underline{a}</code> and prior covariance matrix <code class="reqn">\underline{V}</code>
the posterior covariance matrix is obtained by
</p>
<p style="text-align: center;"><code class="reqn">\overline{V} = \left[ \underline{V}^{-1} + \left(X X^{\prime} \otimes \Sigma^{-1} \right) \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{a} = \overline{V} \left[ \underline{V}^{-1} \underline{a} + vec(\Sigma^{-1} Y X^{\prime}) \right],</code>
</p>

<p>where <code class="reqn">Y</code> is a <code class="reqn">K \times T</code> matrix of the endogenous variables and <code class="reqn">X</code> is an <code class="reqn">M \times T</code> matrix of
the explanatory variables.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>References</h3>

<p>Lütkepohl, H. (2006). <em>New introduction to multiple time series analysis</em> (2nd ed.). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
data &lt;- diff(log(e1))

# Generate model data
temp &lt;- gen_var(data, p = 2, deterministic = "const")
y &lt;- t(temp$data$Y)
x &lt;- t(temp$data$Z)
k &lt;- nrow(y)
tt &lt;- ncol(y)
m &lt;- k * nrow(x)

# Priors
a_mu_prior &lt;- matrix(0, m)
a_v_i_prior &lt;- diag(0.1, m)

# Initial value of inverse Sigma
sigma_i &lt;- solve(tcrossprod(y) / tt)

# Draw parameters
a &lt;- post_normal(y = y, x = x, sigma_i = sigma_i,
                 a_prior = a_mu_prior, v_i_prior = a_v_i_prior)

</code></pre>

<hr>
<h2 id='post_normal_covar_const'>Posterior Simulation of Error Covariance Coefficients</h2><span id='topic+post_normal_covar_const'></span>

<h3>Description</h3>

<p>Produces posterior draws of constant error covariance coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_normal_covar_const(y, u_omega_i, prior_mean, prior_covariance_i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_normal_covar_const_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of data with <code class="reqn">K</code> as the number of
endogenous variables and <code class="reqn">T</code> the number of observations.</p>
</td></tr>
<tr><td><code id="post_normal_covar_const_+3A_u_omega_i">u_omega_i</code></td>
<td>
<p>matrix of error variances of the measurement equation.
Either a <code class="reqn">K \times K</code> matrix for constant variances or
a <code class="reqn">KT \times KT</code> matrix for time varying variances.</p>
</td></tr>
<tr><td><code id="post_normal_covar_const_+3A_prior_mean">prior_mean</code></td>
<td>
<p>vector of prior means. In case of TVP, this vector is used
as initial condition.</p>
</td></tr>
<tr><td><code id="post_normal_covar_const_+3A_prior_covariance_i">prior_covariance_i</code></td>
<td>
<p>inverse prior covariance matrix. In case of TVP, this matrix
is used as initial condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the multivariate model <code class="reqn">A_0 y_t = u_t</code> with <code class="reqn">u_t \sim N(0, \Omega_t)</code>
the function produces a draw of the lower triangular part of <code class="reqn">A_0</code> similar as in
Primiceri (2005), i.e., using </p>
<p style="text-align: center;"><code class="reqn">y_t = Z_t \psi + u_t,</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">Z_{t} = \begin{bmatrix} 0 &amp; \dotsm &amp; \dotsm &amp; 0 \\ -y_{1, t} &amp; 0 &amp; \dotsm &amp; 0 \\ 0 &amp; -y_{[1,2], t} &amp; \ddots &amp; \vdots \\ \vdots &amp; \ddots &amp; \ddots &amp; 0 \\ 0 &amp; \dotsm &amp; 0 &amp; -y_{[1,...,K-1], t} \end{bmatrix}</code>
</p>

<p>and <code class="reqn">y_{[1,...,K-1], t}</code> denotes the first to <code class="reqn">(K-1)</code>th elements of the vector <code class="reqn">y_t</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>References</h3>

<p>Primiceri, G. E. (2005). Time varying structural vector autoregressions and monetary policy.
<em>The Review of Economic Studies, 72</em>(3), 821&ndash;852. <a href="https://doi.org/10.1111/j.1467-937X.2005.00353.x">doi:10.1111/j.1467-937X.2005.00353.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data
data("e1")
y &lt;- log(t(e1))

# Generate artificial draws of other matrices
u_omega_i &lt;- diag(1, 3)
prior_mean &lt;- matrix(0, 3)
prior_covariance_i &lt;- diag(0, 3)

# Obtain posterior draw
post_normal_covar_const(y, u_omega_i, prior_mean, prior_covariance_i)

</code></pre>

<hr>
<h2 id='post_normal_covar_tvp'>Posterior Simulation of Error Covariance Coefficients</h2><span id='topic+post_normal_covar_tvp'></span>

<h3>Description</h3>

<p>Produces posterior draws of time varying error covariance coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_normal_covar_tvp(y, u_omega_i, v_sigma_i, psi_init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_normal_covar_tvp_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of data with <code class="reqn">K</code> as the number of
endogenous variables and <code class="reqn">T</code> the number of observations.</p>
</td></tr>
<tr><td><code id="post_normal_covar_tvp_+3A_u_omega_i">u_omega_i</code></td>
<td>
<p>matrix of error variances of the measurement equation.
Either a <code class="reqn">K \times K</code> matrix for constant variances or
a <code class="reqn">KT \times KT</code> matrix for time varying variances.</p>
</td></tr>
<tr><td><code id="post_normal_covar_tvp_+3A_v_sigma_i">v_sigma_i</code></td>
<td>
<p>matrix of error variances of the state equation.
Either an <code class="reqn">M \times M</code> matrix for constant variances or
an <code class="reqn">MT \times MT</code> matrix for time varying variances, where <code class="reqn">M</code> is the
number of estimated variables.</p>
</td></tr>
<tr><td><code id="post_normal_covar_tvp_+3A_psi_init">psi_init</code></td>
<td>
<p>a vector of inital values of the state equation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the multivariate model <code class="reqn">A_{0,t} y_t = u_t</code> with <code class="reqn">u_t \sim N(0, \Omega_t)</code>
the function produces a draw of the lower triangular part of <code class="reqn">A_{0,t}</code> similar as in
Primiceri (2005), i.e., using </p>
<p style="text-align: center;"><code class="reqn">y_t = Z_t \psi_t + u_t,</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">Z_{t} = \begin{bmatrix} 0 &amp; \dotsm &amp; \dotsm &amp; 0 \\ -y_{1, t} &amp; 0 &amp; \dotsm &amp; 0 \\ 0 &amp; -y_{[1,2], t} &amp; \ddots &amp; \vdots \\ \vdots &amp; \ddots &amp; \ddots &amp; 0 \\ 0 &amp; \dotsm &amp; 0 &amp; -y_{[1,...,K-1], t} \end{bmatrix}</code>
</p>

<p>and <code class="reqn">y_{[1,...,K-1], t}</code> denotes the first to <code class="reqn">(K-1)</code>th elements of the vector <code class="reqn">y_t</code>.
</p>
<p>The algorithm of Chan and Jeliazkov (2009) is used to obtain time varying coefficients.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>References</h3>

<p>Chan, J., &amp; Jeliazkov, I. (2009). Efficient simulation and integrated likelihood estimation in state space
models. <em>International Journal of Mathematical Modelling and Numerical Optimisation, 1</em>(1/2), 101–120.
<a href="https://doi.org/10.1504/IJMMNO.2009.030090">doi:10.1504/IJMMNO.2009.030090</a>
</p>
<p>Primiceri, G. E. (2005). Time varying structural vector autoregressions and monetary policy.
<em>The Review of Economic Studies, 72</em>(3), 821&ndash;852. <a href="https://doi.org/10.1111/j.1467-937X.2005.00353.x">doi:10.1111/j.1467-937X.2005.00353.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data
data("e1")
y &lt;- log(t(e1))

# Generate artificial draws of other matrices
u_omega_i &lt;- diag(1, 3)
v_sigma_i &lt;- diag(1000, 3)
psi_init &lt;- matrix(0, 3)

# Obtain posterior draw
post_normal_covar_tvp(y, u_omega_i, v_sigma_i, psi_init)

</code></pre>

<hr>
<h2 id='post_normal_sur'>Posterior Draw from a Normal Distribution</h2><span id='topic+post_normal_sur'></span>

<h3>Description</h3>

<p>Produces a draw of coefficients from a normal posterior density for
a model with seemingly unrelated regresssions (SUR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_normal_sur(y, z, sigma_i, a_prior, v_i_prior, svd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_normal_sur_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of endogenous variables.</p>
</td></tr>
<tr><td><code id="post_normal_sur_+3A_z">z</code></td>
<td>
<p>a <code class="reqn">KT \times M</code> matrix of explanatory variables.</p>
</td></tr>
<tr><td><code id="post_normal_sur_+3A_sigma_i">sigma_i</code></td>
<td>
<p>the inverse of the constant <code class="reqn">K \times K</code> error variance-covariance matrix.
For time varying variance-covariance matrics a <code class="reqn">KT \times K</code> can be provided.</p>
</td></tr>
<tr><td><code id="post_normal_sur_+3A_a_prior">a_prior</code></td>
<td>
<p>a <code class="reqn">M x 1</code> numeric vector of prior means.</p>
</td></tr>
<tr><td><code id="post_normal_sur_+3A_v_i_prior">v_i_prior</code></td>
<td>
<p>the inverse of the <code class="reqn">M x M</code> prior covariance matrix.</p>
</td></tr>
<tr><td><code id="post_normal_sur_+3A_svd">svd</code></td>
<td>
<p>logical. If <code>TRUE</code> the singular value decomposition is used to determine
the root of the posterior covariance matrix. Default is <code>FALSE</code> which means
that the eigenvalue decomposition is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a posterior draw of the coefficient vector <code class="reqn">a</code> for the model
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = Z_{t} a + u_{t},</code>
</p>

<p>where <code class="reqn">u_t \sim N(0, \Sigma_{t})</code>.
<code class="reqn">y_t</code> is a K-dimensional vector of endogenous variables and
<code class="reqn">Z_t = z_t^{\prime} \otimes I_K</code> is a <code class="reqn">K \times KM</code> matrix of regressors with
<code class="reqn">z_t</code> as a vector of regressors.
</p>
<p>For a given prior mean vector <code class="reqn">\underline{a}</code> and prior covariance matrix <code class="reqn">\underline{V}</code>
the posterior covariance matrix is obtained by
</p>
<p style="text-align: center;"><code class="reqn">\overline{V} = \left[ \underline{V}^{-1} + \sum_{t=1}^{T} Z_{t}^{\prime} \Sigma_{t}^{-1} Z_{t} \right]^{-1}</code>
</p>

<p>and the posterior mean by
</p>
<p style="text-align: center;"><code class="reqn">\overline{a} = \overline{V} \left[ \underline{V}^{-1} \underline{a} + \sum_{t=1}^{T} Z_{t}^{\prime} \Sigma_{t}^{-1} y_{t}  \right].</code>
</p>



<h3>Value</h3>

<p>A vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
data &lt;- diff(log(e1))

# Generate model data
temp &lt;- gen_var(data, p = 2, deterministic = "const")
y &lt;- t(temp$data$Y)
z &lt;- temp$data$SUR
k &lt;- nrow(y)
tt &lt;- ncol(y)
m &lt;- ncol(z)

# Priors
a_mu_prior &lt;- matrix(0, m)
a_v_i_prior &lt;- diag(0.1, m)

# Initial value of inverse Sigma
sigma_i &lt;- solve(tcrossprod(y) / tt)

# Draw parameters
a &lt;- post_normal_sur(y = y, z = z, sigma_i = sigma_i,
                     a_prior = a_mu_prior, v_i_prior = a_v_i_prior)

</code></pre>

<hr>
<h2 id='ssvs'>Stochastic Search Variable Selection</h2><span id='topic+ssvs'></span>

<h3>Description</h3>

<p><code>ssvs</code> employs stochastic search variable selection as proposed by George et al. (2008)
to produce a draw of the precision matrix of the coefficients in a VAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssvs(a, tau0, tau1, prob_prior, include = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssvs_+3A_a">a</code></td>
<td>
<p>an M-dimensional vector of coefficient draws.</p>
</td></tr>
<tr><td><code id="ssvs_+3A_tau0">tau0</code></td>
<td>
<p>an M-dimensional vector of prior standard deviations for restricted
coefficients in vector <code>a</code>.</p>
</td></tr>
<tr><td><code id="ssvs_+3A_tau1">tau1</code></td>
<td>
<p>an M-dimensional vector of prior standard deviations for unrestricted
coefficients in vector <code>a</code>.</p>
</td></tr>
<tr><td><code id="ssvs_+3A_prob_prior">prob_prior</code></td>
<td>
<p>an M-dimensional vector of prior inclusion probabilites for the coefficients
in vector <code>a</code>.</p>
</td></tr>
<tr><td><code id="ssvs_+3A_include">include</code></td>
<td>
<p>an integer vector specifying the positions of coefficients in vector <code>a</code>, which should be
included in the SSVS algorithm. If <code>NULL</code> (default), SSVS will be applied to all coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function employs stochastic search variable selection (SSVS) as proposed
by George et al. (2008) to produce a draw of the diagonal inverse prior covariance matrix
<code class="reqn">\underline{V}^{-1}</code> and the corresponding vector of inclusion parameters <code class="reqn">\lambda</code>
of the vectorised coefficient matrix <code class="reqn">a = vec(A)</code> for the VAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t = A x_t + u_t,</code>
</p>

<p>where <code class="reqn">y_{t}</code> is a K-dimensional vector of endogenous variables,
<code class="reqn">x_{t}</code> is a vector of explanatory variabes
and the error term is <code class="reqn">u_t \sim \Sigma</code>.
</p>


<h3>Value</h3>

<p>A named list containing two components:
</p>
<table>
<tr><td><code>v_i</code></td>
<td>
<p>an <code class="reqn">M \times M</code> inverse prior covariance matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>an M-dimensional vector of inclusion parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>George, E. I., Sun, D., &amp; Ni, S. (2008). Bayesian stochastic search for VAR model
restrictions. <em>Journal of Econometrics, 142</em>(1), 553&ndash;580.
<a href="https://doi.org/10.1016/j.jeconom.2007.08.017">doi:10.1016/j.jeconom.2007.08.017</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
data &lt;- diff(log(e1))

# Generate model data
temp &lt;- gen_var(data, p = 2, deterministic = "const")
y &lt;- t(temp$data$Y)
x &lt;- t(temp$data$Z)
k &lt;- nrow(y)
tt &lt;- ncol(y)
m &lt;- k * nrow(x)

# Obtain SSVS priors using the semiautomatic approach
priors &lt;- ssvs_prior(temp, semiautomatic = c(0.1, 10))
tau0 &lt;- priors$tau0
tau1 &lt;- priors$tau1

# Prior for inclusion parameter
prob_prior &lt;- matrix(0.5, m)

# Priors
a_mu_prior &lt;- matrix(0, m)
a_v_i_prior &lt;- diag(c(tau1^2), m)

# Initial value of Sigma
sigma_i &lt;- solve(tcrossprod(y) / tt)

# Draw parameters
a &lt;- post_normal(y = y, x = x, sigma_i = sigma_i,
                 a_prior = a_mu_prior, v_i_prior = a_v_i_prior)

# Run SSVS
lambda &lt;- ssvs(a = a, tau0 = tau0, tau1 = tau1,
               prob_prior = prob_prior)

</code></pre>

<hr>
<h2 id='ssvs_prior'>Stochastic Search Variable Selection Prior</h2><span id='topic+ssvs_prior'></span>

<h3>Description</h3>

<p>Calculates the priors for a Bayesian VAR model, which employs stochastic search variable selection (SSVS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssvs_prior(object, tau = c(0.05, 10), semiautomatic = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssvs_prior_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvarmodel"</code>, usually, a result of a call to <code><a href="#topic+gen_var">gen_var</a></code>
or <code><a href="#topic+gen_vec">gen_vec</a></code>.</p>
</td></tr>
<tr><td><code id="ssvs_prior_+3A_tau">tau</code></td>
<td>
<p>a numeric vector of two elements containing the prior standard errors of restricted
variables (<code class="reqn">\tau_0</code>) as its first element and unrestricted variables (<code class="reqn">\tau_1</code>)
as its second. Default is <code>c(0.05, 10)</code>.</p>
</td></tr>
<tr><td><code id="ssvs_prior_+3A_semiautomatic">semiautomatic</code></td>
<td>
<p>an optional numeric vector of two elements containing the factors by which
the standard errors associated with an unconstrained least squares estimate of the VAR model are
multiplied to obtain the prior standard errors of restricted (<code class="reqn">\tau_0</code>) and unrestricted
(<code class="reqn">\tau_1</code>) variables. This is the semiautomatic approach described in George et al. (2008).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the vectors of prior standard deviations for restricted
and unrestricted variables, respectively.
</p>


<h3>References</h3>

<p>George, E. I., Sun, D., &amp; Ni, S. (2008). Bayesian stochastic search for VAR model
restrictions. <em>Journal of Econometrics, 142</em>(1), 553&ndash;580.
<a href="https://doi.org/10.1016/j.jeconom.2007.08.017">doi:10.1016/j.jeconom.2007.08.017</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Prepare data
data("e1")
data &lt;- diff(log(e1))

# Generate model input
object &lt;- gen_var(data)

# Obtain SSVS prior
prior &lt;- ssvs_prior(object, semiautomatic = c(.1, 10))

</code></pre>

<hr>
<h2 id='stoch_vol'>Stochastic Volatility</h2><span id='topic+stoch_vol'></span>

<h3>Description</h3>

<p>Produces a draw of log-volatilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoch_vol(y, h, sigma, h_init, constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoch_vol_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">T \times 1</code> vector containing the time series.</p>
</td></tr>
<tr><td><code id="stoch_vol_+3A_h">h</code></td>
<td>
<p>a <code class="reqn">T \times 1</code> vector of log-volatilities.</p>
</td></tr>
<tr><td><code id="stoch_vol_+3A_sigma">sigma</code></td>
<td>
<p>a numeric of the variance of the log-volatilites.</p>
</td></tr>
<tr><td><code id="stoch_vol_+3A_h_init">h_init</code></td>
<td>
<p>a numeric of the initial state of log-volatilities.</p>
</td></tr>
<tr><td><code id="stoch_vol_+3A_constant">constant</code></td>
<td>
<p>a numeric of the constant that should be added to <code class="reqn">y^2</code>
before taking the natural logarithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for function <code><a href="#topic+stochvol_ksc1998">stochvol_ksc1998</a></code>.
</p>


<h3>Value</h3>

<p>A vector of log-volatility draws.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>Kim, S., Shephard, N., &amp; Chib, S. (1998). Stochastic volatility. Likelihood inference and comparison
with ARCH models. <em>Review of Economic Studies 65</em>(3), 361&ndash;393. <a href="https://doi.org/10.1111/1467-937X.00050">doi:10.1111/1467-937X.00050</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("us_macrodata")
y &lt;- matrix(us_macrodata[, "r"])

# Initialise log-volatilites
h_init &lt;- matrix(log(var(y)))
h &lt;- matrix(rep(h_init, length(y)))

# Obtain draw
stoch_vol(y - mean(y), h, matrix(.05), h_init, matrix(0.0001))

</code></pre>

<hr>
<h2 id='stochvol_ksc1998'>Stochastic Volatility</h2><span id='topic+stochvol_ksc1998'></span>

<h3>Description</h3>

<p>Produces a draw of log-volatilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochvol_ksc1998(y, h, sigma, h_init, constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stochvol_ksc1998_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">T \times K</code> matrix containing the time series.</p>
</td></tr>
<tr><td><code id="stochvol_ksc1998_+3A_h">h</code></td>
<td>
<p>a <code class="reqn">T \times K</code> vector of the current draw of log-volatilities.</p>
</td></tr>
<tr><td><code id="stochvol_ksc1998_+3A_sigma">sigma</code></td>
<td>
<p>a <code class="reqn">K \times 1</code> vector of variances of log-volatilities,
where the <code class="reqn">i</code>th element corresponds to the <code class="reqn">i</code>th column in <code>y</code>.</p>
</td></tr>
<tr><td><code id="stochvol_ksc1998_+3A_h_init">h_init</code></td>
<td>
<p>a <code class="reqn">K \times 1</code> vector of the initial states of log-volatilities,
where the <code class="reqn">i</code>th element corresponds to the <code class="reqn">i</code>th column in <code>y</code>.</p>
</td></tr>
<tr><td><code id="stochvol_ksc1998_+3A_constant">constant</code></td>
<td>
<p>a <code class="reqn">K \times 1</code> vector of constants that should be added to <code class="reqn">y^2</code>
before taking the natural logarithm. The <code class="reqn">i</code>th element corresponds to
the <code class="reqn">i</code>th column in <code>y</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each column in <code>y</code> the function produces a posterior
draw of the log-volatility <code class="reqn">h</code> for the model
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = e^{\frac{1}{2}h_t} \epsilon_{t},</code>
</p>

<p>where <code class="reqn">\epsilon_t \sim N(0, 1)</code> and <code class="reqn">h_t</code> is assumed to evolve according to a random walk
</p>
<p style="text-align: center;"><code class="reqn">h_t = h_{t - 1} + u_t,</code>
</p>

<p>with <code class="reqn">u_t \sim N(0, \sigma^2)</code>.
</p>
<p>The implementation is based on the algorithm of Kim, Shephard and Chip (1998) and performs the
following steps:
</p>

<ol>
<li><p> Perform the transformation <code class="reqn">y_t^* = ln(y_t^2 + constant)</code>.
</p>
</li>
<li><p> Obtain a sample from the seven-component normal mixture for
approximating the log-<code class="reqn">\chi_1^2</code> distribution.
</p>
</li>
<li><p> Obtain a draw of log-volatilities.
</p>
</li></ol>

<p>The implementation follows the code provided on the website to the textbook
by Chan, Koop, Poirier, and Tobias (2019).
</p>


<h3>Value</h3>

<p>A vector of log-volatility draws.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>Kim, S., Shephard, N., &amp; Chib, S. (1998). Stochastic volatility. Likelihood inference and comparison
with ARCH models. <em>Review of Economic Studies 65</em>(3), 361&ndash;393. <a href="https://doi.org/10.1111/1467-937X.00050">doi:10.1111/1467-937X.00050</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("us_macrodata")
y &lt;- matrix(us_macrodata[, "r"])

# Initialise log-volatilites
h_init &lt;- matrix(log(var(y)))
h &lt;- matrix(rep(h_init, length(y)))

# Obtain draw
stochvol_ksc1998(y - mean(y), h, matrix(.05), h_init, matrix(0.0001))

</code></pre>

<hr>
<h2 id='stochvol_ocsn2007'>Stochastic Volatility</h2><span id='topic+stochvol_ocsn2007'></span>

<h3>Description</h3>

<p>Produces a draw of log-volatilities based on Omori, Chib, Shephard and Nakajima (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochvol_ocsn2007(y, h, sigma, h_init, constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stochvol_ocsn2007_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">T \times K</code> matrix containing the time series.</p>
</td></tr>
<tr><td><code id="stochvol_ocsn2007_+3A_h">h</code></td>
<td>
<p>a <code class="reqn">T \times K</code> vector of the current draw of log-volatilities.</p>
</td></tr>
<tr><td><code id="stochvol_ocsn2007_+3A_sigma">sigma</code></td>
<td>
<p>a <code class="reqn">K \times 1</code> vector of variances of log-volatilities,
where the <code class="reqn">i</code>th element corresponds to the <code class="reqn">i</code>th column in <code>y</code>.</p>
</td></tr>
<tr><td><code id="stochvol_ocsn2007_+3A_h_init">h_init</code></td>
<td>
<p>a <code class="reqn">K \times 1</code> vector of the initial states of log-volatilities,
where the <code class="reqn">i</code>th element corresponds to the <code class="reqn">i</code>th column in <code>y</code>.</p>
</td></tr>
<tr><td><code id="stochvol_ocsn2007_+3A_constant">constant</code></td>
<td>
<p>a <code class="reqn">K \times 1</code> vector of constants that should be added to <code class="reqn">y^2</code>
before taking the natural logarithm. The <code class="reqn">i</code>th element corresponds to
the <code class="reqn">i</code>th column in <code>y</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each column in <code>y</code> the function produces a posterior
draw of the log-volatility <code class="reqn">h</code> for the model
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = e^{\frac{1}{2}h_t} \epsilon_{t},</code>
</p>

<p>where <code class="reqn">\epsilon_t \sim N(0, 1)</code> and <code class="reqn">h_t</code> is assumed to evolve according to a random walk
</p>
<p style="text-align: center;"><code class="reqn">h_t = h_{t - 1} + u_t,</code>
</p>

<p>with <code class="reqn">u_t \sim N(0, \sigma^2)</code>.
</p>
<p>The implementation follows the algorithm of Omori, Chib, Shephard and Nakajima (2007) and performs the
following steps:
</p>

<ol>
<li><p> Perform the transformation <code class="reqn">y_t^* = ln(y_t^2 + constant)</code>.
</p>
</li>
<li><p> Obtain a sample from the ten-component normal mixture for
approximating the log-<code class="reqn">\chi_1^2</code> distribution.
</p>
</li>
<li><p> Obtain a draw of log-volatilities.
</p>
</li></ol>

<p>The implementation is an adaption of the code provided on the website to the textbook
by Chan, Koop, Poirier, and Tobias (2019).
</p>


<h3>Value</h3>

<p>A vector of log-volatility draws.
</p>


<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>
<p>Omori, Y., Chib, S., Shephard, N., &amp; Nakajima, J. (2007). Stochastic volatiltiy with leverage. Fast and efficient likelihood inference.
<em>Journal of Econometrics 140</em>(2), 425&ndash;449. <a href="https://doi.org/10.1016/j.jeconom.2006.07.008">doi:10.1016/j.jeconom.2006.07.008</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("us_macrodata")
y &lt;- matrix(us_macrodata[, "r"])

# Initialise log-volatilites
h_init &lt;- matrix(log(var(y)))
h &lt;- matrix(rep(h_init, length(y)))

# Obtain draw
stochvol_ocsn2007(y - mean(y), h, matrix(.05), h_init, matrix(0.0001))

</code></pre>

<hr>
<h2 id='summary.bvar'>Summarising Bayesian VAR Coefficients</h2><span id='topic+summary.bvar'></span><span id='topic+print.summary.bvar'></span>

<h3>Description</h3>

<p>summary method for class <code>"bvar"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
summary(object, ci = 0.95, period = NULL, ...)

## S3 method for class 'summary.bvar'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bvar_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvar"</code>, usually, a result of a call to
<code><a href="#topic+bvar">bvar</a></code> or <code><a href="#topic+bvec_to_bvar">bvec_to_bvar</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bvar_+3A_ci">ci</code></td>
<td>
<p>a numeric between 0 and 1 specifying the probability of the credible band.
Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="summary.bvar_+3A_period">period</code></td>
<td>
<p>integer. Index of the period, for which the summary statistics should be generated.
Only used for TVP or SV models. Default is <code>NULL</code>, so that the posterior draws of the last time period
are used.</p>
</td></tr>
<tr><td><code id="summary.bvar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.bvar_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.bvar"</code>, usually, a result of a call to
<code><a href="#topic+summary.bvar">summary.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bvar_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.bvar</code> returns a list of class <code>"summary.bvar"</code>,
which contains the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the VAR coefficients.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the variance-covariance matrix.</p>
</td></tr>
<tr><td><code>specifications</code></td>
<td>
<p>a list containing information on the model specification.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.bvarlist'>Summarising Bayesian VAR or VEC Models</h2><span id='topic+summary.bvarlist'></span>

<h3>Description</h3>

<p>summary method for class <code>"bvarlist"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvarlist'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bvarlist_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvar"</code>, usually, a result of a call to
<code><a href="#topic+draw_posterior">draw_posterior</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bvarlist_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood for the calculation of the information criteria is obtained by
</p>
<p style="text-align: center;"><code class="reqn">LL = \frac{1}{R} \sum_{i = 1}^{R} \left( \sum_{t = 1}^{T} -\frac{K}{2} \ln 2\pi - \frac{1}{2} \ln |\Sigma_t^{(i)}| -\frac{1}{2} (u_t^{{(i)}\prime} (\Sigma_t^{(i)})^{-1} u_t^{(i)} \right)</code>
</p>
<p>,
where <code class="reqn">u_t = y_t - \mu_t</code>. The Akaike, Bayesian and Hannan–Quinn (HQ) information criteria are calculated as
</p>
<p style="text-align: center;"><code class="reqn">AIC = 2 (Kp + Ms + N) - 2 LL</code>
</p>
<p>,
</p>
<p style="text-align: center;"><code class="reqn">BIC = (Kp + Ms + N) ln(T) - 2 LL</code>
</p>
<p> and 
</p>
<p style="text-align: center;"><code class="reqn">HQ = 2  (Kp + Ms + N) ln(ln(T)) - 2 LL</code>
</p>
<p>, respectively,
where <code class="reqn">K</code> is the number of endogenous variables, <code class="reqn">p</code> the number of lags of endogenous variables,
<code class="reqn">M</code> the number of exogenous variables, <code class="reqn">s</code> the number of lags of exogenous variables,
<code class="reqn">N</code> the number of deterministic terms and <code class="reqn">T</code> the number of observations.
</p>


<h3>Value</h3>

<p><code>summary.bvarlist</code> returns a table of class <code>"summary.bvarlist"</code>.
</p>

<hr>
<h2 id='summary.bvec'>Summarising Bayesian VEC Coefficients</h2><span id='topic+summary.bvec'></span><span id='topic+print.summary.bvec'></span>

<h3>Description</h3>

<p>summary method for class <code>"bvec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvec'
summary(object, ci = 0.95, period = NULL, ...)

## S3 method for class 'summary.bvec'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bvec_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bvec"</code>, usually, a result of a call to
<code><a href="#topic+bvec">bvec</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bvec_+3A_ci">ci</code></td>
<td>
<p>a numeric between 0 and 1 specifying the probability of the credible band.
Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="summary.bvec_+3A_period">period</code></td>
<td>
<p>integer. Index of the period of a TVP VEC, for which a summary should be generated.
Only used for TVP models. Default is <code>NULL</code> so that only the most recent time period
is used.</p>
</td></tr>
<tr><td><code id="summary.bvec_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.bvec_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.bvec"</code>, usually, a result of a call to
<code><a href="#topic+summary.bvec">summary.bvec</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bvec_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.bvec</code> returns a list of class <code>"summary.bvec"</code>,
which contains the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the VAR coefficients.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the variance-covariance matrix.</p>
</td></tr>
<tr><td><code>specifications</code></td>
<td>
<p>a list containing information on the model specification.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.dfm'>Summarising Bayesian Dynamic Factor Models</h2><span id='topic+summary.dfm'></span>

<h3>Description</h3>

<p>summary method for class <code>"dfm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfm'
summary(object, ci = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dfm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dfm"</code>, usually, a result of a call to
<code><a href="#topic+dfm">dfm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.dfm_+3A_ci">ci</code></td>
<td>
<p>a numeric between 0 and 1 specifying the probability of the credible band.
Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="summary.dfm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.dfm</code> returns a list of class <code>"summary.dfm"</code>,
which contains the following components:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the factor loadings.</p>
</td></tr>
<tr><td><code>factor</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the factors.</p>
</td></tr>
<tr><td><code>sigma_u</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the variance matrix of the measurement equation.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the factor loadings.</p>
</td></tr>
<tr><td><code>sigma_v</code></td>
<td>
<p>A list of various summary statistics of the posterior
draws of the variance matrix of the transition equation.</p>
</td></tr>
<tr><td><code>specifications</code></td>
<td>
<p>a list containing information on the model specification.</p>
</td></tr>
</table>

<hr>
<h2 id='thin.bvar'>Thinning Posterior Draws</h2><span id='topic+thin.bvar'></span>

<h3>Description</h3>

<p>Thins the MCMC posterior draws in an object of class <code>"bvar"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
thin(x, thin = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin.bvar_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bvar"</code>.</p>
</td></tr>
<tr><td><code id="thin.bvar_+3A_thin">thin</code></td>
<td>
<p>an integer specifying the thinning interval between successive values of posterior draws.</p>
</td></tr>
<tr><td><code id="thin.bvar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"bvar"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Obtain data matrices
model &lt;- gen_var(e1, p = 2, deterministic = 2,
                 iterations = 100, burnin = 10)
# Chosen number of iterations and burn-in draws should be much higher.

# Add prior specifications
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

object &lt;- thin(object)

</code></pre>

<hr>
<h2 id='thin.bvarlist'>Thinning Posterior Draws</h2><span id='topic+thin.bvarlist'></span>

<h3>Description</h3>

<p>Thins the MCMC posterior draws in an object of class <code>"bvarlist"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvarlist'
thin(x, thin = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin.bvarlist_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bvarlist"</code>.</p>
</td></tr>
<tr><td><code id="thin.bvarlist_+3A_thin">thin</code></td>
<td>
<p>an integer specifying the thinning interval between successive values of posterior draws.</p>
</td></tr>
<tr><td><code id="thin.bvarlist_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"bvarlist"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e1")
e1 &lt;- diff(log(e1)) * 100

# Generate multiple model matrices
model &lt;- gen_var(e1, p = 1:2, deterministic = 2,
                 iterations = 100, burnin = 10)

# Add prior specifications
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Thin
object &lt;- thin(object)

</code></pre>

<hr>
<h2 id='thin.bvec'>Thinning Posterior Draws</h2><span id='topic+thin.bvec'></span>

<h3>Description</h3>

<p>Thins the MCMC posterior draws in an object of class <code>"bvec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvec'
thin(x, thin = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin.bvec_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bvec"</code>.</p>
</td></tr>
<tr><td><code id="thin.bvec_+3A_thin">thin</code></td>
<td>
<p>an integer specifying the thinning interval between successive values of posterior draws.</p>
</td></tr>
<tr><td><code id="thin.bvec_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"bvec"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("e6")

# Generate model data
model &lt;- gen_vec(e6, p = 2, r = 1,
                 const = "unrestricted", seasonal = "unrestricted",
                 iterations = 100, burnin = 10)

# Add prior specifications
model &lt;- add_priors(model)

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Thin
object &lt;- thin(object)

</code></pre>

<hr>
<h2 id='thin.dfm'>Thinning Posterior Draws</h2><span id='topic+thin.dfm'></span>

<h3>Description</h3>

<p>Thins the MCMC posterior draws in an object of class <code>"dfm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfm'
thin(x, thin = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin.dfm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"dfm"</code>.</p>
</td></tr>
<tr><td><code id="thin.dfm_+3A_thin">thin</code></td>
<td>
<p>an integer specifying the thinning interval between successive values of posterior draws.</p>
</td></tr>
<tr><td><code id="thin.dfm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"dfm"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("bem_dfmdata")

# Generate model data
model &lt;- gen_dfm(x = bem_dfmdata, p = 1, n = 1,
                 iterations = 20, burnin = 10)
# Number of iterations and burnin should be much higher.

# Add prior specifications
model &lt;- add_priors(model,
                    lambda = list(v_i = .01),
                    sigma_u = list(shape = 5, rate = 4),
                    a = list(v_i = .01),
                    sigma_v = list(shape = 5, rate = 4))

# Obtain posterior draws
object &lt;- draw_posterior(model)

# Plot factors
object &lt;- thin(object, thin = 2)

</code></pre>

<hr>
<h2 id='us_macrodata'>US macroeconomic data</h2><span id='topic+us_macrodata'></span>

<h3>Description</h3>

<p>The data set contains quarterly time series for the US CPI inflation rate, unemployment rate, and
Fed Funds rate from 1959Q2 to 2007Q4. It was produced from file &quot;US_macrodata.csv&quot; of the data sets associated
with Chan, Koop, Poirier and Tobias (2019). Raw data are available at
<a href="https://web.ics.purdue.edu/~jltobias/second_edition/Chapter20/code_for_exercise_1/US_macrodata.csv">https://web.ics.purdue.edu/~jltobias/second_edition/Chapter20/code_for_exercise_1/US_macrodata.csv</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("us_macrodata")
</code></pre>


<h3>Format</h3>

<p>A named time-series object with 195 rows and 3 variables:
</p>

<dl>
<dt>Dp</dt><dd><p>CPI inflation rate.</p>
</dd>
<dt>u</dt><dd><p>unemployment rate.</p>
</dd>
<dt>r</dt><dd><p>Fed Funds rate.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chan, J., Koop, G., Poirier, D. J., &amp; Tobias J. L. (2019). <em>Bayesian econometric methods</em>
(2nd ed.). Cambridge: Cambridge University Press.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
