<!DOCTYPE html><html><head><title>Help for package cleanepi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cleanepi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cleanepi-package'><p>cleanepi: Clean and Standardize Epidemiological Data</p></a></li>
<li><a href='#add_to_dictionary'><p>Add an element to the data dictionary</p></a></li>
<li><a href='#add_to_report'><p>Add an element to the report object</p></a></li>
<li><a href='#check_date_sequence'><p>Check whether the order of the sequence of date-events is valid</p></a></li>
<li><a href='#check_subject_ids'><p>Check whether the subject IDs comply with the expected format. When incorrect</p>
IDs are found, the function sends a warning and the user can call the
<code>correct_subject_ids()</code> function to correct them.</a></li>
<li><a href='#check_subject_ids_oness'><p>Checks the uniqueness in values of the sample IDs column</p></a></li>
<li><a href='#clean_data'><p>Clean and standardize data</p></a></li>
<li><a href='#clean_using_dictionary'><p>Perform dictionary-based cleaning</p></a></li>
<li><a href='#common_na_strings'><p>Common strings representing missing values</p></a></li>
<li><a href='#construct_misspelled_report'><p>Build the report for the detected misspelled values during dictionary-based</p>
data cleaning operation</a></li>
<li><a href='#convert_numeric_to_date'><p>Convert numeric to date</p></a></li>
<li><a href='#convert_to_numeric'><p>Convert columns into numeric</p></a></li>
<li><a href='#correct_subject_ids'><p>Correct the wrong subject IDs based on the user-provided values.</p></a></li>
<li><a href='#date_check_column_existence'><p>Check if date column exists in the given dataset</p></a></li>
<li><a href='#date_check_timeframe'><p>Check date time frame</p></a></li>
<li><a href='#date_choose_first_good'><p>Choose the first non-missing date from a data frame of dates</p></a></li>
<li><a href='#date_convert'><p>Convert characters to dates</p></a></li>
<li><a href='#date_convert_and_update'><p>Convert and update the date values</p></a></li>
<li><a href='#date_detect_complex_format'><p>Detect complex date format</p></a></li>
<li><a href='#date_detect_day_or_month'><p>Detect the appropriate abbreviation for day or month value</p></a></li>
<li><a href='#date_detect_format'><p>Detect a date format with only 1 separator</p></a></li>
<li><a href='#date_detect_separator'><p>Detect the special character that is the separator in the date values</p></a></li>
<li><a href='#date_detect_simple_format'><p>Get format from a simple Date value</p></a></li>
<li><a href='#date_get_format'><p>Detect date format from a date column</p></a></li>
<li><a href='#date_get_part1'><p>Get part1 of date value</p></a></li>
<li><a href='#date_get_part2'><p>Get part2 of date value</p></a></li>
<li><a href='#date_get_part3'><p>Get part3 of date value</p></a></li>
<li><a href='#date_guess'><p>Try and guess dates from a characters</p></a></li>
<li><a href='#date_guess_convert'><p>Guess if a character vector contains Date values, and convert them to date</p></a></li>
<li><a href='#date_i_extract_string'><p>Extract date from a character string</p></a></li>
<li><a href='#date_i_find_format'><p>Guess date format of a character string</p></a></li>
<li><a href='#date_make_format'><p>Build the auto-detected format</p></a></li>
<li><a href='#date_match_format_and_column'><p>Check whether the number of provided formats matches the number of target</p>
columns to be standardized.</a></li>
<li><a href='#date_process'><p>Process date variable</p></a></li>
<li><a href='#date_rescue_lubridate_failures'><p>Find the dates that lubridate couldn't</p></a></li>
<li><a href='#date_trim_outliers'><p>Trim dates outside of the defined boundaries</p></a></li>
<li><a href='#default_cleanepi_settings'><p>Set <code>clean_data()</code> default parameters</p></a></li>
<li><a href='#detect_misspelled_options'><p>Detect misspelled options in columns to be cleaned</p></a></li>
<li><a href='#detect_to_numeric_columns'><p>Detect the numeric columns that appears as characters due to the presence of</p>
some character values in the column.</a></li>
<li><a href='#dictionary_make_metadata'><p>Make data dictionary for 1 field</p></a></li>
<li><a href='#find_duplicates'><p>Identify and return duplicated rows in a data frame or linelist.</p></a></li>
<li><a href='#get_sum'><p>Get sum of numbers from a string</p></a></li>
<li><a href='#get_target_column_names'><p>Get the names of the columns from which duplicates will be found</p></a></li>
<li><a href='#is_date_sequence_ordered'><p>Check order of a sequence of date-events</p></a></li>
<li><a href='#make_readcap_dictionary'><p>Convert Redcap data dictionary into {matchmaker} dictionary format</p></a></li>
<li><a href='#numbers_only'><p>Detects whether a string contains only numbers or not.</p></a></li>
<li><a href='#print_misspelled_values'><p>Print the detected misspelled values</p></a></li>
<li><a href='#print_report'><p>Generate report from data cleaning operations</p></a></li>
<li><a href='#remove_constants'><p>Remove empty rows and columns and constant column</p></a></li>
<li><a href='#remove_duplicates'><p>Remove duplicates</p></a></li>
<li><a href='#replace_missing_values'><p>Replace missing values with <code>NA</code></p></a></li>
<li><a href='#retrieve_column_names'><p>Get column names</p></a></li>
<li><a href='#scan_columns'><p>Calculate the percentage of missing and other data type values in a vector</p>
containing different data types such as numeric, Date, character, and
logical.</a></li>
<li><a href='#scan_data'><p>Scan a data frame to determine the percentage of <code>missing</code>, <code>numeric</code>,</p>
<code>Date</code>, <code>character</code>,  and <code>logical</code> values in every column.</a></li>
<li><a href='#standardize_column_names'><p>Standardize column names of a data frame or linelist</p></a></li>
<li><a href='#standardize_dates'><p>Standardize date variables</p></a></li>
<li><a href='#timespan'><p>Calculate time span between dates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Clean and Standardize Epidemiological Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Cleaning and standardizing tabular data package, tailored
    specifically for curating epidemiological data. It streamlines various data
    cleaning tasks that are typically expected when working with datasets in
    epidemiology. It returns the processed data in the same format, ensuring
    seamless integration into existing workflows. Additionally, it generates a
    comprehensive report detailing the outcomes of each cleaning task.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://epiverse-trace.github.io/cleanepi/">https://epiverse-trace.github.io/cleanepi/</a>,
<a href="https://github.com/epiverse-trace/cleanepi">https://github.com/epiverse-trace/cleanepi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/epiverse-trace/cleanepi/issues">https://github.com/epiverse-trace/cleanepi/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>arsenal, checkmate, dplyr, janitor, linelist (&ge; 1.0.0),
lubridate, magrittr, matchmaker, numberize, readr, rlang,
snakecase, utils, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>htmlwidgets, kableExtra, knitr, lintr, markdown, reactable,
rmarkdown, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>epiverse-trace/epiversetheme</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-15 02:28:06 UTC; karimmane</td>
</tr>
<tr>
<td>Author:</td>
<td>Karim Mané <a href="https://orcid.org/0000-0002-9892-2999"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Thibaut Jombart [cph] (Thibault is the owner of the code in
    guess_dates.R file.),
  Bubacarr Bah <a href="https://orcid.org/0000-0003-3318-6668"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bankolé Ahadzie [aut],
  Nuredin Mohammed [aut],
  Abdoelnaser Degoot
    <a href="https://orcid.org/0000-0001-8788-2496"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Hugo Gruson <a href="https://orcid.org/0000-0002-4094-1476"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Pratik R. Gupte <a href="https://orcid.org/0000-0001-5294-7819"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  James M. Azam <a href="https://orcid.org/0000-0001-5782-7330"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Joshua W. Lambert <a href="https://orcid.org/0000-0001-5218-3046"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Chris Hartgerink <a href="https://orcid.org/0000-0003-1050-6809"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  London School of Hygiene and Tropical Medicine, LSHTM [cph],
  data.org [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karim Mané &lt;karim.mane@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-17 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cleanepi-package'>cleanepi: Clean and Standardize Epidemiological Data</h2><span id='topic+cleanepi'></span><span id='topic+cleanepi-package'></span>

<h3>Description</h3>

<p>Cleaning and standardizing tabular data package, tailored specifically for curating epidemiological data. It streamlines various data cleaning tasks that are typically expected when working with datasets in epidemiology. It returns the processed data in the same format, ensuring seamless integration into existing workflows. Additionally, it generates a comprehensive report detailing the outcomes of each cleaning task.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Karim Mané <a href="mailto:karim.mane@lshtm.ac.uk">karim.mane@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0002-9892-2999">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Bubacarr Bah <a href="mailto:Bubacarr.Bah1@lshtm.ac.uk">Bubacarr.Bah1@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0003-3318-6668">ORCID</a>)
</p>
</li>
<li><p> Bankolé Ahadzie <a href="mailto:Bankole.Ahadzie@lshtm.ac.uk">Bankole.Ahadzie@lshtm.ac.uk</a>
</p>
</li>
<li><p> Nuredin Mohammed <a href="mailto:Nuredin.Mohammed@lshtm.ac.uk">Nuredin.Mohammed@lshtm.ac.uk</a>
</p>
</li>
<li><p> Abdoelnaser Degoot <a href="mailto:abdoelnaser-mahmood.degoot@lshtm.ac.uk">abdoelnaser-mahmood.degoot@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-8788-2496">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a> (Thibault is the owner of the code in guess_dates.R file.) [copyright holder]
</p>
</li>
<li><p> Hugo Gruson <a href="mailto:hugo@data.org">hugo@data.org</a> (<a href="https://orcid.org/0000-0002-4094-1476">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Pratik R. Gupte <a href="mailto:pratik.gupte@lshtm.ac.uk">pratik.gupte@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5294-7819">ORCID</a>) [reviewer]
</p>
</li>
<li><p> James M. Azam <a href="mailto:james.azam@lshtm.ac.uk">james.azam@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5782-7330">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Joshua W. Lambert <a href="mailto:joshua.lambert@lshtm.ac.uk">joshua.lambert@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5218-3046">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Chris Hartgerink <a href="mailto:chris@data.org">chris@data.org</a> (<a href="https://orcid.org/0000-0003-1050-6809">ORCID</a>) [reviewer]
</p>
</li>
<li><p> London School of Hygiene and Tropical Medicine, LSHTM [copyright holder]
</p>
</li>
<li><p> data.org [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://epiverse-trace.github.io/cleanepi/">https://epiverse-trace.github.io/cleanepi/</a>
</p>
</li>
<li> <p><a href="https://github.com/epiverse-trace/cleanepi">https://github.com/epiverse-trace/cleanepi</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/epiverse-trace/cleanepi/issues">https://github.com/epiverse-trace/cleanepi/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_to_dictionary'>Add an element to the data dictionary</h2><span id='topic+add_to_dictionary'></span>

<h3>Description</h3>

<p>Add an element to the data dictionary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_to_dictionary(dictionary, option, value, grp, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_to_dictionary_+3A_dictionary">dictionary</code></td>
<td>
<p>A data frame with the data dictionary</p>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_option">option</code></td>
<td>
<p>A vector of strings with the new options that need to be added
to the dictionary.</p>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_value">value</code></td>
<td>
<p>A vector with the values to be used when replacing the new
options.</p>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_grp">grp</code></td>
<td>
<p>A vector with the name of the column that contains the option
of interest.</p>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_order">order</code></td>
<td>
<p>A numeric with the order of the new option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type data frame. This is the new data dictionary with
an additional line that contains the details about the new options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- add_to_dictionary(
  dictionary = readRDS(system.file("extdata", "test_dict.RDS",
                       package = "cleanepi")),
  option     = "ml",
  value      = "male",
  grp        = "gender",
  order      = NULL
 )
</code></pre>

<hr>
<h2 id='add_to_report'>Add an element to the report object</h2><span id='topic+add_to_report'></span>

<h3>Description</h3>

<p>Add an element to the report object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_to_report(x, key, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_to_report_+3A_x">x</code></td>
<td>
<p>A data frame  or linelist</p>
</td></tr>
<tr><td><code id="add_to_report_+3A_key">key</code></td>
<td>
<p>The name of the cleaning operation</p>
</td></tr>
<tr><td><code id="add_to_report_+3A_value">value</code></td>
<td>
<p>The object to add to the report object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input report object with an additional element
</p>


<h3>Examples</h3>

<pre><code class='language-R'># scan through the data
scan_res &lt;- scan_data(data = readRDS(system.file("extdata", "test_df.RDS",
                                                 package = "cleanepi")))

# Perform data cleaning
cleaned_data &lt;- clean_data(
  data   = readRDS(system.file("extdata", "test_df.RDS",
                               package = "cleanepi")),
  params = list(
    to_numeric = list(target_columns = "sex", lang = "en"),
    dictionary = NULL
  )
)

# add the data scanning result to the report
cleaned_data &lt;- add_to_report(x     = cleaned_data,
                              key   = "scanning_result",
                              value = scan_res)

</code></pre>

<hr>
<h2 id='check_date_sequence'>Check whether the order of the sequence of date-events is valid</h2><span id='topic+check_date_sequence'></span>

<h3>Description</h3>

<p>Checks whether a date sequence in
a vector of  specified columns is in order or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_date_sequence(data, target_columns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_date_sequence_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="check_date_sequence_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of event column names. Users should specify at
least 2 column names in the expected order. For example:
target_columns = c(&quot;date_symptoms_onset&quot;, &quot;date_hospitalization&quot;,
&quot;date_death&quot;).
When the input data is a <code>linelist</code> object, this parameter can be set to
<code>linelist_tags</code> if you wish to the date sequence across tagged columns
only.
The values in this column should be in the ISO8601 format (2024-12-31).
Otherwise, use the <code>standardize_dates()</code> function to standardize them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset. When found, the incorrect date sequences will be
stored in the report where they can be accessed using
<code>attr(data, "report")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import the data
data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))

# standardize the date values
data &lt;- data |&gt;
  standardize_dates(
    target_columns  = c("date_first_pcr_positive_test", "date.of.admission"),
    error_tolerance = 0.4,
    format          = NULL,
    timeframe       = NULL
  )

good_date_sequence &lt;- check_date_sequence(
  data           = data,
  target_columns = c("date_first_pcr_positive_test", "date.of.admission")
)
</code></pre>

<hr>
<h2 id='check_subject_ids'>Check whether the subject IDs comply with the expected format. When incorrect
IDs are found, the function sends a warning and the user can call the
<code>correct_subject_ids()</code> function to correct them.</h2><span id='topic+check_subject_ids'></span>

<h3>Description</h3>

<p>Check whether the subject IDs comply with the expected format. When incorrect
IDs are found, the function sends a warning and the user can call the
<code>correct_subject_ids()</code> function to correct them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_subject_ids(
  data,
  target_columns,
  prefix = NULL,
  suffix = NULL,
  range = NULL,
  nchar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_subject_ids_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of column names with the subject ids.</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_prefix">prefix</code></td>
<td>
<p>A prefix used in the subject IDs</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_suffix">suffix</code></td>
<td>
<p>A suffix used in the subject IDs</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_range">range</code></td>
<td>
<p>A vector with the range of numbers in the sample IDs</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_nchar">nchar</code></td>
<td>
<p>An integer that represents the expected number of characters in
the subject ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with a warning if incorrect subject ids were found
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- check_subject_ids(
  data           = readRDS(system.file("extdata", "test_df.RDS",
                                       package = "cleanepi")),
  target_columns = "study_id",
  prefix         = "PS",
  suffix         = "P2",
  range          = c(1, 100),
  nchar          = 7
)
</code></pre>

<hr>
<h2 id='check_subject_ids_oness'>Checks the uniqueness in values of the sample IDs column</h2><span id='topic+check_subject_ids_oness'></span>

<h3>Description</h3>

<p>Checks the uniqueness in values of the sample IDs column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_subject_ids_oness(data, id_col_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_subject_ids_oness_+3A_data">data</code></td>
<td>
<p>the input data frame</p>
</td></tr>
<tr><td><code id="check_subject_ids_oness_+3A_id_col_name">id_col_name</code></td>
<td>
<p>the name of the column that contains the sample IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input data frame with and extra element in its attributes when
there are missing or duplicated IDs.
</p>

<hr>
<h2 id='clean_data'>Clean and standardize data</h2><span id='topic+clean_data'></span>

<h3>Description</h3>

<p>Cleans up messy data frames by performing several operations.
These include among others: cleaning of column names, detecting and
removing duplicates, empty records and columns, constant columns,
replacing missing values by NA, converting character columns into dates
when they contain a certain number of date values, detecting subject
IDs with wrong formats, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_data(data, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_data_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist</p>
</td></tr>
<tr><td><code id="clean_data_+3A_params">params</code></td>
<td>
<p>A list of parameters that define what cleaning operations will
be applied on the input data. The default parameters are defined in
<code>cleanepi::default_cleanepi_settings()</code>. The possible values are:
</p>

<ol>
<li> <p><code>standardize_column_names</code>: A list with the arguments needed to
standardize the column names. The elements of this list will be the
input for the <code>standardize_column_names()</code> function.
</p>
</li>
<li> <p><code>replace_missing_values</code>: A list of parameters to be used when
replacing the missing values by <code>NA</code>. The elements of the list are the
inputs for the <code>replace_missing_values()</code> function.
</p>
</li>
<li> <p><code>remove_duplicates</code>: A list with the arguments that define the
columns and other parameters to be considered when looking for
duplicates. They are the input values for the <code>remove_duplicates()</code>
function.
</p>
</li>
<li> <p><code>remove_constants</code>: A list with the parameters that define whether to
remove constant data or not. The values are the input for the
<code>remove_constants()</code> function.
</p>
</li>
<li> <p><code>standardize_dates</code>: A list of parameters that will be used to
standardize the date values from the input data. They represent the
input values for the <code>standardize_dates()</code> function.
</p>
</li>
<li> <p><code>standardize_subject_ids</code>: A list of parameters that are needed to
check the IDs that comply with the expect format. These arguments are
the input values of the <code>check_subject_ids()</code>.
</p>
</li>
<li> <p><code>to_numeric</code>: a vector of column names. When provided, the values in
these columns will be converted into numeric.
</p>
</li>
<li> <p><code>dictionary</code>: A data frame that will be used to substitute the
current values in the specified columns the those in the dictionary. It
is the main argument for the <code>clean_using_dictionary()</code> function.
</p>
</li>
<li> <p><code>check_date_sequence</code>: A list of arguments to be used when
determining whether the sequence of date events is respected across all
rows of the input data. The value in this list are the input for the
<code>check_date_sequence()</code> function.
</p>
</li>
<li> <p><code>span</code>: A list with the parameters that define how the time span will
be calculated between 2 columns of between a column and a Date value.
These arguments will be used in the <code>span()</code> function.
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>The cleaned input date according to the user-specified parameters.
This is associated with a data cleaning report that can be accessed using
<code>attr(cleaned_data, "report")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parameters for column names standardization
standardize_col_names &lt;- list(keep = NULL, rename = NULL)

# parameters to remove constant columns, empty rows and columns
remove_cte &lt;- list(cutoff = 1)

# Parameters for substituting missing values with NA:
replace_missing_values &lt;- list(target_columns = NULL, na_strings = "-99")

# Parameters for duplicates removal across all columns
remove_duplicates &lt;- list(target_columns   = NULL)

# Parameters for dates standardization
standardize_dates &lt;- list(target_columns  = NULL,
                          error_tolerance = 0.4,
                          format          = NULL,
                          timeframe       = as.Date(c("1973-05-29",
                                                      "2023-05-29")),
                          orders          = list(
                            world_named_months = c("Ybd", "dby"),
                            world_digit_months = c("dmy", "Ymd"),
                            US_formats         = c("Omdy", "YOmd")
                          ),
                          modern_excel    = TRUE)

# Parameters for subject IDs standardization
standardize_subject_ids &lt;- list(target_columns = "study_id",
                                prefix         = "PS",
                                suffix         = "P2",
                                range          = c(1, 100),
                                nchar          = 7)

to_numeric &lt;- list(target_columns = "sex", lang = "en")


# dictionary = NULL the dictionary-based cleaning will not be performed here

cleaned_data &lt;- clean_data(
  data   = readRDS(system.file("extdata", "test_df.RDS",
                               package = "cleanepi")),
  params = list(
    standardize_column_names = standardize_col_names,
    remove_constants         = remove_cte,
    replace_missing_values   = replace_missing_values,
    remove_duplicates        = remove_duplicates,
    standardize_dates        = standardize_dates,
    standardize_subject_ids  = standardize_subject_ids,
    to_numeric               = to_numeric,
    dictionary               = NULL
  )
)

</code></pre>

<hr>
<h2 id='clean_using_dictionary'>Perform dictionary-based cleaning</h2><span id='topic+clean_using_dictionary'></span>

<h3>Description</h3>

<p>Perform dictionary-based cleaning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_using_dictionary(data, dictionary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_using_dictionary_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="clean_using_dictionary_+3A_dictionary">dictionary</code></td>
<td>
<p>A data dictionary associated with the input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with cleaned values in the target columns specified
in the data dictionary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data           &lt;- readRDS(system.file("extdata", "messy_data.RDS",
                                      package = "cleanepi"))
data$gender[2] &lt;- "homme"
cleaned_df     &lt;- clean_using_dictionary(
  data       = data,
  dictionary = readRDS(system.file("extdata", "test_dict.RDS",
                                   package = "cleanepi"))
)
</code></pre>

<hr>
<h2 id='common_na_strings'>Common strings representing missing values</h2><span id='topic+common_na_strings'></span>

<h3>Description</h3>

<p>This vector contains common values of NA (missing) and is intended for
use within {cleanepi} functions <code><a href="#topic+replace_missing_values">replace_missing_values()</a></code>.
The current list of strings used can be found by printing out
<code>common_na_strings</code>. It serves as a helpful tool to explore your data
for possible missing values. However, I strongly caution against using
this to replace <code>NA</code> values without meticulously examining the
incidence for each case. Please note that <code>common_na_strings</code> utilizes
<code style="white-space: pre;">&#8288;\\&#8288;</code> around the &quot;?&quot;, &quot;.&quot;, and &quot;*&quot; characters to prevent their wildcard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_na_strings
</code></pre>


<h3>Format</h3>

<p>A vector of 35 character strings.
</p>


<h3>Source</h3>

<p>This vector is a combination of <code>naniar::common_na_strings</code>
(<a href="https://github.com/njtierney/naniar/">https://github.com/njtierney/naniar/</a>) and other strings found in the
literature.
</p>

<hr>
<h2 id='construct_misspelled_report'>Build the report for the detected misspelled values during dictionary-based
data cleaning operation</h2><span id='topic+construct_misspelled_report'></span>

<h3>Description</h3>

<p>Build the report for the detected misspelled values during dictionary-based
data cleaning operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_misspelled_report(misspelled_options, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_misspelled_report_+3A_misspelled_options">misspelled_options</code></td>
<td>
<p>A list with the detected misspelled values in the
columns of interest.</p>
</td></tr>
<tr><td><code id="construct_misspelled_report_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame the details about where in the input data the
misspelled values were found.
</p>

<hr>
<h2 id='convert_numeric_to_date'>Convert numeric to date</h2><span id='topic+convert_numeric_to_date'></span>

<h3>Description</h3>

<p>Convert numeric to date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_numeric_to_date(data, target_columns, ref_date, forward = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_numeric_to_date_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist</p>
</td></tr>
<tr><td><code id="convert_numeric_to_date_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of columns names to be converted from numeric
to date. When the input data is a <code>linelist</code> object, this parameter can be
set to <code>linelist_tags</code> if you wish to only convert the tagged columns.</p>
</td></tr>
<tr><td><code id="convert_numeric_to_date_+3A_ref_date">ref_date</code></td>
<td>
<p>A reference date. This can also be a character string with
the name of the reference column.</p>
</td></tr>
<tr><td><code id="convert_numeric_to_date_+3A_forward">forward</code></td>
<td>
<p>A Boolean to indicate whether the counts started after the
reference date (TRUE) or not (FALSE). The default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where the column of interest are updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- readRDS(system.file("extdata", "test_df1.RDS", package = "cleanepi"))
data &lt;- convert_numeric_to_date(
  data           = data,
  target_columns = "recruted_on_day",
  ref_date       = as.Date("2022-10-13"),
  forward        = TRUE
)
</code></pre>

<hr>
<h2 id='convert_to_numeric'>Convert columns into numeric</h2><span id='topic+convert_to_numeric'></span>

<h3>Description</h3>

<p>When the function is invoked without specifying the column names to be
converted, it automatically scans for columns containing exclusively missing,
numeric, and character values. Furthermore, it identifies columns where the
proportion of numeric values is at least twice the percentage of character
values and performs the conversion in them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_numeric(data, target_columns = NULL, lang = c("en", "fr", "es"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_numeric_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist</p>
</td></tr>
<tr><td><code id="convert_to_numeric_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of the target column names. When the input
data is a <code>linelist</code> object, this parameter can be set to <code>linelist_tags</code>
if the tagged columns are those to be converted into numeric.</p>
</td></tr>
<tr><td><code id="convert_to_numeric_+3A_lang">lang</code></td>
<td>
<p>The text's language. Currently one of <code>"en" | "fr" | "es"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame after the conversion process, wherein all the specified
or detected columns have been transformed into numeric format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- convert_to_numeric(
  data           = readRDS(system.file("extdata", "messy_data.RDS",
                                       package = "cleanepi")),
  target_columns = "age",
  lang           = "en"
)
</code></pre>

<hr>
<h2 id='correct_subject_ids'>Correct the wrong subject IDs based on the user-provided values.</h2><span id='topic+correct_subject_ids'></span>

<h3>Description</h3>

<p>After detecting incorrect subject IDs from the <code>check_subject_ids()</code>
function, use this function to provide the correct IDs and perform the
substitution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_subject_ids(data, target_columns, correction_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_subject_ids_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist</p>
</td></tr>
<tr><td><code id="correct_subject_ids_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of column names with the subject ids.</p>
</td></tr>
<tr><td><code id="correct_subject_ids_+3A_correction_table">correction_table</code></td>
<td>
<p>A data frame with the following two columns:
</p>

<ol>
<li> <p><code>from</code>: a column with the wrong subject IDs,
</p>
</li>
<li> <p><code>to</code>: a column with the values to be used to substitute the
incorrect ids.
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset where all subject ids comply with the expected
format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># detect the incorrect subject ids
dat &lt;- check_subject_ids(
  data           = readRDS(system.file("extdata", "test_df.RDS",
                                       package = "cleanepi")),
  target_columns = "study_id",
  prefix         = "PS",
  suffix         = "P2",
  range          = c(1, 100),
  nchar          = 7
)

# generate the correction table
correction_table &lt;- data.frame(
  from = c("P0005P2", "PB500P2", "PS004P2-1"),
  to   = c("PB005P2", "PB050P2", "PS004P2")
)

# perform the correction
dat &lt;- correct_subject_ids(
  data             = dat,
  target_columns   = "study_id",
  correction_table = correction_table
)
</code></pre>

<hr>
<h2 id='date_check_column_existence'>Check if date column exists in the given dataset</h2><span id='topic+date_check_column_existence'></span>

<h3>Description</h3>

<p>Check if date column exists in the given dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_check_column_existence(data, date_column_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_check_column_existence_+3A_data">data</code></td>
<td>
<p>The input data frame</p>
</td></tr>
<tr><td><code id="date_check_column_existence_+3A_date_column_names">date_column_names</code></td>
<td>
<p>A vector with the name of the columns to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input vector if all column names are part of the input data, an
error is issued otherwise.
</p>

<hr>
<h2 id='date_check_timeframe'>Check date time frame</h2><span id='topic+date_check_timeframe'></span>

<h3>Description</h3>

<p>Check date time frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_check_timeframe(first_date, last_date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_check_timeframe_+3A_first_date">first_date</code></td>
<td>
<p>A Date object specifying the first valid date.
The arbitrary default value is fifty years before the <code>last_date</code>.</p>
</td></tr>
<tr><td><code id="date_check_timeframe_+3A_last_date">last_date</code></td>
<td>
<p>A Date object specifying the last valid date.
The defaults value is the current date.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the first and last dates
</p>

<hr>
<h2 id='date_choose_first_good'>Choose the first non-missing date from a data frame of dates</h2><span id='topic+date_choose_first_good'></span>

<h3>Description</h3>

<p>Choose the first non-missing date from a data frame of dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_choose_first_good(date_a_frame, column_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_choose_first_good_+3A_date_a_frame">date_a_frame</code></td>
<td>
<p>A data frame where each column contains a different
parsing of the same date vector</p>
</td></tr>
<tr><td><code id="date_choose_first_good_+3A_column_name">column_name</code></td>
<td>
<p>The target column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The chosen first date value
</p>

<hr>
<h2 id='date_convert'>Convert characters to dates</h2><span id='topic+date_convert'></span>

<h3>Description</h3>

<p>Convert characters to dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_convert(
  data,
  cols,
  error_tolerance,
  timeframe = NULL,
  orders,
  modern_excel
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_convert_+3A_data">data</code></td>
<td>
<p>A data frame or linelist</p>
</td></tr>
<tr><td><code id="date_convert_+3A_cols">cols</code></td>
<td>
<p>date column name(s)</p>
</td></tr>
<tr><td><code id="date_convert_+3A_error_tolerance">error_tolerance</code></td>
<td>
<p>A number between 0 and 1 indicating the proportion of
entries which cannot be identified as dates to be tolerated; if this
proportion is exceeded, the original vector is returned, and a message is
issued; defaults to 0.4 (40 percent).</p>
</td></tr>
<tr><td><code id="date_convert_+3A_timeframe">timeframe</code></td>
<td>
<p>A vector of 2 values of type date. If provided, date values
that do not fall within this timeframe will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="date_convert_+3A_orders">orders</code></td>
<td>
<p>The date codes for fine-grained parsing of dates. This allows
for parsing of mixed dates. If a list is supplied, that list will be used
for successive tries in parsing. Default orders are:
</p>
<div class="sourceCode"><pre>list(
  world_named_months = c("Ybd", "dby"),
  world_digit_months = c("dmy", "Ymd"),
  US_formats         = c("Omdy", "YOmd")
)
</pre></div></td></tr>
<tr><td><code id="date_convert_+3A_modern_excel">modern_excel</code></td>
<td>
<p>When parsing dates from excel, some dates are stored as
integers. Modern versions of Excel represent dates as the number of days
since 1900-01-01, but pre-2011 Excel for OSX have the origin set at
1904-01-01. If this parameter is <code>TRUE</code> (default), then this assumes that
all numeric values represent dates from either a Windows version of Excel
or a 2011 or later version of Excel for OSX. Set this parameter to <code>FALSE</code>
if the data came from an OSX version of Excel before 2011.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where the specified columns have been converted
into Date.
</p>

<hr>
<h2 id='date_convert_and_update'>Convert and update the date values</h2><span id='topic+date_convert_and_update'></span>

<h3>Description</h3>

<p>Convert and update the date values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_convert_and_update(
  data,
  timeframe,
  new_dates,
  cols,
  error_tolerance = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_convert_and_update_+3A_data">data</code></td>
<td>
<p>A data frame or linelist</p>
</td></tr>
<tr><td><code id="date_convert_and_update_+3A_timeframe">timeframe</code></td>
<td>
<p>A vector of 2 values of type date. If provided, date values
that do not fall within this timeframe will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="date_convert_and_update_+3A_new_dates">new_dates</code></td>
<td>
<p>A vector of the converted date values</p>
</td></tr>
<tr><td><code id="date_convert_and_update_+3A_cols">cols</code></td>
<td>
<p>The names of the date column been converted</p>
</td></tr>
<tr><td><code id="date_convert_and_update_+3A_error_tolerance">error_tolerance</code></td>
<td>
<p>A number between 0 and 1 indicating the proportion of
entries which cannot be identified as dates to be tolerated; if this
proportion is exceeded, the original vector is returned, and a message is
issued; defaults to 0.4 (40 percent).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 data frames: the updated input data (if some columns
were converted to Date) and a data frame of date values that are not
within the specified timeframe.
</p>

<hr>
<h2 id='date_detect_complex_format'>Detect complex date format</h2><span id='topic+date_detect_complex_format'></span>

<h3>Description</h3>

<p>Detect complex date format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_complex_format(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_detect_complex_format_+3A_x">x</code></td>
<td>
<p>A string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the inferred format.
</p>

<hr>
<h2 id='date_detect_day_or_month'>Detect the appropriate abbreviation for day or month value</h2><span id='topic+date_detect_day_or_month'></span>

<h3>Description</h3>

<p>Detect the appropriate abbreviation for day or month value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_day_or_month(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_detect_day_or_month_+3A_x">x</code></td>
<td>
<p>The input string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with abbreviation used to distinguish the written day or
month
</p>

<hr>
<h2 id='date_detect_format'>Detect a date format with only 1 separator</h2><span id='topic+date_detect_format'></span>

<h3>Description</h3>

<p>Detect a date format with only 1 separator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_format(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_detect_format_+3A_x">x</code></td>
<td>
<p>A string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the identified format.
</p>

<hr>
<h2 id='date_detect_separator'>Detect the special character that is the separator in the date values</h2><span id='topic+date_detect_separator'></span>

<h3>Description</h3>

<p>Detect the special character that is the separator in the date values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_separator(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_detect_separator_+3A_x">x</code></td>
<td>
<p>A string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A detected separator
</p>
<p>A vector of the identified special characters.
</p>

<hr>
<h2 id='date_detect_simple_format'>Get format from a simple Date value</h2><span id='topic+date_detect_simple_format'></span>

<h3>Description</h3>

<p>Get format from a simple Date value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_simple_format(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_detect_simple_format_+3A_x">x</code></td>
<td>
<p>A string with the date value of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the abbreviation that correspond to the Date value
</p>

<hr>
<h2 id='date_get_format'>Detect date format from a date column</h2><span id='topic+date_get_format'></span>

<h3>Description</h3>

<p>Detect date format from a date column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_format(data, date_column_name, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_get_format_+3A_data">data</code></td>
<td>
<p>A  data frame</p>
</td></tr>
<tr><td><code id="date_get_format_+3A_date_column_name">date_column_name</code></td>
<td>
<p>The name of the date columns of interest</p>
</td></tr>
<tr><td><code id="date_get_format_+3A_sep">sep</code></td>
<td>
<p>A separator in the date string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the detected date format
</p>

<hr>
<h2 id='date_get_part1'>Get part1 of date value</h2><span id='topic+date_get_part1'></span>

<h3>Description</h3>

<p>Get part1 of date value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_part1(x, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_get_part1_+3A_x">x</code></td>
<td>
<p>A string of interest</p>
</td></tr>
<tr><td><code id="date_get_part1_+3A_sep">sep</code></td>
<td>
<p>A separator in the string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the first element of the vector returned by the
<code>strsplit()</code> function.
</p>

<hr>
<h2 id='date_get_part2'>Get part2 of date value</h2><span id='topic+date_get_part2'></span>

<h3>Description</h3>

<p>Get part2 of date value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_part2(x, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_get_part2_+3A_x">x</code></td>
<td>
<p>A string of interest</p>
</td></tr>
<tr><td><code id="date_get_part2_+3A_sep">sep</code></td>
<td>
<p>A separator in the string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the second element of the vector returned by the
<code>strsplit()</code> function.
</p>

<hr>
<h2 id='date_get_part3'>Get part3 of date value</h2><span id='topic+date_get_part3'></span>

<h3>Description</h3>

<p>Get part3 of date value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_part3(x, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_get_part3_+3A_x">x</code></td>
<td>
<p>A string of interest</p>
</td></tr>
<tr><td><code id="date_get_part3_+3A_sep">sep</code></td>
<td>
<p>A separator in the string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the third element of the vector returned by the
<code>strsplit()</code> function.
</p>

<hr>
<h2 id='date_guess'>Try and guess dates from a characters</h2><span id='topic+date_guess'></span>

<h3>Description</h3>

<p>Note that THIS FEATURE IS STILL EXPERIMENTAL: we strongly recommend checking
a few converted dates manually. This function tries to extract dates from a
<code>character</code> vector or a <code>factor</code>. It treats each entry independently, using
regular expressions to detect if a date is present, its format, and if
successful it converts that entry to a standard <code>Date</code> with the <em>Ymd</em> format
(e.g. <code>2018-01-21</code>). Entries which cannot be processed result in <code>NA</code>. An
error threshold can be used to define the maximum number of resulting <code>NA</code>
(i.e. entries without an identified date) that can be tolerated. If this
threshold is exceeded, the original vector is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_guess(
  x,
  column_name,
  quiet = TRUE,
  modern_excel = TRUE,
  orders = list(world_named_months = c("Ybd", "dby"), world_digit_months = c("dmy",
    "Ymd"), US_formats = c("Omdy", "YOmd"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_guess_+3A_x">x</code></td>
<td>
<p>A <code>character</code> vector or a <code>factor</code></p>
</td></tr>
<tr><td><code id="date_guess_+3A_column_name">column_name</code></td>
<td>
<p>The target column name</p>
</td></tr>
<tr><td><code id="date_guess_+3A_quiet">quiet</code></td>
<td>
<p>A logical indicating if messages should be displayed to the
console (<code>TRUE</code>, default); set to <code>FALSE</code> to silence messages</p>
</td></tr>
<tr><td><code id="date_guess_+3A_modern_excel">modern_excel</code></td>
<td>
<p>When parsing dates from excel, some dates are stored as
integers. Modern versions of Excel represent dates as the number of days
since 1900-01-01, but pre-2011 Excel for OSX have the origin set at
1904-01-01. If this parameter is <code>TRUE</code> (default), then this assumes that
all numeric values represent dates from either a Windows version of Excel
or a 2011 or later version of Excel for OSX. Set this parameter to <code>FALSE</code>
if the data came from an OSX version of Excel before 2011.</p>
</td></tr>
<tr><td><code id="date_guess_+3A_orders">orders</code></td>
<td>
<p>The date codes for fine-grained parsing of dates. This allows
for parsing of mixed dates. If a list is supplied, that list will be used
for successive tries in parsing. Default orders are:
</p>
<div class="sourceCode"><pre>list(
  world_named_months = c("Ybd", "dby"),
  world_digit_months = c("dmy", "Ymd"),
  US_formats         = c("Omdy", "YOmd")
)
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>A list of following two elements: a vector of the newly reformatted
dates and a data frame with the date values that were converted from more
than one format. If all values comply with only one format, the later
element will be NULL.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart, Zhian N. Kamvar
</p>

<hr>
<h2 id='date_guess_convert'>Guess if a character vector contains Date values, and convert them to date</h2><span id='topic+date_guess_convert'></span>

<h3>Description</h3>

<p>Guess if a character vector contains Date values, and convert them to date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_guess_convert(data, error_tolerance, timeframe, orders, modern_excel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_guess_convert_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="date_guess_convert_+3A_error_tolerance">error_tolerance</code></td>
<td>
<p>A number between 0 and 1 indicating the proportion of
entries which cannot be identified as dates to be tolerated; if this
proportion is exceeded, the original vector is returned, and a message is
issued; defaults to 0.4 (40 percent).</p>
</td></tr>
<tr><td><code id="date_guess_convert_+3A_timeframe">timeframe</code></td>
<td>
<p>A vector of 2 values of type date. If provided, date values
that do not fall within this timeframe will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="date_guess_convert_+3A_orders">orders</code></td>
<td>
<p>The date codes for fine-grained parsing of dates. This allows
for parsing of mixed dates. If a list is supplied, that list will be used
for successive tries in parsing. Default orders are:
</p>
<div class="sourceCode"><pre>list(
  world_named_months = c("Ybd", "dby"),
  world_digit_months = c("dmy", "Ymd"),
  US_formats         = c("Omdy", "YOmd")
)
</pre></div></td></tr>
<tr><td><code id="date_guess_convert_+3A_modern_excel">modern_excel</code></td>
<td>
<p>When parsing dates from excel, some dates are stored as
integers. Modern versions of Excel represent dates as the number of days
since 1900-01-01, but pre-2011 Excel for OSX have the origin set at
1904-01-01. If this parameter is <code>TRUE</code> (default), then this assumes that
all numeric values represent dates from either a Windows version of Excel
or a 2011 or later version of Excel for OSX. Set this parameter to <code>FALSE</code>
if the data came from an OSX version of Excel before 2011.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data frame where the character columns with date values
have been converted into Date.
</p>

<hr>
<h2 id='date_i_extract_string'>Extract date from a character string</h2><span id='topic+date_i_extract_string'></span>

<h3>Description</h3>

<p>This function looks for a well-formatted date character string inside a
single character string, and returns the matching date using the <code style="white-space: pre;">&#8288;%Y-%m-%d&#8288;</code>
format (e.g. <code>2018-01-23</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_i_extract_string(x)
</code></pre>


<h3>Value</h3>

<p>Either <code>NA_character_</code> or a date, as a standardized character
string.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart
</p>

<hr>
<h2 id='date_i_find_format'>Guess date format of a character string</h2><span id='topic+date_i_find_format'></span>

<h3>Description</h3>

<p>The motivation behind this is that <code>as.Date</code> does not handle correctly its
<code>format</code> argument, e.g. <code>as.Date("01-12-2001", format = "%Y-%m-%d")</code> returns
<code>1-12-20</code>. Tries to match a single character string against regular
expressions representing potential date formats. Returns the format as
something that can be processed by <code>as.Date</code> if a match is found, and <code>NULL</code>
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_i_find_format(x)
</code></pre>


<h3>Value</h3>

<p>If no matching format can be found, the function returns NULL; if a
matching format is found, the function returned the matched regular
expression (clean date) and its format compatible with <code>as.Date</code>.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart
</p>

<hr>
<h2 id='date_make_format'>Build the auto-detected format</h2><span id='topic+date_make_format'></span>

<h3>Description</h3>

<p>Put together the different date format characters that were identified in
the target date column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_make_format(f1, f2, tmp_sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_make_format_+3A_f1">f1</code></td>
<td>
<p>The first part of the date values</p>
</td></tr>
<tr><td><code id="date_make_format_+3A_f2">f2</code></td>
<td>
<p>The second part of the date values</p>
</td></tr>
<tr><td><code id="date_make_format_+3A_tmp_sep">tmp_sep</code></td>
<td>
<p>The character string that separate the first and second parts
of the date values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string that represent the inferred format of the date
values.
</p>

<hr>
<h2 id='date_match_format_and_column'>Check whether the number of provided formats matches the number of target
columns to be standardized.</h2><span id='topic+date_match_format_and_column'></span>

<h3>Description</h3>

<p>Check whether the number of provided formats matches the number of target
columns to be standardized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_match_format_and_column(target_columns, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_match_format_and_column_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of column names to be standardized</p>
</td></tr>
<tr><td><code id="date_match_format_and_column_+3A_format">format</code></td>
<td>
<p>A vector of formats to be used when standardizing the columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of format
</p>

<hr>
<h2 id='date_process'>Process date variable</h2><span id='topic+date_process'></span>

<h3>Description</h3>

<p>Process date variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_process(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_process_+3A_x">x</code></td>
<td>
<p>A object of class Date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted input value into Date or character
</p>

<hr>
<h2 id='date_rescue_lubridate_failures'>Find the dates that lubridate couldn't</h2><span id='topic+date_rescue_lubridate_failures'></span>

<h3>Description</h3>

<p>Find the dates that lubridate couldn't
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_rescue_lubridate_failures(date_a_frame, original_dates, mxl = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_rescue_lubridate_failures_+3A_date_a_frame">date_a_frame</code></td>
<td>
<p>A data frame where each column contains a different
parsing of the same date vector</p>
</td></tr>
<tr><td><code id="date_rescue_lubridate_failures_+3A_original_dates">original_dates</code></td>
<td>
<p>The vector of original dates.</p>
</td></tr>
<tr><td><code id="date_rescue_lubridate_failures_+3A_mxl">mxl</code></td>
<td>
<p>&quot;modern excel&quot; if TRUE, then it uses 1900 as the origin, otherwise
1904 is used as the origin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data frame where the values that do not match the proposed
formats have been converted into Date.
</p>

<hr>
<h2 id='date_trim_outliers'>Trim dates outside of the defined boundaries</h2><span id='topic+date_trim_outliers'></span>

<h3>Description</h3>

<p>Trim dates outside of the defined boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_trim_outliers(new_dates, dmin, dmax, cols, original_dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_trim_outliers_+3A_new_dates">new_dates</code></td>
<td>
<p>A vector of the new date values</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_dmin">dmin</code></td>
<td>
<p>A minimum date</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_dmax">dmax</code></td>
<td>
<p>A maximum date</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_cols">cols</code></td>
<td>
<p>The name of the date column of interest</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_original_dates">original_dates</code></td>
<td>
<p>A vector of the original date values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: the update input vector where date values that
are out of the boundaries are replaced by <code>NA</code>, and a vector of the out of
boundaries values.
</p>

<hr>
<h2 id='default_cleanepi_settings'>Set <code>clean_data()</code> default parameters</h2><span id='topic+default_cleanepi_settings'></span>

<h3>Description</h3>

<p>When calling <code>clean_data()</code> function with <code>param = NULL</code>, the arguments
defined here will applied on the input data. By default, operations that
require the target columns to specified by the user will not be performed.
The default cleaning operations include: i) standardizing column names,
ii) detecting and removing duplicates, and iii) removing constant data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_cleanepi_settings()
</code></pre>


<h3>Value</h3>

<p>The list of the default cleaning parameters.
</p>

<hr>
<h2 id='detect_misspelled_options'>Detect misspelled options in columns to be cleaned</h2><span id='topic+detect_misspelled_options'></span>

<h3>Description</h3>

<p>Detect misspelled options in columns to be cleaned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_misspelled_options(data, dictionary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_misspelled_options_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="detect_misspelled_options_+3A_dictionary">dictionary</code></td>
<td>
<p>A data dictionary associated with the input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the indexes of the misspelled values in every column
that needs to be cleaned.
</p>

<hr>
<h2 id='detect_to_numeric_columns'>Detect the numeric columns that appears as characters due to the presence of
some character values in the column.</h2><span id='topic+detect_to_numeric_columns'></span>

<h3>Description</h3>

<p>Detect the numeric columns that appears as characters due to the presence of
some character values in the column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_to_numeric_columns(scan_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_to_numeric_columns_+3A_scan_res">scan_res</code></td>
<td>
<p>a data frame that corresponds to the result from the
<code>scan_data()</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of column names to be converted into numeric
</p>

<hr>
<h2 id='dictionary_make_metadata'>Make data dictionary for 1 field</h2><span id='topic+dictionary_make_metadata'></span>

<h3>Description</h3>

<p>Make data dictionary for 1 field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dictionary_make_metadata(x, field_column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dictionary_make_metadata_+3A_x">x</code></td>
<td>
<p>A vector choices from the input data</p>
</td></tr>
<tr><td><code id="dictionary_make_metadata_+3A_field_column">field_column</code></td>
<td>
<p>A character with the name of the field where the
choices are made.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the dictionary in the format that is accepted by
the {matchmaker} package.
</p>

<hr>
<h2 id='find_duplicates'>Identify and return duplicated rows in a data frame or linelist.</h2><span id='topic+find_duplicates'></span>

<h3>Description</h3>

<p>Identify and return duplicated rows in a data frame or linelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_duplicates(data, target_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_duplicates_+3A_data">data</code></td>
<td>
<p>A data frame or linelist.</p>
</td></tr>
<tr><td><code id="find_duplicates_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of columns names or indices to consider when
looking for duplicates. When the input data is a <code>linelist</code> object, this
parameter can be set to <code>tags</code>from which duplicates to be removed.
Its default value is <code>NULL</code>, which considers duplicates across all
columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or linelist of all duplicated rows with following 2
additional columns:
</p>

<ol>
<li> <p><code>row_id</code>: the indices of the duplicated rows from the input data.
Users can choose from these indices, which row they consider as
redundant in each group of duplicates.
</p>
</li>
<li> <p><code>group_id</code>: a unique identifier associated to each group of
duplicates.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>dups &lt;- find_duplicates(
  data           = readRDS(system.file("extdata", "test_linelist.RDS",
                                       package = "cleanepi")),
  target_columns = c("dt_onset", "dt_report", "sex", "outcome")
)
</code></pre>

<hr>
<h2 id='get_sum'>Get sum of numbers from a string</h2><span id='topic+get_sum'></span>

<h3>Description</h3>

<p>Get sum of numbers from a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sum_+3A_x">x</code></td>
<td>
<p>A string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric that correspond to the sum of every digit in the provided
string.
</p>

<hr>
<h2 id='get_target_column_names'>Get the names of the columns from which duplicates will be found</h2><span id='topic+get_target_column_names'></span>

<h3>Description</h3>

<p>Get the names of the columns from which duplicates will be found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target_column_names(data, target_columns, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_target_column_names_+3A_data">data</code></td>
<td>
<p>A data frame or linelist</p>
</td></tr>
<tr><td><code id="get_target_column_names_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of column names. For linelist data, this can
be 'linelist_tags'</p>
</td></tr>
<tr><td><code id="get_target_column_names_+3A_cols">cols</code></td>
<td>
<p>A vector of empty and constant columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the target column names or indexes
</p>

<hr>
<h2 id='is_date_sequence_ordered'>Check order of a sequence of date-events</h2><span id='topic+is_date_sequence_ordered'></span>

<h3>Description</h3>

<p>Check order of a sequence of date-events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_date_sequence_ordered(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_date_sequence_ordered_+3A_x">x</code></td>
<td>
<p>A vector of Date values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if elements of the vector are ordered, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='make_readcap_dictionary'>Convert Redcap data dictionary into {matchmaker} dictionary format</h2><span id='topic+make_readcap_dictionary'></span>

<h3>Description</h3>

<p>Convert Redcap data dictionary into {matchmaker} dictionary format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_readcap_dictionary(metadata, field_column, opt_column, field_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_readcap_dictionary_+3A_metadata">metadata</code></td>
<td>
<p>A data frame with the data dictionary associated to a
Redcap project</p>
</td></tr>
<tr><td><code id="make_readcap_dictionary_+3A_field_column">field_column</code></td>
<td>
<p>The name of the column, in the input dictionary, that
contains the field names in of the Redcap project data</p>
</td></tr>
<tr><td><code id="make_readcap_dictionary_+3A_opt_column">opt_column</code></td>
<td>
<p>The name of the column, in the input dictionary, that
contains the definition of the choices in every column of the Redcap
project data</p>
</td></tr>
<tr><td><code id="make_readcap_dictionary_+3A_field_type">field_type</code></td>
<td>
<p>A <code>character</code> with the name of the column that contains the
field type information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 columns. This is in the format required by the
{matchmaker} R package for dictionary-based cleaning.
</p>

<hr>
<h2 id='numbers_only'>Detects whether a string contains only numbers or not.</h2><span id='topic+numbers_only'></span>

<h3>Description</h3>

<p>Detects whether a string contains only numbers or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numbers_only(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numbers_only_+3A_x">x</code></td>
<td>
<p>A string of numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the string only contains numbers, <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='print_misspelled_values'>Print the detected misspelled values</h2><span id='topic+print_misspelled_values'></span>

<h3>Description</h3>

<p>Print the detected misspelled values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_misspelled_values(misspelled_options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_misspelled_values_+3A_misspelled_options">misspelled_options</code></td>
<td>
<p>A list with the misspelled values found in
the different columns of the input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the misspelled values from the column of interest
</p>

<hr>
<h2 id='print_report'>Generate report from data cleaning operations</h2><span id='topic+print_report'></span>

<h3>Description</h3>

<p>Generate report from data cleaning operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_report(
  data,
  report_title = "{cleanepi} data cleaning report",
  output_file_name = NULL,
  format = "html",
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_report_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>linelist</code> object returned from the
<code><a href="#topic+clean_data">clean_data()</a></code> or the main functions of each data cleaning module.</p>
</td></tr>
<tr><td><code id="print_report_+3A_report_title">report_title</code></td>
<td>
<p>The title to appear on the report</p>
</td></tr>
<tr><td><code id="print_report_+3A_output_file_name">output_file_name</code></td>
<td>
<p>A string specifying the name of the report file,
excluding any file extension. If no file name is supplied, one will be
automatically generated with the format <code>cleanepi_report_YYMMDD_HHMMSS</code>.</p>
</td></tr>
<tr><td><code id="print_report_+3A_format">format</code></td>
<td>
<p>The file format of the report. Currently only <code>"html"</code>
is supported.</p>
</td></tr>
<tr><td><code id="print_report_+3A_print">print</code></td>
<td>
<p>A logical that specifies whether to print the generated HTML
file or no.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the name and path of the saved report
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))
test_dictionary &lt;- readRDS(system.file("extdata", "test_dictionary.RDS",
                                       package = "cleanepi"))

# scan through the data
scan_res &lt;- scan_data(data)

# Perform data cleaning
cleaned_data &lt;- data |&gt;
 standardize_column_names(keep = NULL, rename = c("DOB" = "dateOfBirth")) |&gt;
 replace_missing_values(target_columns = NULL, na_strings = "-99") |&gt;
 remove_constants(cutoff = 1.0) |&gt;
 remove_duplicates(target_columns = NULL) |&gt;
 standardize_dates(target_columns  = NULL,
                   error_tolerance = 0.4,
                   format          = NULL,
                   timeframe     = as.Date(c("1973-05-29", "2023-05-29"))) |&gt;
 check_subject_ids(target_columns = "study_id",
                   prefix         = "PS",
                   suffix         = "P2",
                   range          = c(1L, 100L),
                   nchar          = 7L) |&gt;
 convert_to_numeric(target_columns = "sex", lang = "en") |&gt;
 clean_using_dictionary(dictionary = test_dictionary)

# add the data scanning result to the report
cleaned_data &lt;- add_to_report(x     = cleaned_data,
                              key   = "scanning_result",
                              value = scan_res)

# save a report in the current directory using the previously-created objects
print_report(
  data             = cleaned_data,
  report_title     = "{cleanepi} data cleaning report",
  output_file_name = NULL,
  format           = "html",
  print            = TRUE
)


</code></pre>

<hr>
<h2 id='remove_constants'>Remove empty rows and columns and constant column</h2><span id='topic+remove_constants'></span>

<h3>Description</h3>

<p>Remove empty rows and columns and constant column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_constants(data, cutoff = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_constants_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist</p>
</td></tr>
<tr><td><code id="remove_constants_+3A_cutoff">cutoff</code></td>
<td>
<p>The cut-off for empty rows and columns removal. If provided,
only rows and columns where the percent of missing data is greater than
this cut-off will removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset without the empty rows and columns and the
constant columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))

# introduce an empty column
data$empty_column &lt;- NA

# remove the constant columns, empty rows and columns
dat &lt;- remove_constants(
  data   = data,
  cutoff = 1
)

# check the report to see what has happened
report &lt;- attr(dat, "report")
summary(report)
</code></pre>

<hr>
<h2 id='remove_duplicates'>Remove duplicates</h2><span id='topic+remove_duplicates'></span>

<h3>Description</h3>

<p>When removing duplicates, users can specify a set columns to consider with
the 'target_columns' argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_duplicates(data, target_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_duplicates_+3A_data">data</code></td>
<td>
<p>A input data frame or linelist.</p>
</td></tr>
<tr><td><code id="remove_duplicates_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of column names to use when looking for
duplicates. When the input data is a <code>linelist</code> object, this
parameter can be set to <code>linelist_tags</code> if you wish to look for duplicates
on tagged columns only. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  data frame or linelist  without the duplicates values and nor
constant columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>no_dups &lt;- remove_duplicates(
  data           = readRDS(system.file("extdata", "test_linelist.RDS",
                                       package = "cleanepi")),
  target_columns = "linelist_tags"
)
</code></pre>

<hr>
<h2 id='replace_missing_values'>Replace missing values with <code>NA</code></h2><span id='topic+replace_missing_values'></span>

<h3>Description</h3>

<p>Replace missing values with <code>NA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_missing_values(
  data,
  target_columns = NULL,
  na_strings = cleanepi::common_na_strings
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_missing_values_+3A_data">data</code></td>
<td>
<p>A data frame or linelist</p>
</td></tr>
<tr><td><code id="replace_missing_values_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of column names. If provided, the substitution
of missing values will only be executed in those specified columns. When
the input data is a <code>linelist</code> object, this parameter can be set to
<code>linelist_tags</code> if you wish to replace missing values with NA on tagged
columns only.</p>
</td></tr>
<tr><td><code id="replace_missing_values_+3A_na_strings">na_strings</code></td>
<td>
<p>This is a vector of strings that represents the missing
values in the columns of interest. By default, it utilizes
<code>cleanepi::common_na_strings</code>. However, if the missing values string in
the columns of interest is not included in this predefined vector,
it can be used as the value for this argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data where missing values are replaced by <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cleaned_data &lt;- replace_missing_values(
  data           = readRDS(system.file("extdata", "test_df.RDS",
                                       package = "cleanepi")),
  target_columns = "sex",
  na_strings     = "-99"
)

</code></pre>

<hr>
<h2 id='retrieve_column_names'>Get column names</h2><span id='topic+retrieve_column_names'></span>

<h3>Description</h3>

<p>When several performing data cleaning operations using the <code>clean_data()</code>
function, the input column names might be altered by after the column names
cleaning. As a consequence of this, some cleaning operations will fail due to
the column names mismatch. This function is provided to anticipate on this
scenario, hence providing continuity between the cleaning operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve_column_names(data, target_columns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieve_column_names_+3A_data">data</code></td>
<td>
<p>the input data. It can also be a modified data generated in
intermediate cleaning operations.</p>
</td></tr>
<tr><td><code id="retrieve_column_names_+3A_target_columns">target_columns</code></td>
<td>
<p>a vector of target column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of column names to be used for the target cleaning
operations
</p>

<hr>
<h2 id='scan_columns'>Calculate the percentage of missing and other data type values in a vector
containing different data types such as numeric, Date, character, and
logical.</h2><span id='topic+scan_columns'></span>

<h3>Description</h3>

<p>Calculate the percentage of missing and other data type values in a vector
containing different data types such as numeric, Date, character, and
logical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_columns(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_columns_+3A_x">x</code></td>
<td>
<p>A vector of ones or a combination of various data types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 5 elements representing the percentage of missing,
numeric, date, character, and logical values found in the input vector.
</p>

<hr>
<h2 id='scan_data'>Scan a data frame to determine the percentage of <code>missing</code>, <code>numeric</code>,
<code>Date</code>, <code>character</code>,  and <code>logical</code> values in every column.</h2><span id='topic+scan_data'></span>

<h3>Description</h3>

<p>Scan a data frame to determine the percentage of <code>missing</code>, <code>numeric</code>,
<code>Date</code>, <code>character</code>,  and <code>logical</code> values in every column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_data(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_data_+3A_data">data</code></td>
<td>
<p>A data frame or linelist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  data frame or linelist with the same columns as the input data
and 5 rows representing the percentage of missing, numeric, date, character,
and logical values in each column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scan_result &lt;- scan_data(
  data = readRDS(system.file("extdata", "messy_data.RDS",
                             package = "cleanepi"))
)
</code></pre>

<hr>
<h2 id='standardize_column_names'>Standardize column names of a data frame or linelist</h2><span id='topic+standardize_column_names'></span>

<h3>Description</h3>

<p>All columns names will be reformatted to use the snakecase. When the
conversion to snakecase does not work as expected, use the <code>keep</code> and/or
<code>rename</code> arguments to reformat the column name properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_column_names(data, keep = NULL, rename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_column_names_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist.</p>
</td></tr>
<tr><td><code id="standardize_column_names_+3A_keep">keep</code></td>
<td>
<p>A vector of column names to maintain as they are. When dealing
with a linelist, this can be set to <code>linelist_tags</code>, to maintain the
tagged column names. The Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="standardize_column_names_+3A_rename">rename</code></td>
<td>
<p>A named vector of column names to be renamed. This should be in
the form of <code>c(new_name1 = "old_name1", new_name2 = "old_name2")</code> for
example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or linelist with easy to work with column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do not rename 'date.of.admission'
cleaned_data &lt;- standardize_column_names(
  data = readRDS(system.file("extdata", "test_df.RDS",
                             package = "cleanepi")),
  keep = "date.of.admission"
)

# do not rename 'date.of.admission', but rename 'dateOfBirth' and 'sex' to
# 'DOB' and 'gender' respectively
cleaned_data &lt;- standardize_column_names(
  data   = readRDS(system.file("extdata", "test_df.RDS",
                               package = "cleanepi")),
  keep   = "date.of.admission",
  rename = c(DOB = "dateOfBirth", gender = "sex")
)

</code></pre>

<hr>
<h2 id='standardize_dates'>Standardize date variables</h2><span id='topic+standardize_dates'></span>

<h3>Description</h3>

<p>When the format of the values in a column and/or the target columns are not
defined, we strongly recommend checking a few converted dates manually to
make sure that the dates extracted from a <code>character</code> vector or a <code>factor</code>
are correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_dates(
  data,
  target_columns = NULL,
  format = NULL,
  timeframe = NULL,
  error_tolerance = 0.5,
  orders = list(world_named_months = c("Ybd", "dby"), world_digit_months = c("dmy",
    "Ymd"), US_formats = c("Omdy", "YOmd")),
  modern_excel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_dates_+3A_data">data</code></td>
<td>
<p>A data frame or linelist</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_target_columns">target_columns</code></td>
<td>
<p>A vector of the target date column names. When the
input data is a <code>linelist</code> object, this parameter can be set to
<code>linelist_tags</code> if you wish to standardize the date columns across tagged
columns only.</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_format">format</code></td>
<td>
<p>A format of the date values in the date columns</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_timeframe">timeframe</code></td>
<td>
<p>A vector of 2 values of type date. If provided, date values
that do not fall within this timeframe will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_error_tolerance">error_tolerance</code></td>
<td>
<p>A number between 0 and 1 indicating the proportion of
entries which cannot be identified as dates to be tolerated; if this
proportion is exceeded, the original vector is returned, and a message is
issued; defaults to 0.4 (40 percent).</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_orders">orders</code></td>
<td>
<p>The date codes for fine-grained parsing of dates. This allows
for parsing of mixed dates. If a list is supplied, that list will be used
for successive tries in parsing. Default orders are:
</p>
<div class="sourceCode"><pre>list(
  world_named_months = c("Ybd", "dby"),
  world_digit_months = c("dmy", "Ymd"),
  US_formats         = c("Omdy", "YOmd")
)
</pre></div></td></tr>
<tr><td><code id="standardize_dates_+3A_modern_excel">modern_excel</code></td>
<td>
<p>When parsing dates from excel, some dates are stored as
integers. Modern versions of Excel represent dates as the number of days
since 1900-01-01, but pre-2011 Excel for OSX have the origin set at
1904-01-01. If this parameter is <code>TRUE</code> (default), then this assumes that
all numeric values represent dates from either a Windows version of Excel
or a 2011 or later version of Excel for OSX. Set this parameter to <code>FALSE</code>
if the data came from an OSX version of Excel before 2011.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converting ambiguous character strings to dates is difficult for
many reasons:
</p>

<ul>
<li><p> dates may not use the standard Ymd format
</p>
</li>
<li><p> within the same variable, dates may follow different formats
</p>
</li>
<li><p> dates may be mixed with things that are not dates
</p>
</li>
<li><p> the behavior of <code>as.Date</code> in the presence of non-date is hard to predict,
sometimes returning <code>NA</code>, sometimes issuing an error.
</p>
</li></ul>

<p>This function tries to address all the above issues. Dates with the following
format should be automatically detected, irrespective of separators
(e.g. &quot;-&quot;, &quot; &quot;, &quot;/&quot;) and surrounding text:
</p>

<ul>
<li><p> &quot;19 09 2018&quot;
</p>
</li>
<li><p> &quot;2018 09 19&quot;
</p>
</li>
<li><p> &quot;19 Sep 2018&quot;
</p>
</li>
<li><p> &quot;2018 Sep 19&quot;
</p>
</li>
<li><p> &quot;Sep 19 2018&quot;
</p>
</li></ul>



<h4>How it works</h4>

<p>This function relies heavily on <code><a href="lubridate.html#topic+parse_date_time">lubridate::parse_date_time()</a></code>, which is an
extremely flexible date parser that works well for consistent date formats,
but can quickly become unwieldy and may produce spurious results.
<code>standardize_dates()</code> will use a list of formats in the <code>orders</code> argument to
run <code>parse_date_time()</code> with each format vector separately and take the first
correctly parsed date from all the trials.
</p>
<p>With the default orders shown above, the dates 03 Jan 2018, 07/03/1982, and
08/20/85 are correctly interpreted as 2018-01-03, 1982-03-07, and 1985-08-20.
The examples section will show how you can manipulate the <code>orders</code> to be
customized for your situation.
</p>



<h3>Value</h3>

<p>The input dataset where the date columns have been standardized. The
date values that are out of the specified timeframe will be reported in
the report. Similarly, date values that comply with multiple formats will
also be featured in the report object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("03 Jan 2018", "07/03/1982", "08/20/85")
# The below will coerce values where the month is written in letters only
# into Date.
as.Date(lubridate::parse_date_time(x, orders = c("Ybd", "dby")))

# coerce values where the month is written in letters or numbers into Date.
as.Date(lubridate::parse_date_time(x, orders = c("dmy", "Ymd")))

# How to use standardize_dates()
dat &lt;- standardize_dates(
  data            = readRDS(system.file("extdata", "test_df.RDS",
                                        package = "cleanepi")),
  target_columns  = "date_first_pcr_positive_test",
  format          = NULL,
  timeframe       = NULL,
  error_tolerance = 0.4,
  orders          = list(world_named_months = c("Ybd", "dby"),
                         world_digit_months = c("dmy", "Ymd"),
                         US_formats         = c("Omdy", "YOmd")),
  modern_excel    = TRUE
)
</code></pre>

<hr>
<h2 id='timespan'>Calculate time span between dates</h2><span id='topic+timespan'></span>

<h3>Description</h3>

<p>Calculate time span between dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timespan(
  data,
  target_column = NULL,
  end_date = Sys.Date(),
  span_unit = c("years", "months", "weeks", "days"),
  span_column_name = "span",
  span_remainder_unit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timespan_+3A_data">data</code></td>
<td>
<p>The input data frame or linelist</p>
</td></tr>
<tr><td><code id="timespan_+3A_target_column">target_column</code></td>
<td>
<p>A string used to specify the name of the date column of
interest. The values in this column should be of type 'Date' in ISO
format (&quot;2024-01-31&quot;).</p>
</td></tr>
<tr><td><code id="timespan_+3A_end_date">end_date</code></td>
<td>
<p>An end date. It can be either a character that is the name of
another column of type 'Date' from the input data or a vector of Dates or
a single Date value. This should also be in the ISO format (&quot;2024-01-31&quot;).
Default is today's date <code>Sys.Date()</code>.</p>
</td></tr>
<tr><td><code id="timespan_+3A_span_unit">span_unit</code></td>
<td>
<p>A string that specifies the units in which the time span
between the dates will be returned. The possible units are: 'years',
'months', 'weeks' or 'days'.</p>
</td></tr>
<tr><td><code id="timespan_+3A_span_column_name">span_column_name</code></td>
<td>
<p>A string for the name of the new column to be used to
store the calculated time span in the input data frame.</p>
</td></tr>
<tr><td><code id="timespan_+3A_span_remainder_unit">span_remainder_unit</code></td>
<td>
<p>A string for the unit in which the remainder of
the time span should be calculated. May be one of &quot;months&quot;, &quot;weeks&quot;,
and &quot;days&quot;. Remainders requested in the same unit as the age will return
values of 0. Default is NULL for decimal time span.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data frame with one or two additional columns:
</p>

<ol>
<li><p> &quot;span&quot; or any other name chosen by the user. This will contain the
calculated time span in the desired units.
</p>
</li>
<li><p> &quot;<em>_remainder&quot;: a column with the number of the remaining
days or weeks or months depending on the value of the
'span_remainder_unit' parameter. Here '</em>' represents the value of the
'span_column_name' argument.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># In the below example, this function is used to calculate patient's age from
# their dates of birth

# import the data, replace missing values with NA and convert date into ISO
# format
data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))
data &lt;- data |&gt;
  replace_missing_values(target_columns = "dateOfBirth",
                         na_strings     = "-99") |&gt;
  standardize_dates(target_columns  = "dateOfBirth",
                    error_tolerance = 0.0)

# calculate the age in 'years' and return the remainder in 'months'
age &lt;- timespan(
  data                = data,
  target_column       = "dateOfBirth",
  end_date            = Sys.Date(),
  span_unit           = "years",
  span_column_name    = "age_in_years",
  span_remainder_unit = "months"
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
