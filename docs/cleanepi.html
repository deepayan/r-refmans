<!DOCTYPE html><html lang="en-US"><head><title>Help for package cleanepi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cleanepi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cleanepi-package'><p>cleanepi: Clean and Standardize Epidemiological Data</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_to_dictionary'><p>Add an element to the data dictionary</p></a></li>
<li><a href='#add_to_report'><p>Add an element to the report object</p></a></li>
<li><a href='#check_date_sequence'><p>Checks whether the order in a sequence of date events is chronological.</p>
order.</a></li>
<li><a href='#check_subject_ids'><p>Check whether the subject IDs comply with the expected format. When incorrect</p>
IDs are found, the function sends a warning and the user can call the
<code>correct_subject_ids</code> function to correct them.</a></li>
<li><a href='#check_subject_ids_oness'><p>Checks the uniqueness in values of the sample IDs column</p></a></li>
<li><a href='#clean_data'><p>Clean and standardize data</p></a></li>
<li><a href='#clean_using_dictionary'><p>Perform dictionary-based cleaning</p></a></li>
<li><a href='#common_na_strings'><p>Common strings representing missing values</p></a></li>
<li><a href='#construct_misspelled_report'><p>Build the report for the detected misspelled values during dictionary-based</p>
data cleaning operation</a></li>
<li><a href='#convert_numeric_to_date'><p>Convert numeric to date</p></a></li>
<li><a href='#convert_to_numeric'><p>Convert columns into numeric</p></a></li>
<li><a href='#correct_subject_ids'><p>Correct the wrong subject IDs based on the user-provided values.</p></a></li>
<li><a href='#date_check_outsiders'><p>Convert and update  date values</p></a></li>
<li><a href='#date_check_timeframe'><p>Check date time frame</p></a></li>
<li><a href='#date_choose_first_good'><p>Choose the first non-missing date from a data frame of dates</p></a></li>
<li><a href='#date_convert'><p>Convert characters to dates</p></a></li>
<li><a href='#date_detect_complex_format'><p>Detect complex date format</p></a></li>
<li><a href='#date_detect_day_or_month'><p>Detect the appropriate abbreviation for day or month value</p></a></li>
<li><a href='#date_detect_format'><p>Detect a date format with only 1 separator</p></a></li>
<li><a href='#date_detect_separator'><p>Detect the special character that is the separator in the date values</p></a></li>
<li><a href='#date_detect_simple_format'><p>Get format from a simple Date value</p></a></li>
<li><a href='#date_get_format'><p>Infer date format from a vector or characters</p></a></li>
<li><a href='#date_get_part1'><p>Split a string based on a pattern and return the first element of the</p>
resulting vector.</a></li>
<li><a href='#date_get_part2'><p>Get part2 of date value</p></a></li>
<li><a href='#date_get_part3'><p>Get part3 of date value</p></a></li>
<li><a href='#date_guess'><p>Try and guess dates from a characters</p></a></li>
<li><a href='#date_guess_convert'><p>Guess if a character vector contains Date values, and convert them to date</p></a></li>
<li><a href='#date_i_guess_and_convert'><p>Extract date from a character vector</p></a></li>
<li><a href='#date_make_format'><p>Build the auto-detected format</p></a></li>
<li><a href='#date_match_format_and_column'><p>Check whether the number of provided formats matches the number of target</p>
columns to be standardized.</a></li>
<li><a href='#date_process'><p>Process date variable</p></a></li>
<li><a href='#date_rescue_lubridate_failures'><p>Find the dates that lubridate couldn't</p></a></li>
<li><a href='#date_trim_outliers'><p>Trim dates outside of the defined timeframe</p></a></li>
<li><a href='#detect_misspelled_options'><p>Detect misspelled options in columns to be cleaned</p></a></li>
<li><a href='#detect_to_numeric_columns'><p>Detect the numeric columns that appears as characters due to the presence of</p>
some character values in the column.</a></li>
<li><a href='#dictionary_make_metadata'><p>Make data dictionary for 1 field</p></a></li>
<li><a href='#find_duplicates'><p>Identify and return duplicated rows in a data frame or linelist.</p></a></li>
<li><a href='#get_default_params'><p>Set and return <code>clean_data</code> default parameters</p></a></li>
<li><a href='#get_target_column_names'><p>Get the names of the columns from which duplicates will be found</p></a></li>
<li><a href='#is_date_sequence_ordered'><p>Check order of a sequence of date-events</p></a></li>
<li><a href='#make_unique_column_names'><p>Make column names unique when duplicated column names are found after the</p>
transformation</a></li>
<li><a href='#modify_default_params'><p>Update <code>clean_data</code> default argument's values with the</p>
user-provided values.</a></li>
<li><a href='#numbers_only'><p>Detects whether a string contains only numbers or not.</p></a></li>
<li><a href='#perform_remove_constants'><p>Remove constant data.</p></a></li>
<li><a href='#print_misspelled_values'><p>Print the detected misspelled values</p></a></li>
<li><a href='#print_report'><p>Generate report from data cleaning operations</p></a></li>
<li><a href='#remove_constants'><p>Remove constant data, including empty rows, empty columns, and</p>
columns with constant values.</a></li>
<li><a href='#remove_duplicates'><p>Remove duplicates</p></a></li>
<li><a href='#replace_missing_values'><p>Replace missing values with <code>NA</code></p></a></li>
<li><a href='#replace_with_na'><p>Detect and replace values with <code>NA</code> from a vector</p></a></li>
<li><a href='#retrieve_column_names'><p>Get column names</p></a></li>
<li><a href='#scan_data'><p>Scan through a data frame and return the proportion of <code>missing</code>, <code>numeric</code>,</p>
<code>Date</code>, <code>character</code>, <code>logical</code> values.</a></li>
<li><a href='#scan_in_character'><p>Scan through a character column</p></a></li>
<li><a href='#standardize_column_names'><p>Standardize column names of a data frame or line list</p></a></li>
<li><a href='#standardize_dates'><p>Standardize date variables</p></a></li>
<li><a href='#timespan'><p>Calculate time span between dates</p></a></li>
<li><a href='#tr_'><p>Flag out what message will be translated using the <span class="pkg">potools</span> package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Clean and Standardize Epidemiological Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Cleaning and standardizing tabular data package, tailored
    specifically for curating epidemiological data. It streamlines various
    data cleaning tasks that are typically expected when working with
    datasets in epidemiology. It returns the processed data in the same
    format, and generates a comprehensive report detailing the outcomes of
    each cleaning task.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://epiverse-trace.github.io/cleanepi/">https://epiverse-trace.github.io/cleanepi/</a>,
<a href="https://github.com/epiverse-trace/cleanepi">https://github.com/epiverse-trace/cleanepi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/epiverse-trace/cleanepi/issues">https://github.com/epiverse-trace/cleanepi/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, cli, dplyr, janitor, linelist (&ge; 1.0.0),
lubridate, magrittr, matchmaker, numberize, readr, rlang,
tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>htmlwidgets, kableExtra, knitr, lintr, markdown, naniar,
reactable, rmarkdown, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>epiverse-trace/epiversetheme</td>
</tr>
<tr>
<td>Config/potools/style:</td>
<td>explicit</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-04 09:56:22 UTC; hugo</td>
</tr>
<tr>
<td>Author:</td>
<td>Karim Mané <a href="https://orcid.org/0000-0002-9892-2999"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Thibaut Jombart [ctb] (Thibault contributed in development of
    date_guess().),
  Abdoelnaser Degoot
    <a href="https://orcid.org/0000-0001-8788-2496"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bankolé Ahadzie [aut],
  Nuredin Mohammed [aut],
  Bubacarr Bah <a href="https://orcid.org/0000-0003-3318-6668"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Hugo Gruson <a href="https://orcid.org/0000-0002-4094-1476"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb,
    rev],
  Pratik R. Gupte <a href="https://orcid.org/0000-0001-5294-7819"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  James M. Azam <a href="https://orcid.org/0000-0001-5782-7330"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Joshua W. Lambert <a href="https://orcid.org/0000-0001-5218-3046"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Chris Hartgerink <a href="https://orcid.org/0000-0003-1050-6809"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Andree Valle-Campos
    <a href="https://orcid.org/0000-0002-7779-481X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev, ctb],
  London School of Hygiene and Tropical Medicine, LSHTM
    <a href="https://ror.org/00a0jsq62"><img alt="ROR ID"  src="https://cloud.R-project.org/web/ror.svg" style="width:20px; height:20px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cph],
  data.org [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karim Mané &lt;karim.mane@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-04 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cleanepi-package'>cleanepi: Clean and Standardize Epidemiological Data</h2><span id='topic+cleanepi'></span><span id='topic+cleanepi-package'></span>

<h3>Description</h3>

<p>Cleaning and standardizing tabular data package, tailored specifically for curating epidemiological data. It streamlines various data cleaning tasks that are typically expected when working with datasets in epidemiology. It returns the processed data in the same format, and generates a comprehensive report detailing the outcomes of each cleaning task.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Karim Mané <a href="mailto:karim.mane@lshtm.ac.uk">karim.mane@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0002-9892-2999">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Abdoelnaser Degoot <a href="mailto:abdoelnaser-mahmood.degoot@lshtm.ac.uk">abdoelnaser-mahmood.degoot@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-8788-2496">ORCID</a>)
</p>
</li>
<li><p> Bankolé Ahadzie <a href="mailto:Bankole.Ahadzie@lshtm.ac.uk">Bankole.Ahadzie@lshtm.ac.uk</a>
</p>
</li>
<li><p> Nuredin Mohammed <a href="mailto:Nuredin.Mohammed@lshtm.ac.uk">Nuredin.Mohammed@lshtm.ac.uk</a>
</p>
</li>
<li><p> Bubacarr Bah <a href="mailto:Bubacarr.Bah1@lshtm.ac.uk">Bubacarr.Bah1@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0003-3318-6668">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a> (Thibault contributed in development of date_guess().) [contributor]
</p>
</li>
<li><p> Hugo Gruson <a href="mailto:hugo@data.org">hugo@data.org</a> (<a href="https://orcid.org/0000-0002-4094-1476">ORCID</a>) [contributor, reviewer]
</p>
</li>
<li><p> Pratik R. Gupte <a href="mailto:pratik.gupte@lshtm.ac.uk">pratik.gupte@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5294-7819">ORCID</a>) [reviewer]
</p>
</li>
<li><p> James M. Azam <a href="mailto:james.azam@lshtm.ac.uk">james.azam@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5782-7330">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Joshua W. Lambert <a href="mailto:joshua.lambert@lshtm.ac.uk">joshua.lambert@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5218-3046">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Chris Hartgerink <a href="mailto:chris@data.org">chris@data.org</a> (<a href="https://orcid.org/0000-0003-1050-6809">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Andree Valle-Campos <a href="mailto:avallecam@gmail.com">avallecam@gmail.com</a> (<a href="https://orcid.org/0000-0002-7779-481X">ORCID</a>) [reviewer, contributor]
</p>
</li>
<li><p> London School of Hygiene and Tropical Medicine, LSHTM (00a0jsq62) [copyright holder]
</p>
</li>
<li><p> data.org [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://epiverse-trace.github.io/cleanepi/">https://epiverse-trace.github.io/cleanepi/</a>
</p>
</li>
<li> <p><a href="https://github.com/epiverse-trace/cleanepi">https://github.com/epiverse-trace/cleanepi</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/epiverse-trace/cleanepi/issues">https://github.com/epiverse-trace/cleanepi/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_to_dictionary'>Add an element to the data dictionary</h2><span id='topic+add_to_dictionary'></span>

<h3>Description</h3>

<p>Add an element to the data dictionary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_to_dictionary(dictionary, option, value, grp, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_to_dictionary_+3A_dictionary">dictionary</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> with the dictionary associated with
the input data. This is expected to be compatible with the
<span class="pkg">matchmaker</span> package and must contain the following four columns:
</p>

<dl>
<dt><code>options</code></dt><dd><p>This column contains the current values used to
represent the different groups in the input data frame (required).</p>
</dd>
<dt><code>values</code></dt><dd><p>The values that will be used to replace the current
options (required).</p>
</dd>
<dt><code>grp</code></dt><dd><p>The name of the columns where every option belongs to
(required).</p>
</dd>
<dt><code>orders</code></dt><dd><p>This defines the user-defined order of different options
(optional).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_option">option</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of characters with the new options that need
to be added to the dictionary.</p>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_value">value</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of characters with the values to be used when
replacing the new options.</p>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_grp">grp</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of characters with the name of the column that
contains the option of interest.</p>
</td></tr>
<tr><td><code id="add_to_dictionary_+3A_order">order</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of numeric values with the order of the new
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code>. This is the new data dictionary with
an additional line that contains the details about the new options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- add_to_dictionary(
  dictionary = readRDS(
    system.file("extdata", "test_dict.RDS", package = "cleanepi")
  ),
  option = "ml",
  value = "male",
  grp = "gender",
  order = NULL
 )
</code></pre>

<hr>
<h2 id='add_to_report'>Add an element to the report object</h2><span id='topic+add_to_report'></span>

<h3>Description</h3>

<p>Add an element to the report object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_to_report(x, key, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_to_report_+3A_x">x</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="add_to_report_+3A_key">key</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the name of the cleaning operation</p>
</td></tr>
<tr><td><code id="add_to_report_+3A_value">value</code></td>
<td>
<p>The object to add to the report object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> with an
additional element to the report.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># scan through the data
scan_res &lt;- scan_data(
  data = readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))
)

# Perform data cleaning
cleaned_data &lt;- clean_data(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  to_numeric = list(target_columns = "sex", lang = "en"),
  dictionary = NULL
)

# add the data scanning result to the report
cleaned_data &lt;- add_to_report(
  x = cleaned_data,
  key = "scanning_result",
  value = scan_res
)

</code></pre>

<hr>
<h2 id='check_date_sequence'>Checks whether the order in a sequence of date events is chronological.
order.</h2><span id='topic+check_date_sequence'></span>

<h3>Description</h3>

<p>Checks whether a date sequence in a vector of specified columns
is in chronological order or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_date_sequence(data, target_columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_date_sequence_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="check_date_sequence_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names for events. Users
should specify at least 2 column names in the expected order. For example:
<code>target_columns = c("date_symptoms_onset", "date_hospitalization",
   "date_death")</code>.
When the input data is a <code>&lt;linelist&gt;</code> object, this parameter can be
set to <code>linelist_tags</code> to apply the date sequence checking
exclusively to the tagged columns.
The date values in the target columns should be in the ISO8601 format,
e.g., 2024-12-31. Otherwise, use the <code>standardize_dates()</code> function
to standardize the target columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset. When found, the incorrect date sequences will be
stored in the report and can be accessed using
<code>attr(data, "report")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import the data
data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))

# standardize the date values
data &lt;- data %&gt;%
  standardize_dates(
    target_columns  = c("date_first_pcr_positive_test", "date.of.admission"),
    error_tolerance = 0.4,
    format = NULL,
    timeframe = NULL
  )

# check the date sequence in two columns
good_date_sequence &lt;- check_date_sequence(
  data = data,
  target_columns = c("date_first_pcr_positive_test", "date.of.admission")
)
</code></pre>

<hr>
<h2 id='check_subject_ids'>Check whether the subject IDs comply with the expected format. When incorrect
IDs are found, the function sends a warning and the user can call the
<code><a href="#topic+correct_subject_ids">correct_subject_ids</a></code> function to correct them.</h2><span id='topic+check_subject_ids'></span>

<h3>Description</h3>

<p>Check whether the subject IDs comply with the expected format. When incorrect
IDs are found, the function sends a warning and the user can call the
<code><a href="#topic+correct_subject_ids">correct_subject_ids</a></code> function to correct them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_subject_ids(
  data,
  target_columns,
  prefix = NULL,
  suffix = NULL,
  range = NULL,
  nchar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_subject_ids_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names with the subject ids.</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_prefix">prefix</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the expected prefix used in the
subject IDs</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_suffix">suffix</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the expected suffix used in the
subject IDs</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_range">range</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> with the expected range of numbers in the
subject IDs</p>
</td></tr>
<tr><td><code id="check_subject_ids_+3A_nchar">nchar</code></td>
<td>
<p>An <code>&lt;integer&gt;</code> that represents the expected number of
characters in the subject ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with a warning if incorrect subject ids were found
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- check_subject_ids(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  target_columns = "study_id",
  prefix = "PS",
  suffix = "P2",
  range = c(1, 100),
  nchar = 7
)
</code></pre>

<hr>
<h2 id='check_subject_ids_oness'>Checks the uniqueness in values of the sample IDs column</h2><span id='topic+check_subject_ids_oness'></span>

<h3>Description</h3>

<p>Checks the uniqueness in values of the sample IDs column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_subject_ids_oness(data, id_col_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_subject_ids_oness_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="check_subject_ids_oness_+3A_id_col_name">id_col_name</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the name of the column that
contains the sample IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input <code>&lt;data.frame&gt;</code> with and extra element in its
attributes when there are missing or duplicated IDs.
</p>

<hr>
<h2 id='clean_data'>Clean and standardize data</h2><span id='topic+clean_data'></span>

<h3>Description</h3>

<p>Cleans up messy data frames by performing several operations.
These include among others: cleaning of column names, detecting and
removing duplicates, empty records and columns, constant columns,
replacing missing values by NA, converting character columns into dates
when they contain a certain number of date values, detecting subject
IDs with wrong formats, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_data(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_data_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="clean_data_+3A_...">...</code></td>
<td>
<p>A <code>&lt;list&gt;</code> of cleaning operations to be applied on the input
data. The acceptable arguments for <code>...</code> are:
</p>

<dl>
<dt><code>standardize_column_names</code></dt><dd><p>A <code>&lt;list&gt;</code> with the arguments needed
to standardize the column names. The elements of this list are the
input for the <code><a href="#topic+standardize_column_names">standardize_column_names</a></code> function.</p>
</dd>
<dt><code>replace_missing_values</code></dt><dd><p>A <code>&lt;list&gt;</code> of parameters to be used
when replacing the missing values by <code>NA</code>. The elements of the list are
the inputs for the <code><a href="#topic+replace_missing_values">replace_missing_values</a></code> function.</p>
</dd>
<dt><code>remove_duplicates</code></dt><dd><p>A <code>&lt;list&gt;</code> with the arguments that define
the columns and other parameters to be considered when looking for
duplicates. They are the input values for the
<code><a href="#topic+remove_duplicates">remove_duplicates</a></code> function.</p>
</dd>
<dt><code>remove_constants</code></dt><dd><p>A <code>&lt;list&gt;</code> with the parameters that define
whether to remove constant data or not. The values are the input for the
<code><a href="#topic+remove_constants">remove_constants</a></code> function.</p>
</dd>
<dt><code>standardize_dates</code></dt><dd><p>A <code>&lt;list&gt;</code> of parameters that will be used
to standardize the date values from the input data. They represent the
input values for the <code><a href="#topic+standardize_dates">standardize_dates</a></code> function.</p>
</dd>
<dt><code>standardize_subject_ids</code></dt><dd><p>A <code>&lt;list&gt;</code> of parameters that are
needed to check the IDs that comply with the expect format. These
arguments are the input values of the <code><a href="#topic+check_subject_ids">check_subject_ids</a></code>.</p>
</dd>
<dt><code>to_numeric</code></dt><dd><p>A <code>&lt;list&gt;</code> with the parameters needed to convert
the specified columns into numeric. When provided, the parameters will
be the input values for the <code><a href="#topic+convert_to_numeric">convert_to_numeric</a></code>.</p>
</dd>
<dt><code>dictionary</code></dt><dd><p>A <code>&lt;data.frame&gt;</code> that will be used to substitute
the current values in the specified columns the those in the dictionary.
It is the main argument for the <code><a href="#topic+clean_using_dictionary">clean_using_dictionary</a></code>
function.</p>
</dd>
<dt><code>check_date_sequence</code></dt><dd><p>A <code>&lt;list&gt;</code> of arguments to be used when
determining whether the sequence of date events is respected across all
rows of the input data. The value in this list are the input for the
<code><a href="#topic+check_date_sequence">check_date_sequence</a></code> function.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The cleaned input data according to the user-specified parameters.
This is associated with a data cleaning report that can be accessed using
<code>attr(cleaned_data, "report")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parameters for column names standardization
standardize_column_names &lt;- list(keep = NULL, rename = NULL)

# parameters to remove constant columns, empty rows and columns
remove_constants &lt;- list(cutoff = 1)

# Parameters for substituting missing values with NA:
replace_missing_values &lt;- list(target_columns = NULL, na_strings = "-99")

# Parameters for duplicates removal across all columns
remove_duplicates &lt;- list(target_columns   = NULL)

# Parameters for dates standardization
standardize_dates &lt;- list(
  target_columns = NULL,
  error_tolerance = 0.4,
  format = NULL,
  timeframe = as.Date(c("1973-05-29", "2023-05-29")),
  orders = list(
    world_named_months = c("Ybd", "dby"),
    world_digit_months = c("dmy", "Ymd"),
    US_formats = c("Omdy", "YOmd")
  )
)

# Parameters for subject IDs standardization
standardize_subject_ids &lt;- list(
  target_columns = "study_id",
  prefix = "PS",
  suffix = "P2",
  range = c(1, 100),
  nchar = 7
)

# convert the 'sex' column into numeric
to_numeric &lt;- list(target_columns = "sex", lang = "en")

# the dictionary-based cleaning will not be performed here
dictionary = NULL

# no need to check for the sequence of date events
check_date_sequence &lt;- NULL

cleaned_data &lt;- clean_data(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  standardize_column_names = standardize_column_names,
  remove_constants = remove_constants,
  replace_missing_values = replace_missing_values,
  remove_duplicates = remove_duplicates,
  standardize_dates = standardize_dates,
  standardize_subject_ids = standardize_subject_ids,
  to_numeric = to_numeric,
  dictionary = NULL,
  check_date_sequence = NULL
)

</code></pre>

<hr>
<h2 id='clean_using_dictionary'>Perform dictionary-based cleaning</h2><span id='topic+clean_using_dictionary'></span>

<h3>Description</h3>

<p>Perform dictionary-based cleaning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_using_dictionary(data, dictionary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_using_dictionary_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="clean_using_dictionary_+3A_dictionary">dictionary</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> with the dictionary associated with
the input data. This is expected to be compatible with the
<span class="pkg">matchmaker</span> package and must contain the following four columns:
</p>

<dl>
<dt><code>options</code></dt><dd><p>This column contains the current values used to
represent the different groups in the input data frame (required).</p>
</dd>
<dt><code>values</code></dt><dd><p>The values that will be used to replace the current
options (required).</p>
</dd>
<dt><code>grp</code></dt><dd><p>The name of the columns where every option belongs to
(required).</p>
</dd>
<dt><code>orders</code></dt><dd><p>This defines the user-defined order of different options
(optional).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> where the target options
have been replaced with their corresponding values in the columns
specified in the data dictionary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- readRDS(
  system.file("extdata", "messy_data.RDS", package = "cleanepi")
)
dictionary &lt;- readRDS(
  system.file("extdata", "test_dict.RDS", package = "cleanepi")
)

# adding an option that is not defined in the dictionary to the 'gender'
# column
data$gender[2] &lt;- "homme"
cleaned_df &lt;- clean_using_dictionary(
  data = data,
  dictionary = dictionary
)
</code></pre>

<hr>
<h2 id='common_na_strings'>Common strings representing missing values</h2><span id='topic+common_na_strings'></span>

<h3>Description</h3>

<p>This vector contains common values of NA (missing) and is intended for
use within {cleanepi} functions <code><a href="#topic+replace_missing_values">replace_missing_values()</a></code>.
The current list of strings used can be found by printing out
<code>common_na_strings</code>. It serves as a helpful tool to explore your data
for possible missing values. However, I strongly caution against using
this to replace <code>NA</code> values without meticulously examining the
incidence for each case. Please note that <code>common_na_strings</code> utilizes
<code style="white-space: pre;">&#8288;\\&#8288;</code> around the &quot;?&quot;, &quot;.&quot;, and &quot;*&quot; characters to prevent their wildcard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_na_strings
</code></pre>


<h3>Format</h3>

<p>A vector of 35 character strings.
</p>


<h3>Source</h3>

<p>This vector is a combination of <code>naniar::common_na_strings</code>
(<a href="https://github.com/njtierney/naniar/">https://github.com/njtierney/naniar/</a>) and other strings found in the
literature.
</p>

<hr>
<h2 id='construct_misspelled_report'>Build the report for the detected misspelled values during dictionary-based
data cleaning operation</h2><span id='topic+construct_misspelled_report'></span>

<h3>Description</h3>

<p>Build the report for the detected misspelled values during dictionary-based
data cleaning operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_misspelled_report(misspelled_options, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_misspelled_report_+3A_misspelled_options">misspelled_options</code></td>
<td>
<p>A <code>&lt;list&gt;</code> with the detected misspelled values
in the columns of interest.</p>
</td></tr>
<tr><td><code id="construct_misspelled_report_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> the details about where in the input data the
misspelled values were found.
</p>

<hr>
<h2 id='convert_numeric_to_date'>Convert numeric to date</h2><span id='topic+convert_numeric_to_date'></span>

<h3>Description</h3>

<p>Convert numeric to date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_numeric_to_date(data, target_columns, ref_date, forward = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_numeric_to_date_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="convert_numeric_to_date_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of columns names to be converted from
numeric to date. When the input data is a <code>&lt;linelist&gt;</code> object, this
parameter can be set to <code>linelist_tags</code> to apply the conversion
exclusively to the tagged columns.</p>
</td></tr>
<tr><td><code id="convert_numeric_to_date_+3A_ref_date">ref_date</code></td>
<td>
<p>A <code>&lt;Date&gt;</code> value with reference date. This can also be a
character string with the name of the reference column.</p>
</td></tr>
<tr><td><code id="convert_numeric_to_date_+3A_forward">forward</code></td>
<td>
<p>A <code>&lt;logical&gt;</code> to indicate whether the counts started
after the reference date (<code>TRUE</code>) or not (<code>FALSE</code>). The default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> where the column of
interest are updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- readRDS(system.file("extdata", "test_df1.RDS", package = "cleanepi"))
data &lt;- convert_numeric_to_date(
  data = data,
  target_columns = "recruited_on_day",
  ref_date = as.Date("2022-10-13"),
  forward = TRUE
)
</code></pre>

<hr>
<h2 id='convert_to_numeric'>Convert columns into numeric</h2><span id='topic+convert_to_numeric'></span>

<h3>Description</h3>

<p>When this function is invoked without specifying the column names to be
converted, the target columns are the ones returned by the <code>scan_data()</code>
function. Furthermore, it identifies columns where the proportion of numeric
values is at least twice the percentage of character values and performs the
conversion in them. The function internally makes call of the main function
from the <span class="pkg">numberize</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_numeric(data, target_columns = NULL, lang = c("en", "fr", "es"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_numeric_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="convert_to_numeric_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of the target column names. When the
input data is a <code>&lt;linelist&gt;</code> object, this parameter can be set to
<code>linelist_tags</code> to apply the conversion exclusively to the
tagged columns. .</p>
</td></tr>
<tr><td><code id="convert_to_numeric_+3A_lang">lang</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the text's language. Currently one of
<code>"en"</code>, <code>"fr"</code>, <code>"es"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> wherein all the specified
or detected columns have been transformed into numeric format after the
conversion process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- convert_to_numeric(
  data = readRDS(
    system.file("extdata", "messy_data.RDS", package = "cleanepi")
  ),
  target_columns = "age",
  lang = "en"
)
</code></pre>

<hr>
<h2 id='correct_subject_ids'>Correct the wrong subject IDs based on the user-provided values.</h2><span id='topic+correct_subject_ids'></span>

<h3>Description</h3>

<p>After detecting incorrect subject IDs from the <code>check_subject_ids()</code>
function, use this function to provide the correct IDs and perform the
substitution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_subject_ids(data, target_columns, correction_table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_subject_ids_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="correct_subject_ids_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names with the subject ids.</p>
</td></tr>
<tr><td><code id="correct_subject_ids_+3A_correction_table">correction_table</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> with the following two columns:
</p>

<dl>
<dt>from</dt><dd><p>a column with the wrong subject IDs</p>
</dd>
<dt>to</dt><dd><p>a column with the values to be used to substitute the
incorrect ids.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset where all subject ids comply with the expected
format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># detect the incorrect subject ids
dat &lt;- check_subject_ids(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  target_columns = "study_id",
  prefix = "PS",
  suffix = "P2",
  range = c(1, 100),
  nchar = 7
)

# generate the correction table
correction_table &lt;- data.frame(
  from = c("P0005P2", "PB500P2", "PS004P2-1"),
  to = c("PB005P2", "PB050P2", "PS004P2")
)

# perform the correction
dat &lt;- correct_subject_ids(
  data = dat,
  target_columns = "study_id",
  correction_table = correction_table
)
</code></pre>

<hr>
<h2 id='date_check_outsiders'>Convert and update  date values</h2><span id='topic+date_check_outsiders'></span>

<h3>Description</h3>

<p>Convert and update  date values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_check_outsiders(data, timeframe, new_dates, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_check_outsiders_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="date_check_outsiders_+3A_timeframe">timeframe</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of 2 values of type <code>&lt;Date&gt;</code>. If
provided, date values that do not fall within this timeframe will be set
to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="date_check_outsiders_+3A_new_dates">new_dates</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of the converted date values</p>
</td></tr>
<tr><td><code id="date_check_outsiders_+3A_cols">cols</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the names of the date column to be
converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> of 2 data frames: the updated input data (if some
columns were converted to Date) and a data frame of date values that are
not within the specified timeframe.
</p>

<hr>
<h2 id='date_check_timeframe'>Check date time frame</h2><span id='topic+date_check_timeframe'></span>

<h3>Description</h3>

<p>Check date time frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_check_timeframe(first_date, last_date)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_check_timeframe_+3A_first_date">first_date</code></td>
<td>
<p>A <code>&lt;Date&gt;</code> object specifying the first valid date.
Default is fifty years before the <code>last_date</code>.
This can also be a character in ISO8601 format, i.e., &quot;2024-12-31&quot;.</p>
</td></tr>
<tr><td><code id="date_check_timeframe_+3A_last_date">last_date</code></td>
<td>
<p>A <code>&lt;Date&gt;</code> object specifying the last valid date.
Default is the current date. This can also be a character in
ISO8601 format, i.e., &quot;2024-12-31&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> with the first and last dates
</p>

<hr>
<h2 id='date_choose_first_good'>Choose the first non-missing date from a data frame of dates</h2><span id='topic+date_choose_first_good'></span>

<h3>Description</h3>

<p>Choose the first non-missing date from a data frame of dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_choose_first_good(date_a_frame, column_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_choose_first_good_+3A_date_a_frame">date_a_frame</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> where each column contains a
different parsing of the same date vector</p>
</td></tr>
<tr><td><code id="date_choose_first_good_+3A_column_name">column_name</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the target column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The chosen first <code>&lt;Date&gt;</code> value. When there other possible
values for a given date, this will be registered in the report object.
</p>

<hr>
<h2 id='date_convert'>Convert characters to dates</h2><span id='topic+date_convert'></span>

<h3>Description</h3>

<p>Convert characters to dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_convert(data, cols, error_tolerance, timeframe = NULL, orders)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_convert_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="date_convert_+3A_cols">cols</code></td>
<td>
<p>A <code>&lt;Date&gt;</code> column name(s)</p>
</td></tr>
<tr><td><code id="date_convert_+3A_error_tolerance">error_tolerance</code></td>
<td>
<p>A <code>&lt;numeric&gt;</code> between 0 and 1 indicating the
proportion of entries which cannot be identified as dates to be tolerated;
if this proportion is exceeded, the original vector is returned, and a
message is issued; defaults to 0.4 (40 percent).</p>
</td></tr>
<tr><td><code id="date_convert_+3A_timeframe">timeframe</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of 2 values of type <code>&lt;Date&gt;</code>. If
provided, date values that do not fall within this timeframe will be set
to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="date_convert_+3A_orders">orders</code></td>
<td>
<p>A <code>&lt;list&gt;</code> or <code>&lt;vector&gt;</code> of characters with the date
codes for fine-grained parsing of dates. This allows for parsing of mixed
dates. If a <code>&lt;list&gt;</code> is supplied, that <code>&lt;list&gt;</code> will be used for
successive tries in parsing. When this is not provided
(<code>orders = NULL</code>), the function will use the following order defined
in the guesser:
</p>
<div class="sourceCode"><pre>list(
  quarter_partial_dates = c("Y", "Ym", "Yq"),
  world_digit_months = c("Yq", "ymd", "ydm", "dmy", "mdy", "myd", "dym",
                         "Ymd", "Ydm", "dmY", "mdY", "mYd", "dYm"),
  world_named_months = c("dby", "dyb", "bdy", "byd", "ybd", "ydb",
                         "dbY", "dYb", "bdY", "bYd", "Ybd", "Ydb"),
  us_format = c("Omdy", "YOmd")
)
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> with the following two elements: a data frame where
the specified columns have been converted into <code>&lt;Date&gt;</code> values, a
boolean that tells whether numeric values that can also be of type
<code>&lt;Date&gt;</code> are found in the specified columns.
</p>

<hr>
<h2 id='date_detect_complex_format'>Detect complex date format</h2><span id='topic+date_detect_complex_format'></span>

<h3>Description</h3>

<p>Detect complex date format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_complex_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_detect_complex_format_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the inferred format.
</p>

<hr>
<h2 id='date_detect_day_or_month'>Detect the appropriate abbreviation for day or month value</h2><span id='topic+date_detect_day_or_month'></span>

<h3>Description</h3>

<p>Detect the appropriate abbreviation for day or month value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_day_or_month(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_detect_day_or_month_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the input string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the abbreviation used to designate the
written day or month
</p>

<hr>
<h2 id='date_detect_format'>Detect a date format with only 1 separator</h2><span id='topic+date_detect_format'></span>

<h3>Description</h3>

<p>Detect a date format with only 1 separator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_detect_format_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the identified format.
</p>

<hr>
<h2 id='date_detect_separator'>Detect the special character that is the separator in the date values</h2><span id='topic+date_detect_separator'></span>

<h3>Description</h3>

<p>Detect the special character that is the separator in the date values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_separator(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_detect_separator_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the string of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the detected separator
</p>
<p>A <code>&lt;vector&gt;</code> of the identified special characters.
</p>

<hr>
<h2 id='date_detect_simple_format'>Get format from a simple Date value</h2><span id='topic+date_detect_simple_format'></span>

<h3>Description</h3>

<p>Get format from a simple Date value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_detect_simple_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_detect_simple_format_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the date value of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the abbreviation that correspond to the
Date value
</p>

<hr>
<h2 id='date_get_format'>Infer date format from a vector or characters</h2><span id='topic+date_get_format'></span>

<h3>Description</h3>

<p>Infer date format from a vector or characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_get_format_+3A_x">x</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the inferred date format
</p>

<hr>
<h2 id='date_get_part1'>Split a string based on a pattern and return the first element of the
resulting vector.</h2><span id='topic+date_get_part1'></span>

<h3>Description</h3>

<p>Split a string based on a pattern and return the first element of the
resulting vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_part1(x, sep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_get_part1_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> or <code>&lt;Date&gt;</code> value</p>
</td></tr>
<tr><td><code id="date_get_part1_+3A_sep">sep</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the separator identified in 'x'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the first element of the vector returned
by the <code>strsplit()</code> function.
</p>

<hr>
<h2 id='date_get_part2'>Get part2 of date value</h2><span id='topic+date_get_part2'></span>

<h3>Description</h3>

<p>Get part2 of date value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_part2(x, sep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_get_part2_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> or <code>&lt;Date&gt;</code> value</p>
</td></tr>
<tr><td><code id="date_get_part2_+3A_sep">sep</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the separator identified in 'x'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the second element of the vector returned
by the <code>strsplit()</code> function.
</p>

<hr>
<h2 id='date_get_part3'>Get part3 of date value</h2><span id='topic+date_get_part3'></span>

<h3>Description</h3>

<p>Get part3 of date value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_get_part3(x, sep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_get_part3_+3A_x">x</code></td>
<td>
<p><code>&lt;character&gt;</code> or <code>&lt;Date&gt;</code> value</p>
</td></tr>
<tr><td><code id="date_get_part3_+3A_sep">sep</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the separator identified in 'x'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> with the third element of the vector returned
by the <code>strsplit()</code> function.
</p>

<hr>
<h2 id='date_guess'>Try and guess dates from a characters</h2><span id='topic+date_guess'></span>

<h3>Description</h3>

<p>Note that THIS FEATURE IS STILL EXPERIMENTAL: we strongly recommend checking
a few converted dates manually. This function tries to extract dates from a
<code>character</code> vector or a <code>factor</code>. It treats each entry independently, using
regular expressions to detect if a date is present, its format, and if
successful it converts that entry to a standard <code>Date</code> with the <em>Ymd</em> format
(e.g. <code>2018-01-21</code>). Entries which cannot be processed result in <code>NA</code>. An
error threshold can be used to define the maximum number of resulting <code>NA</code>
(i.e. entries without an identified date) that can be tolerated. If this
threshold is exceeded, the original vector is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_guess(x, column_name, quiet = TRUE, orders = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_guess_+3A_x">x</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of characters or factors</p>
</td></tr>
<tr><td><code id="date_guess_+3A_column_name">column_name</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the target column name</p>
</td></tr>
<tr><td><code id="date_guess_+3A_quiet">quiet</code></td>
<td>
<p>A <code>&lt;logical&gt;</code> indicating if messages should be displayed to
the console. Default is <code>TRUE</code>; set to <code>FALSE</code> to silence
messages</p>
</td></tr>
<tr><td><code id="date_guess_+3A_orders">orders</code></td>
<td>
<p>A <code>&lt;list&gt;</code> or <code>&lt;vector&gt;</code> of characters with the date
codes for fine-grained parsing of dates. This allows for parsing of mixed
dates. If a <code>&lt;list&gt;</code> is supplied, that <code>&lt;list&gt;</code> will be used for
successive tries in parsing. When this is not provided
(<code>orders = NULL</code>), the function will use the following order defined
in the guesser:
</p>
<div class="sourceCode"><pre>list(
  quarter_partial_dates = c("Y", "Ym", "Yq"),
  world_digit_months = c("Yq", "ymd", "ydm", "dmy", "mdy", "myd", "dym",
                         "Ymd", "Ydm", "dmY", "mdY", "mYd", "dYm"),
  world_named_months = c("dby", "dyb", "bdy", "byd", "ybd", "ydb",
                         "dbY", "dYb", "bdY", "bYd", "Ybd", "Ydb"),
  us_format = c("Omdy", "YOmd")
)
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> of following three elements: a vector of the newly
reformatted dates, a data frame with the date values that were converted
based on more than one format, and a Boolean that specifies whether
ambiguous values were found or not. If all values comply with only one
format, the second element will be NULL.
</p>

<hr>
<h2 id='date_guess_convert'>Guess if a character vector contains Date values, and convert them to date</h2><span id='topic+date_guess_convert'></span>

<h3>Description</h3>

<p>Guess if a character vector contains Date values, and convert them to date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_guess_convert(data, error_tolerance, timeframe, orders)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_guess_convert_+3A_data">data</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code></p>
</td></tr>
<tr><td><code id="date_guess_convert_+3A_error_tolerance">error_tolerance</code></td>
<td>
<p>A <code>&lt;numeric&gt;</code> between 0 and 1 indicating the
proportion of entries which cannot be identified as dates to be tolerated;
if this proportion is exceeded, the original vector is returned, and a
message is issued; defaults to 0.4 (40 percent).</p>
</td></tr>
<tr><td><code id="date_guess_convert_+3A_timeframe">timeframe</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of 2 values of type <code>&lt;Date&gt;</code>. If
provided, date values that do not fall within this timeframe will be set
to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="date_guess_convert_+3A_orders">orders</code></td>
<td>
<p>A <code>&lt;list&gt;</code> or <code>&lt;vector&gt;</code> of characters with the date
codes for fine-grained parsing of dates. This allows for parsing of mixed
dates. If a <code>&lt;list&gt;</code> is supplied, that <code>&lt;list&gt;</code> will be used for
successive tries in parsing. When this is not provided
(<code>orders = NULL</code>), the function will use the following order defined
in the guesser:
</p>
<div class="sourceCode"><pre>list(
  quarter_partial_dates = c("Y", "Ym", "Yq"),
  world_digit_months = c("Yq", "ymd", "ydm", "dmy", "mdy", "myd", "dym",
                         "Ymd", "Ydm", "dmY", "mdY", "mYd", "dYm"),
  world_named_months = c("dby", "dyb", "bdy", "byd", "ybd", "ydb",
                         "dbY", "dYb", "bdY", "bYd", "Ybd", "Ydb"),
  us_format = c("Omdy", "YOmd")
)
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> with the following two elements: the input data
frame where the character columns with date values have been converted
into <code>&lt;Date&gt;</code>, and a vector of column names where there are numeric
values that can also be of type Date.
</p>

<hr>
<h2 id='date_i_guess_and_convert'>Extract date from a character vector</h2><span id='topic+date_i_guess_and_convert'></span>

<h3>Description</h3>

<p>This function tries converting a single character string into a
well-formatted date, but still returning a character. If it can't convert
it, it returns NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_i_guess_and_convert(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_i_guess_and_convert_+3A_x">x</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the format cannot be resolved, the function returns <code>NA</code>; if
a matching format is found, it returns the <code>&lt;vector&gt;</code> of the
converted values.
</p>

<hr>
<h2 id='date_make_format'>Build the auto-detected format</h2><span id='topic+date_make_format'></span>

<h3>Description</h3>

<p>Put together the different date format characters that were identified from
the target date column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_make_format(f1, f2, f3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_make_format_+3A_f1">f1</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the first part of the inferred format</p>
</td></tr>
<tr><td><code id="date_make_format_+3A_f2">f2</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the second part of the inferred format</p>
</td></tr>
<tr><td><code id="date_make_format_+3A_f3">f3</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the third part of the inferred format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> that represents the inferred format from the
provided elements. It returns <code>&lt;NULL&gt;</code> when the format was not
resolved.
</p>

<hr>
<h2 id='date_match_format_and_column'>Check whether the number of provided formats matches the number of target
columns to be standardized.</h2><span id='topic+date_match_format_and_column'></span>

<h3>Description</h3>

<p>Check whether the number of provided formats matches the number of target
columns to be standardized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_match_format_and_column(target_columns, format)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_match_format_and_column_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names to be standardized</p>
</td></tr>
<tr><td><code id="date_match_format_and_column_+3A_format">format</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of formats to be used when standardizing the
columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;vector&gt;</code> of characters with the validated formats
</p>

<hr>
<h2 id='date_process'>Process date variable</h2><span id='topic+date_process'></span>

<h3>Description</h3>

<p>Process date variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_process(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_process_+3A_x">x</code></td>
<td>
<p>A <code>&lt;Date&gt;</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted input value into <code>&lt;Date&gt;</code> or <code>&lt;character&gt;</code>
</p>

<hr>
<h2 id='date_rescue_lubridate_failures'>Find the dates that lubridate couldn't</h2><span id='topic+date_rescue_lubridate_failures'></span>

<h3>Description</h3>

<p>Find the dates that lubridate couldn't
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_rescue_lubridate_failures(date_a_frame, original_dates, column_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_rescue_lubridate_failures_+3A_date_a_frame">date_a_frame</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> where each column contains a
different parsing of the same date vector</p>
</td></tr>
<tr><td><code id="date_rescue_lubridate_failures_+3A_original_dates">original_dates</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of original dates</p>
</td></tr>
<tr><td><code id="date_rescue_lubridate_failures_+3A_column_name">column_name</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the target column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> with the following two elements: the input data
frame where the values that do not match the proposed formats have been
converted into Date, and a boolean that informs about the presence of
ambiguous values or not.
</p>

<hr>
<h2 id='date_trim_outliers'>Trim dates outside of the defined timeframe</h2><span id='topic+date_trim_outliers'></span>

<h3>Description</h3>

<p>Trim dates outside of the defined timeframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_trim_outliers(new_dates, dmin, dmax, cols, original_dates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_trim_outliers_+3A_new_dates">new_dates</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of the new date values</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_dmin">dmin</code></td>
<td>
<p>A <code>&lt;Date&gt;</code> value with the minimum date</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_dmax">dmax</code></td>
<td>
<p>A <code>&lt;Date&gt;</code> value with the maximum date</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_cols">cols</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the name of the date column of interest</p>
</td></tr>
<tr><td><code id="date_trim_outliers_+3A_original_dates">original_dates</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of the original date values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> of 2 elements: the update input vector where date
values that are out of the specified timeframe are replaced by <code>NA</code>,
and a vector of the out of timeframe values.
</p>

<hr>
<h2 id='detect_misspelled_options'>Detect misspelled options in columns to be cleaned</h2><span id='topic+detect_misspelled_options'></span>

<h3>Description</h3>

<p>Detect misspelled options in columns to be cleaned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_misspelled_options(data, dictionary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_misspelled_options_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="detect_misspelled_options_+3A_dictionary">dictionary</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> with the dictionary associated with
the input data. This is expected to be compatible with the
<span class="pkg">matchmaker</span> package and must contain the following four columns:
</p>

<dl>
<dt><code>options</code></dt><dd><p>This column contains the current values used to
represent the different groups in the input data frame (required).</p>
</dd>
<dt><code>values</code></dt><dd><p>The values that will be used to replace the current
options (required).</p>
</dd>
<dt><code>grp</code></dt><dd><p>The name of the columns where every option belongs to
(required).</p>
</dd>
<dt><code>orders</code></dt><dd><p>This defines the user-defined order of different options
(optional).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> with the indexes of the misspelled values in every
column that needs to be cleaned.
</p>

<hr>
<h2 id='detect_to_numeric_columns'>Detect the numeric columns that appears as characters due to the presence of
some character values in the column.</h2><span id='topic+detect_to_numeric_columns'></span>

<h3>Description</h3>

<p>Detect the numeric columns that appears as characters due to the presence of
some character values in the column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_to_numeric_columns(scan_res, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_to_numeric_columns_+3A_scan_res">scan_res</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> that corresponds to the result from the
<code><a href="#topic+scan_data">scan_data</a></code> function</p>
</td></tr>
<tr><td><code id="detect_to_numeric_columns_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>&lt;vector&gt;</code> of column names to be converted into numeric
</p>

<hr>
<h2 id='dictionary_make_metadata'>Make data dictionary for 1 field</h2><span id='topic+dictionary_make_metadata'></span>

<h3>Description</h3>

<p>Make data dictionary for 1 field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dictionary_make_metadata(x, field_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dictionary_make_metadata_+3A_x">x</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of choices from the input data</p>
</td></tr>
<tr><td><code id="dictionary_make_metadata_+3A_field_column">field_column</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the name of the field where the
choices are made.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> with the dictionary in the format that is
accepted by the <span class="pkg">matchmaker</span> package.
</p>

<hr>
<h2 id='find_duplicates'>Identify and return duplicated rows in a data frame or linelist.</h2><span id='topic+find_duplicates'></span>

<h3>Description</h3>

<p>Identify and return duplicated rows in a data frame or linelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_duplicates(data, target_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_duplicates_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code>.</p>
</td></tr>
<tr><td><code id="find_duplicates_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of columns names or indices to
consider when looking for duplicates. When the input data is a
<code>&lt;linelist&gt;</code> object, this parameter can be set to
<code>linelist_tags</code> from which duplicates to be removed. Its default
value is <code>NULL</code>, which considers duplicates across all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> of all duplicated rows
with following 2 additional columns:
</p>

<dl>
<dt>row_id</dt><dd><p>The indices of the duplicated rows from the input data.
Users can choose from these indices, which row they consider as
redundant in each group of duplicates.</p>
</dd>
<dt>group_id</dt><dd><p>a unique identifier associated to each group of
duplicates.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dups &lt;- find_duplicates(
  data = readRDS(
    system.file("extdata", "test_linelist.RDS", package = "cleanepi")
  ),
  target_columns = c("dt_onset", "dt_report", "sex", "outcome")
)

</code></pre>

<hr>
<h2 id='get_default_params'>Set and return <code><a href="#topic+clean_data">clean_data</a></code> default parameters</h2><span id='topic+get_default_params'></span>

<h3>Description</h3>

<p>When <code>clean_data()</code> function is called without any argument, these
default values provided to the function's arguments will be applied on the
input data. By default, operations that require the target columns to be
specified by the user will not be performed. The default cleaning operations
include: i) standardizing column names, ii) detecting and removing
duplicates, and iii) removing constant data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_default_params()
</code></pre>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> of the default cleaning parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default_params &lt;- get_default_params()

</code></pre>

<hr>
<h2 id='get_target_column_names'>Get the names of the columns from which duplicates will be found</h2><span id='topic+get_target_column_names'></span>

<h3>Description</h3>

<p>Get the names of the columns from which duplicates will be found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target_column_names(data, target_columns, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_target_column_names_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="get_target_column_names_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names. For
<code>&lt;linelist&gt;</code> data, this can be set to <code>linelist_tags</code></p>
</td></tr>
<tr><td><code id="get_target_column_names_+3A_cols">cols</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of empty and constant columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;vector&gt;</code> with the target column names or indexes
</p>

<hr>
<h2 id='is_date_sequence_ordered'>Check order of a sequence of date-events</h2><span id='topic+is_date_sequence_ordered'></span>

<h3>Description</h3>

<p>Check order of a sequence of date-events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_date_sequence_ordered(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_date_sequence_ordered_+3A_x">x</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of <code>&lt;Date&gt;</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if elements of the vector are ordered, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='make_unique_column_names'>Make column names unique when duplicated column names are found after the
transformation</h2><span id='topic+make_unique_column_names'></span>

<h3>Description</h3>

<p>Make column names unique when duplicated column names are found after the
transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_unique_column_names(after, kept, before, rename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_unique_column_names_+3A_after">after</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> with the transformed column names</p>
</td></tr>
<tr><td><code id="make_unique_column_names_+3A_kept">kept</code></td>
<td>
<p>A <code>&lt;logical&gt;</code> vector where column names to keep are set to
TRUE</p>
</td></tr>
<tr><td><code id="make_unique_column_names_+3A_before">before</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> with the initial column names</p>
</td></tr>
<tr><td><code id="make_unique_column_names_+3A_rename">rename</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> with the indices of the column names to be
renamed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjusted <code>&lt;vector&gt;</code> if there were duplicated names introduced
due to the transformation
</p>

<hr>
<h2 id='modify_default_params'>Update <code><a href="#topic+clean_data">clean_data</a></code> default argument's values with the
user-provided values.</h2><span id='topic+modify_default_params'></span>

<h3>Description</h3>

<p>Update <code><a href="#topic+clean_data">clean_data</a></code> default argument's values with the
user-provided values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_default_params(defaults, params, strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_default_params_+3A_defaults">defaults</code></td>
<td>
<p>A <code>&lt;list&gt;</code> with the default arguments</p>
</td></tr>
<tr><td><code id="modify_default_params_+3A_params">params</code></td>
<td>
<p>A <code>&lt;list&gt;</code> with the user-specified arguments</p>
</td></tr>
<tr><td><code id="modify_default_params_+3A_strict">strict</code></td>
<td>
<p>A <code>&lt;logical&gt;</code> that specified whether to trigger an error
or not when there is a difference between the list of default arguments
and list of the arguments provided by the user. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>&lt;list&gt;</code> of parameters that will be used to perform
the data cleaning.
</p>

<hr>
<h2 id='numbers_only'>Detects whether a string contains only numbers or not.</h2><span id='topic+numbers_only'></span>

<h3>Description</h3>

<p>Detects whether a string contains only numbers or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numbers_only(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numbers_only_+3A_x">x</code></td>
<td>
<p>A <code>&lt;character&gt;</code> value</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the string only contains numbers, <code>FALSE</code>
otherwise
</p>

<hr>
<h2 id='perform_remove_constants'>Remove constant data.</h2><span id='topic+perform_remove_constants'></span>

<h3>Description</h3>

<p>This function is called at each iteration of the constant data removal
process until no constant data remains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform_remove_constants(data, cutoff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perform_remove_constants_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="perform_remove_constants_+3A_cutoff">cutoff</code></td>
<td>
<p>A <code>&lt;numeric&gt;</code> value specifying the cut-off for removing
empty rows and columns. If provided, only rows and columns with a
percentage of missing data greater than this cut-off will be removed.
The default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;list&gt;</code> with the input dataset where all empty rows and
columns as well as constant columns have been removed.
</p>

<hr>
<h2 id='print_misspelled_values'>Print the detected misspelled values</h2><span id='topic+print_misspelled_values'></span>

<h3>Description</h3>

<p>Print the detected misspelled values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_misspelled_values(data, misspelled_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_misspelled_values_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="print_misspelled_values_+3A_misspelled_options">misspelled_options</code></td>
<td>
<p>A <code>&lt;list&gt;</code> with the misspelled values found in
the different columns of the input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the misspelled values from the column of interest
</p>

<hr>
<h2 id='print_report'>Generate report from data cleaning operations</h2><span id='topic+print_report'></span>

<h3>Description</h3>

<p>Generate report from data cleaning operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_report(
  data,
  report_title = "{cleanepi} data cleaning report",
  output_file_name = NULL,
  format = "html",
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_report_+3A_data">data</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> object returned from
the <code><a href="#topic+clean_data">clean_data</a></code> or the main functions of each data cleaning
module.</p>
</td></tr>
<tr><td><code id="print_report_+3A_report_title">report_title</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the title that will appear on
the report</p>
</td></tr>
<tr><td><code id="print_report_+3A_output_file_name">output_file_name</code></td>
<td>
<p>A <code>&lt;character&gt;</code> used to specify the name of the
report file, excluding any file extension. If no file name is supplied,
one will be automatically generated with the format
<code>cleanepi_report_YYMMDD_HHMMSS</code>.</p>
</td></tr>
<tr><td><code id="print_report_+3A_format">format</code></td>
<td>
<p>A <code>&lt;character&gt;</code> with the file format of the report.
Currently only <code>"html"</code> is supported.</p>
</td></tr>
<tr><td><code id="print_report_+3A_print">print</code></td>
<td>
<p>A <code>&lt;logical&gt;</code> that specifies whether to print the generated
HTML file or no. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;character&gt;</code> containing the name and path of the saved
report
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))
test_dictionary &lt;- readRDS(
  system.file("extdata", "test_dictionary.RDS", package = "cleanepi")
)

# scan through the data
scan_res &lt;- scan_data(data)

# Perform data cleaning
cleaned_data &lt;- data %&gt;%
 standardize_column_names(keep = NULL, rename = c("DOB" = "dateOfBirth")) %&gt;%
 replace_missing_values(target_columns = NULL, na_strings = "-99") %&gt;%
 remove_constants(cutoff = 1.0) %&gt;%
 remove_duplicates(target_columns = NULL) %&gt;%
 standardize_dates(
   target_columns = NULL,
   error_tolerance = 0.4,
   format = NULL,
   timeframe = as.Date(c("1973-05-29", "2023-05-29"))
 ) %&gt;%
 check_subject_ids(
   target_columns = "study_id",
   prefix = "PS",
   suffix = "P2",
   range = c(1L, 100L),
   nchar = 7L
 ) %&gt;%
 convert_to_numeric(target_columns = "sex", lang = "en") %&gt;%
 clean_using_dictionary(dictionary = test_dictionary)

# add the data scanning result to the report
cleaned_data &lt;- add_to_report(
  x = cleaned_data,
  key = "scanning_result",
  value = scan_res
)

# save a report in the current directory using the previously-created objects
print_report(
  data = cleaned_data,
  report_title = "{cleanepi} data cleaning report",
  output_file_name = NULL,
  format = "html",
  print = TRUE
)


</code></pre>

<hr>
<h2 id='remove_constants'>Remove constant data, including empty rows, empty columns, and
columns with constant values.</h2><span id='topic+remove_constants'></span>

<h3>Description</h3>

<p>The function iteratively removes constant data until none remain.
It records details of the removed constant data as a data frame
within the report object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_constants(data, cutoff = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_constants_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="remove_constants_+3A_cutoff">cutoff</code></td>
<td>
<p>A <code>&lt;numeric&gt;</code> value specifying the cut-off for removing
empty rows and columns. If provided, only rows and columns with a
percentage of missing data greater than this cut-off will be removed.
The default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with empty rows, empty columns, and constant
columns removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))

# introduce an empty column
data$empty_column &lt;- NA
# inject some missing values across some columns
data$study_id[3] = NA_character_
data$date.of.admission[3] = NA_character_
data$date.of.admission[4] = NA_character_
data$dateOfBirth[3] = NA_character_
data$dateOfBirth[4] = NA_character_
data$dateOfBirth[5] = NA_character_

# with cutoff = 1, line 3, 4, and 5 are not removed
test &lt;- remove_constants(
  data = data,
  cutoff = 1
)

# drop rows or columns with a percentage of constant values
# equal to or more than 50%
test &lt;- remove_constants(
  data = test,
  cutoff = 0.5
)

# drop rows or columns with a percentage of constant values
# equal to or more than 25%
test &lt;- remove_constants(
  data = test,
  cutoff = 0.25
)

# drop rows or columns with a percentage of constant values
# equal to or more than 15%
test &lt;- remove_constants(
  data = test,
  cutoff = 0.15
)

# check the report to see what has happened
report &lt;- attr(test, "report")
report$constant_data
</code></pre>

<hr>
<h2 id='remove_duplicates'>Remove duplicates</h2><span id='topic+remove_duplicates'></span>

<h3>Description</h3>

<p>When removing duplicates, users can specify a set columns to consider with
the <code>target_columns</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_duplicates(data, target_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_duplicates_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code>.</p>
</td></tr>
<tr><td><code id="remove_duplicates_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names to use when looking
for duplicates. When the input data is a <code>linelist</code> object, this
parameter can be set to <code>linelist_tags</code> if you wish to look for
duplicates on tagged columns only. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> without the
duplicated rows identified from all or the specified columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>no_dups &lt;- remove_duplicates(
  data = readRDS(
    system.file("extdata", "test_linelist.RDS", package = "cleanepi")
  ),
  target_columns = "linelist_tags"
)


</code></pre>

<hr>
<h2 id='replace_missing_values'>Replace missing values with <code>NA</code></h2><span id='topic+replace_missing_values'></span>

<h3>Description</h3>

<p>Replace missing values with <code>NA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_missing_values(
  data,
  target_columns = NULL,
  na_strings = cleanepi::common_na_strings
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_missing_values_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="replace_missing_values_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names. If provided, missing
values will be substituted only in the specified columns. When the input
data is a <code>&lt;linelist&gt;</code> object, this parameter can be set to
<code>linelist_tags</code> to replace missing values with <code>NA</code> in the
tagged columns only.</p>
</td></tr>
<tr><td><code id="replace_missing_values_+3A_na_strings">na_strings</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of characters that represent the missing
values in the columns of interest. By default, it utilizes
<code>cleanepi::common_na_strings</code>. However, if the missing values string
in the columns of interest is not included in this predefined vector,
it can be used as the value for this argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data where missing values are replaced by <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cleaned_data &lt;- replace_missing_values(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  target_columns = "sex",
  na_strings = "-99"
)

</code></pre>

<hr>
<h2 id='replace_with_na'>Detect and replace values with <code>NA</code> from a vector</h2><span id='topic+replace_with_na'></span>

<h3>Description</h3>

<p>Detect and replace values with <code>NA</code> from a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_with_na(x, na_strings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_with_na_+3A_x">x</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of numeric or character values</p>
</td></tr>
<tr><td><code id="replace_with_na_+3A_na_strings">na_strings</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of the values to be replaced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;vector&gt;</code> where the specified values were replaced with
<code>NA</code> if found.
</p>

<hr>
<h2 id='retrieve_column_names'>Get column names</h2><span id='topic+retrieve_column_names'></span>

<h3>Description</h3>

<p>When performing several data cleaning operations using the
<code>clean_data()</code> function, the input column names might be altered by
after the column names cleaning. As a consequence of this, some cleaning
operations will fail due to the column names mismatch. This function is
provided to anticipate on this scenario, hence providing continuity between
the cleaning operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve_column_names(data, target_columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retrieve_column_names_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="retrieve_column_names_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names. For
<code>&lt;linelist&gt;</code> data, this can be set to <code>linelist_tags</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;vector&gt;</code> of column names to be used for the target cleaning
operations
</p>

<hr>
<h2 id='scan_data'>Scan through a data frame and return the proportion of <code>missing</code>, <code>numeric</code>,
<code>Date</code>, <code>character</code>, <code>logical</code> values.</h2><span id='topic+scan_data'></span>

<h3>Description</h3>

<p>The function checks for the existence of character columns in the data. When
found, it reports back the proportion of the data types mentioned above in
those columns. See the details section to know more about how it works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_data(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan_data_+3A_data">data</code></td>
<td>
<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>How does it work?
The <code>&lt;character&gt;</code> columns are identified first. If no <code>&lt;character&gt;</code>
columns are found, the function returns a message.
</p>
<p>For each <code>&lt;character&gt;</code> column, the function counts:
</p>

<ol>
<li><p> The number of missing values (<code>NA</code>).
</p>
</li>
<li><p> The number of numeric values. A process is initiated to detect valid dates
among these numeric values using <code>lubridate::as_date()</code> and
<code>date_guess()</code> functions. If valid dates are found, a warning is
triggered to alert about ambiguous numeric values potentially representing
dates. <strong>Note:</strong> A date is considered valid if it falls within the range
from today's date to 50 years in the past.
</p>
</li>
<li><p> The detection of <code>&lt;Date&gt;</code> values from non-numeric data using the
<code>date_guess()</code> function. The total date count includes dates
from today's from both numeric and non-numeric values. Due to overlap, the
sum of counts across rows in the scanning result may exceed 1.
</p>
</li>
<li><p> The count of <code>&lt;logical&gt;</code> values.
</p>
</li></ol>

<p>Remaining values are categorized as <code>&lt;character&gt;</code>.
</p>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> if the input data contains columns of type
character. It invisibly returns <code>NA</code> otherwise. The returned data
frame will have the same number of rows as the number of character
columns, and six columns representing their column names, proportion of
missing, numeric, date, character, and logical values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># scan through a data frame of characters
scan_result &lt;- scan_data(
  data = readRDS(
    system.file("extdata", "messy_data.RDS", package = "cleanepi")
  )
)

# scan through a data frame with two character columns
scan_result &lt;- scan_data(
  data = readRDS(system.file("extdata", "test_linelist.RDS",
                             package = "cleanepi"))
)

# scan through a data frame with no character columns
data(iris)
iris[["fct"]] &lt;- as.factor(sample(c("gray", "orange"), nrow(iris),
                           replace = TRUE))
iris[["lgl"]] &lt;- sample(c(TRUE, FALSE), nrow(iris), replace = TRUE)
iris[["date"]] &lt;- as.Date(seq.Date(from = as.Date("2024-01-01"),
                                   to = as.Date("2024-08-30"),
                                   length.out = nrow(iris)))
iris[["posit_ct"]] &lt;- as.POSIXct(iris[["date"]])
scan_result &lt;- scan_data(data = iris)

</code></pre>

<hr>
<h2 id='scan_in_character'>Scan through a character column</h2><span id='topic+scan_in_character'></span>

<h3>Description</h3>

<p>Scan through a character column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_in_character(x, x_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan_in_character_+3A_x">x</code></td>
<td>
<p>The input <code>&lt;vector&gt;</code> of characters</p>
</td></tr>
<tr><td><code id="scan_in_character_+3A_x_name">x_name</code></td>
<td>
<p>The name of the corresponding column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;vector&gt;</code> of <code>&lt;numeric&gt;</code> with the proportion of the
different types of data that were detected within the input vector.
</p>

<hr>
<h2 id='standardize_column_names'>Standardize column names of a data frame or line list</h2><span id='topic+standardize_column_names'></span>

<h3>Description</h3>

<p>All columns names will be reformatted to  snake_case. When the
conversion to snakecase does not work as expected, use the <code>keep</code> and/or
<code>rename</code> arguments to reformat the column name properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_column_names(data, keep = NULL, rename = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_column_names_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code>.</p>
</td></tr>
<tr><td><code id="standardize_column_names_+3A_keep">keep</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of column names to maintain as they are. When
dealing with a <code>&lt;linelist&gt;</code>, this can be set to <code>linelist_tags</code>,
to maintain the tagged column names. The Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="standardize_column_names_+3A_rename">rename</code></td>
<td>
<p>A named <code>&lt;vector&gt;</code> of column names to be renamed. This
should be in the form of
<code>c(new_name1 = "old_name1", new_name2 = "old_name2")</code> for example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code> with easy to work with
column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do not rename 'date.of.admission'
cleaned_data &lt;- standardize_column_names(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  keep = "date.of.admission"
)

# do not rename 'date.of.admission', but rename 'dateOfBirth' and 'sex' to
# 'DOB' and 'gender' respectively
cleaned_data &lt;- standardize_column_names(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  keep = "date.of.admission",
  rename = c(DOB = "dateOfBirth", gender = "sex")
)

</code></pre>

<hr>
<h2 id='standardize_dates'>Standardize date variables</h2><span id='topic+standardize_dates'></span>

<h3>Description</h3>

<p>When the format of the values in a column and/or the target columns are not
defined, we strongly recommend checking a few converted dates manually to
make sure that the dates extracted from a <code>character</code> vector or a <code>factor</code>
are correct.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_dates(
  data,
  target_columns = NULL,
  format = NULL,
  timeframe = NULL,
  error_tolerance = 0.4,
  orders = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_dates_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_target_columns">target_columns</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of the target date column names. When
the input data is a <code>&lt;linelist&gt;</code> object, this parameter can be set to
<code>linelist_tags</code> if you wish to standardize the date columns across
tagged columns only. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_format">format</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of the expected formats in the date values
from the date columns. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_timeframe">timeframe</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of 2 values of type <code>&lt;Date&gt;</code>. If
provided, date values that do not fall within this timeframe will be set
to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_error_tolerance">error_tolerance</code></td>
<td>
<p>A <code>&lt;numeric&gt;</code> between 0 and 1 indicating the
proportion of entries which cannot be identified as dates to be tolerated;
if this proportion is exceeded, the original vector is returned, and a
message is issued; defaults to 0.4 (40 percent).</p>
</td></tr>
<tr><td><code id="standardize_dates_+3A_orders">orders</code></td>
<td>
<p>A <code>&lt;list&gt;</code> or <code>&lt;vector&gt;</code> of characters with the date
codes for fine-grained parsing of dates. This allows for parsing of mixed
dates. If a <code>&lt;list&gt;</code> is supplied, that <code>&lt;list&gt;</code> will be used for
successive tries in parsing. When this is not provided
(<code>orders = NULL</code>), the function will use the following order defined
in the guesser:
</p>
<div class="sourceCode"><pre>list(
  quarter_partial_dates = c("Y", "Ym", "Yq"),
  world_digit_months = c("Yq", "ymd", "ydm", "dmy", "mdy", "myd", "dym",
                         "Ymd", "Ydm", "dmY", "mdY", "mYd", "dYm"),
  world_named_months = c("dby", "dyb", "bdy", "byd", "ybd", "ydb",
                         "dbY", "dYb", "bdY", "bYd", "Ybd", "Ydb"),
  us_format = c("Omdy", "YOmd")
)
</pre></div></td></tr>
</table>


<h3>Details</h3>

<p>Check for the presence of date values that could have multiple formats
from the <code>$multi_format_dates</code> element of the <code>report</code>.<br />
</p>
<p>Converting ambiguous character strings to dates is difficult for
many reasons:
</p>

<ul>
<li><p> dates may not use the standard Ymd format
</p>
</li>
<li><p> within the same variable, dates may follow different formats
</p>
</li>
<li><p> dates may be mixed with things that are not dates
</p>
</li>
<li><p> the behavior of <code>as.Date</code> in the presence of non-date is hard to predict,
sometimes returning <code>NA</code>, sometimes issuing an error.
</p>
</li></ul>

<p>This function tries to address all the above issues. Dates with the following
format should be automatically detected, irrespective of separators
(e.g. &quot;-&quot;, &quot; &quot;, &quot;/&quot;) and surrounding text:
</p>

<ul>
<li><p> &quot;19 09 2018&quot;
</p>
</li>
<li><p> &quot;2018 09 19&quot;
</p>
</li>
<li><p> &quot;19 Sep 2018&quot;
</p>
</li>
<li><p> &quot;2018 Sep 19&quot;
</p>
</li>
<li><p> &quot;Sep 19 2018&quot;
</p>
</li></ul>



<h4>How it works</h4>

<p>This function relies heavily on <code><a href="lubridate.html#topic+parse_date_time">lubridate::parse_date_time()</a></code>, which is an
extremely flexible date parser that works well for consistent date formats,
but can quickly become unwieldy and may produce spurious results.
<code>standardize_dates()</code> will use a list of formats in the <code>orders</code> argument to
run <code>parse_date_time()</code> with each format vector separately and take the first
correctly parsed date from all the trials.
</p>
<p>With the default orders shown above, the dates 03 Jan 2018, 07/03/1982, and
08/20/85 are correctly interpreted as 2018-01-03, 1982-03-07, and 1985-08-20.
The examples section will show how you can manipulate the <code>orders</code> to be
customized for your situation.
</p>



<h3>Value</h3>

<p>The input dataset where the date columns have been standardized. The
date values that are out of the specified timeframe will be reported in
the report. Similarly, date values that comply with multiple formats will
also be featured in the report object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("03 Jan 2018", "07/03/1982", "08/20/85")
# The below will coerce values where the month is written in letters only
# into Date.
as.Date(lubridate::parse_date_time(x, orders = c("Ybd", "dby")))

# coerce values where the month is written in letters or numbers into Date.
as.Date(lubridate::parse_date_time(x, orders = c("dmy", "Ymd")))

# How to use standardize_dates()
dat &lt;- standardize_dates(
  data = readRDS(
    system.file("extdata", "test_df.RDS", package = "cleanepi")
  ),
  target_columns = "date_first_pcr_positive_test",
  format = NULL,
  timeframe = NULL,
  error_tolerance = 0.4,
  orders = list(
    world_named_months = c("Ybd", "dby"),
    world_digit_months = c("dmy", "Ymd"),
    US_format = c("Omdy", "YOmd")
  )
)
</code></pre>

<hr>
<h2 id='timespan'>Calculate time span between dates</h2><span id='topic+timespan'></span>

<h3>Description</h3>

<p>Calculate time span between dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timespan(
  data,
  target_column = NULL,
  end_date = Sys.Date(),
  span_unit = c("years", "months", "weeks", "days"),
  span_column_name = "span",
  span_remainder_unit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timespan_+3A_data">data</code></td>
<td>
<p>The input <code>&lt;data.frame&gt;</code> or <code>&lt;linelist&gt;</code></p>
</td></tr>
<tr><td><code id="timespan_+3A_target_column">target_column</code></td>
<td>
<p>A <code>&lt;vector&gt;</code> of character used to specify the name
of the date column of interest. The values in this column should be of
type <code>&lt;Date&gt;</code> in ISO8601 format, e.g., 2024-01-31.</p>
</td></tr>
<tr><td><code id="timespan_+3A_end_date">end_date</code></td>
<td>
<p>The end date. It can be either a <code>&lt;character&gt;</code> that is
the name of another column of type <code>&lt;Date&gt;</code> from the input data or a
<code>&lt;vector&gt;</code> of Dates or a single <code>&lt;Date&gt;</code> value. This should also
be in the ISO8601 format, e.g., 2024-01-31. Default is today's date
<code>Sys.Date()</code>.</p>
</td></tr>
<tr><td><code id="timespan_+3A_span_unit">span_unit</code></td>
<td>
<p>A <code>&lt;character&gt;</code> that specifies the units in which the
time span between the dates will be returned. The possible units are:
'years', 'months', 'weeks' or 'days'.</p>
</td></tr>
<tr><td><code id="timespan_+3A_span_column_name">span_column_name</code></td>
<td>
<p>A <code>&lt;character&gt;</code> that specifies the name of the
new column to be used to store the calculated time span in the input data
frame.</p>
</td></tr>
<tr><td><code id="timespan_+3A_span_remainder_unit">span_remainder_unit</code></td>
<td>
<p>A <code>&lt;character&gt;</code> that specifies the unit in
which the remainder of the time span should be calculated. May be one of
&quot;months&quot;, &quot;weeks&quot;, and &quot;days&quot;. Remainders requested in the same unit as
the age will return values of 0. Default is <code>NULL</code> for decimal
time span.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>&lt;data.frame&gt;</code> with one or two additional columns:
</p>

<dl>
<dt>span</dt><dd><p>or any other name chosen by the user. This will contain the
calculated time span in the desired units.</p>
</dd>
<dt>&quot;*_remainder&quot;</dt><dd><p>a column with the number of the remaining
days or weeks or months depending on the value of the
'span_remainder_unit' parameter. The star represents here the value
of the 'span_column_name' argument.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># In the below example, this function is used to calculate patient's age from
# their dates of birth

# import the data, replace missing values with NA and convert date into ISO
# format
data &lt;- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))
data &lt;- data %&gt;%
  replace_missing_values(target_columns = "dateOfBirth",
                         na_strings = "-99") %&gt;%
  standardize_dates(target_columns = "dateOfBirth",
                    error_tolerance = 0.0)

# calculate the age in 'years' and return the remainder in 'months'
age &lt;- timespan(
  data = data,
  target_column = "dateOfBirth",
  end_date = Sys.Date(),
  span_unit = "years",
  span_column_name = "age_in_years",
  span_remainder_unit = "months"
)
</code></pre>

<hr>
<h2 id='tr_'>Flag out what message will be translated using the <span class="pkg">potools</span> package</h2><span id='topic+tr_'></span>

<h3>Description</h3>

<p>Flag out what message will be translated using the <span class="pkg">potools</span> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr_(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tr__+3A_...">...</code></td>
<td>
<p>A character string. This represents the message to be translated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was copied from the <code style="white-space: pre;">&#8288;Translation for package developers&#8288;</code>
vignette of the <span class="pkg">potools</span> package.
</p>


<h3>Value</h3>

<p>The input object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
